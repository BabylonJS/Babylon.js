import type {
    FrameGraph,
    FrameGraphTextureHandle,
    DrawWrapper,
    FrameGraphRenderPass,
    FrameGraphRenderContext,
    EffectWrapper,
    IViewportLike,
    Nullable,
    IStencilStateProperties,
} from "core/index";
import { Constants } from "core/Engines/constants";
import { FrameGraphTask } from "../../frameGraphTask";

/**
 * Task which applies a post process.
 */
export class FrameGraphPostProcessTask extends FrameGraphTask {
    /**
     * The source texture to apply the post process on.
     * It's allowed to be undefined if the post process does not require a source texture.
     * In that case, targetTexture must be provided.
     */
    public sourceTexture?: FrameGraphTextureHandle;

    /**
     * The sampling mode to use for the source texture.
     */
    public sourceSamplingMode = Constants.TEXTURE_BILINEAR_SAMPLINGMODE;

    /**
     * The target texture to render the post process to.
     * If not supplied, a texture with the same configuration as the source texture will be created.
     */
    public targetTexture?: FrameGraphTextureHandle;

    /**
     * The stencil state to use for the post process (optional).
     */
    public stencilState?: IStencilStateProperties;

    /**
     * The depth attachment texture to use for the post process (optional).
     * Note that a post-process task never writes to the depth buffer: attaching a depth texture is only useful if you want to test against the depth/stencil aspect or write to the stencil buffer.
     */
    public depthAttachmentTexture?: FrameGraphTextureHandle;

    /**
     * If true, the depth attachment will be read-only.
     * This means that the post process will not write to the depth buffer.
     * Setting depthReadOnly and stencilReadOnly to true is useful when you want to also be able to bind this same depth/stencil attachment to a shader.
     * Note that it will only work in WebGPU, as WebGL does not support read-only depth/stencil attachments.
     */
    public depthReadOnly = false;

    /**
     * If true, the stencil attachment will be read-only.
     * This means that the post process will not write to the stencil buffer.
     * Setting depthReadOnly and stencilReadOnly to true is useful when you want to also be able to bind this same depth/stencil attachment to a shader.
     * Note that it will only work in WebGPU, as WebGL does not support read-only depth/stencil attachments.
     */
    public stencilReadOnly = false;

    /**
     * If true, color write will be disabled when applying the post process.
     * This means that the post process will not write to the color buffer.
     */
    public disableColorWrite = false;

    /**
     * If true, the post process will be generated by a back face full-screen quad (CW order).
     */
    public drawBackFace = false;

    /**
     * If depth testing should be enabled (default is true).
     */
    public depthTest = true;

    /**
     * The alpha mode to use when applying the post process (default is ALPHA_DISABLE).
     */
    public get alphaMode(): number {
        return this.postProcess.alphaMode;
    }

    public set alphaMode(value: number) {
        this.postProcess.alphaMode = value;
    }

    /**
     * The viewport to use when applying the post process.
     * If set to null, the currently active viewport is used.
     * If undefined (default), the viewport is reset to a full screen viewport before applying the post process.
     */
    public viewport?: Nullable<IViewportLike>;

    /**
     * The output texture of the post process.
     */
    public readonly outputTexture: FrameGraphTextureHandle;

    /**
     * The output depth attachment texture.
     * This texture will point to the same texture than the depthAttachmentTexture property if it is set.
     * Note, however, that the handle itself will be different!
     */
    public readonly outputDepthAttachmentTexture: FrameGraphTextureHandle;

    /**
     * The post process to apply.
     */
    public readonly postProcess: EffectWrapper;

    /**
     * The draw wrapper used by the post process
     */
    public get drawWrapper() {
        return this._postProcessDrawWrapper;
    }

    protected readonly _postProcessDrawWrapper: DrawWrapper;
    protected _sourceWidth: number;
    protected _sourceHeight: number;
    protected _outputWidth: number;
    protected _outputHeight: number;

    /**
     * Constructs a new post process task.
     * @param name Name of the task.
     * @param frameGraph The frame graph this task is associated with.
     * @param postProcess The post process to apply.
     */
    constructor(name: string, frameGraph: FrameGraph, postProcess: EffectWrapper) {
        super(name, frameGraph);

        this.postProcess = postProcess;
        this._postProcessDrawWrapper = this.postProcess.drawWrapper;

        this.outputTexture = this._frameGraph.textureManager.createDanglingHandle();
        this.outputDepthAttachmentTexture = this._frameGraph.textureManager.createDanglingHandle();
    }

    public override isReady() {
        return this.postProcess.isReady();
    }

    public override getClassName(): string {
        return "FrameGraphPostProcessTask";
    }

    public record(
        skipCreationOfDisabledPasses = false,
        additionalExecute?: (context: FrameGraphRenderContext) => void,
        additionalBindings?: (context: FrameGraphRenderContext) => void
    ): FrameGraphRenderPass {
        if (this.sourceTexture === undefined && this.targetTexture === undefined) {
            throw new Error(`FrameGraphPostProcessTask "${this.name}": sourceTexture or targetTexture is required`);
        }

        const sourceTextureCreationOptions = this.sourceTexture !== undefined ? this._frameGraph.textureManager.getTextureCreationOptions(this.sourceTexture) : undefined;
        if (sourceTextureCreationOptions) {
            sourceTextureCreationOptions.options.samples = 1;
        }

        this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture, this.targetTexture, this.name, sourceTextureCreationOptions);
        if (this.depthAttachmentTexture !== undefined) {
            this._frameGraph.textureManager.resolveDanglingHandle(this.outputDepthAttachmentTexture, this.depthAttachmentTexture);
        }

        if (sourceTextureCreationOptions) {
            const sourceSize = this._frameGraph.textureManager.getTextureAbsoluteDimensions(sourceTextureCreationOptions);

            this._sourceWidth = sourceSize.width;
            this._sourceHeight = sourceSize.height;
        }

        const outputTextureDescription = this._frameGraph.textureManager.getTextureDescription(this.outputTexture);

        this._outputWidth = outputTextureDescription.size.width;
        this._outputHeight = outputTextureDescription.size.height;

        const pass = this._frameGraph.addRenderPass(this.name);

        pass.depthReadOnly = this.depthReadOnly;
        pass.stencilReadOnly = this.stencilReadOnly;

        pass.addDependencies(this.sourceTexture);

        pass.setRenderTarget(this.outputTexture);
        pass.setRenderTargetDepth(this.depthAttachmentTexture);
        pass.setExecuteFunc((context) => {
            context.pushDebugGroup(`Apply post-process (${this.name})`);
            if (this.sourceTexture !== undefined) {
                context.setTextureSamplingMode(this.sourceTexture, this.sourceSamplingMode);
            }
            additionalExecute?.(context);
            if (this.viewport) {
                context.setViewport(this.viewport);
            }
            context.applyFullScreenEffect(
                this._postProcessDrawWrapper,
                () => {
                    if (this.sourceTexture !== undefined) {
                        context.bindTextureHandle(this._postProcessDrawWrapper.effect!, "textureSampler", this.sourceTexture);
                    }
                    additionalBindings?.(context);
                    this.postProcess.bind();
                },
                this.stencilState,
                this.disableColorWrite,
                this.drawBackFace,
                this.depthTest,
                this.viewport !== undefined
            );
            context.restoreDefaultFramebuffer();
            context.popDebugGroup();
        });

        if (!skipCreationOfDisabledPasses) {
            const passDisabled = this._frameGraph.addRenderPass(this.name + "_disabled", true);

            passDisabled.depthReadOnly = this.depthReadOnly;
            passDisabled.stencilReadOnly = this.stencilReadOnly;

            passDisabled.addDependencies(this.sourceTexture);

            passDisabled.setRenderTarget(this.outputTexture);
            passDisabled.setRenderTargetDepth(this.depthAttachmentTexture);
            passDisabled.setExecuteFunc((context) => {
                if (this.sourceTexture !== undefined) {
                    if (this.viewport) {
                        context.setViewport(this.viewport);
                    }
                    context.copyTexture(this.sourceTexture, undefined, this.viewport !== undefined);
                }
            });
        }

        return pass;
    }

    public override dispose(): void {
        this.postProcess.dispose();
        super.dispose();
    }
}
