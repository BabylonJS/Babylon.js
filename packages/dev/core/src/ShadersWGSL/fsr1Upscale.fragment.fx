#include<ffxFunctions>

struct FsrEasuCon {
    con0: vec4u,
    con1: vec4u,
    con2: vec4u,
    con3: vec4u,
}

var textureSampler: texture_2d<f32>;
var textureSamplerSampler: sampler;
var<uniform> constants: FsrEasuCon;

// Input callback prototypes
fn FsrEasuRF(p: vec2f) -> vec4f {
    return textureGather(0, textureSampler, textureSamplerSampler, p);
}

fn FsrEasuGF(p: vec2f) -> vec4f {
    return textureGather(1, textureSampler, textureSamplerSampler, p);
}

fn FsrEasuBF(p: vec2f) -> vec4f {
    return textureGather(2, textureSampler, textureSamplerSampler, p);
}

// Filtering for a given tap for the scalar.
fn FsrEasuTapF(
    aC: ptr<function, vec3f>, // Accumulated color, with negative lobe.
    aW: ptr<function, f32>, // Accumulated weight.
    off: vec2f, // Pixel offset from resolve position to tap.
    dir: vec2f, // Gradient direction.
    len: vec2f, // Length.
    lob: f32, // Negative lobe strength.
    clp: f32, // Clipping point.
    c: vec3f // Tap color.
) { 
    // Rotate offset by direction.
    var v: vec2f;
    v.x=(off.x*( dir.x))+(off.y*dir.y);
    v.y=(off.x*(-dir.y))+(off.y*dir.x);
    // Anisotropy.
    v*=len;
    // Compute distance^2.
    var d2=v.x*v.x+v.y*v.y;
    // Limit to the window as at corner, 2 taps can easily be outside.
    d2=min(d2,clp);
    // Approximation of lancos2 without sin() or rcp(), or sqrt() to get x.
    //  (25/16 * (2/5 * x^2 - 1)^2 - (25/16 - 1)) * (1/4 * x^2 - 1)^2
    //  |_______________________________________|   |_______________|
    //                   base                             window
    // The general form of the 'base' is,
    //  (a*(b*x^2-1)^2-(a-1))
    // Where 'a=1/(2*b-b^2)' and 'b' moves around the negative lobe.
    var wB=f32(2.0/5.0)*d2+f32(-1.0);
    var wA=lob*d2+(-1.0);
    wB*=wB;
    wA*=wA;
    wB=f32(25.0/16.0)*wB+f32(-(25.0/16.0-1.0));
    let w=wB*wA;
    // Do weighted average.
    *aC+=c*w;*aW+=w;
}

// Accumulate direction and length.
fn FsrEasuSetF(
    dir: ptr<function, vec2f>,
    len: ptr<function, f32>,
    pp: vec2f,
    biS: bool, biT: bool, biU: bool, biV: bool,
    lA: f32, lB: f32, lC: f32, lD: f32, lE: f32
) {
    // Compute bilinear weight, branches factor out as predicates are compiler time immediates.
    //  s t
    //  u v
    var w = f32(0.0);
    if biS {
        w=(f32(1.0)-pp.x)*(f32(1.0)-pp.y);
    }
    if biT {
        w=          pp.x *(f32(1.0)-pp.y);
    }
    if biU {
        w=(f32(1.0)-pp.x)*          pp.y ;
    }
    if biV {
        w=          pp.x *          pp.y ;
    }
    // Direction is the '+' diff.
    //    a
    //  b c d
    //    e
    // Then takes magnitude from abs average of both sides of 'c'.
    // Length converts gradient reversal to 0, smoothly to non-reversal at 1, shaped, then adding horz and vert terms.
    let dc=lD-lC;
    let cb=lC-lB;
    var lenX=max(abs(dc),abs(cb));
    lenX=APrxLoRcpF1(lenX);
    let dirX=lD-lB;
    dir.x+=dirX*w;
    lenX=saturate(abs(dirX)*lenX);
    lenX*=lenX;
    *len+=lenX*w;
    // Repeat for the y axis.
    let ec=lE-lC;
    let ca=lC-lA;
    var lenY=max(abs(ec),abs(ca));
    lenY=APrxLoRcpF1(lenY);
    let dirY=lE-lA;
    dir.y+=dirY*w;
    lenY=saturate(abs(dirY)*lenY);
    lenY*=lenY;
    *len+=lenY*w;
}

fn FsrEasuF(
    pix: ptr<function, vec3f>,
    ip: vec2u, // Integer pixel position in output.
    con0: vec4u, // Constants generated by FsrEasuCon().
    con1: vec4u,
    con2: vec4u,
    con3: vec4u
) {
//------------------------------------------------------------------------------------------------------------------------------
    // Get position of 'f'.
    var pp=vec2f(ip)*bitcast<vec2f>(con0.xy)+bitcast<vec2f>(con0.zw);
    let fp=floor(pp);
    pp-=fp;
//------------------------------------------------------------------------------------------------------------------------------
    // 12-tap kernel.
    //    b c
    //  e f g h
    //  i j k l
    //    n o
    // Gather 4 ordering.
    //  a b
    //  r g
    // For packed FP16, need either {rg} or {ab} so using the following setup for gather in all versions,
    //    a b    <- unused (z)
    //    r g
    //  a b a b
    //  r g r g
    //    a b
    //    r g    <- unused (z)
    // Allowing dead-code removal to remove the 'z's.
    let p0=fp*bitcast<vec2f>(con1.xy)+bitcast<vec2f>(con1.zw);
    // These are from p0 to avoid pulling two constants on pre-Navi hardware.
    let p1=p0+bitcast<vec2f>(con2.xy);
    let p2=p0+bitcast<vec2f>(con2.zw);
    let p3=p0+bitcast<vec2f>(con3.xy);
    let bczzR=FsrEasuRF(p0);
    let bczzG=FsrEasuGF(p0);
    let bczzB=FsrEasuBF(p0);
    let ijfeR=FsrEasuRF(p1);
    let ijfeG=FsrEasuGF(p1);
    let ijfeB=FsrEasuBF(p1);
    let klhgR=FsrEasuRF(p2);
    let klhgG=FsrEasuGF(p2);
    let klhgB=FsrEasuBF(p2);
    let zzonR=FsrEasuRF(p3);
    let zzonG=FsrEasuGF(p3);
    let zzonB=FsrEasuBF(p3);
//------------------------------------------------------------------------------------------------------------------------------
    // Simplest multi-channel approximate luma possible (luma times 2, in 2 FMA/MAD).
    let bczzL=bczzB*vec4f(0.5)+(bczzR*vec4f(0.5)+bczzG);
    let ijfeL=ijfeB*vec4f(0.5)+(ijfeR*vec4f(0.5)+ijfeG);
    let klhgL=klhgB*vec4f(0.5)+(klhgR*vec4f(0.5)+klhgG);
    let zzonL=zzonB*vec4f(0.5)+(zzonR*vec4f(0.5)+zzonG);
    // Rename.
    let bL=bczzL.x;
    let cL=bczzL.y;
    let iL=ijfeL.x;
    let jL=ijfeL.y;
    let fL=ijfeL.z;
    let eL=ijfeL.w;
    let kL=klhgL.x;
    let lL=klhgL.y;
    let hL=klhgL.z;
    let gL=klhgL.w;
    let oL=zzonL.z;
    let nL=zzonL.w;
    // Accumulate for bilinear interpolation.
    var dir=vec2f(0.0);
    var len=f32(0.0);
    FsrEasuSetF(&dir,&len,pp,true, false,false,false,bL,eL,fL,gL,jL);
    FsrEasuSetF(&dir,&len,pp,false,true ,false,false,cL,fL,gL,hL,kL);
    FsrEasuSetF(&dir,&len,pp,false,false,true ,false,fL,iL,jL,kL,nL);
    FsrEasuSetF(&dir,&len,pp,false,false,false,true ,gL,jL,kL,lL,oL);
//------------------------------------------------------------------------------------------------------------------------------
    // Normalize with approximation, and cleanup close to zero.
    let dir2=dir*dir;
    var dirR=dir2.x+dir2.y;
    var zro=dirR<f32(1.0/32768.0);
    dirR=APrxLoRsqF1(dirR);
    dirR=select(dirR, f32(1.0), zro);
    dir.x=select(dir.x, f32(1.0), zro);
    dir*=vec2f(dirR);
    // Transform from {0 to 2} to {0 to 1} range, and shape with square.
    len=len*f32(0.5);
    len*=len;
    // Stretch kernel {1.0 vert|horz, to sqrt(2.0) on diagonal}.
    let stretch=(dir.x*dir.x+dir.y*dir.y)*APrxLoRcpF1(max(abs(dir.x),abs(dir.y)));
    // Anisotropic length after rotation,
    //  x := 1.0 lerp to 'stretch' on edges
    //  y := 1.0 lerp to 2x on edges
    let len2=vec2f(f32(1.0)+(stretch-f32(1.0))*len,f32(1.0)+f32(-0.5)*len);
    // Based on the amount of 'edge',
    // the window shifts from +/-{sqrt(2.0) to slightly beyond 2.0}.
    let lob=f32(0.5)+f32((1.0/4.0-0.04)-0.5)*len;
    // Set distance^2 clipping point to the end of the adjustable window.
    let clp=APrxLoRcpF1(lob);
//------------------------------------------------------------------------------------------------------------------------------
    // Accumulation mixed with min/max of 4 nearest.
    //    b c
    //  e f g h
    //  i j k l
    //    n o
    let min4=min(AMin3F3(vec3f(ijfeR.z,ijfeG.z,ijfeB.z),vec3f(klhgR.w,klhgG.w,klhgB.w),vec3f(ijfeR.y,ijfeG.y,ijfeB.y)),
                vec3f(klhgR.x,klhgG.x,klhgB.x));
    let max4=max(AMax3F3(vec3f(ijfeR.z,ijfeG.z,ijfeB.z),vec3f(klhgR.w,klhgG.w,klhgB.w),vec3f(ijfeR.y,ijfeG.y,ijfeB.y)),
                vec3f(klhgR.x,klhgG.x,klhgB.x));
    // Accumulation.
    var aC=vec3f(0.0);
    var aW=f32(0.0);
    FsrEasuTapF(&aC,&aW,vec2f( 0.0,-1.0)-pp,dir,len2,lob,clp,vec3f(bczzR.x,bczzG.x,bczzB.x)); // b
    FsrEasuTapF(&aC,&aW,vec2f( 1.0,-1.0)-pp,dir,len2,lob,clp,vec3f(bczzR.y,bczzG.y,bczzB.y)); // c
    FsrEasuTapF(&aC,&aW,vec2f(-1.0, 1.0)-pp,dir,len2,lob,clp,vec3f(ijfeR.x,ijfeG.x,ijfeB.x)); // i
    FsrEasuTapF(&aC,&aW,vec2f( 0.0, 1.0)-pp,dir,len2,lob,clp,vec3f(ijfeR.y,ijfeG.y,ijfeB.y)); // j
    FsrEasuTapF(&aC,&aW,vec2f( 0.0, 0.0)-pp,dir,len2,lob,clp,vec3f(ijfeR.z,ijfeG.z,ijfeB.z)); // f
    FsrEasuTapF(&aC,&aW,vec2f(-1.0, 0.0)-pp,dir,len2,lob,clp,vec3f(ijfeR.w,ijfeG.w,ijfeB.w)); // e
    FsrEasuTapF(&aC,&aW,vec2f( 1.0, 1.0)-pp,dir,len2,lob,clp,vec3f(klhgR.x,klhgG.x,klhgB.x)); // k
    FsrEasuTapF(&aC,&aW,vec2f( 2.0, 1.0)-pp,dir,len2,lob,clp,vec3f(klhgR.y,klhgG.y,klhgB.y)); // l
    FsrEasuTapF(&aC,&aW,vec2f( 2.0, 0.0)-pp,dir,len2,lob,clp,vec3f(klhgR.z,klhgG.z,klhgB.z)); // h
    FsrEasuTapF(&aC,&aW,vec2f( 1.0, 0.0)-pp,dir,len2,lob,clp,vec3f(klhgR.w,klhgG.w,klhgB.w)); // g
    FsrEasuTapF(&aC,&aW,vec2f( 1.0, 2.0)-pp,dir,len2,lob,clp,vec3f(zzonR.z,zzonG.z,zzonB.z)); // o
    FsrEasuTapF(&aC,&aW,vec2f( 0.0, 2.0)-pp,dir,len2,lob,clp,vec3f(zzonR.w,zzonG.w,zzonB.w)); // n
//------------------------------------------------------------------------------------------------------------------------------
    // Normalize and dering.
    *pix=min(max4,max(min4,aC*vec3f(1.0/aW)));
}

@fragment
fn main(input: FragmentInputs) -> FragmentOutputs {
    var pix: vec3f;
    let ip = vec2u(fragmentInputs.position.xy);
    FsrEasuF(&pix, ip, constants.con0, constants.con1, constants.con2, constants.con3);
    fragmentOutputs.color = vec4f(pix, 1);
}
