var BABYLON;!function(t){var e=function(t){function e(e,i,n,a,r){t.call(this,e,i,"starfieldProceduralTexture",n,a,r),this._time=1,this._alpha=.5,this._beta=.8,this._zoom=.8,this._formuparam=.53,this._stepsize=.1,this._tile=.85,this._brightness=.0015,this._darkmatter=.4,this._distfading=.73,this._saturation=.85,this.updateShaderUniforms()}return __extends(e,t),e.prototype.updateShaderUniforms=function(){this.setFloat("time",this._time),this.setFloat("alpha",this._alpha),this.setFloat("beta",this._beta),this.setFloat("zoom",this._zoom),this.setFloat("formuparam",this._formuparam),this.setFloat("stepsize",this._stepsize),this.setFloat("tile",this._tile),this.setFloat("brightness",this._brightness),this.setFloat("darkmatter",this._darkmatter),this.setFloat("distfading",this._distfading),this.setFloat("saturation",this._saturation)},Object.defineProperty(e.prototype,"time",{get:function(){return this._time},set:function(t){this._time=t,this.updateShaderUniforms()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"alpha",{get:function(){return this._alpha},set:function(t){this._alpha=t,this.updateShaderUniforms()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"beta",{get:function(){return this._beta},set:function(t){this._beta=t,this.updateShaderUniforms()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"formuparam",{get:function(){return this._formuparam},set:function(t){this._formuparam=t,this.updateShaderUniforms()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"stepsize",{get:function(){return this._stepsize},set:function(t){this._stepsize=t,this.updateShaderUniforms()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"tile",{get:function(){return this._tile},set:function(t){this._tile=t,this.updateShaderUniforms()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"brightness",{get:function(){return this._brightness},set:function(t){this._brightness=t,this.updateShaderUniforms()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"darkmatter",{get:function(){return this._darkmatter},set:function(t){this._darkmatter=t,this.updateShaderUniforms()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"distfading",{get:function(){return this._distfading},set:function(t){this._distfading=t,this.updateShaderUniforms()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"saturation",{get:function(){return this._saturation},set:function(t){this._saturation=t,this.updateShaderUniforms()},enumerable:!0,configurable:!0}),e}(t.ProceduralTexture);t.StarfieldProceduralTexture=e}(BABYLON||(BABYLON={})),BABYLON.Effect.ShadersStore.starfieldProceduralTexturePixelShader="precision highp float;\n\n//defined as const as fragment shaders does not support uniforms in loops\n#define volsteps 20\n#define iterations 15\n\nvarying vec2 vPosition;\nvarying vec2 vUV;\n\nuniform float time;\nuniform float alpha;\nuniform float beta;\nuniform float zoom;\nuniform float formuparam;\nuniform float stepsize;\nuniform float tile;\nuniform float brightness;\nuniform float darkmatter;\nuniform float distfading;\nuniform float saturation;\n\nvoid main()\n{\n	vec3 dir = vec3(vUV * zoom, 1.);\n\n	float localTime = time * 0.0001;\n\n	// Rotation\n	mat2 rot1 = mat2(cos(alpha), sin(alpha), -sin(alpha), cos(alpha));\n	mat2 rot2 = mat2(cos(beta), sin(beta), -sin(beta), cos(beta));\n	dir.xz *= rot1;\n	dir.xy *= rot2;\n	vec3 from = vec3(1., .5, 0.5);\n	from += vec3(localTime*2., localTime, -2.);\n	from.xz *= rot1;\n	from.xy *= rot2;\n\n	//volumetric rendering\n	float s = 0.1, fade = 1.;\n	vec3 v = vec3(0.);\n	for (int r = 0; r < volsteps; r++) {\n		vec3 p = from + s*dir*.5;\n		p = abs(vec3(tile) - mod(p, vec3(tile*2.))); // tiling fold\n		float pa, a = pa = 0.;\n		for (int i = 0; i < iterations; i++) {\n			p = abs(p) / dot(p, p) - formuparam; // the magic formula\n			a += abs(length(p) - pa); // absolute sum of average change\n			pa = length(p);\n		}\n		float dm = max(0., darkmatter - a*a*.001); //dark matter\n		a *= a*a; // add contrast\n		if (r > 6) fade *= 1. - dm; // dark matter, don't render near\n								  //v+=vec3(dm,dm*.5,0.);\n		v += fade;\n		v += vec3(s, s*s, s*s*s*s)*a*brightness*fade; // coloring based on distance\n		fade *= distfading; // distance fading\n		s += stepsize;\n	}\n	v = mix(vec3(length(v)), v, saturation); //color adjust\n	gl_FragColor = vec4(v*.01, 1.);\n}";