{"version":3,"sources":["webpack://BABYLONJS/loaders/src/webpack/universalModuleDefinition","webpack://BABYLONJS/loaders/src/webpack/bootstrap","webpack://BABYLONJS/loaders/src/(webpack)/buildin/global.js","webpack://BABYLONJS/loaders/src/OBJ/index.ts","webpack://BABYLONJS/loaders/src/OBJ/mtlFileLoader.ts","webpack://BABYLONJS/loaders/src/OBJ/objFileLoader.ts","webpack://BABYLONJS/loaders/src/OBJ/solidParser.ts","webpack://BABYLONJS/loaders/src/legacy/legacy-objFileLoader.ts","webpack://BABYLONJS/loaders/src/external {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}"],"names":[],"mappings":"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","file":"babylon.objFileLoader.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-loaders\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-loaders\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"LOADERS\"] = factory(root[\"BABYLON\"]);\n})((typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : this), function(__WEBPACK_EXTERNAL_MODULE_babylonjs_Misc_observable__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./legacy/legacy-objFileLoader.ts\");\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","export * from \"./mtlFileLoader\";\r\nexport * from \"./objLoadingOptions\";\r\nexport * from \"./solidParser\";\r\nexport * from \"./objFileLoader\";\r\n","import { Nullable } from \"babylonjs/types\";\r\nimport { Color3 } from 'babylonjs/Maths/math.color';\r\nimport { Texture } from \"babylonjs/Materials/Textures/texture\";\r\nimport { StandardMaterial } from \"babylonjs/Materials/standardMaterial\";\r\n\r\nimport { Scene } from \"babylonjs/scene\";\r\nimport { AssetContainer } from \"babylonjs/assetContainer\";\r\n/**\r\n * Class reading and parsing the MTL file bundled with the obj file.\r\n */\r\nexport class MTLFileLoader {\r\n    /**\r\n     * Invert Y-Axis of referenced textures on load\r\n     */\r\n    public static INVERT_TEXTURE_Y = true;\r\n\r\n    /**\r\n     * All material loaded from the mtl will be set here\r\n     */\r\n    public materials: StandardMaterial[] = [];\r\n\r\n    /**\r\n     * This function will read the mtl file and create each material described inside\r\n     * This function could be improve by adding :\r\n     * -some component missing (Ni, Tf...)\r\n     * -including the specific options available\r\n     *\r\n     * @param scene defines the scene the material will be created in\r\n     * @param data defines the mtl data to parse\r\n     * @param rootUrl defines the rooturl to use in order to load relative dependencies\r\n     * @param assetContainer defines the asset container to store the material in (can be null)\r\n     */\r\n    public parseMTL(scene: Scene, data: string | ArrayBuffer, rootUrl: string, assetContainer: Nullable<AssetContainer>): void {\r\n        if (data instanceof ArrayBuffer) {\r\n            return;\r\n        }\r\n\r\n        //Split the lines from the file\r\n        var lines = data.split('\\n');\r\n        // whitespace char ie: [ \\t\\r\\n\\f]\r\n        var delimiter_pattern = /\\s+/;\r\n        //Array with RGB colors\r\n        var color: number[];\r\n        //New material\r\n        var material: Nullable<StandardMaterial> = null;\r\n\r\n        //Look at each line\r\n        for (var i = 0; i < lines.length; i++) {\r\n            var line = lines[i].trim();\r\n\r\n            // Blank line or comment\r\n            if (line.length === 0 || line.charAt(0) === '#') {\r\n                continue;\r\n            }\r\n\r\n            //Get the first parameter (keyword)\r\n            var pos = line.indexOf(' ');\r\n            var key = (pos >= 0) ? line.substring(0, pos) : line;\r\n            key = key.toLowerCase();\r\n\r\n            //Get the data following the key\r\n            var value: string = (pos >= 0) ? line.substring(pos + 1).trim() : \"\";\r\n\r\n            //This mtl keyword will create the new material\r\n            if (key === \"newmtl\") {\r\n                //Check if it is the first material.\r\n                // Materials specifications are described after this keyword.\r\n                if (material) {\r\n                    //Add the previous material in the material array.\r\n                    this.materials.push(material);\r\n                }\r\n                //Create a new material.\r\n                // value is the name of the material read in the mtl file\r\n\r\n                scene._blockEntityCollection = !!assetContainer;\r\n                material = new StandardMaterial(value, scene);\r\n                material._parentContainer = assetContainer;\r\n                scene._blockEntityCollection = false;\r\n            } else if (key === \"kd\" && material) {\r\n                // Diffuse color (color under white light) using RGB values\r\n\r\n                //value  = \"r g b\"\r\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set tghe color into the material\r\n                material.diffuseColor = Color3.FromArray(color);\r\n            } else if (key === \"ka\" && material) {\r\n                // Ambient color (color under shadow) using RGB values\r\n\r\n                //value = \"r g b\"\r\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set tghe color into the material\r\n                material.ambientColor = Color3.FromArray(color);\r\n            } else if (key === \"ks\" && material) {\r\n                // Specular color (color when light is reflected from shiny surface) using RGB values\r\n\r\n                //value = \"r g b\"\r\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set the color into the material\r\n                material.specularColor = Color3.FromArray(color);\r\n            } else if (key === \"ke\" && material) {\r\n                // Emissive color using RGB values\r\n                color = value.split(delimiter_pattern, 3).map(parseFloat);\r\n                material.emissiveColor = Color3.FromArray(color);\r\n            } else if (key === \"ns\" && material) {\r\n\r\n                //value = \"Integer\"\r\n                material.specularPower = parseFloat(value);\r\n            } else if (key === \"d\" && material) {\r\n                //d is dissolve for current material. It mean alpha for BABYLON\r\n                material.alpha = parseFloat(value);\r\n\r\n                //Texture\r\n                //This part can be improved by adding the possible options of texture\r\n            } else if (key === \"map_ka\" && material) {\r\n                // ambient texture map with a loaded image\r\n                //We must first get the folder of the image\r\n                material.ambientTexture = MTLFileLoader._getTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_kd\" && material) {\r\n                // Diffuse texture map with a loaded image\r\n                material.diffuseTexture = MTLFileLoader._getTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_ks\" && material) {\r\n                // Specular texture map with a loaded image\r\n                //We must first get the folder of the image\r\n                material.specularTexture = MTLFileLoader._getTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_ns\") {\r\n                //Specular\r\n                //Specular highlight component\r\n                //We must first get the folder of the image\r\n                //\r\n                //Not supported by BABYLON\r\n                //\r\n                //    continue;\r\n            } else if (key === \"map_bump\" && material) {\r\n                //The bump texture\r\n                const values = value.split(delimiter_pattern);\r\n                const bumpMultiplierIndex = values.indexOf('-bm');\r\n                let bumpMultiplier: Nullable<string> = null;\r\n\r\n                if (bumpMultiplierIndex >= 0) {\r\n                    bumpMultiplier = values[bumpMultiplierIndex + 1];\r\n                    values.splice(bumpMultiplierIndex, 2); // remove\r\n                }\r\n\r\n                material.bumpTexture = MTLFileLoader._getTexture(rootUrl, values.join(' '), scene);\r\n                if (material.bumpTexture && bumpMultiplier !== null) {\r\n                    material.bumpTexture.level = parseFloat(bumpMultiplier);\r\n                }\r\n            } else if (key === \"map_d\" && material) {\r\n                // The dissolve of the material\r\n                material.opacityTexture = MTLFileLoader._getTexture(rootUrl, value, scene);\r\n\r\n                //Options for illumination\r\n            } else if (key === \"illum\") {\r\n                //Illumination\r\n                if (value === \"0\") {\r\n                    //That mean Kd == Kd\r\n                } else if (value === \"1\") {\r\n                    //Color on and Ambient on\r\n                } else if (value === \"2\") {\r\n                    //Highlight on\r\n                } else if (value === \"3\") {\r\n                    //Reflection on and Ray trace on\r\n                } else if (value === \"4\") {\r\n                    //Transparency: Glass on, Reflection: Ray trace on\r\n                } else if (value === \"5\") {\r\n                    //Reflection: Fresnel on and Ray trace on\r\n                } else if (value === \"6\") {\r\n                    //Transparency: Refraction on, Reflection: Fresnel off and Ray trace on\r\n                } else if (value === \"7\") {\r\n                    //Transparency: Refraction on, Reflection: Fresnel on and Ray trace on\r\n                } else if (value === \"8\") {\r\n                    //Reflection on and Ray trace off\r\n                } else if (value === \"9\") {\r\n                    //Transparency: Glass on, Reflection: Ray trace off\r\n                } else if (value === \"10\") {\r\n                    //Casts shadows onto invisible surfaces\r\n                }\r\n            } else {\r\n                // console.log(\"Unhandled expression at line : \" + i +'\\n' + \"with value : \" + line);\r\n            }\r\n        }\r\n        //At the end of the file, add the last material\r\n        if (material) {\r\n            this.materials.push(material);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the texture for the material.\r\n     *\r\n     * If the material is imported from input file,\r\n     * We sanitize the url to ensure it takes the textre from aside the material.\r\n     *\r\n     * @param rootUrl The root url to load from\r\n     * @param value The value stored in the mtl\r\n     * @return The Texture\r\n     */\r\n    private static _getTexture(rootUrl: string, value: string, scene: Scene): Nullable<Texture> {\r\n        if (!value) {\r\n            return null;\r\n        }\r\n\r\n        var url = rootUrl;\r\n        // Load from input file.\r\n        if (rootUrl === \"file:\") {\r\n            var lastDelimiter = value.lastIndexOf(\"\\\\\");\r\n            if (lastDelimiter === -1) {\r\n                lastDelimiter = value.lastIndexOf(\"/\");\r\n            }\r\n\r\n            if (lastDelimiter > -1) {\r\n                url += value.substr(lastDelimiter + 1);\r\n            }\r\n            else {\r\n                url += value;\r\n            }\r\n        }\r\n        // Not from input file.\r\n        else {\r\n            url += value;\r\n        }\r\n\r\n        return new Texture(url, scene, false, MTLFileLoader.INVERT_TEXTURE_Y);\r\n    }\r\n}\r\n","import { Nullable } from \"babylonjs/types\";\nimport { Vector2 } from \"babylonjs/Maths/math.vector\";\nimport { Tools } from \"babylonjs/Misc/tools\";\nimport { AbstractMesh } from \"babylonjs/Meshes/abstractMesh\";\nimport { SceneLoader, ISceneLoaderPluginAsync, ISceneLoaderProgressEvent, ISceneLoaderPluginFactory, ISceneLoaderPlugin, ISceneLoaderAsyncResult } from \"babylonjs/Loading/sceneLoader\";\nimport { AssetContainer } from \"babylonjs/assetContainer\";\nimport { Scene } from \"babylonjs/scene\";\nimport { WebRequest } from 'babylonjs/Misc/webRequest';\nimport { MTLFileLoader } from './mtlFileLoader';\nimport { OBJLoadingOptions } from \"./objLoadingOptions\";\nimport { SolidParser } from \"./solidParser\";\nimport { Mesh } from \"babylonjs/Meshes/mesh\";\n\n/**\n * OBJ file type loader.\n * This is a babylon scene loader plugin.\n */\nexport class OBJFileLoader implements ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\n\n    /**\n     * Defines if UVs are optimized by default during load.\n     */\n    public static OPTIMIZE_WITH_UV = true;\n    /**\n     * Invert model on y-axis (does a model scaling inversion)\n     */\n    public static INVERT_Y = false;\n    /**\n     * Invert Y-Axis of referenced textures on load\n     */\n    public static get INVERT_TEXTURE_Y() {\n        return MTLFileLoader.INVERT_TEXTURE_Y;\n    }\n\n    public static set INVERT_TEXTURE_Y(value: boolean) {\n        MTLFileLoader.INVERT_TEXTURE_Y = value;\n    }\n\n    /**\n     * Include in meshes the vertex colors available in some OBJ files.  This is not part of OBJ standard.\n     */\n    public static IMPORT_VERTEX_COLORS = false;\n    /**\n     * Compute the normals for the model, even if normals are present in the file.\n     */\n    public static COMPUTE_NORMALS = false;\n    /**\n     * Optimize the normals for the model. Lighting can be uneven if you use OptimizeWithUV = true because new vertices can be created for the same location if they pertain to different faces.\n     * Using OptimizehNormals = true will help smoothing the lighting by averaging the normals of those vertices.\n     */\n    public static OPTIMIZE_NORMALS = false;\n    /**\n     * Defines custom scaling of UV coordinates of loaded meshes.\n     */\n    public static UV_SCALING = new Vector2(1, 1);\n    /**\n     * Skip loading the materials even if defined in the OBJ file (materials are ignored).\n     */\n    public static SKIP_MATERIALS = false;\n\n    /**\n     * When a material fails to load OBJ loader will silently fail and onSuccess() callback will be triggered.\n     *\n     * Defaults to true for backwards compatibility.\n     */\n    public static MATERIAL_LOADING_FAILS_SILENTLY = true;\n    /**\n     * Defines the name of the plugin.\n     */\n    public name = \"obj\";\n    /**\n     * Defines the extension the plugin is able to load.\n     */\n    public extensions = \".obj\";\n\n    private _assetContainer: Nullable<AssetContainer> = null;\n\n    private _loadingOptions: OBJLoadingOptions;\n\n    /**\n     * Creates loader for .OBJ files\n     *\n     * @param loadingOptions options for loading and parsing OBJ/MTL files.\n     */\n    constructor(loadingOptions?: OBJLoadingOptions) {\n        this._loadingOptions = loadingOptions || OBJFileLoader.DefaultLoadingOptions;\n    }\n\n    private static get DefaultLoadingOptions(): OBJLoadingOptions {\n        return {\n            computeNormals: OBJFileLoader.COMPUTE_NORMALS,\n            optimizeNormals: OBJFileLoader.OPTIMIZE_NORMALS,\n            importVertexColors: OBJFileLoader.IMPORT_VERTEX_COLORS,\n            invertY: OBJFileLoader.INVERT_Y,\n            invertTextureY: OBJFileLoader.INVERT_TEXTURE_Y,\n            UVScaling: OBJFileLoader.UV_SCALING,\n            materialLoadingFailsSilently: OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY,\n            optimizeWithUV: OBJFileLoader.OPTIMIZE_WITH_UV,\n            skipMaterials: OBJFileLoader.SKIP_MATERIALS\n        };\n    }\n\n    /**\n     * Calls synchronously the MTL file attached to this obj.\n     * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.\n     * Without this function materials are not displayed in the first frame (but displayed after).\n     * In consequence it is impossible to get material information in your HTML file\n     *\n     * @param url The URL of the MTL file\n     * @param rootUrl defines where to load data from\n     * @param onSuccess Callback function to be called when the MTL file is loaded\n     */\n    private _loadMTL(url: string, rootUrl: string, onSuccess: (response: string | ArrayBuffer, responseUrl?: string) => any, onFailure: (pathOfFile: string, exception?: any) => void) {\n        //The complete path to the mtl file\n        var pathOfFile = rootUrl + url;\n\n        // Loads through the babylon tools to allow fileInput search.\n        Tools.LoadFile(\n            pathOfFile,\n            onSuccess,\n            undefined,\n            undefined,\n            false,\n            (request?: WebRequest | undefined, exception?: any) => {\n                onFailure(pathOfFile, exception);\n            }\n        );\n    }\n\n    /**\n     * Instantiates a OBJ file loader plugin.\n     * @returns the created plugin\n     */\n    createPlugin(): ISceneLoaderPluginAsync | ISceneLoaderPlugin {\n        return new OBJFileLoader(OBJFileLoader.DefaultLoadingOptions);\n    }\n\n    /**\n     * If the data string can be loaded directly.\n     *\n     * @param data string containing the file data\n     * @returns if the data can be loaded directly\n     */\n    public canDirectLoad(data: string): boolean {\n        return false;\n    }\n\n    /**\n     * Imports one or more meshes from the loaded OBJ data and adds them to the scene\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene the scene the meshes should be added to\n     * @param data the OBJ data to load\n     * @param rootUrl root url to load from\n     * @param onProgress event that fires when loading progress has occured\n     * @param fileName Defines the name of the file to load\n     * @returns a promise containg the loaded meshes, particles, skeletons and animations\n     */\n    public importMeshAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<ISceneLoaderAsyncResult> {\n        //get the meshes from OBJ file\n        return this._parseSolid(meshesNames, scene, data, rootUrl).then((meshes) => {\n            return {\n                meshes: meshes,\n                particleSystems: [],\n                skeletons: [],\n                animationGroups: [],\n                transformNodes: [],\n                geometries: [],\n                lights: []\n            };\n        });\n    }\n\n    /**\n     * Imports all objects from the loaded OBJ data and adds them to the scene\n     * @param scene the scene the objects should be added to\n     * @param data the OBJ data to load\n     * @param rootUrl root url to load from\n     * @param onProgress event that fires when loading progress has occured\n     * @param fileName Defines the name of the file to load\n     * @returns a promise which completes when objects have been loaded to the scene\n     */\n    public loadAsync(scene: Scene, data: string, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<void> {\n        //Get the 3D model\n        return this.importMeshAsync(null, scene, data, rootUrl, onProgress).then(() => {\n            // return void\n        });\n    }\n\n    /**\n     * Load into an asset container.\n     * @param scene The scene to load into\n     * @param data The data to import\n     * @param rootUrl The root url for scene and resources\n     * @param onProgress The callback when the load progresses\n     * @param fileName Defines the name of the file to load\n     * @returns The loaded asset container\n     */\n    public loadAssetContainerAsync(scene: Scene, data: string, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<AssetContainer> {\n        var container = new AssetContainer(scene);\n        this._assetContainer = container;\n\n        return this.importMeshAsync(null, scene, data, rootUrl).then((result) => {\n            result.meshes.forEach((mesh) => container.meshes.push(mesh));\n            result.meshes.forEach((mesh) => {\n                var material = mesh.material;\n                if (material) {\n                    // Materials\n                    if (container.materials.indexOf(material) == -1) {\n                        container.materials.push(material);\n\n                        // Textures\n                        var textures = material.getActiveTextures();\n                        textures.forEach((t) => {\n                            if (container.textures.indexOf(t) == -1) {\n                                container.textures.push(t);\n                            }\n                        });\n                    }\n                }\n            });\n            this._assetContainer = null;\n            return container;\n        }).catch((ex) => {\n            this._assetContainer = null;\n            throw ex;\n        });\n    }\n\n    /**\n     * Read the OBJ file and create an Array of meshes.\n     * Each mesh contains all information given by the OBJ and the MTL file.\n     * i.e. vertices positions and indices, optional normals values, optional UV values, optional material\n     * @param meshesNames defines a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene defines the scene where are displayed the data\n     * @param data defines the content of the obj file\n     * @param rootUrl defines the path to the folder\n     * @returns the list of loaded meshes\n     */\n    private _parseSolid(meshesNames: any, scene: Scene, data: string, rootUrl: string): Promise<Array<AbstractMesh>> {\n        var fileToLoad: string = \"\";      //The name of the mtlFile to load\n        var materialsFromMTLFile: MTLFileLoader = new MTLFileLoader();\n        var materialToUse = new Array<string>();\n        var babylonMeshesArray: Array<Mesh> = []; //The mesh for babylon\n\n        // Main function\n        const solidParser = new SolidParser(materialToUse, babylonMeshesArray, this._loadingOptions);\n\n        solidParser.parse(meshesNames, data, scene, this._assetContainer, (fileName: string) => {\n            fileToLoad = fileName;\n        });\n\n        // load the materials\n        let mtlPromises: Array<Promise<void>> = [];\n        // Check if we have a file to load\n        if (fileToLoad !== \"\" && !this._loadingOptions.skipMaterials) {\n            //Load the file synchronously\n            mtlPromises.push(new Promise((resolve, reject) => {\n                this._loadMTL(fileToLoad, rootUrl, (dataLoaded) => {\n                    try {\n                        //Create materials thanks MTLLoader function\n                        materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl, this._assetContainer);\n                        //Look at each material loaded in the mtl file\n                        for (var n = 0; n < materialsFromMTLFile.materials.length; n++) {\n                            //Three variables to get all meshes with the same material\n                            var startIndex = 0;\n                            var _indices = [];\n                            var _index;\n\n                            //The material from MTL file is used in the meshes loaded\n                            //Push the indice in an array\n                            //Check if the material is not used for another mesh\n                            while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {\n                                _indices.push(_index);\n                                startIndex = _index + 1;\n                            }\n                            //If the material is not used dispose it\n                            if (_index === -1 && _indices.length === 0) {\n                                //If the material is not needed, remove it\n                                materialsFromMTLFile.materials[n].dispose();\n                            } else {\n                                for (var o = 0; o < _indices.length; o++) {\n                                    //Apply the material to the Mesh for each mesh with the material\n                                    const mesh = babylonMeshesArray[_indices[o]];\n                                    const material = materialsFromMTLFile.materials[n];\n                                    mesh.material = material;\n\n                                    if (!mesh.getTotalIndices()) {\n                                        // No indices, we need to turn on point cloud\n                                        material.pointsCloud = true;\n                                    }\n                                }\n                            }\n                        }\n                        resolve();\n                    } catch (e) {\n                        Tools.Warn(`Error processing MTL file: '${fileToLoad}'`);\n                        if (this._loadingOptions.materialLoadingFailsSilently) {\n                            resolve();\n                        } else {\n                            reject(e);\n                        }\n                    }\n                }, (pathOfFile: string, exception?: any) => {\n                    Tools.Warn(`Error downloading MTL file: '${fileToLoad}'`);\n                    if (this._loadingOptions.materialLoadingFailsSilently) {\n                        resolve();\n                    } else {\n                        reject(exception);\n                    }\n                });\n            }));\n\n        }\n        //Return an array with all Mesh\n        return Promise.all(mtlPromises).then(() => {\n            return babylonMeshesArray;\n        });\n    }\n\n}\n\nif (SceneLoader) {\n    //Add this loader into the register plugin\n    SceneLoader.RegisterPlugin(new OBJFileLoader());\n}","import { AssetContainer } from \"babylonjs/assetContainer\";\r\nimport { VertexBuffer } from \"babylonjs/Buffers/buffer\";\r\nimport { Material } from \"babylonjs/Materials/material\";\r\nimport { StandardMaterial } from \"babylonjs/Materials/standardMaterial\";\r\nimport { Color3, Color4 } from \"babylonjs/Maths/math.color\";\r\nimport { Vector2, Vector3 } from \"babylonjs/Maths/math.vector\";\r\nimport { AbstractMesh } from \"babylonjs/Meshes/abstractMesh\";\r\nimport { Geometry } from \"babylonjs/Meshes/geometry\";\r\nimport { Mesh } from \"babylonjs/Meshes/mesh\";\r\nimport { VertexData } from \"babylonjs/Meshes/mesh.vertexData\";\r\nimport { Scene } from \"babylonjs/scene\";\r\nimport { FloatArray, IndicesArray, Nullable } from \"babylonjs/types\";\r\nimport { OBJLoadingOptions } from \"./objLoadingOptions\";\r\n\r\ntype MeshObject = {\r\n    name: string;\r\n    indices?: Array<number>;\r\n    positions?: Array<number>;\r\n    normals?: Array<number>;\r\n    colors?: Array<number>;\r\n    uvs?: Array<number>;\r\n    materialName: string;\r\n    directMaterial?: Nullable<Material>;\r\n};\r\n\r\n/**\r\n * Class used to load mesh data from OBJ content\r\n */\r\nexport class SolidParser {\r\n    // Descriptor\r\n    /** Object descriptor */\r\n    public static ObjectDescriptor = /^o/;\r\n    /** Group descriptor */\r\n    public static GroupDescriptor = /^g/;\r\n    /** Material lib descriptor */\r\n    public static MtlLibGroupDescriptor = /^mtllib /;\r\n    /** Use a material descriptor */\r\n    public static UseMtlDescriptor = /^usemtl /;\r\n    /** Smooth descriptor */\r\n    public static SmoothDescriptor = /^s /;\r\n\r\n    // Patterns\r\n    /** Pattern used to detect a vertex */\r\n    public static VertexPattern = /v(\\s+[\\d|\\.|\\+|\\-|e|E]+){3,7}/;\r\n    /** Pattern used to detect a normal */\r\n    public static NormalPattern = /vn(\\s+[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/;\r\n    /** Pattern used to detect a UV set */\r\n    public static UVPattern = /vt(\\s+[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/;\r\n    /** Pattern used to detect a first kind of face (f vertex vertex vertex) */\r\n    public static FacePattern1 = /f\\s+(([\\d]{1,}[\\s]?){3,})+/;\r\n    /** Pattern used to detect a second kind of face (f vertex/uvs vertex/uvs vertex/uvs) */\r\n    public static FacePattern2 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a third kind of face (f vertex/uvs/normal vertex/uvs/normal vertex/uvs/normal) */\r\n    public static FacePattern3 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a fourth kind of face (f vertex//normal vertex//normal vertex//normal)*/\r\n    public static FacePattern4 = /f\\s+((([\\d]{1,}\\/\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a fifth kind of face (f -vertex/-uvs/-normal -vertex/-uvs/-normal -vertex/-uvs/-normal) */\r\n    public static FacePattern5 = /f\\s+(((-[\\d]{1,}\\/-[\\d]{1,}\\/-[\\d]{1,}[\\s]?){3,})+)/;\r\n\r\n    private _loadingOptions: OBJLoadingOptions;\r\n    private _positions: Array<Vector3> = [];      //values for the positions of vertices\r\n    private _normals: Array<Vector3> = [];      //Values for the normals\r\n    private _uvs: Array<Vector2> = [];      //Values for the textures\r\n    private _colors: Array<Color4> = [];\r\n    private _meshesFromObj: Array<MeshObject> = [];      //[mesh] Contains all the obj meshes\r\n    private _handledMesh: MeshObject;      //The current mesh of meshes array\r\n    private _indicesForBabylon: Array<number> = [];      //The list of indices for VertexData\r\n    private _wrappedPositionForBabylon: Array<Vector3> = [];      //The list of position in vectors\r\n    private _wrappedUvsForBabylon: Array<Vector2> = [];      //Array with all value of uvs to match with the indices\r\n    private _wrappedColorsForBabylon: Array<Color4> = []; // Array with all color values to match with the indices\r\n    private _wrappedNormalsForBabylon: Array<Vector3> = [];      //Array with all value of normals to match with the indices\r\n    private _tuplePosNorm: Array<{ normals: Array<number>; idx: Array<number>; uv: Array<number> }> = [];      //Create a tuple with indice of Position, Normal, UV  [pos, norm, uvs]\r\n    private _curPositionInIndices = 0;\r\n    private _hasMeshes: Boolean = false;   //Meshes are defined in the file\r\n    private _unwrappedPositionsForBabylon: Array<number> = [];      //Value of positionForBabylon w/o Vector3() [x,y,z]\r\n    private _unwrappedColorsForBabylon: Array<number> = [];       // Value of colorForBabylon w/o Color4() [r,g,b,a]\r\n    private _unwrappedNormalsForBabylon: Array<number> = [];      //Value of normalsForBabylon w/o Vector3()  [x,y,z]\r\n    private _unwrappedUVForBabylon: Array<number> = [];      //Value of uvsForBabylon w/o Vector3()      [x,y,z]\r\n    private _triangles: Array<string> = [];      //Indices from new triangles coming from polygons\r\n    private _materialNameFromObj: string = \"\";      //The name of the current material\r\n    private _objMeshName: string = \"\";      //The name of the current obj mesh\r\n    private _increment: number = 1;      //Id for meshes created by the multimaterial\r\n    private _isFirstMaterial: boolean = true;\r\n    private _grayColor = new Color4(0.5, 0.5, 0.5, 1);\r\n    private _materialToUse: string[];\r\n    private _babylonMeshesArray: Array<Mesh>;\r\n\r\n    /**\r\n     * Creates a new SolidParser\r\n     * @param materialToUse defines the array to fill with the list of materials to use (it will be filled by the parse function)\r\n     * @param babylonMeshesArray defines the array to fill with the list of loaded meshes (it will be filled by the parse function)\r\n     * @param loadingOptions defines the loading options to use\r\n     */\r\n    public constructor(materialToUse: string[], babylonMeshesArray: Array<Mesh>, loadingOptions: OBJLoadingOptions) {\r\n        this._materialToUse = materialToUse;\r\n        this._babylonMeshesArray = babylonMeshesArray;\r\n        this._loadingOptions = loadingOptions;\r\n    }\r\n\r\n    /**\r\n     * Search for obj in the given array.\r\n     * This function is called to check if a couple of data already exists in an array.\r\n     *\r\n     * If found, returns the index of the founded tuple index. Returns -1 if not found\r\n     * @param arr Array<{ normals: Array<number>, idx: Array<number> }>\r\n     * @param obj Array<number>\r\n     * @returns {boolean}\r\n     */\r\n    private _isInArray(arr: Array<{ normals: Array<number>; idx: Array<number> }>, obj: Array<number>) {\r\n        if (!arr[obj[0]]) { arr[obj[0]] = { normals: [], idx: [] }; }\r\n        var idx = arr[obj[0]].normals.indexOf(obj[1]);\r\n\r\n        return idx === -1 ? -1 : arr[obj[0]].idx[idx];\r\n    }\r\n\r\n    private _isInArrayUV(arr: Array<{ normals: Array<number>; idx: Array<number>; uv: Array<number> }>, obj: Array<number>) {\r\n        if (!arr[obj[0]]) { arr[obj[0]] = { normals: [], idx: [], uv: [] }; }\r\n        var idx = arr[obj[0]].normals.indexOf(obj[1]);\r\n\r\n        if (idx != 1 && (obj[2] === arr[obj[0]].uv[idx])) {\r\n            return arr[obj[0]].idx[idx];\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * This function set the data for each triangle.\r\n     * Data are position, normals and uvs\r\n     * If a tuple of (position, normal) is not set, add the data into the corresponding array\r\n     * If the tuple already exist, add only their indice\r\n     *\r\n     * @param indicePositionFromObj Integer The index in positions array\r\n     * @param indiceUvsFromObj Integer The index in uvs array\r\n     * @param indiceNormalFromObj Integer The index in normals array\r\n     * @param positionVectorFromOBJ Vector3 The value of position at index objIndice\r\n     * @param textureVectorFromOBJ Vector3 The value of uvs\r\n     * @param normalsVectorFromOBJ Vector3 The value of normals at index objNormale\r\n     */\r\n    private _setData(indicePositionFromObj: number, indiceUvsFromObj: number, indiceNormalFromObj: number, positionVectorFromOBJ: Vector3, textureVectorFromOBJ: Vector2, normalsVectorFromOBJ: Vector3, positionColorsFromOBJ?: Color4) {\r\n        //Check if this tuple already exists in the list of tuples\r\n        var _index: number;\r\n        if (this._loadingOptions.optimizeWithUV) {\r\n            _index = this._isInArrayUV(\r\n                this._tuplePosNorm,\r\n                [\r\n                    indicePositionFromObj,\r\n                    indiceNormalFromObj,\r\n                    indiceUvsFromObj\r\n                ]\r\n            );\r\n        }\r\n        else {\r\n            _index = this._isInArray(\r\n                this._tuplePosNorm,\r\n                [\r\n                    indicePositionFromObj,\r\n                    indiceNormalFromObj\r\n                ]\r\n            );\r\n        }\r\n\r\n        //If it not exists\r\n        if (_index === -1) {\r\n            //Add an new indice.\r\n            //The array of indices is only an array with his length equal to the number of triangles - 1.\r\n            //We add vertices data in this order\r\n            this._indicesForBabylon.push(this._wrappedPositionForBabylon.length);\r\n            //Push the position of vertice for Babylon\r\n            //Each element is a Vector3(x,y,z)\r\n            this._wrappedPositionForBabylon.push(positionVectorFromOBJ);\r\n            //Push the uvs for Babylon\r\n            //Each element is a Vector3(u,v)\r\n            this._wrappedUvsForBabylon.push(textureVectorFromOBJ);\r\n            //Push the normals for Babylon\r\n            //Each element is a Vector3(x,y,z)\r\n            this._wrappedNormalsForBabylon.push(normalsVectorFromOBJ);\r\n\r\n            if (positionColorsFromOBJ !== undefined) {\r\n                //Push the colors for Babylon\r\n                //Each element is a BABYLON.Color4(r,g,b,a)\r\n                this._wrappedColorsForBabylon.push(positionColorsFromOBJ);\r\n            }\r\n\r\n            //Add the tuple in the comparison list\r\n            this._tuplePosNorm[indicePositionFromObj].normals.push(indiceNormalFromObj);\r\n            this._tuplePosNorm[indicePositionFromObj].idx.push(this._curPositionInIndices++);\r\n            if (this._loadingOptions.optimizeWithUV) { this._tuplePosNorm[indicePositionFromObj].uv.push(indiceUvsFromObj); }\r\n        } else {\r\n            //The tuple already exists\r\n            //Add the index of the already existing tuple\r\n            //At this index we can get the value of position, normal, color and uvs of vertex\r\n            this._indicesForBabylon.push(_index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transform Vector() and BABYLON.Color() objects into numbers in an array\r\n     */\r\n    private _unwrapData() {\r\n        //Every array has the same length\r\n        for (var l = 0; l < this._wrappedPositionForBabylon.length; l++) {\r\n            //Push the x, y, z values of each element in the unwrapped array\r\n            this._unwrappedPositionsForBabylon.push(this._wrappedPositionForBabylon[l].x, this._wrappedPositionForBabylon[l].y, this._wrappedPositionForBabylon[l].z);\r\n            this._unwrappedNormalsForBabylon.push(this._wrappedNormalsForBabylon[l].x, this._wrappedNormalsForBabylon[l].y, this._wrappedNormalsForBabylon[l].z);\r\n            this._unwrappedUVForBabylon.push(this._wrappedUvsForBabylon[l].x, this._wrappedUvsForBabylon[l].y); //z is an optional value not supported by BABYLON\r\n            if (this._loadingOptions.importVertexColors) {\r\n                //Push the r, g, b, a values of each element in the unwrapped array\r\n                this._unwrappedColorsForBabylon.push(this._wrappedColorsForBabylon[l].r, this._wrappedColorsForBabylon[l].g, this._wrappedColorsForBabylon[l].b, this._wrappedColorsForBabylon[l].a);\r\n            }\r\n        }\r\n        // Reset arrays for the next new meshes\r\n        this._wrappedPositionForBabylon = [];\r\n        this._wrappedNormalsForBabylon = [];\r\n        this._wrappedUvsForBabylon = [];\r\n        this._wrappedColorsForBabylon = [];\r\n        this._tuplePosNorm = [];\r\n        this._curPositionInIndices = 0;\r\n    }\r\n\r\n    /**\r\n     * Create triangles from polygons\r\n     * It is important to notice that a triangle is a polygon\r\n     * We get 5 patterns of face defined in OBJ File :\r\n     * facePattern1 = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"]\r\n     * facePattern2 = [\"1/1\",\"2/2\",\"3/3\",\"4/4\",\"5/5\",\"6/6\"]\r\n     * facePattern3 = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"4/4/4\",\"5/5/5\",\"6/6/6\"]\r\n     * facePattern4 = [\"1//1\",\"2//2\",\"3//3\",\"4//4\",\"5//5\",\"6//6\"]\r\n     * facePattern5 = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-4/-4/-4\",\"-5/-5/-5\",\"-6/-6/-6\"]\r\n     * Each pattern is divided by the same method\r\n     * @param face Array[String] The indices of elements\r\n     * @param v Integer The variable to increment\r\n     */\r\n    private _getTriangles(faces: Array<string>, v: number) {\r\n        //Work for each element of the array\r\n        for (var faceIndex = v; faceIndex < faces.length - 1; faceIndex++) {\r\n            //Add on the triangle variable the indexes to obtain triangles\r\n            this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\r\n        }\r\n\r\n        //Result obtained after 2 iterations:\r\n        //Pattern1 => triangle = [\"1\",\"2\",\"3\",\"1\",\"3\",\"4\"];\r\n        //Pattern2 => triangle = [\"1/1\",\"2/2\",\"3/3\",\"1/1\",\"3/3\",\"4/4\"];\r\n        //Pattern3 => triangle = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"1/1/1\",\"3/3/3\",\"4/4/4\"];\r\n        //Pattern4 => triangle = [\"1//1\",\"2//2\",\"3//3\",\"1//1\",\"3//3\",\"4//4\"];\r\n        //Pattern5 => triangle = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-1/-1/-1\",\"-3/-3/-3\",\"-4/-4/-4\"];\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 1\r\n     * In this pattern we get vertice positions\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern1(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n        //For each element in the triangles array.\r\n        //This var could contains 1 to an infinity of triangles\r\n        for (var k = 0; k < this._triangles.length; k++) {\r\n            // Set position indice\r\n            var indicePositionFromObj = parseInt(this._triangles[k]) - 1;\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                0, 0,                                       // In the pattern 1, normals and uvs are not defined\r\n                this._positions[indicePositionFromObj],     // Get the vectors data\r\n                Vector2.Zero(), Vector3.Up(),               // Create default vectors\r\n                this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined\r\n            );\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles = [];\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 2\r\n     * In this pattern we get vertice positions and uvsu\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern2(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n        for (var k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1/1\"\r\n            //Split the data for getting position and uv\r\n            var point = this._triangles[k].split(\"/\"); // [\"1\", \"1\"]\r\n            //Set position indice\r\n            var indicePositionFromObj = parseInt(point[0]) - 1;\r\n            //Set uv indice\r\n            var indiceUvsFromObj = parseInt(point[1]) - 1;\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                indiceUvsFromObj,\r\n                0,                                  //Default value for normals\r\n                this._positions[indicePositionFromObj],   //Get the values for each element\r\n                this._uvs[indiceUvsFromObj],\r\n                Vector3.Up(),                //Default value for normals\r\n                this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined\r\n            );\r\n        }\r\n\r\n        //Reset variable for the next line\r\n        this._triangles = [];\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 3\r\n     * In this pattern we get vertice positions, uvs and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern3(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n\r\n        for (var k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1/1/1\"\r\n            //Split the data for getting position, uv, and normals\r\n            var point = this._triangles[k].split(\"/\"); // [\"1\", \"1\", \"1\"]\r\n            // Set position indice\r\n            var indicePositionFromObj = parseInt(point[0]) - 1;\r\n            // Set uv indice\r\n            var indiceUvsFromObj = parseInt(point[1]) - 1;\r\n            // Set normal indice\r\n            var indiceNormalFromObj = parseInt(point[2]) - 1;\r\n\r\n            this._setData(\r\n                indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj,\r\n                this._positions[indicePositionFromObj], this._uvs[indiceUvsFromObj], this._normals[indiceNormalFromObj] //Set the vector for each component\r\n            );\r\n\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles = [];\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 4\r\n     * In this pattern we get vertice positions and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern4(face: Array<string>, v: number) {\r\n        this._getTriangles(face, v);\r\n\r\n        for (var k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1//1\"\r\n            //Split the data for getting position and normals\r\n            var point = this._triangles[k].split(\"//\"); // [\"1\", \"1\"]\r\n            // We check indices, and normals\r\n            var indicePositionFromObj = parseInt(point[0]) - 1;\r\n            var indiceNormalFromObj = parseInt(point[1]) - 1;\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                1, //Default value for uv\r\n                indiceNormalFromObj,\r\n                this._positions[indicePositionFromObj], //Get each vector of data\r\n                Vector2.Zero(),\r\n                this._normals[indiceNormalFromObj],\r\n                this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined\r\n            );\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles = [];\r\n    }\r\n\r\n    /*\r\n     * Create triangles and push the data for each polygon for the pattern 3\r\n     * In this pattern we get vertice positions, uvs and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern5(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n\r\n        for (var k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"-1/-1/-1\"\r\n            //Split the data for getting position, uv, and normals\r\n            var point = this._triangles[k].split(\"/\"); // [\"-1\", \"-1\", \"-1\"]\r\n            // Set position indice\r\n            var indicePositionFromObj = this._positions.length + parseInt(point[0]);\r\n            // Set uv indice\r\n            var indiceUvsFromObj = this._uvs.length + parseInt(point[1]);\r\n            // Set normal indice\r\n            var indiceNormalFromObj = this._normals.length + parseInt(point[2]);\r\n\r\n            this._setData(\r\n                indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj,\r\n                this._positions[indicePositionFromObj], this._uvs[indiceUvsFromObj], this._normals[indiceNormalFromObj], //Set the vector for each component\r\n                this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined\r\n            );\r\n\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles = [];\r\n    }\r\n\r\n    private _addPreviousObjMesh() {\r\n        //Check if it is not the first mesh. Otherwise we don't have data.\r\n        if (this._meshesFromObj.length > 0) {\r\n            //Get the previous mesh for applying the data about the faces\r\n            //=> in obj file, faces definition append after the name of the mesh\r\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\r\n\r\n            //Set the data into Array for the mesh\r\n            this._unwrapData();\r\n\r\n            // Reverse tab. Otherwise face are displayed in the wrong sens\r\n            this._indicesForBabylon.reverse();\r\n            //Set the information for the mesh\r\n            //Slice the array to avoid rewriting because of the fact this is the same var which be rewrited\r\n            this._handledMesh.indices = this._indicesForBabylon.slice();\r\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon.slice();\r\n            this._handledMesh.normals = this._unwrappedNormalsForBabylon.slice();\r\n            this._handledMesh.uvs = this._unwrappedUVForBabylon.slice();\r\n\r\n            if (this._loadingOptions.importVertexColors) {\r\n                this._handledMesh.colors = this._unwrappedColorsForBabylon.slice();\r\n            }\r\n\r\n            //Reset the array for the next mesh\r\n            this._indicesForBabylon = [];\r\n            this._unwrappedPositionsForBabylon = [];\r\n            this._unwrappedColorsForBabylon = [];\r\n            this._unwrappedNormalsForBabylon = [];\r\n            this._unwrappedUVForBabylon = [];\r\n        }\r\n    }\r\n\r\n    private _optimizeNormals(mesh: AbstractMesh): void {\r\n        const positions = mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const normals = mesh.getVerticesData(VertexBuffer.NormalKind);\r\n        const mapVertices: { [key: string]: number[] } = {};\r\n\r\n        if (!positions || !normals) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < positions.length / 3; i++) {\r\n            const x = positions[i * 3 + 0];\r\n            const y = positions[i * 3 + 1];\r\n            const z = positions[i * 3 + 2];\r\n            const key = x + \"_\" + y + \"_\" + z;\r\n\r\n            let lst = mapVertices[key];\r\n            if (!lst) {\r\n                lst = [];\r\n                mapVertices[key] = lst;\r\n            }\r\n            lst.push(i);\r\n        }\r\n\r\n        const normal = new Vector3();\r\n        for (const key in mapVertices) {\r\n            const lst = mapVertices[key];\r\n            if (lst.length < 2) {\r\n                continue;\r\n            }\r\n\r\n            const v0Idx = lst[0];\r\n            for (let i = 1; i < lst.length; ++i) {\r\n                const vIdx = lst[i];\r\n                normals[v0Idx * 3 + 0] += normals[vIdx * 3 + 0];\r\n                normals[v0Idx * 3 + 1] += normals[vIdx * 3 + 1];\r\n                normals[v0Idx * 3 + 2] += normals[vIdx * 3 + 2];\r\n            }\r\n\r\n            normal.copyFromFloats(normals[v0Idx * 3 + 0], normals[v0Idx * 3 + 1], normals[v0Idx * 3 + 2]);\r\n            normal.normalize();\r\n\r\n            for (let i = 0; i < lst.length; ++i) {\r\n                const vIdx = lst[i];\r\n                normals[vIdx * 3 + 0] = normal.x;\r\n                normals[vIdx * 3 + 1] = normal.y;\r\n                normals[vIdx * 3 + 2] = normal.z;\r\n            }\r\n        }\r\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\r\n    }\r\n\r\n    /**\r\n     * Function used to parse an OBJ string\r\n     * @param meshesNames defines the list of meshes to load (all if not defined)\r\n     * @param data defines the OBJ string\r\n     * @param scene defines the hosting scene\r\n     * @param assetContainer defines the asset container to load data in\r\n     * @param onFileToLoadFound defines a callback that will be called if a MTL file is found\r\n     */\r\n    public parse(\r\n        meshesNames: any, data: string, scene: Scene, assetContainer: Nullable<AssetContainer>, onFileToLoadFound: (fileToLoad: string) => void): void {\r\n        // Split the file into lines\r\n        var lines = data.split('\\n');\r\n        // Look at each line\r\n        for (var i = 0; i < lines.length; i++) {\r\n            var line = lines[i].trim().replace(/\\s\\s/g, \" \");\r\n            var result;\r\n\r\n            // Comment or newLine\r\n            if (line.length === 0 || line.charAt(0) === '#') {\r\n                continue;\r\n\r\n                //Get information about one position possible for the vertices\r\n            } else if (SolidParser.VertexPattern.test(line)) {\r\n                result = line.match(/[^ ]+/g)!;  // match will return non-null due to passing regex pattern\r\n\r\n                // Value of result with line: \"v 1.0 2.0 3.0\"\r\n                // [\"v\", \"1.0\", \"2.0\", \"3.0\"]\r\n                // Create a Vector3 with the position x, y, z\r\n                this._positions.push(new Vector3(\r\n                    parseFloat(result[1]),\r\n                    parseFloat(result[2]),\r\n                    parseFloat(result[3])\r\n                ));\r\n\r\n                if (this._loadingOptions.importVertexColors) {\r\n                    if (result.length >= 7) {\r\n                        const r = parseFloat(result[4]);\r\n                        const g = parseFloat(result[5]);\r\n                        const b = parseFloat(result[6]);\r\n\r\n                        this._colors.push(new Color4(\r\n                            r > 1 ? r / 255 : r,\r\n                            g > 1 ? g / 255 : g,\r\n                            b > 1 ? b / 255 : b,\r\n                            (result.length === 7 || result[7] === undefined) ? 1 : parseFloat(result[7])\r\n                        ));\r\n                    } else {\r\n                        // TODO: maybe push NULL and if all are NULL to skip (and remove grayColor var).\r\n                        this._colors.push(this._grayColor);\r\n                    }\r\n                }\r\n\r\n            } else if ((result = SolidParser.NormalPattern.exec(line)) !== null) {\r\n                //Create a Vector3 with the normals x, y, z\r\n                //Value of result\r\n                // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\r\n                //Add the Vector in the list of normals\r\n                this._normals.push(new Vector3(\r\n                    parseFloat(result[1]),\r\n                    parseFloat(result[2]),\r\n                    parseFloat(result[3])\r\n                ));\r\n\r\n            } else if ((result = SolidParser.UVPattern.exec(line)) !== null) {\r\n                //Create a Vector2 with the normals u, v\r\n                //Value of result\r\n                // [\"vt 0.1 0.2 0.3\", \"0.1\", \"0.2\"]\r\n                //Add the Vector in the list of uvs\r\n                this._uvs.push(new Vector2(\r\n                    parseFloat(result[1]) * this._loadingOptions.UVScaling.x,\r\n                    parseFloat(result[2]) * this._loadingOptions.UVScaling.y\r\n                ));\r\n\r\n                //Identify patterns of faces\r\n                //Face could be defined in different type of pattern\r\n            } else if ((result = SolidParser.FacePattern3.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1/1/1 2/2/2 3/3/3\", \"1/1/1 2/2/2 3/3/3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern3(\r\n                    result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\", \"3/3/3\"]\r\n                    1\r\n                );\r\n\r\n            } else if ((result = SolidParser.FacePattern4.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1//1 2//2 3//3\", \"1//1 2//2 3//3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern4(\r\n                    result[1].trim().split(\" \"), // [\"1//1\", \"2//2\", \"3//3\"]\r\n                    1\r\n                );\r\n\r\n            } else if ((result = SolidParser.FacePattern5.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f -1/-1/-1 -2/-2/-2 -3/-3/-3\", \"-1/-1/-1 -2/-2/-2 -3/-3/-3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern5(\r\n                    result[1].trim().split(\" \"), // [\"-1/-1/-1\", \"-2/-2/-2\", \"-3/-3/-3\"]\r\n                    1\r\n                );\r\n\r\n            } else if ((result = SolidParser.FacePattern2.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1/1 2/2 3/3\", \"1/1 2/2 3/3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern2(\r\n                    result[1].trim().split(\" \"), // [\"1/1\", \"2/2\", \"3/3\"]\r\n                    1\r\n                );\r\n\r\n            } else if ((result = SolidParser.FacePattern1.exec(line)) !== null) {\r\n                //Value of result\r\n                //[\"f 1 2 3\", \"1 2 3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern1(\r\n                    result[1].trim().split(\" \"), // [\"1\", \"2\", \"3\"]\r\n                    1\r\n                );\r\n\r\n                // Define a mesh or an object\r\n                // Each time this keyword is analysed, create a new Object with all data for creating a babylonMesh\r\n            } else if (SolidParser.GroupDescriptor.test(line) || SolidParser.ObjectDescriptor.test(line)) {\r\n                // Create a new mesh corresponding to the name of the group.\r\n                // Definition of the mesh\r\n                var objMesh: MeshObject = {\r\n                    name: line.substring(2).trim(), //Set the name of the current obj mesh\r\n                    indices: undefined,\r\n                    positions: undefined,\r\n                    normals: undefined,\r\n                    uvs: undefined,\r\n                    colors: undefined,\r\n                    materialName: \"\"\r\n                };\r\n                this._addPreviousObjMesh();\r\n\r\n                //Push the last mesh created with only the name\r\n                this._meshesFromObj.push(objMesh);\r\n\r\n                //Set this variable to indicate that now meshesFromObj has objects defined inside\r\n                this._hasMeshes = true;\r\n                this._isFirstMaterial = true;\r\n                this._increment = 1;\r\n                //Keyword for applying a material\r\n            } else if (SolidParser.UseMtlDescriptor.test(line)) {\r\n                //Get the name of the material\r\n                this._materialNameFromObj = line.substring(7).trim();\r\n\r\n                //If this new material is in the same mesh\r\n\r\n                if (!this._isFirstMaterial || !this._hasMeshes) {\r\n                    //Set the data for the previous mesh\r\n                    this._addPreviousObjMesh();\r\n                    //Create a new mesh\r\n                    var objMesh: MeshObject =\r\n                    //Set the name of the current obj mesh\r\n                    {\r\n                        name: (this._objMeshName || \"mesh\") + \"_mm\" + this._increment.toString(), //Set the name of the current obj mesh\r\n                        indices: undefined,\r\n                        positions: undefined,\r\n                        normals: undefined,\r\n                        uvs: undefined,\r\n                        colors: undefined,\r\n                        materialName: this._materialNameFromObj\r\n                    };\r\n                    this._increment++;\r\n                    //If meshes are already defined\r\n                    this._meshesFromObj.push(objMesh);\r\n                    this._hasMeshes = true;\r\n                }\r\n                //Set the material name if the previous line define a mesh\r\n\r\n                if (this._hasMeshes && this._isFirstMaterial) {\r\n                    //Set the material name to the previous mesh (1 material per mesh)\r\n                    this._meshesFromObj[this._meshesFromObj.length - 1].materialName = this._materialNameFromObj;\r\n                    this._isFirstMaterial = false;\r\n                }\r\n                // Keyword for loading the mtl file\r\n            } else if (SolidParser.MtlLibGroupDescriptor.test(line)) {\r\n                // Get the name of mtl file\r\n                onFileToLoadFound(line.substring(7).trim());\r\n\r\n                // Apply smoothing\r\n            } else if (SolidParser.SmoothDescriptor.test(line)) {\r\n                // smooth shading => apply smoothing\r\n                // Today I don't know it work with babylon and with obj.\r\n                // With the obj file  an integer is set\r\n            } else {\r\n                //If there is another possibility\r\n                console.log(\"Unhandled expression at line : \" + line);\r\n            }\r\n        }\r\n\r\n        // At the end of the file, add the last mesh into the meshesFromObj array\r\n        if (this._hasMeshes) {\r\n            // Set the data for the last mesh\r\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\r\n\r\n            //Reverse indices for displaying faces in the good sense\r\n            this._indicesForBabylon.reverse();\r\n            //Get the good array\r\n            this._unwrapData();\r\n            //Set array\r\n            this._handledMesh.indices = this._indicesForBabylon;\r\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon;\r\n            this._handledMesh.normals = this._unwrappedNormalsForBabylon;\r\n            this._handledMesh.uvs = this._unwrappedUVForBabylon;\r\n\r\n            if (this._loadingOptions.importVertexColors) {\r\n                this._handledMesh.colors = this._unwrappedColorsForBabylon;\r\n            }\r\n        }\r\n\r\n        // If any o or g keyword not found, create a mesh with a random id\r\n        if (!this._hasMeshes) {\r\n            let newMaterial: Nullable<StandardMaterial> = null;\r\n            if (this._indicesForBabylon.length) {\r\n                // reverse tab of indices\r\n                this._indicesForBabylon.reverse();\r\n                //Get positions normals uvs\r\n                this._unwrapData();\r\n            } else {\r\n                // There is no indices in the file. We will have to switch to point cloud rendering\r\n                for (var pos of this._positions) {\r\n                    this._unwrappedPositionsForBabylon.push(pos.x, pos.y, pos.z);\r\n                }\r\n\r\n                if (this._normals.length) {\r\n                    for (var normal of this._normals) {\r\n                        this._unwrappedNormalsForBabylon.push(normal.x, normal.y, normal.z);\r\n                    }\r\n                }\r\n\r\n                if (this._uvs.length) {\r\n                    for (var uv of this._uvs) {\r\n                        this._unwrappedUVForBabylon.push(uv.x, uv.y);\r\n                    }\r\n                }\r\n\r\n                if (this._colors.length) {\r\n                    for (var color of this._colors) {\r\n                        this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);\r\n                    }\r\n                }\r\n\r\n                if (!this._materialNameFromObj) {\r\n                    // Create a material with point cloud on\r\n                    newMaterial = new StandardMaterial(Geometry.RandomId(), scene);\r\n\r\n                    newMaterial.pointsCloud = true;\r\n\r\n                    this._materialNameFromObj = newMaterial.name;\r\n\r\n                    if (!this._normals.length) {\r\n                        newMaterial.disableLighting = true;\r\n                        newMaterial.emissiveColor = Color3.White();\r\n                    }\r\n                }\r\n            }\r\n\r\n            //Set data for one mesh\r\n            this._meshesFromObj.push({\r\n                name: Geometry.RandomId(),\r\n                indices: this._indicesForBabylon,\r\n                positions: this._unwrappedPositionsForBabylon,\r\n                colors: this._unwrappedColorsForBabylon,\r\n                normals: this._unwrappedNormalsForBabylon,\r\n                uvs: this._unwrappedUVForBabylon,\r\n                materialName: this._materialNameFromObj,\r\n                directMaterial: newMaterial\r\n            });\r\n        }\r\n\r\n        //Set data for each mesh\r\n        for (var j = 0; j < this._meshesFromObj.length; j++) {\r\n\r\n            //check meshesNames (stlFileLoader)\r\n            if (meshesNames && this._meshesFromObj[j].name) {\r\n                if (meshesNames instanceof Array) {\r\n                    if (meshesNames.indexOf(this._meshesFromObj[j].name) === -1) {\r\n                        continue;\r\n                    }\r\n                }\r\n                else {\r\n                    if (this._meshesFromObj[j].name !== meshesNames) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n\r\n            //Get the current mesh\r\n            //Set the data with VertexBuffer for each mesh\r\n            this._handledMesh = this._meshesFromObj[j];\r\n            //Create a Mesh with the name of the obj mesh\r\n\r\n            scene._blockEntityCollection = !!assetContainer;\r\n            var babylonMesh = new Mesh(this._meshesFromObj[j].name, scene);\r\n            babylonMesh._parentContainer = assetContainer;\r\n            scene._blockEntityCollection = false;\r\n\r\n            //Push the name of the material to an array\r\n            //This is indispensable for the importMesh function\r\n            this._materialToUse.push(this._meshesFromObj[j].materialName);\r\n\r\n            if (this._handledMesh.positions?.length === 0) {\r\n                //Push the mesh into an array\r\n                this._babylonMeshesArray.push(babylonMesh);\r\n                continue;\r\n            }\r\n\r\n            var vertexData: VertexData = new VertexData(); //The container for the values\r\n            //Set the data for the babylonMesh\r\n            vertexData.uvs = this._handledMesh.uvs as FloatArray;\r\n            vertexData.indices = this._handledMesh.indices as IndicesArray;\r\n            vertexData.positions = this._handledMesh.positions as FloatArray;\r\n            if (this._loadingOptions.computeNormals) {\r\n                let normals: Array<number> = new Array<number>();\r\n                VertexData.ComputeNormals(this._handledMesh.positions, this._handledMesh.indices, normals);\r\n                vertexData.normals = normals;\r\n            } else {\r\n                vertexData.normals = this._handledMesh.normals as FloatArray;\r\n            }\r\n            if (this._loadingOptions.importVertexColors) {\r\n                vertexData.colors = this._handledMesh.colors as FloatArray;\r\n            }\r\n            //Set the data from the VertexBuffer to the current Mesh\r\n            vertexData.applyToMesh(babylonMesh);\r\n            if (this._loadingOptions.invertY) {\r\n                babylonMesh.scaling.y *= -1;\r\n            }\r\n            if (this._loadingOptions.optimizeNormals) {\r\n                this._optimizeNormals(babylonMesh);\r\n            }\r\n\r\n            //Push the mesh into an array\r\n            this._babylonMeshesArray.push(babylonMesh);\r\n\r\n            if (this._handledMesh.directMaterial) {\r\n                babylonMesh.material = this._handledMesh.directMaterial;\r\n            }\r\n        }\r\n    }\r\n}","import * as Loaders from \"../OBJ/index\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nvar globalObject = (typeof global !== 'undefined') ? global : ((typeof window !== 'undefined') ? window : undefined);\r\nif (typeof globalObject !== \"undefined\") {\r\n    for (var key in Loaders) {\r\n        (<any>globalObject).BABYLON[key] = (<any>Loaders)[key];\r\n    }\r\n}\r\n\r\nexport * from \"../OBJ/index\";","module.exports = __WEBPACK_EXTERNAL_MODULE_babylonjs_Misc_observable__;"],"sourceRoot":""}