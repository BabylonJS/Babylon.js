var BABYLON;!(function(e){var r=(function(e){function r(r,t,o,a,n){var l=e.call(this,r,t,"normalMapProceduralTexture",o,a,n)||this;return l.updateShaderUniforms(),l}return __extends(r,e),r.prototype.updateShaderUniforms=function(){this.setTexture("baseSampler",this._baseTexture),this.setFloat("size",this.getRenderSize())},r.prototype.render=function(r){e.prototype.render.call(this,r)},r.prototype.resize=function(r,t){e.prototype.resize.call(this,r,t),this.updateShaderUniforms()},Object.defineProperty(r.prototype,"baseTexture",{get:function(){return this._baseTexture},set:function(e){this._baseTexture=e,this.updateShaderUniforms()},enumerable:!0,configurable:!0}),r})(e.ProceduralTexture);e.NormalMapProceduralTexture=r})(BABYLON||(BABYLON={})),BABYLON.Effect.ShadersStore.normalMapProceduralTexturePixelShader="precision highp float;\n\nuniform sampler2D baseSampler;\nuniform float size;\n\nvarying vec2 vUV;\n\nconst vec3 LUMA_COEFFICIENT=vec3(0.2126,0.7152,0.0722);\nfloat lumaAtCoord(vec2 coord)\n{\nvec3 pixel=texture2D(baseSampler,coord).rgb;\nfloat luma=dot(pixel,LUMA_COEFFICIENT);\nreturn luma;\n}\nvoid main()\n{\nfloat lumaU0=lumaAtCoord(vUV+vec2(-1.0,0.0)/size);\nfloat lumaU1=lumaAtCoord(vUV+vec2( 1.0,0.0)/size);\nfloat lumaV0=lumaAtCoord(vUV+vec2( 0.0,-1.0)/size);\nfloat lumaV1=lumaAtCoord(vUV+vec2( 0.0,1.0)/size);\nvec2 slope=(vec2(lumaU0-lumaU1,lumaV0-lumaV1)+1.0)*0.5;\ngl_FragColor=vec4(slope,1.0,1.0);\n}\n";