var BABYLON,__extends=this&&this.__extends||(function(){var t=function(e,r){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,r){e.__proto__=r}||function(e,r){for(var o in r)r.hasOwnProperty(o)&&(e[o]=r[o])})(e,r)};return function(e,r){function o(){this.constructor=e}t(e,r),e.prototype=null===r?Object.create(r):(o.prototype=r.prototype,new o)}})(),__decorate=this&&this.__decorate||function(e,r,o,t){var n,a=arguments.length,i=a<3?r:null===t?t=Object.getOwnPropertyDescriptor(r,o):t;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(e,r,o,t);else for(var c=e.length-1;0<=c;c--)(n=e[c])&&(i=(a<3?n(i):3<a?n(r,o,i):n(r,o))||i);return 3<a&&i&&Object.defineProperty(r,o,i),i};!(function(c){var e=(function(i){function t(e,r,o,t,n){var a=i.call(this,e,r,"roadProceduralTexture",o,t,n)||this;return a._roadColor=new c.Color3(.53,.53,.53),a.updateShaderUniforms(),a}return __extends(t,i),t.prototype.updateShaderUniforms=function(){this.setColor3("roadColor",this._roadColor)},Object.defineProperty(t.prototype,"roadColor",{get:function(){return this._roadColor},set:function(e){this._roadColor=e,this.updateShaderUniforms()},enumerable:!0,configurable:!0}),t.prototype.serialize=function(){var e=c.SerializationHelper.Serialize(this,i.prototype.serialize.call(this));return e.customType="BABYLON.RoadProceduralTexture",e},t.Parse=function(e,r,o){return c.SerializationHelper.Parse((function(){return new t(e.name,e._size,r,void 0,e._generateMipMaps)}),e,r,o)},__decorate([c.serializeAsColor3()],t.prototype,"roadColor",null),t})(c.ProceduralTexture);c.RoadProceduralTexture=e})(BABYLON||(BABYLON={})),BABYLON.Effect.ShadersStore.roadProceduralTexturePixelShader="precision highp float;\nvarying vec2 vUV; \nuniform vec3 roadColor;\nfloat rand(vec2 n) {\nreturn fract(cos(dot(n,vec2(12.9898,4.1414)))*43758.5453);\n}\nfloat noise(vec2 n) {\nconst vec2 d=vec2(0.0,1.0);\nvec2 b=floor(n),f=smoothstep(vec2(0.0),vec2(1.0),fract(n));\nreturn mix(mix(rand(b),rand(b+d.yx),f.x),mix(rand(b+d.xy),rand(b+d.yy),f.x),f.y);\n}\nfloat fbm(vec2 n) {\nfloat total=0.0,amplitude=1.0;\nfor (int i=0; i<4; i++) {\ntotal+=noise(n)*amplitude;\nn+=n;\namplitude*=0.5;\n}\nreturn total;\n}\nvoid main(void) {\nfloat ratioy=mod(gl_FragCoord.y*100.0 ,fbm(vUV*2.0));\nvec3 color=roadColor*ratioy;\ngl_FragColor=vec4(color,1.0);\n}";