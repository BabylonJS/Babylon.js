/// <reference path="./babylon.module.d.ts"/>
/// <reference path="./babylon.glTF2Interface.d.ts"/>
/// <reference path="./babylonjs.loaders.module.d.ts"/>

// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../../../../Tools/Gulp/babylonjs
//   ../../../../../Tools/Gulp/babylonjs-loaders
//   ../../../../../Tools/Gulp/babylonjs/Misc/observable
//   ../../../../../Tools/Gulp/babylonjs/Engines/engine
//   ../../../../../Tools/Gulp/babylonjs/Loading/sceneLoader
//   ../../../../../Tools/Gulp/babylonjs/scene
//   ../../../../../Tools/Gulp/babylonjs/Meshes/abstractMesh
//   ../../../../../Tools/Gulp/babylonjs/Particles/IParticleSystem
//   ../../../../../Tools/Gulp/babylonjs/Bones/skeleton
//   ../../../../../Tools/Gulp/babylonjs/Animations/animationGroup
//   ../../../../../Tools/Gulp/babylonjs/Animations/index
//   ../../../../../Tools/Gulp/babylonjs/types
//   ../../../../../Tools/Gulp/babylonjs/Materials/material
//   ../../../../../Tools/Gulp/babylonjs-gltf2interface
//   ../../../../../Tools/Gulp/babylonjs/Maths/math
//   ../../../../../Tools/Gulp/babylonjs-loaders/glTF/glTFFileLoader
//   ../../../../../Tools/Gulp/babylonjs/Materials/Textures/baseTexture
//   ../../../../../Tools/Gulp/babylonjs/Misc/sceneOptimizer
//   ../../../../../Tools/Gulp/babylonjs/Cameras/arcRotateCamera
//   ../../../../../Tools/Gulp/babylonjs/Lights/light
//   ../../../../../Tools/Gulp/babylonjs/Helpers/environmentHelper
//   ../../../../../Tools/Gulp/babylonjs/Cameras/VR/vrExperienceHelper
//   ../../../../../Tools/Gulp/babylonjs/PostProcesses/RenderPipeline/Pipelines/defaultRenderingPipeline
//   ../../../../../Tools/Gulp/babylonjs/Lights/shadowLight
//   ../../../../../Tools/Gulp/babylonjs-loaders/glTF/2.0/glTFLoaderExtension
//   ../../../../../Tools/Gulp/babylonjs/PostProcesses/depthOfFieldEffect
//   ../../../../../Tools/Gulp/babylonjs/Materials/Textures/cubeTexture

declare module 'babylonjs-viewer' {
    import { mapperManager } from 'babylonjs-viewer/configuration/mappers';
    import { viewerGlobals } from 'babylonjs-viewer/configuration/globals';
    import { viewerManager } from 'babylonjs-viewer/viewer/viewerManager';
    import { DefaultViewer } from 'babylonjs-viewer/viewer/defaultViewer';
    import { AbstractViewer } from 'babylonjs-viewer/viewer/viewer';
    import { telemetryManager } from 'babylonjs-viewer/managers/telemetryManager';
    import { ModelLoader } from 'babylonjs-viewer/loader/modelLoader';
    import { ViewerModel, ModelState } from 'babylonjs-viewer/model/viewerModel';
    import { AnimationPlayMode, AnimationState } from 'babylonjs-viewer/model/modelAnimation';
    import { ILoaderPlugin } from 'babylonjs-viewer/loader/plugins/loaderPlugin';
    import { AbstractViewerNavbarButton } from 'babylonjs-viewer/templating/viewerTemplatePlugin';
    import { registerCustomOptimizer } from 'babylonjs-viewer/optimizer/custom';
    /**
        * BabylonJS Viewer
        *
        * An HTML-Based viewer for 3D models, based on BabylonJS and its extensions.
        */
    import * as BABYLON from 'babylonjs';
    import 'babylonjs-loaders';
    import 'pepjs';
    import { InitTags } from 'babylonjs-viewer/initializer';
    let disableInit: boolean;
    /**
        * Dispose all viewers currently registered
        */
    function disposeAll(): void;
    const Version: string;
    export { BABYLON, Version, InitTags, DefaultViewer, AbstractViewer, viewerGlobals, telemetryManager, disableInit, viewerManager, mapperManager, disposeAll, ModelLoader, ViewerModel, AnimationPlayMode, AnimationState, ModelState, ILoaderPlugin, AbstractViewerNavbarButton, registerCustomOptimizer };
    export { GLTF2 } from 'babylonjs-loaders';
    export * from 'babylonjs-viewer/configuration';
}

declare module 'babylonjs-viewer/configuration/mappers' {
    import { ViewerConfiguration } from 'babylonjs-viewer/configuration/configuration';
    /**
        * This is the mapper's interface. Implement this function to create your own mapper and register it at the mapper manager
        */
    export interface IMapper {
            map(rawSource: any): ViewerConfiguration;
    }
    /**
        * The MapperManager manages the different implemented mappers.
        * It allows the user to register new mappers as well and use them to parse their own configuration data
        */
    export class MapperManager {
            /**
                * The default mapper is the JSON mapper.
                */
            static DefaultMapper: string;
            constructor();
            /**
                * Get a specific configuration mapper.
                *
                * @param type the name of the mapper to load
                */
            getMapper(type: string): IMapper;
            /**
                * Use this functio to register your own configuration mapper.
                * After a mapper is registered, it can be used to parse the specific type fo configuration to the standard ViewerConfiguration.
                * @param type the name of the mapper. This will be used to define the configuration type and/or to get the mapper
                * @param mapper The implemented mapper
                */
            registerMapper(type: string, mapper: IMapper): void;
            /**
                * Dispose the mapper manager and all of its mappers.
                */
            dispose(): void;
    }
    /**
        * mapperManager is a singleton of the type MapperManager.
        * The mapperManager can be disposed directly with calling mapperManager.dispose()
        * or indirectly with using BabylonViewer.disposeAll()
        */
    export let mapperManager: MapperManager;
}

declare module 'babylonjs-viewer/configuration/globals' {
    export class ViewerGlobals {
        disableInit: boolean;
        disableWebGL2Support: boolean;
        readonly version: string;
    }
    export let viewerGlobals: ViewerGlobals;
}

declare module 'babylonjs-viewer/viewer/viewerManager' {
    import { Observable } from 'babylonjs/Misc/observable';
    import { AbstractViewer } from 'babylonjs-viewer/viewer/viewer';
    /**
        * The viewer manager is the container for all viewers currently registered on this page.
        * It is possible to have more than one viewer on a single page.
        */
    export class ViewerManager {
            /**
                * A callback that will be triggered when a new viewer was added
                */
            onViewerAdded: (viewer: AbstractViewer) => void;
            /**
                * Will notify when a new viewer was added
                */
            onViewerAddedObservable: Observable<AbstractViewer>;
            /**
                * Will notify when a viewer was removed (disposed)
                */
            onViewerRemovedObservable: Observable<string>;
            constructor();
            /**
                * Adding a new viewer to the viewer manager and start tracking it.
                * @param viewer the viewer to add
                */
            addViewer(viewer: AbstractViewer): void;
            /**
                * remove a viewer from the viewer manager
                * @param viewer the viewer to remove
                */
            removeViewer(viewer: AbstractViewer): void;
            /**
                * Get a viewer by its baseId (if the container element has an ID, it is the this is. if not, a random id was assigned)
                * @param id the id of the HTMl element (or the viewer's, if none provided)
                */
            getViewerById(id: string): AbstractViewer;
            /**
                * Get a viewer using a container element
                * @param element the HTML element to search viewers associated with
                */
            getViewerByHTMLElement(element: HTMLElement): AbstractViewer | undefined;
            /**
                * Get a promise that will fullfil when this viewer was initialized.
                * Since viewer initialization and template injection is asynchronous, using the promise will guaranty that
                * you will get the viewer after everything was already configured.
                * @param id the viewer id to find
                */
            getViewerPromiseById(id: string): Promise<AbstractViewer>;
            /**
                * dispose the manager and all of its associated viewers
                */
            dispose(): void;
    }
    export let viewerManager: ViewerManager;
}

declare module 'babylonjs-viewer/viewer/defaultViewer' {
    import { ViewerConfiguration, IModelConfiguration } from 'babylonjs-viewer/configuration';
    import { Template } from 'babylonjs-viewer/templating/templateManager';
    import { TemplateManager } from 'babylonjs-viewer/templating/templateManager';
    import { AbstractViewerWithTemplate } from 'babylonjs-viewer/viewer/viewerWithTemplate';
    import { ViewerModel } from 'babylonjs-viewer/model/viewerModel';
    import { IViewerTemplatePlugin } from 'babylonjs-viewer/templating/viewerTemplatePlugin';
    /**
        * The Default viewer is the default implementation of the AbstractViewer.
        * It uses the templating system to render a new canvas and controls.
        */
    export class DefaultViewer extends AbstractViewerWithTemplate {
            containerElement: Element;
            /**
                * The corresponsing template manager of this viewer.
                */
            templateManager: TemplateManager;
            fullscreenElement?: Element;
            /**
                * Create a new default viewer
                * @param containerElement the element in which the templates will be rendered
                * @param initialConfiguration the initial configuration. Defaults to extending the default configuration
                */
            constructor(containerElement: Element, initialConfiguration?: ViewerConfiguration);
            registerTemplatePlugin(plugin: IViewerTemplatePlugin): void;
            /**
                * This will be executed when the templates initialize.
                */
            protected _onTemplatesLoaded(): Promise<import("babylonjs-viewer/viewer/viewer").AbstractViewer>;
            protected _initVR(): void;
            /**
                * Toggle fullscreen of the entire viewer
                */
            toggleFullscreen: () => void;
            /**
                * Preparing the container element to present the viewer
                */
            protected _prepareContainerElement(): void;
            /**
                * This function will configure the templates and update them after a model was loaded
                * It is mainly responsible to changing the title and subtitle etc'.
                * @param model the model to be used to configure the templates by
                */
            protected _configureTemplate(model?: ViewerModel): void;
            /**
                * This will load a new model to the default viewer
                * overriding the AbstractViewer's loadModel.
                * The scene will automatically be cleared of the old models, if exist.
                * @param model the configuration object (or URL) to load.
                */
            loadModel(model?: string | File | IModelConfiguration): Promise<ViewerModel>;
            /**
                * Show the overlay and the defined sub-screen.
                * Mainly used for help and errors
                * @param subScreen the name of the subScreen. Those can be defined in the configuration object
                */
            showOverlayScreen(subScreen: string): Promise<Template> | Promise<string>;
            /**
                * Hide the overlay screen.
                */
            hideOverlayScreen(): Promise<Template> | Promise<string>;
            /**
                * show the viewer (in case it was hidden)
                *
                * @param visibilityFunction an optional function to execute in order to show the container
                */
            show(visibilityFunction?: ((template: Template) => Promise<Template>)): Promise<Template>;
            /**
                * hide the viewer (in case it is visible)
                *
                * @param visibilityFunction an optional function to execute in order to hide the container
                */
            hide(visibilityFunction?: ((template: Template) => Promise<Template>)): Promise<Template>;
            /**
                * Show the loading screen.
                * The loading screen can be configured using the configuration object
                */
            showLoadingScreen(): Promise<Template> | Promise<string>;
            /**
                * Hide the loading screen
                */
            hideLoadingScreen(): Promise<Template> | Promise<string>;
            dispose(): void;
            protected _onConfigurationLoaded(configuration: ViewerConfiguration): void;
    }
}

declare module 'babylonjs-viewer/viewer/viewer' {
    import { Engine } from 'babylonjs/Engines/engine';
    import { ISceneLoaderPlugin, ISceneLoaderPluginAsync, SceneLoaderProgressEvent } from 'babylonjs/Loading/sceneLoader';
    import { Observable } from 'babylonjs/Misc/observable';
    import { Scene } from 'babylonjs/scene';
    import { IModelConfiguration, IObserversConfiguration, ViewerConfiguration } from 'babylonjs-viewer/configuration';
    import { ConfigurationContainer } from 'babylonjs-viewer/configuration/configurationContainer';
    import { RenderOnlyConfigurationLoader } from 'babylonjs-viewer/configuration/renderOnlyLoader';
    import { ModelLoader } from 'babylonjs-viewer/loader/modelLoader';
    import { ObservablesManager } from 'babylonjs-viewer/managers/observablesManager';
    import { SceneManager } from 'babylonjs-viewer/managers/sceneManager';
    import { ViewerModel } from 'babylonjs-viewer/model/viewerModel';
    /**
        * The AbstractViewer is the center of Babylon's viewer.
        * It is the basic implementation of the default viewer and is responsible of loading and showing the model and the templates
        */
    export abstract class AbstractViewer {
            containerElement: Element;
            /**
                * Babylon Engine corresponding with this viewer
                */
            engine: Engine;
            /**
                * The ID of this viewer. it will be generated randomly or use the HTML Element's ID.
                */
            readonly baseId: string;
            /**
                * The last loader used to load a model.
                * @deprecated
                */
            lastUsedLoader: ISceneLoaderPlugin | ISceneLoaderPluginAsync;
            /**
                * The ModelLoader instance connected with this viewer.
                */
            modelLoader: ModelLoader;
            /**
                * A flag that controls whether or not the render loop should be executed
                */
            runRenderLoop: boolean;
            /**
                * The scene manager connected with this viewer instance
                */
            sceneManager: SceneManager;
            /**
                * Will notify when the scene was initialized
                */
            readonly onSceneInitObservable: Observable<Scene>;
            /**
                * will notify when the engine was initialized
                */
            readonly onEngineInitObservable: Observable<Engine>;
            /**
                * Will notify when a new model was added to the scene.
                * Note that added does not neccessarily mean loaded!
                */
            readonly onModelAddedObservable: Observable<ViewerModel>;
            /**
                * will notify after every model load
                */
            readonly onModelLoadedObservable: Observable<ViewerModel>;
            /**
                * will notify when any model notify of progress
                */
            readonly onModelLoadProgressObservable: Observable<SceneLoaderProgressEvent>;
            /**
                * will notify when any model load failed.
                */
            readonly onModelLoadErrorObservable: Observable<{
                    message: string;
                    exception: any;
            }>;
            /**
                * Will notify when a model was removed from the scene;
                */
            readonly onModelRemovedObservable: Observable<ViewerModel>;
            /**
                * will notify when a new loader was initialized.
                * Used mainly to know when a model starts loading.
                */
            readonly onLoaderInitObservable: Observable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>;
            /**
                * Observers registered here will be executed when the entire load process has finished.
                */
            readonly onInitDoneObservable: Observable<AbstractViewer>;
            /**
                * Functions added to this observable will be executed on each frame rendered.
                */
            readonly onFrameRenderedObservable: Observable<AbstractViewer>;
            /**
                * Observers registered here will be executed when VR more is entered.
                */
            readonly onEnteringVRObservable: Observable<AbstractViewer>;
            /**
                * Observers registered here will be executed when VR mode is exited.
                */
            readonly onExitingVRObservable: Observable<AbstractViewer>;
            observablesManager: ObservablesManager;
            /**
                * The canvas associated with this viewer
                */
            protected _canvas: HTMLCanvasElement;
            /**
                * The (single) canvas of this viewer
                */
            readonly canvas: HTMLCanvasElement;
            /**
                * is this viewer disposed?
                */
            protected _isDisposed: boolean;
            /**
                * registered onBeforeRender functions.
                * This functions are also registered at the native scene. The reference can be used to unregister them.
                */
            protected _registeredOnBeforeRenderFunctions: Array<() => void>;
            /**
                * The configuration loader of this viewer
                */
            protected _configurationLoader: RenderOnlyConfigurationLoader;
            /**
                * Is the viewer already initialized. for internal use.
                */
            protected _isInit: boolean;
            protected _configurationContainer: ConfigurationContainer;
            readonly configurationContainer: ConfigurationContainer;
            protected getConfigurationLoader(): RenderOnlyConfigurationLoader;
            constructor(containerElement: Element, initialConfiguration?: ViewerConfiguration);
            /**
                * get the baseId of this viewer
                */
            getBaseId(): string;
            /**
                * Do we have a canvas to render on, and is it a part of the scene
                */
            isCanvasInDOM(): boolean;
            /**
             * Set the viewer's background rendering flag.
             */
            renderInBackground: boolean;
            /**
                * Get the configuration object. This is a reference only.
                * The configuration can ONLY be updated using the updateConfiguration function.
                * changing this object will have no direct effect on the scene.
                */
            readonly configuration: ViewerConfiguration;
            /**
                * force resizing the engine.
                */
            forceResize(): void;
            protected _hdToggled: boolean;
            toggleHD(): void;
            protected _vrToggled: boolean;
            protected _vrScale: number;
            protected _vrInit: boolean;
            toggleVR(): void;
            protected _initVR(): void;
            /**
                * The resize function that will be registered with the window object
                */
            protected _resize: () => void;
            protected _onConfigurationLoaded(configuration: ViewerConfiguration): void;
            /**
                * Force a single render loop execution.
                */
            forceRender(): void;
            /**
                * render loop that will be executed by the engine
                */
            protected _render: (force?: boolean) => void;
            /**
                * Takes a screenshot of the scene and returns it as a base64 encoded png.
                * @param callback optional callback that will be triggered when screenshot is done.
                * @param width Optional screenshot width (default to 512).
                * @param height Optional screenshot height (default to 512).
                * @returns a promise with the screenshot data
                */
            takeScreenshot(callback?: (data: string) => void, width?: number, height?: number): Promise<string>;
            /**
                * Update the current viewer configuration with new values.
                * Only provided information will be updated, old configuration values will be kept.
                * If this.configuration was manually changed, you can trigger this function with no parameters,
                * and the entire configuration will be updated.
                * @param newConfiguration the partial configuration to update or a URL to a JSON holding the updated configuration
                *
                */
            updateConfiguration(newConfiguration?: Partial<ViewerConfiguration> | string): void;
            /**
                * this is used to register native functions using the configuration object.
                * This will configure the observers.
                * @param observersConfiguration observers configuration
                */
            protected _configureObservers(observersConfiguration: IObserversConfiguration): void;
            /**
                * Dispose the entire viewer including the scene and the engine
                */
            dispose(): void;
            /**
                * This will prepare the container element for the viewer
                */
            protected abstract _prepareContainerElement(): any;
            /**
                * This function will execute when the HTML templates finished initializing.
                * It should initialize the engine and continue execution.
                *
                * @returns {Promise<AbstractViewer>} The viewer object will be returned after the object was loaded.
                */
            protected _onTemplatesLoaded(): Promise<AbstractViewer>;
            /**
                * This will force the creation of an engine and a scene.
                * It will also load a model if preconfigured.
                * But first - it will load the extendible onTemplateLoaded()!
                */
            protected _onTemplateLoaded(): Promise<AbstractViewer>;
            /**
                * Initialize the engine. Retruns a promise in case async calls are needed.
                *
                * @protected
                * @returns {Promise<Engine>}
                * @memberof Viewer
                */
            protected _initEngine(): Promise<Engine>;
            /**
                * Initialize a model loading. The returned object (a ViewerModel object) will be loaded in the background.
                * The difference between this and loadModel is that loadModel will fulfill the promise when the model finished loading.
                *
                * @param modelConfig model configuration to use when loading the model.
                * @param clearScene should the scene be cleared before loading this model
                * @returns a ViewerModel object that is not yet fully loaded.
                */
            initModel(modelConfig: string | File | IModelConfiguration, clearScene?: boolean): ViewerModel;
            /**
                * load a model using the provided configuration.
                * This function, as opposed to initModel, will return a promise that resolves when the model is loaded, and rejects with error.
                * If you want to attach to the observables of the model, use initModle instead.
                *
                * @param modelConfig the model configuration or URL to load.
                * @param clearScene Should the scene be cleared before loading the model
                * @returns a Promise the fulfills when the model finished loading successfully.
                */
            loadModel(modelConfig: string | File | IModelConfiguration, clearScene?: boolean): Promise<ViewerModel>;
            protected _initTelemetryEvents(): void;
            /**
                * Injects all the spectre shader in the babylon shader store
                */
            protected _injectCustomShaders(): void;
    }
}

declare module 'babylonjs-viewer/managers/telemetryManager' {
    import { Observable } from "babylonjs/Misc/observable";
    import { Engine } from "babylonjs/Engines/engine";
    /**
        * The data structure of a telemetry event.
        */
    export interface TelemetryData {
            event: string;
            session: string;
            date: Date;
            now: number;
            viewerId?: string;
            detail: any;
    }
    /**
        * Receives Telemetry events and raises events to the API
        */
    export class TelemetryManager {
            onEventBroadcastedObservable: Observable<TelemetryData>;
            /**
                * Receives a telemetry event
                * @param event The name of the Telemetry event
                * @param details An additional value, or an object containing a list of property/value pairs
                */
            readonly broadcast: (event: string, viewerId?: string | undefined, details?: any) => void;
            /**
                * Log a Telemetry event for errors raised on the WebGL context.
                * @param engine The Babylon engine with the WebGL context.
                */
            flushWebGLErrors(engine: Engine, viewerId?: string): void;
            /**
                * Enable or disable telemetry events
                * @param enabled Boolan, true if events are enabled
                */
            enable: boolean;
            /**
                * Returns the current session ID or creates one if it doesn't exixt
                * @return The current session ID
                */
            readonly session: string;
            /**
                * Disposes the telemetry manager
                */
            dispose(): void;
    }
    export const telemetryManager: TelemetryManager;
}

declare module 'babylonjs-viewer/loader/modelLoader' {
    import { ConfigurationContainer } from 'babylonjs-viewer/configuration/configurationContainer';
    import { IModelConfiguration } from 'babylonjs-viewer/configuration/interfaces/modelConfiguration';
    import { ObservablesManager } from 'babylonjs-viewer/managers/observablesManager';
    import { ViewerModel } from 'babylonjs-viewer/model/viewerModel';
    import { ILoaderPlugin } from 'babylonjs-viewer/loader/plugins';
    /**
        * An instance of the class is in charge of loading the model correctly.
        * This class will continously be expended with tasks required from the specific loaders Babylon has.
        *
        * A Model loader is unique per (Abstract)Viewer. It is being generated by the viewer
        */
    export class ModelLoader {
            readonly baseUrl: string;
            /**
                * Create a new Model loader
                * @param _viewer the viewer using this model loader
                */
            constructor(_observablesManager: ObservablesManager, _configurationContainer?: ConfigurationContainer | undefined);
            /**
                * Adds a new plugin to the loader process.
                *
                * @param plugin the plugin name or the plugin itself
                */
            addPlugin(plugin: ILoaderPlugin | string): void;
            /**
                * Load a model using predefined configuration
                * @param modelConfiguration the modelConfiguration to use to load the model
                */
            load(modelConfiguration: IModelConfiguration): ViewerModel;
            cancelLoad(model: ViewerModel): void;
            /**
                * dispose the model loader.
                * If loaders are registered and are in the middle of loading, they will be disposed and the request(s) will be cancelled.
                */
            dispose(): void;
    }
}

declare module 'babylonjs-viewer/model/viewerModel' {
    import { IDisposable } from "babylonjs/scene";
    import { ISceneLoaderPlugin, ISceneLoaderPluginAsync } from "babylonjs/Loading/sceneLoader";
    import { AbstractMesh } from "babylonjs/Meshes/abstractMesh";
    import { IParticleSystem } from "babylonjs/Particles/IParticleSystem";
    import { Skeleton } from "babylonjs/Bones/skeleton";
    import { Observable } from "babylonjs/Misc/observable";
    import { SceneLoaderProgressEvent } from "babylonjs/Loading/sceneLoader";
    import { AnimationGroup } from "babylonjs/Animations/animationGroup";
    import { Animation } from "babylonjs/Animations/index";
    import { Nullable } from "babylonjs/types";
    import { Material } from "babylonjs/Materials/material";
    import { IAsset } from "babylonjs-gltf2interface";
    import { IModelConfiguration } from "babylonjs-viewer/configuration/interfaces/modelConfiguration";
    import { IModelAnimation } from "babylonjs-viewer/model/modelAnimation";
    import { ObservablesManager } from "babylonjs-viewer/managers/observablesManager";
    import { ConfigurationContainer } from "babylonjs-viewer/configuration/configurationContainer";
    /**
        * The current state of the model
        */
    export enum ModelState {
            INIT = 0,
            LOADING = 1,
            LOADED = 2,
            ENTRY = 3,
            ENTRYDONE = 4,
            COMPLETE = 5,
            CANCELED = 6,
            ERROR = 7
    }
    /**
        * The viewer model is a container for all assets representing a sngle loaded model.
        */
    export class ViewerModel implements IDisposable {
            /**
                * The loader used to load this model.
                */
            loader: ISceneLoaderPlugin | ISceneLoaderPluginAsync;
            /**
                * This model's root mesh (the parent of all other meshes).
                * This mesh does not(!) exist in the meshes array.
                */
            rootMesh: AbstractMesh;
            /**
                * ParticleSystems connected to this model
                */
            particleSystems: Array<IParticleSystem>;
            /**
                * Skeletons defined in this model
                */
            skeletons: Array<Skeleton>;
            /**
                * The current model animation.
                * On init, this will be undefined.
                */
            currentAnimation: IModelAnimation;
            /**
                * Observers registered here will be executed when the model is done loading
                */
            onLoadedObservable: Observable<ViewerModel>;
            /**
                * Observers registered here will be executed when the loader notified of a progress event
                */
            onLoadProgressObservable: Observable<SceneLoaderProgressEvent>;
            /**
                * Observers registered here will be executed when the loader notified of an error.
                */
            onLoadErrorObservable: Observable<{
                    message: string;
                    exception: any;
            }>;
            /**
                * Will be executed after the model finished loading and complete, including entry animation and lod
                */
            onCompleteObservable: Observable<ViewerModel>;
            /**
                * Observers registered here will be executed every time the model is being configured.
                * This can be used to extend the model's configuration without extending the class itself
                */
            onAfterConfigure: Observable<ViewerModel>;
            /**
                * The current model state (loaded, error, etc)
                */
            state: ModelState;
            /**
                * A loadID provided by the modelLoader, unique to ths (Abstract)Viewer instance.
                */
            loadId: number;
            loadInfo: IAsset;
            constructor(_observablesManager: ObservablesManager, modelConfiguration: IModelConfiguration, _configurationContainer?: ConfigurationContainer | undefined);
            shadowsRenderedAfterLoad: boolean;
            getViewerId(): string | undefined;
            /**
             * Set whether this model is enabled or not.
             */
            enabled: boolean;
            loaderDone: boolean;
            /**
                * Add a mesh to this model.
                * Any mesh that has no parent will be provided with the root mesh as its new parent.
                *
                * @param mesh the new mesh to add
                * @param triggerLoaded should this mesh trigger the onLoaded observable. Used when adding meshes manually.
                */
            addMesh(mesh: AbstractMesh, triggerLoaded?: boolean): Promise<ViewerModel> | undefined;
            /**
                * get the list of meshes (excluding the root mesh)
                */
            readonly meshes: AbstractMesh[];
            /**
             * (Re-)set the model's entire configuration
             * @param newConfiguration the new configuration to replace the new one
             */
            configuration: IModelConfiguration;
            /**
                * Update the current configuration with new values.
                * Configuration will not be overwritten, but merged with the new configuration.
                * Priority is to the new configuration
                * @param newConfiguration the configuration to be merged into the current configuration;
                */
            updateConfiguration(newConfiguration: Partial<IModelConfiguration>): void;
            /**
                * Add a new animation group to this model.
                * @param animationGroup the new animation group to be added
                */
            addAnimationGroup(animationGroup: AnimationGroup): void;
            /**
                * Get the ModelAnimation array
                */
            getAnimations(): Array<IModelAnimation>;
            /**
                * Get the animations' names. Using the names you can play a specific animation.
                */
            getAnimationNames(): Array<string>;
            /**
                * Get an animation by the provided name. Used mainly when playing n animation.
                * @param name the name of the animation to find
                */
            protected _getAnimationByName(name: string): Nullable<IModelAnimation>;
            /**
                * Choose an initialized animation using its name and start playing it
                * @param name the name of the animation to play
                * @returns The model aniamtion to be played.
                */
            playAnimation(name: string): IModelAnimation;
            setCurrentAnimationByName(name: string): IModelAnimation;
            /**
                * Apply a material configuration to a material
                * @param material Material to apply configuration to
                * @hidden
                */
            _applyModelMaterialConfiguration(material: Material): void;
            /**
             * Begin @animations with the specified @easingFunction
             * @param animations The BABYLON Animations to begin
             * @param duration of transition, in seconds
             * @param easingFunction An easing function to apply
             * @param easingMode A easing mode to apply to the easingFunction
             * @param onAnimationEnd Call back trigger at the end of the animation.
             */
            transitionTo(animations: Animation[], duration: number, easingFunction: any, easingMode: number | undefined, // BABYLON.EasingFunction.EASINGMODE_EASEINOUT,
            onAnimationEnd: () => void): void;
            /**
                * Stops and removes all animations that have been applied to the model
                */
            stopAllAnimations(): void;
            /**
                * Will remove this model from the viewer (but NOT dispose it).
                */
            remove(): void;
            /**
                * Dispose this model, including all of its associated assets.
                */
            dispose(): void;
    }
}

declare module 'babylonjs-viewer/model/modelAnimation' {
    import { Vector3 } from "babylonjs/Maths/math";
    import { AnimationGroup } from "babylonjs/Animations/index";
    /**
        * Animation play mode enum - is the animation looping or playing once
        */
    export const enum AnimationPlayMode {
            ONCE = 0,
            LOOP = 1
    }
    /**
        * An enum representing the current state of an animation object
        */
    export const enum AnimationState {
            INIT = 0,
            PLAYING = 1,
            PAUSED = 2,
            STOPPED = 3,
            ENDED = 4
    }
    /**
        * The different type of easing functions available
        */
    export const enum EasingFunction {
            Linear = 0,
            CircleEase = 1,
            BackEase = 2,
            BounceEase = 3,
            CubicEase = 4,
            ElasticEase = 5,
            ExponentialEase = 6,
            PowerEase = 7,
            QuadraticEase = 8,
            QuarticEase = 9,
            QuinticEase = 10,
            SineEase = 11
    }
    /**
        * Defines a simple animation to be applied to a model (scale).
        */
    export interface ModelAnimationConfiguration {
            /**
                * Time of animation, in seconds
                */
            time: number;
            /**
                * Scale to apply
                */
            scaling?: Vector3;
            /**
                * Easing function to apply
                * See SPECTRE.EasingFunction
                */
            easingFunction?: number;
            /**
                * An Easing mode to apply to the easing function
                * See BABYLON.EasingFunction
                */
            easingMode?: number;
    }
    /**
        * This interface can be implemented to define new types of ModelAnimation objects.
        */
    export interface IModelAnimation {
            /**
                * Current animation state (playing, stopped etc')
                */
            readonly state: AnimationState;
            /**
                * the name of the animation
                */
            readonly name: string;
            /**
                * Get the max numbers of frame available in the animation group
                *
                * In correlation to an arry, this would be ".length"
                */
            readonly frames: number;
            /**
                * Get the current frame playing right now.
                * This can be used to poll the frame currently playing (and, for exmaple, display a progress bar with the data)
                *
                * In correlation to an array, this would be the current index
                */
            readonly currentFrame: number;
            /**
                * Animation's FPS value
                */
            readonly fps: number;
            /**
                * Get or set the animation's speed ration (Frame-to-fps)
                */
            speedRatio: number;
            /**
                * Gets or sets the aimation's play mode.
                */
            playMode: AnimationPlayMode;
            /**
                * Start the animation
                */
            start(): any;
            /**
                * Stop the animation.
                * This will fail silently if the animation group is already stopped.
                */
            stop(): any;
            /**
                * Pause the animation
                * This will fail silently if the animation is not currently playing
                */
            pause(): any;
            /**
                * Reset this animation
                */
            reset(): any;
            /**
                * Restart the animation
                */
            restart(): any;
            /**
                * Go to a specific
                * @param frameNumber the frame number to go to
                */
            goToFrame(frameNumber: number): any;
            /**
                * Dispose this animation
                */
            dispose(): any;
    }
    /**
        * The GroupModelAnimation is an implementation of the IModelAnimation interface using BABYLON's
        * native GroupAnimation class.
        */
    export class GroupModelAnimation implements IModelAnimation {
            /**
                * Create a new GroupModelAnimation object using an AnimationGroup object
                * @param _animationGroup The aniamtion group to base the class on
                */
            constructor(_animationGroup: AnimationGroup);
            /**
                * Get the animation's name
                */
            readonly name: string;
            /**
                * Get the current animation's state
                */
            readonly state: AnimationState;
            /**
             * Sets the speed ratio to use for all animations
             */
            speedRatio: number;
            /**
                * Get the max numbers of frame available in the animation group
                *
                * In correlation to an arry, this would be ".length"
                */
            readonly frames: number;
            /**
                * Get the current frame playing right now.
                * This can be used to poll the frame currently playing (and, for exmaple, display a progress bar with the data)
                *
                * In correlation to an array, this would be the current index
                */
            readonly currentFrame: number;
            /**
                * Get the FPS value of this animation
                */
            readonly fps: number;
            /**
             * Set the play mode.
             * If the animation is played, it will continue playing at least once more, depending on the new play mode set.
             * If the animation is not set, the will be initialized and will wait for the user to start playing it.
             */
            playMode: AnimationPlayMode;
            /**
                * Reset the animation group
                */
            reset(): void;
            /**
                * Restart the animation group
                */
            restart(): void;
            /**
                *
                * @param frameNumber Go to a specific frame in the animation
                */
            goToFrame(frameNumber: number): void;
            /**
                * Start playing the animation.
                */
            start(): void;
            /**
                * Pause the animation
                */
            pause(): void;
            /**
                * Stop the animation.
                * This will fail silently if the animation group is already stopped.
                */
            stop(): void;
            /**
                * Dispose this animation object.
                */
            dispose(): void;
    }
}

declare module 'babylonjs-viewer/loader/plugins/loaderPlugin' {
    import { ViewerModel } from "babylonjs-viewer/model/viewerModel";
    import { IGLTFLoaderExtension, IGLTFLoaderData } from "babylonjs-loaders/glTF/glTFFileLoader";
    import { ISceneLoaderPlugin, ISceneLoaderPluginAsync } from "babylonjs/Loading/sceneLoader";
    import { SceneLoaderProgressEvent } from "babylonjs/Loading/sceneLoader";
    import { AbstractMesh } from "babylonjs/Meshes/abstractMesh";
    import { BaseTexture } from "babylonjs/Materials/Textures/baseTexture";
    import { Material } from "babylonjs/Materials/material";
    /**
      * This interface defines the structure of a loader plugin.
      * Any of those functions will be called if (!) the loader supports those callbacks.
      * Any loader supports onInit, onLoaded, onError and onProgress.
      */
    export interface ILoaderPlugin {
        onInit?: (loader: ISceneLoaderPlugin | ISceneLoaderPluginAsync, model: ViewerModel) => void;
        onLoaded?: (model: ViewerModel) => void;
        onError?: (message: string, exception?: any) => void;
        onProgress?: (progressEvent: SceneLoaderProgressEvent) => void;
        onExtensionLoaded?: (extension: IGLTFLoaderExtension) => void;
        onParsed?: (parsedData: IGLTFLoaderData) => void;
        onMeshLoaded?: (mesh: AbstractMesh) => void;
        onTextureLoaded?: (texture: BaseTexture) => void;
        onMaterialLoaded?: (material: Material) => void;
        onComplete?: () => void;
    }
}

declare module 'babylonjs-viewer/templating/viewerTemplatePlugin' {
    import { EventCallback, Template } from "babylonjs-viewer/templating/templateManager";
    export interface IViewerTemplatePlugin {
        readonly templateName: string;
        readonly eventsToAttach?: Array<string>;
        interactionPredicate(event: EventCallback): boolean;
        onEvent?(event: EventCallback): void;
        addHTMLTemplate?(template: Template): void;
    }
    export abstract class AbstractViewerNavbarButton implements IViewerTemplatePlugin {
        readonly templateName: string;
        readonly eventsToAttach: Array<string>;
        protected _prepend: boolean;
        protected _buttonName: string;
        protected _buttonClass: string;
        protected _htmlTemplate: string;
        constructor(buttonName: string, buttonClass?: string, htmlTemplate?: string);
        interactionPredicate(event: EventCallback): boolean;
        abstract onEvent(event: EventCallback): void;
        addHTMLTemplate(template: Template): void;
        protected _generateHTMLElement(template: Template): Element | DocumentFragment;
    }
}

declare module 'babylonjs-viewer/optimizer/custom' {
    import { extendedUpgrade } from "babylonjs-viewer/optimizer/custom/extended";
    import { SceneManager } from "babylonjs-viewer/managers/sceneManager";
    /**
      *
      * @param name the name of the custom optimizer configuration
      * @param upgrade set to true if you want to upgrade optimizer and false if you want to degrade
      */
    export function getCustomOptimizerByName(name: string, upgrade?: boolean): typeof extendedUpgrade;
    export function registerCustomOptimizer(name: string, optimizer: (sceneManager: SceneManager) => boolean): void;
}

declare module 'babylonjs-viewer/initializer' {
    /**
        * Will attach an init function the the DOMContentLoaded event.
        * The init function will be removed automatically after the event was triggered.
        */
    export function initListeners(): void;
    /**
        * Select all HTML tags on the page that match the selector and initialize a viewer
        *
        * @param selector the selector to initialize the viewer on (default is 'babylon')
        */
    export function InitTags(selector?: string): void;
}

declare module 'babylonjs-viewer/configuration' {
    export * from 'babylonjs-viewer/configuration/configuration';
    export * from 'babylonjs-viewer/configuration/interfaces';
}

declare module 'babylonjs-viewer/configuration/configuration' {
    import { EngineOptions } from 'babylonjs/Engines/engine';
    import { ICameraConfiguration, IDefaultRenderingPipelineConfiguration, IGroundConfiguration, ILightConfiguration, IModelConfiguration, IObserversConfiguration, ISceneConfiguration, ISceneOptimizerConfiguration, ISkyboxConfiguration, ITemplateConfiguration, IVRConfiguration } from 'babylonjs-viewer/configuration/interfaces';
    import { IEnvironmentMapConfiguration } from 'babylonjs-viewer/configuration/interfaces/environmentMapConfiguration';
    export function getConfigurationKey(key: string, configObject: any): any;
    export interface ViewerConfiguration {
            version?: string;
            extends?: string;
            pageUrl?: string;
            configuration?: string | {
                    url?: string;
                    payload?: any;
                    mapper?: string;
            };
            observers?: IObserversConfiguration;
            canvasElement?: string;
            model?: IModelConfiguration | string;
            scene?: ISceneConfiguration;
            optimizer?: ISceneOptimizerConfiguration | boolean;
            camera?: ICameraConfiguration;
            skybox?: boolean | ISkyboxConfiguration;
            ground?: boolean | IGroundConfiguration;
            lights?: {
                    [name: string]: number | boolean | ILightConfiguration;
            };
            engine?: {
                    renderInBackground?: boolean;
                    antialiasing?: boolean;
                    disableResize?: boolean;
                    engineOptions?: EngineOptions;
                    adaptiveQuality?: boolean;
                    hdEnabled?: boolean;
            };
            templates?: {
                    main: ITemplateConfiguration;
                    [key: string]: ITemplateConfiguration;
            };
            customShaders?: {
                    shaders?: {
                            [key: string]: string;
                    };
                    includes?: {
                            [key: string]: string;
                    };
            };
            loaderPlugins?: {
                    extendedMaterial?: boolean;
                    msftLod?: boolean;
                    telemetry?: boolean;
                    minecraft?: boolean;
                    [propName: string]: boolean | undefined;
            };
            environmentMap?: IEnvironmentMapConfiguration;
            vr?: IVRConfiguration;
            lab?: {
                    flashlight?: boolean | {
                            exponent?: number;
                            angle?: number;
                            intensity?: number;
                            diffuse?: {
                                    r: number;
                                    g: number;
                                    b: number;
                            };
                            specular?: {
                                    r: number;
                                    g: number;
                                    b: number;
                            };
                    };
                    hideLoadingDelay?: number;
                    /** Deprecated */
                    assetsRootURL?: string;
                    environmentMainColor?: {
                            r: number;
                            g: number;
                            b: number;
                    };
                    /** Deprecated */
                    environmentMap?: {
                            /**
                                * Environment map texture path in relative to the asset folder.
                                */
                            texture: string;
                            /**
                                * Default rotation to apply to the environment map.
                                */
                            rotationY: number;
                            /**
                                * Tint level of the main color on the environment map.
                                */
                            tintLevel: number;
                    };
                    defaultRenderingPipelines?: boolean | IDefaultRenderingPipelineConfiguration;
                    globalLightRotation?: number;
            };
    }
}

declare module 'babylonjs-viewer/templating/templateManager' {
    import { Observable } from 'babylonjs/Misc/observable';
    import { EventManager } from 'babylonjs-viewer/templating/eventManager';
    import { ITemplateConfiguration } from 'babylonjs-viewer/configuration/interfaces';
    /**
        * The object sent when an event is triggered
        */
    export interface EventCallback {
            event: Event;
            template: Template;
            selector: string;
            payload?: any;
    }
    /**
        * The template manager, a member of the viewer class, will manage the viewer's templates and generate the HTML.
        * The template manager managers a single viewer and can be seen as the collection of all sub-templates of the viewer.
        */
    export class TemplateManager {
            containerElement: Element;
            /**
                * Will be triggered when any template is initialized
                */
            onTemplateInit: Observable<Template>;
            /**
                * Will be triggered when any template is fully loaded
                */
            onTemplateLoaded: Observable<Template>;
            /**
                * Will be triggered when a template state changes
                */
            onTemplateStateChange: Observable<Template>;
            /**
                * Will be triggered when all templates finished loading
                */
            onAllLoaded: Observable<TemplateManager>;
            /**
                * Will be triggered when any event on any template is triggered.
                */
            onEventTriggered: Observable<EventCallback>;
            /**
                * This template manager's event manager. In charge of callback registrations to native event types
                */
            eventManager: EventManager;
            constructor(containerElement: Element);
            /**
                * Initialize the template(s) for the viewer. Called bay the Viewer class
                * @param templates the templates to be used to initialize the main template
                */
            initTemplate(templates: {
                    [key: string]: ITemplateConfiguration;
            }): Promise<void>;
            /**
                * Get the canvas in the template tree.
                * There must be one and only one canvas inthe template.
                */
            getCanvas(): HTMLCanvasElement | null;
            /**
                * Get a specific template from the template tree
                * @param name the name of the template to load
                */
            getTemplate(name: string): Template | undefined;
            /**
                * Dispose the template manager
                */
            dispose(): void;
    }
    /**
        * This class represents a single template in the viewer's template tree.
        * An example for a template is a single canvas, an overlay (containing sub-templates) or the navigation bar.
        * A template is injected using the template manager in the correct position.
        * The template is rendered using Handlebars and can use Handlebars' features (such as parameter injection)
        *
        * For further information please refer to the documentation page, https://doc.babylonjs.com
        */
    export class Template {
            name: string;
            /**
                * Will be triggered when the template is loaded
                */
            onLoaded: Observable<Template>;
            /**
                * will be triggered when the template is appended to the tree
                */
            onAppended: Observable<Template>;
            /**
                * Will be triggered when the template's state changed (shown, hidden)
                */
            onStateChange: Observable<Template>;
            /**
                * Will be triggered when an event is triggered on ths template.
                * The event is a native browser event (like mouse or pointer events)
                */
            onEventTriggered: Observable<EventCallback>;
            onParamsUpdated: Observable<Template>;
            onHTMLRendered: Observable<Template>;
            /**
                * is the template loaded?
                */
            isLoaded: boolean;
            /**
                * This is meant to be used to track the show and hide functions.
                * This is NOT (!!) a flag to check if the element is actually visible to the user.
                */
            isShown: boolean;
            /**
                * Is this template a part of the HTML tree (the template manager injected it)
                */
            isInHtmlTree: boolean;
            /**
                * The HTML element containing this template
                */
            parent: HTMLElement;
            /**
                * A promise that is fulfilled when the template finished loading.
                */
            initPromise: Promise<Template>;
            constructor(name: string, _configuration: ITemplateConfiguration);
            /**
                * Some templates have parameters (like background color for example).
                * The parameters are provided to Handlebars which in turn generates the template.
                * This function will update the template with the new parameters
                *
                * Note that when updating parameters the events will be registered again (after being cleared).
                *
                * @param params the new template parameters
                */
            updateParams(params: {
                    [key: string]: string | number | boolean | object;
            }, append?: boolean): void;
            redraw(): void;
            /**
                * Get the template'S configuration
                */
            readonly configuration: ITemplateConfiguration;
            /**
                * A template can be a parent element for other templates or HTML elements.
                * This function will deliver all child HTML elements of this template.
                */
            getChildElements(): Array<string>;
            /**
                * Appending the template to a parent HTML element.
                * If a parent is already set and you wish to replace the old HTML with new one, forceRemove should be true.
                * @param parent the parent to which the template is added
                * @param forceRemove if the parent already exists, shoud the template be removed from it?
                */
            appendTo(parent: HTMLElement, forceRemove?: boolean): void;
            /**
                * Show the template using the provided visibilityFunction, or natively using display: flex.
                * The provided function returns a promise that should be fullfilled when the element is shown.
                * Since it is a promise async operations are more than possible.
                * See the default viewer for an opacity example.
                * @param visibilityFunction The function to execute to show the template.
                */
            show(visibilityFunction?: (template: Template) => Promise<Template>): Promise<Template>;
            /**
                * Hide the template using the provided visibilityFunction, or natively using display: none.
                * The provided function returns a promise that should be fullfilled when the element is hidden.
                * Since it is a promise async operations are more than possible.
                * See the default viewer for an opacity example.
                * @param visibilityFunction The function to execute to show the template.
                */
            hide(visibilityFunction?: (template: Template) => Promise<Template>): Promise<Template>;
            /**
                * Dispose this template
                */
            dispose(): void;
    }
}

declare module 'babylonjs-viewer/viewer/viewerWithTemplate' {
    import { AbstractViewer } from "babylonjs-viewer/viewer/viewer";
    import { ConfigurationLoader } from "babylonjs-viewer/configuration/loader";
    /**
      * The AbstractViewer is the center of Babylon's viewer.
      * It is the basic implementation of the default viewer and is responsible of loading and showing the model and the templates
      */
    export abstract class AbstractViewerWithTemplate extends AbstractViewer {
        protected getConfigurationLoader(): ConfigurationLoader;
    }
}

declare module 'babylonjs-viewer/configuration/configurationContainer' {
    import { ViewerConfiguration } from 'babylonjs-viewer/configuration/configuration';
    import { Color3 } from 'babylonjs/Maths/math';
    import { Scene } from 'babylonjs/scene';
    export class ConfigurationContainer {
        configuration: ViewerConfiguration;
        viewerId: string;
        mainColor: Color3;
        reflectionColor: Color3;
        scene?: Scene;
    }
}

declare module 'babylonjs-viewer/configuration/renderOnlyLoader' {
    import { ViewerConfiguration } from 'babylonjs-viewer/configuration/configuration';
    /**
        * The configuration loader will load the configuration object from any source and will use the defined mapper to
        * parse the object and return a conform ViewerConfiguration.
        * It is a private member of the scene.
        */
    export class RenderOnlyConfigurationLoader {
            constructor(_enableCache?: boolean);
            protected getExtendedConfig(type: string | undefined): ViewerConfiguration;
            /**
                * load a configuration object that is defined in the initial configuration provided.
                * The viewer configuration can extend different types of configuration objects and have an extra configuration defined.
                *
                * @param initConfig the initial configuration that has the definitions of further configuration to load.
                * @param callback an optional callback that will be called sync, if noconfiguration needs to be loaded or configuration is payload-only
                * @returns A promise that delivers the extended viewer configuration, when done.
                */
            loadConfiguration(initConfig?: ViewerConfiguration, callback?: (config: ViewerConfiguration) => void): Promise<ViewerConfiguration>;
            /**
                * Dispose the configuration loader. This will cancel file requests, if active.
                */
            dispose(): void;
    }
}

declare module 'babylonjs-viewer/managers/observablesManager' {
    import { Observable } from 'babylonjs/Misc/observable';
    import { Scene } from 'babylonjs/scene';
    import { Engine } from 'babylonjs/Engines/engine';
    import { SceneLoaderProgressEvent, ISceneLoaderPlugin, ISceneLoaderPluginAsync } from 'babylonjs/Loading/sceneLoader';
    import { ViewerModel } from 'babylonjs-viewer/model/viewerModel';
    export class ObservablesManager {
            /**
                * Will notify when the scene was initialized
                */
            onSceneInitObservable: Observable<Scene>;
            /**
                * will notify when the engine was initialized
                */
            onEngineInitObservable: Observable<Engine>;
            /**
                * Will notify when a new model was added to the scene.
                * Note that added does not neccessarily mean loaded!
                */
            onModelAddedObservable: Observable<ViewerModel>;
            /**
                * will notify after every model load
                */
            onModelLoadedObservable: Observable<ViewerModel>;
            /**
                * will notify when any model notify of progress
                */
            onModelLoadProgressObservable: Observable<SceneLoaderProgressEvent>;
            /**
                * will notify when any model load failed.
                */
            onModelLoadErrorObservable: Observable<{
                    message: string;
                    exception: any;
            }>;
            /**
                * Will notify when a model was removed from the scene;
                */
            onModelRemovedObservable: Observable<ViewerModel>;
            /**
                * will notify when a new loader was initialized.
                * Used mainly to know when a model starts loading.
                */
            onLoaderInitObservable: Observable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>;
            /**
                * Observers registered here will be executed when the entire load process has finished.
                */
            onViewerInitDoneObservable: Observable<any>;
            /**
                * Will notify when the viewer init started (after configuration was loaded)
                */
            onViewerInitStartedObservable: Observable<any>;
            /**
                * Functions added to this observable will be executed on each frame rendered.
                */
            onFrameRenderedObservable: Observable<any>;
            /**
                * Will notify when VR mode is entered.
                */
            onEnteringVRObservable: Observable<any>;
            /**
                * Will notify when VR mode is exited.
                */
            onExitingVRObservable: Observable<any>;
            constructor();
            dispose(): void;
    }
}

declare module 'babylonjs-viewer/managers/sceneManager' {
    import { ILightConfiguration, ISceneConfiguration, ISceneOptimizerConfiguration, ICameraConfiguration, ISkyboxConfiguration, ViewerConfiguration, IGroundConfiguration, IModelConfiguration, IVRConfiguration } from 'babylonjs-viewer/configuration';
    import { ViewerModel } from 'babylonjs-viewer/model/viewerModel';
    import { ViewerLabs } from 'babylonjs-viewer/labs/viewerLabs';
    import { ObservablesManager } from 'babylonjs-viewer/managers/observablesManager';
    import { ConfigurationContainer } from 'babylonjs-viewer/configuration/configurationContainer';
    import { IEnvironmentMapConfiguration } from 'babylonjs-viewer/configuration/interfaces/environmentMapConfiguration';
    import { Observable } from 'babylonjs/Misc/observable';
    import { SceneOptimizer } from 'babylonjs/Misc/sceneOptimizer';
    import { ArcRotateCamera } from 'babylonjs/Cameras/arcRotateCamera';
    import { Light } from 'babylonjs/Lights/light';
    import { EnvironmentHelper } from 'babylonjs/Helpers/environmentHelper';
    import { VRExperienceHelper } from 'babylonjs/Cameras/VR/vrExperienceHelper';
    import { Color3 } from 'babylonjs/Maths/math';
    import { Nullable } from 'babylonjs/types';
    import { DefaultRenderingPipeline } from 'babylonjs/PostProcesses/RenderPipeline/Pipelines/defaultRenderingPipeline';
    import { Engine } from 'babylonjs/Engines/engine';
    import { IShadowLight } from 'babylonjs/Lights/shadowLight';
    import { Scene } from 'babylonjs/scene';
    /**
        * This interface describes the structure of the variable sent with the configuration observables of the scene manager.
        * O - the type of object we are dealing with (Light, ArcRotateCamera, Scene, etc')
        * T - the configuration type
        */
    export interface IPostConfigurationCallback<OBJ, CONF> {
            newConfiguration: CONF;
            sceneManager: SceneManager;
            object: OBJ;
            model?: ViewerModel;
    }
    export class SceneManager {
            /**
                * Will notify when the scene was initialized
                */
            onSceneInitObservable: Observable<Scene>;
            /**
                * Will notify after the scene was configured. Can be used to further configure the scene
                */
            onSceneConfiguredObservable: Observable<IPostConfigurationCallback<Scene, ISceneConfiguration>>;
            /**
                * Will notify after the scene optimized was configured. Can be used to further configure the scene optimizer
                */
            onSceneOptimizerConfiguredObservable: Observable<IPostConfigurationCallback<SceneOptimizer, ISceneOptimizerConfiguration | boolean>>;
            /**
                * Will notify after the camera was configured. Can be used to further configure the camera
                */
            onCameraConfiguredObservable: Observable<IPostConfigurationCallback<ArcRotateCamera, ICameraConfiguration>>;
            /**
                * Will notify after the lights were configured. Can be used to further configure lights
                */
            onLightsConfiguredObservable: Observable<IPostConfigurationCallback<Array<Light>, {
                    [name: string]: ILightConfiguration | boolean | number;
            }>>;
            /**
                * Will notify after the model(s) were configured. Can be used to further configure models
                */
            onModelsConfiguredObservable: Observable<IPostConfigurationCallback<Array<ViewerModel>, IModelConfiguration>>;
            /**
                * Will notify after the envirnoment was configured. Can be used to further configure the environment
                */
            onEnvironmentConfiguredObservable: Observable<IPostConfigurationCallback<EnvironmentHelper, {
                    skybox?: ISkyboxConfiguration | boolean;
                    ground?: IGroundConfiguration | boolean;
            }>>;
            /**
                * Will notify after the model(s) were configured. Can be used to further configure models
                */
            onVRConfiguredObservable: Observable<IPostConfigurationCallback<VRExperienceHelper, IVRConfiguration>>;
            /**
                * The Babylon Scene of this viewer
                */
            scene: Scene;
            /**
                * The camera used in this viewer
                */
            camera: ArcRotateCamera;
            /**
                * Babylon's scene optimizer
                */
            sceneOptimizer: SceneOptimizer;
            /**
                * Models displayed in this viewer.
                */
            models: Array<ViewerModel>;
            /**
                * Babylon's environment helper of this viewer
                */
            environmentHelper?: EnvironmentHelper;
            protected _defaultHighpTextureType: number;
            protected _shadowGeneratorBias: number;
            protected _defaultPipelineTextureType: number;
            /**
                * The maximum number of shadows supported by the curent viewer
                */
            protected _maxShadows: number;
            /**
                * The labs variable consists of objects that will have their API change.
                * Please be careful when using labs in production.
                */
            labs: ViewerLabs;
            readonly defaultRenderingPipeline: Nullable<DefaultRenderingPipeline>;
            protected _vrHelper?: VRExperienceHelper;
            readonly vrHelper: VRExperienceHelper | undefined;
            constructor(_engine: Engine, _configurationContainer: ConfigurationContainer, _observablesManager?: ObservablesManager | undefined);
            /**
                * Returns a boolean representing HDR support
                */
            readonly isHdrSupported: boolean;
            /**
                * Return the main color defined in the configuration.
                */
            readonly mainColor: Color3;
            readonly reflectionColor: Color3;
            animationBlendingEnabled: boolean;
            readonly observablesManager: ObservablesManager | undefined;
            /**
             * Should shadows be rendered every frame, or only once and stop.
             * This can be used to optimize a scene.
             *
             * Not that the shadows will NOT disapear but will remain in place.
             * @param process if true shadows will be updated once every frame. if false they will stop being updated.
             */
            processShadows: boolean;
            groundEnabled: boolean;
            /**
             * sets wether the reflection is disabled.
             */
            groundMirrorEnabled: boolean;
            defaultRenderingPipelineEnabled: boolean;
            /**
                * Sets the engine flags to unlock all babylon features.
                * Can also be configured using the scene.flags configuration object
                */
            unlockBabylonFeatures(): void;
            /**
                * initialize the scene. Calling this function again will dispose the old scene, if exists.
                */
            initScene(sceneConfiguration?: ISceneConfiguration, optimizerConfiguration?: boolean | ISceneOptimizerConfiguration): Promise<Scene>;
            clearScene(clearModels?: boolean, clearLights?: boolean): void;
            /**
                * This will update the scene's configuration, including camera, lights, environment.
                * @param newConfiguration the delta that should be configured. This includes only the changes
                * @param globalConfiguration The global configuration object, after the new configuration was merged into it
                */
            updateConfiguration(newConfiguration: Partial<ViewerConfiguration>): void;
            bloomEnabled: boolean;
            fxaaEnabled: boolean;
            setDefaultMaterial(sceneConfig: ISceneConfiguration): void;
            /**
                * internally configure the scene using the provided configuration.
                * The scene will not be recreated, but just updated.
                * @param sceneConfig the (new) scene configuration
                */
            protected _configureScene(sceneConfig: ISceneConfiguration): void;
            /**
                * Configure the scene optimizer.
                * The existing scene optimizer will be disposed and a new one will be created.
                * @param optimizerConfig the (new) optimizer configuration
                */
            protected _configureOptimizer(optimizerConfig: ISceneOptimizerConfiguration | boolean): void;
            /**
                * configure all models using the configuration.
                * @param modelConfiguration the configuration to use to reconfigure the models
                */
            protected _configureVR(vrConfig: IVRConfiguration): void;
            protected _configureEnvironmentMap(environmentMapConfiguration: IEnvironmentMapConfiguration): any;
            /**
                * (Re) configure the camera. The camera will only be created once and from this point will only be reconfigured.
                * @param cameraConfig the new camera configuration
                * @param model optionally use the model to configure the camera.
                */
            protected _configureCamera(cameraConfig?: ICameraConfiguration): void;
            protected _configureEnvironment(skyboxConifguration?: ISkyboxConfiguration | boolean, groundConfiguration?: IGroundConfiguration | boolean): void;
            /**
                * configure the lights.
                *
                * @param lightsConfiguration the (new) light(s) configuration
                * @param model optionally use the model to configure the camera.
                */
            protected _configureLights(lightsConfiguration?: {
                    [name: string]: ILightConfiguration | boolean | number;
            }): void;
            /**
                * Gets the shadow map blur kernel according to the light configuration.
                * @param light The light used to generate the shadows
                * @param bufferSize The size of the shadow map
                * @return the kernel blur size
                */
            getBlurKernel(light: IShadowLight, bufferSize: number): number;
            /**
                * Alters render settings to reduce features based on hardware feature limitations
                * @param enableHDR Allows the viewer to run in HDR mode.
                */
            protected _handleHardwareLimitations(enableHDR?: boolean): void;
            /**
                * Dispoe the entire viewer including the scene and the engine
                */
            dispose(): void;
    }
}

declare module 'babylonjs-viewer/configuration/interfaces/modelConfiguration' {
    import { IModelAnimationConfiguration } from "babylonjs-viewer/configuration/interfaces/modelAnimationConfiguration";
    export interface IModelConfiguration {
            id?: string;
            url?: string;
            root?: string;
            file?: string | File;
            loader?: string;
            position?: {
                    x: number;
                    y: number;
                    z: number;
            };
            rotation?: {
                    x: number;
                    y: number;
                    z: number;
                    w?: number;
            };
            scaling?: {
                    x: number;
                    y: number;
                    z: number;
            };
            parentObjectIndex?: number;
            castShadow?: boolean;
            receiveShadows?: boolean;
            normalize?: boolean | {
                    center?: boolean;
                    unitSize?: boolean;
                    parentIndex?: number;
            };
            title?: string;
            subtitle?: string;
            thumbnail?: string;
            animation?: {
                    autoStart?: boolean | string;
                    playOnce?: boolean;
                    autoStartIndex?: number;
            };
            entryAnimation?: IModelAnimationConfiguration;
            exitAnimation?: IModelAnimationConfiguration;
            material?: {
                    directEnabled?: boolean;
                    directIntensity?: number;
                    emissiveIntensity?: number;
                    environmentIntensity?: number;
                    [propName: string]: any;
            };
            /**
                * Rotation offset axis definition
                */
            rotationOffsetAxis?: {
                    x: number;
                    y: number;
                    z: number;
            };
            /**
                * the offset angle
                */
            rotationOffsetAngle?: number;
            loaderConfiguration?: {
                    maxLODsToLoad?: number;
                    progressiveLoading?: boolean;
            };
    }
}

declare module 'babylonjs-viewer/loader/plugins' {
    import { TelemetryLoaderPlugin } from "babylonjs-viewer/loader/plugins/telemetryLoaderPlugin";
    import { ILoaderPlugin } from "babylonjs-viewer/loader/plugins/loaderPlugin";
    import { MSFTLodLoaderPlugin } from 'babylonjs-viewer/loader/plugins/msftLodLoaderPlugin';
    import { ApplyMaterialConfigPlugin } from 'babylonjs-viewer/loader/plugins/applyMaterialConfig';
    import { ExtendedMaterialLoaderPlugin } from 'babylonjs-viewer/loader/plugins/extendedMaterialLoaderPlugin';
    export { TelemetryLoaderPlugin, ILoaderPlugin, MSFTLodLoaderPlugin, ApplyMaterialConfigPlugin, ExtendedMaterialLoaderPlugin };
    /**
        * Get a loader plugin according to its name.
        * The plugin will be cached and will be reused if called for again.
        *
        * @param name the name of the plugin
        */
    export function getLoaderPluginByName(name: string): ILoaderPlugin;
    /**
        *
        */
    export function addLoaderPlugin(name: string, plugin: ILoaderPlugin): void;
}

declare module 'babylonjs-viewer/optimizer/custom/extended' {
    import { SceneManager } from 'babylonjs-viewer/managers/sceneManager';
    /**
        * A custom upgrade-oriented function configuration for the scene optimizer.
        *
        * @param viewer the viewer to optimize
        */
    export function extendedUpgrade(sceneManager: SceneManager): boolean;
    /**
        * A custom degrade-oriented function configuration for the scene optimizer.
        *
        * @param viewer the viewer to optimize
        */
    export function extendedDegrade(sceneManager: SceneManager): boolean;
}

declare module 'babylonjs-viewer/configuration/interfaces' {
    export * from 'babylonjs-viewer/configuration/interfaces/cameraConfiguration';
    export * from 'babylonjs-viewer/configuration/interfaces/colorGradingConfiguration';
    export * from 'babylonjs-viewer/configuration/interfaces/defaultRenderingPipelineConfiguration';
    export * from 'babylonjs-viewer/configuration/interfaces/groundConfiguration';
    export * from 'babylonjs-viewer/configuration/interfaces/imageProcessingConfiguration';
    export * from 'babylonjs-viewer/configuration/interfaces/lightConfiguration';
    export * from 'babylonjs-viewer/configuration/interfaces/modelAnimationConfiguration';
    export * from 'babylonjs-viewer/configuration/interfaces/modelConfiguration';
    export * from 'babylonjs-viewer/configuration/interfaces/observersConfiguration';
    export * from 'babylonjs-viewer/configuration/interfaces/sceneConfiguration';
    export * from 'babylonjs-viewer/configuration/interfaces/sceneOptimizerConfiguration';
    export * from 'babylonjs-viewer/configuration/interfaces/skyboxConfiguration';
    export * from 'babylonjs-viewer/configuration/interfaces/templateConfiguration';
    export * from 'babylonjs-viewer/configuration/interfaces/vrConfiguration';
    export * from 'babylonjs-viewer/configuration/interfaces/environmentMapConfiguration';
}

declare module 'babylonjs-viewer/configuration/interfaces/environmentMapConfiguration' {
    export interface IEnvironmentMapConfiguration {
            /**
                * Environment map texture path in relative to the asset folder.
                */
            texture: string;
            /**
                * Default rotation to apply to the environment map.
                */
            rotationY: number;
            /**
                * Tint level of the main color on the environment map.
                */
            tintLevel: number;
            /**
                * The environment's main color.
                */
            mainColor?: {
                    r?: number;
                    g?: number;
                    b?: number;
            };
    }
}

declare module 'babylonjs-viewer/templating/eventManager' {
    import { EventCallback, TemplateManager } from "babylonjs-viewer/templating/templateManager";
    /**
        * The EventManager is in charge of registering user interctions with the viewer.
        * It is used in the TemplateManager
        */
    export class EventManager {
            constructor(_templateManager: TemplateManager);
            /**
                * Register a new callback to a specific template.
                * The best example for the usage can be found in the DefaultViewer
                *
                * @param templateName the templateName to register the event to
                * @param callback The callback to be executed
                * @param eventType the type of event to register
                * @param selector an optional selector. if not defined the parent object in the template will be selected
                */
            registerCallback(templateName: string, callback: (eventData: EventCallback) => void, eventType?: string, selector?: string): void;
            /**
                * This will remove a registered event from the defined template.
                * Each one of the variables apart from the template name are optional, but one must be provided.
                *
                * @param templateName the templateName
                * @param callback the callback to remove (optional)
                * @param eventType the event type to remove (optional)
                * @param selector the selector from which to remove the event (optional)
                */
            unregisterCallback(templateName: string, callback: (eventData: EventCallback) => void, eventType?: string, selector?: string): void;
            /**
                * Dispose the event manager
                */
            dispose(): void;
    }
}

declare module 'babylonjs-viewer/configuration/loader' {
    import { RenderOnlyConfigurationLoader } from "babylonjs-viewer/configuration/renderOnlyLoader";
    export class ConfigurationLoader extends RenderOnlyConfigurationLoader {
        protected getExtendedConfig(type: string | undefined): import("babylonjs-viewer/configuration/configuration").ViewerConfiguration;
    }
}

declare module 'babylonjs-viewer/labs/viewerLabs' {
    import { PBREnvironment } from "babylonjs-viewer/labs/environmentSerializer";
    import { Scene } from "babylonjs/scene";
    import { Vector3 } from "babylonjs/Maths/math";
    import { ShadowLight } from "babylonjs/Lights/shadowLight";
    /**
        * The ViewerLabs class will hold functions that are not (!) backwards compatible.
        * The APIs in all labs-related classes and configuration  might change.
        * Once stable, lab features will be moved to the publis API and configuration object.
        */
    export class ViewerLabs {
            constructor(_scene: Scene);
            assetsRootURL: string;
            environment: PBREnvironment;
            /**
                        * Loads an environment map from a given URL
                        * @param url URL of environment map
                        * @param onSuccess Callback fired after environment successfully applied to the scene
                        * @param onProgress Callback fired at progress events while loading the environment map
                        * @param onError Callback fired when the load fails
                        */
            loadEnvironment(url: string, onSuccess?: (env: PBREnvironment) => void, onProgress?: (bytesLoaded: number, bytesTotal: number) => void, onError?: (e: any) => void): void;
            /**
                * Loads an environment map from a given URL
                * @param buffer ArrayBuffer containing environment map
                * @param onSuccess Callback fired after environment successfully applied to the scene
                * @param onProgress Callback fired at progress events while loading the environment map
                * @param onError Callback fired when the load fails
                */
            loadEnvironment(buffer: ArrayBuffer, onSuccess?: (env: PBREnvironment) => void, onProgress?: (bytesLoaded: number, bytesTotal: number) => void, onError?: (e: any) => void): void;
            /**
                * Sets the environment to an already loaded environment
                * @param env PBREnvironment instance
                * @param onSuccess Callback fired after environment successfully applied to the scene
                * @param onProgress Callback fired at progress events while loading the environment map
                * @param onError Callback fired when the load fails
                */
            loadEnvironment(env: PBREnvironment, onSuccess?: (env: PBREnvironment) => void, onProgress?: (bytesLoaded: number, bytesTotal: number) => void, onError?: (e: any) => void): void;
            /**
                * Applies an `EnvironmentMapConfiguration` to the scene
                * @param environmentMapConfiguration Environment map configuration to apply
                */
            applyEnvironmentMapConfiguration(rotationY?: number): void;
            /**
                * Get an environment asset url by using the configuration if the path is not absolute.
                * @param url Asset url
                * @returns The Asset url using the `environmentAssetsRootURL` if the url is not an absolute path.
                */
            getAssetUrl(url: string): string;
            rotateShadowLight(shadowLight: ShadowLight, amount: number, point?: Vector3, axis?: Vector3, target?: Vector3): void;
    }
}

declare module 'babylonjs-viewer/configuration/interfaces/modelAnimationConfiguration' {
    /**
        * Defines an animation to be applied to a model (translation, scale or rotation).
        */
    export interface IModelAnimationConfiguration {
            /**
                * Time of animation, in seconds
                */
            time?: number;
            /**
                * Scale to apply
                */
            scaling?: {
                    x: number;
                    y: number;
                    z: number;
            };
            /**
                * Easing function to apply
                */
            easingFunction?: number;
            /**
                * An Easing mode to apply to the easing function
                * See BABYLON.EasingFunction
                */
            easingMode?: number;
    }
}

declare module 'babylonjs-viewer/loader/plugins/telemetryLoaderPlugin' {
    import { ILoaderPlugin } from "babylonjs-viewer/loader/plugins/loaderPlugin";
    import { ViewerModel } from "babylonjs-viewer/model/viewerModel";
    import { ISceneLoaderPlugin, ISceneLoaderPluginAsync } from "babylonjs/Loading/sceneLoader";
    export class TelemetryLoaderPlugin implements ILoaderPlugin {
        onInit(loader: ISceneLoaderPlugin | ISceneLoaderPluginAsync, model: ViewerModel): void;
        onLoaded(model: ViewerModel): void;
        onError(message: string, exception: any): void;
        onComplete(): void;
    }
}

declare module 'babylonjs-viewer/loader/plugins/msftLodLoaderPlugin' {
    import { ISceneLoaderPlugin, ISceneLoaderPluginAsync } from 'babylonjs/Loading/sceneLoader';
    import { IGLTFLoaderExtension } from 'babylonjs-loaders/glTF/2.0/glTFLoaderExtension';
    import { ViewerModel } from 'babylonjs-viewer/model/viewerModel';
    import { ILoaderPlugin } from 'babylonjs-viewer/loader/plugins/loaderPlugin';
    /**
      * A loder plugin to use MSFT_lod extension correctly (glTF)
      */
    export class MSFTLodLoaderPlugin implements ILoaderPlugin {
        onInit(loader: ISceneLoaderPlugin | ISceneLoaderPluginAsync, model: ViewerModel): void;
        onExtensionLoaded(extension: IGLTFLoaderExtension): void;
    }
}

declare module 'babylonjs-viewer/loader/plugins/applyMaterialConfig' {
    import { ViewerModel } from 'babylonjs-viewer/model/viewerModel';
    import { ILoaderPlugin } from 'babylonjs-viewer/loader/plugins/loaderPlugin';
    import { ISceneLoaderPlugin, ISceneLoaderPluginAsync } from 'babylonjs/Loading/sceneLoader';
    import { Material } from 'babylonjs/Materials/material';
    /**
      * Force-apply material configuration right after a material was loaded.
      */
    export class ApplyMaterialConfigPlugin implements ILoaderPlugin {
        onInit(loader: ISceneLoaderPlugin | ISceneLoaderPluginAsync, model: ViewerModel): void;
        onMaterialLoaded(material: Material): void;
    }
}

declare module 'babylonjs-viewer/loader/plugins/extendedMaterialLoaderPlugin' {
    import { Material } from 'babylonjs/Materials/material';
    import { ILoaderPlugin } from 'babylonjs-viewer/loader/plugins/loaderPlugin';
    /**
      * A (PBR) material will be extended using this function.
      * This function will hold extra default configuration for the viewer, if not implemented in Babylon itself.
      */
    export class ExtendedMaterialLoaderPlugin implements ILoaderPlugin {
        onMaterialLoaded(baseMaterial: Material): void;
    }
}

declare module 'babylonjs-viewer/configuration/interfaces/cameraConfiguration' {
    export interface ICameraConfiguration {
        position?: {
            x: number;
            y: number;
            z: number;
        };
        rotation?: {
            x: number;
            y: number;
            z: number;
            w: number;
        };
        fov?: number;
        fovMode?: number;
        minZ?: number;
        maxZ?: number;
        inertia?: number;
        exposure?: number;
        pinchPrecision?: number;
        behaviors?: {
            [name: string]: boolean | number | ICameraBehaviorConfiguration;
        };
        disableCameraControl?: boolean;
        disableCtrlForPanning?: boolean;
        disableAutoFocus?: boolean;
        [propName: string]: any;
    }
    export interface ICameraBehaviorConfiguration {
        type: number;
        [propName: string]: any;
    }
}

declare module 'babylonjs-viewer/configuration/interfaces/colorGradingConfiguration' {
    /**
        * The Color Grading Configuration groups the different settings used to define the color grading used in the viewer.
        */
    export interface IColorGradingConfiguration {
            /**
                * Transform data string, encoded as determined by transformDataFormat.
                */
            transformData: string;
            /**
                * The encoding format of TransformData (currently only raw-base16 is supported).
                */
            transformDataFormat: string;
            /**
                * The weight of the transform
                */
            transformWeight: number;
            /**
                * Color curve colorFilterHueGlobal value
                */
            colorFilterHueGlobal: number;
            /**
                * Color curve colorFilterHueShadows value
                */
            colorFilterHueShadows: number;
            /**
                * Color curve colorFilterHueMidtones value
                */
            colorFilterHueMidtones: number;
            /**
                * Color curve colorFilterHueHighlights value
                */
            colorFilterHueHighlights: number;
            /**
                * Color curve colorFilterDensityGlobal value
                */
            colorFilterDensityGlobal: number;
            /**
                * Color curve colorFilterDensityShadows value
                */
            colorFilterDensityShadows: number;
            /**
                * Color curve colorFilterDensityMidtones value
                */
            colorFilterDensityMidtones: number;
            /**
                * Color curve colorFilterDensityHighlights value
                */
            colorFilterDensityHighlights: number;
            /**
                * Color curve saturationGlobal value
                */
            saturationGlobal: number;
            /**
                * Color curve saturationShadows value
                */
            saturationShadows: number;
            /**
                * Color curve saturationMidtones value
                */
            saturationMidtones: number;
            /**
                * Color curve saturationHighlights value
                */
            saturationHighlights: number;
            /**
                * Color curve exposureGlobal value
                */
            exposureGlobal: number;
            /**
                * Color curve exposureShadows value
                */
            exposureShadows: number;
            /**
                * Color curve exposureMidtones value
                */
            exposureMidtones: number;
            /**
                * Color curve exposureHighlights value
                */
            exposureHighlights: number;
    }
}

declare module 'babylonjs-viewer/configuration/interfaces/defaultRenderingPipelineConfiguration' {
    import { DepthOfFieldEffectBlurLevel } from "babylonjs/PostProcesses/depthOfFieldEffect";
    export interface IDefaultRenderingPipelineConfiguration {
        sharpenEnabled?: boolean;
        bloomEnabled?: boolean;
        bloomThreshold?: number;
        depthOfFieldEnabled?: boolean;
        depthOfFieldBlurLevel?: DepthOfFieldEffectBlurLevel;
        fxaaEnabled?: boolean;
        imageProcessingEnabled?: boolean;
        defaultPipelineTextureType?: number;
        bloomScale?: number;
        chromaticAberrationEnabled?: boolean;
        grainEnabled?: boolean;
        bloomKernel?: number;
        hardwareScaleLevel?: number;
        bloomWeight?: number;
        hdr?: boolean;
        samples?: number;
        glowLayerEnabled?: boolean;
    }
}

declare module 'babylonjs-viewer/configuration/interfaces/groundConfiguration' {
    export interface IGroundConfiguration {
        size?: number;
        receiveShadows?: boolean;
        shadowLevel?: number;
        shadowOnly?: boolean;
        mirror?: boolean | {
            sizeRatio?: number;
            blurKernel?: number;
            amount?: number;
            fresnelWeight?: number;
            fallOffDistance?: number;
            textureType?: number;
        };
        texture?: string;
        color?: {
            r: number;
            g: number;
            b: number;
        };
        opacity?: number;
        material?: {
            [propName: string]: any;
        };
    }
}

declare module 'babylonjs-viewer/configuration/interfaces/imageProcessingConfiguration' {
    export interface IImageProcessingConfiguration {
        colorGradingEnabled?: boolean;
        colorCurvesEnabled?: boolean;
        colorCurves?: {
            globalHue?: number;
            globalDensity?: number;
            globalSaturation?: number;
            globalExposure?: number;
            highlightsHue?: number;
            highlightsDensity?: number;
            highlightsSaturation?: number;
            highlightsExposure?: number;
            midtonesHue?: number;
            midtonesDensity?: number;
            midtonesSaturation?: number;
            midtonesExposure?: number;
            shadowsHue?: number;
            shadowsDensity?: number;
            shadowsSaturation?: number;
            shadowsExposure?: number;
        };
        colorGradingWithGreenDepth?: boolean;
        colorGradingBGR?: boolean;
        exposure?: number;
        toneMappingEnabled?: boolean;
        contrast?: number;
        vignetteEnabled?: boolean;
        vignetteStretch?: number;
        vignetteCentreX?: number;
        vignetteCentreY?: number;
        vignetteWeight?: number;
        vignetteColor?: {
            r: number;
            g: number;
            b: number;
            a?: number;
        };
        vignetteCameraFov?: number;
        vignetteBlendMode?: number;
        vignetteM?: boolean;
        applyByPostProcess?: boolean;
        isEnabled?: boolean;
    }
}

declare module 'babylonjs-viewer/configuration/interfaces/lightConfiguration' {
    export interface ILightConfiguration {
        type: number;
        name?: string;
        disabled?: boolean;
        position?: {
            x: number;
            y: number;
            z: number;
        };
        target?: {
            x: number;
            y: number;
            z: number;
        };
        direction?: {
            x: number;
            y: number;
            z: number;
        };
        diffuse?: {
            r: number;
            g: number;
            b: number;
        };
        specular?: {
            r: number;
            g: number;
            b: number;
        };
        intensity?: number;
        intensityMode?: number;
        radius?: number;
        shadownEnabled?: boolean;
        shadowConfig?: {
            useBlurExponentialShadowMap?: boolean;
            useBlurCloseExponentialShadowMap?: boolean;
            useKernelBlur?: boolean;
            blurKernel?: number;
            blurScale?: number;
            minZ?: number;
            maxZ?: number;
            frustumSize?: number;
            angleScale?: number;
            frustumEdgeFalloff?: number;
            [propName: string]: any;
        };
        spotAngle?: number;
        shadowFieldOfView?: number;
        shadowBufferSize?: number;
        shadowFrustumSize?: number;
        shadowMinZ?: number;
        shadowMaxZ?: number;
        [propName: string]: any;
        behaviors?: {
            [name: string]: number | {
                type: number;
                [propName: string]: any;
            };
        };
    }
}

declare module 'babylonjs-viewer/configuration/interfaces/observersConfiguration' {
    export interface IObserversConfiguration {
        onEngineInit?: string;
        onSceneInit?: string;
        onModelLoaded?: string;
    }
}

declare module 'babylonjs-viewer/configuration/interfaces/sceneConfiguration' {
    import { IImageProcessingConfiguration } from "babylonjs-viewer/configuration/interfaces/imageProcessingConfiguration";
    import { IColorGradingConfiguration } from "babylonjs-viewer/configuration/interfaces/colorGradingConfiguration";
    import { IGlowLayerOptions } from "babylonjs";
    export interface ISceneConfiguration {
            debug?: boolean;
            clearColor?: {
                    r: number;
                    g: number;
                    b: number;
                    a: number;
            };
            /** Deprecated, use environmentMap.mainColor instead. */
            mainColor?: {
                    r?: number;
                    g?: number;
                    b?: number;
            };
            imageProcessingConfiguration?: IImageProcessingConfiguration;
            environmentTexture?: string;
            colorGrading?: IColorGradingConfiguration;
            environmentRotationY?: number;
            /**
                * Deprecated, please use default rendering pipeline
                */
            glow?: boolean | IGlowLayerOptions;
            disableHdr?: boolean;
            renderInBackground?: boolean;
            disableCameraControl?: boolean;
            animationPropertiesOverride?: {
                    [propName: string]: any;
            };
            defaultMaterial?: {
                    materialType: "standard" | "pbr";
                    [propName: string]: any;
            };
            flags?: {
                    shadowsEnabled?: boolean;
                    particlesEnabled?: boolean;
                    collisionsEnabled?: boolean;
                    lightsEnabled?: boolean;
                    texturesEnabled?: boolean;
                    lensFlaresEnabled?: boolean;
                    proceduralTexturesEnabled?: boolean;
                    renderTargetsEnabled?: boolean;
                    spritesEnabled?: boolean;
                    skeletonsEnabled?: boolean;
                    audioEnabled?: boolean;
            };
            assetsRootURL?: string;
    }
}

declare module 'babylonjs-viewer/configuration/interfaces/sceneOptimizerConfiguration' {
    export interface ISceneOptimizerConfiguration {
        targetFrameRate?: number;
        trackerDuration?: number;
        autoGeneratePriorities?: boolean;
        improvementMode?: boolean;
        degradation?: string;
        types?: {
            texture?: ISceneOptimizerParameters;
            hardwareScaling?: ISceneOptimizerParameters;
            shadow?: ISceneOptimizerParameters;
            postProcess?: ISceneOptimizerParameters;
            lensFlare?: ISceneOptimizerParameters;
            particles?: ISceneOptimizerParameters;
            renderTarget?: ISceneOptimizerParameters;
            mergeMeshes?: ISceneOptimizerParameters;
        };
        custom?: string;
    }
    export interface ISceneOptimizerParameters {
        priority?: number;
        maximumSize?: number;
        step?: number;
    }
}

declare module 'babylonjs-viewer/configuration/interfaces/skyboxConfiguration' {
    import { IImageProcessingConfiguration } from "babylonjs-viewer/configuration/interfaces/imageProcessingConfiguration";
    export interface ISkyboxConfiguration {
        cubeTexture?: {
            noMipMap?: boolean;
            gammaSpace?: boolean;
            url?: string | Array<string>;
        };
        color?: {
            r: number;
            g: number;
            b: number;
        };
        pbr?: boolean;
        scale?: number;
        blur?: number;
        material?: {
            imageProcessingConfiguration?: IImageProcessingConfiguration;
            [propName: string]: any;
        };
        infiniteDistance?: boolean;
    }
}

declare module 'babylonjs-viewer/configuration/interfaces/templateConfiguration' {
    /**
        * A single template configuration object
        */
    export interface ITemplateConfiguration {
            /**
                * can be either the id of the template's html element or a URL.
                * See - http://doc.babylonjs.com/extensions/the_templating_system#location-vs-html
                */
            location?: string;
            /**
                * If no location is provided you can provide here the raw html of this template.
                * See http://doc.babylonjs.com/extensions/the_templating_system#location-vs-html
                */
            html?: string;
            id?: string;
            /**
                * Parameters that will be delivered to the template and will render it accordingly.
                */
            params?: {
                    [key: string]: string | number | boolean | object;
            };
            /**
                * Events to attach to this template.
                * event name is the key. the value can either be a boolean (attach to the parent element)
                * or a map of html id elements.
                *
                * See - http://doc.babylonjs.com/extensions/the_templating_system#event-binding
                */
            events?: {
                    pointerdown?: boolean | {
                            [id: string]: boolean;
                    };
                    pointerup?: boolean | {
                            [id: string]: boolean;
                    };
                    pointermove?: boolean | {
                            [id: string]: boolean;
                    };
                    pointerover?: boolean | {
                            [id: string]: boolean;
                    };
                    pointerout?: boolean | {
                            [id: string]: boolean;
                    };
                    pointerenter?: boolean | {
                            [id: string]: boolean;
                    };
                    pointerleave?: boolean | {
                            [id: string]: boolean;
                    };
                    pointercancel?: boolean | {
                            [id: string]: boolean;
                    };
                    click?: boolean | {
                            [id: string]: boolean;
                    };
                    dragstart?: boolean | {
                            [id: string]: boolean;
                    };
                    drop?: boolean | {
                            [id: string]: boolean;
                    };
                    [key: string]: boolean | {
                            [id: string]: boolean;
                    } | undefined;
            };
    }
}

declare module 'babylonjs-viewer/configuration/interfaces/vrConfiguration' {
    import { VRExperienceHelperOptions } from "babylonjs";
    export interface IVRConfiguration {
        disabled?: boolean;
        objectScaleFactor?: number;
        disableInteractions?: boolean;
        disableTeleportation?: boolean;
        overrideFloorMeshName?: string;
        vrOptions?: VRExperienceHelperOptions;
        modelHeightCorrection?: number | boolean;
        rotateUsingControllers?: boolean;
        cameraPosition?: {
            x: number;
            y: number;
            z: number;
        };
    }
}

declare module 'babylonjs-viewer/labs/environmentSerializer' {
    import { Vector3 } from 'babylonjs/Maths/math';
    import { TextureCube } from 'babylonjs-viewer/labs/texture';
    /**
        * Spherical polynomial coefficients (counter part to spherical harmonic coefficients used in shader irradiance calculation)
        * @ignoreChildren
        */
    export interface SphericalPolynomalCoefficients {
            x: Vector3;
            y: Vector3;
            z: Vector3;
            xx: Vector3;
            yy: Vector3;
            zz: Vector3;
            yz: Vector3;
            zx: Vector3;
            xy: Vector3;
    }
    /**
        * Wraps data and maps required for environments with physically based rendering
        */
    export interface PBREnvironment {
            /**
                * Spherical Polynomial Coefficients representing an irradiance map
                */
            irradiancePolynomialCoefficients: SphericalPolynomalCoefficients;
            /**
                * Specular cubemap
                */
            specularTexture?: TextureCube;
            /**
                * A scale factor applied to RGB values after reading from environment maps
                */
            textureIntensityScale: number;
    }
    /**
                        * Environment map representations: layouts, projections and approximations
                        */
    export type MapType = 'irradiance_sh_coefficients_9' | 'cubemap_faces';
    /**
        * Image type used for environment map
        */
    export type ImageType = 'png';
    /**
        * A generic field in JSON that report's its type
        */
    export interface TypedObject<T> {
            type: T;
    }
    /**
        * Describes a range of bytes starting at byte pos (inclusive) and finishing at byte pos + length - 1
        */
    export interface ByteRange {
            pos: number;
            length: number;
    }
    /**
        * Complete Spectre Environment JSON Descriptor
        */
    export interface EnvJsonDescriptor {
            radiance: TypedObject<MapType>;
            irradiance: TypedObject<MapType>;
            specular: TypedObject<MapType>;
    }
    /**
        * Spherical harmonic coefficients to provide an irradiance map
        */
    export interface IrradianceSHCoefficients9 extends TypedObject<MapType> {
            l00: Array<number>;
            l1_1: Array<number>;
            l10: Array<number>;
            l11: Array<number>;
            l2_2: Array<number>;
            l2_1: Array<number>;
            l20: Array<number>;
            l21: Array<number>;
            l22: Array<number>;
    }
    /**
        * A generic set of images, where the image content is specified by byte ranges in the mipmaps field
        */
    export interface ImageSet<T> extends TypedObject<MapType> {
            imageType: ImageType;
            width: number;
            height: number;
            mipmaps: Array<T>;
            multiplier: number;
    }
    /**
        * A set of cubemap faces
        */
    export type CubemapFaces = ImageSet<Array<ByteRange>>;
    /**
        * A single image containing an atlas of equirectangular-projection maps across all mip levels
        */
    export type EquirectangularMipmapAtlas = ImageSet<ByteRange>;
    /**
        * A static class proving methods to aid parsing Spectre environment files
        */
    export class EnvironmentDeserializer {
            /**
                * Parses an arraybuffer into a new PBREnvironment object
                * @param arrayBuffer The arraybuffer of the Spectre environment file
                * @return a PBREnvironment object
                */
            static Parse(arrayBuffer: ArrayBuffer): PBREnvironment;
    }
}

declare module 'babylonjs-viewer/labs/texture' {
    import { Scene } from "babylonjs/scene";
    import { CubeTexture } from "babylonjs/Materials/Textures/cubeTexture";
    import { BaseTexture } from "babylonjs/Materials/Textures/baseTexture";
    /**
        * WebGL Pixel Formats
        */
    export const enum PixelFormat {
            DEPTH_COMPONENT = 6402,
            ALPHA = 6406,
            RGB = 6407,
            RGBA = 6408,
            LUMINANCE = 6409,
            LUMINANCE_ALPHA = 6410
    }
    /**
        * WebGL Pixel Types
        */
    export const enum PixelType {
            UNSIGNED_BYTE = 5121,
            UNSIGNED_SHORT_4_4_4_4 = 32819,
            UNSIGNED_SHORT_5_5_5_1 = 32820,
            UNSIGNED_SHORT_5_6_5 = 33635
    }
    /**
        * WebGL Texture Magnification Filter
        */
    export const enum TextureMagFilter {
            NEAREST = 9728,
            LINEAR = 9729
    }
    /**
        * WebGL Texture Minification Filter
        */
    export const enum TextureMinFilter {
            NEAREST = 9728,
            LINEAR = 9729,
            NEAREST_MIPMAP_NEAREST = 9984,
            LINEAR_MIPMAP_NEAREST = 9985,
            NEAREST_MIPMAP_LINEAR = 9986,
            LINEAR_MIPMAP_LINEAR = 9987
    }
    /**
        * WebGL Texture Wrap Modes
        */
    export const enum TextureWrapMode {
            REPEAT = 10497,
            CLAMP_TO_EDGE = 33071,
            MIRRORED_REPEAT = 33648
    }
    /**
        * Raw texture data and descriptor sufficient for WebGL texture upload
        */
    export interface TextureData {
            /**
                * Width of image
                */
            width: number;
            /**
                * Height of image
                */
            height: number;
            /**
                * Format of pixels in data
                */
            format: PixelFormat;
            /**
                * Row byte alignment of pixels in data
                */
            alignment: number;
            /**
                * Pixel data
                */
            data: ArrayBufferView;
    }
    /**
        * Wraps sampling parameters for a WebGL texture
        */
    export interface SamplingParameters {
            /**
                * Magnification mode when upsampling from a WebGL texture
                */
            magFilter?: TextureMagFilter;
            /**
                * Minification mode when upsampling from a WebGL texture
                */
            minFilter?: TextureMinFilter;
            /**
                * X axis wrapping mode when sampling out of a WebGL texture bounds
                */
            wrapS?: TextureWrapMode;
            /**
                * Y axis wrapping mode when sampling out of a WebGL texture bounds
                */
            wrapT?: TextureWrapMode;
            /**
             * Anisotropic filtering samples
             */
            maxAnisotropy?: number;
    }
    /**
        * Represents a valid WebGL texture source for use in texImage2D
        */
    export type TextureSource = TextureData | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement;
    /**
        * A generic set of texture mipmaps (where index 0 has the largest dimension)
        */
    export type Mipmaps<T> = Array<T>;
    /**
        * A set of 6 cubemap arranged in the order [+x, -x, +y, -y, +z, -z]
        */
    export type Faces<T> = Array<T>;
    /**
        * A set of texture mipmaps specifically for 2D textures in WebGL (where index 0 has the largest dimension)
        */
    export type Mipmaps2D = Mipmaps<TextureSource>;
    /**
        * A set of texture mipmaps specifically for cubemap textures in WebGL (where index 0 has the largest dimension)
        */
    export type MipmapsCube = Mipmaps<Faces<TextureSource>>;
    /**
        * A minimal WebGL cubemap descriptor
        */
    export class TextureCube {
            internalFormat: PixelFormat;
            type: PixelType;
            source: MipmapsCube;
            /**
                * Returns the width of a face of the texture or 0 if not available
                */
            readonly Width: number;
            /**
                * Returns the height of a face of the texture or 0 if not available
                */
            readonly Height: number;
            /**
                * constructor
                * @param internalFormat WebGL pixel format for the texture on the GPU
                * @param type WebGL pixel type of the supplied data and texture on the GPU
                * @param source An array containing mipmap levels of faces, where each mipmap level is an array of faces and each face is a TextureSource object
                */
            constructor(internalFormat: PixelFormat, type: PixelType, source?: MipmapsCube);
    }
    /**
                * A static class providing methods to aid working with Bablyon textures.
                */
    export class TextureUtils {
            /**
                * A prefix used when storing a babylon texture object reference on a Spectre texture object
                */
            static BabylonTextureKeyPrefix: string;
            /**
                * Controls anisotropic filtering for deserialized textures.
                */
            static MaxAnisotropy: number;
            /**
                * Returns a BabylonCubeTexture instance from a Spectre texture cube, subject to sampling parameters.
                * If such a texture has already been requested in the past, this texture will be returned, otherwise a new one will be created.
                * The advantage of this is to enable working with texture objects without the need to initialize on the GPU until desired.
                * @param scene A Babylon Scene instance
                * @param textureCube A Spectre TextureCube object
                * @param parameters WebGL texture sampling parameters
                * @param automaticMipmaps Pass true to enable automatic mipmap generation where possible (requires power of images)
                * @param environment Specifies that the texture will be used as an environment
                * @param singleLod Specifies that the texture will be a singleLod (for environment)
                * @return Babylon cube texture
                */
            static GetBabylonCubeTexture(scene: Scene, textureCube: TextureCube, automaticMipmaps: boolean, environment?: boolean, singleLod?: boolean): CubeTexture;
            /**
                * Applies Spectre SamplingParameters to a Babylon texture by directly setting texture parameters on the internal WebGLTexture as well as setting Babylon fields
                * @param babylonTexture Babylon texture to apply texture to (requires the Babylon texture has an initialize _texture field)
                * @param parameters Spectre SamplingParameters to apply
                */
            static ApplySamplingParameters(babylonTexture: BaseTexture, parameters: SamplingParameters): void;
            /**
                * Environment preprocessing dedicated value (Internal Use or Advanced only).
                */
            static EnvironmentLODScale: number;
            /**
                * Environment preprocessing dedicated value (Internal Use or Advanced only)..
                */
            static EnvironmentLODOffset: number;
    }
}

