declare module BABYLON {
    /** Alias type for value that can be null */
    export type Nullable<T> = T | null;
    /**
     * Alias type for number that are floats
     * @ignorenaming
     */
    export type float = number;
    /**
     * Alias type for number that are doubles.
     * @ignorenaming
     */
    export type double = number;
    /**
     * Alias type for number that are integer
     * @ignorenaming
     */
    export type int = number;
    /** Alias type for number array or Float32Array */
    export type FloatArray = number[] | Float32Array;
    /** Alias type for number array or Float32Array or Int32Array or Uint32Array or Uint16Array */
    export type IndicesArray = number[] | Int32Array | Uint32Array | Uint16Array;
    /**
     * Alias for types that can be used by a Buffer or VertexBuffer.
     */
    export type DataArray = number[] | ArrayBuffer | ArrayBufferView;
    /**
     * Alias type for primitive types
     * @ignorenaming
     */
    type Primitive = undefined | null | boolean | string | number | Function;
    /**
     * Type modifier to make all the properties of an object Readonly
     */
    export type Immutable<T> = T extends Primitive ? T : T extends Array<infer U> ? ReadonlyArray<U> : DeepImmutable<T>;
    /**
     * Type modifier to make all the properties of an object Readonly recursively
     */
    export type DeepImmutable<T> = T extends Primitive ? T : T extends Array<infer U> ? DeepImmutableArray<U> : DeepImmutableObject<T>;
    /**
     * Type modifier to make object properties readonly.
     */
    export type DeepImmutableObject<T> = {
        readonly [K in keyof T]: DeepImmutable<T[K]>;
    };
    /** @hidden */
    interface DeepImmutableArray<T> extends ReadonlyArray<DeepImmutable<T>> {
    }
}
declare module BABYLON {
    /**
     * A class serves as a medium between the observable and its observers
     */
    export class EventState {
        /**
         * Create a new EventState
         * @param mask defines the mask associated with this state
         * @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true
         * @param target defines the original target of the state
         * @param currentTarget defines the current target of the state
         */
        constructor(mask: number, skipNextObservers?: boolean, target?: any, currentTarget?: any);
        /**
         * Initialize the current event state
         * @param mask defines the mask associated with this state
         * @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true
         * @param target defines the original target of the state
         * @param currentTarget defines the current target of the state
         * @returns the current event state
         */
        initalize(mask: number, skipNextObservers?: boolean, target?: any, currentTarget?: any): EventState;
        /**
         * An Observer can set this property to true to prevent subsequent observers of being notified
         */
        skipNextObservers: boolean;
        /**
         * Get the mask value that were used to trigger the event corresponding to this EventState object
         */
        mask: number;
        /**
         * The object that originally notified the event
         */
        target?: any;
        /**
         * The current object in the bubbling phase
         */
        currentTarget?: any;
        /**
         * This will be populated with the return value of the last function that was executed.
         * If it is the first function in the callback chain it will be the event data.
         */
        lastReturnValue?: any;
    }
    /**
     * Represent an Observer registered to a given Observable object.
     */
    export class Observer<T> {
        /**
         * Defines the callback to call when the observer is notified
         */
        callback: (eventData: T, eventState: EventState) => void;
        /**
         * Defines the mask of the observer (used to filter notifications)
         */
        mask: number;
        /**
         * Defines the current scope used to restore the JS context
         */
        scope: any;
        /** @hidden */
        _willBeUnregistered: boolean;
        /**
         * Gets or sets a property defining that the observer as to be unregistered after the next notification
         */
        unregisterOnNextCall: boolean;
        /**
         * Creates a new observer
         * @param callback defines the callback to call when the observer is notified
         * @param mask defines the mask of the observer (used to filter notifications)
         * @param scope defines the current scope used to restore the JS context
         */
        constructor(
        /**
         * Defines the callback to call when the observer is notified
         */
        callback: (eventData: T, eventState: EventState) => void, 
        /**
         * Defines the mask of the observer (used to filter notifications)
         */
        mask: number, 
        /**
         * Defines the current scope used to restore the JS context
         */
        scope?: any);
    }
    /**
     * Represent a list of observers registered to multiple Observables object.
     */
    export class MultiObserver<T> {
        private _observers;
        private _observables;
        /**
         * Release associated resources
         */
        dispose(): void;
        /**
         * Raise a callback when one of the observable will notify
         * @param observables defines a list of observables to watch
         * @param callback defines the callback to call on notification
         * @param mask defines the mask used to filter notifications
         * @param scope defines the current scope used to restore the JS context
         * @returns the new MultiObserver
         */
        static Watch<T>(observables: Observable<T>[], callback: (eventData: T, eventState: EventState) => void, mask?: number, scope?: any): MultiObserver<T>;
    }
    /**
     * The Observable class is a simple implementation of the Observable pattern.
     *
     * There's one slight particularity though: a given Observable can notify its observer using a particular mask value, only the Observers registered with this mask value will be notified.
     * This enable a more fine grained execution without having to rely on multiple different Observable objects.
     * For instance you may have a given Observable that have four different types of notifications: Move (mask = 0x01), Stop (mask = 0x02), Turn Right (mask = 0X04), Turn Left (mask = 0X08).
     * A given observer can register itself with only Move and Stop (mask = 0x03), then it will only be notified when one of these two occurs and will never be for Turn Left/Right.
     */
    export class Observable<T> {
        private _observers;
        private _eventState;
        private _onObserverAdded;
        /**
         * Gets the list of observers
         */
        get observers(): Array<Observer<T>>;
        /**
         * Creates a new observable
         * @param onObserverAdded defines a callback to call when a new observer is added
         */
        constructor(onObserverAdded?: (observer: Observer<T>) => void);
        /**
         * Create a new Observer with the specified callback
         * @param callback the callback that will be executed for that Observer
         * @param mask the mask used to filter observers
         * @param insertFirst if true the callback will be inserted at the first position, hence executed before the others ones. If false (default behavior) the callback will be inserted at the last position, executed after all the others already present.
         * @param scope optional scope for the callback to be called from
         * @param unregisterOnFirstCall defines if the observer as to be unregistered after the next notification
         * @returns the new observer created for the callback
         */
        add(callback: (eventData: T, eventState: EventState) => void, mask?: number, insertFirst?: boolean, scope?: any, unregisterOnFirstCall?: boolean): Nullable<Observer<T>>;
        /**
         * Create a new Observer with the specified callback and unregisters after the next notification
         * @param callback the callback that will be executed for that Observer
         * @returns the new observer created for the callback
         */
        addOnce(callback: (eventData: T, eventState: EventState) => void): Nullable<Observer<T>>;
        /**
         * Remove an Observer from the Observable object
         * @param observer the instance of the Observer to remove
         * @returns false if it doesn't belong to this Observable
         */
        remove(observer: Nullable<Observer<T>>): boolean;
        /**
         * Remove a callback from the Observable object
         * @param callback the callback to remove
         * @param scope optional scope. If used only the callbacks with this scope will be removed
         * @returns false if it doesn't belong to this Observable
        */
        removeCallback(callback: (eventData: T, eventState: EventState) => void, scope?: any): boolean;
        private _deferUnregister;
        private _remove;
        /**
         * Moves the observable to the top of the observer list making it get called first when notified
         * @param observer the observer to move
         */
        makeObserverTopPriority(observer: Observer<T>): void;
        /**
         * Moves the observable to the bottom of the observer list making it get called last when notified
         * @param observer the observer to move
         */
        makeObserverBottomPriority(observer: Observer<T>): void;
        /**
         * Notify all Observers by calling their respective callback with the given data
         * Will return true if all observers were executed, false if an observer set skipNextObservers to true, then prevent the subsequent ones to execute
         * @param eventData defines the data to send to all observers
         * @param mask defines the mask of the current notification (observers with incompatible mask (ie mask & observer.mask === 0) will not be notified)
         * @param target defines the original target of the state
         * @param currentTarget defines the current target of the state
         * @returns false if the complete observer chain was not processed (because one observer set the skipNextObservers to true)
         */
        notifyObservers(eventData: T, mask?: number, target?: any, currentTarget?: any): boolean;
        /**
         * Calling this will execute each callback, expecting it to be a promise or return a value.
         * If at any point in the chain one function fails, the promise will fail and the execution will not continue.
         * This is useful when a chain of events (sometimes async events) is needed to initialize a certain object
         * and it is crucial that all callbacks will be executed.
         * The order of the callbacks is kept, callbacks are not executed parallel.
         *
         * @param eventData The data to be sent to each callback
         * @param mask is used to filter observers defaults to -1
         * @param target defines the callback target (see EventState)
         * @param currentTarget defines he current object in the bubbling phase
         * @returns {Promise<T>} will return a Promise than resolves when all callbacks executed successfully.
         */
        notifyObserversWithPromise(eventData: T, mask?: number, target?: any, currentTarget?: any): Promise<T>;
        /**
         * Notify a specific observer
         * @param observer defines the observer to notify
         * @param eventData defines the data to be sent to each callback
         * @param mask is used to filter observers defaults to -1
         */
        notifyObserver(observer: Observer<T>, eventData: T, mask?: number): void;
        /**
         * Gets a boolean indicating if the observable has at least one observer
         * @returns true is the Observable has at least one Observer registered
         */
        hasObservers(): boolean;
        /**
        * Clear the list of observers
        */
        clear(): void;
        /**
         * Clone the current observable
         * @returns a new observable
         */
        clone(): Observable<T>;
        /**
         * Does this observable handles observer registered with a given mask
         * @param mask defines the mask to be tested
         * @return whether or not one observer registered with the given mask is handeled
        **/
        hasSpecificMask(mask?: number): boolean;
    }
}
declare module BABYLON {
    /**
     * Sets of helpers dealing with the DOM and some of the recurrent functions needed in
     * Babylon.js
     */
    export class DomManagement {
        /**
         * Checks if the window object exists
         * @returns true if the window object exists
         */
        static IsWindowObjectExist(): boolean;
        /**
         * Checks if the navigator object exists
         * @returns true if the navigator object exists
         */
        static IsNavigatorAvailable(): boolean;
        /**
         * Check if the document object exists
         * @returns true if the document object exists
         */
        static IsDocumentAvailable(): boolean;
        /**
         * Extracts text content from a DOM element hierarchy
         * @param element defines the root element
         * @returns a string
         */
        static GetDOMTextContent(element: HTMLElement): string;
    }
}
declare module BABYLON {
    /**
     * Logger used througouht the application to allow configuration of
     * the log level required for the messages.
     */
    export class Logger {
        /**
         * No log
         */
        static readonly NoneLogLevel: number;
        /**
         * Only message logs
         */
        static readonly MessageLogLevel: number;
        /**
         * Only warning logs
         */
        static readonly WarningLogLevel: number;
        /**
         * Only error logs
         */
        static readonly ErrorLogLevel: number;
        /**
         * All logs
         */
        static readonly AllLogLevel: number;
        private static _LogCache;
        /**
         * Gets a value indicating the number of loading errors
         * @ignorenaming
         */
        static errorsCount: number;
        /**
         * Callback called when a new log is added
         */
        static OnNewCacheEntry: (entry: string) => void;
        private static _AddLogEntry;
        private static _FormatMessage;
        private static _LogDisabled;
        private static _LogEnabled;
        private static _WarnDisabled;
        private static _WarnEnabled;
        private static _ErrorDisabled;
        private static _ErrorEnabled;
        /**
         * Log a message to the console
         */
        static Log: (message: string) => void;
        /**
         * Write a warning message to the console
         */
        static Warn: (message: string) => void;
        /**
         * Write an error message to the console
         */
        static Error: (message: string) => void;
        /**
         * Gets current log cache (list of logs)
         */
        static get LogCache(): string;
        /**
         * Clears the log cache
         */
        static ClearLogCache(): void;
        /**
         * Sets the current log level (MessageLogLevel / WarningLogLevel / ErrorLogLevel)
         */
        static set LogLevels(level: number);
    }
}
declare module BABYLON {
    /** @hidden */
    export class _TypeStore {
        /** @hidden */
        static RegisteredTypes: {
            [key: string]: Object;
        };
        /** @hidden */
        static GetClass(fqdn: string): any;
    }
}
declare module BABYLON {
    /**
     * Helper to manipulate strings
     */
    export class StringTools {
        /**
         * Checks for a matching suffix at the end of a string (for ES5 and lower)
         * @param str Source string
         * @param suffix Suffix to search for in the source string
         * @returns Boolean indicating whether the suffix was found (true) or not (false)
         */
        static EndsWith(str: string, suffix: string): boolean;
        /**
         * Checks for a matching suffix at the beginning of a string (for ES5 and lower)
         * @param str Source string
         * @param suffix Suffix to search for in the source string
         * @returns Boolean indicating whether the suffix was found (true) or not (false)
         */
        static StartsWith(str: string, suffix: string): boolean;
        /**
         * Decodes a buffer into a string
         * @param buffer The buffer to decode
         * @returns The decoded string
         */
        static Decode(buffer: Uint8Array | Uint16Array): string;
        /**
         * Encode a buffer to a base64 string
         * @param buffer defines the buffer to encode
         * @returns the encoded string
         */
        static EncodeArrayBufferToBase64(buffer: ArrayBuffer | ArrayBufferView): string;
        /**
        * Converts a number to string and pads with preceeding zeroes until it is of specified length.
        * @param num the number to convert and pad
        * @param length the expected length of the string
        * @returns the padded string
        */
        static PadNumber(num: number, length: number): string;
    }
}
declare module BABYLON {
    /**
     * Class containing a set of static utilities functions for deep copy.
     */
    export class DeepCopier {
        /**
         * Tries to copy an object by duplicating every property
         * @param source defines the source object
         * @param destination defines the target object
         * @param doNotCopyList defines a list of properties to avoid
         * @param mustCopyList defines a list of properties to copy (even if they start with _)
         */
        static DeepCopy(source: any, destination: any, doNotCopyList?: string[], mustCopyList?: string[]): void;
    }
}
declare module BABYLON {
    /**
     * Class containing a set of static utilities functions for precision date
     */
    export class PrecisionDate {
        /**
         * Gets either window.performance.now() if supported or Date.now() else
         */
        static get Now(): number;
    }
}
declare module BABYLON {
    /** @hidden */
    export class _DevTools {
        static WarnImport(name: string): string;
    }
}
declare module BABYLON {
    /**
     * Interface used to define the mechanism to get data from the network
     */
    export interface IWebRequest {
        /**
         * Returns client's response url
         */
        responseURL: string;
        /**
         * Returns client's status
         */
        status: number;
        /**
         * Returns client's status as a text
         */
        statusText: string;
    }
}
declare module BABYLON {
    /**
     * Extended version of XMLHttpRequest with support for customizations (headers, ...)
     */
    export class WebRequest implements IWebRequest {
        private _xhr;
        /**
         * Custom HTTP Request Headers to be sent with XMLHttpRequests
         * i.e. when loading files, where the server/service expects an Authorization header
         */
        static CustomRequestHeaders: {
            [key: string]: string;
        };
        /**
         * Add callback functions in this array to update all the requests before they get sent to the network
         */
        static CustomRequestModifiers: ((request: XMLHttpRequest, url: string) => void)[];
        private _injectCustomRequestHeaders;
        /**
         * Gets or sets a function to be called when loading progress changes
         */
        get onprogress(): ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;
        set onprogress(value: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null);
        /**
         * Returns client's state
         */
        get readyState(): number;
        /**
         * Returns client's status
         */
        get status(): number;
        /**
         * Returns client's status as a text
         */
        get statusText(): string;
        /**
         * Returns client's response
         */
        get response(): any;
        /**
         * Returns client's response url
         */
        get responseURL(): string;
        /**
         * Returns client's response as text
         */
        get responseText(): string;
        /**
         * Gets or sets the expected response type
         */
        get responseType(): XMLHttpRequestResponseType;
        set responseType(value: XMLHttpRequestResponseType);
        /** @hidden */
        addEventListener<K extends keyof XMLHttpRequestEventMap>(type: K, listener: (this: XMLHttpRequest, ev: XMLHttpRequestEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        /** @hidden */
        removeEventListener<K extends keyof XMLHttpRequestEventMap>(type: K, listener: (this: XMLHttpRequest, ev: XMLHttpRequestEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        /**
         * Cancels any network activity
         */
        abort(): void;
        /**
         * Initiates the request. The optional argument provides the request body. The argument is ignored if request method is GET or HEAD
         * @param body defines an optional request body
         */
        send(body?: Document | BodyInit | null): void;
        /**
         * Sets the request method, request URL
         * @param method defines the method to use (GET, POST, etc..)
         * @param url defines the url to connect with
         */
        open(method: string, url: string): void;
        /**
         * Sets the value of a request header.
         * @param name The name of the header whose value is to be set
         * @param value The value to set as the body of the header
         */
        setRequestHeader(name: string, value: string): void;
        /**
         * Get the string containing the text of a particular header's value.
         * @param name The name of the header
         * @returns The string containing the text of the given header name
         */
        getResponseHeader(name: string): Nullable<string>;
    }
}
declare module BABYLON {
    /**
     * File request interface
     */
    export interface IFileRequest {
        /**
         * Raised when the request is complete (success or error).
         */
        onCompleteObservable: Observable<IFileRequest>;
        /**
         * Aborts the request for a file.
         */
        abort: () => void;
    }
}
declare module BABYLON {
    /**
     * Define options used to create a render target texture
     */
    export class RenderTargetCreationOptions {
        /**
         * Specifies is mipmaps must be generated
         */
        generateMipMaps?: boolean;
        /** Specifies whether or not a depth should be allocated in the texture (true by default) */
        generateDepthBuffer?: boolean;
        /** Specifies whether or not a stencil should be allocated in the texture (false by default)*/
        generateStencilBuffer?: boolean;
        /** Defines texture type (int by default) */
        type?: number;
        /** Defines sampling mode (trilinear by default) */
        samplingMode?: number;
        /** Defines format (RGBA by default) */
        format?: number;
    }
}
declare module BABYLON {
    /** Defines the cross module used constants to avoid circular dependncies */
    export class Constants {
        /** Defines that alpha blending is disabled */
        static readonly ALPHA_DISABLE: number;
        /** Defines that alpha blending is SRC ALPHA * SRC + DEST */
        static readonly ALPHA_ADD: number;
        /** Defines that alpha blending is SRC ALPHA * SRC + (1 - SRC ALPHA) * DEST */
        static readonly ALPHA_COMBINE: number;
        /** Defines that alpha blending is DEST - SRC * DEST */
        static readonly ALPHA_SUBTRACT: number;
        /** Defines that alpha blending is SRC * DEST */
        static readonly ALPHA_MULTIPLY: number;
        /** Defines that alpha blending is SRC ALPHA * SRC + (1 - SRC) * DEST */
        static readonly ALPHA_MAXIMIZED: number;
        /** Defines that alpha blending is SRC + DEST */
        static readonly ALPHA_ONEONE: number;
        /** Defines that alpha blending is SRC + (1 - SRC ALPHA) * DEST */
        static readonly ALPHA_PREMULTIPLIED: number;
        /**
         * Defines that alpha blending is SRC + (1 - SRC ALPHA) * DEST
         * Alpha will be set to (1 - SRC ALPHA) * DEST ALPHA
         */
        static readonly ALPHA_PREMULTIPLIED_PORTERDUFF: number;
        /** Defines that alpha blending is CST * SRC + (1 - CST) * DEST */
        static readonly ALPHA_INTERPOLATE: number;
        /**
         * Defines that alpha blending is SRC + (1 - SRC) * DEST
         * Alpha will be set to SRC ALPHA + (1 - SRC ALPHA) * DEST ALPHA
         */
        static readonly ALPHA_SCREENMODE: number;
        /**
         * Defines that alpha blending is SRC + DST
         * Alpha will be set to SRC ALPHA + DST ALPHA
         */
        static readonly ALPHA_ONEONE_ONEONE: number;
        /**
         * Defines that alpha blending is SRC * DST ALPHA + DST
         * Alpha will be set to 0
         */
        static readonly ALPHA_ALPHATOCOLOR: number;
        /**
         * Defines that alpha blending is SRC * (1 - DST) + DST * (1 - SRC)
         */
        static readonly ALPHA_REVERSEONEMINUS: number;
        /**
         * Defines that alpha blending is SRC + DST * (1 - SRC ALPHA)
         * Alpha will be set to SRC ALPHA + DST ALPHA * (1 - SRC ALPHA)
         */
        static readonly ALPHA_SRC_DSTONEMINUSSRCALPHA: number;
        /**
         * Defines that alpha blending is SRC + DST
         * Alpha will be set to SRC ALPHA
         */
        static readonly ALPHA_ONEONE_ONEZERO: number;
        /**
         * Defines that alpha blending is SRC * (1 - DST) + DST * (1 - SRC)
         * Alpha will be set to DST ALPHA
         */
        static readonly ALPHA_EXCLUSION: number;
        /** Defines that alpha blending equation a SUM */
        static readonly ALPHA_EQUATION_ADD: number;
        /** Defines that alpha blending equation a SUBSTRACTION */
        static readonly ALPHA_EQUATION_SUBSTRACT: number;
        /** Defines that alpha blending equation a REVERSE SUBSTRACTION */
        static readonly ALPHA_EQUATION_REVERSE_SUBTRACT: number;
        /** Defines that alpha blending equation a MAX operation */
        static readonly ALPHA_EQUATION_MAX: number;
        /** Defines that alpha blending equation a MIN operation */
        static readonly ALPHA_EQUATION_MIN: number;
        /**
         * Defines that alpha blending equation a DARKEN operation:
         * It takes the min of the src and sums the alpha channels.
         */
        static readonly ALPHA_EQUATION_DARKEN: number;
        /** Defines that the ressource is not delayed*/
        static readonly DELAYLOADSTATE_NONE: number;
        /** Defines that the ressource was successfully delay loaded */
        static readonly DELAYLOADSTATE_LOADED: number;
        /** Defines that the ressource is currently delay loading */
        static readonly DELAYLOADSTATE_LOADING: number;
        /** Defines that the ressource is delayed and has not started loading */
        static readonly DELAYLOADSTATE_NOTLOADED: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will never pass. i.e. Nothing will be drawn */
        static readonly NEVER: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn */
        static readonly ALWAYS: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than the stored value */
        static readonly LESS: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is equals to the stored value */
        static readonly EQUAL: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than or equal to the stored value */
        static readonly LEQUAL: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than the stored value */
        static readonly GREATER: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than or equal to the stored value */
        static readonly GEQUAL: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is not equal to the stored value */
        static readonly NOTEQUAL: number;
        /** Passed to stencilOperation to specify that stencil value must be kept */
        static readonly KEEP: number;
        /** Passed to stencilOperation to specify that stencil value must be replaced */
        static readonly REPLACE: number;
        /** Passed to stencilOperation to specify that stencil value must be incremented */
        static readonly INCR: number;
        /** Passed to stencilOperation to specify that stencil value must be decremented */
        static readonly DECR: number;
        /** Passed to stencilOperation to specify that stencil value must be inverted */
        static readonly INVERT: number;
        /** Passed to stencilOperation to specify that stencil value must be incremented with wrapping */
        static readonly INCR_WRAP: number;
        /** Passed to stencilOperation to specify that stencil value must be decremented with wrapping */
        static readonly DECR_WRAP: number;
        /** Texture is not repeating outside of 0..1 UVs */
        static readonly TEXTURE_CLAMP_ADDRESSMODE: number;
        /** Texture is repeating outside of 0..1 UVs */
        static readonly TEXTURE_WRAP_ADDRESSMODE: number;
        /** Texture is repeating and mirrored */
        static readonly TEXTURE_MIRROR_ADDRESSMODE: number;
        /** ALPHA */
        static readonly TEXTUREFORMAT_ALPHA: number;
        /** LUMINANCE */
        static readonly TEXTUREFORMAT_LUMINANCE: number;
        /** LUMINANCE_ALPHA */
        static readonly TEXTUREFORMAT_LUMINANCE_ALPHA: number;
        /** RGB */
        static readonly TEXTUREFORMAT_RGB: number;
        /** RGBA */
        static readonly TEXTUREFORMAT_RGBA: number;
        /** RED */
        static readonly TEXTUREFORMAT_RED: number;
        /** RED (2nd reference) */
        static readonly TEXTUREFORMAT_R: number;
        /** RG */
        static readonly TEXTUREFORMAT_RG: number;
        /** RED_INTEGER */
        static readonly TEXTUREFORMAT_RED_INTEGER: number;
        /** RED_INTEGER (2nd reference) */
        static readonly TEXTUREFORMAT_R_INTEGER: number;
        /** RG_INTEGER */
        static readonly TEXTUREFORMAT_RG_INTEGER: number;
        /** RGB_INTEGER */
        static readonly TEXTUREFORMAT_RGB_INTEGER: number;
        /** RGBA_INTEGER */
        static readonly TEXTUREFORMAT_RGBA_INTEGER: number;
        /** UNSIGNED_BYTE */
        static readonly TEXTURETYPE_UNSIGNED_BYTE: number;
        /** UNSIGNED_BYTE (2nd reference) */
        static readonly TEXTURETYPE_UNSIGNED_INT: number;
        /** FLOAT */
        static readonly TEXTURETYPE_FLOAT: number;
        /** HALF_FLOAT */
        static readonly TEXTURETYPE_HALF_FLOAT: number;
        /** BYTE */
        static readonly TEXTURETYPE_BYTE: number;
        /** SHORT */
        static readonly TEXTURETYPE_SHORT: number;
        /** UNSIGNED_SHORT */
        static readonly TEXTURETYPE_UNSIGNED_SHORT: number;
        /** INT */
        static readonly TEXTURETYPE_INT: number;
        /** UNSIGNED_INT */
        static readonly TEXTURETYPE_UNSIGNED_INTEGER: number;
        /** UNSIGNED_SHORT_4_4_4_4 */
        static readonly TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4: number;
        /** UNSIGNED_SHORT_5_5_5_1 */
        static readonly TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1: number;
        /** UNSIGNED_SHORT_5_6_5 */
        static readonly TEXTURETYPE_UNSIGNED_SHORT_5_6_5: number;
        /** UNSIGNED_INT_2_10_10_10_REV */
        static readonly TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV: number;
        /** UNSIGNED_INT_24_8 */
        static readonly TEXTURETYPE_UNSIGNED_INT_24_8: number;
        /** UNSIGNED_INT_10F_11F_11F_REV */
        static readonly TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV: number;
        /** UNSIGNED_INT_5_9_9_9_REV */
        static readonly TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV: number;
        /** FLOAT_32_UNSIGNED_INT_24_8_REV */
        static readonly TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV: number;
        /** nearest is mag = nearest and min = nearest and no mip */
        static readonly TEXTURE_NEAREST_SAMPLINGMODE: number;
        /** mag = nearest and min = nearest and mip = none */
        static readonly TEXTURE_NEAREST_NEAREST: number;
        /** Bilinear is mag = linear and min = linear and no mip */
        static readonly TEXTURE_BILINEAR_SAMPLINGMODE: number;
        /** mag = linear and min = linear and mip = none */
        static readonly TEXTURE_LINEAR_LINEAR: number;
        /** Trilinear is mag = linear and min = linear and mip = linear */
        static readonly TEXTURE_TRILINEAR_SAMPLINGMODE: number;
        /** Trilinear is mag = linear and min = linear and mip = linear */
        static readonly TEXTURE_LINEAR_LINEAR_MIPLINEAR: number;
        /** mag = nearest and min = nearest and mip = nearest */
        static readonly TEXTURE_NEAREST_NEAREST_MIPNEAREST: number;
        /** mag = nearest and min = linear and mip = nearest */
        static readonly TEXTURE_NEAREST_LINEAR_MIPNEAREST: number;
        /** mag = nearest and min = linear and mip = linear */
        static readonly TEXTURE_NEAREST_LINEAR_MIPLINEAR: number;
        /** mag = nearest and min = linear and mip = none */
        static readonly TEXTURE_NEAREST_LINEAR: number;
        /** nearest is mag = nearest and min = nearest and mip = linear */
        static readonly TEXTURE_NEAREST_NEAREST_MIPLINEAR: number;
        /** mag = linear and min = nearest and mip = nearest */
        static readonly TEXTURE_LINEAR_NEAREST_MIPNEAREST: number;
        /** mag = linear and min = nearest and mip = linear */
        static readonly TEXTURE_LINEAR_NEAREST_MIPLINEAR: number;
        /** Bilinear is mag = linear and min = linear and mip = nearest */
        static readonly TEXTURE_LINEAR_LINEAR_MIPNEAREST: number;
        /** mag = linear and min = nearest and mip = none */
        static readonly TEXTURE_LINEAR_NEAREST: number;
        /** Explicit coordinates mode */
        static readonly TEXTURE_EXPLICIT_MODE: number;
        /** Spherical coordinates mode */
        static readonly TEXTURE_SPHERICAL_MODE: number;
        /** Planar coordinates mode */
        static readonly TEXTURE_PLANAR_MODE: number;
        /** Cubic coordinates mode */
        static readonly TEXTURE_CUBIC_MODE: number;
        /** Projection coordinates mode */
        static readonly TEXTURE_PROJECTION_MODE: number;
        /** Skybox coordinates mode */
        static readonly TEXTURE_SKYBOX_MODE: number;
        /** Inverse Cubic coordinates mode */
        static readonly TEXTURE_INVCUBIC_MODE: number;
        /** Equirectangular coordinates mode */
        static readonly TEXTURE_EQUIRECTANGULAR_MODE: number;
        /** Equirectangular Fixed coordinates mode */
        static readonly TEXTURE_FIXED_EQUIRECTANGULAR_MODE: number;
        /** Equirectangular Fixed Mirrored coordinates mode */
        static readonly TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE: number;
        /** Offline (baking) quality for texture filtering */
        static readonly TEXTURE_FILTERING_QUALITY_OFFLINE: number;
        /** High quality for texture filtering */
        static readonly TEXTURE_FILTERING_QUALITY_HIGH: number;
        /** Medium quality for texture filtering */
        static readonly TEXTURE_FILTERING_QUALITY_MEDIUM: number;
        /** Low quality for texture filtering */
        static readonly TEXTURE_FILTERING_QUALITY_LOW: number;
        /** Defines that texture rescaling will use a floor to find the closer power of 2 size */
        static readonly SCALEMODE_FLOOR: number;
        /** Defines that texture rescaling will look for the nearest power of 2 size */
        static readonly SCALEMODE_NEAREST: number;
        /** Defines that texture rescaling will use a ceil to find the closer power of 2 size */
        static readonly SCALEMODE_CEILING: number;
        /**
         * The dirty texture flag value
         */
        static readonly MATERIAL_TextureDirtyFlag: number;
        /**
         * The dirty light flag value
         */
        static readonly MATERIAL_LightDirtyFlag: number;
        /**
         * The dirty fresnel flag value
         */
        static readonly MATERIAL_FresnelDirtyFlag: number;
        /**
         * The dirty attribute flag value
         */
        static readonly MATERIAL_AttributesDirtyFlag: number;
        /**
         * The dirty misc flag value
         */
        static readonly MATERIAL_MiscDirtyFlag: number;
        /**
         * The all dirty flag value
         */
        static readonly MATERIAL_AllDirtyFlag: number;
        /**
         * Returns the triangle fill mode
         */
        static readonly MATERIAL_TriangleFillMode: number;
        /**
         * Returns the wireframe mode
         */
        static readonly MATERIAL_WireFrameFillMode: number;
        /**
         * Returns the point fill mode
         */
        static readonly MATERIAL_PointFillMode: number;
        /**
         * Returns the point list draw mode
         */
        static readonly MATERIAL_PointListDrawMode: number;
        /**
         * Returns the line list draw mode
         */
        static readonly MATERIAL_LineListDrawMode: number;
        /**
         * Returns the line loop draw mode
         */
        static readonly MATERIAL_LineLoopDrawMode: number;
        /**
         * Returns the line strip draw mode
         */
        static readonly MATERIAL_LineStripDrawMode: number;
        /**
         * Returns the triangle strip draw mode
         */
        static readonly MATERIAL_TriangleStripDrawMode: number;
        /**
         * Returns the triangle fan draw mode
         */
        static readonly MATERIAL_TriangleFanDrawMode: number;
        /**
         * Stores the clock-wise side orientation
         */
        static readonly MATERIAL_ClockWiseSideOrientation: number;
        /**
         * Stores the counter clock-wise side orientation
         */
        static readonly MATERIAL_CounterClockWiseSideOrientation: number;
        /**
         * Nothing
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly ACTION_NothingTrigger: number;
        /**
         * On pick
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly ACTION_OnPickTrigger: number;
        /**
         * On left pick
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly ACTION_OnLeftPickTrigger: number;
        /**
         * On right pick
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly ACTION_OnRightPickTrigger: number;
        /**
         * On center pick
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly ACTION_OnCenterPickTrigger: number;
        /**
         * On pick down
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly ACTION_OnPickDownTrigger: number;
        /**
         * On double pick
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly ACTION_OnDoublePickTrigger: number;
        /**
         * On pick up
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly ACTION_OnPickUpTrigger: number;
        /**
         * On pick out.
         * This trigger will only be raised if you also declared a OnPickDown
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly ACTION_OnPickOutTrigger: number;
        /**
         * On long press
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly ACTION_OnLongPressTrigger: number;
        /**
         * On pointer over
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly ACTION_OnPointerOverTrigger: number;
        /**
         * On pointer out
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly ACTION_OnPointerOutTrigger: number;
        /**
         * On every frame
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly ACTION_OnEveryFrameTrigger: number;
        /**
         * On intersection enter
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly ACTION_OnIntersectionEnterTrigger: number;
        /**
         * On intersection exit
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly ACTION_OnIntersectionExitTrigger: number;
        /**
         * On key down
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly ACTION_OnKeyDownTrigger: number;
        /**
         * On key up
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly ACTION_OnKeyUpTrigger: number;
        /**
         * Billboard mode will only apply to Y axis
         */
        static readonly PARTICLES_BILLBOARDMODE_Y: number;
        /**
         * Billboard mode will apply to all axes
         */
        static readonly PARTICLES_BILLBOARDMODE_ALL: number;
        /**
         * Special billboard mode where the particle will be biilboard to the camera but rotated to align with direction
         */
        static readonly PARTICLES_BILLBOARDMODE_STRETCHED: number;
        /** Default culling strategy : this is an exclusion test and it's the more accurate.
         *  Test order :
         *  Is the bounding sphere outside the frustum ?
         *  If not, are the bounding box vertices outside the frustum ?
         *  It not, then the cullable object is in the frustum.
         */
        static readonly MESHES_CULLINGSTRATEGY_STANDARD: number;
        /** Culling strategy : Bounding Sphere Only.
         *  This is an exclusion test. It's faster than the standard strategy because the bounding box is not tested.
         *  It's also less accurate than the standard because some not visible objects can still be selected.
         *  Test : is the bounding sphere outside the frustum ?
         *  If not, then the cullable object is in the frustum.
         */
        static readonly MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY: number;
        /** Culling strategy : Optimistic Inclusion.
         *  This in an inclusion test first, then the standard exclusion test.
         *  This can be faster when a cullable object is expected to be almost always in the camera frustum.
         *  This could also be a little slower than the standard test when the tested object center is not the frustum but one of its bounding box vertex is still inside.
         *  Anyway, it's as accurate as the standard strategy.
         *  Test :
         *  Is the cullable object bounding sphere center in the frustum ?
         *  If not, apply the default culling strategy.
         */
        static readonly MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION: number;
        /** Culling strategy : Optimistic Inclusion then Bounding Sphere Only.
         *  This in an inclusion test first, then the bounding sphere only exclusion test.
         *  This can be the fastest test when a cullable object is expected to be almost always in the camera frustum.
         *  This could also be a little slower than the BoundingSphereOnly strategy when the tested object center is not in the frustum but its bounding sphere still intersects it.
         *  It's less accurate than the standard strategy and as accurate as the BoundingSphereOnly strategy.
         *  Test :
         *  Is the cullable object bounding sphere center in the frustum ?
         *  If not, apply the Bounding Sphere Only strategy. No Bounding Box is tested here.
         */
        static readonly MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY: number;
        /**
         * No logging while loading
         */
        static readonly SCENELOADER_NO_LOGGING: number;
        /**
         * Minimal logging while loading
         */
        static readonly SCENELOADER_MINIMAL_LOGGING: number;
        /**
         * Summary logging while loading
         */
        static readonly SCENELOADER_SUMMARY_LOGGING: number;
        /**
         * Detailled logging while loading
         */
        static readonly SCENELOADER_DETAILED_LOGGING: number;
        /**
         * Prepass texture index for color
         */
        static readonly PREPASS_COLOR_INDEX: number;
        /**
         * Prepass texture index for irradiance
         */
        static readonly PREPASS_IRRADIANCE_INDEX: number;
        /**
         * Prepass texture index for depth + normal
         */
        static readonly PREPASS_DEPTHNORMAL_INDEX: number;
        /**
         * Prepass texture index for albedo
         */
        static readonly PREPASS_ALBEDO_INDEX: number;
    }
}
declare module BABYLON {
    /**
     * This represents the required contract to create a new type of texture loader.
     */
    export interface IInternalTextureLoader {
        /**
         * Defines wether the loader supports cascade loading the different faces.
         */
        supportCascades: boolean;
        /**
         * This returns if the loader support the current file information.
         * @param extension defines the file extension of the file being loaded
         * @param mimeType defines the optional mime type of the file being loaded
         * @returns true if the loader can load the specified file
         */
        canLoad(extension: string, mimeType?: string): boolean;
        /**
         * Uploads the cube texture data to the WebGL texture. It has already been bound.
         * @param data contains the texture data
         * @param texture defines the BabylonJS internal texture
         * @param createPolynomials will be true if polynomials have been requested
         * @param onLoad defines the callback to trigger once the texture is ready
         * @param onError defines the callback to trigger in case of error
         */
        loadCubeData(data: ArrayBufferView | ArrayBufferView[], texture: InternalTexture, createPolynomials: boolean, onLoad: Nullable<(data?: any) => void>, onError: Nullable<(message?: string, exception?: any) => void>): void;
        /**
         * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.
         * @param data contains the texture data
         * @param texture defines the BabylonJS internal texture
         * @param callback defines the method to call once ready to upload
         */
        loadData(data: ArrayBufferView, texture: InternalTexture, callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void, loadFailed?: boolean) => void): void;
    }
}
declare module BABYLON {
    /**
     * Class used to store and describe the pipeline context associated with an effect
     */
    export interface IPipelineContext {
        /**
         * Gets a boolean indicating that this pipeline context is supporting asynchronous creating
         */
        isAsync: boolean;
        /**
         * Gets a boolean indicating that the context is ready to be used (like shaders / pipelines are compiled and ready for instance)
         */
        isReady: boolean;
        /** @hidden */
        _getVertexShaderCode(): string | null;
        /** @hidden */
        _getFragmentShaderCode(): string | null;
        /** @hidden */
        _handlesSpectorRebuildCallback(onCompiled: (compiledObject: any) => void): void;
    }
}
declare module BABYLON {
    /**
     * Class used to store gfx data (like WebGLBuffer)
     */
    export class DataBuffer {
        /**
         * Gets or sets the number of objects referencing this buffer
         */
        references: number;
        /** Gets or sets the size of the underlying buffer */
        capacity: number;
        /**
         * Gets or sets a boolean indicating if the buffer contains 32bits indices
         */
        is32Bits: boolean;
        /**
         * Gets the underlying buffer
         */
        get underlyingResource(): any;
    }
}
declare module BABYLON {
    /** @hidden */
    export interface IShaderProcessor {
        attributeProcessor?: (attribute: string) => string;
        varyingProcessor?: (varying: string, isFragment: boolean) => string;
        uniformProcessor?: (uniform: string, isFragment: boolean) => string;
        uniformBufferProcessor?: (uniformBuffer: string, isFragment: boolean) => string;
        endOfUniformBufferProcessor?: (closingBracketLine: string, isFragment: boolean) => string;
        lineProcessor?: (line: string, isFragment: boolean) => string;
        preProcessor?: (code: string, defines: string[], isFragment: boolean) => string;
        postProcessor?: (code: string, defines: string[], isFragment: boolean) => string;
    }
}
declare module BABYLON {
    /** @hidden */
    export interface ProcessingOptions {
        defines: string[];
        indexParameters: any;
        isFragment: boolean;
        shouldUseHighPrecisionShader: boolean;
        supportsUniformBuffers: boolean;
        shadersRepository: string;
        includesShadersStore: {
            [key: string]: string;
        };
        processor?: IShaderProcessor;
        version: string;
        platformName: string;
        lookForClosingBracketForUniformBuffer?: boolean;
    }
}
declare module BABYLON {
    /** @hidden */
    export class ShaderCodeNode {
        line: string;
        children: ShaderCodeNode[];
        additionalDefineKey?: string;
        additionalDefineValue?: string;
        isValid(preprocessors: {
            [key: string]: string;
        }): boolean;
        process(preprocessors: {
            [key: string]: string;
        }, options: ProcessingOptions): string;
    }
}
declare module BABYLON {
    /** @hidden */
    export class ShaderCodeCursor {
        private _lines;
        lineIndex: number;
        get currentLine(): string;
        get canRead(): boolean;
        set lines(value: string[]);
    }
}
declare module BABYLON {
    /** @hidden */
    export class ShaderCodeConditionNode extends ShaderCodeNode {
        process(preprocessors: {
            [key: string]: string;
        }, options: ProcessingOptions): string;
    }
}
declare module BABYLON {
    /** @hidden */
    export class ShaderDefineExpression {
        isTrue(preprocessors: {
            [key: string]: string;
        }): boolean;
        private static _OperatorPriority;
        private static _Stack;
        static postfixToInfix(postfix: string[]): string;
        static infixToPostfix(infix: string): string[];
    }
}
declare module BABYLON {
    /** @hidden */
    export class ShaderCodeTestNode extends ShaderCodeNode {
        testExpression: ShaderDefineExpression;
        isValid(preprocessors: {
            [key: string]: string;
        }): boolean;
    }
}
declare module BABYLON {
    /** @hidden */
    export class ShaderDefineIsDefinedOperator extends ShaderDefineExpression {
        define: string;
        not: boolean;
        constructor(define: string, not?: boolean);
        isTrue(preprocessors: {
            [key: string]: string;
        }): boolean;
    }
}
declare module BABYLON {
    /** @hidden */
    export class ShaderDefineOrOperator extends ShaderDefineExpression {
        leftOperand: ShaderDefineExpression;
        rightOperand: ShaderDefineExpression;
        isTrue(preprocessors: {
            [key: string]: string;
        }): boolean;
    }
}
declare module BABYLON {
    /** @hidden */
    export class ShaderDefineAndOperator extends ShaderDefineExpression {
        leftOperand: ShaderDefineExpression;
        rightOperand: ShaderDefineExpression;
        isTrue(preprocessors: {
            [key: string]: string;
        }): boolean;
    }
}
declare module BABYLON {
    /** @hidden */
    export class ShaderDefineArithmeticOperator extends ShaderDefineExpression {
        define: string;
        operand: string;
        testValue: string;
        constructor(define: string, operand: string, testValue: string);
        isTrue(preprocessors: {
            [key: string]: string;
        }): boolean;
    }
}
declare module BABYLON {
    /**
     * Class used to enable access to offline support
     * @see https://doc.babylonjs.com/how_to/caching_resources_in_indexeddb
     */
    export interface IOfflineProvider {
        /**
         * Gets a boolean indicating if scene must be saved in the database
         */
        enableSceneOffline: boolean;
        /**
         * Gets a boolean indicating if textures must be saved in the database
         */
        enableTexturesOffline: boolean;
        /**
         * Open the offline support and make it available
         * @param successCallback defines the callback to call on success
         * @param errorCallback defines the callback to call on error
         */
        open(successCallback: () => void, errorCallback: () => void): void;
        /**
         * Loads an image from the offline support
         * @param url defines the url to load from
         * @param image defines the target DOM image
         */
        loadImage(url: string, image: HTMLImageElement): void;
        /**
         * Loads a file from offline support
         * @param url defines the URL to load from
         * @param sceneLoaded defines a callback to call on success
         * @param progressCallBack defines a callback to call when progress changed
         * @param errorCallback defines a callback to call on error
         * @param useArrayBuffer defines a boolean to use array buffer instead of text string
         */
        loadFile(url: string, sceneLoaded: (data: any) => void, progressCallBack?: (data: any) => void, errorCallback?: () => void, useArrayBuffer?: boolean): void;
    }
}
declare module BABYLON {
    /**
     * Class used to help managing file picking and drag'n'drop
     * File Storage
     */
    export class FilesInputStore {
        /**
         * List of files ready to be loaded
         */
        static FilesToLoad: {
            [key: string]: File;
        };
    }
}
declare module BABYLON {
    /**
     * Class used to define a retry strategy when error happens while loading assets
     */
    export class RetryStrategy {
        /**
         * Function used to defines an exponential back off strategy
         * @param maxRetries defines the maximum number of retries (3 by default)
         * @param baseInterval defines the interval between retries
         * @returns the strategy function to use
         */
        static ExponentialBackoff(maxRetries?: number, baseInterval?: number): (url: string, request: WebRequest, retryIndex: number) => number;
    }
}
declare module BABYLON {
    /**
     * @ignore
     * Application error to support additional information when loading a file
     */
    export abstract class BaseError extends Error {
        protected static _setPrototypeOf: (o: any, proto: object | null) => any;
    }
}
declare module BABYLON {
    /** @ignore */
    export class LoadFileError extends BaseError {
        request?: WebRequest;
        file?: File;
        /**
         * Creates a new LoadFileError
         * @param message defines the message of the error
         * @param request defines the optional web request
         * @param file defines the optional file
         */
        constructor(message: string, object?: WebRequest | File);
    }
    /** @ignore */
    export class RequestFileError extends BaseError {
        request: WebRequest;
        /**
         * Creates a new LoadFileError
         * @param message defines the message of the error
         * @param request defines the optional web request
         */
        constructor(message: string, request: WebRequest);
    }
    /** @ignore */
    export class ReadFileError extends BaseError {
        file: File;
        /**
         * Creates a new ReadFileError
         * @param message defines the message of the error
         * @param file defines the optional file
         */
        constructor(message: string, file: File);
    }
    /**
     * @hidden
     */
    export class FileTools {
        /**
         * Gets or sets the retry strategy to apply when an error happens while loading an asset
         */
        static DefaultRetryStrategy: (url: string, request: WebRequest, retryIndex: number) => number;
        /**
         * Gets or sets the base URL to use to load assets
         */
        static BaseUrl: string;
        /**
         * Default behaviour for cors in the application.
         * It can be a string if the expected behavior is identical in the entire app.
         * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)
         */
        static CorsBehavior: string | ((url: string | string[]) => string);
        /**
         * Gets or sets a function used to pre-process url before using them to load assets
         */
        static PreprocessUrl: (url: string) => string;
        /**
         * Removes unwanted characters from an url
         * @param url defines the url to clean
         * @returns the cleaned url
         */
        private static _CleanUrl;
        /**
         * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.
         * @param url define the url we are trying
         * @param element define the dom element where to configure the cors policy
         */
        static SetCorsBehavior(url: string | string[], element: {
            crossOrigin: string | null;
        }): void;
        /**
         * Loads an image as an HTMLImageElement.
         * @param input url string, ArrayBuffer, or Blob to load
         * @param onLoad callback called when the image successfully loads
         * @param onError callback called when the image fails to load
         * @param offlineProvider offline provider for caching
         * @param mimeType optional mime type
         * @returns the HTMLImageElement of the loaded image
         */
        static LoadImage(input: string | ArrayBuffer | ArrayBufferView | Blob, onLoad: (img: HTMLImageElement | ImageBitmap) => void, onError: (message?: string, exception?: any) => void, offlineProvider: Nullable<IOfflineProvider>, mimeType?: string): Nullable<HTMLImageElement>;
        /**
         * Reads a file from a File object
         * @param file defines the file to load
         * @param onSuccess defines the callback to call when data is loaded
         * @param onProgress defines the callback to call during loading process
         * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer
         * @param onError defines the callback to call when an error occurs
         * @returns a file request object
         */
        static ReadFile(file: File, onSuccess: (data: any) => void, onProgress?: (ev: ProgressEvent) => any, useArrayBuffer?: boolean, onError?: (error: ReadFileError) => void): IFileRequest;
        /**
         * Loads a file from a url
         * @param url url to load
         * @param onSuccess callback called when the file successfully loads
         * @param onProgress callback called while file is loading (if the server supports this mode)
         * @param offlineProvider defines the offline provider for caching
         * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer
         * @param onError callback called when the file fails to load
         * @returns a file request object
         */
        static LoadFile(url: string, onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void, onProgress?: (ev: ProgressEvent) => void, offlineProvider?: IOfflineProvider, useArrayBuffer?: boolean, onError?: (request?: WebRequest, exception?: LoadFileError) => void): IFileRequest;
        /**
         * Loads a file
         * @param url url to load
         * @param onSuccess callback called when the file successfully loads
         * @param onProgress callback called while file is loading (if the server supports this mode)
         * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer
         * @param onError callback called when the file fails to load
         * @param onOpened callback called when the web request is opened
         * @returns a file request object
         */
        static RequestFile(url: string, onSuccess: (data: string | ArrayBuffer, request?: WebRequest) => void, onProgress?: (event: ProgressEvent) => void, offlineProvider?: IOfflineProvider, useArrayBuffer?: boolean, onError?: (error: RequestFileError) => void, onOpened?: (request: WebRequest) => void): IFileRequest;
        /**
         * Checks if the loaded document was accessed via `file:`-Protocol.
         * @returns boolean
         */
        static IsFileURL(): boolean;
    }
}
declare module BABYLON {
    /** @hidden */
    export class ShaderProcessor {
        static Process(sourceCode: string, options: ProcessingOptions, callback: (migratedCode: string) => void): void;
        private static _ProcessPrecision;
        private static _ExtractOperation;
        private static _BuildSubExpression;
        private static _BuildExpression;
        private static _MoveCursorWithinIf;
        private static _MoveCursor;
        private static _EvaluatePreProcessors;
        private static _PreparePreProcessors;
        private static _ProcessShaderConversion;
        private static _ProcessIncludes;
        /**
         * Loads a file from a url
         * @param url url to load
         * @param onSuccess callback called when the file successfully loads
         * @param onProgress callback called while file is loading (if the server supports this mode)
         * @param offlineProvider defines the offline provider for caching
         * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer
         * @param onError callback called when the file fails to load
         * @returns a file request object
         * @hidden
         */
        static _FileToolsLoadFile(url: string, onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void, onProgress?: (ev: ProgressEvent) => void, offlineProvider?: IOfflineProvider, useArrayBuffer?: boolean, onError?: (request?: WebRequest, exception?: LoadFileError) => void): IFileRequest;
    }
}
declare module BABYLON {
    /**
     * @hidden
     */
    export interface IColor4Like {
        r: float;
        g: float;
        b: float;
        a: float;
    }
    /**
     * @hidden
     */
    export interface IColor3Like {
        r: float;
        g: float;
        b: float;
    }
    /**
     * @hidden
     */
    export interface IVector4Like {
        x: float;
        y: float;
        z: float;
        w: float;
    }
    /**
     * @hidden
     */
    export interface IVector3Like {
        x: float;
        y: float;
        z: float;
    }
    /**
     * @hidden
     */
    export interface IVector2Like {
        x: float;
        y: float;
    }
    /**
     * @hidden
     */
    export interface IMatrixLike {
        toArray(): DeepImmutable<Float32Array | Array<number>>;
        updateFlag: int;
    }
    /**
     * @hidden
     */
    export interface IViewportLike {
        x: float;
        y: float;
        width: float;
        height: float;
    }
    /**
     * @hidden
     */
    export interface IPlaneLike {
        normal: IVector3Like;
        d: float;
        normalize(): void;
    }
}
declare module BABYLON {
    /**
     * Interface used to define common properties for effect fallbacks
     */
    export interface IEffectFallbacks {
        /**
         * Removes the defines that should be removed when falling back.
         * @param currentDefines defines the current define statements for the shader.
         * @param effect defines the current effect we try to compile
         * @returns The resulting defines with defines of the current rank removed.
         */
        reduce(currentDefines: string, effect: Effect): string;
        /**
         * Removes the fallback from the bound mesh.
         */
        unBindMesh(): void;
        /**
         * Checks to see if more fallbacks are still availible.
         */
        hasMoreFallbacks: boolean;
    }
}
declare module BABYLON {
    /**
     * Class used to evalaute queries containing `and` and `or` operators
     */
    export class AndOrNotEvaluator {
        /**
         * Evaluate a query
         * @param query defines the query to evaluate
         * @param evaluateCallback defines the callback used to filter result
         * @returns true if the query matches
         */
        static Eval(query: string, evaluateCallback: (val: any) => boolean): boolean;
        private static _HandleParenthesisContent;
        private static _SimplifyNegation;
    }
}
declare module BABYLON {
    /**
     * Class used to store custom tags
     */
    export class Tags {
        /**
         * Adds support for tags on the given object
         * @param obj defines the object to use
         */
        static EnableFor(obj: any): void;
        /**
         * Removes tags support
         * @param obj defines the object to use
         */
        static DisableFor(obj: any): void;
        /**
         * Gets a boolean indicating if the given object has tags
         * @param obj defines the object to use
         * @returns a boolean
         */
        static HasTags(obj: any): boolean;
        /**
         * Gets the tags available on a given object
         * @param obj defines the object to use
         * @param asString defines if the tags must be returned as a string instead of an array of strings
         * @returns the tags
         */
        static GetTags(obj: any, asString?: boolean): any;
        /**
         * Adds tags to an object
         * @param obj defines the object to use
         * @param tagsString defines the tag string. The tags 'true' and 'false' are reserved and cannot be used as tags.
         * A tag cannot start with '||', '&&', and '!'. It cannot contain whitespaces
         */
        static AddTagsTo(obj: any, tagsString: string): void;
        /**
         * @hidden
         */
        static _AddTagTo(obj: any, tag: string): void;
        /**
         * Removes specific tags from a specific object
         * @param obj defines the object to use
         * @param tagsString defines the tags to remove
         */
        static RemoveTagsFrom(obj: any, tagsString: string): void;
        /**
         * @hidden
         */
        static _RemoveTagFrom(obj: any, tag: string): void;
        /**
         * Defines if tags hosted on an object match a given query
         * @param obj defines the object to use
         * @param tagsQuery defines the tag query
         * @returns a boolean
         */
        static MatchesQuery(obj: any, tagsQuery: string): boolean;
    }
}
declare module BABYLON {
    /**
     * Scalar computation library
     */
    export class Scalar {
        /**
         * Two pi constants convenient for computation.
         */
        static TwoPi: number;
        /**
         * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)
         * @param a number
         * @param b number
         * @param epsilon (default = 1.401298E-45)
         * @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)
         */
        static WithinEpsilon(a: number, b: number, epsilon?: number): boolean;
        /**
         * Returns a string : the upper case translation of the number i to hexadecimal.
         * @param i number
         * @returns the upper case translation of the number i to hexadecimal.
         */
        static ToHex(i: number): string;
        /**
         * Returns -1 if value is negative and +1 is value is positive.
         * @param value the value
         * @returns the value itself if it's equal to zero.
         */
        static Sign(value: number): number;
        /**
         * Returns the value itself if it's between min and max.
         * Returns min if the value is lower than min.
         * Returns max if the value is greater than max.
         * @param value the value to clmap
         * @param min the min value to clamp to (default: 0)
         * @param max the max value to clamp to (default: 1)
         * @returns the clamped value
         */
        static Clamp(value: number, min?: number, max?: number): number;
        /**
         * the log2 of value.
         * @param value the value to compute log2 of
         * @returns the log2 of value.
         */
        static Log2(value: number): number;
        /**
        * Loops the value, so that it is never larger than length and never smaller than 0.
        *
        * This is similar to the modulo operator but it works with floating point numbers.
        * For example, using 3.0 for t and 2.5 for length, the result would be 0.5.
        * With t = 5 and length = 2.5, the result would be 0.0.
        * Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator
        * @param value the value
        * @param length the length
        * @returns the looped value
        */
        static Repeat(value: number, length: number): number;
        /**
         * Normalize the value between 0.0 and 1.0 using min and max values
         * @param value value to normalize
         * @param min max to normalize between
         * @param max min to normalize between
         * @returns the normalized value
         */
        static Normalize(value: number, min: number, max: number): number;
        /**
        * Denormalize the value from 0.0 and 1.0 using min and max values
        * @param normalized value to denormalize
        * @param min max to denormalize between
        * @param max min to denormalize between
        * @returns the denormalized value
        */
        static Denormalize(normalized: number, min: number, max: number): number;
        /**
        * Calculates the shortest difference between two given angles given in degrees.
        * @param current current angle in degrees
        * @param target target angle in degrees
        * @returns the delta
        */
        static DeltaAngle(current: number, target: number): number;
        /**
        * PingPongs the value t, so that it is never larger than length and never smaller than 0.
        * @param tx value
        * @param length length
        * @returns The returned value will move back and forth between 0 and length
        */
        static PingPong(tx: number, length: number): number;
        /**
        * Interpolates between min and max with smoothing at the limits.
        *
        * This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up
        * from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.
        * @param from from
        * @param to to
        * @param tx value
        * @returns the smooth stepped value
        */
        static SmoothStep(from: number, to: number, tx: number): number;
        /**
        * Moves a value current towards target.
        *
        * This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.
        * Negative values of maxDelta pushes the value away from target.
        * @param current current value
        * @param target target value
        * @param maxDelta max distance to move
        * @returns resulting value
        */
        static MoveTowards(current: number, target: number, maxDelta: number): number;
        /**
        * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.
        *
        * Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta
        *  are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.
        * @param current current value
        * @param target target value
        * @param maxDelta max distance to move
        * @returns resulting angle
        */
        static MoveTowardsAngle(current: number, target: number, maxDelta: number): number;
        /**
         * Creates a new scalar with values linearly interpolated of "amount" between the start scalar and the end scalar.
         * @param start start value
         * @param end target value
         * @param amount amount to lerp between
         * @returns the lerped value
         */
        static Lerp(start: number, end: number, amount: number): number;
        /**
        * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.
        * The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.
        * @param start start value
        * @param end target value
        * @param amount amount to lerp between
        * @returns the lerped value
        */
        static LerpAngle(start: number, end: number, amount: number): number;
        /**
        * Calculates the linear parameter t that produces the interpolant value within the range [a, b].
        * @param a start value
        * @param b target value
        * @param value value between a and b
        * @returns the inverseLerp value
        */
        static InverseLerp(a: number, b: number, value: number): number;
        /**
         * Returns a new scalar located for "amount" (float) on the Hermite spline defined by the scalars "value1", "value3", "tangent1", "tangent2".
         * @see http://mathworld.wolfram.com/HermitePolynomial.html
         * @param value1 spline value
         * @param tangent1 spline value
         * @param value2 spline value
         * @param tangent2 spline value
         * @param amount input value
         * @returns hermite result
         */
        static Hermite(value1: number, tangent1: number, value2: number, tangent2: number, amount: number): number;
        /**
        * Returns a random float number between and min and max values
        * @param min min value of random
        * @param max max value of random
        * @returns random value
        */
        static RandomRange(min: number, max: number): number;
        /**
        * This function returns percentage of a number in a given range.
        *
        * RangeToPercent(40,20,60) will return 0.5 (50%)
        * RangeToPercent(34,0,100) will return 0.34 (34%)
        * @param number to convert to percentage
        * @param min min range
        * @param max max range
        * @returns the percentage
        */
        static RangeToPercent(number: number, min: number, max: number): number;
        /**
        * This function returns number that corresponds to the percentage in a given range.
        *
        * PercentToRange(0.34,0,100) will return 34.
        * @param percent to convert to number
        * @param min min range
        * @param max max range
        * @returns the number
        */
        static PercentToRange(percent: number, min: number, max: number): number;
        /**
         * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.
         * @param angle The angle to normalize in radian.
         * @return The converted angle.
         */
        static NormalizeRadians(angle: number): number;
    }
}
declare module BABYLON {
    /**
     * Constant used to convert a value to gamma space
     * @ignorenaming
     */
    export const ToGammaSpace: number;
    /**
     * Constant used to convert a value to linear space
     * @ignorenaming
     */
    export const ToLinearSpace = 2.2;
    /**
     * Constant used to define the minimal number value in Babylon.js
     * @ignorenaming
     */
    let Epsilon: number;
}
declare module BABYLON {
    /**
     * Class used to represent a viewport on screen
     */
    export class Viewport {
        /** viewport left coordinate */
        x: number;
        /** viewport top coordinate */
        y: number;
        /**viewport width */
        width: number;
        /** viewport height */
        height: number;
        /**
         * Creates a Viewport object located at (x, y) and sized (width, height)
         * @param x defines viewport left coordinate
         * @param y defines viewport top coordinate
         * @param width defines the viewport width
         * @param height defines the viewport height
         */
        constructor(
        /** viewport left coordinate */
        x: number, 
        /** viewport top coordinate */
        y: number, 
        /**viewport width */
        width: number, 
        /** viewport height */
        height: number);
        /**
         * Creates a new viewport using absolute sizing (from 0-> width, 0-> height instead of 0->1)
         * @param renderWidth defines the rendering width
         * @param renderHeight defines the rendering height
         * @returns a new Viewport
         */
        toGlobal(renderWidth: number, renderHeight: number): Viewport;
        /**
         * Stores absolute viewport value into a target viewport (from 0-> width, 0-> height instead of 0->1)
         * @param renderWidth defines the rendering width
         * @param renderHeight defines the rendering height
         * @param ref defines the target viewport
         * @returns the current viewport
         */
        toGlobalToRef(renderWidth: number, renderHeight: number, ref: Viewport): Viewport;
        /**
         * Returns a new Viewport copied from the current one
         * @returns a new Viewport
         */
        clone(): Viewport;
    }
}
declare module BABYLON {
    /**
     * Class containing a set of static utilities functions for arrays.
     */
    export class ArrayTools {
        /**
         * Returns an array of the given size filled with element built from the given constructor and the paramters
         * @param size the number of element to construct and put in the array
         * @param itemBuilder a callback responsible for creating new instance of item. Called once per array entry.
         * @returns a new array filled with new objects
         */
        static BuildArray<T>(size: number, itemBuilder: () => T): Array<T>;
    }
}
declare module BABYLON {
    /**
     * Represents a plane by the equation ax + by + cz + d = 0
     */
    export class Plane {
        private static _TmpMatrix;
        /**
         * Normal of the plane (a,b,c)
         */
        normal: Vector3;
        /**
         * d component of the plane
         */
        d: number;
        /**
         * Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0
         * @param a a component of the plane
         * @param b b component of the plane
         * @param c c component of the plane
         * @param d d component of the plane
         */
        constructor(a: number, b: number, c: number, d: number);
        /**
         * @returns the plane coordinates as a new array of 4 elements [a, b, c, d].
         */
        asArray(): number[];
        /**
         * @returns a new plane copied from the current Plane.
         */
        clone(): Plane;
        /**
         * @returns the string "Plane".
         */
        getClassName(): string;
        /**
         * @returns the Plane hash code.
         */
        getHashCode(): number;
        /**
         * Normalize the current Plane in place.
         * @returns the updated Plane.
         */
        normalize(): Plane;
        /**
         * Applies a transformation the plane and returns the result
         * @param transformation the transformation matrix to be applied to the plane
         * @returns a new Plane as the result of the transformation of the current Plane by the given matrix.
         */
        transform(transformation: DeepImmutable<Matrix>): Plane;
        /**
         * Compute the dot product between the point and the plane normal
         * @param point point to calculate the dot product with
         * @returns the dot product (float) of the point coordinates and the plane normal.
         */
        dotCoordinate(point: DeepImmutable<Vector3>): number;
        /**
         * Updates the current Plane from the plane defined by the three given points.
         * @param point1 one of the points used to contruct the plane
         * @param point2 one of the points used to contruct the plane
         * @param point3 one of the points used to contruct the plane
         * @returns the updated Plane.
         */
        copyFromPoints(point1: DeepImmutable<Vector3>, point2: DeepImmutable<Vector3>, point3: DeepImmutable<Vector3>): Plane;
        /**
         * Checks if the plane is facing a given direction
         * @param direction the direction to check if the plane is facing
         * @param epsilon value the dot product is compared against (returns true if dot <= epsilon)
         * @returns True is the vector "direction"  is the same side than the plane normal.
         */
        isFrontFacingTo(direction: DeepImmutable<Vector3>, epsilon: number): boolean;
        /**
         * Calculates the distance to a point
         * @param point point to calculate distance to
         * @returns the signed distance (float) from the given point to the Plane.
         */
        signedDistanceTo(point: DeepImmutable<Vector3>): number;
        /**
         * Creates a plane from an  array
         * @param array the array to create a plane from
         * @returns a new Plane from the given array.
         */
        static FromArray(array: DeepImmutable<ArrayLike<number>>): Plane;
        /**
         * Creates a plane from three points
         * @param point1 point used to create the plane
         * @param point2 point used to create the plane
         * @param point3 point used to create the plane
         * @returns a new Plane defined by the three given points.
         */
        static FromPoints(point1: DeepImmutable<Vector3>, point2: DeepImmutable<Vector3>, point3: DeepImmutable<Vector3>): Plane;
        /**
         * Creates a plane from an origin point and a normal
         * @param origin origin of the plane to be constructed
         * @param normal normal of the plane to be constructed
         * @returns a new Plane the normal vector to this plane at the given origin point.
         * Note : the vector "normal" is updated because normalized.
         */
        static FromPositionAndNormal(origin: DeepImmutable<Vector3>, normal: Vector3): Plane;
        /**
         * Calculates the distance from a plane and a point
         * @param origin origin of the plane to be constructed
         * @param normal normal of the plane to be constructed
         * @param point point to calculate distance to
         * @returns the signed distance between the plane defined by the normal vector at the "origin"" point and the given other point.
         */
        static SignedDistanceToPlaneFromPositionAndNormal(origin: DeepImmutable<Vector3>, normal: DeepImmutable<Vector3>, point: DeepImmutable<Vector3>): number;
    }
}
declare module BABYLON {
    /** @hidden */
    export class PerformanceConfigurator {
        /** @hidden */
        static MatrixUse64Bits: boolean;
        /** @hidden */
        static MatrixTrackPrecisionChange: boolean;
        /** @hidden */
        static MatrixCurrentType: any;
        /** @hidden */
        static MatrixTrackedMatrices: Array<any> | null;
        /** @hidden */
        static SetMatrixPrecision(use64bits: boolean): void;
    }
}
declare module BABYLON {
    /**
     * Class representing a vector containing 2 coordinates
     */
    export class Vector2 {
        /** defines the first coordinate */
        x: number;
        /** defines the second coordinate */
        y: number;
        /**
         * Creates a new Vector2 from the given x and y coordinates
         * @param x defines the first coordinate
         * @param y defines the second coordinate
         */
        constructor(
        /** defines the first coordinate */
        x?: number, 
        /** defines the second coordinate */
        y?: number);
        /**
         * Gets a string with the Vector2 coordinates
         * @returns a string with the Vector2 coordinates
         */
        toString(): string;
        /**
         * Gets class name
         * @returns the string "Vector2"
         */
        getClassName(): string;
        /**
         * Gets current vector hash code
         * @returns the Vector2 hash code as a number
         */
        getHashCode(): number;
        /**
         * Sets the Vector2 coordinates in the given array or Float32Array from the given index.
         * @param array defines the source array
         * @param index defines the offset in source array
         * @returns the current Vector2
         */
        toArray(array: FloatArray, index?: number): Vector2;
        /**
         * Update the current vector from an array
         * @param array defines the destination array
         * @param index defines the offset in the destination array
         * @returns the current Vector3
         */
        fromArray(array: FloatArray, index?: number): Vector2;
        /**
         * Copy the current vector to an array
         * @returns a new array with 2 elements: the Vector2 coordinates.
         */
        asArray(): number[];
        /**
         * Sets the Vector2 coordinates with the given Vector2 coordinates
         * @param source defines the source Vector2
         * @returns the current updated Vector2
         */
        copyFrom(source: DeepImmutable<Vector2>): Vector2;
        /**
         * Sets the Vector2 coordinates with the given floats
         * @param x defines the first coordinate
         * @param y defines the second coordinate
         * @returns the current updated Vector2
         */
        copyFromFloats(x: number, y: number): Vector2;
        /**
         * Sets the Vector2 coordinates with the given floats
         * @param x defines the first coordinate
         * @param y defines the second coordinate
         * @returns the current updated Vector2
         */
        set(x: number, y: number): Vector2;
        /**
         * Add another vector with the current one
         * @param otherVector defines the other vector
         * @returns a new Vector2 set with the addition of the current Vector2 and the given one coordinates
         */
        add(otherVector: DeepImmutable<Vector2>): Vector2;
        /**
         * Sets the "result" coordinates with the addition of the current Vector2 and the given one coordinates
         * @param otherVector defines the other vector
         * @param result defines the target vector
         * @returns the unmodified current Vector2
         */
        addToRef(otherVector: DeepImmutable<Vector2>, result: Vector2): Vector2;
        /**
         * Set the Vector2 coordinates by adding the given Vector2 coordinates
         * @param otherVector defines the other vector
         * @returns the current updated Vector2
         */
        addInPlace(otherVector: DeepImmutable<Vector2>): Vector2;
        /**
         * Gets a new Vector2 by adding the current Vector2 coordinates to the given Vector3 x, y coordinates
         * @param otherVector defines the other vector
         * @returns a new Vector2
         */
        addVector3(otherVector: Vector3): Vector2;
        /**
         * Gets a new Vector2 set with the subtracted coordinates of the given one from the current Vector2
         * @param otherVector defines the other vector
         * @returns a new Vector2
         */
        subtract(otherVector: Vector2): Vector2;
        /**
         * Sets the "result" coordinates with the subtraction of the given one from the current Vector2 coordinates.
         * @param otherVector defines the other vector
         * @param result defines the target vector
         * @returns the unmodified current Vector2
         */
        subtractToRef(otherVector: DeepImmutable<Vector2>, result: Vector2): Vector2;
        /**
         * Sets the current Vector2 coordinates by subtracting from it the given one coordinates
         * @param otherVector defines the other vector
         * @returns the current updated Vector2
         */
        subtractInPlace(otherVector: DeepImmutable<Vector2>): Vector2;
        /**
         * Multiplies in place the current Vector2 coordinates by the given ones
         * @param otherVector defines the other vector
         * @returns the current updated Vector2
         */
        multiplyInPlace(otherVector: DeepImmutable<Vector2>): Vector2;
        /**
         * Returns a new Vector2 set with the multiplication of the current Vector2 and the given one coordinates
         * @param otherVector defines the other vector
         * @returns a new Vector2
         */
        multiply(otherVector: DeepImmutable<Vector2>): Vector2;
        /**
         * Sets "result" coordinates with the multiplication of the current Vector2 and the given one coordinates
         * @param otherVector defines the other vector
         * @param result defines the target vector
         * @returns the unmodified current Vector2
         */
        multiplyToRef(otherVector: DeepImmutable<Vector2>, result: Vector2): Vector2;
        /**
         * Gets a new Vector2 set with the Vector2 coordinates multiplied by the given floats
         * @param x defines the first coordinate
         * @param y defines the second coordinate
         * @returns a new Vector2
         */
        multiplyByFloats(x: number, y: number): Vector2;
        /**
         * Returns a new Vector2 set with the Vector2 coordinates divided by the given one coordinates
         * @param otherVector defines the other vector
         * @returns a new Vector2
         */
        divide(otherVector: Vector2): Vector2;
        /**
         * Sets the "result" coordinates with the Vector2 divided by the given one coordinates
         * @param otherVector defines the other vector
         * @param result defines the target vector
         * @returns the unmodified current Vector2
         */
        divideToRef(otherVector: DeepImmutable<Vector2>, result: Vector2): Vector2;
        /**
         * Divides the current Vector2 coordinates by the given ones
         * @param otherVector defines the other vector
         * @returns the current updated Vector2
         */
        divideInPlace(otherVector: DeepImmutable<Vector2>): Vector2;
        /**
         * Gets a new Vector2 with current Vector2 negated coordinates
         * @returns a new Vector2
         */
        negate(): Vector2;
        /**
         * Negate this vector in place
         * @returns this
         */
        negateInPlace(): Vector2;
        /**
         * Negate the current Vector2 and stores the result in the given vector "result" coordinates
         * @param result defines the Vector3 object where to store the result
         * @returns the current Vector2
         */
        negateToRef(result: Vector2): Vector2;
        /**
         * Multiply the Vector2 coordinates by scale
         * @param scale defines the scaling factor
         * @returns the current updated Vector2
         */
        scaleInPlace(scale: number): Vector2;
        /**
         * Returns a new Vector2 scaled by "scale" from the current Vector2
         * @param scale defines the scaling factor
         * @returns a new Vector2
         */
        scale(scale: number): Vector2;
        /**
         * Scale the current Vector2 values by a factor to a given Vector2
         * @param scale defines the scale factor
         * @param result defines the Vector2 object where to store the result
         * @returns the unmodified current Vector2
         */
        scaleToRef(scale: number, result: Vector2): Vector2;
        /**
         * Scale the current Vector2 values by a factor and add the result to a given Vector2
         * @param scale defines the scale factor
         * @param result defines the Vector2 object where to store the result
         * @returns the unmodified current Vector2
         */
        scaleAndAddToRef(scale: number, result: Vector2): Vector2;
        /**
         * Gets a boolean if two vectors are equals
         * @param otherVector defines the other vector
         * @returns true if the given vector coordinates strictly equal the current Vector2 ones
         */
        equals(otherVector: DeepImmutable<Vector2>): boolean;
        /**
         * Gets a boolean if two vectors are equals (using an epsilon value)
         * @param otherVector defines the other vector
         * @param epsilon defines the minimal distance to consider equality
         * @returns true if the given vector coordinates are close to the current ones by a distance of epsilon.
         */
        equalsWithEpsilon(otherVector: DeepImmutable<Vector2>, epsilon?: number): boolean;
        /**
         * Gets a new Vector2 from current Vector2 floored values
         * @returns a new Vector2
         */
        floor(): Vector2;
        /**
         * Gets a new Vector2 from current Vector2 floored values
         * @returns a new Vector2
         */
        fract(): Vector2;
        /**
         * Gets the length of the vector
         * @returns the vector length (float)
         */
        length(): number;
        /**
         * Gets the vector squared length
         * @returns the vector squared length (float)
         */
        lengthSquared(): number;
        /**
         * Normalize the vector
         * @returns the current updated Vector2
         */
        normalize(): Vector2;
        /**
         * Gets a new Vector2 copied from the Vector2
         * @returns a new Vector2
         */
        clone(): Vector2;
        /**
         * Gets a new Vector2(0, 0)
         * @returns a new Vector2
         */
        static Zero(): Vector2;
        /**
         * Gets a new Vector2(1, 1)
         * @returns a new Vector2
         */
        static One(): Vector2;
        /**
         * Gets a new Vector2 set from the given index element of the given array
         * @param array defines the data source
         * @param offset defines the offset in the data source
         * @returns a new Vector2
         */
        static FromArray(array: DeepImmutable<ArrayLike<number>>, offset?: number): Vector2;
        /**
         * Sets "result" from the given index element of the given array
         * @param array defines the data source
         * @param offset defines the offset in the data source
         * @param result defines the target vector
         */
        static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number, result: Vector2): void;
        /**
         * Gets a new Vector2 located for "amount" (float) on the CatmullRom spline defined by the given four Vector2
         * @param value1 defines 1st point of control
         * @param value2 defines 2nd point of control
         * @param value3 defines 3rd point of control
         * @param value4 defines 4th point of control
         * @param amount defines the interpolation factor
         * @returns a new Vector2
         */
        static CatmullRom(value1: DeepImmutable<Vector2>, value2: DeepImmutable<Vector2>, value3: DeepImmutable<Vector2>, value4: DeepImmutable<Vector2>, amount: number): Vector2;
        /**
         * Returns a new Vector2 set with same the coordinates than "value" ones if the vector "value" is in the square defined by "min" and "max".
         * If a coordinate of "value" is lower than "min" coordinates, the returned Vector2 is given this "min" coordinate.
         * If a coordinate of "value" is greater than "max" coordinates, the returned Vector2 is given this "max" coordinate
         * @param value defines the value to clamp
         * @param min defines the lower limit
         * @param max defines the upper limit
         * @returns a new Vector2
         */
        static Clamp(value: DeepImmutable<Vector2>, min: DeepImmutable<Vector2>, max: DeepImmutable<Vector2>): Vector2;
        /**
         * Returns a new Vector2 located for "amount" (float) on the Hermite spline defined by the vectors "value1", "value3", "tangent1", "tangent2"
         * @param value1 defines the 1st control point
         * @param tangent1 defines the outgoing tangent
         * @param value2 defines the 2nd control point
         * @param tangent2 defines the incoming tangent
         * @param amount defines the interpolation factor
         * @returns a new Vector2
         */
        static Hermite(value1: DeepImmutable<Vector2>, tangent1: DeepImmutable<Vector2>, value2: DeepImmutable<Vector2>, tangent2: DeepImmutable<Vector2>, amount: number): Vector2;
        /**
         * Returns a new Vector2 located for "amount" (float) on the linear interpolation between the vector "start" adn the vector "end".
         * @param start defines the start vector
         * @param end defines the end vector
         * @param amount defines the interpolation factor
         * @returns a new Vector2
         */
        static Lerp(start: DeepImmutable<Vector2>, end: DeepImmutable<Vector2>, amount: number): Vector2;
        /**
         * Gets the dot product of the vector "left" and the vector "right"
         * @param left defines first vector
         * @param right defines second vector
         * @returns the dot product (float)
         */
        static Dot(left: DeepImmutable<Vector2>, right: DeepImmutable<Vector2>): number;
        /**
         * Returns a new Vector2 equal to the normalized given vector
         * @param vector defines the vector to normalize
         * @returns a new Vector2
         */
        static Normalize(vector: DeepImmutable<Vector2>): Vector2;
        /**
         * Gets a new Vector2 set with the minimal coordinate values from the "left" and "right" vectors
         * @param left defines 1st vector
         * @param right defines 2nd vector
         * @returns a new Vector2
         */
        static Minimize(left: DeepImmutable<Vector2>, right: DeepImmutable<Vector2>): Vector2;
        /**
         * Gets a new Vecto2 set with the maximal coordinate values from the "left" and "right" vectors
         * @param left defines 1st vector
         * @param right defines 2nd vector
         * @returns a new Vector2
         */
        static Maximize(left: DeepImmutable<Vector2>, right: DeepImmutable<Vector2>): Vector2;
        /**
         * Gets a new Vector2 set with the transformed coordinates of the given vector by the given transformation matrix
         * @param vector defines the vector to transform
         * @param transformation defines the matrix to apply
         * @returns a new Vector2
         */
        static Transform(vector: DeepImmutable<Vector2>, transformation: DeepImmutable<Matrix>): Vector2;
        /**
         * Transforms the given vector coordinates by the given transformation matrix and stores the result in the vector "result" coordinates
         * @param vector defines the vector to transform
         * @param transformation defines the matrix to apply
         * @param result defines the target vector
         */
        static TransformToRef(vector: DeepImmutable<Vector2>, transformation: DeepImmutable<Matrix>, result: Vector2): void;
        /**
         * Determines if a given vector is included in a triangle
         * @param p defines the vector to test
         * @param p0 defines 1st triangle point
         * @param p1 defines 2nd triangle point
         * @param p2 defines 3rd triangle point
         * @returns true if the point "p" is in the triangle defined by the vertors "p0", "p1", "p2"
         */
        static PointInTriangle(p: DeepImmutable<Vector2>, p0: DeepImmutable<Vector2>, p1: DeepImmutable<Vector2>, p2: DeepImmutable<Vector2>): boolean;
        /**
         * Gets the distance between the vectors "value1" and "value2"
         * @param value1 defines first vector
         * @param value2 defines second vector
         * @returns the distance between vectors
         */
        static Distance(value1: DeepImmutable<Vector2>, value2: DeepImmutable<Vector2>): number;
        /**
         * Returns the squared distance between the vectors "value1" and "value2"
         * @param value1 defines first vector
         * @param value2 defines second vector
         * @returns the squared distance between vectors
         */
        static DistanceSquared(value1: DeepImmutable<Vector2>, value2: DeepImmutable<Vector2>): number;
        /**
         * Gets a new Vector2 located at the center of the vectors "value1" and "value2"
         * @param value1 defines first vector
         * @param value2 defines second vector
         * @returns a new Vector2
         */
        static Center(value1: DeepImmutable<Vector2>, value2: DeepImmutable<Vector2>): Vector2;
        /**
         * Gets the shortest distance (float) between the point "p" and the segment defined by the two points "segA" and "segB".
         * @param p defines the middle point
         * @param segA defines one point of the segment
         * @param segB defines the other point of the segment
         * @returns the shortest distance
         */
        static DistanceOfPointFromSegment(p: DeepImmutable<Vector2>, segA: DeepImmutable<Vector2>, segB: DeepImmutable<Vector2>): number;
    }
    /**
     * Class used to store (x,y,z) vector representation
     * A Vector3 is the main object used in 3D geometry
     * It can represent etiher the coordinates of a point the space, either a direction
     * Reminder: js uses a left handed forward facing system
     */
    export class Vector3 {
        private static _UpReadOnly;
        private static _ZeroReadOnly;
        /** @hidden */
        _x: number;
        /** @hidden */
        _y: number;
        /** @hidden */
        _z: number;
        /** @hidden */
        _isDirty: boolean;
        /** Gets or sets the x coordinate */
        get x(): number;
        set x(value: number);
        /** Gets or sets the y coordinate */
        get y(): number;
        set y(value: number);
        /** Gets or sets the z coordinate */
        get z(): number;
        set z(value: number);
        /**
         * Creates a new Vector3 object from the given x, y, z (floats) coordinates.
         * @param x defines the first coordinates (on X axis)
         * @param y defines the second coordinates (on Y axis)
         * @param z defines the third coordinates (on Z axis)
         */
        constructor(x?: number, y?: number, z?: number);
        /**
         * Creates a string representation of the Vector3
         * @returns a string with the Vector3 coordinates.
         */
        toString(): string;
        /**
         * Gets the class name
         * @returns the string "Vector3"
         */
        getClassName(): string;
        /**
         * Creates the Vector3 hash code
         * @returns a number which tends to be unique between Vector3 instances
         */
        getHashCode(): number;
        /**
         * Creates an array containing three elements : the coordinates of the Vector3
         * @returns a new array of numbers
         */
        asArray(): number[];
        /**
         * Populates the given array or Float32Array from the given index with the successive coordinates of the Vector3
         * @param array defines the destination array
         * @param index defines the offset in the destination array
         * @returns the current Vector3
         */
        toArray(array: FloatArray, index?: number): Vector3;
        /**
         * Update the current vector from an array
         * @param array defines the destination array
         * @param index defines the offset in the destination array
         * @returns the current Vector3
         */
        fromArray(array: FloatArray, index?: number): Vector3;
        /**
         * Converts the current Vector3 into a quaternion (considering that the Vector3 contains Euler angles representation of a rotation)
         * @returns a new Quaternion object, computed from the Vector3 coordinates
         */
        toQuaternion(): Quaternion;
        /**
         * Adds the given vector to the current Vector3
         * @param otherVector defines the second operand
         * @returns the current updated Vector3
         */
        addInPlace(otherVector: DeepImmutable<Vector3>): Vector3;
        /**
         * Adds the given coordinates to the current Vector3
         * @param x defines the x coordinate of the operand
         * @param y defines the y coordinate of the operand
         * @param z defines the z coordinate of the operand
         * @returns the current updated Vector3
         */
        addInPlaceFromFloats(x: number, y: number, z: number): Vector3;
        /**
         * Gets a new Vector3, result of the addition the current Vector3 and the given vector
         * @param otherVector defines the second operand
         * @returns the resulting Vector3
         */
        add(otherVector: DeepImmutable<Vector3>): Vector3;
        /**
         * Adds the current Vector3 to the given one and stores the result in the vector "result"
         * @param otherVector defines the second operand
         * @param result defines the Vector3 object where to store the result
         * @returns the current Vector3
         */
        addToRef(otherVector: DeepImmutable<Vector3>, result: Vector3): Vector3;
        /**
         * Subtract the given vector from the current Vector3
         * @param otherVector defines the second operand
         * @returns the current updated Vector3
         */
        subtractInPlace(otherVector: DeepImmutable<Vector3>): Vector3;
        /**
         * Returns a new Vector3, result of the subtraction of the given vector from the current Vector3
         * @param otherVector defines the second operand
         * @returns the resulting Vector3
         */
        subtract(otherVector: DeepImmutable<Vector3>): Vector3;
        /**
         * Subtracts the given vector from the current Vector3 and stores the result in the vector "result".
         * @param otherVector defines the second operand
         * @param result defines the Vector3 object where to store the result
         * @returns the current Vector3
         */
        subtractToRef(otherVector: DeepImmutable<Vector3>, result: Vector3): Vector3;
        /**
         * Returns a new Vector3 set with the subtraction of the given floats from the current Vector3 coordinates
         * @param x defines the x coordinate of the operand
         * @param y defines the y coordinate of the operand
         * @param z defines the z coordinate of the operand
         * @returns the resulting Vector3
         */
        subtractFromFloats(x: number, y: number, z: number): Vector3;
        /**
         * Subtracts the given floats from the current Vector3 coordinates and set the given vector "result" with this result
         * @param x defines the x coordinate of the operand
         * @param y defines the y coordinate of the operand
         * @param z defines the z coordinate of the operand
         * @param result defines the Vector3 object where to store the result
         * @returns the current Vector3
         */
        subtractFromFloatsToRef(x: number, y: number, z: number, result: Vector3): Vector3;
        /**
         * Gets a new Vector3 set with the current Vector3 negated coordinates
         * @returns a new Vector3
         */
        negate(): Vector3;
        /**
         * Negate this vector in place
         * @returns this
         */
        negateInPlace(): Vector3;
        /**
         * Negate the current Vector3 and stores the result in the given vector "result" coordinates
         * @param result defines the Vector3 object where to store the result
         * @returns the current Vector3
         */
        negateToRef(result: Vector3): Vector3;
        /**
         * Multiplies the Vector3 coordinates by the float "scale"
         * @param scale defines the multiplier factor
         * @returns the current updated Vector3
         */
        scaleInPlace(scale: number): Vector3;
        /**
         * Returns a new Vector3 set with the current Vector3 coordinates multiplied by the float "scale"
         * @param scale defines the multiplier factor
         * @returns a new Vector3
         */
        scale(scale: number): Vector3;
        /**
         * Multiplies the current Vector3 coordinates by the float "scale" and stores the result in the given vector "result" coordinates
         * @param scale defines the multiplier factor
         * @param result defines the Vector3 object where to store the result
         * @returns the current Vector3
         */
        scaleToRef(scale: number, result: Vector3): Vector3;
        /**
         * Scale the current Vector3 values by a factor and add the result to a given Vector3
         * @param scale defines the scale factor
         * @param result defines the Vector3 object where to store the result
         * @returns the unmodified current Vector3
         */
        scaleAndAddToRef(scale: number, result: Vector3): Vector3;
        /**
         * Projects the current vector3 to a plane along a ray starting from a specified origin and directed towards the point.
         * @param origin defines the origin of the projection ray
         * @param plane defines the plane to project to
         * @returns the projected vector3
         */
        projectOnPlane(plane: Plane, origin: Vector3): Vector3;
        /**
         * Projects the current vector3 to a plane along a ray starting from a specified origin and directed towards the point.
         * @param origin defines the origin of the projection ray
         * @param plane defines the plane to project to
         * @param result defines the Vector3 where to store the result
         */
        projectOnPlaneToRef(plane: Plane, origin: Vector3, result: Vector3): void;
        /**
         * Returns true if the current Vector3 and the given vector coordinates are strictly equal
         * @param otherVector defines the second operand
         * @returns true if both vectors are equals
         */
        equals(otherVector: DeepImmutable<Vector3>): boolean;
        /**
         * Returns true if the current Vector3 and the given vector coordinates are distant less than epsilon
         * @param otherVector defines the second operand
         * @param epsilon defines the minimal distance to define values as equals
         * @returns true if both vectors are distant less than epsilon
         */
        equalsWithEpsilon(otherVector: DeepImmutable<Vector3>, epsilon?: number): boolean;
        /**
         * Returns true if the current Vector3 coordinates equals the given floats
         * @param x defines the x coordinate of the operand
         * @param y defines the y coordinate of the operand
         * @param z defines the z coordinate of the operand
         * @returns true if both vectors are equals
         */
        equalsToFloats(x: number, y: number, z: number): boolean;
        /**
         * Multiplies the current Vector3 coordinates by the given ones
         * @param otherVector defines the second operand
         * @returns the current updated Vector3
         */
        multiplyInPlace(otherVector: DeepImmutable<Vector3>): Vector3;
        /**
         * Returns a new Vector3, result of the multiplication of the current Vector3 by the given vector
         * @param otherVector defines the second operand
         * @returns the new Vector3
         */
        multiply(otherVector: DeepImmutable<Vector3>): Vector3;
        /**
         * Multiplies the current Vector3 by the given one and stores the result in the given vector "result"
         * @param otherVector defines the second operand
         * @param result defines the Vector3 object where to store the result
         * @returns the current Vector3
         */
        multiplyToRef(otherVector: DeepImmutable<Vector3>, result: Vector3): Vector3;
        /**
         * Returns a new Vector3 set with the result of the mulliplication of the current Vector3 coordinates by the given floats
         * @param x defines the x coordinate of the operand
         * @param y defines the y coordinate of the operand
         * @param z defines the z coordinate of the operand
         * @returns the new Vector3
         */
        multiplyByFloats(x: number, y: number, z: number): Vector3;
        /**
         * Returns a new Vector3 set with the result of the division of the current Vector3 coordinates by the given ones
         * @param otherVector defines the second operand
         * @returns the new Vector3
         */
        divide(otherVector: DeepImmutable<Vector3>): Vector3;
        /**
         * Divides the current Vector3 coordinates by the given ones and stores the result in the given vector "result"
         * @param otherVector defines the second operand
         * @param result defines the Vector3 object where to store the result
         * @returns the current Vector3
         */
        divideToRef(otherVector: DeepImmutable<Vector3>, result: Vector3): Vector3;
        /**
         * Divides the current Vector3 coordinates by the given ones.
         * @param otherVector defines the second operand
         * @returns the current updated Vector3
         */
        divideInPlace(otherVector: Vector3): Vector3;
        /**
         * Updates the current Vector3 with the minimal coordinate values between its and the given vector ones
         * @param other defines the second operand
         * @returns the current updated Vector3
         */
        minimizeInPlace(other: DeepImmutable<Vector3>): Vector3;
        /**
         * Updates the current Vector3 with the maximal coordinate values between its and the given vector ones.
         * @param other defines the second operand
         * @returns the current updated Vector3
         */
        maximizeInPlace(other: DeepImmutable<Vector3>): Vector3;
        /**
         * Updates the current Vector3 with the minimal coordinate values between its and the given coordinates
         * @param x defines the x coordinate of the operand
         * @param y defines the y coordinate of the operand
         * @param z defines the z coordinate of the operand
         * @returns the current updated Vector3
         */
        minimizeInPlaceFromFloats(x: number, y: number, z: number): Vector3;
        /**
         * Updates the current Vector3 with the maximal coordinate values between its and the given coordinates.
         * @param x defines the x coordinate of the operand
         * @param y defines the y coordinate of the operand
         * @param z defines the z coordinate of the operand
         * @returns the current updated Vector3
         */
        maximizeInPlaceFromFloats(x: number, y: number, z: number): Vector3;
        /**
         * Due to float precision, scale of a mesh could be uniform but float values are off by a small fraction
         * Check if is non uniform within a certain amount of decimal places to account for this
         * @param epsilon the amount the values can differ
         * @returns if the the vector is non uniform to a certain number of decimal places
         */
        isNonUniformWithinEpsilon(epsilon: number): boolean;
        /**
         * Gets a boolean indicating that the vector is non uniform meaning x, y or z are not all the same
         */
        get isNonUniform(): boolean;
        /**
         * Gets a new Vector3 from current Vector3 floored values
         * @returns a new Vector3
         */
        floor(): Vector3;
        /**
         * Gets a new Vector3 from current Vector3 floored values
         * @returns a new Vector3
         */
        fract(): Vector3;
        /**
         * Gets the length of the Vector3
         * @returns the length of the Vector3
         */
        length(): number;
        /**
         * Gets the squared length of the Vector3
         * @returns squared length of the Vector3
         */
        lengthSquared(): number;
        /**
         * Normalize the current Vector3.
         * Please note that this is an in place operation.
         * @returns the current updated Vector3
         */
        normalize(): Vector3;
        /**
         * Reorders the x y z properties of the vector in place
         * @param order new ordering of the properties (eg. for vector 1,2,3 with "ZYX" will produce 3,2,1)
         * @returns the current updated vector
         */
        reorderInPlace(order: string): this;
        /**
         * Rotates the vector around 0,0,0 by a quaternion
         * @param quaternion the rotation quaternion
         * @param result vector to store the result
         * @returns the resulting vector
         */
        rotateByQuaternionToRef(quaternion: Quaternion, result: Vector3): Vector3;
        /**
         * Rotates a vector around a given point
         * @param quaternion the rotation quaternion
         * @param point the point to rotate around
         * @param result vector to store the result
         * @returns the resulting vector
         */
        rotateByQuaternionAroundPointToRef(quaternion: Quaternion, point: Vector3, result: Vector3): Vector3;
        /**
         * Returns a new Vector3 as the cross product of the current vector and the "other" one
         * The cross product is then orthogonal to both current and "other"
         * @param other defines the right operand
         * @returns the cross product
         */
        cross(other: Vector3): Vector3;
        /**
         * Normalize the current Vector3 with the given input length.
         * Please note that this is an in place operation.
         * @param len the length of the vector
         * @returns the current updated Vector3
         */
        normalizeFromLength(len: number): Vector3;
        /**
         * Normalize the current Vector3 to a new vector
         * @returns the new Vector3
         */
        normalizeToNew(): Vector3;
        /**
         * Normalize the current Vector3 to the reference
         * @param reference define the Vector3 to update
         * @returns the updated Vector3
         */
        normalizeToRef(reference: Vector3): Vector3;
        /**
         * Creates a new Vector3 copied from the current Vector3
         * @returns the new Vector3
         */
        clone(): Vector3;
        /**
         * Copies the given vector coordinates to the current Vector3 ones
         * @param source defines the source Vector3
         * @returns the current updated Vector3
         */
        copyFrom(source: DeepImmutable<Vector3>): Vector3;
        /**
         * Copies the given floats to the current Vector3 coordinates
         * @param x defines the x coordinate of the operand
         * @param y defines the y coordinate of the operand
         * @param z defines the z coordinate of the operand
         * @returns the current updated Vector3
         */
        copyFromFloats(x: number, y: number, z: number): Vector3;
        /**
         * Copies the given floats to the current Vector3 coordinates
         * @param x defines the x coordinate of the operand
         * @param y defines the y coordinate of the operand
         * @param z defines the z coordinate of the operand
         * @returns the current updated Vector3
         */
        set(x: number, y: number, z: number): Vector3;
        /**
         * Copies the given float to the current Vector3 coordinates
         * @param v defines the x, y and z coordinates of the operand
         * @returns the current updated Vector3
         */
        setAll(v: number): Vector3;
        /**
         * Get the clip factor between two vectors
         * @param vector0 defines the first operand
         * @param vector1 defines the second operand
         * @param axis defines the axis to use
         * @param size defines the size along the axis
         * @returns the clip factor
         */
        static GetClipFactor(vector0: DeepImmutable<Vector3>, vector1: DeepImmutable<Vector3>, axis: DeepImmutable<Vector3>, size: number): number;
        /**
         * Get angle between two vectors
         * @param vector0 angle between vector0 and vector1
         * @param vector1 angle between vector0 and vector1
         * @param normal direction of the normal
         * @return the angle between vector0 and vector1
         */
        static GetAngleBetweenVectors(vector0: DeepImmutable<Vector3>, vector1: DeepImmutable<Vector3>, normal: DeepImmutable<Vector3>): number;
        /**
         * Returns a new Vector3 set from the index "offset" of the given array
         * @param array defines the source array
         * @param offset defines the offset in the source array
         * @returns the new Vector3
         */
        static FromArray(array: DeepImmutable<ArrayLike<number>>, offset?: number): Vector3;
        /**
         * Returns a new Vector3 set from the index "offset" of the given Float32Array
         * @param array defines the source array
         * @param offset defines the offset in the source array
         * @returns the new Vector3
         * @deprecated Please use FromArray instead.
         */
        static FromFloatArray(array: DeepImmutable<Float32Array>, offset?: number): Vector3;
        /**
         * Sets the given vector "result" with the element values from the index "offset" of the given array
         * @param array defines the source array
         * @param offset defines the offset in the source array
         * @param result defines the Vector3 where to store the result
         */
        static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number, result: Vector3): void;
        /**
         * Sets the given vector "result" with the element values from the index "offset" of the given Float32Array
         * @param array defines the source array
         * @param offset defines the offset in the source array
         * @param result defines the Vector3 where to store the result
         * @deprecated Please use FromArrayToRef instead.
         */
        static FromFloatArrayToRef(array: DeepImmutable<Float32Array>, offset: number, result: Vector3): void;
        /**
         * Sets the given vector "result" with the given floats.
         * @param x defines the x coordinate of the source
         * @param y defines the y coordinate of the source
         * @param z defines the z coordinate of the source
         * @param result defines the Vector3 where to store the result
         */
        static FromFloatsToRef(x: number, y: number, z: number, result: Vector3): void;
        /**
         * Returns a new Vector3 set to (0.0, 0.0, 0.0)
         * @returns a new empty Vector3
         */
        static Zero(): Vector3;
        /**
         * Returns a new Vector3 set to (1.0, 1.0, 1.0)
         * @returns a new unit Vector3
         */
        static One(): Vector3;
        /**
         * Returns a new Vector3 set to (0.0, 1.0, 0.0)
         * @returns a new up Vector3
         */
        static Up(): Vector3;
        /**
         * Gets a up Vector3 that must not be updated
         */
        static get UpReadOnly(): DeepImmutable<Vector3>;
        /**
         * Gets a zero Vector3 that must not be updated
         */
        static get ZeroReadOnly(): DeepImmutable<Vector3>;
        /**
         * Returns a new Vector3 set to (0.0, -1.0, 0.0)
         * @returns a new down Vector3
         */
        static Down(): Vector3;
        /**
         * Returns a new Vector3 set to (0.0, 0.0, 1.0)
         * @param rightHandedSystem is the scene right-handed (negative z)
         * @returns a new forward Vector3
         */
        static Forward(rightHandedSystem?: boolean): Vector3;
        /**
         * Returns a new Vector3 set to (0.0, 0.0, -1.0)
         * @param rightHandedSystem is the scene right-handed (negative-z)
         * @returns a new forward Vector3
         */
        static Backward(rightHandedSystem?: boolean): Vector3;
        /**
         * Returns a new Vector3 set to (1.0, 0.0, 0.0)
         * @returns a new right Vector3
         */
        static Right(): Vector3;
        /**
         * Returns a new Vector3 set to (-1.0, 0.0, 0.0)
         * @returns a new left Vector3
         */
        static Left(): Vector3;
        /**
         * Returns a new Vector3 set with the result of the transformation by the given matrix of the given vector.
         * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)
         * @param vector defines the Vector3 to transform
         * @param transformation defines the transformation matrix
         * @returns the transformed Vector3
         */
        static TransformCoordinates(vector: DeepImmutable<Vector3>, transformation: DeepImmutable<Matrix>): Vector3;
        /**
         * Sets the given vector "result" coordinates with the result of the transformation by the given matrix of the given vector
         * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)
         * @param vector defines the Vector3 to transform
         * @param transformation defines the transformation matrix
         * @param result defines the Vector3 where to store the result
         */
        static TransformCoordinatesToRef(vector: DeepImmutable<Vector3>, transformation: DeepImmutable<Matrix>, result: Vector3): void;
        /**
         * Sets the given vector "result" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)
         * This method computes tranformed coordinates only, not transformed direction vectors
         * @param x define the x coordinate of the source vector
         * @param y define the y coordinate of the source vector
         * @param z define the z coordinate of the source vector
         * @param transformation defines the transformation matrix
         * @param result defines the Vector3 where to store the result
         */
        static TransformCoordinatesFromFloatsToRef(x: number, y: number, z: number, transformation: DeepImmutable<Matrix>, result: Vector3): void;
        /**
         * Returns a new Vector3 set with the result of the normal transformation by the given matrix of the given vector
         * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)
         * @param vector defines the Vector3 to transform
         * @param transformation defines the transformation matrix
         * @returns the new Vector3
         */
        static TransformNormal(vector: DeepImmutable<Vector3>, transformation: DeepImmutable<Matrix>): Vector3;
        /**
         * Sets the given vector "result" with the result of the normal transformation by the given matrix of the given vector
         * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)
         * @param vector defines the Vector3 to transform
         * @param transformation defines the transformation matrix
         * @param result defines the Vector3 where to store the result
         */
        static TransformNormalToRef(vector: DeepImmutable<Vector3>, transformation: DeepImmutable<Matrix>, result: Vector3): void;
        /**
         * Sets the given vector "result" with the result of the normal transformation by the given matrix of the given floats (x, y, z)
         * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)
         * @param x define the x coordinate of the source vector
         * @param y define the y coordinate of the source vector
         * @param z define the z coordinate of the source vector
         * @param transformation defines the transformation matrix
         * @param result defines the Vector3 where to store the result
         */
        static TransformNormalFromFloatsToRef(x: number, y: number, z: number, transformation: DeepImmutable<Matrix>, result: Vector3): void;
        /**
         * Returns a new Vector3 located for "amount" on the CatmullRom interpolation spline defined by the vectors "value1", "value2", "value3", "value4"
         * @param value1 defines the first control point
         * @param value2 defines the second control point
         * @param value3 defines the third control point
         * @param value4 defines the fourth control point
         * @param amount defines the amount on the spline to use
         * @returns the new Vector3
         */
        static CatmullRom(value1: DeepImmutable<Vector3>, value2: DeepImmutable<Vector3>, value3: DeepImmutable<Vector3>, value4: DeepImmutable<Vector3>, amount: number): Vector3;
        /**
         * Returns a new Vector3 set with the coordinates of "value", if the vector "value" is in the cube defined by the vectors "min" and "max"
         * If a coordinate value of "value" is lower than one of the "min" coordinate, then this "value" coordinate is set with the "min" one
         * If a coordinate value of "value" is greater than one of the "max" coordinate, then this "value" coordinate is set with the "max" one
         * @param value defines the current value
         * @param min defines the lower range value
         * @param max defines the upper range value
         * @returns the new Vector3
         */
        static Clamp(value: DeepImmutable<Vector3>, min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>): Vector3;
        /**
         * Sets the given vector "result" with the coordinates of "value", if the vector "value" is in the cube defined by the vectors "min" and "max"
         * If a coordinate value of "value" is lower than one of the "min" coordinate, then this "value" coordinate is set with the "min" one
         * If a coordinate value of "value" is greater than one of the "max" coordinate, then this "value" coordinate is set with the "max" one
         * @param value defines the current value
         * @param min defines the lower range value
         * @param max defines the upper range value
         * @param result defines the Vector3 where to store the result
         */
        static ClampToRef(value: DeepImmutable<Vector3>, min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, result: Vector3): void;
        /**
         * Checks if a given vector is inside a specific range
         * @param v defines the vector to test
         * @param min defines the minimum range
         * @param max defines the maximum range
         */
        static CheckExtends(v: Vector3, min: Vector3, max: Vector3): void;
        /**
         * Returns a new Vector3 located for "amount" (float) on the Hermite interpolation spline defined by the vectors "value1", "tangent1", "value2", "tangent2"
         * @param value1 defines the first control point
         * @param tangent1 defines the first tangent vector
         * @param value2 defines the second control point
         * @param tangent2 defines the second tangent vector
         * @param amount defines the amount on the interpolation spline (between 0 and 1)
         * @returns the new Vector3
         */
        static Hermite(value1: DeepImmutable<Vector3>, tangent1: DeepImmutable<Vector3>, value2: DeepImmutable<Vector3>, tangent2: DeepImmutable<Vector3>, amount: number): Vector3;
        /**
         * Returns a new Vector3 located for "amount" (float) on the linear interpolation between the vectors "start" and "end"
         * @param start defines the start value
         * @param end defines the end value
         * @param amount max defines amount between both (between 0 and 1)
         * @returns the new Vector3
         */
        static Lerp(start: DeepImmutable<Vector3>, end: DeepImmutable<Vector3>, amount: number): Vector3;
        /**
         * Sets the given vector "result" with the result of the linear interpolation from the vector "start" for "amount" to the vector "end"
         * @param start defines the start value
         * @param end defines the end value
         * @param amount max defines amount between both (between 0 and 1)
         * @param result defines the Vector3 where to store the result
         */
        static LerpToRef(start: DeepImmutable<Vector3>, end: DeepImmutable<Vector3>, amount: number, result: Vector3): void;
        /**
         * Returns the dot product (float) between the vectors "left" and "right"
         * @param left defines the left operand
         * @param right defines the right operand
         * @returns the dot product
         */
        static Dot(left: DeepImmutable<Vector3>, right: DeepImmutable<Vector3>): number;
        /**
         * Returns a new Vector3 as the cross product of the vectors "left" and "right"
         * The cross product is then orthogonal to both "left" and "right"
         * @param left defines the left operand
         * @param right defines the right operand
         * @returns the cross product
         */
        static Cross(left: DeepImmutable<Vector3>, right: DeepImmutable<Vector3>): Vector3;
        /**
         * Sets the given vector "result" with the cross product of "left" and "right"
         * The cross product is then orthogonal to both "left" and "right"
         * @param left defines the left operand
         * @param right defines the right operand
         * @param result defines the Vector3 where to store the result
         */
        static CrossToRef(left: DeepImmutable<Vector3>, right: DeepImmutable<Vector3>, result: Vector3): void;
        /**
         * Returns a new Vector3 as the normalization of the given vector
         * @param vector defines the Vector3 to normalize
         * @returns the new Vector3
         */
        static Normalize(vector: DeepImmutable<Vector3>): Vector3;
        /**
         * Sets the given vector "result" with the normalization of the given first vector
         * @param vector defines the Vector3 to normalize
         * @param result defines the Vector3 where to store the result
         */
        static NormalizeToRef(vector: DeepImmutable<Vector3>, result: Vector3): void;
        /**
         * Project a Vector3 onto screen space
         * @param vector defines the Vector3 to project
         * @param world defines the world matrix to use
         * @param transform defines the transform (view x projection) matrix to use
         * @param viewport defines the screen viewport to use
         * @returns the new Vector3
         */
        static Project(vector: DeepImmutable<Vector3>, world: DeepImmutable<Matrix>, transform: DeepImmutable<Matrix>, viewport: DeepImmutable<Viewport>): Vector3;
        /** @hidden */
        static _UnprojectFromInvertedMatrixToRef(source: DeepImmutable<Vector3>, matrix: DeepImmutable<Matrix>, result: Vector3): void;
        /**
         * Unproject from screen space to object space
         * @param source defines the screen space Vector3 to use
         * @param viewportWidth defines the current width of the viewport
         * @param viewportHeight defines the current height of the viewport
         * @param world defines the world matrix to use (can be set to Identity to go to world space)
         * @param transform defines the transform (view x projection) matrix to use
         * @returns the new Vector3
         */
        static UnprojectFromTransform(source: Vector3, viewportWidth: number, viewportHeight: number, world: DeepImmutable<Matrix>, transform: DeepImmutable<Matrix>): Vector3;
        /**
         * Unproject from screen space to object space
         * @param source defines the screen space Vector3 to use
         * @param viewportWidth defines the current width of the viewport
         * @param viewportHeight defines the current height of the viewport
         * @param world defines the world matrix to use (can be set to Identity to go to world space)
         * @param view defines the view matrix to use
         * @param projection defines the projection matrix to use
         * @returns the new Vector3
         */
        static Unproject(source: DeepImmutable<Vector3>, viewportWidth: number, viewportHeight: number, world: DeepImmutable<Matrix>, view: DeepImmutable<Matrix>, projection: DeepImmutable<Matrix>): Vector3;
        /**
         * Unproject from screen space to object space
         * @param source defines the screen space Vector3 to use
         * @param viewportWidth defines the current width of the viewport
         * @param viewportHeight defines the current height of the viewport
         * @param world defines the world matrix to use (can be set to Identity to go to world space)
         * @param view defines the view matrix to use
         * @param projection defines the projection matrix to use
         * @param result defines the Vector3 where to store the result
         */
        static UnprojectToRef(source: DeepImmutable<Vector3>, viewportWidth: number, viewportHeight: number, world: DeepImmutable<Matrix>, view: DeepImmutable<Matrix>, projection: DeepImmutable<Matrix>, result: Vector3): void;
        /**
         * Unproject from screen space to object space
         * @param sourceX defines the screen space x coordinate to use
         * @param sourceY defines the screen space y coordinate to use
         * @param sourceZ defines the screen space z coordinate to use
         * @param viewportWidth defines the current width of the viewport
         * @param viewportHeight defines the current height of the viewport
         * @param world defines the world matrix to use (can be set to Identity to go to world space)
         * @param view defines the view matrix to use
         * @param projection defines the projection matrix to use
         * @param result defines the Vector3 where to store the result
         */
        static UnprojectFloatsToRef(sourceX: float, sourceY: float, sourceZ: float, viewportWidth: number, viewportHeight: number, world: DeepImmutable<Matrix>, view: DeepImmutable<Matrix>, projection: DeepImmutable<Matrix>, result: Vector3): void;
        /**
         * Gets the minimal coordinate values between two Vector3
         * @param left defines the first operand
         * @param right defines the second operand
         * @returns the new Vector3
         */
        static Minimize(left: DeepImmutable<Vector3>, right: DeepImmutable<Vector3>): Vector3;
        /**
         * Gets the maximal coordinate values between two Vector3
         * @param left defines the first operand
         * @param right defines the second operand
         * @returns the new Vector3
         */
        static Maximize(left: DeepImmutable<Vector3>, right: DeepImmutable<Vector3>): Vector3;
        /**
         * Returns the distance between the vectors "value1" and "value2"
         * @param value1 defines the first operand
         * @param value2 defines the second operand
         * @returns the distance
         */
        static Distance(value1: DeepImmutable<Vector3>, value2: DeepImmutable<Vector3>): number;
        /**
         * Returns the squared distance between the vectors "value1" and "value2"
         * @param value1 defines the first operand
         * @param value2 defines the second operand
         * @returns the squared distance
         */
        static DistanceSquared(value1: DeepImmutable<Vector3>, value2: DeepImmutable<Vector3>): number;
        /**
         * Returns a new Vector3 located at the center between "value1" and "value2"
         * @param value1 defines the first operand
         * @param value2 defines the second operand
         * @returns the new Vector3
         */
        static Center(value1: DeepImmutable<Vector3>, value2: DeepImmutable<Vector3>): Vector3;
        /**
         * Given three orthogonal normalized left-handed oriented Vector3 axis in space (target system),
         * RotationFromAxis() returns the rotation Euler angles (ex : rotation.x, rotation.y, rotation.z) to apply
         * to something in order to rotate it from its local system to the given target system
         * Note: axis1, axis2 and axis3 are normalized during this operation
         * @param axis1 defines the first axis
         * @param axis2 defines the second axis
         * @param axis3 defines the third axis
         * @returns a new Vector3
         */
        static RotationFromAxis(axis1: DeepImmutable<Vector3>, axis2: DeepImmutable<Vector3>, axis3: DeepImmutable<Vector3>): Vector3;
        /**
         * The same than RotationFromAxis but updates the given ref Vector3 parameter instead of returning a new Vector3
         * @param axis1 defines the first axis
         * @param axis2 defines the second axis
         * @param axis3 defines the third axis
         * @param ref defines the Vector3 where to store the result
         */
        static RotationFromAxisToRef(axis1: DeepImmutable<Vector3>, axis2: DeepImmutable<Vector3>, axis3: DeepImmutable<Vector3>, ref: Vector3): void;
    }
    /**
     * Vector4 class created for EulerAngle class conversion to Quaternion
     */
    export class Vector4 {
        /** x value of the vector */
        x: number;
        /** y value of the vector */
        y: number;
        /** z value of the vector */
        z: number;
        /** w value of the vector */
        w: number;
        /**
         * Creates a Vector4 object from the given floats.
         * @param x x value of the vector
         * @param y y value of the vector
         * @param z z value of the vector
         * @param w w value of the vector
         */
        constructor(
        /** x value of the vector */
        x: number, 
        /** y value of the vector */
        y: number, 
        /** z value of the vector */
        z: number, 
        /** w value of the vector */
        w: number);
        /**
         * Returns the string with the Vector4 coordinates.
         * @returns a string containing all the vector values
         */
        toString(): string;
        /**
         * Returns the string "Vector4".
         * @returns "Vector4"
         */
        getClassName(): string;
        /**
         * Returns the Vector4 hash code.
         * @returns a unique hash code
         */
        getHashCode(): number;
        /**
         * Returns a new array populated with 4 elements : the Vector4 coordinates.
         * @returns the resulting array
         */
        asArray(): number[];
        /**
         * Populates the given array from the given index with the Vector4 coordinates.
         * @param array array to populate
         * @param index index of the array to start at (default: 0)
         * @returns the Vector4.
         */
        toArray(array: FloatArray, index?: number): Vector4;
        /**
         * Update the current vector from an array
         * @param array defines the destination array
         * @param index defines the offset in the destination array
         * @returns the current Vector3
         */
        fromArray(array: FloatArray, index?: number): Vector4;
        /**
         * Adds the given vector to the current Vector4.
         * @param otherVector the vector to add
         * @returns the updated Vector4.
         */
        addInPlace(otherVector: DeepImmutable<Vector4>): Vector4;
        /**
         * Returns a new Vector4 as the result of the addition of the current Vector4 and the given one.
         * @param otherVector the vector to add
         * @returns the resulting vector
         */
        add(otherVector: DeepImmutable<Vector4>): Vector4;
        /**
         * Updates the given vector "result" with the result of the addition of the current Vector4 and the given one.
         * @param otherVector the vector to add
         * @param result the vector to store the result
         * @returns the current Vector4.
         */
        addToRef(otherVector: DeepImmutable<Vector4>, result: Vector4): Vector4;
        /**
         * Subtract in place the given vector from the current Vector4.
         * @param otherVector the vector to subtract
         * @returns the updated Vector4.
         */
        subtractInPlace(otherVector: DeepImmutable<Vector4>): Vector4;
        /**
         * Returns a new Vector4 with the result of the subtraction of the given vector from the current Vector4.
         * @param otherVector the vector to add
         * @returns the new vector with the result
         */
        subtract(otherVector: DeepImmutable<Vector4>): Vector4;
        /**
         * Sets the given vector "result" with the result of the subtraction of the given vector from the current Vector4.
         * @param otherVector the vector to subtract
         * @param result the vector to store the result
         * @returns the current Vector4.
         */
        subtractToRef(otherVector: DeepImmutable<Vector4>, result: Vector4): Vector4;
        /**
         * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.
         */
        /**
         * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.
         * @param x value to subtract
         * @param y value to subtract
         * @param z value to subtract
         * @param w value to subtract
         * @returns new vector containing the result
         */
        subtractFromFloats(x: number, y: number, z: number, w: number): Vector4;
        /**
         * Sets the given vector "result" set with the result of the subtraction of the given floats from the current Vector4 coordinates.
         * @param x value to subtract
         * @param y value to subtract
         * @param z value to subtract
         * @param w value to subtract
         * @param result the vector to store the result in
         * @returns the current Vector4.
         */
        subtractFromFloatsToRef(x: number, y: number, z: number, w: number, result: Vector4): Vector4;
        /**
         * Returns a new Vector4 set with the current Vector4 negated coordinates.
         * @returns a new vector with the negated values
         */
        negate(): Vector4;
        /**
         * Negate this vector in place
         * @returns this
         */
        negateInPlace(): Vector4;
        /**
         * Negate the current Vector4 and stores the result in the given vector "result" coordinates
         * @param result defines the Vector3 object where to store the result
         * @returns the current Vector4
         */
        negateToRef(result: Vector4): Vector4;
        /**
         * Multiplies the current Vector4 coordinates by scale (float).
         * @param scale the number to scale with
         * @returns the updated Vector4.
         */
        scaleInPlace(scale: number): Vector4;
        /**
         * Returns a new Vector4 set with the current Vector4 coordinates multiplied by scale (float).
         * @param scale the number to scale with
         * @returns a new vector with the result
         */
        scale(scale: number): Vector4;
        /**
         * Sets the given vector "result" with the current Vector4 coordinates multiplied by scale (float).
         * @param scale the number to scale with
         * @param result a vector to store the result in
         * @returns the current Vector4.
         */
        scaleToRef(scale: number, result: Vector4): Vector4;
        /**
         * Scale the current Vector4 values by a factor and add the result to a given Vector4
         * @param scale defines the scale factor
         * @param result defines the Vector4 object where to store the result
         * @returns the unmodified current Vector4
         */
        scaleAndAddToRef(scale: number, result: Vector4): Vector4;
        /**
         * Boolean : True if the current Vector4 coordinates are stricly equal to the given ones.
         * @param otherVector the vector to compare against
         * @returns true if they are equal
         */
        equals(otherVector: DeepImmutable<Vector4>): boolean;
        /**
         * Boolean : True if the current Vector4 coordinates are each beneath the distance "epsilon" from the given vector ones.
         * @param otherVector vector to compare against
         * @param epsilon (Default: very small number)
         * @returns true if they are equal
         */
        equalsWithEpsilon(otherVector: DeepImmutable<Vector4>, epsilon?: number): boolean;
        /**
         * Boolean : True if the given floats are strictly equal to the current Vector4 coordinates.
         * @param x x value to compare against
         * @param y y value to compare against
         * @param z z value to compare against
         * @param w w value to compare against
         * @returns true if equal
         */
        equalsToFloats(x: number, y: number, z: number, w: number): boolean;
        /**
         * Multiplies in place the current Vector4 by the given one.
         * @param otherVector vector to multiple with
         * @returns the updated Vector4.
         */
        multiplyInPlace(otherVector: Vector4): Vector4;
        /**
         * Returns a new Vector4 set with the multiplication result of the current Vector4 and the given one.
         * @param otherVector vector to multiple with
         * @returns resulting new vector
         */
        multiply(otherVector: DeepImmutable<Vector4>): Vector4;
        /**
         * Updates the given vector "result" with the multiplication result of the current Vector4 and the given one.
         * @param otherVector vector to multiple with
         * @param result vector to store the result
         * @returns the current Vector4.
         */
        multiplyToRef(otherVector: DeepImmutable<Vector4>, result: Vector4): Vector4;
        /**
         * Returns a new Vector4 set with the multiplication result of the given floats and the current Vector4 coordinates.
         * @param x x value multiply with
         * @param y y value multiply with
         * @param z z value multiply with
         * @param w w value multiply with
         * @returns resulting new vector
         */
        multiplyByFloats(x: number, y: number, z: number, w: number): Vector4;
        /**
         * Returns a new Vector4 set with the division result of the current Vector4 by the given one.
         * @param otherVector vector to devide with
         * @returns resulting new vector
         */
        divide(otherVector: DeepImmutable<Vector4>): Vector4;
        /**
         * Updates the given vector "result" with the division result of the current Vector4 by the given one.
         * @param otherVector vector to devide with
         * @param result vector to store the result
         * @returns the current Vector4.
         */
        divideToRef(otherVector: DeepImmutable<Vector4>, result: Vector4): Vector4;
        /**
         * Divides the current Vector3 coordinates by the given ones.
         * @param otherVector vector to devide with
         * @returns the updated Vector3.
         */
        divideInPlace(otherVector: DeepImmutable<Vector4>): Vector4;
        /**
         * Updates the Vector4 coordinates with the minimum values between its own and the given vector ones
         * @param other defines the second operand
         * @returns the current updated Vector4
         */
        minimizeInPlace(other: DeepImmutable<Vector4>): Vector4;
        /**
         * Updates the Vector4 coordinates with the maximum values between its own and the given vector ones
         * @param other defines the second operand
         * @returns the current updated Vector4
         */
        maximizeInPlace(other: DeepImmutable<Vector4>): Vector4;
        /**
         * Gets a new Vector4 from current Vector4 floored values
         * @returns a new Vector4
         */
        floor(): Vector4;
        /**
         * Gets a new Vector4 from current Vector3 floored values
         * @returns a new Vector4
         */
        fract(): Vector4;
        /**
         * Returns the Vector4 length (float).
         * @returns the length
         */
        length(): number;
        /**
         * Returns the Vector4 squared length (float).
         * @returns the length squared
         */
        lengthSquared(): number;
        /**
         * Normalizes in place the Vector4.
         * @returns the updated Vector4.
         */
        normalize(): Vector4;
        /**
         * Returns a new Vector3 from the Vector4 (x, y, z) coordinates.
         * @returns this converted to a new vector3
         */
        toVector3(): Vector3;
        /**
         * Returns a new Vector4 copied from the current one.
         * @returns the new cloned vector
         */
        clone(): Vector4;
        /**
         * Updates the current Vector4 with the given one coordinates.
         * @param source the source vector to copy from
         * @returns the updated Vector4.
         */
        copyFrom(source: DeepImmutable<Vector4>): Vector4;
        /**
         * Updates the current Vector4 coordinates with the given floats.
         * @param x float to copy from
         * @param y float to copy from
         * @param z float to copy from
         * @param w float to copy from
         * @returns the updated Vector4.
         */
        copyFromFloats(x: number, y: number, z: number, w: number): Vector4;
        /**
         * Updates the current Vector4 coordinates with the given floats.
         * @param x float to set from
         * @param y float to set from
         * @param z float to set from
         * @param w float to set from
         * @returns the updated Vector4.
         */
        set(x: number, y: number, z: number, w: number): Vector4;
        /**
         * Copies the given float to the current Vector3 coordinates
         * @param v defines the x, y, z and w coordinates of the operand
         * @returns the current updated Vector3
         */
        setAll(v: number): Vector4;
        /**
         * Returns a new Vector4 set from the starting index of the given array.
         * @param array the array to pull values from
         * @param offset the offset into the array to start at
         * @returns the new vector
         */
        static FromArray(array: DeepImmutable<ArrayLike<number>>, offset?: number): Vector4;
        /**
         * Updates the given vector "result" from the starting index of the given array.
         * @param array the array to pull values from
         * @param offset the offset into the array to start at
         * @param result the vector to store the result in
         */
        static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number, result: Vector4): void;
        /**
         * Updates the given vector "result" from the starting index of the given Float32Array.
         * @param array the array to pull values from
         * @param offset the offset into the array to start at
         * @param result the vector to store the result in
         */
        static FromFloatArrayToRef(array: DeepImmutable<Float32Array>, offset: number, result: Vector4): void;
        /**
         * Updates the given vector "result" coordinates from the given floats.
         * @param x float to set from
         * @param y float to set from
         * @param z float to set from
         * @param w float to set from
         * @param result the vector to the floats in
         */
        static FromFloatsToRef(x: number, y: number, z: number, w: number, result: Vector4): void;
        /**
         * Returns a new Vector4 set to (0.0, 0.0, 0.0, 0.0)
         * @returns the new vector
         */
        static Zero(): Vector4;
        /**
         * Returns a new Vector4 set to (1.0, 1.0, 1.0, 1.0)
         * @returns the new vector
         */
        static One(): Vector4;
        /**
         * Returns a new normalized Vector4 from the given one.
         * @param vector the vector to normalize
         * @returns the vector
         */
        static Normalize(vector: DeepImmutable<Vector4>): Vector4;
        /**
         * Updates the given vector "result" from the normalization of the given one.
         * @param vector the vector to normalize
         * @param result the vector to store the result in
         */
        static NormalizeToRef(vector: DeepImmutable<Vector4>, result: Vector4): void;
        /**
         * Returns a vector with the minimum values from the left and right vectors
         * @param left left vector to minimize
         * @param right right vector to minimize
         * @returns a new vector with the minimum of the left and right vector values
         */
        static Minimize(left: DeepImmutable<Vector4>, right: DeepImmutable<Vector4>): Vector4;
        /**
         * Returns a vector with the maximum values from the left and right vectors
         * @param left left vector to maximize
         * @param right right vector to maximize
         * @returns a new vector with the maximum of the left and right vector values
         */
        static Maximize(left: DeepImmutable<Vector4>, right: DeepImmutable<Vector4>): Vector4;
        /**
         * Returns the distance (float) between the vectors "value1" and "value2".
         * @param value1 value to calulate the distance between
         * @param value2 value to calulate the distance between
         * @return the distance between the two vectors
         */
        static Distance(value1: DeepImmutable<Vector4>, value2: DeepImmutable<Vector4>): number;
        /**
         * Returns the squared distance (float) between the vectors "value1" and "value2".
         * @param value1 value to calulate the distance between
         * @param value2 value to calulate the distance between
         * @return the distance between the two vectors squared
         */
        static DistanceSquared(value1: DeepImmutable<Vector4>, value2: DeepImmutable<Vector4>): number;
        /**
         * Returns a new Vector4 located at the center between the vectors "value1" and "value2".
         * @param value1 value to calulate the center between
         * @param value2 value to calulate the center between
         * @return the center between the two vectors
         */
        static Center(value1: DeepImmutable<Vector4>, value2: DeepImmutable<Vector4>): Vector4;
        /**
         * Returns a new Vector4 set with the result of the normal transformation by the given matrix of the given vector.
         * This methods computes transformed normalized direction vectors only.
         * @param vector the vector to transform
         * @param transformation the transformation matrix to apply
         * @returns the new vector
         */
        static TransformNormal(vector: DeepImmutable<Vector4>, transformation: DeepImmutable<Matrix>): Vector4;
        /**
         * Sets the given vector "result" with the result of the normal transformation by the given matrix of the given vector.
         * This methods computes transformed normalized direction vectors only.
         * @param vector the vector to transform
         * @param transformation the transformation matrix to apply
         * @param result the vector to store the result in
         */
        static TransformNormalToRef(vector: DeepImmutable<Vector4>, transformation: DeepImmutable<Matrix>, result: Vector4): void;
        /**
         * Sets the given vector "result" with the result of the normal transformation by the given matrix of the given floats (x, y, z, w).
         * This methods computes transformed normalized direction vectors only.
         * @param x value to transform
         * @param y value to transform
         * @param z value to transform
         * @param w value to transform
         * @param transformation the transformation matrix to apply
         * @param result the vector to store the results in
         */
        static TransformNormalFromFloatsToRef(x: number, y: number, z: number, w: number, transformation: DeepImmutable<Matrix>, result: Vector4): void;
        /**
         * Creates a new Vector4 from a Vector3
         * @param source defines the source data
         * @param w defines the 4th component (default is 0)
         * @returns a new Vector4
         */
        static FromVector3(source: Vector3, w?: number): Vector4;
    }
    /**
     * Class used to store quaternion data
     * @see https://en.wikipedia.org/wiki/Quaternion
     * @see https://doc.babylonjs.com/features/position,_rotation,_scaling
     */
    export class Quaternion {
        /** @hidden */
        _x: number;
        /** @hidden */
        _y: number;
        /** @hidden */
        _z: number;
        /** @hidden */
        _w: number;
        /** @hidden */
        _isDirty: boolean;
        /** Gets or sets the x coordinate */
        get x(): number;
        set x(value: number);
        /** Gets or sets the y coordinate */
        get y(): number;
        set y(value: number);
        /** Gets or sets the z coordinate */
        get z(): number;
        set z(value: number);
        /** Gets or sets the w coordinate */
        get w(): number;
        set w(value: number);
        /**
         * Creates a new Quaternion from the given floats
         * @param x defines the first component (0 by default)
         * @param y defines the second component (0 by default)
         * @param z defines the third component (0 by default)
         * @param w defines the fourth component (1.0 by default)
         */
        constructor(x?: number, y?: number, z?: number, w?: number);
        /**
         * Gets a string representation for the current quaternion
         * @returns a string with the Quaternion coordinates
         */
        toString(): string;
        /**
         * Gets the class name of the quaternion
         * @returns the string "Quaternion"
         */
        getClassName(): string;
        /**
         * Gets a hash code for this quaternion
         * @returns the quaternion hash code
         */
        getHashCode(): number;
        /**
         * Copy the quaternion to an array
         * @returns a new array populated with 4 elements from the quaternion coordinates
         */
        asArray(): number[];
        /**
         * Check if two quaternions are equals
         * @param otherQuaternion defines the second operand
         * @return true if the current quaternion and the given one coordinates are strictly equals
         */
        equals(otherQuaternion: DeepImmutable<Quaternion>): boolean;
        /**
         * Gets a boolean if two quaternions are equals (using an epsilon value)
         * @param otherQuaternion defines the other quaternion
         * @param epsilon defines the minimal distance to consider equality
         * @returns true if the given quaternion coordinates are close to the current ones by a distance of epsilon.
         */
        equalsWithEpsilon(otherQuaternion: DeepImmutable<Quaternion>, epsilon?: number): boolean;
        /**
         * Clone the current quaternion
         * @returns a new quaternion copied from the current one
         */
        clone(): Quaternion;
        /**
         * Copy a quaternion to the current one
         * @param other defines the other quaternion
         * @returns the updated current quaternion
         */
        copyFrom(other: DeepImmutable<Quaternion>): Quaternion;
        /**
         * Updates the current quaternion with the given float coordinates
         * @param x defines the x coordinate
         * @param y defines the y coordinate
         * @param z defines the z coordinate
         * @param w defines the w coordinate
         * @returns the updated current quaternion
         */
        copyFromFloats(x: number, y: number, z: number, w: number): Quaternion;
        /**
         * Updates the current quaternion from the given float coordinates
         * @param x defines the x coordinate
         * @param y defines the y coordinate
         * @param z defines the z coordinate
         * @param w defines the w coordinate
         * @returns the updated current quaternion
         */
        set(x: number, y: number, z: number, w: number): Quaternion;
        /**
         * Adds two quaternions
         * @param other defines the second operand
         * @returns a new quaternion as the addition result of the given one and the current quaternion
         */
        add(other: DeepImmutable<Quaternion>): Quaternion;
        /**
         * Add a quaternion to the current one
         * @param other defines the quaternion to add
         * @returns the current quaternion
         */
        addInPlace(other: DeepImmutable<Quaternion>): Quaternion;
        /**
         * Subtract two quaternions
         * @param other defines the second operand
         * @returns a new quaternion as the subtraction result of the given one from the current one
         */
        subtract(other: Quaternion): Quaternion;
        /**
         * Multiplies the current quaternion by a scale factor
         * @param value defines the scale factor
         * @returns a new quaternion set by multiplying the current quaternion coordinates by the float "scale"
         */
        scale(value: number): Quaternion;
        /**
         * Scale the current quaternion values by a factor and stores the result to a given quaternion
         * @param scale defines the scale factor
         * @param result defines the Quaternion object where to store the result
         * @returns the unmodified current quaternion
         */
        scaleToRef(scale: number, result: Quaternion): Quaternion;
        /**
         * Multiplies in place the current quaternion by a scale factor
         * @param value defines the scale factor
         * @returns the current modified quaternion
         */
        scaleInPlace(value: number): Quaternion;
        /**
         * Scale the current quaternion values by a factor and add the result to a given quaternion
         * @param scale defines the scale factor
         * @param result defines the Quaternion object where to store the result
         * @returns the unmodified current quaternion
         */
        scaleAndAddToRef(scale: number, result: Quaternion): Quaternion;
        /**
         * Multiplies two quaternions
         * @param q1 defines the second operand
         * @returns a new quaternion set as the multiplication result of the current one with the given one "q1"
         */
        multiply(q1: DeepImmutable<Quaternion>): Quaternion;
        /**
         * Sets the given "result" as the the multiplication result of the current one with the given one "q1"
         * @param q1 defines the second operand
         * @param result defines the target quaternion
         * @returns the current quaternion
         */
        multiplyToRef(q1: DeepImmutable<Quaternion>, result: Quaternion): Quaternion;
        /**
         * Updates the current quaternion with the multiplication of itself with the given one "q1"
         * @param q1 defines the second operand
         * @returns the currentupdated quaternion
         */
        multiplyInPlace(q1: DeepImmutable<Quaternion>): Quaternion;
        /**
         * Conjugates (1-q) the current quaternion and stores the result in the given quaternion
         * @param ref defines the target quaternion
         * @returns the current quaternion
         */
        conjugateToRef(ref: Quaternion): Quaternion;
        /**
         * Conjugates in place (1-q) the current quaternion
         * @returns the current updated quaternion
         */
        conjugateInPlace(): Quaternion;
        /**
         * Conjugates in place (1-q) the current quaternion
         * @returns a new quaternion
         */
        conjugate(): Quaternion;
        /**
         * Gets length of current quaternion
         * @returns the quaternion length (float)
         */
        length(): number;
        /**
         * Normalize in place the current quaternion
         * @returns the current updated quaternion
         */
        normalize(): Quaternion;
        /**
         * Returns a new Vector3 set with the Euler angles translated from the current quaternion
         * @param order is a reserved parameter and is ignore for now
         * @returns a new Vector3 containing the Euler angles
         */
        toEulerAngles(order?: string): Vector3;
        /**
         * Sets the given vector3 "result" with the Euler angles translated from the current quaternion
         * @param result defines the vector which will be filled with the Euler angles
         * @param order is a reserved parameter and is ignore for now
         * @returns the current unchanged quaternion
         */
        toEulerAnglesToRef(result: Vector3): Quaternion;
        /**
         * Updates the given rotation matrix with the current quaternion values
         * @param result defines the target matrix
         * @returns the current unchanged quaternion
         */
        toRotationMatrix(result: Matrix): Quaternion;
        /**
         * Updates the current quaternion from the given rotation matrix values
         * @param matrix defines the source matrix
         * @returns the current updated quaternion
         */
        fromRotationMatrix(matrix: DeepImmutable<Matrix>): Quaternion;
        /**
         * Creates a new quaternion from a rotation matrix
         * @param matrix defines the source matrix
         * @returns a new quaternion created from the given rotation matrix values
         */
        static FromRotationMatrix(matrix: DeepImmutable<Matrix>): Quaternion;
        /**
         * Updates the given quaternion with the given rotation matrix values
         * @param matrix defines the source matrix
         * @param result defines the target quaternion
         */
        static FromRotationMatrixToRef(matrix: DeepImmutable<Matrix>, result: Quaternion): void;
        /**
         * Returns the dot product (float) between the quaternions "left" and "right"
         * @param left defines the left operand
         * @param right defines the right operand
         * @returns the dot product
         */
        static Dot(left: DeepImmutable<Quaternion>, right: DeepImmutable<Quaternion>): number;
        /**
         * Checks if the two quaternions are close to each other
         * @param quat0 defines the first quaternion to check
         * @param quat1 defines the second quaternion to check
         * @returns true if the two quaternions are close to each other
         */
        static AreClose(quat0: DeepImmutable<Quaternion>, quat1: DeepImmutable<Quaternion>): boolean;
        /**
         * Creates an empty quaternion
         * @returns a new quaternion set to (0.0, 0.0, 0.0)
         */
        static Zero(): Quaternion;
        /**
         * Inverse a given quaternion
         * @param q defines the source quaternion
         * @returns a new quaternion as the inverted current quaternion
         */
        static Inverse(q: DeepImmutable<Quaternion>): Quaternion;
        /**
         * Inverse a given quaternion
         * @param q defines the source quaternion
         * @param result the quaternion the result will be stored in
         * @returns the result quaternion
         */
        static InverseToRef(q: Quaternion, result: Quaternion): Quaternion;
        /**
         * Creates an identity quaternion
         * @returns the identity quaternion
         */
        static Identity(): Quaternion;
        /**
         * Gets a boolean indicating if the given quaternion is identity
         * @param quaternion defines the quaternion to check
         * @returns true if the quaternion is identity
         */
        static IsIdentity(quaternion: DeepImmutable<Quaternion>): boolean;
        /**
         * Creates a quaternion from a rotation around an axis
         * @param axis defines the axis to use
         * @param angle defines the angle to use
         * @returns a new quaternion created from the given axis (Vector3) and angle in radians (float)
         */
        static RotationAxis(axis: DeepImmutable<Vector3>, angle: number): Quaternion;
        /**
         * Creates a rotation around an axis and stores it into the given quaternion
         * @param axis defines the axis to use
         * @param angle defines the angle to use
         * @param result defines the target quaternion
         * @returns the target quaternion
         */
        static RotationAxisToRef(axis: DeepImmutable<Vector3>, angle: number, result: Quaternion): Quaternion;
        /**
         * Creates a new quaternion from data stored into an array
         * @param array defines the data source
         * @param offset defines the offset in the source array where the data starts
         * @returns a new quaternion
         */
        static FromArray(array: DeepImmutable<ArrayLike<number>>, offset?: number): Quaternion;
        /**
         * Updates the given quaternion "result" from the starting index of the given array.
         * @param array the array to pull values from
         * @param offset the offset into the array to start at
         * @param result the quaternion to store the result in
         */
        static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number, result: Quaternion): void;
        /**
         * Create a quaternion from Euler rotation angles
         * @param x Pitch
         * @param y Yaw
         * @param z Roll
         * @returns the new Quaternion
         */
        static FromEulerAngles(x: number, y: number, z: number): Quaternion;
        /**
         * Updates a quaternion from Euler rotation angles
         * @param x Pitch
         * @param y Yaw
         * @param z Roll
         * @param result the quaternion to store the result
         * @returns the updated quaternion
         */
        static FromEulerAnglesToRef(x: number, y: number, z: number, result: Quaternion): Quaternion;
        /**
         * Create a quaternion from Euler rotation vector
         * @param vec the Euler vector (x Pitch, y Yaw, z Roll)
         * @returns the new Quaternion
         */
        static FromEulerVector(vec: DeepImmutable<Vector3>): Quaternion;
        /**
         * Updates a quaternion from Euler rotation vector
         * @param vec the Euler vector (x Pitch, y Yaw, z Roll)
         * @param result the quaternion to store the result
         * @returns the updated quaternion
         */
        static FromEulerVectorToRef(vec: DeepImmutable<Vector3>, result: Quaternion): Quaternion;
        /**
         * Creates a new quaternion from the given Euler float angles (y, x, z)
         * @param yaw defines the rotation around Y axis
         * @param pitch defines the rotation around X axis
         * @param roll defines the rotation around Z axis
         * @returns the new quaternion
         */
        static RotationYawPitchRoll(yaw: number, pitch: number, roll: number): Quaternion;
        /**
         * Creates a new rotation from the given Euler float angles (y, x, z) and stores it in the target quaternion
         * @param yaw defines the rotation around Y axis
         * @param pitch defines the rotation around X axis
         * @param roll defines the rotation around Z axis
         * @param result defines the target quaternion
         */
        static RotationYawPitchRollToRef(yaw: number, pitch: number, roll: number, result: Quaternion): void;
        /**
         * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation
         * @param alpha defines the rotation around first axis
         * @param beta defines the rotation around second axis
         * @param gamma defines the rotation around third axis
         * @returns the new quaternion
         */
        static RotationAlphaBetaGamma(alpha: number, beta: number, gamma: number): Quaternion;
        /**
         * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation and stores it in the target quaternion
         * @param alpha defines the rotation around first axis
         * @param beta defines the rotation around second axis
         * @param gamma defines the rotation around third axis
         * @param result defines the target quaternion
         */
        static RotationAlphaBetaGammaToRef(alpha: number, beta: number, gamma: number, result: Quaternion): void;
        /**
         * Creates a new quaternion containing the rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation)
         * @param axis1 defines the first axis
         * @param axis2 defines the second axis
         * @param axis3 defines the third axis
         * @returns the new quaternion
         */
        static RotationQuaternionFromAxis(axis1: DeepImmutable<Vector3>, axis2: DeepImmutable<Vector3>, axis3: DeepImmutable<Vector3>): Quaternion;
        /**
         * Creates a rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation) and stores it in the target quaternion
         * @param axis1 defines the first axis
         * @param axis2 defines the second axis
         * @param axis3 defines the third axis
         * @param ref defines the target quaternion
         */
        static RotationQuaternionFromAxisToRef(axis1: DeepImmutable<Vector3>, axis2: DeepImmutable<Vector3>, axis3: DeepImmutable<Vector3>, ref: Quaternion): void;
        /**
         * Interpolates between two quaternions
         * @param left defines first quaternion
         * @param right defines second quaternion
         * @param amount defines the gradient to use
         * @returns the new interpolated quaternion
         */
        static Slerp(left: DeepImmutable<Quaternion>, right: DeepImmutable<Quaternion>, amount: number): Quaternion;
        /**
         * Interpolates between two quaternions and stores it into a target quaternion
         * @param left defines first quaternion
         * @param right defines second quaternion
         * @param amount defines the gradient to use
         * @param result defines the target quaternion
         */
        static SlerpToRef(left: DeepImmutable<Quaternion>, right: DeepImmutable<Quaternion>, amount: number, result: Quaternion): void;
        /**
         * Interpolate between two quaternions using Hermite interpolation
         * @param value1 defines first quaternion
         * @param tangent1 defines the incoming tangent
         * @param value2 defines second quaternion
         * @param tangent2 defines the outgoing tangent
         * @param amount defines the target quaternion
         * @returns the new interpolated quaternion
         */
        static Hermite(value1: DeepImmutable<Quaternion>, tangent1: DeepImmutable<Quaternion>, value2: DeepImmutable<Quaternion>, tangent2: DeepImmutable<Quaternion>, amount: number): Quaternion;
    }
    /**
     * Class used to store matrix data (4x4)
     */
    export class Matrix {
        /**
         * Gets the precision of matrix computations
         */
        static get Use64Bits(): boolean;
        private static _updateFlagSeed;
        private static _identityReadOnly;
        private _isIdentity;
        private _isIdentityDirty;
        private _isIdentity3x2;
        private _isIdentity3x2Dirty;
        /**
         * Gets the update flag of the matrix which is an unique number for the matrix.
         * It will be incremented every time the matrix data change.
         * You can use it to speed the comparison between two versions of the same matrix.
         */
        updateFlag: number;
        private readonly _m;
        /**
         * Gets the internal data of the matrix
         */
        get m(): DeepImmutable<Float32Array | Array<number>>;
        /** @hidden */
        _markAsUpdated(): void;
        /** @hidden */
        private _updateIdentityStatus;
        /**
         * Creates an empty matrix (filled with zeros)
         */
        constructor();
        /**
         * Check if the current matrix is identity
         * @returns true is the matrix is the identity matrix
         */
        isIdentity(): boolean;
        /**
         * Check if the current matrix is identity as a texture matrix (3x2 store in 4x4)
         * @returns true is the matrix is the identity matrix
         */
        isIdentityAs3x2(): boolean;
        /**
         * Gets the determinant of the matrix
         * @returns the matrix determinant
         */
        determinant(): number;
        /**
         * Returns the matrix as a Float32Array or Array<number>
         * @returns the matrix underlying array
         */
        toArray(): DeepImmutable<Float32Array | Array<number>>;
        /**
         * Returns the matrix as a Float32Array or Array<number>
        * @returns the matrix underlying array.
        */
        asArray(): DeepImmutable<Float32Array | Array<number>>;
        /**
         * Inverts the current matrix in place
         * @returns the current inverted matrix
         */
        invert(): Matrix;
        /**
         * Sets all the matrix elements to zero
         * @returns the current matrix
         */
        reset(): Matrix;
        /**
         * Adds the current matrix with a second one
         * @param other defines the matrix to add
         * @returns a new matrix as the addition of the current matrix and the given one
         */
        add(other: DeepImmutable<Matrix>): Matrix;
        /**
         * Sets the given matrix "result" to the addition of the current matrix and the given one
         * @param other defines the matrix to add
         * @param result defines the target matrix
         * @returns the current matrix
         */
        addToRef(other: DeepImmutable<Matrix>, result: Matrix): Matrix;
        /**
         * Adds in place the given matrix to the current matrix
         * @param other defines the second operand
         * @returns the current updated matrix
         */
        addToSelf(other: DeepImmutable<Matrix>): Matrix;
        /**
         * Sets the given matrix to the current inverted Matrix
         * @param other defines the target matrix
         * @returns the unmodified current matrix
         */
        invertToRef(other: Matrix): Matrix;
        /**
         * add a value at the specified position in the current Matrix
         * @param index the index of the value within the matrix. between 0 and 15.
         * @param value the value to be added
         * @returns the current updated matrix
         */
        addAtIndex(index: number, value: number): Matrix;
        /**
         * mutiply the specified position in the current Matrix by a value
         * @param index the index of the value within the matrix. between 0 and 15.
         * @param value the value to be added
         * @returns the current updated matrix
         */
        multiplyAtIndex(index: number, value: number): Matrix;
        /**
         * Inserts the translation vector (using 3 floats) in the current matrix
         * @param x defines the 1st component of the translation
         * @param y defines the 2nd component of the translation
         * @param z defines the 3rd component of the translation
         * @returns the current updated matrix
         */
        setTranslationFromFloats(x: number, y: number, z: number): Matrix;
        /**
         * Adds the translation vector (using 3 floats) in the current matrix
         * @param x defines the 1st component of the translation
         * @param y defines the 2nd component of the translation
         * @param z defines the 3rd component of the translation
         * @returns the current updated matrix
         */
        addTranslationFromFloats(x: number, y: number, z: number): Matrix;
        /**
         * Inserts the translation vector in the current matrix
         * @param vector3 defines the translation to insert
         * @returns the current updated matrix
         */
        setTranslation(vector3: DeepImmutable<Vector3>): Matrix;
        /**
         * Gets the translation value of the current matrix
         * @returns a new Vector3 as the extracted translation from the matrix
         */
        getTranslation(): Vector3;
        /**
         * Fill a Vector3 with the extracted translation from the matrix
         * @param result defines the Vector3 where to store the translation
         * @returns the current matrix
         */
        getTranslationToRef(result: Vector3): Matrix;
        /**
         * Remove rotation and scaling part from the matrix
         * @returns the updated matrix
         */
        removeRotationAndScaling(): Matrix;
        /**
         * Multiply two matrices
         * @param other defines the second operand
         * @returns a new matrix set with the multiplication result of the current Matrix and the given one
         */
        multiply(other: DeepImmutable<Matrix>): Matrix;
        /**
         * Copy the current matrix from the given one
         * @param other defines the source matrix
         * @returns the current updated matrix
         */
        copyFrom(other: DeepImmutable<Matrix>): Matrix;
        /**
         * Populates the given array from the starting index with the current matrix values
         * @param array defines the target array
         * @param offset defines the offset in the target array where to start storing values
         * @returns the current matrix
         */
        copyToArray(array: Float32Array | Array<number>, offset?: number): Matrix;
        /**
         * Sets the given matrix "result" with the multiplication result of the current Matrix and the given one
         * @param other defines the second operand
         * @param result defines the matrix where to store the multiplication
         * @returns the current matrix
         */
        multiplyToRef(other: DeepImmutable<Matrix>, result: Matrix): Matrix;
        /**
         * Sets the Float32Array "result" from the given index "offset" with the multiplication of the current matrix and the given one
         * @param other defines the second operand
         * @param result defines the array where to store the multiplication
         * @param offset defines the offset in the target array where to start storing values
         * @returns the current matrix
         */
        multiplyToArray(other: DeepImmutable<Matrix>, result: Float32Array | Array<number>, offset: number): Matrix;
        /**
         * Check equality between this matrix and a second one
         * @param value defines the second matrix to compare
         * @returns true is the current matrix and the given one values are strictly equal
         */
        equals(value: DeepImmutable<Matrix>): boolean;
        /**
         * Clone the current matrix
         * @returns a new matrix from the current matrix
         */
        clone(): Matrix;
        /**
         * Returns the name of the current matrix class
         * @returns the string "Matrix"
         */
        getClassName(): string;
        /**
         * Gets the hash code of the current matrix
         * @returns the hash code
         */
        getHashCode(): number;
        /**
         * Decomposes the current Matrix into a translation, rotation and scaling components
         * @param scale defines the scale vector3 given as a reference to update
         * @param rotation defines the rotation quaternion given as a reference to update
         * @param translation defines the translation vector3 given as a reference to update
         * @returns true if operation was successful
         */
        decompose(scale?: Vector3, rotation?: Quaternion, translation?: Vector3): boolean;
        /**
         * Gets specific row of the matrix
         * @param index defines the number of the row to get
         * @returns the index-th row of the current matrix as a new Vector4
         */
        getRow(index: number): Nullable<Vector4>;
        /**
         * Sets the index-th row of the current matrix to the vector4 values
         * @param index defines the number of the row to set
         * @param row defines the target vector4
         * @returns the updated current matrix
         */
        setRow(index: number, row: Vector4): Matrix;
        /**
         * Compute the transpose of the matrix
         * @returns the new transposed matrix
         */
        transpose(): Matrix;
        /**
         * Compute the transpose of the matrix and store it in a given matrix
         * @param result defines the target matrix
         * @returns the current matrix
         */
        transposeToRef(result: Matrix): Matrix;
        /**
         * Sets the index-th row of the current matrix with the given 4 x float values
         * @param index defines the row index
         * @param x defines the x component to set
         * @param y defines the y component to set
         * @param z defines the z component to set
         * @param w defines the w component to set
         * @returns the updated current matrix
         */
        setRowFromFloats(index: number, x: number, y: number, z: number, w: number): Matrix;
        /**
         * Compute a new matrix set with the current matrix values multiplied by scale (float)
         * @param scale defines the scale factor
         * @returns a new matrix
         */
        scale(scale: number): Matrix;
        /**
         * Scale the current matrix values by a factor to a given result matrix
         * @param scale defines the scale factor
         * @param result defines the matrix to store the result
         * @returns the current matrix
         */
        scaleToRef(scale: number, result: Matrix): Matrix;
        /**
         * Scale the current matrix values by a factor and add the result to a given matrix
         * @param scale defines the scale factor
         * @param result defines the Matrix to store the result
         * @returns the current matrix
         */
        scaleAndAddToRef(scale: number, result: Matrix): Matrix;
        /**
         * Writes to the given matrix a normal matrix, computed from this one (using values from identity matrix for fourth row and column).
         * @param ref matrix to store the result
         */
        toNormalMatrix(ref: Matrix): void;
        /**
         * Gets only rotation part of the current matrix
         * @returns a new matrix sets to the extracted rotation matrix from the current one
         */
        getRotationMatrix(): Matrix;
        /**
         * Extracts the rotation matrix from the current one and sets it as the given "result"
         * @param result defines the target matrix to store data to
         * @returns the current matrix
         */
        getRotationMatrixToRef(result: Matrix): Matrix;
        /**
         * Toggles model matrix from being right handed to left handed in place and vice versa
         */
        toggleModelMatrixHandInPlace(): void;
        /**
         * Toggles projection matrix from being right handed to left handed in place and vice versa
         */
        toggleProjectionMatrixHandInPlace(): void;
        /**
         * Creates a matrix from an array
         * @param array defines the source array
         * @param offset defines an offset in the source array
         * @returns a new Matrix set from the starting index of the given array
         */
        static FromArray(array: DeepImmutable<ArrayLike<number>>, offset?: number): Matrix;
        /**
         * Copy the content of an array into a given matrix
         * @param array defines the source array
         * @param offset defines an offset in the source array
         * @param result defines the target matrix
         */
        static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number, result: Matrix): void;
        /**
         * Stores an array into a matrix after having multiplied each component by a given factor
         * @param array defines the source array
         * @param offset defines the offset in the source array
         * @param scale defines the scaling factor
         * @param result defines the target matrix
         */
        static FromFloat32ArrayToRefScaled(array: DeepImmutable<Float32Array | Array<number>>, offset: number, scale: number, result: Matrix): void;
        /**
         * Gets an identity matrix that must not be updated
         */
        static get IdentityReadOnly(): DeepImmutable<Matrix>;
        /**
         * Stores a list of values (16) inside a given matrix
         * @param initialM11 defines 1st value of 1st row
         * @param initialM12 defines 2nd value of 1st row
         * @param initialM13 defines 3rd value of 1st row
         * @param initialM14 defines 4th value of 1st row
         * @param initialM21 defines 1st value of 2nd row
         * @param initialM22 defines 2nd value of 2nd row
         * @param initialM23 defines 3rd value of 2nd row
         * @param initialM24 defines 4th value of 2nd row
         * @param initialM31 defines 1st value of 3rd row
         * @param initialM32 defines 2nd value of 3rd row
         * @param initialM33 defines 3rd value of 3rd row
         * @param initialM34 defines 4th value of 3rd row
         * @param initialM41 defines 1st value of 4th row
         * @param initialM42 defines 2nd value of 4th row
         * @param initialM43 defines 3rd value of 4th row
         * @param initialM44 defines 4th value of 4th row
         * @param result defines the target matrix
         */
        static FromValuesToRef(initialM11: number, initialM12: number, initialM13: number, initialM14: number, initialM21: number, initialM22: number, initialM23: number, initialM24: number, initialM31: number, initialM32: number, initialM33: number, initialM34: number, initialM41: number, initialM42: number, initialM43: number, initialM44: number, result: Matrix): void;
        /**
         * Creates new matrix from a list of values (16)
         * @param initialM11 defines 1st value of 1st row
         * @param initialM12 defines 2nd value of 1st row
         * @param initialM13 defines 3rd value of 1st row
         * @param initialM14 defines 4th value of 1st row
         * @param initialM21 defines 1st value of 2nd row
         * @param initialM22 defines 2nd value of 2nd row
         * @param initialM23 defines 3rd value of 2nd row
         * @param initialM24 defines 4th value of 2nd row
         * @param initialM31 defines 1st value of 3rd row
         * @param initialM32 defines 2nd value of 3rd row
         * @param initialM33 defines 3rd value of 3rd row
         * @param initialM34 defines 4th value of 3rd row
         * @param initialM41 defines 1st value of 4th row
         * @param initialM42 defines 2nd value of 4th row
         * @param initialM43 defines 3rd value of 4th row
         * @param initialM44 defines 4th value of 4th row
         * @returns the new matrix
         */
        static FromValues(initialM11: number, initialM12: number, initialM13: number, initialM14: number, initialM21: number, initialM22: number, initialM23: number, initialM24: number, initialM31: number, initialM32: number, initialM33: number, initialM34: number, initialM41: number, initialM42: number, initialM43: number, initialM44: number): Matrix;
        /**
         * Creates a new matrix composed by merging scale (vector3), rotation (quaternion) and translation (vector3)
         * @param scale defines the scale vector3
         * @param rotation defines the rotation quaternion
         * @param translation defines the translation vector3
         * @returns a new matrix
         */
        static Compose(scale: DeepImmutable<Vector3>, rotation: DeepImmutable<Quaternion>, translation: DeepImmutable<Vector3>): Matrix;
        /**
         * Sets a matrix to a value composed by merging scale (vector3), rotation (quaternion) and translation (vector3)
         * @param scale defines the scale vector3
         * @param rotation defines the rotation quaternion
         * @param translation defines the translation vector3
         * @param result defines the target matrix
         */
        static ComposeToRef(scale: DeepImmutable<Vector3>, rotation: DeepImmutable<Quaternion>, translation: DeepImmutable<Vector3>, result: Matrix): void;
        /**
         * Creates a new identity matrix
         * @returns a new identity matrix
         */
        static Identity(): Matrix;
        /**
         * Creates a new identity matrix and stores the result in a given matrix
         * @param result defines the target matrix
         */
        static IdentityToRef(result: Matrix): void;
        /**
         * Creates a new zero matrix
         * @returns a new zero matrix
         */
        static Zero(): Matrix;
        /**
         * Creates a new rotation matrix for "angle" radians around the X axis
         * @param angle defines the angle (in radians) to use
         * @return the new matrix
         */
        static RotationX(angle: number): Matrix;
        /**
         * Creates a new matrix as the invert of a given matrix
         * @param source defines the source matrix
         * @returns the new matrix
         */
        static Invert(source: DeepImmutable<Matrix>): Matrix;
        /**
         * Creates a new rotation matrix for "angle" radians around the X axis and stores it in a given matrix
         * @param angle defines the angle (in radians) to use
         * @param result defines the target matrix
         */
        static RotationXToRef(angle: number, result: Matrix): void;
        /**
         * Creates a new rotation matrix for "angle" radians around the Y axis
         * @param angle defines the angle (in radians) to use
         * @return the new matrix
         */
        static RotationY(angle: number): Matrix;
        /**
         * Creates a new rotation matrix for "angle" radians around the Y axis and stores it in a given matrix
         * @param angle defines the angle (in radians) to use
         * @param result defines the target matrix
         */
        static RotationYToRef(angle: number, result: Matrix): void;
        /**
         * Creates a new rotation matrix for "angle" radians around the Z axis
         * @param angle defines the angle (in radians) to use
         * @return the new matrix
         */
        static RotationZ(angle: number): Matrix;
        /**
         * Creates a new rotation matrix for "angle" radians around the Z axis and stores it in a given matrix
         * @param angle defines the angle (in radians) to use
         * @param result defines the target matrix
         */
        static RotationZToRef(angle: number, result: Matrix): void;
        /**
         * Creates a new rotation matrix for "angle" radians around the given axis
         * @param axis defines the axis to use
         * @param angle defines the angle (in radians) to use
         * @return the new matrix
         */
        static RotationAxis(axis: DeepImmutable<Vector3>, angle: number): Matrix;
        /**
         * Creates a new rotation matrix for "angle" radians around the given axis and stores it in a given matrix
         * @param axis defines the axis to use
         * @param angle defines the angle (in radians) to use
         * @param result defines the target matrix
         */
        static RotationAxisToRef(axis: DeepImmutable<Vector3>, angle: number, result: Matrix): void;
        /**
         * Takes normalised vectors and returns a rotation matrix to align "from" with "to".
         * Taken from http://www.iquilezles.org/www/articles/noacos/noacos.htm
         * @param from defines the vector to align
         * @param to defines the vector to align to
         * @param result defines the target matrix
         */
        static RotationAlignToRef(from: DeepImmutable<Vector3>, to: DeepImmutable<Vector3>, result: Matrix): void;
        /**
         * Creates a rotation matrix
         * @param yaw defines the yaw angle in radians (Y axis)
         * @param pitch defines the pitch angle in radians (X axis)
         * @param roll defines the roll angle in radians (Z axis)
         * @returns the new rotation matrix
         */
        static RotationYawPitchRoll(yaw: number, pitch: number, roll: number): Matrix;
        /**
         * Creates a rotation matrix and stores it in a given matrix
         * @param yaw defines the yaw angle in radians (Y axis)
         * @param pitch defines the pitch angle in radians (X axis)
         * @param roll defines the roll angle in radians (Z axis)
         * @param result defines the target matrix
         */
        static RotationYawPitchRollToRef(yaw: number, pitch: number, roll: number, result: Matrix): void;
        /**
         * Creates a scaling matrix
         * @param x defines the scale factor on X axis
         * @param y defines the scale factor on Y axis
         * @param z defines the scale factor on Z axis
         * @returns the new matrix
         */
        static Scaling(x: number, y: number, z: number): Matrix;
        /**
         * Creates a scaling matrix and stores it in a given matrix
         * @param x defines the scale factor on X axis
         * @param y defines the scale factor on Y axis
         * @param z defines the scale factor on Z axis
         * @param result defines the target matrix
         */
        static ScalingToRef(x: number, y: number, z: number, result: Matrix): void;
        /**
         * Creates a translation matrix
         * @param x defines the translation on X axis
         * @param y defines the translation on Y axis
         * @param z defines the translationon Z axis
         * @returns the new matrix
         */
        static Translation(x: number, y: number, z: number): Matrix;
        /**
         * Creates a translation matrix and stores it in a given matrix
         * @param x defines the translation on X axis
         * @param y defines the translation on Y axis
         * @param z defines the translationon Z axis
         * @param result defines the target matrix
         */
        static TranslationToRef(x: number, y: number, z: number, result: Matrix): void;
        /**
         * Returns a new Matrix whose values are the interpolated values for "gradient" (float) between the ones of the matrices "startValue" and "endValue".
         * @param startValue defines the start value
         * @param endValue defines the end value
         * @param gradient defines the gradient factor
         * @returns the new matrix
         */
        static Lerp(startValue: DeepImmutable<Matrix>, endValue: DeepImmutable<Matrix>, gradient: number): Matrix;
        /**
         * Set the given matrix "result" as the interpolated values for "gradient" (float) between the ones of the matrices "startValue" and "endValue".
         * @param startValue defines the start value
         * @param endValue defines the end value
         * @param gradient defines the gradient factor
         * @param result defines the Matrix object where to store data
         */
        static LerpToRef(startValue: DeepImmutable<Matrix>, endValue: DeepImmutable<Matrix>, gradient: number, result: Matrix): void;
        /**
         * Builds a new matrix whose values are computed by:
         * * decomposing the the "startValue" and "endValue" matrices into their respective scale, rotation and translation matrices
         * * interpolating for "gradient" (float) the values between each of these decomposed matrices between the start and the end
         * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices
         * @param startValue defines the first matrix
         * @param endValue defines the second matrix
         * @param gradient defines the gradient between the two matrices
         * @returns the new matrix
         */
        static DecomposeLerp(startValue: DeepImmutable<Matrix>, endValue: DeepImmutable<Matrix>, gradient: number): Matrix;
        /**
         * Update a matrix to values which are computed by:
         * * decomposing the the "startValue" and "endValue" matrices into their respective scale, rotation and translation matrices
         * * interpolating for "gradient" (float) the values between each of these decomposed matrices between the start and the end
         * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices
         * @param startValue defines the first matrix
         * @param endValue defines the second matrix
         * @param gradient defines the gradient between the two matrices
         * @param result defines the target matrix
         */
        static DecomposeLerpToRef(startValue: DeepImmutable<Matrix>, endValue: DeepImmutable<Matrix>, gradient: number, result: Matrix): void;
        /**
         * Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up"
         * This function works in left handed mode
         * @param eye defines the final position of the entity
         * @param target defines where the entity should look at
         * @param up defines the up vector for the entity
         * @returns the new matrix
         */
        static LookAtLH(eye: DeepImmutable<Vector3>, target: DeepImmutable<Vector3>, up: DeepImmutable<Vector3>): Matrix;
        /**
         * Sets the given "result" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up".
         * This function works in left handed mode
         * @param eye defines the final position of the entity
         * @param target defines where the entity should look at
         * @param up defines the up vector for the entity
         * @param result defines the target matrix
         */
        static LookAtLHToRef(eye: DeepImmutable<Vector3>, target: DeepImmutable<Vector3>, up: DeepImmutable<Vector3>, result: Matrix): void;
        /**
         * Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up"
         * This function works in right handed mode
         * @param eye defines the final position of the entity
         * @param target defines where the entity should look at
         * @param up defines the up vector for the entity
         * @returns the new matrix
         */
        static LookAtRH(eye: DeepImmutable<Vector3>, target: DeepImmutable<Vector3>, up: DeepImmutable<Vector3>): Matrix;
        /**
         * Sets the given "result" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up".
         * This function works in right handed mode
         * @param eye defines the final position of the entity
         * @param target defines where the entity should look at
         * @param up defines the up vector for the entity
         * @param result defines the target matrix
         */
        static LookAtRHToRef(eye: DeepImmutable<Vector3>, target: DeepImmutable<Vector3>, up: DeepImmutable<Vector3>, result: Matrix): void;
        /**
         * Create a left-handed orthographic projection matrix
         * @param width defines the viewport width
         * @param height defines the viewport height
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @returns a new matrix as a left-handed orthographic projection matrix
         */
        static OrthoLH(width: number, height: number, znear: number, zfar: number): Matrix;
        /**
         * Store a left-handed orthographic projection to a given matrix
         * @param width defines the viewport width
         * @param height defines the viewport height
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @param result defines the target matrix
         */
        static OrthoLHToRef(width: number, height: number, znear: number, zfar: number, result: Matrix): void;
        /**
         * Create a left-handed orthographic projection matrix
         * @param left defines the viewport left coordinate
         * @param right defines the viewport right coordinate
         * @param bottom defines the viewport bottom coordinate
         * @param top defines the viewport top coordinate
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @returns a new matrix as a left-handed orthographic projection matrix
         */
        static OrthoOffCenterLH(left: number, right: number, bottom: number, top: number, znear: number, zfar: number): Matrix;
        /**
         * Stores a left-handed orthographic projection into a given matrix
         * @param left defines the viewport left coordinate
         * @param right defines the viewport right coordinate
         * @param bottom defines the viewport bottom coordinate
         * @param top defines the viewport top coordinate
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @param result defines the target matrix
         */
        static OrthoOffCenterLHToRef(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, result: Matrix): void;
        /**
         * Creates a right-handed orthographic projection matrix
         * @param left defines the viewport left coordinate
         * @param right defines the viewport right coordinate
         * @param bottom defines the viewport bottom coordinate
         * @param top defines the viewport top coordinate
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @returns a new matrix as a right-handed orthographic projection matrix
         */
        static OrthoOffCenterRH(left: number, right: number, bottom: number, top: number, znear: number, zfar: number): Matrix;
        /**
         * Stores a right-handed orthographic projection into a given matrix
         * @param left defines the viewport left coordinate
         * @param right defines the viewport right coordinate
         * @param bottom defines the viewport bottom coordinate
         * @param top defines the viewport top coordinate
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @param result defines the target matrix
         */
        static OrthoOffCenterRHToRef(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, result: Matrix): void;
        /**
         * Creates a left-handed perspective projection matrix
         * @param width defines the viewport width
         * @param height defines the viewport height
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @returns a new matrix as a left-handed perspective projection matrix
         */
        static PerspectiveLH(width: number, height: number, znear: number, zfar: number): Matrix;
        /**
         * Creates a left-handed perspective projection matrix
         * @param fov defines the horizontal field of view
         * @param aspect defines the aspect ratio
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @returns a new matrix as a left-handed perspective projection matrix
         */
        static PerspectiveFovLH(fov: number, aspect: number, znear: number, zfar: number): Matrix;
        /**
         * Stores a left-handed perspective projection into a given matrix
         * @param fov defines the horizontal field of view
         * @param aspect defines the aspect ratio
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @param result defines the target matrix
         * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally
         */
        static PerspectiveFovLHToRef(fov: number, aspect: number, znear: number, zfar: number, result: Matrix, isVerticalFovFixed?: boolean): void;
        /**
         * Stores a left-handed perspective projection into a given matrix with depth reversed
         * @param fov defines the horizontal field of view
         * @param aspect defines the aspect ratio
         * @param znear defines the near clip plane
         * @param zfar not used as infinity is used as far clip
         * @param result defines the target matrix
         * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally
         */
        static PerspectiveFovReverseLHToRef(fov: number, aspect: number, znear: number, zfar: number, result: Matrix, isVerticalFovFixed?: boolean): void;
        /**
         * Creates a right-handed perspective projection matrix
         * @param fov defines the horizontal field of view
         * @param aspect defines the aspect ratio
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @returns a new matrix as a right-handed perspective projection matrix
         */
        static PerspectiveFovRH(fov: number, aspect: number, znear: number, zfar: number): Matrix;
        /**
         * Stores a right-handed perspective projection into a given matrix
         * @param fov defines the horizontal field of view
         * @param aspect defines the aspect ratio
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @param result defines the target matrix
         * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally
         */
        static PerspectiveFovRHToRef(fov: number, aspect: number, znear: number, zfar: number, result: Matrix, isVerticalFovFixed?: boolean): void;
        /**
         * Stores a right-handed perspective projection into a given matrix
         * @param fov defines the horizontal field of view
         * @param aspect defines the aspect ratio
         * @param znear defines the near clip plane
         * @param zfar not used as infinity is used as far clip
         * @param result defines the target matrix
         * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally
         */
        static PerspectiveFovReverseRHToRef(fov: number, aspect: number, znear: number, zfar: number, result: Matrix, isVerticalFovFixed?: boolean): void;
        /**
         * Stores a perspective projection for WebVR info a given matrix
         * @param fov defines the field of view
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @param result defines the target matrix
         * @param rightHanded defines if the matrix must be in right-handed mode (false by default)
         */
        static PerspectiveFovWebVRToRef(fov: {
            upDegrees: number;
            downDegrees: number;
            leftDegrees: number;
            rightDegrees: number;
        }, znear: number, zfar: number, result: Matrix, rightHanded?: boolean): void;
        /**
         * Computes a complete transformation matrix
         * @param viewport defines the viewport to use
         * @param world defines the world matrix
         * @param view defines the view matrix
         * @param projection defines the projection matrix
         * @param zmin defines the near clip plane
         * @param zmax defines the far clip plane
         * @returns the transformation matrix
         */
        static GetFinalMatrix(viewport: DeepImmutable<Viewport>, world: DeepImmutable<Matrix>, view: DeepImmutable<Matrix>, projection: DeepImmutable<Matrix>, zmin: number, zmax: number): Matrix;
        /**
         * Extracts a 2x2 matrix from a given matrix and store the result in a Float32Array
         * @param matrix defines the matrix to use
         * @returns a new Float32Array array with 4 elements : the 2x2 matrix extracted from the given matrix
         */
        static GetAsMatrix2x2(matrix: DeepImmutable<Matrix>): Float32Array | Array<number>;
        /**
         * Extracts a 3x3 matrix from a given matrix and store the result in a Float32Array
         * @param matrix defines the matrix to use
         * @returns a new Float32Array array with 9 elements : the 3x3 matrix extracted from the given matrix
         */
        static GetAsMatrix3x3(matrix: DeepImmutable<Matrix>): Float32Array | Array<number>;
        /**
         * Compute the transpose of a given matrix
         * @param matrix defines the matrix to transpose
         * @returns the new matrix
         */
        static Transpose(matrix: DeepImmutable<Matrix>): Matrix;
        /**
         * Compute the transpose of a matrix and store it in a target matrix
         * @param matrix defines the matrix to transpose
         * @param result defines the target matrix
         */
        static TransposeToRef(matrix: DeepImmutable<Matrix>, result: Matrix): void;
        /**
         * Computes a reflection matrix from a plane
         * @param plane defines the reflection plane
         * @returns a new matrix
         */
        static Reflection(plane: DeepImmutable<IPlaneLike>): Matrix;
        /**
         * Computes a reflection matrix from a plane
         * @param plane defines the reflection plane
         * @param result defines the target matrix
         */
        static ReflectionToRef(plane: DeepImmutable<IPlaneLike>, result: Matrix): void;
        /**
         * Sets the given matrix as a rotation matrix composed from the 3 left handed axes
         * @param xaxis defines the value of the 1st axis
         * @param yaxis defines the value of the 2nd axis
         * @param zaxis defines the value of the 3rd axis
         * @param result defines the target matrix
         */
        static FromXYZAxesToRef(xaxis: DeepImmutable<Vector3>, yaxis: DeepImmutable<Vector3>, zaxis: DeepImmutable<Vector3>, result: Matrix): void;
        /**
         * Creates a rotation matrix from a quaternion and stores it in a target matrix
         * @param quat defines the quaternion to use
         * @param result defines the target matrix
         */
        static FromQuaternionToRef(quat: DeepImmutable<Quaternion>, result: Matrix): void;
    }
    /**
     * @hidden
     */
    export class TmpVectors {
        static Vector2: Vector2[];
        static Vector3: Vector3[];
        static Vector4: Vector4[];
        static Quaternion: Quaternion[];
        static Matrix: Matrix[];
    }
}
declare module BABYLON {
    /**
     * Defines potential orientation for back face culling
     */
    export enum Orientation {
        /**
         * Clockwise
         */
        CW = 0,
        /** Counter clockwise */
        CCW = 1
    }
    /** Class used to represent a Bezier curve */
    export class BezierCurve {
        /**
         * Returns the cubic Bezier interpolated value (float) at "t" (float) from the given x1, y1, x2, y2 floats
         * @param t defines the time
         * @param x1 defines the left coordinate on X axis
         * @param y1 defines the left coordinate on Y axis
         * @param x2 defines the right coordinate on X axis
         * @param y2 defines the right coordinate on Y axis
         * @returns the interpolated value
         */
        static Interpolate(t: number, x1: number, y1: number, x2: number, y2: number): number;
    }
    /**
     * Defines angle representation
     */
    export class Angle {
        private _radians;
        /**
         * Creates an Angle object of "radians" radians (float).
         * @param radians the angle in radians
         */
        constructor(radians: number);
        /**
         * Get value in degrees
         * @returns the Angle value in degrees (float)
         */
        degrees(): number;
        /**
         * Get value in radians
         * @returns the Angle value in radians (float)
         */
        radians(): number;
        /**
         * Gets a new Angle object valued with the gradient angle, in radians, of the line joining two points
         * @param a defines first point as the origin
         * @param b defines point
         * @returns a new Angle
         */
        static BetweenTwoPoints(a: DeepImmutable<Vector2>, b: DeepImmutable<Vector2>): Angle;
        /**
         * Gets a new Angle object from the given float in radians
         * @param radians defines the angle value in radians
         * @returns a new Angle
         */
        static FromRadians(radians: number): Angle;
        /**
         * Gets a new Angle object from the given float in degrees
         * @param degrees defines the angle value in degrees
         * @returns a new Angle
         */
        static FromDegrees(degrees: number): Angle;
    }
    /**
     * This represents an arc in a 2d space.
     */
    export class Arc2 {
        /** Defines the start point of the arc */
        startPoint: Vector2;
        /** Defines the mid point of the arc */
        midPoint: Vector2;
        /** Defines the end point of the arc */
        endPoint: Vector2;
        /**
         * Defines the center point of the arc.
         */
        centerPoint: Vector2;
        /**
         * Defines the radius of the arc.
         */
        radius: number;
        /**
         * Defines the angle of the arc (from mid point to end point).
         */
        angle: Angle;
        /**
         * Defines the start angle of the arc (from start point to middle point).
         */
        startAngle: Angle;
        /**
         * Defines the orientation of the arc (clock wise/counter clock wise).
         */
        orientation: Orientation;
        /**
         * Creates an Arc object from the three given points : start, middle and end.
         * @param startPoint Defines the start point of the arc
         * @param midPoint Defines the midlle point of the arc
         * @param endPoint Defines the end point of the arc
         */
        constructor(
        /** Defines the start point of the arc */
        startPoint: Vector2, 
        /** Defines the mid point of the arc */
        midPoint: Vector2, 
        /** Defines the end point of the arc */
        endPoint: Vector2);
    }
    /**
     * Represents a 2D path made up of multiple 2D points
     */
    export class Path2 {
        private _points;
        private _length;
        /**
         * If the path start and end point are the same
         */
        closed: boolean;
        /**
         * Creates a Path2 object from the starting 2D coordinates x and y.
         * @param x the starting points x value
         * @param y the starting points y value
         */
        constructor(x: number, y: number);
        /**
         * Adds a new segment until the given coordinates (x, y) to the current Path2.
         * @param x the added points x value
         * @param y the added points y value
         * @returns the updated Path2.
         */
        addLineTo(x: number, y: number): Path2;
        /**
         * Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.
         * @param midX middle point x value
         * @param midY middle point y value
         * @param endX end point x value
         * @param endY end point y value
         * @param numberOfSegments (default: 36)
         * @returns the updated Path2.
         */
        addArcTo(midX: number, midY: number, endX: number, endY: number, numberOfSegments?: number): Path2;
        /**
         * Closes the Path2.
         * @returns the Path2.
         */
        close(): Path2;
        /**
         * Gets the sum of the distance between each sequential point in the path
         * @returns the Path2 total length (float).
         */
        length(): number;
        /**
         * Gets the points which construct the path
         * @returns the Path2 internal array of points.
         */
        getPoints(): Vector2[];
        /**
         * Retreives the point at the distance aways from the starting point
         * @param normalizedLengthPosition the length along the path to retreive the point from
         * @returns a new Vector2 located at a percentage of the Path2 total length on this path.
         */
        getPointAtLengthPosition(normalizedLengthPosition: number): Vector2;
        /**
         * Creates a new path starting from an x and y position
         * @param x starting x value
         * @param y starting y value
         * @returns a new Path2 starting at the coordinates (x, y).
         */
        static StartingAt(x: number, y: number): Path2;
    }
    /**
     * Represents a 3D path made up of multiple 3D points
     */
    export class Path3D {
        /**
         * an array of Vector3, the curve axis of the Path3D
         */
        path: Vector3[];
        private _curve;
        private _distances;
        private _tangents;
        private _normals;
        private _binormals;
        private _raw;
        private _alignTangentsWithPath;
        private readonly _pointAtData;
        /**
        * new Path3D(path, normal, raw)
        * Creates a Path3D. A Path3D is a logical math object, so not a mesh.
        * please read the description in the tutorial : https://doc.babylonjs.com/how_to/how_to_use_path3d
        * @param path an array of Vector3, the curve axis of the Path3D
        * @param firstNormal (options) Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.
        * @param raw (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.
        * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path.
        */
        constructor(
        /**
         * an array of Vector3, the curve axis of the Path3D
         */
        path: Vector3[], firstNormal?: Nullable<Vector3>, raw?: boolean, alignTangentsWithPath?: boolean);
        /**
         * Returns the Path3D array of successive Vector3 designing its curve.
         * @returns the Path3D array of successive Vector3 designing its curve.
         */
        getCurve(): Vector3[];
        /**
         * Returns the Path3D array of successive Vector3 designing its curve.
         * @returns the Path3D array of successive Vector3 designing its curve.
         */
        getPoints(): Vector3[];
        /**
         * @returns the computed length (float) of the path.
         */
        length(): number;
        /**
         * Returns an array populated with tangent vectors on each Path3D curve point.
         * @returns an array populated with tangent vectors on each Path3D curve point.
         */
        getTangents(): Vector3[];
        /**
         * Returns an array populated with normal vectors on each Path3D curve point.
         * @returns an array populated with normal vectors on each Path3D curve point.
         */
        getNormals(): Vector3[];
        /**
         * Returns an array populated with binormal vectors on each Path3D curve point.
         * @returns an array populated with binormal vectors on each Path3D curve point.
         */
        getBinormals(): Vector3[];
        /**
         * Returns an array populated with distances (float) of the i-th point from the first curve point.
         * @returns an array populated with distances (float) of the i-th point from the first curve point.
         */
        getDistances(): number[];
        /**
         * Returns an interpolated point along this path
         * @param position the position of the point along this path, from 0.0 to 1.0
         * @returns a new Vector3 as the point
         */
        getPointAt(position: number): Vector3;
        /**
         * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.
         * @param position the position of the point along this path, from 0.0 to 1.0
         * @param interpolated (optional, default false) : boolean, if true returns an interpolated tangent instead of the tangent of the previous path point.
         * @returns a tangent vector corresponding to the interpolated Path3D curve point, if not interpolated, the tangent is taken from the precomputed tangents array.
         */
        getTangentAt(position: number, interpolated?: boolean): Vector3;
        /**
         * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.
         * @param position the position of the point along this path, from 0.0 to 1.0
         * @param interpolated (optional, default false) : boolean, if true returns an interpolated normal instead of the normal of the previous path point.
         * @returns a normal vector corresponding to the interpolated Path3D curve point, if not interpolated, the normal is taken from the precomputed normals array.
         */
        getNormalAt(position: number, interpolated?: boolean): Vector3;
        /**
         * Returns the binormal vector of an interpolated Path3D curve point at the specified position along this path.
         * @param position the position of the point along this path, from 0.0 to 1.0
         * @param interpolated (optional, default false) : boolean, if true returns an interpolated binormal instead of the binormal of the previous path point.
         * @returns a binormal vector corresponding to the interpolated Path3D curve point, if not interpolated, the binormal is taken from the precomputed binormals array.
         */
        getBinormalAt(position: number, interpolated?: boolean): Vector3;
        /**
         * Returns the distance (float) of an interpolated Path3D curve point at the specified position along this path.
         * @param position the position of the point along this path, from 0.0 to 1.0
         * @returns the distance of the interpolated Path3D curve point at the specified position along this path.
         */
        getDistanceAt(position: number): number;
        /**
         * Returns the array index of the previous point of an interpolated point along this path
         * @param position the position of the point to interpolate along this path, from 0.0 to 1.0
         * @returns the array index
         */
        getPreviousPointIndexAt(position: number): number;
        /**
         * Returns the position of an interpolated point relative to the two path points it lies between, from 0.0 (point A) to 1.0 (point B)
         * @param position the position of the point to interpolate along this path, from 0.0 to 1.0
         * @returns the sub position
         */
        getSubPositionAt(position: number): number;
        /**
         * Returns the position of the closest virtual point on this path to an arbitrary Vector3, from 0.0 to 1.0
         * @param target the vector of which to get the closest position to
         * @returns the position of the closest virtual point on this path to the target vector
         */
        getClosestPositionTo(target: Vector3): number;
        /**
         * Returns a sub path (slice) of this path
         * @param start the position of the fist path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values
         * @param end the position of the last path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values
         * @returns a sub path (slice) of this path
         */
        slice(start?: number, end?: number): Path3D;
        /**
         * Forces the Path3D tangent, normal, binormal and distance recomputation.
         * @param path path which all values are copied into the curves points
         * @param firstNormal which should be projected onto the curve
         * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path
         * @returns the same object updated.
         */
        update(path: Vector3[], firstNormal?: Nullable<Vector3>, alignTangentsWithPath?: boolean): Path3D;
        private _compute;
        private _getFirstNonNullVector;
        private _getLastNonNullVector;
        private _normalVector;
        /**
         * Updates the point at data for an interpolated point along this curve
         * @param position the position of the point along this curve, from 0.0 to 1.0
         * @interpolateTNB wether to compute the interpolated tangent, normal and binormal
         * @returns the (updated) point at data
         */
        private _updatePointAtData;
        /**
         * Updates the point at data from the specified parameters
         * @param position where along the path the interpolated point is, from 0.0 to 1.0
         * @param point the interpolated point
         * @param parentIndex the index of an existing curve point that is on, or else positionally the first behind, the interpolated point
         */
        private _setPointAtData;
        /**
         * Updates the point at interpolation matrix for the tangents, normals and binormals
         */
        private _updateInterpolationMatrix;
    }
    /**
     * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.
     * A Curve3 is designed from a series of successive Vector3.
     * @see https://doc.babylonjs.com/how_to/how_to_use_curve3
     */
    export class Curve3 {
        private _points;
        private _length;
        /**
         * Returns a Curve3 object along a Quadratic Bezier curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#quadratic-bezier-curve
         * @param v0 (Vector3) the origin point of the Quadratic Bezier
         * @param v1 (Vector3) the control point
         * @param v2 (Vector3) the end point of the Quadratic Bezier
         * @param nbPoints (integer) the wanted number of points in the curve
         * @returns the created Curve3
         */
        static CreateQuadraticBezier(v0: DeepImmutable<Vector3>, v1: DeepImmutable<Vector3>, v2: DeepImmutable<Vector3>, nbPoints: number): Curve3;
        /**
         * Returns a Curve3 object along a Cubic Bezier curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#cubic-bezier-curve
         * @param v0 (Vector3) the origin point of the Cubic Bezier
         * @param v1 (Vector3) the first control point
         * @param v2 (Vector3) the second control point
         * @param v3 (Vector3) the end point of the Cubic Bezier
         * @param nbPoints (integer) the wanted number of points in the curve
         * @returns the created Curve3
         */
        static CreateCubicBezier(v0: DeepImmutable<Vector3>, v1: DeepImmutable<Vector3>, v2: DeepImmutable<Vector3>, v3: DeepImmutable<Vector3>, nbPoints: number): Curve3;
        /**
         * Returns a Curve3 object along a Hermite Spline curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#hermite-spline
         * @param p1 (Vector3) the origin point of the Hermite Spline
         * @param t1 (Vector3) the tangent vector at the origin point
         * @param p2 (Vector3) the end point of the Hermite Spline
         * @param t2 (Vector3) the tangent vector at the end point
         * @param nbPoints (integer) the wanted number of points in the curve
         * @returns the created Curve3
         */
        static CreateHermiteSpline(p1: DeepImmutable<Vector3>, t1: DeepImmutable<Vector3>, p2: DeepImmutable<Vector3>, t2: DeepImmutable<Vector3>, nbPoints: number): Curve3;
        /**
         * Returns a Curve3 object along a CatmullRom Spline curve :
         * @param points (array of Vector3) the points the spline must pass through. At least, four points required
         * @param nbPoints (integer) the wanted number of points between each curve control points
         * @param closed (boolean) optional with default false, when true forms a closed loop from the points
         * @returns the created Curve3
         */
        static CreateCatmullRomSpline(points: DeepImmutable<Vector3[]>, nbPoints: number, closed?: boolean): Curve3;
        /**
         * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.
         * A Curve3 is designed from a series of successive Vector3.
         * Tuto : https://doc.babylonjs.com/how_to/how_to_use_curve3#curve3-object
         * @param points points which make up the curve
         */
        constructor(points: Vector3[]);
        /**
         * @returns the Curve3 stored array of successive Vector3
         */
        getPoints(): Vector3[];
        /**
         * @returns the computed length (float) of the curve.
         */
        length(): number;
        /**
         * Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);
         * This new Curve3 is built by translating and sticking the curveB at the end of the curveA.
         * curveA and curveB keep unchanged.
         * @param curve the curve to continue from this curve
         * @returns the newly constructed curve
         */
        continue(curve: DeepImmutable<Curve3>): Curve3;
        private _computeLength;
    }
}
declare module BABYLON {
    /**
     * This represents the main contract an easing function should follow.
     * Easing functions are used throughout the animation system.
     * @see https://doc.babylonjs.com/babylon101/animations#easing-functions
     */
    export interface IEasingFunction {
        /**
         * Given an input gradient between 0 and 1, this returns the corrseponding value
         * of the easing function.
         * The link below provides some of the most common examples of easing functions.
         * @see https://easings.net/
         * @param gradient Defines the value between 0 and 1 we want the easing value for
         * @returns the corresponding value on the curve defined by the easing function
         */
        ease(gradient: number): number;
    }
    /**
     * Base class used for every default easing function.
     * @see https://doc.babylonjs.com/babylon101/animations#easing-functions
     */
    export class EasingFunction implements IEasingFunction {
        /**
         * Interpolation follows the mathematical formula associated with the easing function.
         */
        static readonly EASINGMODE_EASEIN: number;
        /**
         * Interpolation follows 100% interpolation minus the output of the formula associated with the easing function.
         */
        static readonly EASINGMODE_EASEOUT: number;
        /**
         * Interpolation uses EaseIn for the first half of the animation and EaseOut for the second half.
         */
        static readonly EASINGMODE_EASEINOUT: number;
        private _easingMode;
        /**
         * Sets the easing mode of the current function.
         * @param easingMode Defines the willing mode (EASINGMODE_EASEIN, EASINGMODE_EASEOUT or EASINGMODE_EASEINOUT)
         */
        setEasingMode(easingMode: number): void;
        /**
         * Gets the current easing mode.
         * @returns the easing mode
         */
        getEasingMode(): number;
        /**
         * @hidden
         */
        easeInCore(gradient: number): number;
        /**
         * Given an input gradient between 0 and 1, this returns the corresponding value
         * of the easing function.
         * @param gradient Defines the value between 0 and 1 we want the easing value for
         * @returns the corresponding value on the curve defined by the easing function
         */
        ease(gradient: number): number;
    }
    /**
     * Easing function with a circle shape (see link below).
     * @see https://easings.net/#easeInCirc
     * @see https://doc.babylonjs.com/babylon101/animations#easing-functions
     */
    export class CircleEase extends EasingFunction implements IEasingFunction {
        /** @hidden */
        easeInCore(gradient: number): number;
    }
    /**
     * Easing function with a ease back shape (see link below).
     * @see https://easings.net/#easeInBack
     * @see https://doc.babylonjs.com/babylon101/animations#easing-functions
     */
    export class BackEase extends EasingFunction implements IEasingFunction {
        /** Defines the amplitude of the function */
        amplitude: number;
        /**
         * Instantiates a back ease easing
         * @see https://easings.net/#easeInBack
         * @param amplitude Defines the amplitude of the function
         */
        constructor(
        /** Defines the amplitude of the function */
        amplitude?: number);
        /** @hidden */
        easeInCore(gradient: number): number;
    }
    /**
     * Easing function with a bouncing shape (see link below).
     * @see https://easings.net/#easeInBounce
     * @see https://doc.babylonjs.com/babylon101/animations#easing-functions
     */
    export class BounceEase extends EasingFunction implements IEasingFunction {
        /** Defines the number of bounces */
        bounces: number;
        /** Defines the amplitude of the bounce */
        bounciness: number;
        /**
         * Instantiates a bounce easing
         * @see https://easings.net/#easeInBounce
         * @param bounces Defines the number of bounces
         * @param bounciness Defines the amplitude of the bounce
         */
        constructor(
        /** Defines the number of bounces */
        bounces?: number, 
        /** Defines the amplitude of the bounce */
        bounciness?: number);
        /** @hidden */
        easeInCore(gradient: number): number;
    }
    /**
     * Easing function with a power of 3 shape (see link below).
     * @see https://easings.net/#easeInCubic
     * @see https://doc.babylonjs.com/babylon101/animations#easing-functions
     */
    export class CubicEase extends EasingFunction implements IEasingFunction {
        /** @hidden */
        easeInCore(gradient: number): number;
    }
    /**
     * Easing function with an elastic shape (see link below).
     * @see https://easings.net/#easeInElastic
     * @see https://doc.babylonjs.com/babylon101/animations#easing-functions
     */
    export class ElasticEase extends EasingFunction implements IEasingFunction {
        /** Defines the number of oscillations*/
        oscillations: number;
        /** Defines the amplitude of the oscillations*/
        springiness: number;
        /**
         * Instantiates an elastic easing function
         * @see https://easings.net/#easeInElastic
         * @param oscillations Defines the number of oscillations
         * @param springiness Defines the amplitude of the oscillations
         */
        constructor(
        /** Defines the number of oscillations*/
        oscillations?: number, 
        /** Defines the amplitude of the oscillations*/
        springiness?: number);
        /** @hidden */
        easeInCore(gradient: number): number;
    }
    /**
     * Easing function with an exponential shape (see link below).
     * @see https://easings.net/#easeInExpo
     * @see https://doc.babylonjs.com/babylon101/animations#easing-functions
     */
    export class ExponentialEase extends EasingFunction implements IEasingFunction {
        /** Defines the exponent of the function */
        exponent: number;
        /**
         * Instantiates an exponential easing function
         * @see https://easings.net/#easeInExpo
         * @param exponent Defines the exponent of the function
         */
        constructor(
        /** Defines the exponent of the function */
        exponent?: number);
        /** @hidden */
        easeInCore(gradient: number): number;
    }
    /**
     * Easing function with a power shape (see link below).
     * @see https://easings.net/#easeInQuad
     * @see https://doc.babylonjs.com/babylon101/animations#easing-functions
     */
    export class PowerEase extends EasingFunction implements IEasingFunction {
        /** Defines the power of the function */
        power: number;
        /**
         * Instantiates an power base easing function
         * @see https://easings.net/#easeInQuad
         * @param power Defines the power of the function
         */
        constructor(
        /** Defines the power of the function */
        power?: number);
        /** @hidden */
        easeInCore(gradient: number): number;
    }
    /**
     * Easing function with a power of 2 shape (see link below).
     * @see https://easings.net/#easeInQuad
     * @see https://doc.babylonjs.com/babylon101/animations#easing-functions
     */
    export class QuadraticEase extends EasingFunction implements IEasingFunction {
        /** @hidden */
        easeInCore(gradient: number): number;
    }
    /**
     * Easing function with a power of 4 shape (see link below).
     * @see https://easings.net/#easeInQuart
     * @see https://doc.babylonjs.com/babylon101/animations#easing-functions
     */
    export class QuarticEase extends EasingFunction implements IEasingFunction {
        /** @hidden */
        easeInCore(gradient: number): number;
    }
    /**
     * Easing function with a power of 5 shape (see link below).
     * @see https://easings.net/#easeInQuint
     * @see https://doc.babylonjs.com/babylon101/animations#easing-functions
     */
    export class QuinticEase extends EasingFunction implements IEasingFunction {
        /** @hidden */
        easeInCore(gradient: number): number;
    }
    /**
     * Easing function with a sin shape (see link below).
     * @see https://easings.net/#easeInSine
     * @see https://doc.babylonjs.com/babylon101/animations#easing-functions
     */
    export class SineEase extends EasingFunction implements IEasingFunction {
        /** @hidden */
        easeInCore(gradient: number): number;
    }
    /**
     * Easing function with a bezier shape (see link below).
     * @see http://cubic-bezier.com/#.17,.67,.83,.67
     * @see https://doc.babylonjs.com/babylon101/animations#easing-functions
     */
    export class BezierCurveEase extends EasingFunction implements IEasingFunction {
        /** Defines the x component of the start tangent in the bezier curve */
        x1: number;
        /** Defines the y component of the start tangent in the bezier curve */
        y1: number;
        /** Defines the x component of the end tangent in the bezier curve */
        x2: number;
        /** Defines the y component of the end tangent in the bezier curve */
        y2: number;
        /**
         * Instantiates a bezier function
         * @see http://cubic-bezier.com/#.17,.67,.83,.67
         * @param x1 Defines the x component of the start tangent in the bezier curve
         * @param y1 Defines the y component of the start tangent in the bezier curve
         * @param x2 Defines the x component of the end tangent in the bezier curve
         * @param y2 Defines the y component of the end tangent in the bezier curve
         */
        constructor(
        /** Defines the x component of the start tangent in the bezier curve */
        x1?: number, 
        /** Defines the y component of the start tangent in the bezier curve */
        y1?: number, 
        /** Defines the x component of the end tangent in the bezier curve */
        x2?: number, 
        /** Defines the y component of the end tangent in the bezier curve */
        y2?: number);
        /** @hidden */
        easeInCore(gradient: number): number;
    }
}
declare module BABYLON {
    /**
     * Class used to hold a RBG color
     */
    export class Color3 {
        /**
         * Defines the red component (between 0 and 1, default is 0)
         */
        r: number;
        /**
         * Defines the green component (between 0 and 1, default is 0)
         */
        g: number;
        /**
         * Defines the blue component (between 0 and 1, default is 0)
         */
        b: number;
        /**
         * Creates a new Color3 object from red, green, blue values, all between 0 and 1
         * @param r defines the red component (between 0 and 1, default is 0)
         * @param g defines the green component (between 0 and 1, default is 0)
         * @param b defines the blue component (between 0 and 1, default is 0)
         */
        constructor(
        /**
         * Defines the red component (between 0 and 1, default is 0)
         */
        r?: number, 
        /**
         * Defines the green component (between 0 and 1, default is 0)
         */
        g?: number, 
        /**
         * Defines the blue component (between 0 and 1, default is 0)
         */
        b?: number);
        /**
         * Creates a string with the Color3 current values
         * @returns the string representation of the Color3 object
         */
        toString(): string;
        /**
         * Returns the string "Color3"
         * @returns "Color3"
         */
        getClassName(): string;
        /**
         * Compute the Color3 hash code
         * @returns an unique number that can be used to hash Color3 objects
         */
        getHashCode(): number;
        /**
         * Stores in the given array from the given starting index the red, green, blue values as successive elements
         * @param array defines the array where to store the r,g,b components
         * @param index defines an optional index in the target array to define where to start storing values
         * @returns the current Color3 object
         */
        toArray(array: FloatArray, index?: number): Color3;
        /**
         * Update the current color with values stored in an array from the starting index of the given array
         * @param array defines the source array
         * @param offset defines an offset in the source array
         * @returns the current Color3 object
         */
        fromArray(array: DeepImmutable<ArrayLike<number>>, offset?: number): Color3;
        /**
         * Returns a new Color4 object from the current Color3 and the given alpha
         * @param alpha defines the alpha component on the new Color4 object (default is 1)
         * @returns a new Color4 object
         */
        toColor4(alpha?: number): Color4;
        /**
         * Returns a new array populated with 3 numeric elements : red, green and blue values
         * @returns the new array
         */
        asArray(): number[];
        /**
         * Returns the luminance value
         * @returns a float value
         */
        toLuminance(): number;
        /**
         * Multiply each Color3 rgb values by the given Color3 rgb values in a new Color3 object
         * @param otherColor defines the second operand
         * @returns the new Color3 object
         */
        multiply(otherColor: DeepImmutable<Color3>): Color3;
        /**
         * Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object "result"
         * @param otherColor defines the second operand
         * @param result defines the Color3 object where to store the result
         * @returns the current Color3
         */
        multiplyToRef(otherColor: DeepImmutable<Color3>, result: Color3): Color3;
        /**
         * Determines equality between Color3 objects
         * @param otherColor defines the second operand
         * @returns true if the rgb values are equal to the given ones
         */
        equals(otherColor: DeepImmutable<Color3>): boolean;
        /**
         * Determines equality between the current Color3 object and a set of r,b,g values
         * @param r defines the red component to check
         * @param g defines the green component to check
         * @param b defines the blue component to check
         * @returns true if the rgb values are equal to the given ones
         */
        equalsFloats(r: number, g: number, b: number): boolean;
        /**
         * Multiplies in place each rgb value by scale
         * @param scale defines the scaling factor
         * @returns the updated Color3
         */
        scale(scale: number): Color3;
        /**
         * Multiplies the rgb values by scale and stores the result into "result"
         * @param scale defines the scaling factor
         * @param result defines the Color3 object where to store the result
         * @returns the unmodified current Color3
         */
        scaleToRef(scale: number, result: Color3): Color3;
        /**
         * Scale the current Color3 values by a factor and add the result to a given Color3
         * @param scale defines the scale factor
         * @param result defines color to store the result into
         * @returns the unmodified current Color3
         */
        scaleAndAddToRef(scale: number, result: Color3): Color3;
        /**
         * Clamps the rgb values by the min and max values and stores the result into "result"
         * @param min defines minimum clamping value (default is 0)
         * @param max defines maximum clamping value (default is 1)
         * @param result defines color to store the result into
         * @returns the original Color3
         */
        clampToRef(min: number | undefined, max: number | undefined, result: Color3): Color3;
        /**
         * Creates a new Color3 set with the added values of the current Color3 and of the given one
         * @param otherColor defines the second operand
         * @returns the new Color3
         */
        add(otherColor: DeepImmutable<Color3>): Color3;
        /**
         * Stores the result of the addition of the current Color3 and given one rgb values into "result"
         * @param otherColor defines the second operand
         * @param result defines Color3 object to store the result into
         * @returns the unmodified current Color3
         */
        addToRef(otherColor: DeepImmutable<Color3>, result: Color3): Color3;
        /**
         * Returns a new Color3 set with the subtracted values of the given one from the current Color3
         * @param otherColor defines the second operand
         * @returns the new Color3
         */
        subtract(otherColor: DeepImmutable<Color3>): Color3;
        /**
         * Stores the result of the subtraction of given one from the current Color3 rgb values into "result"
         * @param otherColor defines the second operand
         * @param result defines Color3 object to store the result into
         * @returns the unmodified current Color3
         */
        subtractToRef(otherColor: DeepImmutable<Color3>, result: Color3): Color3;
        /**
         * Copy the current object
         * @returns a new Color3 copied the current one
         */
        clone(): Color3;
        /**
         * Copies the rgb values from the source in the current Color3
         * @param source defines the source Color3 object
         * @returns the updated Color3 object
         */
        copyFrom(source: DeepImmutable<Color3>): Color3;
        /**
         * Updates the Color3 rgb values from the given floats
         * @param r defines the red component to read from
         * @param g defines the green component to read from
         * @param b defines the blue component to read from
         * @returns the current Color3 object
         */
        copyFromFloats(r: number, g: number, b: number): Color3;
        /**
         * Updates the Color3 rgb values from the given floats
         * @param r defines the red component to read from
         * @param g defines the green component to read from
         * @param b defines the blue component to read from
         * @returns the current Color3 object
         */
        set(r: number, g: number, b: number): Color3;
        /**
         * Compute the Color3 hexadecimal code as a string
         * @returns a string containing the hexadecimal representation of the Color3 object
         */
        toHexString(): string;
        /**
         * Computes a new Color3 converted from the current one to linear space
         * @returns a new Color3 object
         */
        toLinearSpace(): Color3;
        /**
         * Converts current color in rgb space to HSV values
         * @returns a new color3 representing the HSV values
         */
        toHSV(): Color3;
        /**
         * Converts current color in rgb space to HSV values
         * @param result defines the Color3 where to store the HSV values
         */
        toHSVToRef(result: Color3): void;
        /**
         * Converts the Color3 values to linear space and stores the result in "convertedColor"
         * @param convertedColor defines the Color3 object where to store the linear space version
         * @returns the unmodified Color3
         */
        toLinearSpaceToRef(convertedColor: Color3): Color3;
        /**
         * Computes a new Color3 converted from the current one to gamma space
         * @returns a new Color3 object
         */
        toGammaSpace(): Color3;
        /**
         * Converts the Color3 values to gamma space and stores the result in "convertedColor"
         * @param convertedColor defines the Color3 object where to store the gamma space version
         * @returns the unmodified Color3
         */
        toGammaSpaceToRef(convertedColor: Color3): Color3;
        private static _BlackReadOnly;
        /**
         * Convert Hue, saturation and value to a Color3 (RGB)
         * @param hue defines the hue
         * @param saturation defines the saturation
         * @param value defines the value
         * @param result defines the Color3 where to store the RGB values
         */
        static HSVtoRGBToRef(hue: number, saturation: number, value: number, result: Color3): void;
        /**
         * Creates a new Color3 from the string containing valid hexadecimal values
         * @param hex defines a string containing valid hexadecimal values
         * @returns a new Color3 object
         */
        static FromHexString(hex: string): Color3;
        /**
         * Creates a new Color3 from the starting index of the given array
         * @param array defines the source array
         * @param offset defines an offset in the source array
         * @returns a new Color3 object
         */
        static FromArray(array: DeepImmutable<ArrayLike<number>>, offset?: number): Color3;
        /**
         * Creates a new Color3 from the starting index element of the given array
         * @param array defines the source array to read from
         * @param offset defines the offset in the source array
         * @param result defines the target Color3 object
         */
        static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number | undefined, result: Color3): void;
        /**
         * Creates a new Color3 from integer values (< 256)
         * @param r defines the red component to read from (value between 0 and 255)
         * @param g defines the green component to read from (value between 0 and 255)
         * @param b defines the blue component to read from (value between 0 and 255)
         * @returns a new Color3 object
         */
        static FromInts(r: number, g: number, b: number): Color3;
        /**
         * Creates a new Color3 with values linearly interpolated of "amount" between the start Color3 and the end Color3
         * @param start defines the start Color3 value
         * @param end defines the end Color3 value
         * @param amount defines the gradient value between start and end
         * @returns a new Color3 object
         */
        static Lerp(start: DeepImmutable<Color3>, end: DeepImmutable<Color3>, amount: number): Color3;
        /**
         * Creates a new Color3 with values linearly interpolated of "amount" between the start Color3 and the end Color3
         * @param left defines the start value
         * @param right defines the end value
         * @param amount defines the gradient factor
         * @param result defines the Color3 object where to store the result
         */
        static LerpToRef(left: DeepImmutable<Color3>, right: DeepImmutable<Color3>, amount: number, result: Color3): void;
        /**
         * Returns a Color3 value containing a red color
         * @returns a new Color3 object
         */
        static Red(): Color3;
        /**
         * Returns a Color3 value containing a green color
         * @returns a new Color3 object
         */
        static Green(): Color3;
        /**
         * Returns a Color3 value containing a blue color
         * @returns a new Color3 object
         */
        static Blue(): Color3;
        /**
         * Returns a Color3 value containing a black color
         * @returns a new Color3 object
         */
        static Black(): Color3;
        /**
          * Gets a Color3 value containing a black color that must not be updated
          */
        static get BlackReadOnly(): DeepImmutable<Color3>;
        /**
         * Returns a Color3 value containing a white color
         * @returns a new Color3 object
         */
        static White(): Color3;
        /**
         * Returns a Color3 value containing a purple color
         * @returns a new Color3 object
         */
        static Purple(): Color3;
        /**
         * Returns a Color3 value containing a magenta color
         * @returns a new Color3 object
         */
        static Magenta(): Color3;
        /**
         * Returns a Color3 value containing a yellow color
         * @returns a new Color3 object
         */
        static Yellow(): Color3;
        /**
         * Returns a Color3 value containing a gray color
         * @returns a new Color3 object
         */
        static Gray(): Color3;
        /**
         * Returns a Color3 value containing a teal color
         * @returns a new Color3 object
         */
        static Teal(): Color3;
        /**
         * Returns a Color3 value containing a random color
         * @returns a new Color3 object
         */
        static Random(): Color3;
    }
    /**
     * Class used to hold a RBGA color
     */
    export class Color4 {
        /**
         * Defines the red component (between 0 and 1, default is 0)
         */
        r: number;
        /**
         * Defines the green component (between 0 and 1, default is 0)
         */
        g: number;
        /**
         * Defines the blue component (between 0 and 1, default is 0)
         */
        b: number;
        /**
         * Defines the alpha component (between 0 and 1, default is 1)
         */
        a: number;
        /**
         * Creates a new Color4 object from red, green, blue values, all between 0 and 1
         * @param r defines the red component (between 0 and 1, default is 0)
         * @param g defines the green component (between 0 and 1, default is 0)
         * @param b defines the blue component (between 0 and 1, default is 0)
         * @param a defines the alpha component (between 0 and 1, default is 1)
         */
        constructor(
        /**
         * Defines the red component (between 0 and 1, default is 0)
         */
        r?: number, 
        /**
         * Defines the green component (between 0 and 1, default is 0)
         */
        g?: number, 
        /**
         * Defines the blue component (between 0 and 1, default is 0)
         */
        b?: number, 
        /**
         * Defines the alpha component (between 0 and 1, default is 1)
         */
        a?: number);
        /**
         * Adds in place the given Color4 values to the current Color4 object
         * @param right defines the second operand
         * @returns the current updated Color4 object
         */
        addInPlace(right: DeepImmutable<Color4>): Color4;
        /**
         * Creates a new array populated with 4 numeric elements : red, green, blue, alpha values
         * @returns the new array
         */
        asArray(): number[];
        /**
         * Stores from the starting index in the given array the Color4 successive values
         * @param array defines the array where to store the r,g,b components
         * @param index defines an optional index in the target array to define where to start storing values
         * @returns the current Color4 object
         */
        toArray(array: number[], index?: number): Color4;
        /**
         * Update the current color with values stored in an array from the starting index of the given array
         * @param array defines the source array
         * @param offset defines an offset in the source array
         * @returns the current Color4 object
         */
        fromArray(array: DeepImmutable<ArrayLike<number>>, offset?: number): Color4;
        /**
         * Determines equality between Color4 objects
         * @param otherColor defines the second operand
         * @returns true if the rgba values are equal to the given ones
         */
        equals(otherColor: DeepImmutable<Color4>): boolean;
        /**
         * Creates a new Color4 set with the added values of the current Color4 and of the given one
         * @param right defines the second operand
         * @returns a new Color4 object
         */
        add(right: DeepImmutable<Color4>): Color4;
        /**
         * Creates a new Color4 set with the subtracted values of the given one from the current Color4
         * @param right defines the second operand
         * @returns a new Color4 object
         */
        subtract(right: DeepImmutable<Color4>): Color4;
        /**
         * Subtracts the given ones from the current Color4 values and stores the results in "result"
         * @param right defines the second operand
         * @param result defines the Color4 object where to store the result
         * @returns the current Color4 object
         */
        subtractToRef(right: DeepImmutable<Color4>, result: Color4): Color4;
        /**
         * Creates a new Color4 with the current Color4 values multiplied by scale
         * @param scale defines the scaling factor to apply
         * @returns a new Color4 object
         */
        scale(scale: number): Color4;
        /**
         * Multiplies the current Color4 values by scale and stores the result in "result"
         * @param scale defines the scaling factor to apply
         * @param result defines the Color4 object where to store the result
         * @returns the current unmodified Color4
         */
        scaleToRef(scale: number, result: Color4): Color4;
        /**
         * Scale the current Color4 values by a factor and add the result to a given Color4
         * @param scale defines the scale factor
         * @param result defines the Color4 object where to store the result
         * @returns the unmodified current Color4
         */
        scaleAndAddToRef(scale: number, result: Color4): Color4;
        /**
         * Clamps the rgb values by the min and max values and stores the result into "result"
         * @param min defines minimum clamping value (default is 0)
         * @param max defines maximum clamping value (default is 1)
         * @param result defines color to store the result into.
         * @returns the cuurent Color4
         */
        clampToRef(min: number | undefined, max: number | undefined, result: Color4): Color4;
        /**
          * Multipy an Color4 value by another and return a new Color4 object
          * @param color defines the Color4 value to multiply by
          * @returns a new Color4 object
          */
        multiply(color: Color4): Color4;
        /**
         * Multipy a Color4 value by another and push the result in a reference value
         * @param color defines the Color4 value to multiply by
         * @param result defines the Color4 to fill the result in
         * @returns the result Color4
         */
        multiplyToRef(color: Color4, result: Color4): Color4;
        /**
         * Creates a string with the Color4 current values
         * @returns the string representation of the Color4 object
         */
        toString(): string;
        /**
         * Returns the string "Color4"
         * @returns "Color4"
         */
        getClassName(): string;
        /**
         * Compute the Color4 hash code
         * @returns an unique number that can be used to hash Color4 objects
         */
        getHashCode(): number;
        /**
         * Creates a new Color4 copied from the current one
         * @returns a new Color4 object
         */
        clone(): Color4;
        /**
         * Copies the given Color4 values into the current one
         * @param source defines the source Color4 object
         * @returns the current updated Color4 object
         */
        copyFrom(source: Color4): Color4;
        /**
         * Copies the given float values into the current one
         * @param r defines the red component to read from
         * @param g defines the green component to read from
         * @param b defines the blue component to read from
         * @param a defines the alpha component to read from
         * @returns the current updated Color4 object
         */
        copyFromFloats(r: number, g: number, b: number, a: number): Color4;
        /**
         * Copies the given float values into the current one
         * @param r defines the red component to read from
         * @param g defines the green component to read from
         * @param b defines the blue component to read from
         * @param a defines the alpha component to read from
         * @returns the current updated Color4 object
         */
        set(r: number, g: number, b: number, a: number): Color4;
        /**
         * Compute the Color4 hexadecimal code as a string
         * @param returnAsColor3 defines if the string should only contains RGB values (off by default)
         * @returns a string containing the hexadecimal representation of the Color4 object
         */
        toHexString(returnAsColor3?: boolean): string;
        /**
         * Computes a new Color4 converted from the current one to linear space
         * @returns a new Color4 object
         */
        toLinearSpace(): Color4;
        /**
         * Converts the Color4 values to linear space and stores the result in "convertedColor"
         * @param convertedColor defines the Color4 object where to store the linear space version
         * @returns the unmodified Color4
         */
        toLinearSpaceToRef(convertedColor: Color4): Color4;
        /**
         * Computes a new Color4 converted from the current one to gamma space
         * @returns a new Color4 object
         */
        toGammaSpace(): Color4;
        /**
         * Converts the Color4 values to gamma space and stores the result in "convertedColor"
         * @param convertedColor defines the Color4 object where to store the gamma space version
         * @returns the unmodified Color4
         */
        toGammaSpaceToRef(convertedColor: Color4): Color4;
        /**
         * Creates a new Color4 from the string containing valid hexadecimal values
         * @param hex defines a string containing valid hexadecimal values
         * @returns a new Color4 object
         */
        static FromHexString(hex: string): Color4;
        /**
         * Creates a new Color4 object set with the linearly interpolated values of "amount" between the left Color4 object and the right Color4 object
         * @param left defines the start value
         * @param right defines the end value
         * @param amount defines the gradient factor
         * @returns a new Color4 object
         */
        static Lerp(left: DeepImmutable<Color4>, right: DeepImmutable<Color4>, amount: number): Color4;
        /**
         * Set the given "result" with the linearly interpolated values of "amount" between the left Color4 object and the right Color4 object
         * @param left defines the start value
         * @param right defines the end value
         * @param amount defines the gradient factor
         * @param result defines the Color4 object where to store data
         */
        static LerpToRef(left: DeepImmutable<Color4>, right: DeepImmutable<Color4>, amount: number, result: Color4): void;
        /**
         * Creates a new Color4 from a Color3 and an alpha value
         * @param color3 defines the source Color3 to read from
         * @param alpha defines the alpha component (1.0 by default)
         * @returns a new Color4 object
         */
        static FromColor3(color3: DeepImmutable<Color3>, alpha?: number): Color4;
        /**
         * Creates a new Color4 from the starting index element of the given array
         * @param array defines the source array to read from
         * @param offset defines the offset in the source array
         * @returns a new Color4 object
         */
        static FromArray(array: DeepImmutable<ArrayLike<number>>, offset?: number): Color4;
        /**
         * Creates a new Color4 from the starting index element of the given array
         * @param array defines the source array to read from
         * @param offset defines the offset in the source array
         * @param result defines the target Color4 object
         */
        static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number | undefined, result: Color4): void;
        /**
         * Creates a new Color3 from integer values (< 256)
         * @param r defines the red component to read from (value between 0 and 255)
         * @param g defines the green component to read from (value between 0 and 255)
         * @param b defines the blue component to read from (value between 0 and 255)
         * @param a defines the alpha component to read from (value between 0 and 255)
         * @returns a new Color3 object
         */
        static FromInts(r: number, g: number, b: number, a: number): Color4;
        /**
         * Check the content of a given array and convert it to an array containing RGBA data
         * If the original array was already containing count * 4 values then it is returned directly
         * @param colors defines the array to check
         * @param count defines the number of RGBA data to expect
         * @returns an array containing count * 4 values (RGBA)
         */
        static CheckColors4(colors: number[], count: number): number[];
    }
    /**
     * @hidden
     */
    export class TmpColors {
        static Color3: Color3[];
        static Color4: Color4[];
    }
}
declare module BABYLON {
    /**
     * Defines an interface which represents an animation key frame
     */
    export interface IAnimationKey {
        /**
         * Frame of the key frame
         */
        frame: number;
        /**
         * Value at the specifies key frame
         */
        value: any;
        /**
         * The input tangent for the cubic hermite spline
         */
        inTangent?: any;
        /**
         * The output tangent for the cubic hermite spline
         */
        outTangent?: any;
        /**
         * The animation interpolation type
         */
        interpolation?: AnimationKeyInterpolation;
    }
    /**
     * Enum for the animation key frame interpolation type
     */
    export enum AnimationKeyInterpolation {
        /**
         * Do not interpolate between keys and use the start key value only. Tangents are ignored
         */
        STEP = 1
    }
}
declare module BABYLON {
    /**
     * Represents the range of an animation
     */
    export class AnimationRange {
        /**The name of the animation range**/
        name: string;
        /**The starting frame of the animation */
        from: number;
        /**The ending frame of the animation*/
        to: number;
        /**
         * Initializes the range of an animation
         * @param name The name of the animation range
         * @param from The starting frame of the animation
         * @param to The ending frame of the animation
         */
        constructor(
        /**The name of the animation range**/
        name: string, 
        /**The starting frame of the animation */
        from: number, 
        /**The ending frame of the animation*/
        to: number);
        /**
         * Makes a copy of the animation range
         * @returns A copy of the animation range
         */
        clone(): AnimationRange;
    }
}
declare module BABYLON {
    /**
     * Composed of a frame, and an action function
     */
    export class AnimationEvent {
        /** The frame for which the event is triggered **/
        frame: number;
        /** The event to perform when triggered **/
        action: (currentFrame: number) => void;
        /** Specifies if the event should be triggered only once**/
        onlyOnce?: boolean | undefined;
        /**
         * Specifies if the animation event is done
         */
        isDone: boolean;
        /**
         * Initializes the animation event
         * @param frame The frame for which the event is triggered
         * @param action The event to perform when triggered
         * @param onlyOnce Specifies if the event should be triggered only once
         */
        constructor(
        /** The frame for which the event is triggered **/
        frame: number, 
        /** The event to perform when triggered **/
        action: (currentFrame: number) => void, 
        /** Specifies if the event should be triggered only once**/
        onlyOnce?: boolean | undefined);
        /** @hidden */
        _clone(): AnimationEvent;
    }
}
declare module BABYLON {
    /**
     * Interface used to define a behavior
     */
    export interface Behavior<T> {
        /** gets or sets behavior's name */
        name: string;
        /**
         * Function called when the behavior needs to be initialized (after attaching it to a target)
         */
        init(): void;
        /**
         * Called when the behavior is attached to a target
         * @param target defines the target where the behavior is attached to
         */
        attach(target: T): void;
        /**
         * Called when the behavior is detached from its target
         */
        detach(): void;
    }
    /**
     * Interface implemented by classes supporting behaviors
     */
    export interface IBehaviorAware<T> {
        /**
         * Attach a behavior
         * @param behavior defines the behavior to attach
         * @returns the current host
         */
        addBehavior(behavior: Behavior<T>): T;
        /**
         * Remove a behavior from the current object
         * @param behavior defines the behavior to detach
         * @returns the current host
         */
        removeBehavior(behavior: Behavior<T>): T;
        /**
         * Gets a behavior using its name to search
         * @param name defines the name to search
         * @returns the behavior or null if not found
         */
        getBehaviorByName(name: string): Nullable<Behavior<T>>;
    }
}
declare module BABYLON {
    /**
     * Defines an array and its length.
     * It can be helpfull to group result from both Arrays and smart arrays in one structure.
     */
    export interface ISmartArrayLike<T> {
        /**
         * The data of the array.
         */
        data: Array<T>;
        /**
         * The active length of the array.
         */
        length: number;
    }
    /**
     * Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.
     */
    export class SmartArray<T> implements ISmartArrayLike<T> {
        /**
         * The full set of data from the array.
         */
        data: Array<T>;
        /**
         * The active length of the array.
         */
        length: number;
        protected _id: number;
        /**
         * Instantiates a Smart Array.
         * @param capacity defines the default capacity of the array.
         */
        constructor(capacity: number);
        /**
         * Pushes a value at the end of the active data.
         * @param value defines the object to push in the array.
         */
        push(value: T): void;
        /**
         * Iterates over the active data and apply the lambda to them.
         * @param func defines the action to apply on each value.
         */
        forEach(func: (content: T) => void): void;
        /**
         * Sorts the full sets of data.
         * @param compareFn defines the comparison function to apply.
         */
        sort(compareFn: (a: T, b: T) => number): void;
        /**
         * Resets the active data to an empty array.
         */
        reset(): void;
        /**
         * Releases all the data from the array as well as the array.
         */
        dispose(): void;
        /**
         * Concats the active data with a given array.
         * @param array defines the data to concatenate with.
         */
        concat(array: any): void;
        /**
         * Returns the position of a value in the active data.
         * @param value defines the value to find the index for
         * @returns the index if found in the active data otherwise -1
         */
        indexOf(value: T): number;
        /**
         * Returns whether an element is part of the active data.
         * @param value defines the value to look for
         * @returns true if found in the active data otherwise false
         */
        contains(value: T): boolean;
        private static _GlobalId;
    }
    /**
     * Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.
     * The data in this array can only be present once
     */
    export class SmartArrayNoDuplicate<T> extends SmartArray<T> {
        private _duplicateId;
        /**
         * Pushes a value at the end of the active data.
         * THIS DOES NOT PREVENT DUPPLICATE DATA
         * @param value defines the object to push in the array.
         */
        push(value: T): void;
        /**
         * Pushes a value at the end of the active data.
         * If the data is already present, it won t be added again
         * @param value defines the object to push in the array.
         * @returns true if added false if it was already present
         */
        pushNoDuplicate(value: T): boolean;
        /**
         * Resets the active data to an empty array.
         */
        reset(): void;
        /**
         * Concats the active data with a given array.
         * This ensures no dupplicate will be present in the result.
         * @param array defines the data to concatenate with.
         */
        concatWithNoDuplicate(array: any): void;
    }
}
declare module BABYLON {
    /**
     * @ignore
     * This is a list of all the different input types that are available in the application.
     * Fo instance: ArcRotateCameraGamepadInput...
     */
    export var CameraInputTypes: {};
    /**
     * This is the contract to implement in order to create a new input class.
     * Inputs are dealing with listening to user actions and moving the camera accordingly.
     */
    export interface ICameraInput<TCamera extends Camera> {
        /**
         * Defines the camera the input is attached to.
         */
        camera: Nullable<TCamera>;
        /**
         * Gets the class name of the current intput.
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Get the friendly name associated with the input class.
         * @returns the input friendly name
         */
        getSimpleName(): string;
        /**
         * Attach the input controls to a specific dom element to get the input from.
         * @param element Defines the element the controls should be listened from
         * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Detach the current controls from the specified dom element.
         * @param element Defines the element to stop listening the inputs from
         */
        detachControl(element: Nullable<HTMLElement>): void;
        /**
         * Update the current camera state depending on the inputs that have been used this frame.
         * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
         */
        checkInputs?: () => void;
    }
    /**
     * Represents a map of input types to input instance or input index to input instance.
     */
    export interface CameraInputsMap<TCamera extends Camera> {
        /**
         * Accessor to the input by input type.
         */
        [name: string]: ICameraInput<TCamera>;
        /**
         * Accessor to the input by input index.
         */
        [idx: number]: ICameraInput<TCamera>;
    }
    /**
     * This represents the input manager used within a camera.
     * It helps dealing with all the different kind of input attached to a camera.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class CameraInputsManager<TCamera extends Camera> {
        /**
         * Defines the list of inputs attahed to the camera.
         */
        attached: CameraInputsMap<TCamera>;
        /**
         * Defines the dom element the camera is collecting inputs from.
         * This is null if the controls have not been attached.
         */
        attachedElement: Nullable<HTMLElement>;
        /**
         * Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         */
        noPreventDefault: boolean;
        /**
         * Defined the camera the input manager belongs to.
         */
        camera: TCamera;
        /**
         * Update the current camera state depending on the inputs that have been used this frame.
         * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
         */
        checkInputs: () => void;
        /**
         * Instantiate a new Camera Input Manager.
         * @param camera Defines the camera the input manager blongs to
         */
        constructor(camera: TCamera);
        /**
         * Add an input method to a camera
         * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
         * @param input camera input method
         */
        add(input: ICameraInput<TCamera>): void;
        /**
         * Remove a specific input method from a camera
         * example: camera.inputs.remove(camera.inputs.attached.mouse);
         * @param inputToRemove camera input method
         */
        remove(inputToRemove: ICameraInput<TCamera>): void;
        /**
         * Remove a specific input type from a camera
         * example: camera.inputs.remove("ArcRotateCameraGamepadInput");
         * @param inputType the type of the input to remove
         */
        removeByType(inputType: string): void;
        private _addCheckInputs;
        /**
         * Attach the input controls to the currently attached dom element to listen the events from.
         * @param input Defines the input to attach
         */
        attachInput(input: ICameraInput<TCamera>): void;
        /**
         * Attach the current manager inputs controls to a specific dom element to listen the events from.
         * @param element Defines the dom element to collect the events from
         * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         */
        attachElement(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Detach the current manager inputs controls from a specific dom element.
         * @param element Defines the dom element to collect the events from
         * @param disconnect Defines whether the input should be removed from the current list of attached inputs
         */
        detachElement(element: HTMLElement, disconnect?: boolean): void;
        /**
         * Rebuild the dynamic inputCheck function from the current list of
         * defined inputs in the manager.
         */
        rebuildInputCheck(): void;
        /**
         * Remove all attached input methods from a camera
         */
        clear(): void;
        /**
         * Serialize the current input manager attached to a camera.
         * This ensures than once parsed,
         * the input associated to the camera will be identical to the current ones
         * @param serializedCamera Defines the camera serialization JSON the input serialization should write to
         */
        serialize(serializedCamera: any): void;
        /**
         * Parses an input manager serialized JSON to restore the previous list of inputs
         * and states associated to a camera.
         * @param parsedCamera Defines the JSON to parse
         */
        parse(parsedCamera: any): void;
    }
}
declare module BABYLON {
    /**
     * Class used to store data that will be store in GPU memory
     */
    export class Buffer {
        private _engine;
        private _buffer;
        /** @hidden */
        _data: Nullable<DataArray>;
        private _updatable;
        private _instanced;
        private _divisor;
        /**
         * Gets the byte stride.
         */
        readonly byteStride: number;
        /**
         * Constructor
         * @param engine the engine
         * @param data the data to use for this buffer
         * @param updatable whether the data is updatable
         * @param stride the stride (optional)
         * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)
         * @param instanced whether the buffer is instanced (optional)
         * @param useBytes set to true if the stride in in bytes (optional)
         * @param divisor sets an optional divisor for instances (1 by default)
         */
        constructor(engine: any, data: DataArray, updatable: boolean, stride?: number, postponeInternalCreation?: boolean, instanced?: boolean, useBytes?: boolean, divisor?: number);
        /**
         * Create a new VertexBuffer based on the current buffer
         * @param kind defines the vertex buffer kind (position, normal, etc.)
         * @param offset defines offset in the buffer (0 by default)
         * @param size defines the size in floats of attributes (position is 3 for instance)
         * @param stride defines the stride size in floats in the buffer (the offset to apply to reach next value when data is interleaved)
         * @param instanced defines if the vertex buffer contains indexed data
         * @param useBytes defines if the offset and stride are in bytes     *
         * @param divisor sets an optional divisor for instances (1 by default)
         * @returns the new vertex buffer
         */
        createVertexBuffer(kind: string, offset: number, size: number, stride?: number, instanced?: boolean, useBytes?: boolean, divisor?: number): VertexBuffer;
        /**
         * Gets a boolean indicating if the Buffer is updatable?
         * @returns true if the buffer is updatable
         */
        isUpdatable(): boolean;
        /**
         * Gets current buffer's data
         * @returns a DataArray or null
         */
        getData(): Nullable<DataArray>;
        /**
         * Gets underlying native buffer
         * @returns underlying native buffer
         */
        getBuffer(): Nullable<DataBuffer>;
        /**
         * Gets the stride in float32 units (i.e. byte stride / 4).
         * May not be an integer if the byte stride is not divisible by 4.
         * @returns the stride in float32 units
         * @deprecated Please use byteStride instead.
         */
        getStrideSize(): number;
        /**
         * Store data into the buffer. If the buffer was already used it will be either recreated or updated depending on isUpdatable property
         * @param data defines the data to store
         */
        create(data?: Nullable<DataArray>): void;
        /** @hidden */
        _rebuild(): void;
        /**
         * Update current buffer data
         * @param data defines the data to store
         */
        update(data: DataArray): void;
        /**
         * Updates the data directly.
         * @param data the new data
         * @param offset the new offset
         * @param vertexCount the vertex count (optional)
         * @param useBytes set to true if the offset is in bytes
         */
        updateDirectly(data: DataArray, offset: number, vertexCount?: number, useBytes?: boolean): void;
        /**
         * Release all resources
         */
        dispose(): void;
    }
    /**
         * Specialized buffer used to store vertex data
         */
    export class VertexBuffer {
        /** @hidden */
        _buffer: Buffer;
        private _kind;
        private _size;
        private _ownsBuffer;
        private _instanced;
        private _instanceDivisor;
        /**
         * The byte type.
         */
        static readonly BYTE: number;
        /**
         * The unsigned byte type.
         */
        static readonly UNSIGNED_BYTE: number;
        /**
         * The short type.
         */
        static readonly SHORT: number;
        /**
         * The unsigned short type.
         */
        static readonly UNSIGNED_SHORT: number;
        /**
         * The integer type.
         */
        static readonly INT: number;
        /**
         * The unsigned integer type.
         */
        static readonly UNSIGNED_INT: number;
        /**
         * The float type.
         */
        static readonly FLOAT: number;
        /**
         * Gets or sets the instance divisor when in instanced mode
         */
        get instanceDivisor(): number;
        set instanceDivisor(value: number);
        /**
         * Gets the byte stride.
         */
        readonly byteStride: number;
        /**
         * Gets the byte offset.
         */
        readonly byteOffset: number;
        /**
         * Gets whether integer data values should be normalized into a certain range when being casted to a float.
         */
        readonly normalized: boolean;
        /**
         * Gets the data type of each component in the array.
         */
        readonly type: number;
        /**
         * Constructor
         * @param engine the engine
         * @param data the data to use for this vertex buffer
         * @param kind the vertex buffer kind
         * @param updatable whether the data is updatable
         * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)
         * @param stride the stride (optional)
         * @param instanced whether the buffer is instanced (optional)
         * @param offset the offset of the data (optional)
         * @param size the number of components (optional)
         * @param type the type of the component (optional)
         * @param normalized whether the data contains normalized data (optional)
         * @param useBytes set to true if stride and offset are in bytes (optional)
         * @param divisor defines the instance divisor to use (1 by default)
         */
        constructor(engine: any, data: DataArray | Buffer, kind: string, updatable: boolean, postponeInternalCreation?: boolean, stride?: number, instanced?: boolean, offset?: number, size?: number, type?: number, normalized?: boolean, useBytes?: boolean, divisor?: number);
        /** @hidden */
        _rebuild(): void;
        /**
         * Returns the kind of the VertexBuffer (string)
         * @returns a string
         */
        getKind(): string;
        /**
         * Gets a boolean indicating if the VertexBuffer is updatable?
         * @returns true if the buffer is updatable
         */
        isUpdatable(): boolean;
        /**
         * Gets current buffer's data
         * @returns a DataArray or null
         */
        getData(): Nullable<DataArray>;
        /**
         * Gets underlying native buffer
         * @returns underlying native buffer
         */
        getBuffer(): Nullable<DataBuffer>;
        /**
         * Gets the stride in float32 units (i.e. byte stride / 4).
         * May not be an integer if the byte stride is not divisible by 4.
         * @returns the stride in float32 units
         * @deprecated Please use byteStride instead.
         */
        getStrideSize(): number;
        /**
         * Returns the offset as a multiple of the type byte length.
         * @returns the offset in bytes
         * @deprecated Please use byteOffset instead.
         */
        getOffset(): number;
        /**
         * Returns the number of components per vertex attribute (integer)
         * @returns the size in float
         */
        getSize(): number;
        /**
         * Gets a boolean indicating is the internal buffer of the VertexBuffer is instanced
         * @returns true if this buffer is instanced
         */
        getIsInstanced(): boolean;
        /**
         * Returns the instancing divisor, zero for non-instanced (integer).
         * @returns a number
         */
        getInstanceDivisor(): number;
        /**
         * Store data into the buffer. If the buffer was already used it will be either recreated or updated depending on isUpdatable property
         * @param data defines the data to store
         */
        create(data?: DataArray): void;
        /**
         * Updates the underlying buffer according to the passed numeric array or Float32Array.
         * This function will create a new buffer if the current one is not updatable
         * @param data defines the data to store
         */
        update(data: DataArray): void;
        /**
         * Updates directly the underlying WebGLBuffer according to the passed numeric array or Float32Array.
         * Returns the directly updated WebGLBuffer.
         * @param data the new data
         * @param offset the new offset
         * @param useBytes set to true if the offset is in bytes
         */
        updateDirectly(data: DataArray, offset: number, useBytes?: boolean): void;
        /**
         * Disposes the VertexBuffer and the underlying WebGLBuffer.
         */
        dispose(): void;
        /**
         * Enumerates each value of this vertex buffer as numbers.
         * @param count the number of values to enumerate
         * @param callback the callback function called for each value
         */
        forEach(count: number, callback: (value: number, index: number) => void): void;
        /**
         * Positions
         */
        static readonly PositionKind: string;
        /**
         * Normals
         */
        static readonly NormalKind: string;
        /**
         * Tangents
         */
        static readonly TangentKind: string;
        /**
         * Texture coordinates
         */
        static readonly UVKind: string;
        /**
         * Texture coordinates 2
         */
        static readonly UV2Kind: string;
        /**
         * Texture coordinates 3
         */
        static readonly UV3Kind: string;
        /**
         * Texture coordinates 4
         */
        static readonly UV4Kind: string;
        /**
         * Texture coordinates 5
         */
        static readonly UV5Kind: string;
        /**
         * Texture coordinates 6
         */
        static readonly UV6Kind: string;
        /**
         * Colors
         */
        static readonly ColorKind: string;
        /**
         * Matrix indices (for bones)
         */
        static readonly MatricesIndicesKind: string;
        /**
         * Matrix weights (for bones)
         */
        static readonly MatricesWeightsKind: string;
        /**
         * Additional matrix indices (for bones)
         */
        static readonly MatricesIndicesExtraKind: string;
        /**
         * Additional matrix weights (for bones)
         */
        static readonly MatricesWeightsExtraKind: string;
        /**
         * Deduces the stride given a kind.
         * @param kind The kind string to deduce
         * @returns The deduced stride
         */
        static DeduceStride(kind: string): number;
        /**
         * Gets the byte length of the given type.
         * @param type the type
         * @returns the number of bytes
         */
        static GetTypeByteLength(type: number): number;
        /**
         * Enumerates each value of the given parameters as numbers.
         * @param data the data to enumerate
         * @param byteOffset the byte offset of the data
         * @param byteStride the byte stride of the data
         * @param componentCount the number of components per element
         * @param componentType the type of the component
         * @param count the number of values to enumerate
         * @param normalized whether the data is normalized
         * @param callback the callback function called for each value
         */
        static ForEach(data: DataArray, byteOffset: number, byteStride: number, componentCount: number, componentType: number, count: number, normalized: boolean, callback: (value: number, index: number) => void): void;
        private static _GetFloatValue;
    }
}
declare module BABYLON {
    /**
     * The options Interface for creating a Capsule Mesh
     */
    export interface ICreateCapsuleOptions {
        /** The Orientation of the capsule.  Default : Vector3.Up() */
        orientation?: Vector3;
        /** Number of sub segments on the tube section of the capsule running parallel to orientation. */
        subdivisions: number;
        /** Number of cylindrical segments on the capsule. */
        tessellation: number;
        /** Height or Length of the capsule. */
        height: number;
        /** Radius of the capsule. */
        radius: number;
        /** Height or Length of the capsule. */
        capSubdivisions: number;
        /** Overwrite for the top radius. */
        radiusTop?: number;
        /** Overwrite for the bottom radius. */
        radiusBottom?: number;
        /** Overwrite for the top capSubdivisions. */
        topCapSubdivisions?: number;
        /** Overwrite for the bottom capSubdivisions. */
        bottomCapSubdivisions?: number;
    }
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class CapsuleBuilder {
        /**
         * Creates a capsule or a pill mesh
         * @param name defines the name of the mesh
         * @param options The constructors options.
         * @param scene The scene the mesh is scoped to.
         * @returns Capsule Mesh
         */
        static CreateCapsule(name: string, options: ICreateCapsuleOptions | undefined, scene: any): Mesh;
    }
}
declare module BABYLON {
    /**
     * @hidden
     */
    export class IntersectionInfo {
        bu: Nullable<number>;
        bv: Nullable<number>;
        distance: number;
        faceId: number;
        subMeshId: number;
        constructor(bu: Nullable<number>, bv: Nullable<number>, distance: number);
    }
}
declare module BABYLON {
    /**
     * Class used to store bounding sphere information
     */
    export class BoundingSphere {
        /**
         * Gets the center of the bounding sphere in local space
         */
        readonly center: Vector3;
        /**
         * Radius of the bounding sphere in local space
         */
        radius: number;
        /**
         * Gets the center of the bounding sphere in world space
         */
        readonly centerWorld: Vector3;
        /**
         * Radius of the bounding sphere in world space
         */
        radiusWorld: number;
        /**
         * Gets the minimum vector in local space
         */
        readonly minimum: Vector3;
        /**
         * Gets the maximum vector in local space
         */
        readonly maximum: Vector3;
        private _worldMatrix;
        private static readonly TmpVector3;
        /**
         * Creates a new bounding sphere
         * @param min defines the minimum vector (in local space)
         * @param max defines the maximum vector (in local space)
         * @param worldMatrix defines the new world matrix
         */
        constructor(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>);
        /**
         * Recreates the entire bounding sphere from scratch as if we call the constructor in place
         * @param min defines the new minimum vector (in local space)
         * @param max defines the new maximum vector (in local space)
         * @param worldMatrix defines the new world matrix
         */
        reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>): void;
        /**
         * Scale the current bounding sphere by applying a scale factor
         * @param factor defines the scale factor to apply
         * @returns the current bounding box
         */
        scale(factor: number): BoundingSphere;
        /**
         * Gets the world matrix of the bounding box
         * @returns a matrix
         */
        getWorldMatrix(): DeepImmutable<Matrix>;
        /** @hidden */
        _update(worldMatrix: DeepImmutable<Matrix>): void;
        /**
         * Tests if the bounding sphere is intersecting the frustum planes
         * @param frustumPlanes defines the frustum planes to test
         * @returns true if there is an intersection
         */
        isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean;
        /**
         * Tests if the bounding sphere center is in between the frustum planes.
         * Used for optimistic fast inclusion.
         * @param frustumPlanes defines the frustum planes to test
         * @returns true if the sphere center is in between the frustum planes
         */
        isCenterInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean;
        /**
         * Tests if a point is inside the bounding sphere
         * @param point defines the point to test
         * @returns true if the point is inside the bounding sphere
         */
        intersectsPoint(point: DeepImmutable<Vector3>): boolean;
        /**
         * Checks if two sphere intersct
         * @param sphere0 sphere 0
         * @param sphere1 sphere 1
         * @returns true if the speres intersect
         */
        static Intersects(sphere0: DeepImmutable<BoundingSphere>, sphere1: DeepImmutable<BoundingSphere>): boolean;
    }
}
declare module BABYLON {
    /**
     * Class used to store bounding box information
     */
    export class BoundingBox implements ICullable {
        /**
         * Gets the 8 vectors representing the bounding box in local space
         */
        readonly vectors: Vector3[];
        /**
         * Gets the center of the bounding box in local space
         */
        readonly center: Vector3;
        /**
         * Gets the center of the bounding box in world space
         */
        readonly centerWorld: Vector3;
        /**
         * Gets the extend size in local space
         */
        readonly extendSize: Vector3;
        /**
         * Gets the extend size in world space
         */
        readonly extendSizeWorld: Vector3;
        /**
         * Gets the OBB (object bounding box) directions
         */
        readonly directions: Vector3[];
        /**
         * Gets the 8 vectors representing the bounding box in world space
         */
        readonly vectorsWorld: Vector3[];
        /**
         * Gets the minimum vector in world space
         */
        readonly minimumWorld: Vector3;
        /**
         * Gets the maximum vector in world space
         */
        readonly maximumWorld: Vector3;
        /**
         * Gets the minimum vector in local space
         */
        readonly minimum: Vector3;
        /**
         * Gets the maximum vector in local space
         */
        readonly maximum: Vector3;
        private _worldMatrix;
        private static readonly TmpVector3;
        /**
         * @hidden
         */
        _tag: number;
        /**
         * Creates a new bounding box
         * @param min defines the minimum vector (in local space)
         * @param max defines the maximum vector (in local space)
         * @param worldMatrix defines the new world matrix
         */
        constructor(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>);
        /**
         * Recreates the entire bounding box from scratch as if we call the constructor in place
         * @param min defines the new minimum vector (in local space)
         * @param max defines the new maximum vector (in local space)
         * @param worldMatrix defines the new world matrix
         */
        reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>): void;
        /**
         * Scale the current bounding box by applying a scale factor
         * @param factor defines the scale factor to apply
         * @returns the current bounding box
         */
        scale(factor: number): BoundingBox;
        /**
         * Gets the world matrix of the bounding box
         * @returns a matrix
         */
        getWorldMatrix(): DeepImmutable<Matrix>;
        /** @hidden */
        _update(world: DeepImmutable<Matrix>): void;
        /**
         * Tests if the bounding box is intersecting the frustum planes
         * @param frustumPlanes defines the frustum planes to test
         * @returns true if there is an intersection
         */
        isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean;
        /**
         * Tests if the bounding box is entirely inside the frustum planes
         * @param frustumPlanes defines the frustum planes to test
         * @returns true if there is an inclusion
         */
        isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean;
        /**
         * Tests if a point is inside the bounding box
         * @param point defines the point to test
         * @returns true if the point is inside the bounding box
         */
        intersectsPoint(point: DeepImmutable<Vector3>): boolean;
        /**
         * Tests if the bounding box intersects with a bounding sphere
         * @param sphere defines the sphere to test
         * @returns true if there is an intersection
         */
        intersectsSphere(sphere: DeepImmutable<BoundingSphere>): boolean;
        /**
         * Tests if the bounding box intersects with a box defined by a min and max vectors
         * @param min defines the min vector to use
         * @param max defines the max vector to use
         * @returns true if there is an intersection
         */
        intersectsMinMax(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>): boolean;
        /**
         * Tests if two bounding boxes are intersections
         * @param box0 defines the first box to test
         * @param box1 defines the second box to test
         * @returns true if there is an intersection
         */
        static Intersects(box0: DeepImmutable<BoundingBox>, box1: DeepImmutable<BoundingBox>): boolean;
        /**
         * Tests if a bounding box defines by a min/max vectors intersects a sphere
         * @param minPoint defines the minimum vector of the bounding box
         * @param maxPoint defines the maximum vector of the bounding box
         * @param sphereCenter defines the sphere center
         * @param sphereRadius defines the sphere radius
         * @returns true if there is an intersection
         */
        static IntersectsSphere(minPoint: DeepImmutable<Vector3>, maxPoint: DeepImmutable<Vector3>, sphereCenter: DeepImmutable<Vector3>, sphereRadius: number): boolean;
        /**
         * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes
         * @param boundingVectors defines an array of 8 vectors representing a bounding box
         * @param frustumPlanes defines the frustum planes to test
         * @return true if there is an inclusion
         */
        static IsCompletelyInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean;
        /**
         * Tests if a bounding box defined with 8 vectors intersects frustum planes
         * @param boundingVectors defines an array of 8 vectors representing a bounding box
         * @param frustumPlanes defines the frustum planes to test
         * @return true if there is an intersection
         */
        static IsInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean;
    }
}
declare module BABYLON {
    /** @hidden */
    export class Collider {
        /** Define if a collision was found */
        collisionFound: boolean;
        /**
         * Define last intersection point in local space
         */
        intersectionPoint: Vector3;
        /**
         * Define last collided mesh
         */
        collidedMesh: Nullable<AbstractMesh>;
        private _collisionPoint;
        private _planeIntersectionPoint;
        private _tempVector;
        private _tempVector2;
        private _tempVector3;
        private _tempVector4;
        private _edge;
        private _baseToVertex;
        private _destinationPoint;
        private _slidePlaneNormal;
        private _displacementVector;
        /** @hidden */
        _radius: Vector3;
        /** @hidden */
        _retry: number;
        private _velocity;
        private _basePoint;
        private _epsilon;
        /** @hidden */
        _velocityWorldLength: number;
        /** @hidden */
        _basePointWorld: Vector3;
        private _velocityWorld;
        private _normalizedVelocity;
        /** @hidden */
        _initialVelocity: Vector3;
        /** @hidden */
        _initialPosition: Vector3;
        private _nearestDistance;
        private _collisionMask;
        get collisionMask(): number;
        set collisionMask(mask: number);
        /**
         * Gets the plane normal used to compute the sliding response (in local space)
         */
        get slidePlaneNormal(): Vector3;
        /** @hidden */
        _initialize(source: Vector3, dir: Vector3, e: number): void;
        /** @hidden */
        _checkPointInTriangle(point: Vector3, pa: Vector3, pb: Vector3, pc: Vector3, n: Vector3): boolean;
        /** @hidden */
        _canDoCollision(sphereCenter: Vector3, sphereRadius: number, vecMin: Vector3, vecMax: Vector3): boolean;
        /** @hidden */
        _testTriangle(faceIndex: number, trianglePlaneArray: Array<Plane>, p1: Vector3, p2: Vector3, p3: Vector3, hasMaterial: boolean, hostMesh: AbstractMesh): void;
        /** @hidden */
        _collide(trianglePlaneArray: Array<Plane>, pts: Vector3[], indices: IndicesArray, indexStart: number, indexEnd: number, decal: number, hasMaterial: boolean, hostMesh: AbstractMesh): void;
        /** @hidden */
        _getResponse(pos: Vector3, vel: Vector3): void;
    }
}
declare module BABYLON {
    /**
     * Interface for cullable objects
     * @see https://doc.babylonjs.com/babylon101/materials#back-face-culling
     */
    export interface ICullable {
        /**
         * Checks if the object or part of the object is in the frustum
         * @param frustumPlanes Camera near/planes
         * @returns true if the object is in frustum otherwise false
         */
        isInFrustum(frustumPlanes: Plane[]): boolean;
        /**
         * Checks if a cullable object (mesh...) is in the camera frustum
         * Unlike isInFrustum this cheks the full bounding box
         * @param frustumPlanes Camera near/planes
         * @returns true if the object is in frustum otherwise false
         */
        isCompletelyInFrustum(frustumPlanes: Plane[]): boolean;
    }
    /**
     * Info for a bounding data of a mesh
     */
    export class BoundingInfo implements ICullable {
        /**
         * Bounding box for the mesh
         */
        readonly boundingBox: BoundingBox;
        /**
         * Bounding sphere for the mesh
         */
        readonly boundingSphere: BoundingSphere;
        private _isLocked;
        private static readonly TmpVector3;
        /**
         * Constructs bounding info
         * @param minimum min vector of the bounding box/sphere
         * @param maximum max vector of the bounding box/sphere
         * @param worldMatrix defines the new world matrix
         */
        constructor(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>);
        /**
         * Recreates the entire bounding info from scratch as if we call the constructor in place
         * @param min defines the new minimum vector (in local space)
         * @param max defines the new maximum vector (in local space)
         * @param worldMatrix defines the new world matrix
         */
        reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>): void;
        /**
         * min vector of the bounding box/sphere
         */
        get minimum(): Vector3;
        /**
         * max vector of the bounding box/sphere
         */
        get maximum(): Vector3;
        /**
         * If the info is locked and won't be updated to avoid perf overhead
         */
        get isLocked(): boolean;
        set isLocked(value: boolean);
        /**
         * Updates the bounding sphere and box
         * @param world world matrix to be used to update
         */
        update(world: DeepImmutable<Matrix>): void;
        /**
         * Recreate the bounding info to be centered around a specific point given a specific extend.
         * @param center New center of the bounding info
         * @param extend New extend of the bounding info
         * @returns the current bounding info
         */
        centerOn(center: DeepImmutable<Vector3>, extend: DeepImmutable<Vector3>): BoundingInfo;
        /**
         * Scale the current bounding info by applying a scale factor
         * @param factor defines the scale factor to apply
         * @returns the current bounding info
         */
        scale(factor: number): BoundingInfo;
        /**
         * Returns `true` if the bounding info is within the frustum defined by the passed array of planes.
         * @param frustumPlanes defines the frustum to test
         * @param strategy defines the strategy to use for the culling (default is BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD)
         * @returns true if the bounding info is in the frustum planes
         */
        isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>, strategy?: number): boolean;
        /**
         * Gets the world distance between the min and max points of the bounding box
         */
        get diagonalLength(): number;
        /**
         * Checks if a cullable object (mesh...) is in the camera frustum
         * Unlike isInFrustum this cheks the full bounding box
         * @param frustumPlanes Camera near/planes
         * @returns true if the object is in frustum otherwise false
         */
        isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean;
        /** @hidden */
        _checkCollision(collider: Collider): boolean;
        /**
         * Checks if a point is inside the bounding box and bounding sphere or the mesh
         * @see https://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh
         * @param point the point to check intersection with
         * @returns if the point intersects
         */
        intersectsPoint(point: DeepImmutable<Vector3>): boolean;
        /**
         * Checks if another bounding info intersects the bounding box and bounding sphere or the mesh
         * @see https://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh
         * @param boundingInfo the bounding info to check intersection with
         * @param precise if the intersection should be done using OBB
         * @returns if the bounding info intersects
         */
        intersects(boundingInfo: DeepImmutable<BoundingInfo>, precise: boolean): boolean;
    }
}
declare module BABYLON {
    /**
     * Extracts minimum and maximum values from a list of indexed positions
     * @param positions defines the positions to use
     * @param indices defines the indices to the positions
     * @param indexStart defines the start index
     * @param indexCount defines the end index
     * @param bias defines bias value to add to the result
     * @return minimum and maximum values
     */
    export function extractMinAndMaxIndexed(positions: FloatArray, indices: IndicesArray, indexStart: number, indexCount: number, bias?: Nullable<Vector2>): {
        minimum: Vector3;
        maximum: Vector3;
    };
    /**
     * Extracts minimum and maximum values from a list of positions
     * @param positions defines the positions to use
     * @param start defines the start index in the positions array
     * @param count defines the number of positions to handle
     * @param bias defines bias value to add to the result
     * @param stride defines the stride size to use (distance between two positions in the positions array)
     * @return minimum and maximum values
     */
    export function extractMinAndMax(positions: FloatArray, start: number, count: number, bias?: Nullable<Vector2>, stride?: number): {
        minimum: Vector3;
        maximum: Vector3;
    };
}
declare module BABYLON {
    /** @hidden */
    export class WebGLDataBuffer extends DataBuffer {
        private _buffer;
        constructor(resource: WebGLBuffer);
        get underlyingResource(): any;
    }
}
declare module BABYLON {
    /** @hidden */
    export class WebGLPipelineContext implements IPipelineContext {
        engine: ThinEngine;
        program: Nullable<WebGLProgram>;
        context?: WebGLRenderingContext;
        vertexShader?: WebGLShader;
        fragmentShader?: WebGLShader;
        isParallelCompiled: boolean;
        onCompiled?: () => void;
        transformFeedback?: WebGLTransformFeedback | null;
        vertexCompilationError: Nullable<string>;
        fragmentCompilationError: Nullable<string>;
        programLinkError: Nullable<string>;
        programValidationError: Nullable<string>;
        get isAsync(): boolean;
        get isReady(): boolean;
        _handlesSpectorRebuildCallback(onCompiled: (program: WebGLProgram) => void): void;
        _getVertexShaderCode(): string | null;
        _getFragmentShaderCode(): string | null;
    }
}
declare module BABYLON {
        interface ThinEngine {
            /**
             * Create an uniform buffer
             * @see https://doc.babylonjs.com/features/webgl2#uniform-buffer-objets
             * @param elements defines the content of the uniform buffer
             * @returns the webGL uniform buffer
             */
            createUniformBuffer(elements: FloatArray): DataBuffer;
            /**
             * Create a dynamic uniform buffer
             * @see https://doc.babylonjs.com/features/webgl2#uniform-buffer-objets
             * @param elements defines the content of the uniform buffer
             * @returns the webGL uniform buffer
             */
            createDynamicUniformBuffer(elements: FloatArray): DataBuffer;
            /**
             * Update an existing uniform buffer
             * @see https://doc.babylonjs.com/features/webgl2#uniform-buffer-objets
             * @param uniformBuffer defines the target uniform buffer
             * @param elements defines the content to update
             * @param offset defines the offset in the uniform buffer where update should start
             * @param count defines the size of the data to update
             */
            updateUniformBuffer(uniformBuffer: DataBuffer, elements: FloatArray, offset?: number, count?: number): void;
            /**
             * Bind an uniform buffer to the current webGL context
             * @param buffer defines the buffer to bind
             */
            bindUniformBuffer(buffer: Nullable<DataBuffer>): void;
            /**
             * Bind a buffer to the current webGL context at a given location
             * @param buffer defines the buffer to bind
             * @param location defines the index where to bind the buffer
             */
            bindUniformBufferBase(buffer: DataBuffer, location: number): void;
            /**
             * Bind a specific block at a given index in a specific shader program
             * @param pipelineContext defines the pipeline context to use
             * @param blockName defines the block name
             * @param index defines the index where to bind the block
             */
            bindUniformBlock(pipelineContext: IPipelineContext, blockName: string, index: number): void;
        }
}
declare module BABYLON {
    /**
     * Uniform buffer objects.
     *
     * Handles blocks of uniform on the GPU.
     *
     * If WebGL 2 is not available, this class falls back on traditionnal setUniformXXX calls.
     *
     * For more information, please refer to :
     * https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object
     */
    export class UniformBuffer {
        private _engine;
        private _buffer;
        private _data;
        private _bufferData;
        private _dynamic?;
        private _uniformLocations;
        private _uniformSizes;
        private _uniformLocationPointer;
        private _needSync;
        private _noUBO;
        private _currentEffect;
        /** @hidden */
        _alreadyBound: boolean;
        private static _MAX_UNIFORM_SIZE;
        private static _tempBuffer;
        /**
         * Lambda to Update a 3x3 Matrix in a uniform buffer.
         * This is dynamic to allow compat with webgl 1 and 2.
         * You will need to pass the name of the uniform as well as the value.
         */
        updateMatrix3x3: (name: string, matrix: Float32Array) => void;
        /**
         * Lambda to Update a 2x2 Matrix in a uniform buffer.
         * This is dynamic to allow compat with webgl 1 and 2.
         * You will need to pass the name of the uniform as well as the value.
         */
        updateMatrix2x2: (name: string, matrix: Float32Array) => void;
        /**
         * Lambda to Update a single float in a uniform buffer.
         * This is dynamic to allow compat with webgl 1 and 2.
         * You will need to pass the name of the uniform as well as the value.
         */
        updateFloat: (name: string, x: number) => void;
        /**
         * Lambda to Update a vec2 of float in a uniform buffer.
         * This is dynamic to allow compat with webgl 1 and 2.
         * You will need to pass the name of the uniform as well as the value.
         */
        updateFloat2: (name: string, x: number, y: number, suffix?: string) => void;
        /**
         * Lambda to Update a vec3 of float in a uniform buffer.
         * This is dynamic to allow compat with webgl 1 and 2.
         * You will need to pass the name of the uniform as well as the value.
         */
        updateFloat3: (name: string, x: number, y: number, z: number, suffix?: string) => void;
        /**
         * Lambda to Update a vec4 of float in a uniform buffer.
         * This is dynamic to allow compat with webgl 1 and 2.
         * You will need to pass the name of the uniform as well as the value.
         */
        updateFloat4: (name: string, x: number, y: number, z: number, w: number, suffix?: string) => void;
        /**
         * Lambda to Update a 4x4 Matrix in a uniform buffer.
         * This is dynamic to allow compat with webgl 1 and 2.
         * You will need to pass the name of the uniform as well as the value.
         */
        updateMatrix: (name: string, mat: Matrix) => void;
        /**
         * Lambda to Update vec3 of float from a Vector in a uniform buffer.
         * This is dynamic to allow compat with webgl 1 and 2.
         * You will need to pass the name of the uniform as well as the value.
         */
        updateVector3: (name: string, vector: Vector3) => void;
        /**
         * Lambda to Update vec4 of float from a Vector in a uniform buffer.
         * This is dynamic to allow compat with webgl 1 and 2.
         * You will need to pass the name of the uniform as well as the value.
         */
        updateVector4: (name: string, vector: Vector4) => void;
        /**
         * Lambda to Update vec3 of float from a Color in a uniform buffer.
         * This is dynamic to allow compat with webgl 1 and 2.
         * You will need to pass the name of the uniform as well as the value.
         */
        updateColor3: (name: string, color: Color3, suffix?: string) => void;
        /**
         * Lambda to Update vec4 of float from a Color in a uniform buffer.
         * This is dynamic to allow compat with webgl 1 and 2.
         * You will need to pass the name of the uniform as well as the value.
         */
        updateColor4: (name: string, color: Color3, alpha: number, suffix?: string) => void;
        /**
         * Instantiates a new Uniform buffer objects.
         *
         * Handles blocks of uniform on the GPU.
         *
         * If WebGL 2 is not available, this class falls back on traditionnal setUniformXXX calls.
         *
         * For more information, please refer to :
         * @see https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object
         * @param engine Define the engine the buffer is associated with
         * @param data Define the data contained in the buffer
         * @param dynamic Define if the buffer is updatable
         */
        constructor(engine: Engine, data?: number[], dynamic?: boolean);
        /**
         * Indicates if the buffer is using the WebGL2 UBO implementation,
         * or just falling back on setUniformXXX calls.
         */
        get useUbo(): boolean;
        /**
         * Indicates if the WebGL underlying uniform buffer is in sync
         * with the javascript cache data.
         */
        get isSync(): boolean;
        /**
         * Indicates if the WebGL underlying uniform buffer is dynamic.
         * Also, a dynamic UniformBuffer will disable cache verification and always
         * update the underlying WebGL uniform buffer to the GPU.
         * @returns if Dynamic, otherwise false
         */
        isDynamic(): boolean;
        /**
         * The data cache on JS side.
         * @returns the underlying data as a float array
         */
        getData(): Float32Array;
        /**
         * The underlying WebGL Uniform buffer.
         * @returns the webgl buffer
         */
        getBuffer(): Nullable<DataBuffer>;
        /**
         * std140 layout specifies how to align data within an UBO structure.
         * See https://khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf#page=159
         * for specs.
         */
        private _fillAlignment;
        /**
         * Adds an uniform in the buffer.
         * Warning : the subsequents calls of this function must be in the same order as declared in the shader
         * for the layout to be correct !
         * @param name Name of the uniform, as used in the uniform block in the shader.
         * @param size Data size, or data directly.
         */
        addUniform(name: string, size: number | number[]): void;
        /**
         * Adds a Matrix 4x4 to the uniform buffer.
         * @param name Name of the uniform, as used in the uniform block in the shader.
         * @param mat A 4x4 matrix.
         */
        addMatrix(name: string, mat: Matrix): void;
        /**
         * Adds a vec2 to the uniform buffer.
         * @param name Name of the uniform, as used in the uniform block in the shader.
         * @param x Define the x component value of the vec2
         * @param y Define the y component value of the vec2
         */
        addFloat2(name: string, x: number, y: number): void;
        /**
         * Adds a vec3 to the uniform buffer.
         * @param name Name of the uniform, as used in the uniform block in the shader.
         * @param x Define the x component value of the vec3
         * @param y Define the y component value of the vec3
         * @param z Define the z component value of the vec3
         */
        addFloat3(name: string, x: number, y: number, z: number): void;
        /**
         * Adds a vec3 to the uniform buffer.
         * @param name Name of the uniform, as used in the uniform block in the shader.
         * @param color Define the vec3 from a Color
         */
        addColor3(name: string, color: Color3): void;
        /**
         * Adds a vec4 to the uniform buffer.
         * @param name Name of the uniform, as used in the uniform block in the shader.
         * @param color Define the rgb components from a Color
         * @param alpha Define the a component of the vec4
         */
        addColor4(name: string, color: Color3, alpha: number): void;
        /**
         * Adds a vec3 to the uniform buffer.
         * @param name Name of the uniform, as used in the uniform block in the shader.
         * @param vector Define the vec3 components from a Vector
         */
        addVector3(name: string, vector: Vector3): void;
        /**
         * Adds a Matrix 3x3 to the uniform buffer.
         * @param name Name of the uniform, as used in the uniform block in the shader.
         */
        addMatrix3x3(name: string): void;
        /**
         * Adds a Matrix 2x2 to the uniform buffer.
         * @param name Name of the uniform, as used in the uniform block in the shader.
         */
        addMatrix2x2(name: string): void;
        /**
         * Effectively creates the WebGL Uniform Buffer, once layout is completed with `addUniform`.
         */
        create(): void;
        /** @hidden */
        _rebuild(): void;
        /**
         * Updates the WebGL Uniform Buffer on the GPU.
         * If the `dynamic` flag is set to true, no cache comparison is done.
         * Otherwise, the buffer will be updated only if the cache differs.
         */
        update(): void;
        /**
         * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.
         * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.
         * @param data Define the flattened data
         * @param size Define the size of the data.
         */
        updateUniform(uniformName: string, data: FloatArray, size: number): void;
        private _valueCache;
        private _cacheMatrix;
        private _updateMatrix3x3ForUniform;
        private _updateMatrix3x3ForEffect;
        private _updateMatrix2x2ForEffect;
        private _updateMatrix2x2ForUniform;
        private _updateFloatForEffect;
        private _updateFloatForUniform;
        private _updateFloat2ForEffect;
        private _updateFloat2ForUniform;
        private _updateFloat3ForEffect;
        private _updateFloat3ForUniform;
        private _updateFloat4ForEffect;
        private _updateFloat4ForUniform;
        private _updateMatrixForEffect;
        private _updateMatrixForUniform;
        private _updateVector3ForEffect;
        private _updateVector3ForUniform;
        private _updateVector4ForEffect;
        private _updateVector4ForUniform;
        private _updateColor3ForEffect;
        private _updateColor3ForUniform;
        private _updateColor4ForEffect;
        private _updateColor4ForUniform;
        /**
         * Sets a sampler uniform on the effect.
         * @param name Define the name of the sampler.
         * @param texture Define the texture to set in the sampler
         */
        setTexture(name: string, texture: Nullable<BaseTexture>): void;
        /**
         * Directly updates the value of the uniform in the cache AND on the GPU.
         * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.
         * @param data Define the flattened data
         */
        updateUniformDirectly(uniformName: string, data: FloatArray): void;
        /**
         * Binds this uniform buffer to an effect.
         * @param effect Define the effect to bind the buffer to
         * @param name Name of the uniform block in the shader.
         */
        bindToEffect(effect: Effect, name: string): void;
        /**
         * Disposes the uniform buffer.
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * Enum that determines the text-wrapping mode to use.
     */
    export enum InspectableType {
        /**
         * Checkbox for booleans
         */
        Checkbox = 0,
        /**
         * Sliders for numbers
         */
        Slider = 1,
        /**
         * Vector3
         */
        Vector3 = 2,
        /**
         * Quaternions
         */
        Quaternion = 3,
        /**
         * Color3
         */
        Color3 = 4,
        /**
         * String
         */
        String = 5
    }
    /**
     * Interface used to define custom inspectable properties.
     * This interface is used by the inspector to display custom property grids
     * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility
     */
    export interface IInspectable {
        /**
         * Gets the label to display
         */
        label: string;
        /**
         * Gets the name of the property to edit
         */
        propertyName: string;
        /**
         * Gets the type of the editor to use
         */
        type: InspectableType;
        /**
         * Gets the minimum value of the property when using in "slider" mode
         */
        min?: number;
        /**
         * Gets the maximum value of the property when using in "slider" mode
         */
        max?: number;
        /**
         * Gets the setp to use when using in "slider" mode
         */
        step?: number;
    }
}
declare module BABYLON {
    /**
     * Class used to provide helper for timing
     */
    export class TimingTools {
        /**
         * Polyfill for setImmediate
         * @param action defines the action to execute after the current execution block
         */
        static SetImmediate(action: () => void): void;
    }
}
declare module BABYLON {
    /**
     * Class used to enable instatition of objects by class name
     */
    export class InstantiationTools {
        /**
         * Use this object to register external classes like custom textures or material
         * to allow the laoders to instantiate them
         */
        static RegisteredExternalClasses: {
            [key: string]: Object;
        };
        /**
         * Tries to instantiate a new object from a given class name
         * @param className defines the class name to instantiate
         * @returns the new object or null if the system was not able to do the instantiation
         */
        static Instantiate(className: string): any;
    }
}
declare module BABYLON {
    /**
     * Define options used to create a depth texture
     */
    export class DepthTextureCreationOptions {
        /** Specifies whether or not a stencil should be allocated in the texture */
        generateStencil?: boolean;
        /** Specifies whether or not bilinear filtering is enable on the texture */
        bilinearFiltering?: boolean;
        /** Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode */
        comparisonFunction?: number;
        /** Specifies if the created texture is a cube texture */
        isCube?: boolean;
    }
}
declare module BABYLON {
        interface ThinEngine {
            /**
             * Creates a depth stencil cube texture.
             * This is only available in WebGL 2.
             * @param size The size of face edge in the cube texture.
             * @param options The options defining the cube texture.
             * @returns The cube texture
             */
            _createDepthStencilCubeTexture(size: number, options: DepthTextureCreationOptions): InternalTexture;
            /**
             * Creates a cube texture
             * @param rootUrl defines the url where the files to load is located
             * @param scene defines the current scene
             * @param files defines the list of files to load (1 per face)
             * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)
             * @param onLoad defines an optional callback raised when the texture is loaded
             * @param onError defines an optional callback raised if there is an issue to load the texture
             * @param format defines the format of the data
             * @param forcedExtension defines the extension to use to pick the right loader
             * @param createPolynomials if a polynomial sphere should be created for the cube texture
             * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness
             * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness
             * @param fallback defines texture to use while falling back when (compressed) texture file not found.
             * @returns the cube texture as an InternalTexture
             */
            createCubeTexture(rootUrl: string, scene: Nullable<Scene>, files: Nullable<string[]>, noMipmap: boolean | undefined, onLoad: Nullable<(data?: any) => void>, onError: Nullable<(message?: string, exception?: any) => void>, format: number | undefined, forcedExtension: any, createPolynomials: boolean, lodScale: number, lodOffset: number, fallback: Nullable<InternalTexture>): InternalTexture;
            /**
             * Creates a cube texture
             * @param rootUrl defines the url where the files to load is located
             * @param scene defines the current scene
             * @param files defines the list of files to load (1 per face)
             * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)
             * @param onLoad defines an optional callback raised when the texture is loaded
             * @param onError defines an optional callback raised if there is an issue to load the texture
             * @param format defines the format of the data
             * @param forcedExtension defines the extension to use to pick the right loader
             * @returns the cube texture as an InternalTexture
             */
            createCubeTexture(rootUrl: string, scene: Nullable<Scene>, files: Nullable<string[]>, noMipmap: boolean, onLoad: Nullable<(data?: any) => void>, onError: Nullable<(message?: string, exception?: any) => void>, format: number | undefined, forcedExtension: any): InternalTexture;
            /**
             * Creates a cube texture
             * @param rootUrl defines the url where the files to load is located
             * @param scene defines the current scene
             * @param files defines the list of files to load (1 per face)
             * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)
             * @param onLoad defines an optional callback raised when the texture is loaded
             * @param onError defines an optional callback raised if there is an issue to load the texture
             * @param format defines the format of the data
             * @param forcedExtension defines the extension to use to pick the right loader
             * @param createPolynomials if a polynomial sphere should be created for the cube texture
             * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness
             * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness
             * @returns the cube texture as an InternalTexture
             */
            createCubeTexture(rootUrl: string, scene: Nullable<Scene>, files: Nullable<string[]>, noMipmap: boolean, onLoad: Nullable<(data?: any) => void>, onError: Nullable<(message?: string, exception?: any) => void>, format: number | undefined, forcedExtension: any, createPolynomials: boolean, lodScale: number, lodOffset: number): InternalTexture;
            /** @hidden */
            _partialLoadFile(url: string, index: number, loadedFiles: ArrayBuffer[], onfinish: (files: ArrayBuffer[]) => void, onErrorCallBack: Nullable<(message?: string, exception?: any) => void>): void;
            /** @hidden */
            _cascadeLoadFiles(scene: Nullable<Scene>, onfinish: (images: ArrayBuffer[]) => void, files: string[], onError: Nullable<(message?: string, exception?: any) => void>): void;
            /** @hidden */
            _cascadeLoadImgs(scene: Nullable<Scene>, onfinish: (images: HTMLImageElement[]) => void, files: string[], onError: Nullable<(message?: string, exception?: any) => void>, mimeType?: string): void;
            /** @hidden */
            _partialLoadImg(url: string, index: number, loadedImages: HTMLImageElement[], scene: Nullable<Scene>, onfinish: (images: HTMLImageElement[]) => void, onErrorCallBack: Nullable<(message?: string, exception?: any) => void>, mimeType?: string): void;
            /**
             * @hidden
             */
            _setCubeMapTextureParams(loadMipmap: boolean): void;
        }
}
declare module BABYLON {
    /**
     * Class for creating a cube texture
     */
    export class CubeTexture extends BaseTexture {
        private _delayedOnLoad;
        /**
         * Observable triggered once the texture has been loaded.
         */
        onLoadObservable: Observable<CubeTexture>;
        /**
         * The url of the texture
         */
        url: string;
        /**
         * Gets or sets the center of the bounding box associated with the cube texture.
         * It must define where the camera used to render the texture was set
         * @see https://doc.babylonjs.com/how_to/reflect#using-local-cubemap-mode
         */
        boundingBoxPosition: Vector3;
        private _boundingBoxSize;
        /**
         * Gets or sets the size of the bounding box associated with the cube texture
         * When defined, the cubemap will switch to local mode
         * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity
         * @example https://www.babylonjs-playground.com/#RNASML
         */
        set boundingBoxSize(value: Vector3);
        /**
         * Returns the bounding box size
         * @see https://doc.babylonjs.com/how_to/reflect#using-local-cubemap-mode
         */
        get boundingBoxSize(): Vector3;
        protected _rotationY: number;
        /**
         * Sets texture matrix rotation angle around Y axis in radians.
         */
        set rotationY(value: number);
        /**
         * Gets texture matrix rotation angle around Y axis radians.
         */
        get rotationY(): number;
        /**
         * Are mip maps generated for this texture or not.
         */
        get noMipmap(): boolean;
        private _noMipmap;
        private _files;
        protected _forcedExtension: Nullable<string>;
        private _extensions;
        private _textureMatrix;
        private _format;
        private _createPolynomials;
        /**
         * Creates a cube texture from an array of image urls
         * @param files defines an array of image urls
         * @param scene defines the hosting scene
         * @param noMipmap specifies if mip maps are not used
         * @returns a cube texture
         */
        static CreateFromImages(files: string[], scene: Scene, noMipmap?: boolean): CubeTexture;
        /**
         * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.
         * @param url defines the url of the prefiltered texture
         * @param scene defines the scene the texture is attached to
         * @param forcedExtension defines the extension of the file if different from the url
         * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary
         * @return the prefiltered texture
         */
        static CreateFromPrefilteredData(url: string, scene: Scene, forcedExtension?: any, createPolynomials?: boolean): CubeTexture;
        /**
         * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well
         * as prefiltered data.
         * @param rootUrl defines the url of the texture or the root name of the six images
         * @param null defines the scene or engine the texture is attached to
         * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...
         * @param noMipmap defines if mipmaps should be created or not
         * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz
         * @param onLoad defines a callback triggered at the end of the file load if no errors occured
         * @param onError defines a callback triggered in case of error during load
         * @param format defines the internal format to use for the texture once loaded
         * @param prefiltered defines whether or not the texture is created from prefiltered data
         * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name
         * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary
         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness
         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness
         * @return the cube texture
         */
        constructor(rootUrl: string, sceneOrEngine: Scene | ThinEngine, extensions?: Nullable<string[]>, noMipmap?: boolean, files?: Nullable<string[]>, onLoad?: Nullable<() => void>, onError?: Nullable<(message?: string, exception?: any) => void>, format?: number, prefiltered?: boolean, forcedExtension?: any, createPolynomials?: boolean, lodScale?: number, lodOffset?: number);
        /**
         * Get the current class name of the texture useful for serialization or dynamic coding.
         * @returns "CubeTexture"
         */
        getClassName(): string;
        /**
         * Update the url (and optional buffer) of this texture if url was null during construction.
         * @param url the url of the texture
         * @param forcedExtension defines the extension to use
         * @param onLoad callback called when the texture is loaded  (defaults to null)
         * @param prefiltered Defines whether the updated texture is prefiltered or not
         */
        updateURL(url: string, forcedExtension?: string, onLoad?: () => void, prefiltered?: boolean): void;
        /**
         * Delays loading of the cube texture
         * @param forcedExtension defines the extension to use
         */
        delayLoad(forcedExtension?: string): void;
        /**
         * Returns the reflection texture matrix
         * @returns the reflection texture matrix
         */
        getReflectionTextureMatrix(): Matrix;
        /**
         * Sets the reflection texture matrix
         * @param value Reflection texture matrix
         */
        setReflectionTextureMatrix(value: Matrix): void;
        /**
         * Parses text to create a cube texture
         * @param parsedTexture define the serialized text to read from
         * @param scene defines the hosting scene
         * @param rootUrl defines the root url of the cube texture
         * @returns a cube texture
         */
        static Parse(parsedTexture: any, scene: Scene, rootUrl: string): CubeTexture;
        /**
         * Makes a clone, or deep copy, of the cube texture
         * @returns a new cube texture
         */
        clone(): CubeTexture;
    }
}
declare module BABYLON {
    /**
     * Manages the defines for the Material
     */
    export class MaterialDefines {
        /** @hidden */
        protected _keys: string[];
        private _isDirty;
        /** @hidden */
        _renderId: number;
        /** @hidden */
        _areLightsDirty: boolean;
        /** @hidden */
        _areLightsDisposed: boolean;
        /** @hidden */
        _areAttributesDirty: boolean;
        /** @hidden */
        _areTexturesDirty: boolean;
        /** @hidden */
        _areFresnelDirty: boolean;
        /** @hidden */
        _areMiscDirty: boolean;
        /** @hidden */
        _areImageProcessingDirty: boolean;
        /** @hidden */
        _normals: boolean;
        /** @hidden */
        _uvs: boolean;
        /** @hidden */
        _needNormals: boolean;
        /** @hidden */
        _needUVs: boolean;
        [id: string]: any;
        /**
         * Specifies if the material needs to be re-calculated
         */
        get isDirty(): boolean;
        /**
         * Marks the material to indicate that it has been re-calculated
         */
        markAsProcessed(): void;
        /**
         * Marks the material to indicate that it needs to be re-calculated
         */
        markAsUnprocessed(): void;
        /**
         * Marks the material to indicate all of its defines need to be re-calculated
         */
        markAllAsDirty(): void;
        /**
         * Marks the material to indicate that image processing needs to be re-calculated
         */
        markAsImageProcessingDirty(): void;
        /**
         * Marks the material to indicate the lights need to be re-calculated
         * @param disposed Defines whether the light is dirty due to dispose or not
         */
        markAsLightDirty(disposed?: boolean): void;
        /**
         * Marks the attribute state as changed
         */
        markAsAttributesDirty(): void;
        /**
         * Marks the texture state as changed
         */
        markAsTexturesDirty(): void;
        /**
         * Marks the fresnel state as changed
         */
        markAsFresnelDirty(): void;
        /**
         * Marks the misc state as changed
         */
        markAsMiscDirty(): void;
        /**
         * Rebuilds the material defines
         */
        rebuild(): void;
        /**
         * Specifies if two material defines are equal
         * @param other - A material define instance to compare to
         * @returns - Boolean indicating if the material defines are equal (true) or not (false)
         */
        isEqual(other: MaterialDefines): boolean;
        /**
         * Clones this instance's defines to another instance
         * @param other - material defines to clone values to
         */
        cloneTo(other: MaterialDefines): void;
        /**
         * Resets the material define values
         */
        reset(): void;
        /**
         * Converts the material define values to a string
         * @returns - String of material define information
         */
        toString(): string;
    }
}
declare module BABYLON {
    /**
     * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
     * corresponding to low luminance, medium luminance, and high luminance areas respectively.
     */
    export class ColorCurves {
        private _dirty;
        private _tempColor;
        private _globalCurve;
        private _highlightsCurve;
        private _midtonesCurve;
        private _shadowsCurve;
        private _positiveCurve;
        private _negativeCurve;
        private _globalHue;
        private _globalDensity;
        private _globalSaturation;
        private _globalExposure;
        /**
         * Gets the global Hue value.
         * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
         */
        get globalHue(): number;
        /**
         * Sets the global Hue value.
         * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
         */
        set globalHue(value: number);
        /**
         * Gets the global Density value.
         * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
         * Values less than zero provide a filter of opposite hue.
         */
        get globalDensity(): number;
        /**
         * Sets the global Density value.
         * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
         * Values less than zero provide a filter of opposite hue.
         */
        set globalDensity(value: number);
        /**
         * Gets the global Saturation value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
         */
        get globalSaturation(): number;
        /**
         * Sets the global Saturation value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
         */
        set globalSaturation(value: number);
        /**
         * Gets the global Exposure value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
         */
        get globalExposure(): number;
        /**
         * Sets the global Exposure value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
         */
        set globalExposure(value: number);
        private _highlightsHue;
        private _highlightsDensity;
        private _highlightsSaturation;
        private _highlightsExposure;
        /**
         * Gets the highlights Hue value.
         * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
         */
        get highlightsHue(): number;
        /**
         * Sets the highlights Hue value.
         * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
         */
        set highlightsHue(value: number);
        /**
         * Gets the highlights Density value.
         * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
         * Values less than zero provide a filter of opposite hue.
         */
        get highlightsDensity(): number;
        /**
         * Sets the highlights Density value.
         * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
         * Values less than zero provide a filter of opposite hue.
         */
        set highlightsDensity(value: number);
        /**
         * Gets the highlights Saturation value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
         */
        get highlightsSaturation(): number;
        /**
         * Sets the highlights Saturation value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
         */
        set highlightsSaturation(value: number);
        /**
         * Gets the highlights Exposure value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
         */
        get highlightsExposure(): number;
        /**
         * Sets the highlights Exposure value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
         */
        set highlightsExposure(value: number);
        private _midtonesHue;
        private _midtonesDensity;
        private _midtonesSaturation;
        private _midtonesExposure;
        /**
         * Gets the midtones Hue value.
         * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
         */
        get midtonesHue(): number;
        /**
         * Sets the midtones Hue value.
         * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
         */
        set midtonesHue(value: number);
        /**
         * Gets the midtones Density value.
         * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
         * Values less than zero provide a filter of opposite hue.
         */
        get midtonesDensity(): number;
        /**
         * Sets the midtones Density value.
         * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
         * Values less than zero provide a filter of opposite hue.
         */
        set midtonesDensity(value: number);
        /**
         * Gets the midtones Saturation value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
         */
        get midtonesSaturation(): number;
        /**
         * Sets the midtones Saturation value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
         */
        set midtonesSaturation(value: number);
        /**
         * Gets the midtones Exposure value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
         */
        get midtonesExposure(): number;
        /**
         * Sets the midtones Exposure value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
         */
        set midtonesExposure(value: number);
        private _shadowsHue;
        private _shadowsDensity;
        private _shadowsSaturation;
        private _shadowsExposure;
        /**
         * Gets the shadows Hue value.
         * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
         */
        get shadowsHue(): number;
        /**
         * Sets the shadows Hue value.
         * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
         */
        set shadowsHue(value: number);
        /**
         * Gets the shadows Density value.
         * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
         * Values less than zero provide a filter of opposite hue.
         */
        get shadowsDensity(): number;
        /**
         * Sets the shadows Density value.
         * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
         * Values less than zero provide a filter of opposite hue.
         */
        set shadowsDensity(value: number);
        /**
         * Gets the shadows Saturation value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
         */
        get shadowsSaturation(): number;
        /**
         * Sets the shadows Saturation value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
         */
        set shadowsSaturation(value: number);
        /**
         * Gets the shadows Exposure value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
         */
        get shadowsExposure(): number;
        /**
         * Sets the shadows Exposure value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
         */
        set shadowsExposure(value: number);
        /**
         * Returns the class name
         * @returns The class name
         */
        getClassName(): string;
        /**
         * Binds the color curves to the shader.
         * @param colorCurves The color curve to bind
         * @param effect The effect to bind to
         * @param positiveUniform The positive uniform shader parameter
         * @param neutralUniform The neutral uniform shader parameter
         * @param negativeUniform The negative uniform shader parameter
         */
        static Bind(colorCurves: ColorCurves, effect: Effect, positiveUniform?: string, neutralUniform?: string, negativeUniform?: string): void;
        /**
         * Prepare the list of uniforms associated with the ColorCurves effects.
         * @param uniformsList The list of uniforms used in the effect
         */
        static PrepareUniforms(uniformsList: string[]): void;
        /**
         * Returns color grading data based on a hue, density, saturation and exposure value.
         * @param filterHue The hue of the color filter.
         * @param filterDensity The density of the color filter.
         * @param saturation The saturation.
         * @param exposure The exposure.
         * @param result The result data container.
         */
        private getColorGradingDataToRef;
        /**
         * Takes an input slider value and returns an adjusted value that provides extra control near the centre.
         * @param value The input slider value in range [-100,100].
         * @returns Adjusted value.
         */
        private static applyColorGradingSliderNonlinear;
        /**
         * Returns an RGBA Color4 based on Hue, Saturation and Brightness (also referred to as value, HSV).
         * @param hue The hue (H) input.
         * @param saturation The saturation (S) input.
         * @param brightness The brightness (B) input.
         * @result An RGBA color represented as Vector4.
         */
        private static fromHSBToRef;
        /**
         * Returns a value clamped between min and max
         * @param value The value to clamp
         * @param min The minimum of value
         * @param max The maximum of value
         * @returns The clamped value.
         */
        private static clamp;
        /**
         * Clones the current color curve instance.
         * @return The cloned curves
         */
        clone(): ColorCurves;
        /**
         * Serializes the current color curve instance to a json representation.
         * @return a JSON representation
         */
        serialize(): any;
        /**
         * Parses the color curve from a json representation.
         * @param source the JSON source to parse
         * @return The parsed curves
         */
        static Parse(source: any): ColorCurves;
    }
}
declare module BABYLON {
    /**
     * Interface to follow in your material defines to integrate easily the
     * Image proccessing functions.
     * @hidden
     */
    export interface IImageProcessingConfigurationDefines {
        IMAGEPROCESSING: boolean;
        VIGNETTE: boolean;
        VIGNETTEBLENDMODEMULTIPLY: boolean;
        VIGNETTEBLENDMODEOPAQUE: boolean;
        TONEMAPPING: boolean;
        TONEMAPPING_ACES: boolean;
        CONTRAST: boolean;
        EXPOSURE: boolean;
        COLORCURVES: boolean;
        COLORGRADING: boolean;
        COLORGRADING3D: boolean;
        SAMPLER3DGREENDEPTH: boolean;
        SAMPLER3DBGRMAP: boolean;
        IMAGEPROCESSINGPOSTPROCESS: boolean;
    }
    /**
     * @hidden
     */
    export class ImageProcessingConfigurationDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {
        IMAGEPROCESSING: boolean;
        VIGNETTE: boolean;
        VIGNETTEBLENDMODEMULTIPLY: boolean;
        VIGNETTEBLENDMODEOPAQUE: boolean;
        TONEMAPPING: boolean;
        TONEMAPPING_ACES: boolean;
        CONTRAST: boolean;
        COLORCURVES: boolean;
        COLORGRADING: boolean;
        COLORGRADING3D: boolean;
        SAMPLER3DGREENDEPTH: boolean;
        SAMPLER3DBGRMAP: boolean;
        IMAGEPROCESSINGPOSTPROCESS: boolean;
        EXPOSURE: boolean;
        constructor();
    }
    /**
     * This groups together the common properties used for image processing either in direct forward pass
     * or through post processing effect depending on the use of the image processing pipeline in your scene
     * or not.
     */
    export class ImageProcessingConfiguration {
        /**
         * Default tone mapping applied in BabylonJS.
         */
        static readonly TONEMAPPING_STANDARD: number;
        /**
         * ACES Tone mapping (used by default in unreal and unity). This can help getting closer
         * to other engines rendering to increase portability.
         */
        static readonly TONEMAPPING_ACES: number;
        /**
         * Color curves setup used in the effect if colorCurvesEnabled is set to true
         */
        colorCurves: Nullable<ColorCurves>;
        private _colorCurvesEnabled;
        /**
         * Gets wether the color curves effect is enabled.
         */
        get colorCurvesEnabled(): boolean;
        /**
         * Sets wether the color curves effect is enabled.
         */
        set colorCurvesEnabled(value: boolean);
        private _colorGradingTexture;
        /**
         * Color grading LUT texture used in the effect if colorGradingEnabled is set to true
         */
        get colorGradingTexture(): Nullable<BaseTexture>;
        /**
         * Color grading LUT texture used in the effect if colorGradingEnabled is set to true
         */
        set colorGradingTexture(value: Nullable<BaseTexture>);
        private _colorGradingEnabled;
        /**
         * Gets wether the color grading effect is enabled.
         */
        get colorGradingEnabled(): boolean;
        /**
         * Sets wether the color grading effect is enabled.
         */
        set colorGradingEnabled(value: boolean);
        private _colorGradingWithGreenDepth;
        /**
         * Gets wether the color grading effect is using a green depth for the 3d Texture.
         */
        get colorGradingWithGreenDepth(): boolean;
        /**
         * Sets wether the color grading effect is using a green depth for the 3d Texture.
         */
        set colorGradingWithGreenDepth(value: boolean);
        private _colorGradingBGR;
        /**
         * Gets wether the color grading texture contains BGR values.
         */
        get colorGradingBGR(): boolean;
        /**
         * Sets wether the color grading texture contains BGR values.
         */
        set colorGradingBGR(value: boolean);
        /** @hidden */
        _exposure: number;
        /**
         * Gets the Exposure used in the effect.
         */
        get exposure(): number;
        /**
         * Sets the Exposure used in the effect.
         */
        set exposure(value: number);
        private _toneMappingEnabled;
        /**
         * Gets wether the tone mapping effect is enabled.
         */
        get toneMappingEnabled(): boolean;
        /**
         * Sets wether the tone mapping effect is enabled.
         */
        set toneMappingEnabled(value: boolean);
        private _toneMappingType;
        /**
         * Gets the type of tone mapping effect.
         */
        get toneMappingType(): number;
        /**
         * Sets the type of tone mapping effect used in BabylonJS.
         */
        set toneMappingType(value: number);
        protected _contrast: number;
        /**
         * Gets the contrast used in the effect.
         */
        get contrast(): number;
        /**
         * Sets the contrast used in the effect.
         */
        set contrast(value: number);
        /**
         * Vignette stretch size.
         */
        vignetteStretch: number;
        /**
         * Vignette centre X Offset.
         */
        vignetteCentreX: number;
        /**
         * Vignette centre Y Offset.
         */
        vignetteCentreY: number;
        /**
         * Vignette weight or intensity of the vignette effect.
         */
        vignetteWeight: number;
        /**
         * Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
         * if vignetteEnabled is set to true.
         */
        vignetteColor: Color4;
        /**
         * Camera field of view used by the Vignette effect.
         */
        vignetteCameraFov: number;
        private _vignetteBlendMode;
        /**
         * Gets the vignette blend mode allowing different kind of effect.
         */
        get vignetteBlendMode(): number;
        /**
         * Sets the vignette blend mode allowing different kind of effect.
         */
        set vignetteBlendMode(value: number);
        private _vignetteEnabled;
        /**
         * Gets wether the vignette effect is enabled.
         */
        get vignetteEnabled(): boolean;
        /**
         * Sets wether the vignette effect is enabled.
         */
        set vignetteEnabled(value: boolean);
        private _applyByPostProcess;
        /**
         * Gets wether the image processing is applied through a post process or not.
         */
        get applyByPostProcess(): boolean;
        /**
         * Sets wether the image processing is applied through a post process or not.
         */
        set applyByPostProcess(value: boolean);
        private _isEnabled;
        /**
         * Gets wether the image processing is enabled or not.
         */
        get isEnabled(): boolean;
        /**
         * Sets wether the image processing is enabled or not.
         */
        set isEnabled(value: boolean);
        /**
        * An event triggered when the configuration changes and requires Shader to Update some parameters.
        */
        onUpdateParameters: Observable<ImageProcessingConfiguration>;
        /**
         * Method called each time the image processing information changes requires to recompile the effect.
         */
        protected _updateParameters(): void;
        /**
         * Gets the current class name.
         * @return "ImageProcessingConfiguration"
         */
        getClassName(): string;
        /**
         * Prepare the list of uniforms associated with the Image Processing effects.
         * @param uniforms The list of uniforms used in the effect
         * @param defines the list of defines currently in use
         */
        static PrepareUniforms(uniforms: string[], defines: IImageProcessingConfigurationDefines): void;
        /**
         * Prepare the list of samplers associated with the Image Processing effects.
         * @param samplersList The list of uniforms used in the effect
         * @param defines the list of defines currently in use
         */
        static PrepareSamplers(samplersList: string[], defines: IImageProcessingConfigurationDefines): void;
        /**
         * Prepare the list of defines associated to the shader.
         * @param defines the list of defines to complete
         * @param forPostProcess Define if we are currently in post process mode or not
         */
        prepareDefines(defines: IImageProcessingConfigurationDefines, forPostProcess?: boolean): void;
        /**
         * Returns true if all the image processing information are ready.
         * @returns True if ready, otherwise, false
         */
        isReady(): boolean;
        /**
         * Binds the image processing to the shader.
         * @param effect The effect to bind to
         * @param overrideAspectRatio Override the aspect ratio of the effect
         */
        bind(effect: Effect, overrideAspectRatio?: number): void;
        /**
         * Clones the current image processing instance.
         * @return The cloned image processing
         */
        clone(): ImageProcessingConfiguration;
        /**
         * Serializes the current image processing instance to a json representation.
         * @return a JSON representation
         */
        serialize(): any;
        /**
         * Parses the image processing from a json representation.
         * @param source the JSON source to parse
         * @return The parsed image processing
         */
        static Parse(source: any): ImageProcessingConfiguration;
        private static _VIGNETTEMODE_MULTIPLY;
        private static _VIGNETTEMODE_OPAQUE;
        /**
         * Used to apply the vignette as a mix with the pixel color.
         */
        static get VIGNETTEMODE_MULTIPLY(): number;
        /**
         * Used to apply the vignette as a replacement of the pixel color.
         */
        static get VIGNETTEMODE_OPAQUE(): number;
    }
}
declare module BABYLON {
    /** @hidden */
    export var postprocessVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Type used to define a render target texture size (either with a number or with a rect width and height)
     */
    export type RenderTargetTextureSize = number | {
        width: number;
        height: number;
        layers?: number;
    };
        interface ThinEngine {
            /**
             * Creates a new render target texture
             * @param size defines the size of the texture
             * @param options defines the options used to create the texture
             * @returns a new render target texture stored in an InternalTexture
             */
            createRenderTargetTexture(size: RenderTargetTextureSize, options: boolean | RenderTargetCreationOptions): InternalTexture;
            /**
             * Creates a depth stencil texture.
             * This is only available in WebGL 2 or with the depth texture extension available.
             * @param size The size of face edge in the texture.
             * @param options The options defining the texture.
             * @returns The texture
             */
            createDepthStencilTexture(size: RenderTargetTextureSize, options: DepthTextureCreationOptions): InternalTexture;
            /** @hidden */
            _createDepthStencilTexture(size: RenderTargetTextureSize, options: DepthTextureCreationOptions): InternalTexture;
        }
}
declare module BABYLON {
    /**
     * Defines the kind of connection point for node based material
     */
    export enum NodeMaterialBlockConnectionPointTypes {
        /** Float */
        Float = 1,
        /** Int */
        Int = 2,
        /** Vector2 */
        Vector2 = 4,
        /** Vector3 */
        Vector3 = 8,
        /** Vector4 */
        Vector4 = 16,
        /** Color3 */
        Color3 = 32,
        /** Color4 */
        Color4 = 64,
        /** Matrix */
        Matrix = 128,
        /** Custom object */
        Object = 256,
        /** Detect type based on connection */
        AutoDetect = 1024,
        /** Output type that will be defined by input type */
        BasedOnInput = 2048
    }
}
declare module BABYLON {
    /**
     * Enum used to define the target of a block
     */
    export enum NodeMaterialBlockTargets {
        /** Vertex shader */
        Vertex = 1,
        /** Fragment shader */
        Fragment = 2,
        /** Neutral */
        Neutral = 4,
        /** Vertex and Fragment */
        VertexAndFragment = 3
    }
}
declare module BABYLON {
    /**
     * Enum defining the mode of a NodeMaterialBlockConnectionPoint
     */
    export enum NodeMaterialBlockConnectionPointMode {
        /** Value is an uniform */
        Uniform = 0,
        /** Value is a mesh attribute */
        Attribute = 1,
        /** Value is a varying between vertex and fragment shaders */
        Varying = 2,
        /** Mode is undefined */
        Undefined = 3
    }
}
declare module BABYLON {
    /**
     * Enum used to define system values e.g. values automatically provided by the system
     */
    export enum NodeMaterialSystemValues {
        /** World */
        World = 1,
        /** View */
        View = 2,
        /** Projection */
        Projection = 3,
        /** ViewProjection */
        ViewProjection = 4,
        /** WorldView */
        WorldView = 5,
        /** WorldViewProjection */
        WorldViewProjection = 6,
        /** CameraPosition */
        CameraPosition = 7,
        /** Fog Color */
        FogColor = 8,
        /** Delta time */
        DeltaTime = 9
    }
}
declare module BABYLON {
    /** Defines supported spaces */
    export enum Space {
        /** Local (object) space */
        LOCAL = 0,
        /** World space */
        WORLD = 1,
        /** Bone space */
        BONE = 2
    }
    /** Defines the 3 main axes */
    export class Axis {
        /** X axis */
        static X: Vector3;
        /** Y axis */
        static Y: Vector3;
        /** Z axis */
        static Z: Vector3;
    }
}
declare module BABYLON {
    /**
     * Represents a camera frustum
     */
    export class Frustum {
        /**
         * Gets the planes representing the frustum
         * @param transform matrix to be applied to the returned planes
         * @returns a new array of 6 Frustum planes computed by the given transformation matrix.
         */
        static GetPlanes(transform: DeepImmutable<Matrix>): Plane[];
        /**
         * Gets the near frustum plane transformed by the transform matrix
         * @param transform transformation matrix to be applied to the resulting frustum plane
         * @param frustumPlane the resuling frustum plane
         */
        static GetNearPlaneToRef(transform: DeepImmutable<Matrix>, frustumPlane: Plane): void;
        /**
         * Gets the far frustum plane transformed by the transform matrix
         * @param transform transformation matrix to be applied to the resulting frustum plane
         * @param frustumPlane the resuling frustum plane
         */
        static GetFarPlaneToRef(transform: DeepImmutable<Matrix>, frustumPlane: Plane): void;
        /**
         * Gets the left frustum plane transformed by the transform matrix
         * @param transform transformation matrix to be applied to the resulting frustum plane
         * @param frustumPlane the resuling frustum plane
         */
        static GetLeftPlaneToRef(transform: DeepImmutable<Matrix>, frustumPlane: Plane): void;
        /**
         * Gets the right frustum plane transformed by the transform matrix
         * @param transform transformation matrix to be applied to the resulting frustum plane
         * @param frustumPlane the resuling frustum plane
         */
        static GetRightPlaneToRef(transform: DeepImmutable<Matrix>, frustumPlane: Plane): void;
        /**
         * Gets the top frustum plane transformed by the transform matrix
         * @param transform transformation matrix to be applied to the resulting frustum plane
         * @param frustumPlane the resuling frustum plane
         */
        static GetTopPlaneToRef(transform: DeepImmutable<Matrix>, frustumPlane: Plane): void;
        /**
         * Gets the bottom frustum plane transformed by the transform matrix
         * @param transform transformation matrix to be applied to the resulting frustum plane
         * @param frustumPlane the resuling frustum plane
         */
        static GetBottomPlaneToRef(transform: DeepImmutable<Matrix>, frustumPlane: Plane): void;
        /**
         * Sets the given array "frustumPlanes" with the 6 Frustum planes computed by the given transformation matrix.
         * @param transform transformation matrix to be applied to the resulting frustum planes
         * @param frustumPlanes the resuling frustum planes
         */
        static GetPlanesToRef(transform: DeepImmutable<Matrix>, frustumPlanes: Plane[]): void;
    }
}
declare module BABYLON {
    /**
     * Interface for the size containing width and height
     */
    export interface ISize {
        /**
         * Width
         */
        width: number;
        /**
         * Heighht
         */
        height: number;
    }
    /**
     * Size containing widht and height
     */
    export class Size implements ISize {
        /**
         * Width
         */
        width: number;
        /**
         * Height
         */
        height: number;
        /**
         * Creates a Size object from the given width and height (floats).
         * @param width width of the new size
         * @param height height of the new size
         */
        constructor(width: number, height: number);
        /**
         * Returns a string with the Size width and height
         * @returns a string with the Size width and height
         */
        toString(): string;
        /**
         * "Size"
         * @returns the string "Size"
         */
        getClassName(): string;
        /**
         * Returns the Size hash code.
         * @returns a hash code for a unique width and height
         */
        getHashCode(): number;
        /**
         * Updates the current size from the given one.
         * @param src the given size
         */
        copyFrom(src: Size): void;
        /**
         * Updates in place the current Size from the given floats.
         * @param width width of the new size
         * @param height height of the new size
         * @returns the updated Size.
         */
        copyFromFloats(width: number, height: number): Size;
        /**
         * Updates in place the current Size from the given floats.
         * @param width width to set
         * @param height height to set
         * @returns the updated Size.
         */
        set(width: number, height: number): Size;
        /**
         * Multiplies the width and height by numbers
         * @param w factor to multiple the width by
         * @param h factor to multiple the height by
         * @returns a new Size set with the multiplication result of the current Size and the given floats.
         */
        multiplyByFloats(w: number, h: number): Size;
        /**
         * Clones the size
         * @returns a new Size copied from the given one.
         */
        clone(): Size;
        /**
         * True if the current Size and the given one width and height are strictly equal.
         * @param other the other size to compare against
         * @returns True if the current Size and the given one width and height are strictly equal.
         */
        equals(other: Size): boolean;
        /**
         * The surface of the Size : width * height (float).
         */
        get surface(): number;
        /**
         * Create a new size of zero
         * @returns a new Size set to (0.0, 0.0)
         */
        static Zero(): Size;
        /**
         * Sums the width and height of two sizes
         * @param otherSize size to add to this size
         * @returns a new Size set as the addition result of the current Size and the given one.
         */
        add(otherSize: Size): Size;
        /**
         * Subtracts the width and height of two
         * @param otherSize size to subtract to this size
         * @returns a new Size set as the subtraction result of  the given one from the current Size.
         */
        subtract(otherSize: Size): Size;
        /**
         * Creates a new Size set at the linear interpolation "amount" between "start" and "end"
         * @param start starting size to lerp between
         * @param end end size to lerp between
         * @param amount amount to lerp between the start and end values
         * @returns a new Size set at the linear interpolation "amount" between "start" and "end"
         */
        static Lerp(start: Size, end: Size, amount: number): Size;
    }
}
declare module BABYLON {
    /**
     * Contains position and normal vectors for a vertex
     */
    export class PositionNormalVertex {
        /** the position of the vertex (defaut: 0,0,0) */
        position: Vector3;
        /** the normal of the vertex (defaut: 0,1,0) */
        normal: Vector3;
        /**
         * Creates a PositionNormalVertex
         * @param position the position of the vertex (defaut: 0,0,0)
         * @param normal the normal of the vertex (defaut: 0,1,0)
         */
        constructor(
        /** the position of the vertex (defaut: 0,0,0) */
        position?: Vector3, 
        /** the normal of the vertex (defaut: 0,1,0) */
        normal?: Vector3);
        /**
         * Clones the PositionNormalVertex
         * @returns the cloned PositionNormalVertex
         */
        clone(): PositionNormalVertex;
    }
    /**
     * Contains position, normal and uv vectors for a vertex
     */
    export class PositionNormalTextureVertex {
        /** the position of the vertex (defaut: 0,0,0) */
        position: Vector3;
        /** the normal of the vertex (defaut: 0,1,0) */
        normal: Vector3;
        /** the uv of the vertex (default: 0,0) */
        uv: Vector2;
        /**
         * Creates a PositionNormalTextureVertex
         * @param position the position of the vertex (defaut: 0,0,0)
         * @param normal the normal of the vertex (defaut: 0,1,0)
         * @param uv the uv of the vertex (default: 0,0)
         */
        constructor(
        /** the position of the vertex (defaut: 0,0,0) */
        position?: Vector3, 
        /** the normal of the vertex (defaut: 0,1,0) */
        normal?: Vector3, 
        /** the uv of the vertex (default: 0,0) */
        uv?: Vector2);
        /**
         * Clones the PositionNormalTextureVertex
         * @returns the cloned PositionNormalTextureVertex
         */
        clone(): PositionNormalTextureVertex;
    }
}
declare module BABYLON {
    /**
     * Enum defining the type of animations supported by InputBlock
     */
    export enum AnimatedInputBlockTypes {
        /** No animation */
        None = 0,
        /** Time based animation. Will only work for floats */
        Time = 1
    }
}
declare module BABYLON {
    /**
     * Interface describing all the common properties and methods a shadow light needs to implement.
     * This helps both the shadow generator and materials to genrate the corresponding shadow maps
     * as well as binding the different shadow properties to the effects.
     */
    export interface IShadowLight extends Light {
        /**
         * The light id in the scene (used in scene.findLighById for instance)
         */
        id: string;
        /**
         * The position the shdow will be casted from.
         */
        position: Vector3;
        /**
         * In 2d mode (needCube being false), the direction used to cast the shadow.
         */
        direction: Vector3;
        /**
         * The transformed position. Position of the light in world space taking parenting in account.
         */
        transformedPosition: Vector3;
        /**
         * The transformed direction. Direction of the light in world space taking parenting in account.
         */
        transformedDirection: Vector3;
        /**
         * The friendly name of the light in the scene.
         */
        name: string;
        /**
         * Defines the shadow projection clipping minimum z value.
         */
        shadowMinZ: number;
        /**
         * Defines the shadow projection clipping maximum z value.
         */
        shadowMaxZ: number;
        /**
         * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light
         * @returns true if the information has been computed, false if it does not need to (no parenting)
         */
        computeTransformedInformation(): boolean;
        /**
         * Gets the scene the light belongs to.
         * @returns The scene
         */
        getScene(): Scene;
        /**
         * Callback defining a custom Projection Matrix Builder.
         * This can be used to override the default projection matrix computation.
         */
        customProjectionMatrixBuilder: (viewMatrix: Matrix, renderList: Array<AbstractMesh>, result: Matrix) => void;
        /**
         * Sets the shadow projection matrix in parameter to the generated projection matrix.
         * @param matrix The materix to updated with the projection information
         * @param viewMatrix The transform matrix of the light
         * @param renderList The list of mesh to render in the map
         * @returns The current light
         */
        setShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): IShadowLight;
        /**
         * Gets the current depth scale used in ESM.
         * @returns The scale
         */
        getDepthScale(): number;
        /**
         * Returns whether or not the shadow generation require a cube texture or a 2d texture.
         * @returns true if a cube texture needs to be use
         */
        needCube(): boolean;
        /**
         * Detects if the projection matrix requires to be recomputed this frame.
         * @returns true if it requires to be recomputed otherwise, false.
         */
        needProjectionMatrixCompute(): boolean;
        /**
         * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.
         */
        forceProjectionMatrixCompute(): void;
        /**
         * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.
         * @param faceIndex The index of the face we are computed the direction to generate shadow
         * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true
         */
        getShadowDirection(faceIndex?: number): Vector3;
        /**
         * Gets the minZ used for shadow according to both the scene and the light.
         * @param activeCamera The camera we are returning the min for
         * @returns the depth min z
         */
        getDepthMinZ(activeCamera: Camera): number;
        /**
         * Gets the maxZ used for shadow according to both the scene and the light.
         * @param activeCamera The camera we are returning the max for
         * @returns the depth max z
         */
        getDepthMaxZ(activeCamera: Camera): number;
    }
    /**
     * Base implementation IShadowLight
     * It groups all the common behaviour in order to reduce dupplication and better follow the DRY pattern.
     */
    export abstract class ShadowLight extends Light implements IShadowLight {
        protected abstract _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void;
        protected _position: Vector3;
        protected _setPosition(value: Vector3): void;
        /**
         * Sets the position the shadow will be casted from. Also use as the light position for both
         * point and spot lights.
         */
        get position(): Vector3;
        /**
         * Sets the position the shadow will be casted from. Also use as the light position for both
         * point and spot lights.
         */
        set position(value: Vector3);
        protected _direction: Vector3;
        protected _setDirection(value: Vector3): void;
        /**
         * In 2d mode (needCube being false), gets the direction used to cast the shadow.
         * Also use as the light direction on spot and directional lights.
         */
        get direction(): Vector3;
        /**
         * In 2d mode (needCube being false), sets the direction used to cast the shadow.
         * Also use as the light direction on spot and directional lights.
         */
        set direction(value: Vector3);
        protected _shadowMinZ: number;
        /**
         * Gets the shadow projection clipping minimum z value.
         */
        get shadowMinZ(): number;
        /**
         * Sets the shadow projection clipping minimum z value.
         */
        set shadowMinZ(value: number);
        protected _shadowMaxZ: number;
        /**
         * Sets the shadow projection clipping maximum z value.
         */
        get shadowMaxZ(): number;
        /**
         * Gets the shadow projection clipping maximum z value.
         */
        set shadowMaxZ(value: number);
        /**
         * Callback defining a custom Projection Matrix Builder.
         * This can be used to override the default projection matrix computation.
         */
        customProjectionMatrixBuilder: (viewMatrix: Matrix, renderList: Array<AbstractMesh>, result: Matrix) => void;
        /**
         * The transformed position. Position of the light in world space taking parenting in account.
         */
        transformedPosition: Vector3;
        /**
         * The transformed direction. Direction of the light in world space taking parenting in account.
         */
        transformedDirection: Vector3;
        private _needProjectionMatrixCompute;
        /**
         * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light
         * @returns true if the information has been computed, false if it does not need to (no parenting)
         */
        computeTransformedInformation(): boolean;
        /**
         * Return the depth scale used for the shadow map.
         * @returns the depth scale.
         */
        getDepthScale(): number;
        /**
         * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.
         * @param faceIndex The index of the face we are computed the direction to generate shadow
         * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true
         */
        getShadowDirection(faceIndex?: number): Vector3;
        /**
         * Returns the ShadowLight absolute position in the World.
         * @returns the position vector in world space
         */
        getAbsolutePosition(): Vector3;
        /**
         * Sets the ShadowLight direction toward the passed target.
         * @param target The point to target in local space
         * @returns the updated ShadowLight direction
         */
        setDirectionToTarget(target: Vector3): Vector3;
        /**
         * Returns the light rotation in euler definition.
         * @returns the x y z rotation in local space.
         */
        getRotation(): Vector3;
        /**
         * Returns whether or not the shadow generation require a cube texture or a 2d texture.
         * @returns true if a cube texture needs to be use
         */
        needCube(): boolean;
        /**
         * Detects if the projection matrix requires to be recomputed this frame.
         * @returns true if it requires to be recomputed otherwise, false.
         */
        needProjectionMatrixCompute(): boolean;
        /**
         * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.
         */
        forceProjectionMatrixCompute(): void;
        /** @hidden */
        _initCache(): void;
        /** @hidden */
        _isSynchronized(): boolean;
        /**
         * Computes the world matrix of the node
         * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch
         * @returns the world matrix
         */
        computeWorldMatrix(force?: boolean): Matrix;
        /**
         * Gets the minZ used for shadow according to both the scene and the light.
         * @param activeCamera The camera we are returning the min for
         * @returns the depth min z
         */
        getDepthMinZ(activeCamera: Camera): number;
        /**
         * Gets the maxZ used for shadow according to both the scene and the light.
         * @param activeCamera The camera we are returning the max for
         * @returns the depth max z
         */
        getDepthMaxZ(activeCamera: Camera): number;
        /**
         * Sets the shadow projection matrix in parameter to the generated projection matrix.
         * @param matrix The materix to updated with the projection information
         * @param viewMatrix The transform matrix of the light
         * @param renderList The list of mesh to render in the map
         * @returns The current light
         */
        setShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): IShadowLight;
    }
}
declare module BABYLON {
    /** @hidden */
    export var packingFunctions: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var bayerDitherFunctions: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var shadowMapFragmentDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var clipPlaneFragmentDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var clipPlaneFragment: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var shadowMapFragment: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var shadowMapPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var bonesDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var morphTargetsVertexGlobalDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var morphTargetsVertexDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var instancesDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var helperFunctions: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var shadowMapVertexDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var clipPlaneVertexDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var morphTargetsVertex: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var instancesVertex: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var bonesVertex: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var shadowMapVertexNormalBias: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var shadowMapVertexMetric: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var clipPlaneVertex: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var shadowMapVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var depthBoxBlurPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var shadowMapFragmentSoftTransparentShadow: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * EffectFallbacks can be used to add fallbacks (properties to disable) to certain properties when desired to improve performance.
     * (Eg. Start at high quality with reflection and fog, if fps is low, remove reflection, if still low remove fog)
     */
    export class EffectFallbacks implements IEffectFallbacks {
        private _defines;
        private _currentRank;
        private _maxRank;
        private _mesh;
        /**
         * Removes the fallback from the bound mesh.
         */
        unBindMesh(): void;
        /**
         * Adds a fallback on the specified property.
         * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)
         * @param define The name of the define in the shader
         */
        addFallback(rank: number, define: string): void;
        /**
         * Sets the mesh to use CPU skinning when needing to fallback.
         * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)
         * @param mesh The mesh to use the fallbacks.
         */
        addCPUSkinningFallback(rank: number, mesh: AbstractMesh): void;
        /**
         * Checks to see if more fallbacks are still availible.
         */
        get hasMoreFallbacks(): boolean;
        /**
         * Removes the defines that should be removed when falling back.
         * @param currentDefines defines the current define statements for the shader.
         * @param effect defines the current effect we try to compile
         * @returns The resulting defines with defines of the current rank removed.
         */
        reduce(currentDefines: string, effect: Effect): string;
    }
}
declare module BABYLON {
    /**
     * Interface used to define Action
     */
    export interface IAction {
        /**
       * Trigger for the action
       */
        trigger: number;
        /** Options of the trigger */
        triggerOptions: any;
        /**
         * Gets the trigger parameters
         * @returns the trigger parameters
         */
        getTriggerParameter(): any;
        /**
         * Internal only - executes current action event
         * @hidden
         */
        _executeCurrent(evt?: ActionEvent): void;
        /**
         * Serialize placeholder for child classes
         * @param parent of child
         * @returns the serialized object
         */
        serialize(parent: any): any;
        /**
        * Internal only
        * @hidden
        */
        _prepare(): void;
        /**
         * Internal only - manager for action
         * @hidden
         */
        _actionManager: Nullable<AbstractActionManager>;
        /**
         * Adds action to chain of actions, may be a DoNothingAction
         * @param action defines the next action to execute
         * @returns The action passed in
         * @see https://www.babylonjs-playground.com/#1T30HR#0
         */
        then(action: IAction): IAction;
    }
    /**
     * The action to be carried out following a trigger
     * @see https://doc.babylonjs.com/how_to/how_to_use_actions#available-actions
     */
    export class Action implements IAction {
        /** the trigger, with or without parameters, for the action */
        triggerOptions: any;
        /**
         * Trigger for the action
         */
        trigger: number;
        /**
         * Internal only - manager for action
         * @hidden
         */
        _actionManager: ActionManager;
        private _nextActiveAction;
        private _child;
        private _condition?;
        private _triggerParameter;
        /**
        * An event triggered prior to action being executed.
        */
        onBeforeExecuteObservable: Observable<Action>;
        /**
         * Creates a new Action
         * @param triggerOptions the trigger, with or without parameters, for the action
         * @param condition an optional determinant of action
         */
        constructor(
        /** the trigger, with or without parameters, for the action */
        triggerOptions: any, condition?: Condition);
        /**
         * Internal only
         * @hidden
         */
        _prepare(): void;
        /**
         * Gets the trigger parameters
         * @returns the trigger parameters
         */
        getTriggerParameter(): any;
        /**
         * Internal only - executes current action event
         * @hidden
         */
        _executeCurrent(evt?: ActionEvent): void;
        /**
         * Execute placeholder for child classes
         * @param evt optional action event
         */
        execute(evt?: ActionEvent): void;
        /**
         * Skips to next active action
         */
        skipToNextActiveAction(): void;
        /**
         * Adds action to chain of actions, may be a DoNothingAction
         * @param action defines the next action to execute
         * @returns The action passed in
         * @see https://www.babylonjs-playground.com/#1T30HR#0
         */
        then(action: Action): Action;
        /**
         * Internal only
         * @hidden
         */
        _getProperty(propertyPath: string): string;
        /**
         * Internal only
         * @hidden
         */
        _getEffectiveTarget(target: any, propertyPath: string): any;
        /**
         * Serialize placeholder for child classes
         * @param parent of child
         * @returns the serialized object
         */
        serialize(parent: any): any;
        /**
         * Internal only called by serialize
         * @hidden
         */
        protected _serialize(serializedAction: any, parent?: any): any;
        /**
         * Internal only
         * @hidden
         */
        static _SerializeValueAsString: (value: any) => string;
        /**
         * Internal only
         * @hidden
         */
        static _GetTargetProperty: (target: Scene | Node) => {
            name: string;
            targetType: string;
            value: string;
        };
    }
}
declare module BABYLON {
    /**
     * A Condition applied to an Action
     */
    export class Condition {
        /**
         * Internal only - manager for action
         * @hidden
         */
        _actionManager: ActionManager;
        /**
         * Internal only
         * @hidden
         */
        _evaluationId: number;
        /**
         * Internal only
         * @hidden
         */
        _currentResult: boolean;
        /**
         * Creates a new Condition
         * @param actionManager the manager of the action the condition is applied to
         */
        constructor(actionManager: ActionManager);
        /**
         * Check if the current condition is valid
         * @returns a boolean
         */
        isValid(): boolean;
        /**
         * Internal only
         * @hidden
         */
        _getProperty(propertyPath: string): string;
        /**
         * Internal only
         * @hidden
         */
        _getEffectiveTarget(target: any, propertyPath: string): any;
        /**
         * Serialize placeholder for child classes
         * @returns the serialized object
         */
        serialize(): any;
        /**
         * Internal only
         * @hidden
         */
        protected _serialize(serializedCondition: any): any;
    }
    /**
     * Defines specific conditional operators as extensions of Condition
     */
    export class ValueCondition extends Condition {
        /** path to specify the property of the target the conditional operator uses  */
        propertyPath: string;
        /** the value compared by the conditional operator against the current value of the property */
        value: any;
        /** the conditional operator, default ValueCondition.IsEqual */
        operator: number;
        /**
         * Internal only
         * @hidden
         */
        private static _IsEqual;
        /**
         * Internal only
         * @hidden
         */
        private static _IsDifferent;
        /**
         * Internal only
         * @hidden
         */
        private static _IsGreater;
        /**
         * Internal only
         * @hidden
         */
        private static _IsLesser;
        /**
         * returns the number for IsEqual
         */
        static get IsEqual(): number;
        /**
         * Returns the number for IsDifferent
         */
        static get IsDifferent(): number;
        /**
         * Returns the number for IsGreater
         */
        static get IsGreater(): number;
        /**
         * Returns the number for IsLesser
         */
        static get IsLesser(): number;
        /**
         * Internal only The action manager for the condition
         * @hidden
         */
        _actionManager: ActionManager;
        /**
         * Internal only
         * @hidden
         */
        private _target;
        /**
         * Internal only
         * @hidden
         */
        private _effectiveTarget;
        /**
         * Internal only
         * @hidden
         */
        private _property;
        /**
         * Creates a new ValueCondition
         * @param actionManager manager for the action the condition applies to
         * @param target for the action
         * @param propertyPath path to specify the property of the target the conditional operator uses
         * @param value the value compared by the conditional operator against the current value of the property
         * @param operator the conditional operator, default ValueCondition.IsEqual
         */
        constructor(actionManager: ActionManager, target: any, 
        /** path to specify the property of the target the conditional operator uses  */
        propertyPath: string, 
        /** the value compared by the conditional operator against the current value of the property */
        value: any, 
        /** the conditional operator, default ValueCondition.IsEqual */
        operator?: number);
        /**
         * Compares the given value with the property value for the specified conditional operator
         * @returns the result of the comparison
         */
        isValid(): boolean;
        /**
         * Serialize the ValueCondition into a JSON compatible object
         * @returns serialization object
         */
        serialize(): any;
        /**
         * Gets the name of the conditional operator for the ValueCondition
         * @param operator the conditional operator
         * @returns the name
         */
        static GetOperatorName(operator: number): string;
    }
    /**
     * Defines a predicate condition as an extension of Condition
     */
    export class PredicateCondition extends Condition {
        /** defines the predicate function used to validate the condition */
        predicate: () => boolean;
        /**
         * Internal only - manager for action
         * @hidden
         */
        _actionManager: ActionManager;
        /**
         * Creates a new PredicateCondition
         * @param actionManager manager for the action the condition applies to
         * @param predicate defines the predicate function used to validate the condition
         */
        constructor(actionManager: ActionManager, 
        /** defines the predicate function used to validate the condition */
        predicate: () => boolean);
        /**
         * @returns the validity of the predicate condition
         */
        isValid(): boolean;
    }
    /**
     * Defines a state condition as an extension of Condition
     */
    export class StateCondition extends Condition {
        /** Value to compare with target state  */
        value: string;
        /**
         * Internal only - manager for action
         * @hidden
         */
        _actionManager: ActionManager;
        /**
         * Internal only
         * @hidden
         */
        private _target;
        /**
         * Creates a new StateCondition
         * @param actionManager manager for the action the condition applies to
         * @param target of the condition
         * @param value to compare with target state
         */
        constructor(actionManager: ActionManager, target: any, 
        /** Value to compare with target state  */
        value: string);
        /**
         * Gets a boolean indicating if the current condition is met
         * @returns the validity of the state
         */
        isValid(): boolean;
        /**
         * Serialize the StateCondition into a JSON compatible object
         * @returns serialization object
         */
        serialize(): any;
    }
}
declare module BABYLON {
    /**
     * This defines an action responsible to toggle a boolean once triggered.
     * @see https://doc.babylonjs.com/how_to/how_to_use_actions
     */
    export class SwitchBooleanAction extends Action {
        /**
         * The path to the boolean property in the target object
         */
        propertyPath: string;
        private _target;
        private _effectiveTarget;
        private _property;
        /**
         * Instantiate the action
         * @param triggerOptions defines the trigger options
         * @param target defines the object containing the boolean
         * @param propertyPath defines the path to the boolean property in the target object
         * @param condition defines the trigger related conditions
         */
        constructor(triggerOptions: any, target: any, propertyPath: string, condition?: Condition);
        /** @hidden */
        _prepare(): void;
        /**
         * Execute the action toggle the boolean value.
         */
        execute(): void;
        /**
         * Serializes the actions and its related information.
         * @param parent defines the object to serialize in
         * @returns the serialized object
         */
        serialize(parent: any): any;
    }
    /**
     * This defines an action responsible to set a the state field of the target
     *  to a desired value once triggered.
     * @see https://doc.babylonjs.com/how_to/how_to_use_actions
     */
    export class SetStateAction extends Action {
        /**
         * The value to store in the state field.
         */
        value: string;
        private _target;
        /**
         * Instantiate the action
         * @param triggerOptions defines the trigger options
         * @param target defines the object containing the state property
         * @param value defines the value to store in the state field
         * @param condition defines the trigger related conditions
         */
        constructor(triggerOptions: any, target: any, value: string, condition?: Condition);
        /**
         * Execute the action and store the value on the target state property.
         */
        execute(): void;
        /**
         * Serializes the actions and its related information.
         * @param parent defines the object to serialize in
         * @returns the serialized object
         */
        serialize(parent: any): any;
    }
    /**
     * This defines an action responsible to set a property of the target
     *  to a desired value once triggered.
     * @see https://doc.babylonjs.com/how_to/how_to_use_actions
     */
    export class SetValueAction extends Action {
        /**
         * The path of the property to set in the target.
         */
        propertyPath: string;
        /**
         * The value to set in the property
         */
        value: any;
        private _target;
        private _effectiveTarget;
        private _property;
        /**
         * Instantiate the action
         * @param triggerOptions defines the trigger options
         * @param target defines the object containing the property
         * @param propertyPath defines the path of the property to set in the target
         * @param value defines the value to set in the property
         * @param condition defines the trigger related conditions
         */
        constructor(triggerOptions: any, target: any, propertyPath: string, value: any, condition?: Condition);
        /** @hidden */
        _prepare(): void;
        /**
         * Execute the action and set the targetted property to the desired value.
         */
        execute(): void;
        /**
         * Serializes the actions and its related information.
         * @param parent defines the object to serialize in
         * @returns the serialized object
         */
        serialize(parent: any): any;
    }
    /**
     * This defines an action responsible to increment the target value
     *  to a desired value once triggered.
     * @see https://doc.babylonjs.com/how_to/how_to_use_actions
     */
    export class IncrementValueAction extends Action {
        /**
         * The path of the property to increment in the target.
         */
        propertyPath: string;
        /**
         * The value we should increment the property by.
         */
        value: any;
        private _target;
        private _effectiveTarget;
        private _property;
        /**
         * Instantiate the action
         * @param triggerOptions defines the trigger options
         * @param target defines the object containing the property
         * @param propertyPath defines the path of the property to increment in the target
         * @param value defines the value value we should increment the property by
         * @param condition defines the trigger related conditions
         */
        constructor(triggerOptions: any, target: any, propertyPath: string, value: any, condition?: Condition);
        /** @hidden */
        _prepare(): void;
        /**
         * Execute the action and increment the target of the value amount.
         */
        execute(): void;
        /**
         * Serializes the actions and its related information.
         * @param parent defines the object to serialize in
         * @returns the serialized object
         */
        serialize(parent: any): any;
    }
    /**
     * This defines an action responsible to start an animation once triggered.
     * @see https://doc.babylonjs.com/how_to/how_to_use_actions
     */
    export class PlayAnimationAction extends Action {
        /**
         * Where the animation should start (animation frame)
         */
        from: number;
        /**
         * Where the animation should stop (animation frame)
         */
        to: number;
        /**
         * Define if the animation should loop or stop after the first play.
         */
        loop?: boolean;
        private _target;
        /**
         * Instantiate the action
         * @param triggerOptions defines the trigger options
         * @param target defines the target animation or animation name
         * @param from defines from where the animation should start (animation frame)
         * @param end defines where the animation should stop (animation frame)
         * @param loop defines if the animation should loop or stop after the first play
         * @param condition defines the trigger related conditions
         */
        constructor(triggerOptions: any, target: any, from: number, to: number, loop?: boolean, condition?: Condition);
        /** @hidden */
        _prepare(): void;
        /**
         * Execute the action and play the animation.
         */
        execute(): void;
        /**
         * Serializes the actions and its related information.
         * @param parent defines the object to serialize in
         * @returns the serialized object
         */
        serialize(parent: any): any;
    }
    /**
     * This defines an action responsible to stop an animation once triggered.
     * @see https://doc.babylonjs.com/how_to/how_to_use_actions
     */
    export class StopAnimationAction extends Action {
        private _target;
        /**
         * Instantiate the action
         * @param triggerOptions defines the trigger options
         * @param target defines the target animation or animation name
         * @param condition defines the trigger related conditions
         */
        constructor(triggerOptions: any, target: any, condition?: Condition);
        /** @hidden */
        _prepare(): void;
        /**
         * Execute the action and stop the animation.
         */
        execute(): void;
        /**
         * Serializes the actions and its related information.
         * @param parent defines the object to serialize in
         * @returns the serialized object
         */
        serialize(parent: any): any;
    }
    /**
     * This defines an action responsible that does nothing once triggered.
     * @see https://doc.babylonjs.com/how_to/how_to_use_actions
     */
    export class DoNothingAction extends Action {
        /**
         * Instantiate the action
         * @param triggerOptions defines the trigger options
         * @param condition defines the trigger related conditions
         */
        constructor(triggerOptions?: any, condition?: Condition);
        /**
         * Execute the action and do nothing.
         */
        execute(): void;
        /**
         * Serializes the actions and its related information.
         * @param parent defines the object to serialize in
         * @returns the serialized object
         */
        serialize(parent: any): any;
    }
    /**
     * This defines an action responsible to trigger several actions once triggered.
     * @see https://doc.babylonjs.com/how_to/how_to_use_actions
     */
    export class CombineAction extends Action {
        /**
         * The list of aggregated animations to run.
         */
        children: Action[];
        /**
         * Instantiate the action
         * @param triggerOptions defines the trigger options
         * @param children defines the list of aggregated animations to run
         * @param condition defines the trigger related conditions
         */
        constructor(triggerOptions: any, children: Action[], condition?: Condition);
        /** @hidden */
        _prepare(): void;
        /**
         * Execute the action and executes all the aggregated actions.
         */
        execute(evt: ActionEvent): void;
        /**
         * Serializes the actions and its related information.
         * @param parent defines the object to serialize in
         * @returns the serialized object
         */
        serialize(parent: any): any;
    }
    /**
     * This defines an action responsible to run code (external event) once triggered.
     * @see https://doc.babylonjs.com/how_to/how_to_use_actions
     */
    export class ExecuteCodeAction extends Action {
        /**
         * The callback function to run.
         */
        func: (evt: ActionEvent) => void;
        /**
         * Instantiate the action
         * @param triggerOptions defines the trigger options
         * @param func defines the callback function to run
         * @param condition defines the trigger related conditions
         */
        constructor(triggerOptions: any, func: (evt: ActionEvent) => void, condition?: Condition);
        /**
         * Execute the action and run the attached code.
         */
        execute(evt: ActionEvent): void;
    }
    /**
     * This defines an action responsible to set the parent property of the target once triggered.
     * @see https://doc.babylonjs.com/how_to/how_to_use_actions
     */
    export class SetParentAction extends Action {
        private _parent;
        private _target;
        /**
         * Instantiate the action
         * @param triggerOptions defines the trigger options
         * @param target defines the target containing the parent property
         * @param parent defines from where the animation should start (animation frame)
         * @param condition defines the trigger related conditions
         */
        constructor(triggerOptions: any, target: any, parent: any, condition?: Condition);
        /** @hidden */
        _prepare(): void;
        /**
         * Execute the action and set the parent property.
         */
        execute(): void;
        /**
         * Serializes the actions and its related information.
         * @param parent defines the object to serialize in
         * @returns the serialized object
         */
        serialize(parent: any): any;
    }
}
declare module BABYLON {
    /**
     * Action Manager manages all events to be triggered on a given mesh or the global scene.
     * A single scene can have many Action Managers to handle predefined actions on specific meshes.
     * @see https://doc.babylonjs.com/how_to/how_to_use_actions
     */
    export class ActionManager extends AbstractActionManager {
        /**
         * Nothing
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly NothingTrigger: number;
        /**
         * On pick
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnPickTrigger: number;
        /**
         * On left pick
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnLeftPickTrigger: number;
        /**
         * On right pick
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnRightPickTrigger: number;
        /**
         * On center pick
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnCenterPickTrigger: number;
        /**
         * On pick down
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnPickDownTrigger: number;
        /**
         * On double pick
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnDoublePickTrigger: number;
        /**
         * On pick up
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnPickUpTrigger: number;
        /**
         * On pick out.
         * This trigger will only be raised if you also declared a OnPickDown
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnPickOutTrigger: number;
        /**
         * On long press
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnLongPressTrigger: number;
        /**
         * On pointer over
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnPointerOverTrigger: number;
        /**
         * On pointer out
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnPointerOutTrigger: number;
        /**
         * On every frame
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnEveryFrameTrigger: number;
        /**
         * On intersection enter
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnIntersectionEnterTrigger: number;
        /**
         * On intersection exit
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnIntersectionExitTrigger: number;
        /**
         * On key down
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnKeyDownTrigger: number;
        /**
         * On key up
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnKeyUpTrigger: number;
        private _scene;
        /**
         * Creates a new action manager
         * @param scene defines the hosting scene
         */
        constructor(scene: Scene);
        /**
         * Releases all associated resources
         */
        dispose(): void;
        /**
         * Gets hosting scene
         * @returns the hosting scene
         */
        getScene(): Scene;
        /**
         * Does this action manager handles actions of any of the given triggers
         * @param triggers defines the triggers to be tested
         * @return a boolean indicating whether one (or more) of the triggers is handled
         */
        hasSpecificTriggers(triggers: number[]): boolean;
        /**
         * Does this action manager handles actions of any of the given triggers. This function takes two arguments for
         * speed.
         * @param triggerA defines the trigger to be tested
         * @param triggerB defines the trigger to be tested
         * @return a boolean indicating whether one (or more) of the triggers is handled
         */
        hasSpecificTriggers2(triggerA: number, triggerB: number): boolean;
        /**
         * Does this action manager handles actions of a given trigger
         * @param trigger defines the trigger to be tested
         * @param parameterPredicate defines an optional predicate to filter triggers by parameter
         * @return whether the trigger is handled
         */
        hasSpecificTrigger(trigger: number, parameterPredicate?: (parameter: any) => boolean): boolean;
        /**
         * Does this action manager has pointer triggers
         */
        get hasPointerTriggers(): boolean;
        /**
         * Does this action manager has pick triggers
         */
        get hasPickTriggers(): boolean;
        /**
         * Registers an action to this action manager
         * @param action defines the action to be registered
         * @return the action amended (prepared) after registration
         */
        registerAction(action: IAction): Nullable<IAction>;
        /**
         * Unregisters an action to this action manager
         * @param action defines the action to be unregistered
         * @return a boolean indicating whether the action has been unregistered
         */
        unregisterAction(action: IAction): Boolean;
        /**
         * Process a specific trigger
         * @param trigger defines the trigger to process
         * @param evt defines the event details to be processed
         */
        processTrigger(trigger: number, evt?: IActionEvent): void;
        /** @hidden */
        _getEffectiveTarget(target: any, propertyPath: string): any;
        /** @hidden */
        _getProperty(propertyPath: string): string;
        /**
         * Serialize this manager to a JSON object
         * @param name defines the property name to store this manager
         * @returns a JSON representation of this manager
         */
        serialize(name: string): any;
        /**
         * Creates a new ActionManager from a JSON data
         * @param parsedActions defines the JSON data to read from
         * @param object defines the hosting mesh
         * @param scene defines the hosting scene
         */
        static Parse(parsedActions: any, object: Nullable<AbstractMesh>, scene: Scene): void;
        /**
         * Get a trigger name by index
         * @param trigger defines the trigger index
         * @returns a trigger name
         */
        static GetTriggerName(trigger: number): string;
    }
}
declare module BABYLON {
    /**
     * Class used to represent a sprite
     * @see https://doc.babylonjs.com/babylon101/sprites
     */
    export class Sprite implements IAnimatable {
        /** defines the name */
        name: string;
        /** Gets or sets the current world position */
        position: Vector3;
        /** Gets or sets the main color */
        color: Color4;
        /** Gets or sets the width */
        width: number;
        /** Gets or sets the height */
        height: number;
        /** Gets or sets rotation angle */
        angle: number;
        /** Gets or sets the cell index in the sprite sheet */
        cellIndex: number;
        /** Gets or sets the cell reference in the sprite sheet, uses sprite's filename when added to sprite sheet */
        cellRef: string;
        /** Gets or sets a boolean indicating if UV coordinates should be inverted in U axis */
        invertU: boolean;
        /** Gets or sets a boolean indicating if UV coordinates should be inverted in B axis */
        invertV: boolean;
        /** Gets or sets a boolean indicating that this sprite should be disposed after animation ends */
        disposeWhenFinishedAnimating: boolean;
        /** Gets the list of attached animations */
        animations: Nullable<Array<Animation>>;
        /** Gets or sets a boolean indicating if the sprite can be picked */
        isPickable: boolean;
        /** Gets or sets a boolean indicating that sprite texture alpha will be used for precise picking (false by default) */
        useAlphaForPicking: boolean;
        /** @hidden */
        _xOffset: number;
        /** @hidden */
        _yOffset: number;
        /** @hidden */
        _xSize: number;
        /** @hidden */
        _ySize: number;
        /**
         * Gets or sets the associated action manager
         */
        actionManager: Nullable<ActionManager>;
        /**
        * An event triggered when the control has been disposed
        */
        onDisposeObservable: Observable<Sprite>;
        private _animationStarted;
        private _loopAnimation;
        private _fromIndex;
        private _toIndex;
        private _delay;
        private _direction;
        private _manager;
        private _time;
        private _onAnimationEnd;
        /**
         * Gets or sets a boolean indicating if the sprite is visible (renderable). Default is true
         */
        isVisible: boolean;
        /**
         * Gets or sets the sprite size
         */
        get size(): number;
        set size(value: number);
        /**
         * Returns a boolean indicating if the animation is started
         */
        get animationStarted(): boolean;
        /**
         * Gets or sets the unique id of the sprite
         */
        uniqueId: number;
        /**
         * Gets the manager of this sprite
         */
        get manager(): ISpriteManager;
        /**
         * Creates a new Sprite
         * @param name defines the name
         * @param manager defines the manager
         */
        constructor(
        /** defines the name */
        name: string, manager: ISpriteManager);
        /**
         * Returns the string "Sprite"
         * @returns "Sprite"
         */
        getClassName(): string;
        /** Gets or sets the initial key for the animation (setting it will restart the animation)  */
        get fromIndex(): number;
        set fromIndex(value: number);
        /** Gets or sets the end key for the animation (setting it will restart the animation)  */
        get toIndex(): number;
        set toIndex(value: number);
        /** Gets or sets a boolean indicating if the animation is looping (setting it will restart the animation)  */
        get loopAnimation(): boolean;
        set loopAnimation(value: boolean);
        /** Gets or sets the delay between cell changes (setting it will restart the animation)  */
        get delay(): number;
        set delay(value: number);
        /**
         * Starts an animation
         * @param from defines the initial key
         * @param to defines the end key
         * @param loop defines if the animation must loop
         * @param delay defines the start delay (in ms)
         * @param onAnimationEnd defines a callback to call when animation ends
         */
        playAnimation(from: number, to: number, loop: boolean, delay: number, onAnimationEnd?: Nullable<() => void>): void;
        /** Stops current animation (if any) */
        stopAnimation(): void;
        /** @hidden */
        _animate(deltaTime: number): void;
        /** Release associated resources */
        dispose(): void;
        /**
         * Serializes the sprite to a JSON object
         * @returns the JSON object
         */
        serialize(): any;
        /**
         * Parses a JSON object to create a new sprite
         * @param parsedSprite The JSON object to parse
         * @param manager defines the hosting manager
         * @returns the new sprite
         */
        static Parse(parsedSprite: any, manager: SpriteManager): Sprite;
    }
}
declare module BABYLON {
    /**
         * Information about the result of picking within a scene
         * @see https://doc.babylonjs.com/babylon101/picking_collisions
         */
    export class PickingInfo {
        /** @hidden */
        _pickingUnavailable: boolean;
        /**
         * If the pick collided with an object
         */
        hit: boolean;
        /**
         * Distance away where the pick collided
         */
        distance: number;
        /**
         * The location of pick collision
         */
        pickedPoint: Nullable<Vector3>;
        /**
         * The mesh corresponding the the pick collision
         */
        pickedMesh: Nullable<AbstractMesh>;
        /** (See getTextureCoordinates) The barycentric U coordinate that is used when calculating the texture coordinates of the collision.*/
        bu: number;
        /** (See getTextureCoordinates) The barycentric V coordinate that is used when calculating the texture coordinates of the collision.*/
        bv: number;
        /** The index of the face on the mesh that was picked, or the index of the Line if the picked Mesh is a LinesMesh */
        faceId: number;
        /** The index of the face on the subMesh that was picked, or the index of the Line if the picked Mesh is a LinesMesh */
        subMeshFaceId: number;
        /** Id of the the submesh that was picked */
        subMeshId: number;
        /** If a sprite was picked, this will be the sprite the pick collided with */
        pickedSprite: Nullable<Sprite>;
        /** If we are pikcing a mesh with thin instance, this will give you the picked thin instance */
        thinInstanceIndex: number;
        /**
         * If a mesh was used to do the picking (eg. 6dof controller) this will be populated.
         */
        originMesh: Nullable<AbstractMesh>;
        /**
         * The ray that was used to perform the picking.
         */
        ray: Nullable<Ray>;
        /**
         * Gets the normal correspodning to the face the pick collided with
         * @param useWorldCoordinates If the resulting normal should be relative to the world (default: false)
         * @param useVerticesNormals If the vertices normals should be used to calculate the normal instead of the normal map
         * @returns The normal correspodning to the face the pick collided with
         */
        getNormal(useWorldCoordinates?: boolean, useVerticesNormals?: boolean): Nullable<Vector3>;
        /**
         * Gets the texture coordinates of where the pick occured
         * @returns the vector containing the coordnates of the texture
         */
        getTextureCoordinates(): Nullable<Vector2>;
    }
}
declare module BABYLON {
    /**
     * Class representing a ray with position and direction
     */
    export class Ray {
        /** origin point */
        origin: Vector3;
        /** direction */
        direction: Vector3;
        /** length of the ray */
        length: number;
        private static readonly _TmpVector3;
        private _tmpRay;
        /**
         * Creates a new ray
         * @param origin origin point
         * @param direction direction
         * @param length length of the ray
         */
        constructor(
        /** origin point */
        origin: Vector3, 
        /** direction */
        direction: Vector3, 
        /** length of the ray */
        length?: number);
        /**
         * Checks if the ray intersects a box
         * This does not account for the ray lenght by design to improve perfs.
         * @param minimum bound of the box
         * @param maximum bound of the box
         * @param intersectionTreshold extra extend to be added to the box in all direction
         * @returns if the box was hit
         */
        intersectsBoxMinMax(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, intersectionTreshold?: number): boolean;
        /**
         * Checks if the ray intersects a box
         * This does not account for the ray lenght by design to improve perfs.
         * @param box the bounding box to check
         * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction
         * @returns if the box was hit
         */
        intersectsBox(box: DeepImmutable<BoundingBox>, intersectionTreshold?: number): boolean;
        /**
         * If the ray hits a sphere
         * @param sphere the bounding sphere to check
         * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction
         * @returns true if it hits the sphere
         */
        intersectsSphere(sphere: DeepImmutable<BoundingSphere>, intersectionTreshold?: number): boolean;
        /**
         * If the ray hits a triange
         * @param vertex0 triangle vertex
         * @param vertex1 triangle vertex
         * @param vertex2 triangle vertex
         * @returns intersection information if hit
         */
        intersectsTriangle(vertex0: DeepImmutable<Vector3>, vertex1: DeepImmutable<Vector3>, vertex2: DeepImmutable<Vector3>): Nullable<IntersectionInfo>;
        /**
         * Checks if ray intersects a plane
         * @param plane the plane to check
         * @returns the distance away it was hit
         */
        intersectsPlane(plane: DeepImmutable<Plane>): Nullable<number>;
        /**
         * Calculate the intercept of a ray on a given axis
         * @param axis to check 'x' | 'y' | 'z'
         * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)
         * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.
         */
        intersectsAxis(axis: string, offset?: number): Nullable<Vector3>;
        /**
         * Checks if ray intersects a mesh
         * @param mesh the mesh to check
         * @param fastCheck defines if the first intersection will be used (and not the closest)
         * @returns picking info of the intersecton
         */
        intersectsMesh(mesh: DeepImmutable<AbstractMesh>, fastCheck?: boolean): PickingInfo;
        /**
         * Checks if ray intersects a mesh
         * @param meshes the meshes to check
         * @param fastCheck defines if the first intersection will be used (and not the closest)
         * @param results array to store result in
         * @returns Array of picking infos
         */
        intersectsMeshes(meshes: Array<DeepImmutable<AbstractMesh>>, fastCheck?: boolean, results?: Array<PickingInfo>): Array<PickingInfo>;
        private _comparePickingInfo;
        private static smallnum;
        private static rayl;
        /**
         * Intersection test between the ray and a given segment whithin a given tolerance (threshold)
         * @param sega the first point of the segment to test the intersection against
         * @param segb the second point of the segment to test the intersection against
         * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful
         * @return the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection
         */
        intersectionSegment(sega: DeepImmutable<Vector3>, segb: DeepImmutable<Vector3>, threshold: number): number;
        /**
         * Update the ray from viewport position
         * @param x position
         * @param y y position
         * @param viewportWidth viewport width
         * @param viewportHeight viewport height
         * @param world world matrix
         * @param view view matrix
         * @param projection projection matrix
         * @returns this ray updated
         */
        update(x: number, y: number, viewportWidth: number, viewportHeight: number, world: DeepImmutable<Matrix>, view: DeepImmutable<Matrix>, projection: DeepImmutable<Matrix>): Ray;
        /**
         * Creates a ray with origin and direction of 0,0,0
         * @returns the new ray
         */
        static Zero(): Ray;
        /**
         * Creates a new ray from screen space and viewport
         * @param x position
         * @param y y position
         * @param viewportWidth viewport width
         * @param viewportHeight viewport height
         * @param world world matrix
         * @param view view matrix
         * @param projection projection matrix
         * @returns new ray
         */
        static CreateNew(x: number, y: number, viewportWidth: number, viewportHeight: number, world: DeepImmutable<Matrix>, view: DeepImmutable<Matrix>, projection: DeepImmutable<Matrix>): Ray;
        /**
         * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be
         * transformed to the given world matrix.
         * @param origin The origin point
         * @param end The end point
         * @param world a matrix to transform the ray to. Default is the identity matrix.
         * @returns the new ray
         */
        static CreateNewFromTo(origin: Vector3, end: Vector3, world?: DeepImmutable<Matrix>): Ray;
        /**
         * Transforms a ray by a matrix
         * @param ray ray to transform
         * @param matrix matrix to apply
         * @returns the resulting new ray
         */
        static Transform(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>): Ray;
        /**
         * Transforms a ray by a matrix
         * @param ray ray to transform
         * @param matrix matrix to apply
         * @param result ray to store result in
         */
        static TransformToRef(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>, result: Ray): void;
        /**
         * Unproject a ray from screen space to object space
         * @param sourceX defines the screen space x coordinate to use
         * @param sourceY defines the screen space y coordinate to use
         * @param viewportWidth defines the current width of the viewport
         * @param viewportHeight defines the current height of the viewport
         * @param world defines the world matrix to use (can be set to Identity to go to world space)
         * @param view defines the view matrix to use
         * @param projection defines the projection matrix to use
         */
        unprojectRayToRef(sourceX: float, sourceY: float, viewportWidth: number, viewportHeight: number, world: DeepImmutable<Matrix>, view: DeepImmutable<Matrix>, projection: DeepImmutable<Matrix>): void;
    }
    /**
     * Type used to define predicate used to select faces when a mesh intersection is detected
     */
    export type TrianglePickingPredicate = (p0: Vector3, p1: Vector3, p2: Vector3, ray: Ray) => boolean;
        interface Scene {
            /** @hidden */
            _tempPickingRay: Nullable<Ray>;
            /** @hidden */
            _cachedRayForTransform: Ray;
            /** @hidden */
            _pickWithRayInverseMatrix: Matrix;
            /** @hidden */
            _internalPick(rayFunction: (world: Matrix) => Ray, predicate?: (mesh: AbstractMesh) => boolean, fastCheck?: boolean, onlyBoundingInfo?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo>;
            /** @hidden */
            _internalMultiPick(rayFunction: (world: Matrix) => Ray, predicate?: (mesh: AbstractMesh) => boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]>;
            /** @hidden */
            _internalPickForMesh(pickingInfo: Nullable<PickingInfo>, rayFunction: (world: Matrix) => Ray, mesh: AbstractMesh, world: Matrix, fastCheck?: boolean, onlyBoundingInfo?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo>;
        }
}
declare module BABYLON {
    /**
     * Groups all the scene component constants in one place to ease maintenance.
     * @hidden
     */
    export class SceneComponentConstants {
        static readonly NAME_EFFECTLAYER: string;
        static readonly NAME_LAYER: string;
        static readonly NAME_LENSFLARESYSTEM: string;
        static readonly NAME_BOUNDINGBOXRENDERER: string;
        static readonly NAME_PARTICLESYSTEM: string;
        static readonly NAME_GAMEPAD: string;
        static readonly NAME_SIMPLIFICATIONQUEUE: string;
        static readonly NAME_GEOMETRYBUFFERRENDERER: string;
        static readonly NAME_PREPASSRENDERER: string;
        static readonly NAME_DEPTHRENDERER: string;
        static readonly NAME_POSTPROCESSRENDERPIPELINEMANAGER: string;
        static readonly NAME_SPRITE: string;
        static readonly NAME_OUTLINERENDERER: string;
        static readonly NAME_PROCEDURALTEXTURE: string;
        static readonly NAME_SHADOWGENERATOR: string;
        static readonly NAME_OCTREE: string;
        static readonly NAME_PHYSICSENGINE: string;
        static readonly NAME_AUDIO: string;
        static readonly STEP_ISREADYFORMESH_EFFECTLAYER: number;
        static readonly STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER: number;
        static readonly STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER: number;
        static readonly STEP_ACTIVEMESH_BOUNDINGBOXRENDERER: number;
        static readonly STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER: number;
        static readonly STEP_BEFORECAMERADRAW_EFFECTLAYER: number;
        static readonly STEP_BEFORECAMERADRAW_LAYER: number;
        static readonly STEP_BEFORECAMERADRAW_PREPASS: number;
        static readonly STEP_BEFORERENDERTARGETDRAW_LAYER: number;
        static readonly STEP_BEFORERENDERINGMESH_OUTLINE: number;
        static readonly STEP_AFTERRENDERINGMESH_OUTLINE: number;
        static readonly STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW: number;
        static readonly STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER: number;
        static readonly STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE: number;
        static readonly STEP_BEFORECAMERAUPDATE_GAMEPAD: number;
        static readonly STEP_BEFORECLEAR_PROCEDURALTEXTURE: number;
        static readonly STEP_AFTERRENDERTARGETDRAW_LAYER: number;
        static readonly STEP_AFTERCAMERADRAW_EFFECTLAYER: number;
        static readonly STEP_AFTERCAMERADRAW_LENSFLARESYSTEM: number;
        static readonly STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW: number;
        static readonly STEP_AFTERCAMERADRAW_LAYER: number;
        static readonly STEP_AFTERCAMERADRAW_PREPASS: number;
        static readonly STEP_AFTERRENDER_AUDIO: number;
        static readonly STEP_GATHERRENDERTARGETS_DEPTHRENDERER: number;
        static readonly STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER: number;
        static readonly STEP_GATHERRENDERTARGETS_SHADOWGENERATOR: number;
        static readonly STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER: number;
        static readonly STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER: number;
        static readonly STEP_BEFORECLEARSTAGE_PREPASS: number;
        static readonly STEP_POINTERMOVE_SPRITE: number;
        static readonly STEP_POINTERDOWN_SPRITE: number;
        static readonly STEP_POINTERUP_SPRITE: number;
    }
    /**
     * This represents a scene component.
     *
     * This is used to decouple the dependency the scene is having on the different workloads like
     * layers, post processes...
     */
    export interface ISceneComponent {
        /**
         * The name of the component. Each component must have a unique name.
         */
        name: string;
        /**
         * The scene the component belongs to.
         */
        scene: Scene;
        /**
         * Register the component to one instance of a scene.
         */
        register(): void;
        /**
         * Rebuilds the elements related to this component in case of
         * context lost for instance.
         */
        rebuild(): void;
        /**
         * Disposes the component and the associated ressources.
         */
        dispose(): void;
    }
    /**
     * This represents a SERIALIZABLE scene component.
     *
     * This extends Scene Component to add Serialization methods on top.
     */
    export interface ISceneSerializableComponent extends ISceneComponent {
        /**
         * Adds all the elements from the container to the scene
         * @param container the container holding the elements
         */
        addFromContainer(container: AbstractScene): void;
        /**
         * Removes all the elements in the container from the scene
         * @param container contains the elements to remove
         * @param dispose if the removed element should be disposed (default: false)
         */
        removeFromContainer(container: AbstractScene, dispose?: boolean): void;
        /**
         * Serializes the component data to the specified json object
         * @param serializationObject The object to serialize to
         */
        serialize(serializationObject: any): void;
    }
    /**
     * Strong typing of a Mesh related stage step action
     */
    export type MeshStageAction = (mesh: AbstractMesh, hardwareInstancedRendering: boolean) => boolean;
    /**
     * Strong typing of a Evaluate Sub Mesh related stage step action
     */
    export type EvaluateSubMeshStageAction = (mesh: AbstractMesh, subMesh: SubMesh) => void;
    /**
     * Strong typing of a Active Mesh related stage step action
     */
    export type ActiveMeshStageAction = (sourceMesh: AbstractMesh, mesh: AbstractMesh) => void;
    /**
     * Strong typing of a Camera related stage step action
     */
    export type CameraStageAction = (camera: Camera) => void;
    /**
     * Strong typing of a Camera Frame buffer related stage step action
     */
    export type CameraStageFrameBufferAction = (camera: Camera) => boolean;
    /**
     * Strong typing of a Render Target related stage step action
     */
    export type RenderTargetStageAction = (renderTarget: RenderTargetTexture) => void;
    /**
     * Strong typing of a RenderingGroup related stage step action
     */
    export type RenderingGroupStageAction = (renderingGroupId: number) => void;
    /**
     * Strong typing of a Mesh Render related stage step action
     */
    export type RenderingMeshStageAction = (mesh: Mesh, subMesh: SubMesh, batch: _InstancesBatch) => void;
    /**
     * Strong typing of a simple stage step action
     */
    export type SimpleStageAction = () => void;
    /**
     * Strong typing of a render target action.
     */
    export type RenderTargetsStageAction = (renderTargets: SmartArrayNoDuplicate<RenderTargetTexture>) => void;
    /**
     * Strong typing of a pointer move action.
     */
    export type PointerMoveStageAction = (unTranslatedPointerX: number, unTranslatedPointerY: number, pickResult: Nullable<PickingInfo>, isMeshPicked: boolean, element: HTMLElement) => Nullable<PickingInfo>;
    /**
     * Strong typing of a pointer up/down action.
     */
    export type PointerUpDownStageAction = (unTranslatedPointerX: number, unTranslatedPointerY: number, pickResult: Nullable<PickingInfo>, evt: PointerEvent) => Nullable<PickingInfo>;
    /**
     * Representation of a stage in the scene (Basically a list of ordered steps)
     * @hidden
     */
    export class Stage<T extends Function> extends Array<{
        index: number;
        component: ISceneComponent;
        action: T;
    }> {
        /**
         * Hide ctor from the rest of the world.
         * @param items The items to add.
         */
        private constructor();
        /**
         * Creates a new Stage.
         * @returns A new instance of a Stage
         */
        static Create<T extends Function>(): Stage<T>;
        /**
         * Registers a step in an ordered way in the targeted stage.
         * @param index Defines the position to register the step in
         * @param component Defines the component attached to the step
         * @param action Defines the action to launch during the step
         */
        registerStep(index: number, component: ISceneComponent, action: T): void;
        /**
         * Clears all the steps from the stage.
         */
        clear(): void;
    }
}
declare module BABYLON {
        interface Scene {
            /** @hidden */
            _pointerOverSprite: Nullable<Sprite>;
            /** @hidden */
            _pickedDownSprite: Nullable<Sprite>;
            /** @hidden */
            _tempSpritePickingRay: Nullable<Ray>;
            /**
             * All of the sprite managers added to this scene
             * @see https://doc.babylonjs.com/babylon101/sprites
             */
            spriteManagers: Array<ISpriteManager>;
            /**
             * An event triggered when sprites rendering is about to start
             * Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)
             */
            onBeforeSpritesRenderingObservable: Observable<Scene>;
            /**
             * An event triggered when sprites rendering is done
             * Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)
             */
            onAfterSpritesRenderingObservable: Observable<Scene>;
            /** @hidden */
            _internalPickSprites(ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo>;
            /** Launch a ray to try to pick a sprite in the scene
             * @param x position on screen
             * @param y position on screen
             * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true
             * @param fastCheck defines if the first intersection will be used (and not the closest)
             * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used
             * @returns a PickingInfo
             */
            pickSprite(x: number, y: number, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo>;
            /** Use the given ray to pick a sprite in the scene
             * @param ray The ray (in world space) to use to pick meshes
             * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true
             * @param fastCheck defines if the first intersection will be used (and not the closest)
             * @param camera camera to use. Can be set to null. In this case, the scene.activeCamera will be used
             * @returns a PickingInfo
             */
            pickSpriteWithRay(ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo>;
            /** @hidden */
            _internalMultiPickSprites(ray: Ray, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]>;
            /** Launch a ray to try to pick sprites in the scene
             * @param x position on screen
             * @param y position on screen
             * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true
             * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used
             * @returns a PickingInfo array
             */
            multiPickSprite(x: number, y: number, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]>;
            /** Use the given ray to pick sprites in the scene
             * @param ray The ray (in world space) to use to pick meshes
             * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true
             * @param camera camera to use. Can be set to null. In this case, the scene.activeCamera will be used
             * @returns a PickingInfo array
             */
            multiPickSpriteWithRay(ray: Ray, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]>;
            /**
             * Force the sprite under the pointer
             * @param sprite defines the sprite to use
             */
            setPointerOverSprite(sprite: Nullable<Sprite>): void;
            /**
             * Gets the sprite under the pointer
             * @returns a Sprite or null if no sprite is under the pointer
             */
            getPointerOverSprite(): Nullable<Sprite>;
        }
    /**
     * Defines the sprite scene component responsible to manage sprites
     * in a given scene.
     */
    export class SpriteSceneComponent implements ISceneComponent {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        readonly name: string;
        /**
         * The scene the component belongs to.
         */
        scene: Scene;
        /** @hidden */
        private _spritePredicate;
        /**
         * Creates a new instance of the component for the given scene
         * @param scene Defines the scene to register the component in
         */
        constructor(scene: Scene);
        /**
         * Registers the component in a given scene
         */
        register(): void;
        /**
         * Rebuilds the elements related to this component in case of
         * context lost for instance.
         */
        rebuild(): void;
        /**
         * Disposes the component and the associated ressources.
         */
        dispose(): void;
        private _pickSpriteButKeepRay;
        private _pointerMove;
        private _pointerDown;
        private _pointerUp;
    }
}
declare module BABYLON {
    /** @hidden */
    export var fogFragmentDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var fogFragment: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var spritesPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var fogVertexDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var spritesVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Defines the minimum interface to fullfil in order to be a sprite manager.
     */
    export interface ISpriteManager extends IDisposable {
        /**
         * Gets manager's name
         */
        name: string;
        /**
         * Restricts the camera to viewing objects with the same layerMask.
         * A camera with a layerMask of 1 will render spriteManager.layerMask & camera.layerMask!== 0
         */
        layerMask: number;
        /**
         * Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true
         */
        isPickable: boolean;
        /**
         * Gets the hosting scene
         */
        scene: Scene;
        /**
         * Specifies the rendering group id for this mesh (0 by default)
         * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#rendering-groups
         */
        renderingGroupId: number;
        /**
         * Defines the list of sprites managed by the manager.
         */
        sprites: Array<Sprite>;
        /**
         * Gets or sets the spritesheet texture
         */
        texture: Texture;
        /** Defines the default width of a cell in the spritesheet */
        cellWidth: number;
        /** Defines the default height of a cell in the spritesheet */
        cellHeight: number;
        /**
         * Tests the intersection of a sprite with a specific ray.
         * @param ray The ray we are sending to test the collision
         * @param camera The camera space we are sending rays in
         * @param predicate A predicate allowing excluding sprites from the list of object to test
         * @param fastCheck defines if the first intersection will be used (and not the closest)
         * @returns picking info or null.
         */
        intersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean): Nullable<PickingInfo>;
        /**
         * Intersects the sprites with a ray
         * @param ray defines the ray to intersect with
         * @param camera defines the current active camera
         * @param predicate defines a predicate used to select candidate sprites
         * @returns null if no hit or a PickingInfo array
         */
        multiIntersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean): Nullable<PickingInfo[]>;
        /**
         * Renders the list of sprites on screen.
         */
        render(): void;
    }
    /**
     * Class used to manage multiple sprites on the same spritesheet
     * @see https://doc.babylonjs.com/babylon101/sprites
     */
    export class SpriteManager implements ISpriteManager {
        /** defines the manager's name */
        name: string;
        /** Define the Url to load snippets */
        static SnippetUrl: string;
        /** Snippet ID if the manager was created from the snippet server */
        snippetId: string;
        /** Gets the list of sprites */
        sprites: Sprite[];
        /** Gets or sets the rendering group id (0 by default) */
        renderingGroupId: number;
        /** Gets or sets camera layer mask */
        layerMask: number;
        /** Gets or sets a boolean indicating if the manager must consider scene fog when rendering */
        fogEnabled: boolean;
        /** Gets or sets a boolean indicating if the sprites are pickable */
        isPickable: boolean;
        /** Defines the default width of a cell in the spritesheet */
        cellWidth: number;
        /** Defines the default height of a cell in the spritesheet */
        cellHeight: number;
        /** Associative array from JSON sprite data file */
        private _cellData;
        /** Array of sprite names from JSON sprite data file */
        private _spriteMap;
        /** True when packed cell data from JSON file is ready*/
        private _packedAndReady;
        private _textureContent;
        private _useInstancing;
        /**
        * An event triggered when the manager is disposed.
        */
        onDisposeObservable: Observable<SpriteManager>;
        private _onDisposeObserver;
        /**
         * Callback called when the manager is disposed
         */
        set onDispose(callback: () => void);
        private _capacity;
        private _fromPacked;
        private _spriteTexture;
        private _epsilon;
        private _scene;
        private _vertexData;
        private _buffer;
        private _vertexBuffers;
        private _spriteBuffer;
        private _indexBuffer;
        private _effectBase;
        private _effectFog;
        private _vertexBufferSize;
        /**
         * Gets or sets the unique id of the sprite
         */
        uniqueId: number;
        /**
         * Gets the array of sprites
         */
        get children(): Sprite[];
        /**
         * Gets the hosting scene
         */
        get scene(): Scene;
        /**
         * Gets the capacity of the manager
         */
        get capacity(): number;
        /**
         * Gets or sets the spritesheet texture
         */
        get texture(): Texture;
        set texture(value: Texture);
        private _blendMode;
        /**
         * Blend mode use to render the particle, it can be any of
         * the static Constants.ALPHA_x properties provided in this class.
         * Default value is Constants.ALPHA_COMBINE
         */
        get blendMode(): number;
        set blendMode(blendMode: number);
        /** Disables writing to the depth buffer when rendering the sprites.
         *  It can be handy to disable depth writing when using textures without alpha channel
         *  and setting some specific blend modes.
        */
        disableDepthWrite: boolean;
        /**
         * Creates a new sprite manager
         * @param name defines the manager's name
         * @param imgUrl defines the sprite sheet url
         * @param capacity defines the maximum allowed number of sprites
         * @param cellSize defines the size of a sprite cell
         * @param scene defines the hosting scene
         * @param epsilon defines the epsilon value to align texture (0.01 by default)
         * @param samplingMode defines the smapling mode to use with spritesheet
         * @param fromPacked set to false; do not alter
         * @param spriteJSON null otherwise a JSON object defining sprite sheet data; do not alter
         */
        constructor(
        /** defines the manager's name */
        name: string, imgUrl: string, capacity: number, cellSize: any, scene: Scene, epsilon?: number, samplingMode?: number, fromPacked?: boolean, spriteJSON?: any | null);
        /**
         * Returns the string "SpriteManager"
         * @returns "SpriteManager"
         */
        getClassName(): string;
        private _makePacked;
        private _appendSpriteVertex;
        private _checkTextureAlpha;
        /**
         * Intersects the sprites with a ray
         * @param ray defines the ray to intersect with
         * @param camera defines the current active camera
         * @param predicate defines a predicate used to select candidate sprites
         * @param fastCheck defines if a fast check only must be done (the first potential sprite is will be used and not the closer)
         * @returns null if no hit or a PickingInfo
         */
        intersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean): Nullable<PickingInfo>;
        /**
         * Intersects the sprites with a ray
         * @param ray defines the ray to intersect with
         * @param camera defines the current active camera
         * @param predicate defines a predicate used to select candidate sprites
         * @returns null if no hit or a PickingInfo array
         */
        multiIntersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean): Nullable<PickingInfo[]>;
        /**
         * Render all child sprites
         */
        render(): void;
        /**
         * Release associated resources
         */
        dispose(): void;
        /**
         * Serializes the sprite manager to a JSON object
         * @param serializeTexture defines if the texture must be serialized as well
         * @returns the JSON object
         */
        serialize(serializeTexture?: boolean): any;
        /**
         * Parses a JSON object to create a new sprite manager.
         * @param parsedManager The JSON object to parse
         * @param scene The scene to create the sprite managerin
         * @param rootUrl The root url to use to load external dependencies like texture
         * @returns the new sprite manager
         */
        static Parse(parsedManager: any, scene: Scene, rootUrl: string): SpriteManager;
        /**
         * Creates a sprite manager from a snippet saved in a remote file
         * @param name defines the name of the sprite manager to create (can be null or empty to use the one from the json data)
         * @param url defines the url to load from
         * @param scene defines the hosting scene
         * @param rootUrl defines the root URL to use to load textures and relative dependencies
         * @returns a promise that will resolve to the new sprite manager
         */
        static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, rootUrl?: string): Promise<SpriteManager>;
        /**
         * Creates a sprite manager from a snippet saved by the sprite editor
         * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)
         * @param scene defines the hosting scene
         * @param rootUrl defines the root URL to use to load textures and relative dependencies
         * @returns a promise that will resolve to the new sprite manager
         */
        static CreateFromSnippetAsync(snippetId: string, scene: Scene, rootUrl?: string): Promise<SpriteManager>;
    }
}
declare module BABYLON {
    /** Interface used by value gradients (color, factor, ...) */
    export interface IValueGradient {
        /**
         * Gets or sets the gradient value (between 0 and 1)
         */
        gradient: number;
    }
    /** Class used to store color4 gradient */
    export class ColorGradient implements IValueGradient {
        /**
         * Gets or sets the gradient value (between 0 and 1)
         */
        gradient: number;
        /**
         * Gets or sets first associated color
         */
        color1: Color4;
        /**
         * Gets or sets second associated color
         */
        color2?: Color4 | undefined;
        /**
         * Creates a new color4 gradient
         * @param gradient gets or sets the gradient value (between 0 and 1)
         * @param color1 gets or sets first associated color
         * @param color2 gets or sets first second color
         */
        constructor(
        /**
         * Gets or sets the gradient value (between 0 and 1)
         */
        gradient: number, 
        /**
         * Gets or sets first associated color
         */
        color1: Color4, 
        /**
         * Gets or sets second associated color
         */
        color2?: Color4 | undefined);
        /**
         * Will get a color picked randomly between color1 and color2.
         * If color2 is undefined then color1 will be used
         * @param result defines the target Color4 to store the result in
         */
        getColorToRef(result: Color4): void;
    }
    /** Class used to store color 3 gradient */
    export class Color3Gradient implements IValueGradient {
        /**
         * Gets or sets the gradient value (between 0 and 1)
         */
        gradient: number;
        /**
         * Gets or sets the associated color
         */
        color: Color3;
        /**
         * Creates a new color3 gradient
         * @param gradient gets or sets the gradient value (between 0 and 1)
         * @param color gets or sets associated color
         */
        constructor(
        /**
         * Gets or sets the gradient value (between 0 and 1)
         */
        gradient: number, 
        /**
         * Gets or sets the associated color
         */
        color: Color3);
    }
    /** Class used to store factor gradient */
    export class FactorGradient implements IValueGradient {
        /**
         * Gets or sets the gradient value (between 0 and 1)
         */
        gradient: number;
        /**
         * Gets or sets first associated factor
         */
        factor1: number;
        /**
         * Gets or sets second associated factor
         */
        factor2?: number | undefined;
        /**
         * Creates a new factor gradient
         * @param gradient gets or sets the gradient value (between 0 and 1)
         * @param factor1 gets or sets first associated factor
         * @param factor2 gets or sets second associated factor
         */
        constructor(
        /**
         * Gets or sets the gradient value (between 0 and 1)
         */
        gradient: number, 
        /**
         * Gets or sets first associated factor
         */
        factor1: number, 
        /**
         * Gets or sets second associated factor
         */
        factor2?: number | undefined);
        /**
         * Will get a number picked randomly between factor1 and factor2.
         * If factor2 is undefined then factor1 will be used
         * @returns the picked number
         */
        getFactor(): number;
    }
    /**
     * Helper used to simplify some generic gradient tasks
     */
    export class GradientHelper {
        /**
         * Gets the current gradient from an array of IValueGradient
         * @param ratio defines the current ratio to get
         * @param gradients defines the array of IValueGradient
         * @param updateFunc defines the callback function used to get the final value from the selected gradients
         */
        static GetCurrentGradient(ratio: number, gradients: IValueGradient[], updateFunc: (current: IValueGradient, next: IValueGradient, scale: number) => void): void;
    }
}
declare module BABYLON {
        interface ThinEngine {
            /**
             * Creates a raw texture
             * @param data defines the data to store in the texture
             * @param width defines the width of the texture
             * @param height defines the height of the texture
             * @param format defines the format of the data
             * @param generateMipMaps defines if the engine should generate the mip levels
             * @param invertY defines if data must be stored with Y axis inverted
             * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)
             * @param compression defines the compression used (null by default)
             * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)
             * @returns the raw texture inside an InternalTexture
             */
            createRawTexture(data: Nullable<ArrayBufferView>, width: number, height: number, format: number, generateMipMaps: boolean, invertY: boolean, samplingMode: number, compression: Nullable<string>, type: number): InternalTexture;
            /**
             * Update a raw texture
             * @param texture defines the texture to update
             * @param data defines the data to store in the texture
             * @param format defines the format of the data
             * @param invertY defines if data must be stored with Y axis inverted
             */
            updateRawTexture(texture: Nullable<InternalTexture>, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;
            /**
             * Update a raw texture
             * @param texture defines the texture to update
             * @param data defines the data to store in the texture
             * @param format defines the format of the data
             * @param invertY defines if data must be stored with Y axis inverted
             * @param compression defines the compression used (null by default)
             * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)
             */
            updateRawTexture(texture: Nullable<InternalTexture>, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string>, type: number): void;
            /**
             * Creates a new raw cube texture
             * @param data defines the array of data to use to create each face
             * @param size defines the size of the textures
             * @param format defines the format of the data
             * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)
             * @param generateMipMaps  defines if the engine should generate the mip levels
             * @param invertY defines if data must be stored with Y axis inverted
             * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)
             * @param compression defines the compression used (null by default)
             * @returns the cube texture as an InternalTexture
             */
            createRawCubeTexture(data: Nullable<ArrayBufferView[]>, size: number, format: number, type: number, generateMipMaps: boolean, invertY: boolean, samplingMode: number, compression: Nullable<string>): InternalTexture;
            /**
             * Update a raw cube texture
             * @param texture defines the texture to udpdate
             * @param data defines the data to store
             * @param format defines the data format
             * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)
             * @param invertY defines if data must be stored with Y axis inverted
             */
            updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean): void;
            /**
             * Update a raw cube texture
             * @param texture defines the texture to udpdate
             * @param data defines the data to store
             * @param format defines the data format
             * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)
             * @param invertY defines if data must be stored with Y axis inverted
             * @param compression defines the compression used (null by default)
             */
            updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>): void;
            /**
             * Update a raw cube texture
             * @param texture defines the texture to udpdate
             * @param data defines the data to store
             * @param format defines the data format
             * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)
             * @param invertY defines if data must be stored with Y axis inverted
             * @param compression defines the compression used (null by default)
             * @param level defines which level of the texture to update
             */
            updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>, level: number): void;
            /**
             * Creates a new raw cube texture from a specified url
             * @param url defines the url where the data is located
             * @param scene defines the current scene
             * @param size defines the size of the textures
             * @param format defines the format of the data
             * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)
             * @param noMipmap defines if the engine should avoid generating the mip levels
             * @param callback defines a callback used to extract texture data from loaded data
             * @param mipmapGenerator defines to provide an optional tool to generate mip levels
             * @param onLoad defines a callback called when texture is loaded
             * @param onError defines a callback called if there is an error
             * @returns the cube texture as an InternalTexture
             */
            createRawCubeTextureFromUrl(url: string, scene: Nullable<Scene>, size: number, format: number, type: number, noMipmap: boolean, callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>, mipmapGenerator: Nullable<((faces: ArrayBufferView[]) => ArrayBufferView[][])>, onLoad: Nullable<() => void>, onError: Nullable<(message?: string, exception?: any) => void>): InternalTexture;
            /**
             * Creates a new raw cube texture from a specified url
             * @param url defines the url where the data is located
             * @param scene defines the current scene
             * @param size defines the size of the textures
             * @param format defines the format of the data
             * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)
             * @param noMipmap defines if the engine should avoid generating the mip levels
             * @param callback defines a callback used to extract texture data from loaded data
             * @param mipmapGenerator defines to provide an optional tool to generate mip levels
             * @param onLoad defines a callback called when texture is loaded
             * @param onError defines a callback called if there is an error
             * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)
             * @param invertY defines if data must be stored with Y axis inverted
             * @returns the cube texture as an InternalTexture
             */
            createRawCubeTextureFromUrl(url: string, scene: Nullable<Scene>, size: number, format: number, type: number, noMipmap: boolean, callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>, mipmapGenerator: Nullable<((faces: ArrayBufferView[]) => ArrayBufferView[][])>, onLoad: Nullable<() => void>, onError: Nullable<(message?: string, exception?: any) => void>, samplingMode: number, invertY: boolean): InternalTexture;
            /**
             * Creates a new raw 3D texture
             * @param data defines the data used to create the texture
             * @param width defines the width of the texture
             * @param height defines the height of the texture
             * @param depth defines the depth of the texture
             * @param format defines the format of the texture
             * @param generateMipMaps defines if the engine must generate mip levels
             * @param invertY defines if data must be stored with Y axis inverted
             * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)
             * @param compression defines the compressed used (can be null)
             * @param textureType defines the compressed used (can be null)
             * @returns a new raw 3D texture (stored in an InternalTexture)
             */
            createRawTexture3D(data: Nullable<ArrayBufferView>, width: number, height: number, depth: number, format: number, generateMipMaps: boolean, invertY: boolean, samplingMode: number, compression: Nullable<string>, textureType: number): InternalTexture;
            /**
             * Update a raw 3D texture
             * @param texture defines the texture to update
             * @param data defines the data to store
             * @param format defines the data format
             * @param invertY defines if data must be stored with Y axis inverted
             */
            updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;
            /**
             * Update a raw 3D texture
             * @param texture defines the texture to update
             * @param data defines the data to store
             * @param format defines the data format
             * @param invertY defines if data must be stored with Y axis inverted
             * @param compression defines the used compression (can be null)
             * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)
             */
            updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string>, textureType: number): void;
            /**
             * Creates a new raw 2D array texture
             * @param data defines the data used to create the texture
             * @param width defines the width of the texture
             * @param height defines the height of the texture
             * @param depth defines the number of layers of the texture
             * @param format defines the format of the texture
             * @param generateMipMaps defines if the engine must generate mip levels
             * @param invertY defines if data must be stored with Y axis inverted
             * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)
             * @param compression defines the compressed used (can be null)
             * @param textureType defines the compressed used (can be null)
             * @returns a new raw 2D array texture (stored in an InternalTexture)
             */
            createRawTexture2DArray(data: Nullable<ArrayBufferView>, width: number, height: number, depth: number, format: number, generateMipMaps: boolean, invertY: boolean, samplingMode: number, compression: Nullable<string>, textureType: number): InternalTexture;
            /**
             * Update a raw 2D array texture
             * @param texture defines the texture to update
             * @param data defines the data to store
             * @param format defines the data format
             * @param invertY defines if data must be stored with Y axis inverted
             */
            updateRawTexture2DArray(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;
            /**
             * Update a raw 2D array texture
             * @param texture defines the texture to update
             * @param data defines the data to store
             * @param format defines the data format
             * @param invertY defines if data must be stored with Y axis inverted
             * @param compression defines the used compression (can be null)
             * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)
             */
            updateRawTexture2DArray(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string>, textureType: number): void;
        }
}
declare module BABYLON {
    /**
     * Raw texture can help creating a texture directly from an array of data.
     * This can be super useful if you either get the data from an uncompressed source or
     * if you wish to create your texture pixel by pixel.
     */
    export class RawTexture extends Texture {
        /**
         * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)
         */
        format: number;
        /**
         * Instantiates a new RawTexture.
         * Raw texture can help creating a texture directly from an array of data.
         * This can be super useful if you either get the data from an uncompressed source or
         * if you wish to create your texture pixel by pixel.
         * @param data define the array of data to use to create the texture
         * @param width define the width of the texture
         * @param height define the height of the texture
         * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)
         * @param sceneOrEngine defines the scene or engine the texture will belong to
         * @param generateMipMaps define whether mip maps should be generated or not
         * @param invertY define if the data should be flipped on Y when uploaded to the GPU
         * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
         * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
         */
        constructor(data: ArrayBufferView, width: number, height: number, 
        /**
         * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)
         */
        format: number, sceneOrEngine: Nullable<Scene | ThinEngine>, generateMipMaps?: boolean, invertY?: boolean, samplingMode?: number, type?: number);
        /**
         * Updates the texture underlying data.
         * @param data Define the new data of the texture
         */
        update(data: ArrayBufferView): void;
        /**
         * Creates a luminance texture from some data.
         * @param data Define the texture data
         * @param width Define the width of the texture
         * @param height Define the height of the texture
         * @param sceneOrEngine defines the scene or engine the texture will belong to
         * @param generateMipMaps Define whether or not to create mip maps for the texture
         * @param invertY define if the data should be flipped on Y when uploaded to the GPU
         * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
         * @returns the luminance texture
         */
        static CreateLuminanceTexture(data: ArrayBufferView, width: number, height: number, sceneOrEngine: Nullable<Scene | ThinEngine>, generateMipMaps?: boolean, invertY?: boolean, samplingMode?: number): RawTexture;
        /**
         * Creates a luminance alpha texture from some data.
         * @param data Define the texture data
         * @param width Define the width of the texture
         * @param height Define the height of the texture
         * @param sceneOrEngine defines the scene or engine the texture will belong to
         * @param generateMipMaps Define whether or not to create mip maps for the texture
         * @param invertY define if the data should be flipped on Y when uploaded to the GPU
         * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
         * @returns the luminance alpha texture
         */
        static CreateLuminanceAlphaTexture(data: ArrayBufferView, width: number, height: number, sceneOrEngine: Nullable<Scene | ThinEngine>, generateMipMaps?: boolean, invertY?: boolean, samplingMode?: number): RawTexture;
        /**
         * Creates an alpha texture from some data.
         * @param data Define the texture data
         * @param width Define the width of the texture
         * @param height Define the height of the texture
         * @param sceneOrEngine defines the scene or engine the texture will belong to
         * @param generateMipMaps Define whether or not to create mip maps for the texture
         * @param invertY define if the data should be flipped on Y when uploaded to the GPU
         * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
         * @returns the alpha texture
         */
        static CreateAlphaTexture(data: ArrayBufferView, width: number, height: number, sceneOrEngine: Nullable<Scene | ThinEngine>, generateMipMaps?: boolean, invertY?: boolean, samplingMode?: number): RawTexture;
        /**
         * Creates a RGB texture from some data.
         * @param data Define the texture data
         * @param width Define the width of the texture
         * @param height Define the height of the texture
         * @param sceneOrEngine defines the scene or engine the texture will belong to
         * @param generateMipMaps Define whether or not to create mip maps for the texture
         * @param invertY define if the data should be flipped on Y when uploaded to the GPU
         * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
         * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
         * @returns the RGB alpha texture
         */
        static CreateRGBTexture(data: ArrayBufferView, width: number, height: number, sceneOrEngine: Nullable<Scene | ThinEngine>, generateMipMaps?: boolean, invertY?: boolean, samplingMode?: number, type?: number): RawTexture;
        /**
         * Creates a RGBA texture from some data.
         * @param data Define the texture data
         * @param width Define the width of the texture
         * @param height Define the height of the texture
         * @param sceneOrEngine defines the scene or engine the texture will belong to
         * @param generateMipMaps Define whether or not to create mip maps for the texture
         * @param invertY define if the data should be flipped on Y when uploaded to the GPU
         * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
         * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
         * @returns the RGBA texture
         */
        static CreateRGBATexture(data: ArrayBufferView, width: number, height: number, sceneOrEngine: Nullable<Scene | ThinEngine>, generateMipMaps?: boolean, invertY?: boolean, samplingMode?: number, type?: number): RawTexture;
        /**
         * Creates a R texture from some data.
         * @param data Define the texture data
         * @param width Define the width of the texture
         * @param height Define the height of the texture
         * @param sceneOrEngine defines the scene or engine the texture will belong to
         * @param generateMipMaps Define whether or not to create mip maps for the texture
         * @param invertY define if the data should be flipped on Y when uploaded to the GPU
         * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
         * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
         * @returns the R texture
         */
        static CreateRTexture(data: ArrayBufferView, width: number, height: number, sceneOrEngine: Nullable<Scene | ThinEngine>, generateMipMaps?: boolean, invertY?: boolean, samplingMode?: number, type?: number): RawTexture;
    }
}
declare module BABYLON {
        interface ThinEngine {
            /**
             * Update a dynamic index buffer
             * @param indexBuffer defines the target index buffer
             * @param indices defines the data to update
             * @param offset defines the offset in the target index buffer where update should start
             */
            updateDynamicIndexBuffer(indexBuffer: DataBuffer, indices: IndicesArray, offset?: number): void;
            /**
             * Updates a dynamic vertex buffer.
             * @param vertexBuffer the vertex buffer to update
             * @param data the data used to update the vertex buffer
             * @param byteOffset the byte offset of the data
             * @param byteLength the byte length of the data
             */
            updateDynamicVertexBuffer(vertexBuffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void;
        }
}
declare module BABYLON {
        interface AbstractScene {
            /**
             * The list of procedural textures added to the scene
             * @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures
             */
            proceduralTextures: Array<ProceduralTexture>;
        }
    /**
     * Defines the Procedural Texture scene component responsible to manage any Procedural Texture
     * in a given scene.
     */
    export class ProceduralTextureSceneComponent implements ISceneComponent {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        readonly name: string;
        /**
         * The scene the component belongs to.
         */
        scene: Scene;
        /**
         * Creates a new instance of the component for the given scene
         * @param scene Defines the scene to register the component in
         */
        constructor(scene: Scene);
        /**
         * Registers the component in a given scene
         */
        register(): void;
        /**
         * Rebuilds the elements related to this component in case of
         * context lost for instance.
         */
        rebuild(): void;
        /**
         * Disposes the component and the associated ressources.
         */
        dispose(): void;
        private _beforeClear;
    }
}
declare module BABYLON {
        interface ThinEngine {
            /**
             * Creates a new render target cube texture
             * @param size defines the size of the texture
             * @param options defines the options used to create the texture
             * @returns a new render target cube texture stored in an InternalTexture
             */
            createRenderTargetCubeTexture(size: number, options?: Partial<RenderTargetCreationOptions>): InternalTexture;
        }
}
declare module BABYLON {
    /** @hidden */
    export var proceduralVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.
     * This is the base class of any Procedural texture and contains most of the shareable code.
     * @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures
     */
    export class ProceduralTexture extends Texture {
        /**
         * Define if the texture is enabled or not (disabled texture will not render)
         */
        isEnabled: boolean;
        /**
         * Define if the texture must be cleared before rendering (default is true)
         */
        autoClear: boolean;
        /**
         * Callback called when the texture is generated
         */
        onGenerated: () => void;
        /**
         * Event raised when the texture is generated
         */
        onGeneratedObservable: Observable<ProceduralTexture>;
        /**
         * Event raised before the texture is generated
         */
        onBeforeGenerationObservable: Observable<ProceduralTexture>;
        /**
         * Gets or sets the node material used to create this texture (null if the texture was manually created)
         */
        nodeMaterialSource: Nullable<NodeMaterial>;
        /** @hidden */
        _generateMipMaps: boolean;
        /** @hidden **/
        _effect: Effect;
        /** @hidden */
        _textures: {
            [key: string]: Texture;
        };
        /** @hidden */
        protected _fallbackTexture: Nullable<Texture>;
        private _size;
        private _currentRefreshId;
        private _frameId;
        private _refreshRate;
        private _vertexBuffers;
        private _indexBuffer;
        private _uniforms;
        private _samplers;
        private _fragment;
        private _floats;
        private _ints;
        private _floatsArrays;
        private _colors3;
        private _colors4;
        private _vectors2;
        private _vectors3;
        private _matrices;
        private _fallbackTextureUsed;
        private _fullEngine;
        private _cachedDefines;
        private _contentUpdateId;
        private _contentData;
        /**
         * Instantiates a new procedural texture.
         * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
         * This is the base class of any Procedural texture and contains most of the shareable code.
         * @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures
         * @param name  Define the name of the texture
         * @param size Define the size of the texture to create
         * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later
         * @param scene Define the scene the texture belongs to
         * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture
         * @param generateMipMaps Define if the texture should creates mip maps or not
         * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)
         */
        constructor(name: string, size: RenderTargetTextureSize, fragment: any, scene: Nullable<Scene>, fallbackTexture?: Nullable<Texture>, generateMipMaps?: boolean, isCube?: boolean);
        /**
         * The effect that is created when initializing the post process.
         * @returns The created effect corresponding the the postprocess.
         */
        getEffect(): Effect;
        /**
         * Gets texture content (Use this function wisely as reading from a texture can be slow)
         * @returns an ArrayBufferView (Uint8Array or Float32Array)
         */
        getContent(): Nullable<ArrayBufferView>;
        private _createIndexBuffer;
        /** @hidden */
        _rebuild(): void;
        /**
         * Resets the texture in order to recreate its associated resources.
         * This can be called in case of context loss
         */
        reset(): void;
        protected _getDefines(): string;
        /**
         * Is the texture ready to be used ? (rendered at least once)
         * @returns true if ready, otherwise, false.
         */
        isReady(): boolean;
        /**
         * Resets the refresh counter of the texture and start bak from scratch.
         * Could be useful to regenerate the texture if it is setup to render only once.
         */
        resetRefreshCounter(): void;
        /**
         * Set the fragment shader to use in order to render the texture.
         * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.
         */
        setFragment(fragment: any): void;
        /**
         * Define the refresh rate of the texture or the rendering frequency.
         * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...
         */
        get refreshRate(): number;
        set refreshRate(value: number);
        /** @hidden */
        _shouldRender(): boolean;
        /**
         * Get the size the texture is rendering at.
         * @returns the size (on cube texture it is always squared)
         */
        getRenderSize(): RenderTargetTextureSize;
        /**
         * Resize the texture to new value.
         * @param size Define the new size the texture should have
         * @param generateMipMaps Define whether the new texture should create mip maps
         */
        resize(size: number, generateMipMaps: boolean): void;
        private _checkUniform;
        /**
         * Set a texture in the shader program used to render.
         * @param name Define the name of the uniform samplers as defined in the shader
         * @param texture Define the texture to bind to this sampler
         * @return the texture itself allowing "fluent" like uniform updates
         */
        setTexture(name: string, texture: Texture): ProceduralTexture;
        /**
         * Set a float in the shader.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the texture itself allowing "fluent" like uniform updates
         */
        setFloat(name: string, value: number): ProceduralTexture;
        /**
         * Set a int in the shader.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the texture itself allowing "fluent" like uniform updates
         */
        setInt(name: string, value: number): ProceduralTexture;
        /**
         * Set an array of floats in the shader.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the texture itself allowing "fluent" like uniform updates
         */
        setFloats(name: string, value: number[]): ProceduralTexture;
        /**
         * Set a vec3 in the shader from a Color3.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the texture itself allowing "fluent" like uniform updates
         */
        setColor3(name: string, value: Color3): ProceduralTexture;
        /**
         * Set a vec4 in the shader from a Color4.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the texture itself allowing "fluent" like uniform updates
         */
        setColor4(name: string, value: Color4): ProceduralTexture;
        /**
         * Set a vec2 in the shader from a Vector2.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the texture itself allowing "fluent" like uniform updates
         */
        setVector2(name: string, value: Vector2): ProceduralTexture;
        /**
         * Set a vec3 in the shader from a Vector3.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the texture itself allowing "fluent" like uniform updates
         */
        setVector3(name: string, value: Vector3): ProceduralTexture;
        /**
         * Set a mat4 in the shader from a MAtrix.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the texture itself allowing "fluent" like uniform updates
         */
        setMatrix(name: string, value: Matrix): ProceduralTexture;
        /**
         * Render the texture to its associated render target.
         * @param useCameraPostProcess Define if camera post process should be applied to the texture
         */
        render(useCameraPostProcess?: boolean): void;
        /**
         * Clone the texture.
         * @returns the cloned texture
         */
        clone(): ProceduralTexture;
        /**
         * Dispose the texture and release its asoociated resources.
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * This represents the base class for particle system in Babylon.
     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
     * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.
     * @example https://doc.babylonjs.com/babylon101/particles
     */
    export class BaseParticleSystem {
        /**
         * Source color is added to the destination color without alpha affecting the result
         */
        static BLENDMODE_ONEONE: number;
        /**
         * Blend current color and particle color using particles alpha
         */
        static BLENDMODE_STANDARD: number;
        /**
         * Add current color and particle color multiplied by particles alpha
         */
        static BLENDMODE_ADD: number;
        /**
         * Multiply current color with particle color
         */
        static BLENDMODE_MULTIPLY: number;
        /**
         * Multiply current color with particle color then add current color and particle color multiplied by particles alpha
         */
        static BLENDMODE_MULTIPLYADD: number;
        /**
         * List of animations used by the particle system.
         */
        animations: Animation[];
        /**
         * Gets or sets the unique id of the particle system
         */
        uniqueId: number;
        /**
         * The id of the Particle system.
         */
        id: string;
        /**
         * The friendly name of the Particle system.
         */
        name: string;
        /**
         * Snippet ID if the particle system was created from the snippet server
         */
        snippetId: string;
        /**
         * The rendering group used by the Particle system to chose when to render.
         */
        renderingGroupId: number;
        /**
         * The emitter represents the Mesh or position we are attaching the particle system to.
         */
        emitter: Nullable<AbstractMesh | Vector3>;
        /**
         * The maximum number of particles to emit per frame
         */
        emitRate: number;
        /**
         * If you want to launch only a few particles at once, that can be done, as well.
         */
        manualEmitCount: number;
        /**
         * The overall motion speed (0.01 is default update speed, faster updates = faster animation)
         */
        updateSpeed: number;
        /**
         * The amount of time the particle system is running (depends of the overall update speed).
         */
        targetStopDuration: number;
        /**
         * Specifies whether the particle system will be disposed once it reaches the end of the animation.
         */
        disposeOnStop: boolean;
        /**
         * Minimum power of emitting particles.
         */
        minEmitPower: number;
        /**
         * Maximum power of emitting particles.
         */
        maxEmitPower: number;
        /**
         * Minimum life time of emitting particles.
         */
        minLifeTime: number;
        /**
         * Maximum life time of emitting particles.
         */
        maxLifeTime: number;
        /**
         * Minimum Size of emitting particles.
         */
        minSize: number;
        /**
         * Maximum Size of emitting particles.
         */
        maxSize: number;
        /**
         * Minimum scale of emitting particles on X axis.
         */
        minScaleX: number;
        /**
         * Maximum scale of emitting particles on X axis.
         */
        maxScaleX: number;
        /**
         * Minimum scale of emitting particles on Y axis.
         */
        minScaleY: number;
        /**
         * Maximum scale of emitting particles on Y axis.
         */
        maxScaleY: number;
        /**
         * Gets or sets the minimal initial rotation in radians.
         */
        minInitialRotation: number;
        /**
         * Gets or sets the maximal initial rotation in radians.
         */
        maxInitialRotation: number;
        /**
         * Minimum angular speed of emitting particles (Z-axis rotation for each particle).
         */
        minAngularSpeed: number;
        /**
         * Maximum angular speed of emitting particles (Z-axis rotation for each particle).
         */
        maxAngularSpeed: number;
        /**
         * The texture used to render each particle. (this can be a spritesheet)
         */
        particleTexture: Nullable<BaseTexture>;
        /**
         * The layer mask we are rendering the particles through.
         */
        layerMask: number;
        /**
         * This can help using your own shader to render the particle system.
         * The according effect will be created
         */
        customShader: any;
        /**
         * By default particle system starts as soon as they are created. This prevents the
         * automatic start to happen and let you decide when to start emitting particles.
         */
        preventAutoStart: boolean;
        private _noiseTexture;
        /**
         * Gets or sets a texture used to add random noise to particle positions
         */
        get noiseTexture(): Nullable<ProceduralTexture>;
        set noiseTexture(value: Nullable<ProceduralTexture>);
        /** Gets or sets the strength to apply to the noise value (default is (10, 10, 10)) */
        noiseStrength: Vector3;
        /**
         * Callback triggered when the particle animation is ending.
         */
        onAnimationEnd: Nullable<() => void>;
        /**
         * Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE or ParticleSystem.BLENDMODE_STANDARD.
         */
        blendMode: number;
        /**
         * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls
         * to override the particles.
         */
        forceDepthWrite: boolean;
        /** Gets or sets a value indicating how many cycles (or frames) must be executed before first rendering (this value has to be set before starting the system). Default is 0 */
        preWarmCycles: number;
        /** Gets or sets a value indicating the time step multiplier to use in pre-warm mode (default is 1) */
        preWarmStepOffset: number;
        /**
         * If using a spritesheet (isAnimationSheetEnabled) defines the speed of the sprite loop (default is 1 meaning the animation will play once during the entire particle lifetime)
         */
        spriteCellChangeSpeed: number;
        /**
         * If using a spritesheet (isAnimationSheetEnabled) defines the first sprite cell to display
         */
        startSpriteCellID: number;
        /**
         * If using a spritesheet (isAnimationSheetEnabled) defines the last sprite cell to display
         */
        endSpriteCellID: number;
        /**
         * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell width to use
         */
        spriteCellWidth: number;
        /**
         * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell height to use
         */
        spriteCellHeight: number;
        /**
         * This allows the system to random pick the start cell ID between startSpriteCellID and endSpriteCellID
         */
        spriteRandomStartCell: boolean;
        /** Gets or sets a Vector2 used to move the pivot (by default (0,0)) */
        translationPivot: Vector2;
        /** @hidden */
        protected _isAnimationSheetEnabled: boolean;
        /**
         * Gets or sets a boolean indicating that hosted animations (in the system.animations array) must be started when system.start() is called
         */
        beginAnimationOnStart: boolean;
        /**
         * Gets or sets the frame to start the animation from when beginAnimationOnStart is true
         */
        beginAnimationFrom: number;
        /**
         * Gets or sets the frame to end the animation on when beginAnimationOnStart is true
         */
        beginAnimationTo: number;
        /**
         * Gets or sets a boolean indicating if animations must loop when beginAnimationOnStart is true
         */
        beginAnimationLoop: boolean;
        /**
         * Gets or sets a world offset applied to all particles
         */
        worldOffset: Vector3;
        /**
         * Gets or sets whether an animation sprite sheet is enabled or not on the particle system
         */
        get isAnimationSheetEnabled(): boolean;
        set isAnimationSheetEnabled(value: boolean);
        /**
         * Get hosting scene
         * @returns the scene
         */
        getScene(): Nullable<Scene>;
        /**
         * You can use gravity if you want to give an orientation to your particles.
         */
        gravity: Vector3;
        protected _colorGradients: Nullable<Array<ColorGradient>>;
        protected _sizeGradients: Nullable<Array<FactorGradient>>;
        protected _lifeTimeGradients: Nullable<Array<FactorGradient>>;
        protected _angularSpeedGradients: Nullable<Array<FactorGradient>>;
        protected _velocityGradients: Nullable<Array<FactorGradient>>;
        protected _limitVelocityGradients: Nullable<Array<FactorGradient>>;
        protected _dragGradients: Nullable<Array<FactorGradient>>;
        protected _emitRateGradients: Nullable<Array<FactorGradient>>;
        protected _startSizeGradients: Nullable<Array<FactorGradient>>;
        protected _rampGradients: Nullable<Array<Color3Gradient>>;
        protected _colorRemapGradients: Nullable<Array<FactorGradient>>;
        protected _alphaRemapGradients: Nullable<Array<FactorGradient>>;
        protected _hasTargetStopDurationDependantGradient(): boolean | null;
        /**
         * Defines the delay in milliseconds before starting the system (0 by default)
         */
        startDelay: number;
        /**
         * Gets the current list of drag gradients.
         * You must use addDragGradient and removeDragGradient to udpate this list
         * @returns the list of drag gradients
         */
        getDragGradients(): Nullable<Array<FactorGradient>>;
        /** Gets or sets a value indicating the damping to apply if the limit velocity factor is reached */
        limitVelocityDamping: number;
        /**
         * Gets the current list of limit velocity gradients.
         * You must use addLimitVelocityGradient and removeLimitVelocityGradient to udpate this list
         * @returns the list of limit velocity gradients
         */
        getLimitVelocityGradients(): Nullable<Array<FactorGradient>>;
        /**
         * Gets the current list of color gradients.
         * You must use addColorGradient and removeColorGradient to udpate this list
         * @returns the list of color gradients
         */
        getColorGradients(): Nullable<Array<ColorGradient>>;
        /**
         * Gets the current list of size gradients.
         * You must use addSizeGradient and removeSizeGradient to udpate this list
         * @returns the list of size gradients
         */
        getSizeGradients(): Nullable<Array<FactorGradient>>;
        /**
         * Gets the current list of color remap gradients.
         * You must use addColorRemapGradient and removeColorRemapGradient to udpate this list
         * @returns the list of color remap gradients
         */
        getColorRemapGradients(): Nullable<Array<FactorGradient>>;
        /**
         * Gets the current list of alpha remap gradients.
         * You must use addAlphaRemapGradient and removeAlphaRemapGradient to udpate this list
         * @returns the list of alpha remap gradients
         */
        getAlphaRemapGradients(): Nullable<Array<FactorGradient>>;
        /**
         * Gets the current list of life time gradients.
         * You must use addLifeTimeGradient and removeLifeTimeGradient to udpate this list
         * @returns the list of life time gradients
         */
        getLifeTimeGradients(): Nullable<Array<FactorGradient>>;
        /**
         * Gets the current list of angular speed gradients.
         * You must use addAngularSpeedGradient and removeAngularSpeedGradient to udpate this list
         * @returns the list of angular speed gradients
         */
        getAngularSpeedGradients(): Nullable<Array<FactorGradient>>;
        /**
         * Gets the current list of velocity gradients.
         * You must use addVelocityGradient and removeVelocityGradient to udpate this list
         * @returns the list of velocity gradients
         */
        getVelocityGradients(): Nullable<Array<FactorGradient>>;
        /**
         * Gets the current list of start size gradients.
         * You must use addStartSizeGradient and removeStartSizeGradient to udpate this list
         * @returns the list of start size gradients
         */
        getStartSizeGradients(): Nullable<Array<FactorGradient>>;
        /**
         * Gets the current list of emit rate gradients.
         * You must use addEmitRateGradient and removeEmitRateGradient to udpate this list
         * @returns the list of emit rate gradients
         */
        getEmitRateGradients(): Nullable<Array<FactorGradient>>;
        /**
         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
         * This only works when particleEmitterTyps is a BoxParticleEmitter
         */
        get direction1(): Vector3;
        set direction1(value: Vector3);
        /**
         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
         * This only works when particleEmitterTyps is a BoxParticleEmitter
         */
        get direction2(): Vector3;
        set direction2(value: Vector3);
        /**
         * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
         * This only works when particleEmitterTyps is a BoxParticleEmitter
         */
        get minEmitBox(): Vector3;
        set minEmitBox(value: Vector3);
        /**
         * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
         * This only works when particleEmitterTyps is a BoxParticleEmitter
         */
        get maxEmitBox(): Vector3;
        set maxEmitBox(value: Vector3);
        /**
         * Random color of each particle after it has been emitted, between color1 and color2 vectors
         */
        color1: Color4;
        /**
         * Random color of each particle after it has been emitted, between color1 and color2 vectors
         */
        color2: Color4;
        /**
         * Color the particle will have at the end of its lifetime
         */
        colorDead: Color4;
        /**
         * An optional mask to filter some colors out of the texture, or filter a part of the alpha channel
         */
        textureMask: Color4;
        /**
         * The particle emitter type defines the emitter used by the particle system.
         * It can be for example box, sphere, or cone...
         */
        particleEmitterType: IParticleEmitterType;
        /** @hidden */
        _isSubEmitter: boolean;
        /**
         * Gets or sets the billboard mode to use when isBillboardBased = true.
         * Value can be: ParticleSystem.BILLBOARDMODE_ALL, ParticleSystem.BILLBOARDMODE_Y, ParticleSystem.BILLBOARDMODE_STRETCHED
         */
        billboardMode: number;
        protected _isBillboardBased: boolean;
        /**
         * Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction
         */
        get isBillboardBased(): boolean;
        set isBillboardBased(value: boolean);
        /**
         * The scene the particle system belongs to.
         */
        protected _scene: Nullable<Scene>;
        /**
         * The engine the particle system belongs to.
         */
        protected _engine: ThinEngine;
        /**
         * Local cache of defines for image processing.
         */
        protected _imageProcessingConfigurationDefines: ImageProcessingConfigurationDefines;
        /**
         * Default configuration related to image processing available in the standard Material.
         */
        protected _imageProcessingConfiguration: Nullable<ImageProcessingConfiguration>;
        /**
         * Gets the image processing configuration used either in this material.
         */
        get imageProcessingConfiguration(): Nullable<ImageProcessingConfiguration>;
        /**
         * Sets the Default image processing configuration used either in the this material.
         *
         * If sets to null, the scene one is in use.
         */
        set imageProcessingConfiguration(value: Nullable<ImageProcessingConfiguration>);
        /**
         * Attaches a new image processing configuration to the Standard Material.
         * @param configuration
         */
        protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void;
        /** @hidden */
        protected _reset(): void;
        /** @hidden */
        protected _removeGradientAndTexture(gradient: number, gradients: Nullable<IValueGradient[]>, texture: Nullable<RawTexture>): BaseParticleSystem;
        /**
         * Instantiates a particle system.
         * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
         * @param name The name of the particle system
         */
        constructor(name: string);
        /**
         * Creates a Point Emitter for the particle system (emits directly from the emitter position)
         * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
         * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
         * @returns the emitter
         */
        createPointEmitter(direction1: Vector3, direction2: Vector3): PointParticleEmitter;
        /**
         * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)
         * @param radius The radius of the hemisphere to emit from
         * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
         * @returns the emitter
         */
        createHemisphericEmitter(radius?: number, radiusRange?: number): HemisphericParticleEmitter;
        /**
         * Creates a Sphere Emitter for the particle system (emits along the sphere radius)
         * @param radius The radius of the sphere to emit from
         * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
         * @returns the emitter
         */
        createSphereEmitter(radius?: number, radiusRange?: number): SphereParticleEmitter;
        /**
         * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)
         * @param radius The radius of the sphere to emit from
         * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere
         * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere
         * @returns the emitter
         */
        createDirectedSphereEmitter(radius?: number, direction1?: Vector3, direction2?: Vector3): SphereDirectedParticleEmitter;
        /**
         * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)
         * @param radius The radius of the emission cylinder
         * @param height The height of the emission cylinder
         * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius
         * @param directionRandomizer How much to randomize the particle direction [0-1]
         * @returns the emitter
         */
        createCylinderEmitter(radius?: number, height?: number, radiusRange?: number, directionRandomizer?: number): CylinderParticleEmitter;
        /**
         * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)
         * @param radius The radius of the cylinder to emit from
         * @param height The height of the emission cylinder
         * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
         * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder
         * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder
         * @returns the emitter
         */
        createDirectedCylinderEmitter(radius?: number, height?: number, radiusRange?: number, direction1?: Vector3, direction2?: Vector3): CylinderDirectedParticleEmitter;
        /**
         * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)
         * @param radius The radius of the cone to emit from
         * @param angle The base angle of the cone
         * @returns the emitter
         */
        createConeEmitter(radius?: number, angle?: number): ConeParticleEmitter;
        /**
         * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)
         * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
         * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
         * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox
         * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox
         * @returns the emitter
         */
        createBoxEmitter(direction1: Vector3, direction2: Vector3, minEmitBox: Vector3, maxEmitBox: Vector3): BoxParticleEmitter;
    }
}
declare module BABYLON {
    /**
         * Type of sub emitter
         */
    export enum SubEmitterType {
        /**
         * Attached to the particle over it's lifetime
         */
        ATTACHED = 0,
        /**
         * Created when the particle dies
         */
        END = 1
    }
    /**
     * Sub emitter class used to emit particles from an existing particle
     */
    export class SubEmitter {
        /**
         * the particle system to be used by the sub emitter
         */
        particleSystem: ParticleSystem;
        /**
         * Type of the submitter (Default: END)
         */
        type: SubEmitterType;
        /**
         * If the particle should inherit the direction from the particle it's attached to. (+Y will face the direction the particle is moving) (Default: false)
         * Note: This only is supported when using an emitter of type Mesh
         */
        inheritDirection: boolean;
        /**
         * How much of the attached particles speed should be added to the sub emitted particle (default: 0)
         */
        inheritedVelocityAmount: number;
        /**
         * Creates a sub emitter
         * @param particleSystem the particle system to be used by the sub emitter
         */
        constructor(
        /**
         * the particle system to be used by the sub emitter
         */
        particleSystem: ParticleSystem);
        /**
         * Clones the sub emitter
         * @returns the cloned sub emitter
         */
        clone(): SubEmitter;
        /**
         * Serialize current object to a JSON object
         * @returns the serialized object
         */
        serialize(): any;
        /** @hidden */
        static _ParseParticleSystem(system: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string): ParticleSystem;
        /**
         * Creates a new SubEmitter from a serialized JSON version
         * @param serializationObject defines the JSON object to read from
         * @param sceneOrEngine defines the hosting scene or the hosting engine
         * @param rootUrl defines the rootUrl for data loading
         * @returns a new SubEmitter
         */
        static Parse(serializationObject: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string): SubEmitter;
        /** Release associated resources */
        dispose(): void;
    }
}
declare module BABYLON {
    /** @hidden */
    export var imageProcessingDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var imageProcessingFunctions: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var particlesPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var particlesVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Interface used to define entities containing multiple clip planes
     */
    export interface IClipPlanesHolder {
        /**
         * Gets or sets the active clipplane 1
         */
        clipPlane: Nullable<Plane>;
        /**
         * Gets or sets the active clipplane 2
         */
        clipPlane2: Nullable<Plane>;
        /**
         * Gets or sets the active clipplane 3
         */
        clipPlane3: Nullable<Plane>;
        /**
         * Gets or sets the active clipplane 4
         */
        clipPlane4: Nullable<Plane>;
        /**
         * Gets or sets the active clipplane 5
         */
        clipPlane5: Nullable<Plane>;
        /**
         * Gets or sets the active clipplane 6
         */
        clipPlane6: Nullable<Plane>;
    }
}
declare module BABYLON {
    /**
     * "Static Class" containing a few commonly used helper while dealing with material for rendering purpose.
     *
     * It is complementary with MaterialHelper but provides completely independent functions (for tree shaking sake)
     *
     * This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.
     */
    export class ThinMaterialHelper {
        /**
         * Binds the clip plane information from the holder to the effect.
         * @param effect The effect we are binding the data to
         * @param holder The entity containing the clip plane information
         */
        static BindClipPlane(effect: Effect, holder: IClipPlanesHolder): void;
    }
}
declare module BABYLON {
        interface ThinEngine {
            /**
             * Sets alpha constants used by some alpha blending modes
             * @param r defines the red component
             * @param g defines the green component
             * @param b defines the blue component
             * @param a defines the alpha component
             */
            setAlphaConstants(r: number, g: number, b: number, a: number): void;
            /**
             * Sets the current alpha mode
             * @param mode defines the mode to use (one of the Engine.ALPHA_XXX)
             * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)
             * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered
             */
            setAlphaMode(mode: number, noDepthWriteChange?: boolean): void;
            /**
             * Gets the current alpha mode
             * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered
             * @returns the current alpha mode
             */
            getAlphaMode(): number;
            /**
             * Sets the current alpha equation
             * @param equation defines the equation to use (one of the Engine.ALPHA_EQUATION_XXX)
             */
            setAlphaEquation(equation: number): void;
            /**
             * Gets the current alpha equation.
             * @returns the current alpha equation
             */
            getAlphaEquation(): number;
        }
}
declare module BABYLON {
    /**
     * This represents a particle system in Babylon.
     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
     * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.
     * @example https://doc.babylonjs.com/babylon101/particles
     */
    export class ParticleSystem extends BaseParticleSystem implements IDisposable, IAnimatable, IParticleSystem {
        /**
         * Billboard mode will only apply to Y axis
         */
        static readonly BILLBOARDMODE_Y: number;
        /**
         * Billboard mode will apply to all axes
         */
        static readonly BILLBOARDMODE_ALL: number;
        /**
         * Special billboard mode where the particle will be biilboard to the camera but rotated to align with direction
         */
        static readonly BILLBOARDMODE_STRETCHED: number;
        /**
         * This function can be defined to provide custom update for active particles.
         * This function will be called instead of regular update (age, position, color, etc.).
         * Do not forget that this function will be called on every frame so try to keep it simple and fast :)
         */
        updateFunction: (particles: Particle[]) => void;
        private _emitterWorldMatrix;
        /**
         * This function can be defined to specify initial direction for every new particle.
         * It by default use the emitterType defined function
         */
        startDirectionFunction: (worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean) => void;
        /**
         * This function can be defined to specify initial position for every new particle.
         * It by default use the emitterType defined function
         */
        startPositionFunction: (worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean) => void;
        /**
         * @hidden
         */
        _inheritedVelocityOffset: Vector3;
        /**
        * An event triggered when the system is disposed
        */
        onDisposeObservable: Observable<IParticleSystem>;
        private _onDisposeObserver;
        /**
         * Sets a callback that will be triggered when the system is disposed
         */
        set onDispose(callback: () => void);
        private _particles;
        private _epsilon;
        private _capacity;
        private _stockParticles;
        private _newPartsExcess;
        private _vertexData;
        private _vertexBuffer;
        private _vertexBuffers;
        private _spriteBuffer;
        private _indexBuffer;
        private _effect;
        private _customEffect;
        private _cachedDefines;
        private _scaledColorStep;
        private _colorDiff;
        private _scaledDirection;
        private _scaledGravity;
        private _currentRenderId;
        private _alive;
        private _useInstancing;
        private _started;
        private _stopped;
        private _actualFrame;
        private _scaledUpdateSpeed;
        private _vertexBufferSize;
        /** @hidden */
        _currentEmitRateGradient: Nullable<FactorGradient>;
        /** @hidden */
        _currentEmitRate1: number;
        /** @hidden */
        _currentEmitRate2: number;
        /** @hidden */
        _currentStartSizeGradient: Nullable<FactorGradient>;
        /** @hidden */
        _currentStartSize1: number;
        /** @hidden */
        _currentStartSize2: number;
        private readonly _rawTextureWidth;
        private _rampGradientsTexture;
        private _useRampGradients;
        /** Gets or sets a matrix to use to compute projection */
        defaultProjectionMatrix: Matrix;
        /** Gets or sets a matrix to use to compute view */
        defaultViewMatrix: Matrix;
        /** Gets or sets a boolean indicating that ramp gradients must be used
         * @see https://doc.babylonjs.com/babylon101/particles#ramp-gradients
         */
        get useRampGradients(): boolean;
        set useRampGradients(value: boolean);
        /**
         * The Sub-emitters templates that will be used to generate the sub particle system to be associated with the system, this property is used by the root particle system only.
         * When a particle is spawned, an array will be chosen at random and all the emitters in that array will be attached to the particle.  (Default: [])
         */
        subEmitters: Array<ParticleSystem | SubEmitter | Array<SubEmitter>>;
        private _subEmitters;
        /**
         * @hidden
         * If the particle systems emitter should be disposed when the particle system is disposed
         */
        _disposeEmitterOnDispose: boolean;
        /**
        * The current active Sub-systems, this property is used by the root particle system only.
        */
        activeSubSystems: Array<ParticleSystem>;
        /**
         * Specifies if the particles are updated in emitter local space or world space
         */
        isLocal: boolean;
        private _rootParticleSystem;
        /**
         * Gets the current list of active particles
         */
        get particles(): Particle[];
        /**
         * Gets the number of particles active at the same time.
         * @returns The number of active particles.
         */
        getActiveCount(): number;
        /**
         * Returns the string "ParticleSystem"
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Gets a boolean indicating that the system is stopping
         * @returns true if the system is currently stopping
         */
        isStopping(): boolean;
        /**
         * Gets the custom effect used to render the particles
         * @param blendMode Blend mode for which the effect should be retrieved
         * @returns The effect
         */
        getCustomEffect(blendMode?: number): Nullable<Effect>;
        /**
         * Sets the custom effect used to render the particles
         * @param effect The effect to set
         * @param blendMode Blend mode for which the effect should be set
         */
        setCustomEffect(effect: Nullable<Effect>, blendMode?: number): void;
        /** @hidden */
        private _onBeforeDrawParticlesObservable;
        /**
         * Observable that will be called just before the particles are drawn
         */
        get onBeforeDrawParticlesObservable(): Observable<Nullable<Effect>>;
        /**
         * Gets the name of the particle vertex shader
         */
        get vertexShaderName(): string;
        /**
         * Instantiates a particle system.
         * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
         * @param name The name of the particle system
         * @param capacity The max number of particles alive at the same time
         * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene
         * @param customEffect a custom effect used to change the way particles are rendered by default
         * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture
         * @param epsilon Offset used to render the particles
         */
        constructor(name: string, capacity: number, sceneOrEngine: Scene | ThinEngine, customEffect?: Nullable<Effect>, isAnimationSheetEnabled?: boolean, epsilon?: number);
        private _addFactorGradient;
        private _removeFactorGradient;
        /**
         * Adds a new life time gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the life time factor to affect to the specified gradient
         * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
         * @returns the current particle system
         */
        addLifeTimeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;
        /**
         * Remove a specific life time gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeLifeTimeGradient(gradient: number): IParticleSystem;
        /**
         * Adds a new size gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the size factor to affect to the specified gradient
         * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
         * @returns the current particle system
         */
        addSizeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;
        /**
         * Remove a specific size gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeSizeGradient(gradient: number): IParticleSystem;
        /**
         * Adds a new color remap gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param min defines the color remap minimal range
         * @param max defines the color remap maximal range
         * @returns the current particle system
         */
        addColorRemapGradient(gradient: number, min: number, max: number): IParticleSystem;
        /**
         * Remove a specific color remap gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeColorRemapGradient(gradient: number): IParticleSystem;
        /**
         * Adds a new alpha remap gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param min defines the alpha remap minimal range
         * @param max defines the alpha remap maximal range
         * @returns the current particle system
         */
        addAlphaRemapGradient(gradient: number, min: number, max: number): IParticleSystem;
        /**
         * Remove a specific alpha remap gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeAlphaRemapGradient(gradient: number): IParticleSystem;
        /**
         * Adds a new angular speed gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the angular speed  to affect to the specified gradient
         * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
         * @returns the current particle system
         */
        addAngularSpeedGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;
        /**
         * Remove a specific angular speed gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeAngularSpeedGradient(gradient: number): IParticleSystem;
        /**
         * Adds a new velocity gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the velocity to affect to the specified gradient
         * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
         * @returns the current particle system
         */
        addVelocityGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;
        /**
         * Remove a specific velocity gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeVelocityGradient(gradient: number): IParticleSystem;
        /**
         * Adds a new limit velocity gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the limit velocity value to affect to the specified gradient
         * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
         * @returns the current particle system
         */
        addLimitVelocityGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;
        /**
         * Remove a specific limit velocity gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeLimitVelocityGradient(gradient: number): IParticleSystem;
        /**
         * Adds a new drag gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the drag value to affect to the specified gradient
         * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
         * @returns the current particle system
         */
        addDragGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;
        /**
         * Remove a specific drag gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeDragGradient(gradient: number): IParticleSystem;
        /**
         * Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the emit rate value to affect to the specified gradient
         * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
         * @returns the current particle system
         */
        addEmitRateGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;
        /**
         * Remove a specific emit rate gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeEmitRateGradient(gradient: number): IParticleSystem;
        /**
         * Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the start size value to affect to the specified gradient
         * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
         * @returns the current particle system
         */
        addStartSizeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;
        /**
         * Remove a specific start size gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeStartSizeGradient(gradient: number): IParticleSystem;
        private _createRampGradientTexture;
        /**
         * Gets the current list of ramp gradients.
         * You must use addRampGradient and removeRampGradient to udpate this list
         * @returns the list of ramp gradients
         */
        getRampGradients(): Nullable<Array<Color3Gradient>>;
        /** Force the system to rebuild all gradients that need to be resync */
        forceRefreshGradients(): void;
        private _syncRampGradientTexture;
        /**
         * Adds a new ramp gradient used to remap particle colors
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param color defines the color to affect to the specified gradient
         * @returns the current particle system
         */
        addRampGradient(gradient: number, color: Color3): ParticleSystem;
        /**
         * Remove a specific ramp gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeRampGradient(gradient: number): ParticleSystem;
        /**
         * Adds a new color gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param color1 defines the color to affect to the specified gradient
         * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from
         * @returns this particle system
         */
        addColorGradient(gradient: number, color1: Color4, color2?: Color4): IParticleSystem;
        /**
         * Remove a specific color gradient
         * @param gradient defines the gradient to remove
         * @returns this particle system
         */
        removeColorGradient(gradient: number): IParticleSystem;
        private _fetchR;
        protected _reset(): void;
        private _resetEffect;
        private _createVertexBuffers;
        private _createIndexBuffer;
        /**
         * Gets the maximum number of particles active at the same time.
         * @returns The max number of active particles.
         */
        getCapacity(): number;
        /**
         * Gets whether there are still active particles in the system.
         * @returns True if it is alive, otherwise false.
         */
        isAlive(): boolean;
        /**
         * Gets if the system has been started. (Note: this will still be true after stop is called)
         * @returns True if it has been started, otherwise false.
         */
        isStarted(): boolean;
        private _prepareSubEmitterInternalArray;
        /**
         * Starts the particle system and begins to emit
         * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)
         */
        start(delay?: number): void;
        /**
         * Stops the particle system.
         * @param stopSubEmitters if true it will stop the current system and all created sub-Systems if false it will stop the current root system only, this param is used by the root particle system only. the default value is true.
         */
        stop(stopSubEmitters?: boolean): void;
        /**
         * Remove all active particles
         */
        reset(): void;
        /**
         * @hidden (for internal use only)
         */
        _appendParticleVertex(index: number, particle: Particle, offsetX: number, offsetY: number): void;
        /**
         * "Recycles" one of the particle by copying it back to the "stock" of particles and removing it from the active list.
         * Its lifetime will start back at 0.
         */
        recycleParticle: (particle: Particle) => void;
        private _stopSubEmitters;
        private _createParticle;
        private _removeFromRoot;
        private _emitFromParticle;
        private _update;
        /** @hidden */
        static _GetAttributeNamesOrOptions(isAnimationSheetEnabled?: boolean, isBillboardBased?: boolean, useRampGradients?: boolean): string[];
        /** @hidden */
        static _GetEffectCreationOptions(isAnimationSheetEnabled?: boolean): string[];
        /**
         * Fill the defines array according to the current settings of the particle system
         * @param defines Array to be updated
         * @param blendMode blend mode to take into account when updating the array
         */
        fillDefines(defines: Array<string>, blendMode: number): void;
        /**
         * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system
         * @param uniforms Uniforms array to fill
         * @param attributes Attributes array to fill
         * @param samplers Samplers array to fill
         */
        fillUniformsAttributesAndSamplerNames(uniforms: Array<string>, attributes: Array<string>, samplers: Array<string>): void;
        /** @hidden */
        private _getEffect;
        /**
         * Animates the particle system for the current frame by emitting new particles and or animating the living ones.
         * @param preWarmOnly will prevent the system from updating the vertex buffer (default is false)
         */
        animate(preWarmOnly?: boolean): void;
        private _appendParticleVertices;
        /**
         * Rebuilds the particle system.
         */
        rebuild(): void;
        /**
         * Is this system ready to be used/rendered
         * @return true if the system is ready
         */
        isReady(): boolean;
        private _render;
        /**
         * Renders the particle system in its current state.
         * @returns the current number of particles
         */
        render(): number;
        /**
         * Disposes the particle system and free the associated resources
         * @param disposeTexture defines if the particule texture must be disposed as well (true by default)
         */
        dispose(disposeTexture?: boolean): void;
        /**
         * Clones the particle system.
         * @param name The name of the cloned object
         * @param newEmitter The new emitter to use
         * @returns the cloned particle system
         */
        clone(name: string, newEmitter: any): ParticleSystem;
        /**
         * Serializes the particle system to a JSON object
         * @param serializeTexture defines if the texture must be serialized as well
         * @returns the JSON object
         */
        serialize(serializeTexture?: boolean): any;
        /** @hidden */
        static _Serialize(serializationObject: any, particleSystem: IParticleSystem, serializeTexture: boolean): void;
        /** @hidden */
        static _Parse(parsedParticleSystem: any, particleSystem: IParticleSystem, sceneOrEngine: Scene | ThinEngine, rootUrl: string): void;
        /**
         * Parses a JSON object to create a particle system.
         * @param parsedParticleSystem The JSON object to parse
         * @param sceneOrEngine The scene or the engine to create the particle system in
         * @param rootUrl The root url to use to load external dependencies like texture
         * @param doNotStart Ignore the preventAutoStart attribute and does not start
         * @returns the Parsed particle system
         */
        static Parse(parsedParticleSystem: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string, doNotStart?: boolean): ParticleSystem;
    }
}
declare module BABYLON {
    /**
     * A particle represents one of the element emitted by a particle system.
     * This is mainly define by its coordinates, direction, velocity and age.
     */
    export class Particle {
        /**
         * The particle system the particle belongs to.
         */
        particleSystem: ParticleSystem;
        private static _Count;
        /**
         * Unique ID of the particle
         */
        id: number;
        /**
         * The world position of the particle in the scene.
         */
        position: Vector3;
        /**
         * The world direction of the particle in the scene.
         */
        direction: Vector3;
        /**
         * The color of the particle.
         */
        color: Color4;
        /**
         * The color change of the particle per step.
         */
        colorStep: Color4;
        /**
         * Defines how long will the life of the particle be.
         */
        lifeTime: number;
        /**
         * The current age of the particle.
         */
        age: number;
        /**
         * The current size of the particle.
         */
        size: number;
        /**
         * The current scale of the particle.
         */
        scale: Vector2;
        /**
         * The current angle of the particle.
         */
        angle: number;
        /**
         * Defines how fast is the angle changing.
         */
        angularSpeed: number;
        /**
         * Defines the cell index used by the particle to be rendered from a sprite.
         */
        cellIndex: number;
        /**
         * The information required to support color remapping
         */
        remapData: Vector4;
        /** @hidden */
        _randomCellOffset?: number;
        /** @hidden */
        _initialDirection: Nullable<Vector3>;
        /** @hidden */
        _attachedSubEmitters: Nullable<Array<SubEmitter>>;
        /** @hidden */
        _initialStartSpriteCellID: number;
        /** @hidden */
        _initialEndSpriteCellID: number;
        /** @hidden */
        _currentColorGradient: Nullable<ColorGradient>;
        /** @hidden */
        _currentColor1: Color4;
        /** @hidden */
        _currentColor2: Color4;
        /** @hidden */
        _currentSizeGradient: Nullable<FactorGradient>;
        /** @hidden */
        _currentSize1: number;
        /** @hidden */
        _currentSize2: number;
        /** @hidden */
        _currentAngularSpeedGradient: Nullable<FactorGradient>;
        /** @hidden */
        _currentAngularSpeed1: number;
        /** @hidden */
        _currentAngularSpeed2: number;
        /** @hidden */
        _currentVelocityGradient: Nullable<FactorGradient>;
        /** @hidden */
        _currentVelocity1: number;
        /** @hidden */
        _currentVelocity2: number;
        /** @hidden */
        _currentLimitVelocityGradient: Nullable<FactorGradient>;
        /** @hidden */
        _currentLimitVelocity1: number;
        /** @hidden */
        _currentLimitVelocity2: number;
        /** @hidden */
        _currentDragGradient: Nullable<FactorGradient>;
        /** @hidden */
        _currentDrag1: number;
        /** @hidden */
        _currentDrag2: number;
        /** @hidden */
        _randomNoiseCoordinates1: Vector3;
        /** @hidden */
        _randomNoiseCoordinates2: Vector3;
        /** @hidden */
        _localPosition?: Vector3;
        /**
         * Creates a new instance Particle
         * @param particleSystem the particle system the particle belongs to
         */
        constructor(
        /**
         * The particle system the particle belongs to.
         */
        particleSystem: ParticleSystem);
        private updateCellInfoFromSystem;
        /**
         * Defines how the sprite cell index is updated for the particle
         */
        updateCellIndex(): void;
        /** @hidden */
        _inheritParticleInfoToSubEmitter(subEmitter: SubEmitter): void;
        /** @hidden */
        _inheritParticleInfoToSubEmitters(): void;
        /** @hidden */
        _reset(): void;
        /**
         * Copy the properties of particle to another one.
         * @param other the particle to copy the information to.
         */
        copyTo(other: Particle): void;
    }
}
declare module BABYLON {
    /**
     * Particle emitter represents a volume emitting particles.
     * This is the responsibility of the implementation to define the volume shape like cone/sphere/box.
     */
    export interface IParticleEmitterType {
        /**
         * Called by the particle System when the direction is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param directionToUpdate is the direction vector to update with the result
         * @param particle is the particle we are computed the direction for
         * @param isLocal defines if the direction should be set in local space
         */
        startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void;
        /**
         * Called by the particle System when the position is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param positionToUpdate is the position vector to update with the result
         * @param particle is the particle we are computed the position for
         * @param isLocal defines if the position should be set in local space
         */
        startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void;
        /**
         * Clones the current emitter and returns a copy of it
         * @returns the new emitter
         */
        clone(): IParticleEmitterType;
        /**
         * Called by the GPUParticleSystem to setup the update shader
         * @param effect defines the update shader
         */
        applyToShader(effect: Effect): void;
        /**
         * Returns a string to use to update the GPU particles update shader
         * @returns the effect defines string
         */
        getEffectDefines(): string;
        /**
         * Returns a string representing the class name
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Serializes the particle system to a JSON object.
         * @returns the JSON object
         */
        serialize(): any;
        /**
         * Parse properties from a JSON object
         * @param serializationObject defines the JSON object
         * @param scene defines the hosting scene
         */
        parse(serializationObject: any, scene: Nullable<Scene>): void;
    }
}
declare module BABYLON {
    /**
     * Particle emitter emitting particles from the inside of a box.
     * It emits the particles randomly between 2 given directions.
     */
    export class BoxParticleEmitter implements IParticleEmitterType {
        /**
         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
         */
        direction1: Vector3;
        /**
         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
         */
        direction2: Vector3;
        /**
         * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
         */
        minEmitBox: Vector3;
        /**
         * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
         */
        maxEmitBox: Vector3;
        /**
         * Creates a new instance BoxParticleEmitter
         */
        constructor();
        /**
         * Called by the particle System when the direction is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param directionToUpdate is the direction vector to update with the result
         * @param particle is the particle we are computed the direction for
         * @param isLocal defines if the direction should be set in local space
         */
        startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void;
        /**
         * Called by the particle System when the position is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param positionToUpdate is the position vector to update with the result
         * @param particle is the particle we are computed the position for
         * @param isLocal defines if the position should be set in local space
         */
        startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void;
        /**
         * Clones the current emitter and returns a copy of it
         * @returns the new emitter
         */
        clone(): BoxParticleEmitter;
        /**
         * Called by the GPUParticleSystem to setup the update shader
         * @param effect defines the update shader
         */
        applyToShader(effect: Effect): void;
        /**
         * Returns a string to use to update the GPU particles update shader
         * @returns a string containng the defines string
         */
        getEffectDefines(): string;
        /**
         * Returns the string "BoxParticleEmitter"
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Serializes the particle system to a JSON object.
         * @returns the JSON object
         */
        serialize(): any;
        /**
         * Parse properties from a JSON object
         * @param serializationObject defines the JSON object
         */
        parse(serializationObject: any): void;
    }
}
declare module BABYLON {
    /**
     * Particle emitter emitting particles from the inside of a cone.
     * It emits the particles alongside the cone volume from the base to the particle.
     * The emission direction might be randomized.
     */
    export class ConeParticleEmitter implements IParticleEmitterType {
        /** defines how much to randomize the particle direction [0-1] (default is 0) */
        directionRandomizer: number;
        private _radius;
        private _angle;
        private _height;
        /**
         * Gets or sets a value indicating where on the radius the start position should be picked (1 = everywhere, 0 = only surface)
         */
        radiusRange: number;
        /**
         * Gets or sets a value indicating where on the height the start position should be picked (1 = everywhere, 0 = only surface)
         */
        heightRange: number;
        /**
         * Gets or sets a value indicating if all the particles should be emitted from the spawn point only (the base of the cone)
         */
        emitFromSpawnPointOnly: boolean;
        /**
         * Gets or sets the radius of the emission cone
         */
        get radius(): number;
        set radius(value: number);
        /**
         * Gets or sets the angle of the emission cone
         */
        get angle(): number;
        set angle(value: number);
        private _buildHeight;
        /**
         * Creates a new instance ConeParticleEmitter
         * @param radius the radius of the emission cone (1 by default)
         * @param angle the cone base angle (PI by default)
         * @param directionRandomizer defines how much to randomize the particle direction [0-1] (default is 0)
         */
        constructor(radius?: number, angle?: number, 
        /** defines how much to randomize the particle direction [0-1] (default is 0) */
        directionRandomizer?: number);
        /**
         * Called by the particle System when the direction is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param directionToUpdate is the direction vector to update with the result
         * @param particle is the particle we are computed the direction for
         * @param isLocal defines if the direction should be set in local space
         */
        startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void;
        /**
         * Called by the particle System when the position is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param positionToUpdate is the position vector to update with the result
         * @param particle is the particle we are computed the position for
         * @param isLocal defines if the position should be set in local space
         */
        startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void;
        /**
         * Clones the current emitter and returns a copy of it
         * @returns the new emitter
         */
        clone(): ConeParticleEmitter;
        /**
         * Called by the GPUParticleSystem to setup the update shader
         * @param effect defines the update shader
         */
        applyToShader(effect: Effect): void;
        /**
         * Returns a string to use to update the GPU particles update shader
         * @returns a string containng the defines string
         */
        getEffectDefines(): string;
        /**
         * Returns the string "ConeParticleEmitter"
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Serializes the particle system to a JSON object.
         * @returns the JSON object
         */
        serialize(): any;
        /**
         * Parse properties from a JSON object
         * @param serializationObject defines the JSON object
         */
        parse(serializationObject: any): void;
    }
}
declare module BABYLON {
    /**
     * Particle emitter emitting particles from the inside of a cylinder.
     * It emits the particles alongside the cylinder radius. The emission direction might be randomized.
     */
    export class CylinderParticleEmitter implements IParticleEmitterType {
        /**
         * The radius of the emission cylinder.
         */
        radius: number;
        /**
         * The height of the emission cylinder.
         */
        height: number;
        /**
         * The range of emission [0-1] 0 Surface only, 1 Entire Radius.
         */
        radiusRange: number;
        /**
         * How much to randomize the particle direction [0-1].
         */
        directionRandomizer: number;
        /**
        * Creates a new instance CylinderParticleEmitter
        * @param radius the radius of the emission cylinder (1 by default)
        * @param height the height of the emission cylinder (1 by default)
        * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
        * @param directionRandomizer defines how much to randomize the particle direction [0-1]
        */
        constructor(
        /**
         * The radius of the emission cylinder.
         */
        radius?: number, 
        /**
         * The height of the emission cylinder.
         */
        height?: number, 
        /**
         * The range of emission [0-1] 0 Surface only, 1 Entire Radius.
         */
        radiusRange?: number, 
        /**
         * How much to randomize the particle direction [0-1].
         */
        directionRandomizer?: number);
        /**
         * Called by the particle System when the direction is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param directionToUpdate is the direction vector to update with the result
         * @param particle is the particle we are computed the direction for
         * @param isLocal defines if the direction should be set in local space
         */
        startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void;
        /**
         * Called by the particle System when the position is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param positionToUpdate is the position vector to update with the result
         * @param particle is the particle we are computed the position for
         * @param isLocal defines if the position should be set in local space
         */
        startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void;
        /**
         * Clones the current emitter and returns a copy of it
         * @returns the new emitter
         */
        clone(): CylinderParticleEmitter;
        /**
         * Called by the GPUParticleSystem to setup the update shader
         * @param effect defines the update shader
         */
        applyToShader(effect: Effect): void;
        /**
         * Returns a string to use to update the GPU particles update shader
         * @returns a string containng the defines string
         */
        getEffectDefines(): string;
        /**
         * Returns the string "CylinderParticleEmitter"
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Serializes the particle system to a JSON object.
         * @returns the JSON object
         */
        serialize(): any;
        /**
         * Parse properties from a JSON object
         * @param serializationObject defines the JSON object
         */
        parse(serializationObject: any): void;
    }
    /**
     * Particle emitter emitting particles from the inside of a cylinder.
     * It emits the particles randomly between two vectors.
     */
    export class CylinderDirectedParticleEmitter extends CylinderParticleEmitter {
        /**
         * The min limit of the emission direction.
         */
        direction1: Vector3;
        /**
         * The max limit of the emission direction.
         */
        direction2: Vector3;
        /**
         * Creates a new instance CylinderDirectedParticleEmitter
         * @param radius the radius of the emission cylinder (1 by default)
         * @param height the height of the emission cylinder (1 by default)
         * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
         * @param direction1 the min limit of the emission direction (up vector by default)
         * @param direction2 the max limit of the emission direction (up vector by default)
         */
        constructor(radius?: number, height?: number, radiusRange?: number, 
        /**
         * The min limit of the emission direction.
         */
        direction1?: Vector3, 
        /**
         * The max limit of the emission direction.
         */
        direction2?: Vector3);
        /**
         * Called by the particle System when the direction is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param directionToUpdate is the direction vector to update with the result
         * @param particle is the particle we are computed the direction for
         */
        startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle): void;
        /**
         * Clones the current emitter and returns a copy of it
         * @returns the new emitter
         */
        clone(): CylinderDirectedParticleEmitter;
        /**
         * Called by the GPUParticleSystem to setup the update shader
         * @param effect defines the update shader
         */
        applyToShader(effect: Effect): void;
        /**
         * Returns a string to use to update the GPU particles update shader
         * @returns a string containng the defines string
         */
        getEffectDefines(): string;
        /**
         * Returns the string "CylinderDirectedParticleEmitter"
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Serializes the particle system to a JSON object.
         * @returns the JSON object
         */
        serialize(): any;
        /**
         * Parse properties from a JSON object
         * @param serializationObject defines the JSON object
         */
        parse(serializationObject: any): void;
    }
}
declare module BABYLON {
    /**
     * Particle emitter emitting particles from the inside of a hemisphere.
     * It emits the particles alongside the hemisphere radius. The emission direction might be randomized.
     */
    export class HemisphericParticleEmitter implements IParticleEmitterType {
        /**
         * The radius of the emission hemisphere.
         */
        radius: number;
        /**
         * The range of emission [0-1] 0 Surface only, 1 Entire Radius.
         */
        radiusRange: number;
        /**
         * How much to randomize the particle direction [0-1].
         */
        directionRandomizer: number;
        /**
        * Creates a new instance HemisphericParticleEmitter
        * @param radius the radius of the emission hemisphere (1 by default)
        * @param radiusRange the range of the emission hemisphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)
        * @param directionRandomizer defines how much to randomize the particle direction [0-1]
        */
        constructor(
        /**
         * The radius of the emission hemisphere.
         */
        radius?: number, 
        /**
         * The range of emission [0-1] 0 Surface only, 1 Entire Radius.
         */
        radiusRange?: number, 
        /**
         * How much to randomize the particle direction [0-1].
         */
        directionRandomizer?: number);
        /**
         * Called by the particle System when the direction is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param directionToUpdate is the direction vector to update with the result
         * @param particle is the particle we are computed the direction for
         * @param isLocal defines if the direction should be set in local space
         */
        startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void;
        /**
         * Called by the particle System when the position is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param positionToUpdate is the position vector to update with the result
         * @param particle is the particle we are computed the position for
         * @param isLocal defines if the position should be set in local space
         */
        startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void;
        /**
         * Clones the current emitter and returns a copy of it
         * @returns the new emitter
         */
        clone(): HemisphericParticleEmitter;
        /**
         * Called by the GPUParticleSystem to setup the update shader
         * @param effect defines the update shader
         */
        applyToShader(effect: Effect): void;
        /**
         * Returns a string to use to update the GPU particles update shader
         * @returns a string containng the defines string
         */
        getEffectDefines(): string;
        /**
         * Returns the string "HemisphericParticleEmitter"
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Serializes the particle system to a JSON object.
         * @returns the JSON object
         */
        serialize(): any;
        /**
         * Parse properties from a JSON object
         * @param serializationObject defines the JSON object
         */
        parse(serializationObject: any): void;
    }
}
declare module BABYLON {
    /**
     * Particle emitter emitting particles from a point.
     * It emits the particles randomly between 2 given directions.
     */
    export class PointParticleEmitter implements IParticleEmitterType {
        /**
         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
         */
        direction1: Vector3;
        /**
         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
         */
        direction2: Vector3;
        /**
         * Creates a new instance PointParticleEmitter
         */
        constructor();
        /**
         * Called by the particle System when the direction is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param directionToUpdate is the direction vector to update with the result
         * @param particle is the particle we are computed the direction for
         * @param isLocal defines if the direction should be set in local space
         */
        startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void;
        /**
         * Called by the particle System when the position is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param positionToUpdate is the position vector to update with the result
         * @param particle is the particle we are computed the position for
         * @param isLocal defines if the position should be set in local space
         */
        startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void;
        /**
         * Clones the current emitter and returns a copy of it
         * @returns the new emitter
         */
        clone(): PointParticleEmitter;
        /**
         * Called by the GPUParticleSystem to setup the update shader
         * @param effect defines the update shader
         */
        applyToShader(effect: Effect): void;
        /**
         * Returns a string to use to update the GPU particles update shader
         * @returns a string containng the defines string
         */
        getEffectDefines(): string;
        /**
         * Returns the string "PointParticleEmitter"
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Serializes the particle system to a JSON object.
         * @returns the JSON object
         */
        serialize(): any;
        /**
         * Parse properties from a JSON object
         * @param serializationObject defines the JSON object
         */
        parse(serializationObject: any): void;
    }
}
declare module BABYLON {
    /**
     * Particle emitter emitting particles from the inside of a sphere.
     * It emits the particles alongside the sphere radius. The emission direction might be randomized.
     */
    export class SphereParticleEmitter implements IParticleEmitterType {
        /**
         * The radius of the emission sphere.
         */
        radius: number;
        /**
         * The range of emission [0-1] 0 Surface only, 1 Entire Radius.
         */
        radiusRange: number;
        /**
         * How much to randomize the particle direction [0-1].
         */
        directionRandomizer: number;
        /**
        * Creates a new instance SphereParticleEmitter
        * @param radius the radius of the emission sphere (1 by default)
        * @param radiusRange the range of the emission sphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)
        * @param directionRandomizer defines how much to randomize the particle direction [0-1]
        */
        constructor(
        /**
         * The radius of the emission sphere.
         */
        radius?: number, 
        /**
         * The range of emission [0-1] 0 Surface only, 1 Entire Radius.
         */
        radiusRange?: number, 
        /**
         * How much to randomize the particle direction [0-1].
         */
        directionRandomizer?: number);
        /**
         * Called by the particle System when the direction is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param directionToUpdate is the direction vector to update with the result
         * @param particle is the particle we are computed the direction for
         * @param isLocal defines if the direction should be set in local space
         */
        startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void;
        /**
         * Called by the particle System when the position is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param positionToUpdate is the position vector to update with the result
         * @param particle is the particle we are computed the position for
         * @param isLocal defines if the position should be set in local space
         */
        startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void;
        /**
         * Clones the current emitter and returns a copy of it
         * @returns the new emitter
         */
        clone(): SphereParticleEmitter;
        /**
         * Called by the GPUParticleSystem to setup the update shader
         * @param effect defines the update shader
         */
        applyToShader(effect: Effect): void;
        /**
         * Returns a string to use to update the GPU particles update shader
         * @returns a string containng the defines string
         */
        getEffectDefines(): string;
        /**
         * Returns the string "SphereParticleEmitter"
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Serializes the particle system to a JSON object.
         * @returns the JSON object
         */
        serialize(): any;
        /**
         * Parse properties from a JSON object
         * @param serializationObject defines the JSON object
         */
        parse(serializationObject: any): void;
    }
    /**
     * Particle emitter emitting particles from the inside of a sphere.
     * It emits the particles randomly between two vectors.
     */
    export class SphereDirectedParticleEmitter extends SphereParticleEmitter {
        /**
         * The min limit of the emission direction.
         */
        direction1: Vector3;
        /**
         * The max limit of the emission direction.
         */
        direction2: Vector3;
        /**
         * Creates a new instance SphereDirectedParticleEmitter
         * @param radius the radius of the emission sphere (1 by default)
         * @param direction1 the min limit of the emission direction (up vector by default)
         * @param direction2 the max limit of the emission direction (up vector by default)
         */
        constructor(radius?: number, 
        /**
         * The min limit of the emission direction.
         */
        direction1?: Vector3, 
        /**
         * The max limit of the emission direction.
         */
        direction2?: Vector3);
        /**
         * Called by the particle System when the direction is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param directionToUpdate is the direction vector to update with the result
         * @param particle is the particle we are computed the direction for
         */
        startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle): void;
        /**
         * Clones the current emitter and returns a copy of it
         * @returns the new emitter
         */
        clone(): SphereDirectedParticleEmitter;
        /**
         * Called by the GPUParticleSystem to setup the update shader
         * @param effect defines the update shader
         */
        applyToShader(effect: Effect): void;
        /**
         * Returns a string to use to update the GPU particles update shader
         * @returns a string containng the defines string
         */
        getEffectDefines(): string;
        /**
         * Returns the string "SphereDirectedParticleEmitter"
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Serializes the particle system to a JSON object.
         * @returns the JSON object
         */
        serialize(): any;
        /**
         * Parse properties from a JSON object
         * @param serializationObject defines the JSON object
         */
        parse(serializationObject: any): void;
    }
}
declare module BABYLON {
    /**
     * Particle emitter emitting particles from a custom list of positions.
     */
    export class CustomParticleEmitter implements IParticleEmitterType {
        /**
         * Gets or sets the position generator that will create the inital position of each particle.
         * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles
         */
        particlePositionGenerator: (index: number, particle: Nullable<Particle>, outPosition: Vector3) => void;
        /**
         * Gets or sets the destination generator that will create the final destination of each particle.
         *  * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles
         */
        particleDestinationGenerator: (index: number, particle: Nullable<Particle>, outDestination: Vector3) => void;
        /**
         * Creates a new instance CustomParticleEmitter
         */
        constructor();
        /**
         * Called by the particle System when the direction is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param directionToUpdate is the direction vector to update with the result
         * @param particle is the particle we are computed the direction for
         * @param isLocal defines if the direction should be set in local space
         */
        startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void;
        /**
         * Called by the particle System when the position is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param positionToUpdate is the position vector to update with the result
         * @param particle is the particle we are computed the position for
         * @param isLocal defines if the position should be set in local space
         */
        startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void;
        /**
         * Clones the current emitter and returns a copy of it
         * @returns the new emitter
         */
        clone(): CustomParticleEmitter;
        /**
         * Called by the GPUParticleSystem to setup the update shader
         * @param effect defines the update shader
         */
        applyToShader(effect: Effect): void;
        /**
         * Returns a string to use to update the GPU particles update shader
         * @returns a string containng the defines string
         */
        getEffectDefines(): string;
        /**
         * Returns the string "PointParticleEmitter"
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Serializes the particle system to a JSON object.
         * @returns the JSON object
         */
        serialize(): any;
        /**
         * Parse properties from a JSON object
         * @param serializationObject defines the JSON object
         */
        parse(serializationObject: any): void;
    }
}
declare module BABYLON {
    /**
     * Particle emitter emitting particles from the inside of a box.
     * It emits the particles randomly between 2 given directions.
     */
    export class MeshParticleEmitter implements IParticleEmitterType {
        private _indices;
        private _positions;
        private _normals;
        private _storedNormal;
        private _mesh;
        /**
         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
         */
        direction1: Vector3;
        /**
         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
         */
        direction2: Vector3;
        /**
         * Gets or sets a boolean indicating that particle directions must be built from mesh face normals
         */
        useMeshNormalsForDirection: boolean;
        /** Defines the mesh to use as source */
        get mesh(): Nullable<AbstractMesh>;
        set mesh(value: Nullable<AbstractMesh>);
        /**
         * Creates a new instance MeshParticleEmitter
         * @param mesh defines the mesh to use as source
         */
        constructor(mesh?: Nullable<AbstractMesh>);
        /**
         * Called by the particle System when the direction is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param directionToUpdate is the direction vector to update with the result
         * @param particle is the particle we are computed the direction for
         * @param isLocal defines if the direction should be set in local space
         */
        startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void;
        /**
         * Called by the particle System when the position is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param positionToUpdate is the position vector to update with the result
         * @param particle is the particle we are computed the position for
         * @param isLocal defines if the position should be set in local space
         */
        startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void;
        /**
         * Clones the current emitter and returns a copy of it
         * @returns the new emitter
         */
        clone(): MeshParticleEmitter;
        /**
         * Called by the GPUParticleSystem to setup the update shader
         * @param effect defines the update shader
         */
        applyToShader(effect: Effect): void;
        /**
         * Returns a string to use to update the GPU particles update shader
         * @returns a string containng the defines string
         */
        getEffectDefines(): string;
        /**
         * Returns the string "BoxParticleEmitter"
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Serializes the particle system to a JSON object.
         * @returns the JSON object
         */
        serialize(): any;
        /**
         * Parse properties from a JSON object
         * @param serializationObject defines the JSON object
         * @param scene defines the hosting scene
         */
        parse(serializationObject: any, scene: Nullable<Scene>): void;
    }
}
declare module BABYLON {
    /**
     * Interface representing a particle system in Babylon.js.
     * This groups the common functionalities that needs to be implemented in order to create a particle system.
     * A particle system represents a way to manage particles from their emission to their animation and rendering.
     */
    export interface IParticleSystem {
        /**
         * List of animations used by the particle system.
         */
        animations: Animation[];
        /**
         * The id of the Particle system.
         */
        id: string;
        /**
         * The name of the Particle system.
         */
        name: string;
        /**
         * The emitter represents the Mesh or position we are attaching the particle system to.
         */
        emitter: Nullable<AbstractMesh | Vector3>;
        /**
         * Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction
         */
        isBillboardBased: boolean;
        /**
         * The rendering group used by the Particle system to chose when to render.
         */
        renderingGroupId: number;
        /**
         * The layer mask we are rendering the particles through.
         */
        layerMask: number;
        /**
        * The overall motion speed (0.01 is default update speed, faster updates = faster animation)
        */
        updateSpeed: number;
        /**
         * The amount of time the particle system is running (depends of the overall update speed).
         */
        targetStopDuration: number;
        /**
         * The texture used to render each particle. (this can be a spritesheet)
         */
        particleTexture: Nullable<BaseTexture>;
        /**
         * Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE, ParticleSystem.BLENDMODE_STANDARD or ParticleSystem.BLENDMODE_ADD.
         */
        blendMode: number;
        /**
         * Minimum life time of emitting particles.
         */
        minLifeTime: number;
        /**
         * Maximum life time of emitting particles.
         */
        maxLifeTime: number;
        /**
         * Minimum Size of emitting particles.
         */
        minSize: number;
        /**
         * Maximum Size of emitting particles.
         */
        maxSize: number;
        /**
         * Minimum scale of emitting particles on X axis.
         */
        minScaleX: number;
        /**
         * Maximum scale of emitting particles on X axis.
         */
        maxScaleX: number;
        /**
         * Minimum scale of emitting particles on Y axis.
         */
        minScaleY: number;
        /**
         * Maximum scale of emitting particles on Y axis.
         */
        maxScaleY: number;
        /**
         * Random color of each particle after it has been emitted, between color1 and color2 vectors.
         */
        color1: Color4;
        /**
         * Random color of each particle after it has been emitted, between color1 and color2 vectors.
         */
        color2: Color4;
        /**
         * Color the particle will have at the end of its lifetime.
         */
        colorDead: Color4;
        /**
         * The maximum number of particles to emit per frame until we reach the activeParticleCount value
         */
        emitRate: number;
        /**
         * You can use gravity if you want to give an orientation to your particles.
         */
        gravity: Vector3;
        /**
         * Minimum power of emitting particles.
         */
        minEmitPower: number;
        /**
         * Maximum power of emitting particles.
         */
        maxEmitPower: number;
        /**
         * Minimum angular speed of emitting particles (Z-axis rotation for each particle).
         */
        minAngularSpeed: number;
        /**
         * Maximum angular speed of emitting particles (Z-axis rotation for each particle).
         */
        maxAngularSpeed: number;
        /**
         * Gets or sets the minimal initial rotation in radians.
         */
        minInitialRotation: number;
        /**
         * Gets or sets the maximal initial rotation in radians.
         */
        maxInitialRotation: number;
        /**
         * The particle emitter type defines the emitter used by the particle system.
         * It can be for example box, sphere, or cone...
         */
        particleEmitterType: Nullable<IParticleEmitterType>;
        /**
         * Defines the delay in milliseconds before starting the system (0 by default)
         */
        startDelay: number;
        /**
         * Gets or sets a value indicating how many cycles (or frames) must be executed before first rendering (this value has to be set before starting the system). Default is 0
         */
        preWarmCycles: number;
        /**
         * Gets or sets a value indicating the time step multiplier to use in pre-warm mode (default is 1)
         */
        preWarmStepOffset: number;
        /**
         * If using a spritesheet (isAnimationSheetEnabled) defines the speed of the sprite loop (default is 1 meaning the animation will play once during the entire particle lifetime)
         */
        spriteCellChangeSpeed: number;
        /**
         * If using a spritesheet (isAnimationSheetEnabled) defines the first sprite cell to display
         */
        startSpriteCellID: number;
        /**
         * If using a spritesheet (isAnimationSheetEnabled) defines the last sprite cell to display
         */
        endSpriteCellID: number;
        /**
         * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell width to use
         */
        spriteCellWidth: number;
        /**
         * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell height to use
         */
        spriteCellHeight: number;
        /**
         * This allows the system to random pick the start cell ID between startSpriteCellID and endSpriteCellID
         */
        spriteRandomStartCell: boolean;
        /**
         * Gets or sets a boolean indicating if a spritesheet is used to animate the particles texture
         */
        isAnimationSheetEnabled: boolean;
        /** Gets or sets a Vector2 used to move the pivot (by default (0,0)) */
        translationPivot: Vector2;
        /**
         * Gets or sets a texture used to add random noise to particle positions
         */
        noiseTexture: Nullable<BaseTexture>;
        /** Gets or sets the strength to apply to the noise value (default is (10, 10, 10)) */
        noiseStrength: Vector3;
        /**
         * Gets or sets the billboard mode to use when isBillboardBased = true.
         * Value can be: ParticleSystem.BILLBOARDMODE_ALL, ParticleSystem.BILLBOARDMODE_Y, ParticleSystem.BILLBOARDMODE_STRETCHED
         */
        billboardMode: number;
        /** Gets or sets a value indicating the damping to apply if the limit velocity factor is reached */
        limitVelocityDamping: number;
        /**
         * Gets or sets a boolean indicating that hosted animations (in the system.animations array) must be started when system.start() is called
         */
        beginAnimationOnStart: boolean;
        /**
         * Gets or sets the frame to start the animation from when beginAnimationOnStart is true
         */
        beginAnimationFrom: number;
        /**
         * Gets or sets the frame to end the animation on when beginAnimationOnStart is true
         */
        beginAnimationTo: number;
        /**
         * Gets or sets a boolean indicating if animations must loop when beginAnimationOnStart is true
         */
        beginAnimationLoop: boolean;
        /**
         * Specifies whether the particle system will be disposed once it reaches the end of the animation.
         */
        disposeOnStop: boolean;
        /**
         * Specifies if the particles are updated in emitter local space or world space
         */
        isLocal: boolean;
        /** Snippet ID if the particle system was created from the snippet server */
        snippetId: string;
        /** Gets or sets a matrix to use to compute projection */
        defaultProjectionMatrix: Matrix;
        /**
         * Gets the maximum number of particles active at the same time.
         * @returns The max number of active particles.
         */
        getCapacity(): number;
        /**
         * Gets the number of particles active at the same time.
         * @returns The number of active particles.
         */
        getActiveCount(): number;
        /**
         * Gets if the system has been started. (Note: this will still be true after stop is called)
         * @returns True if it has been started, otherwise false.
         */
        isStarted(): boolean;
        /**
         * Animates the particle system for this frame.
         */
        animate(): void;
        /**
         * Renders the particle system in its current state.
         * @returns the current number of particles
         */
        render(): number;
        /**
         * Dispose the particle system and frees its associated resources.
         * @param disposeTexture defines if the particule texture must be disposed as well (true by default)
         */
        dispose(disposeTexture?: boolean): void;
        /**
        * An event triggered when the system is disposed
        */
        onDisposeObservable: Observable<IParticleSystem>;
        /**
         * Clones the particle system.
         * @param name The name of the cloned object
         * @param newEmitter The new emitter to use
         * @returns the cloned particle system
         */
        clone(name: string, newEmitter: any): Nullable<IParticleSystem>;
        /**
         * Serializes the particle system to a JSON object
         * @param serializeTexture defines if the texture must be serialized as well
         * @returns the JSON object
         */
        serialize(serializeTexture: boolean): any;
        /**
         * Rebuild the particle system
         */
        rebuild(): void;
        /** Force the system to rebuild all gradients that need to be resync */
        forceRefreshGradients(): void;
        /**
         * Starts the particle system and begins to emit
         * @param delay defines the delay in milliseconds before starting the system (0 by default)
         */
        start(delay?: number): void;
        /**
         * Stops the particle system.
         */
        stop(): void;
        /**
         * Remove all active particles
         */
        reset(): void;
        /**
         * Gets a boolean indicating that the system is stopping
         * @returns true if the system is currently stopping
         */
        isStopping(): boolean;
        /**
         * Is this system ready to be used/rendered
         * @return true if the system is ready
         */
        isReady(): boolean;
        /**
         * Returns the string "ParticleSystem"
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Gets the custom effect used to render the particles
         * @param blendMode Blend mode for which the effect should be retrieved
         * @returns The effect
         */
        getCustomEffect(blendMode: number): Nullable<Effect>;
        /**
         * Sets the custom effect used to render the particles
         * @param effect The effect to set
         * @param blendMode Blend mode for which the effect should be set
         */
        setCustomEffect(effect: Nullable<Effect>, blendMode: number): void;
        /**
         * Fill the defines array according to the current settings of the particle system
         * @param defines Array to be updated
         * @param blendMode blend mode to take into account when updating the array
         */
        fillDefines(defines: Array<string>, blendMode: number): void;
        /**
         * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system
         * @param uniforms Uniforms array to fill
         * @param attributes Attributes array to fill
         * @param samplers Samplers array to fill
         */
        fillUniformsAttributesAndSamplerNames(uniforms: Array<string>, attributes: Array<string>, samplers: Array<string>): void;
        /**
         * Observable that will be called just before the particles are drawn
         */
        onBeforeDrawParticlesObservable: Observable<Nullable<Effect>>;
        /**
         * Gets the name of the particle vertex shader
         */
        vertexShaderName: string;
        /**
         * Adds a new color gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param color1 defines the color to affect to the specified gradient
         * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from
         * @returns the current particle system
         */
        addColorGradient(gradient: number, color1: Color4, color2?: Color4): IParticleSystem;
        /**
         * Remove a specific color gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeColorGradient(gradient: number): IParticleSystem;
        /**
         * Adds a new size gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the size factor to affect to the specified gradient
         * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
         * @returns the current particle system
         */
        addSizeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;
        /**
         * Remove a specific size gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeSizeGradient(gradient: number): IParticleSystem;
        /**
         * Gets the current list of color gradients.
         * You must use addColorGradient and removeColorGradient to udpate this list
         * @returns the list of color gradients
         */
        getColorGradients(): Nullable<Array<ColorGradient>>;
        /**
         * Gets the current list of size gradients.
         * You must use addSizeGradient and removeSizeGradient to udpate this list
         * @returns the list of size gradients
         */
        getSizeGradients(): Nullable<Array<FactorGradient>>;
        /**
         * Gets the current list of angular speed gradients.
         * You must use addAngularSpeedGradient and removeAngularSpeedGradient to udpate this list
         * @returns the list of angular speed gradients
         */
        getAngularSpeedGradients(): Nullable<Array<FactorGradient>>;
        /**
         * Adds a new angular speed gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the angular speed to affect to the specified gradient
         * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
         * @returns the current particle system
         */
        addAngularSpeedGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;
        /**
         * Remove a specific angular speed gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeAngularSpeedGradient(gradient: number): IParticleSystem;
        /**
         * Gets the current list of velocity gradients.
         * You must use addVelocityGradient and removeVelocityGradient to udpate this list
         * @returns the list of velocity gradients
         */
        getVelocityGradients(): Nullable<Array<FactorGradient>>;
        /**
         * Adds a new velocity gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the velocity to affect to the specified gradient
         * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
         * @returns the current particle system
         */
        addVelocityGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;
        /**
         * Remove a specific velocity gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeVelocityGradient(gradient: number): IParticleSystem;
        /**
         * Gets the current list of limit velocity gradients.
         * You must use addLimitVelocityGradient and removeLimitVelocityGradient to udpate this list
         * @returns the list of limit velocity gradients
         */
        getLimitVelocityGradients(): Nullable<Array<FactorGradient>>;
        /**
         * Adds a new limit velocity gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the limit velocity to affect to the specified gradient
         * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
         * @returns the current particle system
         */
        addLimitVelocityGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;
        /**
         * Remove a specific limit velocity gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeLimitVelocityGradient(gradient: number): IParticleSystem;
        /**
         * Adds a new drag gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the drag to affect to the specified gradient
         * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
         * @returns the current particle system
         */
        addDragGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;
        /**
         * Remove a specific drag gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeDragGradient(gradient: number): IParticleSystem;
        /**
         * Gets the current list of drag gradients.
         * You must use addDragGradient and removeDragGradient to udpate this list
         * @returns the list of drag gradients
         */
        getDragGradients(): Nullable<Array<FactorGradient>>;
        /**
         * Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the emit rate to affect to the specified gradient
         * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
         * @returns the current particle system
         */
        addEmitRateGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;
        /**
         * Remove a specific emit rate gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeEmitRateGradient(gradient: number): IParticleSystem;
        /**
         * Gets the current list of emit rate gradients.
         * You must use addEmitRateGradient and removeEmitRateGradient to udpate this list
         * @returns the list of emit rate gradients
         */
        getEmitRateGradients(): Nullable<Array<FactorGradient>>;
        /**
         * Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the start size to affect to the specified gradient
         * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
         * @returns the current particle system
         */
        addStartSizeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;
        /**
         * Remove a specific start size gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeStartSizeGradient(gradient: number): IParticleSystem;
        /**
         * Gets the current list of start size gradients.
         * You must use addStartSizeGradient and removeStartSizeGradient to udpate this list
         * @returns the list of start size gradients
         */
        getStartSizeGradients(): Nullable<Array<FactorGradient>>;
        /**
         * Adds a new life time gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the life time factor to affect to the specified gradient
         * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
         * @returns the current particle system
         */
        addLifeTimeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;
        /**
         * Remove a specific life time gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeLifeTimeGradient(gradient: number): IParticleSystem;
        /**
         * Gets the current list of life time gradients.
         * You must use addLifeTimeGradient and removeLifeTimeGradient to udpate this list
         * @returns the list of life time gradients
         */
        getLifeTimeGradients(): Nullable<Array<FactorGradient>>;
        /**
         * Gets the current list of color gradients.
         * You must use addColorGradient and removeColorGradient to udpate this list
         * @returns the list of color gradients
         */
        getColorGradients(): Nullable<Array<ColorGradient>>;
        /**
         * Adds a new ramp gradient used to remap particle colors
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param color defines the color to affect to the specified gradient
         * @returns the current particle system
         */
        addRampGradient(gradient: number, color: Color3): IParticleSystem;
        /**
         * Gets the current list of ramp gradients.
         * You must use addRampGradient and removeRampGradient to udpate this list
         * @returns the list of ramp gradients
         */
        getRampGradients(): Nullable<Array<Color3Gradient>>;
        /** Gets or sets a boolean indicating that ramp gradients must be used
         * @see https://doc.babylonjs.com/babylon101/particles#ramp-gradients
         */
        useRampGradients: boolean;
        /**
         * Adds a new color remap gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param min defines the color remap minimal range
         * @param max defines the color remap maximal range
         * @returns the current particle system
         */
        addColorRemapGradient(gradient: number, min: number, max: number): IParticleSystem;
        /**
         * Gets the current list of color remap gradients.
         * You must use addColorRemapGradient and removeColorRemapGradient to udpate this list
         * @returns the list of color remap gradients
         */
        getColorRemapGradients(): Nullable<Array<FactorGradient>>;
        /**
         * Adds a new alpha remap gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param min defines the alpha remap minimal range
         * @param max defines the alpha remap maximal range
         * @returns the current particle system
         */
        addAlphaRemapGradient(gradient: number, min: number, max: number): IParticleSystem;
        /**
         * Gets the current list of alpha remap gradients.
         * You must use addAlphaRemapGradient and removeAlphaRemapGradient to udpate this list
         * @returns the list of alpha remap gradients
         */
        getAlphaRemapGradients(): Nullable<Array<FactorGradient>>;
        /**
         * Creates a Point Emitter for the particle system (emits directly from the emitter position)
         * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
         * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
         * @returns the emitter
         */
        createPointEmitter(direction1: Vector3, direction2: Vector3): PointParticleEmitter;
        /**
         * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)
         * @param radius The radius of the hemisphere to emit from
         * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
         * @returns the emitter
         */
        createHemisphericEmitter(radius: number, radiusRange: number): HemisphericParticleEmitter;
        /**
         * Creates a Sphere Emitter for the particle system (emits along the sphere radius)
         * @param radius The radius of the sphere to emit from
         * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
         * @returns the emitter
         */
        createSphereEmitter(radius: number, radiusRange: number): SphereParticleEmitter;
        /**
         * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)
         * @param radius The radius of the sphere to emit from
         * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere
         * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere
         * @returns the emitter
         */
        createDirectedSphereEmitter(radius: number, direction1: Vector3, direction2: Vector3): SphereDirectedParticleEmitter;
        /**
         * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)
         * @param radius The radius of the emission cylinder
         * @param height The height of the emission cylinder
         * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius
         * @param directionRandomizer How much to randomize the particle direction [0-1]
         * @returns the emitter
         */
        createCylinderEmitter(radius: number, height: number, radiusRange: number, directionRandomizer: number): CylinderParticleEmitter;
        /**
         * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)
         * @param radius The radius of the cylinder to emit from
         * @param height The height of the emission cylinder
         * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
         * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder
         * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder
         * @returns the emitter
         */
        createDirectedCylinderEmitter(radius: number, height: number, radiusRange: number, direction1: Vector3, direction2: Vector3): SphereDirectedParticleEmitter;
        /**
         * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)
         * @param radius The radius of the cone to emit from
         * @param angle The base angle of the cone
         * @returns the emitter
         */
        createConeEmitter(radius: number, angle: number): ConeParticleEmitter;
        /**
         * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)
         * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
         * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
         * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox
         * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox
         * @returns the emitter
         */
        createBoxEmitter(direction1: Vector3, direction2: Vector3, minEmitBox: Vector3, maxEmitBox: Vector3): BoxParticleEmitter;
        /**
         * Get hosting scene
         * @returns the scene
         */
        getScene(): Nullable<Scene>;
    }
}
declare module BABYLON {
    /**
     * A TransformNode is an object that is not rendered but can be used as a center of transformation. This can decrease memory usage and increase rendering speed compared to using an empty mesh as a parent and is less complicated than using a pivot matrix.
     * @see https://doc.babylonjs.com/how_to/transformnode
     */
    export class TransformNode extends Node {
        /**
         * Object will not rotate to face the camera
         */
        static BILLBOARDMODE_NONE: number;
        /**
         * Object will rotate to face the camera but only on the x axis
         */
        static BILLBOARDMODE_X: number;
        /**
         * Object will rotate to face the camera but only on the y axis
         */
        static BILLBOARDMODE_Y: number;
        /**
         * Object will rotate to face the camera but only on the z axis
         */
        static BILLBOARDMODE_Z: number;
        /**
         * Object will rotate to face the camera
         */
        static BILLBOARDMODE_ALL: number;
        /**
         * Object will rotate to face the camera's position instead of orientation
         */
        static BILLBOARDMODE_USE_POSITION: number;
        private static _TmpRotation;
        private static _TmpScaling;
        private static _TmpTranslation;
        private _forward;
        private _forwardInverted;
        private _up;
        private _right;
        private _rightInverted;
        private _position;
        private _rotation;
        private _rotationQuaternion;
        protected _scaling: Vector3;
        protected _isDirty: boolean;
        private _transformToBoneReferal;
        private _isAbsoluteSynced;
        private _billboardMode;
        /**
        * Gets or sets the billboard mode. Default is 0.
        *
        * | Value | Type | Description |
        * | --- | --- | --- |
        * | 0 | BILLBOARDMODE_NONE |  |
        * | 1 | BILLBOARDMODE_X |  |
        * | 2 | BILLBOARDMODE_Y |  |
        * | 4 | BILLBOARDMODE_Z |  |
        * | 7 | BILLBOARDMODE_ALL |  |
        *
        */
        get billboardMode(): number;
        set billboardMode(value: number);
        private _preserveParentRotationForBillboard;
        /**
         * Gets or sets a boolean indicating that parent rotation should be preserved when using billboards.
         * This could be useful for glTF objects where parent rotation helps converting from right handed to left handed
         */
        get preserveParentRotationForBillboard(): boolean;
        set preserveParentRotationForBillboard(value: boolean);
        /**
         * Multiplication factor on scale x/y/z when computing the world matrix. Eg. for a 1x1x1 cube setting this to 2 will make it a 2x2x2 cube
         */
        scalingDeterminant: number;
        private _infiniteDistance;
        /**
         * Gets or sets the distance of the object to max, often used by skybox
         */
        get infiniteDistance(): boolean;
        set infiniteDistance(value: boolean);
        /**
         * Gets or sets a boolean indicating that non uniform scaling (when at least one component is different from others) should be ignored.
         * By default the system will update normals to compensate
         */
        ignoreNonUniformScaling: boolean;
        /**
         * Gets or sets a boolean indicating that even if rotationQuaternion is defined, you can keep updating rotation property and Babylon.js will just mix both
         */
        reIntegrateRotationIntoRotationQuaternion: boolean;
        /** @hidden */
        _poseMatrix: Nullable<Matrix>;
        /** @hidden */
        _localMatrix: Matrix;
        private _usePivotMatrix;
        private _absolutePosition;
        private _absoluteScaling;
        private _absoluteRotationQuaternion;
        private _pivotMatrix;
        private _pivotMatrixInverse;
        /** @hidden */
        _postMultiplyPivotMatrix: boolean;
        protected _isWorldMatrixFrozen: boolean;
        /** @hidden */
        _indexInSceneTransformNodesArray: number;
        /**
        * An event triggered after the world matrix is updated
        */
        onAfterWorldMatrixUpdateObservable: Observable<TransformNode>;
        constructor(name: string, scene?: Nullable<Scene>, isPure?: boolean);
        /**
         * Gets a string identifying the name of the class
         * @returns "TransformNode" string
         */
        getClassName(): string;
        /**
          * Gets or set the node position (default is (0.0, 0.0, 0.0))
          */
        get position(): Vector3;
        set position(newPosition: Vector3);
        /**
          * Gets or sets the rotation property : a Vector3 defining the rotation value in radians around each local axis X, Y, Z  (default is (0.0, 0.0, 0.0)).
          * If rotation quaternion is set, this Vector3 will be ignored and copy from the quaternion
          */
        get rotation(): Vector3;
        set rotation(newRotation: Vector3);
        /**
         * Gets or sets the scaling property : a Vector3 defining the node scaling along each local axis X, Y, Z (default is (0.0, 0.0, 0.0)).
         */
        get scaling(): Vector3;
        set scaling(newScaling: Vector3);
        /**
         * Gets or sets the rotation Quaternion property : this a Quaternion object defining the node rotation by using a unit quaternion (undefined by default, but can be null).
         * If set, only the rotationQuaternion is then used to compute the node rotation (ie. node.rotation will be ignored)
         */
        get rotationQuaternion(): Nullable<Quaternion>;
        set rotationQuaternion(quaternion: Nullable<Quaternion>);
        /**
         * The forward direction of that transform in world space.
         */
        get forward(): Vector3;
        /**
         * The up direction of that transform in world space.
         */
        get up(): Vector3;
        /**
         * The right direction of that transform in world space.
         */
        get right(): Vector3;
        /**
         * Copies the parameter passed Matrix into the mesh Pose matrix.
         * @param matrix the matrix to copy the pose from
         * @returns this TransformNode.
         */
        updatePoseMatrix(matrix: Matrix): TransformNode;
        /**
         * Returns the mesh Pose matrix.
         * @returns the pose matrix
         */
        getPoseMatrix(): Matrix;
        /** @hidden */
        _isSynchronized(): boolean;
        /** @hidden */
        _initCache(): void;
        /**
        * Flag the transform node as dirty (Forcing it to update everything)
        * @param property if set to "rotation" the objects rotationQuaternion will be set to null
        * @returns this transform node
        */
        markAsDirty(property: string): TransformNode;
        /**
         * Returns the current mesh absolute position.
         * Returns a Vector3.
         */
        get absolutePosition(): Vector3;
        /**
         * Returns the current mesh absolute scaling.
         * Returns a Vector3.
         */
        get absoluteScaling(): Vector3;
        /**
         * Returns the current mesh absolute rotation.
         * Returns a Quaternion.
         */
        get absoluteRotationQuaternion(): Quaternion;
        /**
         * Sets a new matrix to apply before all other transformation
         * @param matrix defines the transform matrix
         * @returns the current TransformNode
         */
        setPreTransformMatrix(matrix: Matrix): TransformNode;
        /**
         * Sets a new pivot matrix to the current node
         * @param matrix defines the new pivot matrix to use
         * @param postMultiplyPivotMatrix defines if the pivot matrix must be cancelled in the world matrix. When this parameter is set to true (default), the inverse of the pivot matrix is also applied at the end to cancel the transformation effect
         * @returns the current TransformNode
        */
        setPivotMatrix(matrix: DeepImmutable<Matrix>, postMultiplyPivotMatrix?: boolean): TransformNode;
        /**
         * Returns the mesh pivot matrix.
         * Default : Identity.
         * @returns the matrix
         */
        getPivotMatrix(): Matrix;
        /**
         * Instantiate (when possible) or clone that node with its hierarchy
         * @param newParent defines the new parent to use for the instance (or clone)
         * @param options defines options to configure how copy is done
         * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created
         * @returns an instance (or a clone) of the current node with its hiearchy
         */
        instantiateHierarchy(newParent?: Nullable<TransformNode>, options?: {
            doNotInstantiate: boolean;
        }, onNewNodeCreated?: (source: TransformNode, clone: TransformNode) => void): Nullable<TransformNode>;
        /**
         * Prevents the World matrix to be computed any longer
         * @param newWorldMatrix defines an optional matrix to use as world matrix
         * @returns the TransformNode.
         */
        freezeWorldMatrix(newWorldMatrix?: Nullable<Matrix>): TransformNode;
        /**
         * Allows back the World matrix computation.
         * @returns the TransformNode.
         */
        unfreezeWorldMatrix(): this;
        /**
         * True if the World matrix has been frozen.
         */
        get isWorldMatrixFrozen(): boolean;
        /**
        * Retuns the mesh absolute position in the World.
        * @returns a Vector3.
        */
        getAbsolutePosition(): Vector3;
        /**
         * Sets the mesh absolute position in the World from a Vector3 or an Array(3).
         * @param absolutePosition the absolute position to set
         * @returns the TransformNode.
         */
        setAbsolutePosition(absolutePosition: Vector3): TransformNode;
        /**
         * Sets the mesh position in its local space.
         * @param vector3 the position to set in localspace
         * @returns the TransformNode.
         */
        setPositionWithLocalVector(vector3: Vector3): TransformNode;
        /**
         * Returns the mesh position in the local space from the current World matrix values.
         * @returns a new Vector3.
         */
        getPositionExpressedInLocalSpace(): Vector3;
        /**
         * Translates the mesh along the passed Vector3 in its local space.
         * @param vector3 the distance to translate in localspace
         * @returns the TransformNode.
         */
        locallyTranslate(vector3: Vector3): TransformNode;
        private static _lookAtVectorCache;
        /**
         * Orients a mesh towards a target point. Mesh must be drawn facing user.
         * @param targetPoint the position (must be in same space as current mesh) to look at
         * @param yawCor optional yaw (y-axis) correction in radians
         * @param pitchCor optional pitch (x-axis) correction in radians
         * @param rollCor optional roll (z-axis) correction in radians
         * @param space the choosen space of the target
         * @returns the TransformNode.
         */
        lookAt(targetPoint: Vector3, yawCor?: number, pitchCor?: number, rollCor?: number, space?: Space): TransformNode;
        /**
          * Returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.
          * This Vector3 is expressed in the World space.
          * @param localAxis axis to rotate
          * @returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.
          */
        getDirection(localAxis: Vector3): Vector3;
        /**
         * Sets the Vector3 "result" as the rotated Vector3 "localAxis" in the same rotation than the mesh.
         * localAxis is expressed in the mesh local space.
         * result is computed in the Wordl space from the mesh World matrix.
         * @param localAxis axis to rotate
         * @param result the resulting transformnode
         * @returns this TransformNode.
         */
        getDirectionToRef(localAxis: Vector3, result: Vector3): TransformNode;
        /**
         * Sets this transform node rotation to the given local axis.
         * @param localAxis the axis in local space
         * @param yawCor optional yaw (y-axis) correction in radians
         * @param pitchCor optional pitch (x-axis) correction in radians
         * @param rollCor optional roll (z-axis) correction in radians
         * @returns this TransformNode
         */
        setDirection(localAxis: Vector3, yawCor?: number, pitchCor?: number, rollCor?: number): TransformNode;
        /**
         * Sets a new pivot point to the current node
         * @param point defines the new pivot point to use
         * @param space defines if the point is in world or local space (local by default)
         * @returns the current TransformNode
        */
        setPivotPoint(point: Vector3, space?: Space): TransformNode;
        /**
         * Returns a new Vector3 set with the mesh pivot point coordinates in the local space.
         * @returns the pivot point
         */
        getPivotPoint(): Vector3;
        /**
         * Sets the passed Vector3 "result" with the coordinates of the mesh pivot point in the local space.
         * @param result the vector3 to store the result
         * @returns this TransformNode.
         */
        getPivotPointToRef(result: Vector3): TransformNode;
        /**
         * Returns a new Vector3 set with the mesh pivot point World coordinates.
         * @returns a new Vector3 set with the mesh pivot point World coordinates.
         */
        getAbsolutePivotPoint(): Vector3;
        /**
         * Sets the Vector3 "result" coordinates with the mesh pivot point World coordinates.
         * @param result vector3 to store the result
         * @returns this TransformNode.
         */
        getAbsolutePivotPointToRef(result: Vector3): TransformNode;
        /**
         * Defines the passed node as the parent of the current node.
         * The node will remain exactly where it is and its position / rotation will be updated accordingly
         * @see https://doc.babylonjs.com/how_to/parenting
         * @param node the node ot set as the parent
         * @returns this TransformNode.
         */
        setParent(node: Nullable<Node>): TransformNode;
        private _nonUniformScaling;
        /**
         * True if the scaling property of this object is non uniform eg. (1,2,1)
         */
        get nonUniformScaling(): boolean;
        /** @hidden */
        _updateNonUniformScalingState(value: boolean): boolean;
        /**
         * Attach the current TransformNode to another TransformNode associated with a bone
         * @param bone Bone affecting the TransformNode
         * @param affectedTransformNode TransformNode associated with the bone
         * @returns this object
         */
        attachToBone(bone: Bone, affectedTransformNode: TransformNode): TransformNode;
        /**
         * Detach the transform node if its associated with a bone
         * @returns this object
         */
        detachFromBone(): TransformNode;
        private static _rotationAxisCache;
        /**
         * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in the given space.
         * space (default LOCAL) can be either Space.LOCAL, either Space.WORLD.
         * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.
         * The passed axis is also normalized.
         * @param axis the axis to rotate around
         * @param amount the amount to rotate in radians
         * @param space Space to rotate in (Default: local)
         * @returns the TransformNode.
         */
        rotate(axis: Vector3, amount: number, space?: Space): TransformNode;
        /**
         * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in world space.
         * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.
         * The passed axis is also normalized. .
         * Method is based on http://www.euclideanspace.com/maths/geometry/affine/aroundPoint/index.htm
         * @param point the point to rotate around
         * @param axis the axis to rotate around
         * @param amount the amount to rotate in radians
         * @returns the TransformNode
         */
        rotateAround(point: Vector3, axis: Vector3, amount: number): TransformNode;
        /**
         * Translates the mesh along the axis vector for the passed distance in the given space.
         * space (default LOCAL) can be either Space.LOCAL, either Space.WORLD.
         * @param axis the axis to translate in
         * @param distance the distance to translate
         * @param space Space to rotate in (Default: local)
         * @returns the TransformNode.
         */
        translate(axis: Vector3, distance: number, space?: Space): TransformNode;
        /**
         * Adds a rotation step to the mesh current rotation.
         * x, y, z are Euler angles expressed in radians.
         * This methods updates the current mesh rotation, either mesh.rotation, either mesh.rotationQuaternion if it's set.
         * This means this rotation is made in the mesh local space only.
         * It's useful to set a custom rotation order different from the BJS standard one YXZ.
         * Example : this rotates the mesh first around its local X axis, then around its local Z axis, finally around its local Y axis.
         * ```javascript
         * mesh.addRotation(x1, 0, 0).addRotation(0, 0, z2).addRotation(0, 0, y3);
         * ```
         * Note that `addRotation()` accumulates the passed rotation values to the current ones and computes the .rotation or .rotationQuaternion updated values.
         * Under the hood, only quaternions are used. So it's a little faster is you use .rotationQuaternion because it doesn't need to translate them back to Euler angles.
         * @param x Rotation to add
         * @param y Rotation to add
         * @param z Rotation to add
         * @returns the TransformNode.
         */
        addRotation(x: number, y: number, z: number): TransformNode;
        /**
         * @hidden
         */
        protected _getEffectiveParent(): Nullable<Node>;
        /**
         * Computes the world matrix of the node
         * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch
         * @returns the world matrix
         */
        computeWorldMatrix(force?: boolean): Matrix;
        /**
         * Resets this nodeTransform's local matrix to Matrix.Identity().
         * @param independentOfChildren indicates if all child nodeTransform's world-space transform should be preserved.
         */
        resetLocalMatrix(independentOfChildren?: boolean): void;
        protected _afterComputeWorldMatrix(): void;
        /**
        * If you'd like to be called back after the mesh position, rotation or scaling has been updated.
        * @param func callback function to add
        *
        * @returns the TransformNode.
        */
        registerAfterWorldMatrixUpdate(func: (mesh: TransformNode) => void): TransformNode;
        /**
         * Removes a registered callback function.
         * @param func callback function to remove
         * @returns the TransformNode.
         */
        unregisterAfterWorldMatrixUpdate(func: (mesh: TransformNode) => void): TransformNode;
        /**
         * Gets the position of the current mesh in camera space
         * @param camera defines the camera to use
         * @returns a position
         */
        getPositionInCameraSpace(camera?: Nullable<Camera>): Vector3;
        /**
         * Returns the distance from the mesh to the active camera
         * @param camera defines the camera to use
         * @returns the distance
         */
        getDistanceToCamera(camera?: Nullable<Camera>): number;
        /**
         * Clone the current transform node
         * @param name Name of the new clone
         * @param newParent New parent for the clone
         * @param doNotCloneChildren Do not clone children hierarchy
         * @returns the new transform node
         */
        clone(name: string, newParent: Nullable<Node>, doNotCloneChildren?: boolean): Nullable<TransformNode>;
        /**
         * Serializes the objects information.
         * @param currentSerializationObject defines the object to serialize in
         * @returns the serialized object
         */
        serialize(currentSerializationObject?: any): any;
        /**
         * Returns a new TransformNode object parsed from the source provided.
         * @param parsedTransformNode is the source.
         * @param scene the scne the object belongs to
         * @param rootUrl is a string, it's the root URL to prefix the `delayLoadingFile` property with
         * @returns a new TransformNode object parsed from the source provided.
         */
        static Parse(parsedTransformNode: any, scene: Scene, rootUrl: string): TransformNode;
        /**
         * Get all child-transformNodes of this node
         * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered
         * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
         * @returns an array of TransformNode
         */
        getChildTransformNodes(directDescendantsOnly?: boolean, predicate?: (node: Node) => boolean): TransformNode[];
        /**
         * Releases resources associated with this transform node.
         * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
         * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
         */
        dispose(doNotRecurse?: boolean, disposeMaterialAndTextures?: boolean): void;
        /**
         * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)
         * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false
         * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false
         * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling
         * @returns the current mesh
         */
        normalizeToUnitCube(includeDescendants?: boolean, ignoreRotation?: boolean, predicate?: Nullable<(node: AbstractMesh) => boolean>): TransformNode;
        private _syncAbsoluteScalingAndRotation;
    }
}
declare module BABYLON {
    /**
     * Class used to override all child animations of a given target
     */
    export class AnimationPropertiesOverride {
        /**
         * Gets or sets a value indicating if animation blending must be used
         */
        enableBlending: boolean;
        /**
         * Gets or sets the blending speed to use when enableBlending is true
         */
        blendingSpeed: number;
        /**
         * Gets or sets the default loop mode to use
         */
        loopMode: number;
    }
}
declare module BABYLON {
    /**
     * Class used to store bone information
     * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons
     */
    export class Bone extends Node {
        /**
         * defines the bone name
         */
        name: string;
        private static _tmpVecs;
        private static _tmpQuat;
        private static _tmpMats;
        /**
         * Gets the list of child bones
         */
        children: Bone[];
        /** Gets the animations associated with this bone */
        animations: Animation[];
        /**
         * Gets or sets bone length
         */
        length: number;
        /**
         * @hidden Internal only
         * Set this value to map this bone to a different index in the transform matrices
         * Set this value to -1 to exclude the bone from the transform matrices
         */
        _index: Nullable<number>;
        private _skeleton;
        private _localMatrix;
        private _restPose;
        private _bindPose;
        private _baseMatrix;
        private _absoluteTransform;
        private _invertedAbsoluteTransform;
        private _parent;
        private _scalingDeterminant;
        private _worldTransform;
        private _localScaling;
        private _localRotation;
        private _localPosition;
        private _needToDecompose;
        private _needToCompose;
        /** @hidden */
        _linkedTransformNode: Nullable<TransformNode>;
        /** @hidden */
        _waitingTransformNodeId: Nullable<string>;
        /** @hidden */
        get _matrix(): Matrix;
        /** @hidden */
        set _matrix(value: Matrix);
        /**
         * Create a new bone
         * @param name defines the bone name
         * @param skeleton defines the parent skeleton
         * @param parentBone defines the parent (can be null if the bone is the root)
         * @param localMatrix defines the local matrix
         * @param restPose defines the rest pose matrix
         * @param baseMatrix defines the base matrix
         * @param index defines index of the bone in the hiearchy
         */
        constructor(
        /**
         * defines the bone name
         */
        name: string, skeleton: Skeleton, parentBone?: Nullable<Bone>, localMatrix?: Nullable<Matrix>, restPose?: Nullable<Matrix>, baseMatrix?: Nullable<Matrix>, index?: Nullable<number>);
        /**
         * Gets the current object class name.
         * @return the class name
         */
        getClassName(): string;
        /**
         * Gets the parent skeleton
         * @returns a skeleton
         */
        getSkeleton(): Skeleton;
        /**
         * Gets parent bone
         * @returns a bone or null if the bone is the root of the bone hierarchy
         */
        getParent(): Nullable<Bone>;
        /**
         * Returns an array containing the root bones
         * @returns an array containing the root bones
         */
        getChildren(): Array<Bone>;
        /**
         * Gets the node index in matrix array generated for rendering
         * @returns the node index
         */
        getIndex(): number;
        /**
         * Sets the parent bone
         * @param parent defines the parent (can be null if the bone is the root)
         * @param updateDifferenceMatrix defines if the difference matrix must be updated
         */
        setParent(parent: Nullable<Bone>, updateDifferenceMatrix?: boolean): void;
        /**
         * Gets the local matrix
         * @returns a matrix
         */
        getLocalMatrix(): Matrix;
        /**
         * Gets the base matrix (initial matrix which remains unchanged)
         * @returns a matrix
         */
        getBaseMatrix(): Matrix;
        /**
         * Gets the rest pose matrix
         * @returns a matrix
         */
        getRestPose(): Matrix;
        /**
         * Sets the rest pose matrix
         * @param matrix the local-space rest pose to set for this bone
         */
        setRestPose(matrix: Matrix): void;
        /**
         * Gets the bind pose matrix
         * @returns the bind pose matrix
         */
        getBindPose(): Matrix;
        /**
         * Sets the bind pose matrix
         * @param matrix the local-space bind pose to set for this bone
         */
        setBindPose(matrix: Matrix): void;
        /**
         * Gets a matrix used to store world matrix (ie. the matrix sent to shaders)
         */
        getWorldMatrix(): Matrix;
        /**
         * Sets the local matrix to rest pose matrix
         */
        returnToRest(): void;
        /**
         * Gets the inverse of the absolute transform matrix.
         * This matrix will be multiplied by local matrix to get the difference matrix (ie. the difference between original state and current state)
         * @returns a matrix
         */
        getInvertedAbsoluteTransform(): Matrix;
        /**
         * Gets the absolute transform matrix (ie base matrix * parent world matrix)
         * @returns a matrix
         */
        getAbsoluteTransform(): Matrix;
        /**
         * Links with the given transform node.
         * The local matrix of this bone is copied from the transform node every frame.
         * @param transformNode defines the transform node to link to
         */
        linkTransformNode(transformNode: Nullable<TransformNode>): void;
        /**
         * Gets the node used to drive the bone's transformation
         * @returns a transform node or null
         */
        getTransformNode(): Nullable<TransformNode>;
        /** Gets or sets current position (in local space) */
        get position(): Vector3;
        set position(newPosition: Vector3);
        /** Gets or sets current rotation (in local space) */
        get rotation(): Vector3;
        set rotation(newRotation: Vector3);
        /** Gets or sets current rotation quaternion (in local space) */
        get rotationQuaternion(): Quaternion;
        set rotationQuaternion(newRotation: Quaternion);
        /** Gets or sets current scaling (in local space) */
        get scaling(): Vector3;
        set scaling(newScaling: Vector3);
        /**
         * Gets the animation properties override
         */
        get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride>;
        private _decompose;
        private _compose;
        /**
         * Update the base and local matrices
         * @param matrix defines the new base or local matrix
         * @param updateDifferenceMatrix defines if the difference matrix must be updated
         * @param updateLocalMatrix defines if the local matrix should be updated
         */
        updateMatrix(matrix: Matrix, updateDifferenceMatrix?: boolean, updateLocalMatrix?: boolean): void;
        /** @hidden */
        _updateDifferenceMatrix(rootMatrix?: Matrix, updateChildren?: boolean): void;
        /**
         * Flag the bone as dirty (Forcing it to update everything)
         */
        markAsDirty(): void;
        /** @hidden */
        _markAsDirtyAndCompose(): void;
        private _markAsDirtyAndDecompose;
        /**
         * Translate the bone in local or world space
         * @param vec The amount to translate the bone
         * @param space The space that the translation is in
         * @param mesh The mesh that this bone is attached to. This is only used in world space
         */
        translate(vec: Vector3, space?: Space, mesh?: AbstractMesh): void;
        /**
         * Set the postion of the bone in local or world space
         * @param position The position to set the bone
         * @param space The space that the position is in
         * @param mesh The mesh that this bone is attached to.  This is only used in world space
         */
        setPosition(position: Vector3, space?: Space, mesh?: AbstractMesh): void;
        /**
         * Set the absolute position of the bone (world space)
         * @param position The position to set the bone
         * @param mesh The mesh that this bone is attached to
         */
        setAbsolutePosition(position: Vector3, mesh?: AbstractMesh): void;
        /**
         * Scale the bone on the x, y and z axes (in local space)
         * @param x The amount to scale the bone on the x axis
         * @param y The amount to scale the bone on the y axis
         * @param z The amount to scale the bone on the z axis
         * @param scaleChildren sets this to true if children of the bone should be scaled as well (false by default)
         */
        scale(x: number, y: number, z: number, scaleChildren?: boolean): void;
        /**
         * Set the bone scaling in local space
         * @param scale defines the scaling vector
         */
        setScale(scale: Vector3): void;
        /**
         * Gets the current scaling in local space
         * @returns the current scaling vector
         */
        getScale(): Vector3;
        /**
         * Gets the current scaling in local space and stores it in a target vector
         * @param result defines the target vector
         */
        getScaleToRef(result: Vector3): void;
        /**
         * Set the yaw, pitch, and roll of the bone in local or world space
         * @param yaw The rotation of the bone on the y axis
         * @param pitch The rotation of the bone on the x axis
         * @param roll The rotation of the bone on the z axis
         * @param space The space that the axes of rotation are in
         * @param mesh The mesh that this bone is attached to.  This is only used in world space
         */
        setYawPitchRoll(yaw: number, pitch: number, roll: number, space?: Space, mesh?: AbstractMesh): void;
        /**
         * Add a rotation to the bone on an axis in local or world space
         * @param axis The axis to rotate the bone on
         * @param amount The amount to rotate the bone
         * @param space The space that the axis is in
         * @param mesh The mesh that this bone is attached to. This is only used in world space
         */
        rotate(axis: Vector3, amount: number, space?: Space, mesh?: AbstractMesh): void;
        /**
         * Set the rotation of the bone to a particular axis angle in local or world space
         * @param axis The axis to rotate the bone on
         * @param angle The angle that the bone should be rotated to
         * @param space The space that the axis is in
         * @param mesh The mesh that this bone is attached to.  This is only used in world space
         */
        setAxisAngle(axis: Vector3, angle: number, space?: Space, mesh?: AbstractMesh): void;
        /**
         * Set the euler rotation of the bone in local or world space
         * @param rotation The euler rotation that the bone should be set to
         * @param space The space that the rotation is in
         * @param mesh The mesh that this bone is attached to. This is only used in world space
         */
        setRotation(rotation: Vector3, space?: Space, mesh?: AbstractMesh): void;
        /**
         * Set the quaternion rotation of the bone in local or world space
         * @param quat The quaternion rotation that the bone should be set to
         * @param space The space that the rotation is in
         * @param mesh The mesh that this bone is attached to. This is only used in world space
         */
        setRotationQuaternion(quat: Quaternion, space?: Space, mesh?: AbstractMesh): void;
        /**
         * Set the rotation matrix of the bone in local or world space
         * @param rotMat The rotation matrix that the bone should be set to
         * @param space The space that the rotation is in
         * @param mesh The mesh that this bone is attached to. This is only used in world space
         */
        setRotationMatrix(rotMat: Matrix, space?: Space, mesh?: AbstractMesh): void;
        private _rotateWithMatrix;
        private _getNegativeRotationToRef;
        /**
         * Get the position of the bone in local or world space
         * @param space The space that the returned position is in
         * @param mesh The mesh that this bone is attached to. This is only used in world space
         * @returns The position of the bone
         */
        getPosition(space?: Space, mesh?: Nullable<AbstractMesh>): Vector3;
        /**
         * Copy the position of the bone to a vector3 in local or world space
         * @param space The space that the returned position is in
         * @param mesh The mesh that this bone is attached to. This is only used in world space
         * @param result The vector3 to copy the position to
         */
        getPositionToRef(space: Space | undefined, mesh: Nullable<AbstractMesh>, result: Vector3): void;
        /**
         * Get the absolute position of the bone (world space)
         * @param mesh The mesh that this bone is attached to
         * @returns The absolute position of the bone
         */
        getAbsolutePosition(mesh?: Nullable<AbstractMesh>): Vector3;
        /**
         * Copy the absolute position of the bone (world space) to the result param
         * @param mesh The mesh that this bone is attached to
         * @param result The vector3 to copy the absolute position to
         */
        getAbsolutePositionToRef(mesh: AbstractMesh, result: Vector3): void;
        /**
         * Compute the absolute transforms of this bone and its children
         */
        computeAbsoluteTransforms(): void;
        /**
         * Get the world direction from an axis that is in the local space of the bone
         * @param localAxis The local direction that is used to compute the world direction
         * @param mesh The mesh that this bone is attached to
         * @returns The world direction
         */
        getDirection(localAxis: Vector3, mesh?: Nullable<AbstractMesh>): Vector3;
        /**
         * Copy the world direction to a vector3 from an axis that is in the local space of the bone
         * @param localAxis The local direction that is used to compute the world direction
         * @param mesh The mesh that this bone is attached to
         * @param result The vector3 that the world direction will be copied to
         */
        getDirectionToRef(localAxis: Vector3, mesh: AbstractMesh | null | undefined, result: Vector3): void;
        /**
         * Get the euler rotation of the bone in local or world space
         * @param space The space that the rotation should be in
         * @param mesh The mesh that this bone is attached to.  This is only used in world space
         * @returns The euler rotation
         */
        getRotation(space?: Space, mesh?: Nullable<AbstractMesh>): Vector3;
        /**
         * Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space
         * @param space The space that the rotation should be in
         * @param mesh The mesh that this bone is attached to.  This is only used in world space
         * @param result The vector3 that the rotation should be copied to
         */
        getRotationToRef(space: Space | undefined, mesh: AbstractMesh | null | undefined, result: Vector3): void;
        /**
         * Get the quaternion rotation of the bone in either local or world space
         * @param space The space that the rotation should be in
         * @param mesh The mesh that this bone is attached to.  This is only used in world space
         * @returns The quaternion rotation
         */
        getRotationQuaternion(space?: Space, mesh?: Nullable<AbstractMesh>): Quaternion;
        /**
         * Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space
         * @param space The space that the rotation should be in
         * @param mesh The mesh that this bone is attached to.  This is only used in world space
         * @param result The quaternion that the rotation should be copied to
         */
        getRotationQuaternionToRef(space: Space | undefined, mesh: AbstractMesh | null | undefined, result: Quaternion): void;
        /**
         * Get the rotation matrix of the bone in local or world space
         * @param space The space that the rotation should be in
         * @param mesh The mesh that this bone is attached to.  This is only used in world space
         * @returns The rotation matrix
         */
        getRotationMatrix(space: Space | undefined, mesh: AbstractMesh): Matrix;
        /**
         * Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space
         * @param space The space that the rotation should be in
         * @param mesh The mesh that this bone is attached to.  This is only used in world space
         * @param result The quaternion that the rotation should be copied to
         */
        getRotationMatrixToRef(space: Space | undefined, mesh: AbstractMesh, result: Matrix): void;
        /**
         * Get the world position of a point that is in the local space of the bone
         * @param position The local position
         * @param mesh The mesh that this bone is attached to
         * @returns The world position
         */
        getAbsolutePositionFromLocal(position: Vector3, mesh?: Nullable<AbstractMesh>): Vector3;
        /**
         * Get the world position of a point that is in the local space of the bone and copy it to the result param
         * @param position The local position
         * @param mesh The mesh that this bone is attached to
         * @param result The vector3 that the world position should be copied to
         */
        getAbsolutePositionFromLocalToRef(position: Vector3, mesh: AbstractMesh | null | undefined, result: Vector3): void;
        /**
         * Get the local position of a point that is in world space
         * @param position The world position
         * @param mesh The mesh that this bone is attached to
         * @returns The local position
         */
        getLocalPositionFromAbsolute(position: Vector3, mesh?: Nullable<AbstractMesh>): Vector3;
        /**
         * Get the local position of a point that is in world space and copy it to the result param
         * @param position The world position
         * @param mesh The mesh that this bone is attached to
         * @param result The vector3 that the local position should be copied to
         */
        getLocalPositionFromAbsoluteToRef(position: Vector3, mesh: AbstractMesh | null | undefined, result: Vector3): void;
    }
}
declare module BABYLON {
    /**
     * Defines a runtime animation
     */
    export class RuntimeAnimation {
        private _events;
        /**
         * The current frame of the runtime animation
         */
        private _currentFrame;
        /**
         * The animation used by the runtime animation
         */
        private _animation;
        /**
         * The target of the runtime animation
         */
        private _target;
        /**
         * The initiating animatable
         */
        private _host;
        /**
         * The original value of the runtime animation
         */
        private _originalValue;
        /**
         * The original blend value of the runtime animation
         */
        private _originalBlendValue;
        /**
         * The offsets cache of the runtime animation
         */
        private _offsetsCache;
        /**
         * The high limits cache of the runtime animation
         */
        private _highLimitsCache;
        /**
         * Specifies if the runtime animation has been stopped
         */
        private _stopped;
        /**
         * The blending factor of the runtime animation
         */
        private _blendingFactor;
        /**
         * The BabylonJS scene
         */
        private _scene;
        /**
         * The current value of the runtime animation
         */
        private _currentValue;
        /** @hidden */
        _animationState: _IAnimationState;
        /**
         * The active target of the runtime animation
         */
        private _activeTargets;
        private _currentActiveTarget;
        private _directTarget;
        /**
         * The target path of the runtime animation
         */
        private _targetPath;
        /**
         * The weight of the runtime animation
         */
        private _weight;
        /**
         * The ratio offset of the runtime animation
         */
        private _ratioOffset;
        /**
         * The previous delay of the runtime animation
         */
        private _previousDelay;
        /**
         * The previous ratio of the runtime animation
         */
        private _previousRatio;
        private _enableBlending;
        private _keys;
        private _minFrame;
        private _maxFrame;
        private _minValue;
        private _maxValue;
        private _targetIsArray;
        /**
         * Gets the current frame of the runtime animation
         */
        get currentFrame(): number;
        /**
         * Gets the weight of the runtime animation
         */
        get weight(): number;
        /**
         * Gets the current value of the runtime animation
         */
        get currentValue(): any;
        /**
         * Gets the target path of the runtime animation
         */
        get targetPath(): string;
        /**
         * Gets the actual target of the runtime animation
         */
        get target(): any;
        /**
         * Gets the additive state of the runtime animation
         */
        get isAdditive(): boolean;
        /** @hidden */
        _onLoop: () => void;
        /**
         * Create a new RuntimeAnimation object
         * @param target defines the target of the animation
         * @param animation defines the source animation object
         * @param scene defines the hosting scene
         * @param host defines the initiating Animatable
         */
        constructor(target: any, animation: Animation, scene: Scene, host: Animatable);
        private _preparePath;
        /**
         * Gets the animation from the runtime animation
         */
        get animation(): Animation;
        /**
         * Resets the runtime animation to the beginning
         * @param restoreOriginal defines whether to restore the target property to the original value
         */
        reset(restoreOriginal?: boolean): void;
        /**
         * Specifies if the runtime animation is stopped
         * @returns Boolean specifying if the runtime animation is stopped
         */
        isStopped(): boolean;
        /**
         * Disposes of the runtime animation
         */
        dispose(): void;
        /**
         * Apply the interpolated value to the target
         * @param currentValue defines the value computed by the animation
         * @param weight defines the weight to apply to this value (Defaults to 1.0)
         */
        setValue(currentValue: any, weight: number): void;
        private _getOriginalValues;
        private _setValue;
        /**
         * Gets the loop pmode of the runtime animation
         * @returns Loop Mode
         */
        private _getCorrectLoopMode;
        /**
         * Move the current animation to a given frame
         * @param frame defines the frame to move to
         */
        goToFrame(frame: number): void;
        /**
         * @hidden Internal use only
         */
        _prepareForSpeedRatioChange(newSpeedRatio: number): void;
        /**
         * Execute the current animation
         * @param delay defines the delay to add to the current frame
         * @param from defines the lower bound of the animation range
         * @param to defines the upper bound of the animation range
         * @param loop defines if the current animation must loop
         * @param speedRatio defines the current speed ratio
         * @param weight defines the weight of the animation (default is -1 so no weight)
         * @param onLoop optional callback called when animation loops
         * @returns a boolean indicating if the animation is running
         */
        animate(delay: number, from: number, to: number, loop: boolean, speedRatio: number, weight?: number): boolean;
    }
}
declare module BABYLON {
    /**
     * Class used to store an actual running animation
     */
    export class Animatable {
        /** defines the target object */
        target: any;
        /** defines the starting frame number (default is 0) */
        fromFrame: number;
        /** defines the ending frame number (default is 100) */
        toFrame: number;
        /** defines if the animation must loop (default is false)  */
        loopAnimation: boolean;
        /** defines a callback to call when animation ends if it is not looping */
        onAnimationEnd?: (() => void) | null | undefined;
        /** defines a callback to call when animation loops */
        onAnimationLoop?: (() => void) | null | undefined;
        /** defines whether the animation should be evaluated additively */
        isAdditive: boolean;
        private _localDelayOffset;
        private _pausedDelay;
        private _runtimeAnimations;
        private _paused;
        private _scene;
        private _speedRatio;
        private _weight;
        private _syncRoot;
        /**
         * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.
         * This will only apply for non looping animation (default is true)
         */
        disposeOnEnd: boolean;
        /**
         * Gets a boolean indicating if the animation has started
         */
        animationStarted: boolean;
        /**
         * Observer raised when the animation ends
         */
        onAnimationEndObservable: Observable<Animatable>;
        /**
         * Observer raised when the animation loops
         */
        onAnimationLoopObservable: Observable<Animatable>;
        /**
         * Gets the root Animatable used to synchronize and normalize animations
         */
        get syncRoot(): Nullable<Animatable>;
        /**
         * Gets the current frame of the first RuntimeAnimation
         * Used to synchronize Animatables
         */
        get masterFrame(): number;
        /**
         * Gets or sets the animatable weight (-1.0 by default meaning not weighted)
         */
        get weight(): number;
        set weight(value: number);
        /**
         * Gets or sets the speed ratio to apply to the animatable (1.0 by default)
         */
        get speedRatio(): number;
        set speedRatio(value: number);
        /**
         * Creates a new Animatable
         * @param scene defines the hosting scene
         * @param target defines the target object
         * @param fromFrame defines the starting frame number (default is 0)
         * @param toFrame defines the ending frame number (default is 100)
         * @param loopAnimation defines if the animation must loop (default is false)
         * @param speedRatio defines the factor to apply to animation speed (default is 1)
         * @param onAnimationEnd defines a callback to call when animation ends if it is not looping
         * @param animations defines a group of animation to add to the new Animatable
         * @param onAnimationLoop defines a callback to call when animation loops
         * @param isAdditive defines whether the animation should be evaluated additively
         */
        constructor(scene: Scene, 
        /** defines the target object */
        target: any, 
        /** defines the starting frame number (default is 0) */
        fromFrame?: number, 
        /** defines the ending frame number (default is 100) */
        toFrame?: number, 
        /** defines if the animation must loop (default is false)  */
        loopAnimation?: boolean, speedRatio?: number, 
        /** defines a callback to call when animation ends if it is not looping */
        onAnimationEnd?: (() => void) | null | undefined, animations?: Animation[], 
        /** defines a callback to call when animation loops */
        onAnimationLoop?: (() => void) | null | undefined, 
        /** defines whether the animation should be evaluated additively */
        isAdditive?: boolean);
        /**
         * Synchronize and normalize current Animatable with a source Animatable
         * This is useful when using animation weights and when animations are not of the same length
         * @param root defines the root Animatable to synchronize with
         * @returns the current Animatable
         */
        syncWith(root: Animatable): Animatable;
        /**
         * Gets the list of runtime animations
         * @returns an array of RuntimeAnimation
         */
        getAnimations(): RuntimeAnimation[];
        /**
         * Adds more animations to the current animatable
         * @param target defines the target of the animations
         * @param animations defines the new animations to add
         */
        appendAnimations(target: any, animations: Animation[]): void;
        /**
         * Gets the source animation for a specific property
         * @param property defines the propertyu to look for
         * @returns null or the source animation for the given property
         */
        getAnimationByTargetProperty(property: string): Nullable<Animation>;
        /**
         * Gets the runtime animation for a specific property
         * @param property defines the propertyu to look for
         * @returns null or the runtime animation for the given property
         */
        getRuntimeAnimationByTargetProperty(property: string): Nullable<RuntimeAnimation>;
        /**
         * Resets the animatable to its original state
         */
        reset(): void;
        /**
         * Allows the animatable to blend with current running animations
         * @see https://doc.babylonjs.com/babylon101/animations#animation-blending
         * @param blendingSpeed defines the blending speed to use
         */
        enableBlending(blendingSpeed: number): void;
        /**
         * Disable animation blending
         * @see https://doc.babylonjs.com/babylon101/animations#animation-blending
         */
        disableBlending(): void;
        /**
         * Jump directly to a given frame
         * @param frame defines the frame to jump to
         */
        goToFrame(frame: number): void;
        /**
         * Pause the animation
         */
        pause(): void;
        /**
         * Restart the animation
         */
        restart(): void;
        private _raiseOnAnimationEnd;
        /**
         * Stop and delete the current animation
         * @param animationName defines a string used to only stop some of the runtime animations instead of all
         * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)
         */
        stop(animationName?: string, targetMask?: (target: any) => boolean): void;
        /**
         * Wait asynchronously for the animation to end
         * @returns a promise which will be fullfilled when the animation ends
         */
        waitAsync(): Promise<Animatable>;
        /** @hidden */
        _animate(delay: number): boolean;
    }
        interface Scene {
            /** @hidden */
            _registerTargetForLateAnimationBinding(runtimeAnimation: RuntimeAnimation, originalValue: any): void;
            /** @hidden */
            _processLateAnimationBindingsForMatrices(holder: {
                totalWeight: number;
                totalAdditiveWeight: number;
                animations: RuntimeAnimation[];
                additiveAnimations: RuntimeAnimation[];
                originalValue: Matrix;
            }): any;
            /** @hidden */
            _processLateAnimationBindingsForQuaternions(holder: {
                totalWeight: number;
                totalAdditiveWeight: number;
                animations: RuntimeAnimation[];
                additiveAnimations: RuntimeAnimation[];
                originalValue: Quaternion;
            }, refQuaternion: Quaternion): Quaternion;
            /** @hidden */
            _processLateAnimationBindings(): void;
            /**
             * Will start the animation sequence of a given target
             * @param target defines the target
             * @param from defines from which frame should animation start
             * @param to defines until which frame should animation run.
             * @param weight defines the weight to apply to the animation (1.0 by default)
             * @param loop defines if the animation loops
             * @param speedRatio defines the speed in which to run the animation (1.0 by default)
             * @param onAnimationEnd defines the function to be executed when the animation ends
             * @param animatable defines an animatable object. If not provided a new one will be created from the given params
             * @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)
             * @param onAnimationLoop defines the callback to call when an animation loops
             * @param isAdditive defines whether the animation should be evaluated additively (false by default)
             * @returns the animatable object created for this animation
             */
            beginWeightedAnimation(target: any, from: number, to: number, weight: number, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void, animatable?: Animatable, targetMask?: (target: any) => boolean, onAnimationLoop?: () => void, isAdditive?: boolean): Animatable;
            /**
             * Will start the animation sequence of a given target
             * @param target defines the target
             * @param from defines from which frame should animation start
             * @param to defines until which frame should animation run.
             * @param loop defines if the animation loops
             * @param speedRatio defines the speed in which to run the animation (1.0 by default)
             * @param onAnimationEnd defines the function to be executed when the animation ends
             * @param animatable defines an animatable object. If not provided a new one will be created from the given params
             * @param stopCurrent defines if the current animations must be stopped first (true by default)
             * @param targetMask defines if the target should be animate if animations are present (this is called recursively on descendant animatables regardless of return value)
             * @param onAnimationLoop defines the callback to call when an animation loops
             * @param isAdditive defines whether the animation should be evaluated additively (false by default)
             * @returns the animatable object created for this animation
             */
            beginAnimation(target: any, from: number, to: number, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void, animatable?: Animatable, stopCurrent?: boolean, targetMask?: (target: any) => boolean, onAnimationLoop?: () => void, isAdditive?: boolean): Animatable;
            /**
             * Will start the animation sequence of a given target and its hierarchy
             * @param target defines the target
             * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.
             * @param from defines from which frame should animation start
             * @param to defines until which frame should animation run.
             * @param loop defines if the animation loops
             * @param speedRatio defines the speed in which to run the animation (1.0 by default)
             * @param onAnimationEnd defines the function to be executed when the animation ends
             * @param animatable defines an animatable object. If not provided a new one will be created from the given params
             * @param stopCurrent defines if the current animations must be stopped first (true by default)
             * @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)
             * @param onAnimationLoop defines the callback to call when an animation loops
             * @param isAdditive defines whether the animation should be evaluated additively (false by default)
             * @returns the list of created animatables
             */
            beginHierarchyAnimation(target: any, directDescendantsOnly: boolean, from: number, to: number, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void, animatable?: Animatable, stopCurrent?: boolean, targetMask?: (target: any) => boolean, onAnimationLoop?: () => void, isAdditive?: boolean): Animatable[];
            /**
             * Begin a new animation on a given node
             * @param target defines the target where the animation will take place
             * @param animations defines the list of animations to start
             * @param from defines the initial value
             * @param to defines the final value
             * @param loop defines if you want animation to loop (off by default)
             * @param speedRatio defines the speed ratio to apply to all animations
             * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)
             * @param onAnimationLoop defines the callback to call when an animation loops
             * @param isAdditive defines whether the animation should be evaluated additively (false by default)
             * @returns the list of created animatables
             */
            beginDirectAnimation(target: any, animations: Animation[], from: number, to: number, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void, onAnimationLoop?: () => void, isAdditive?: boolean): Animatable;
            /**
             * Begin a new animation on a given node and its hierarchy
             * @param target defines the root node where the animation will take place
             * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.
             * @param animations defines the list of animations to start
             * @param from defines the initial value
             * @param to defines the final value
             * @param loop defines if you want animation to loop (off by default)
             * @param speedRatio defines the speed ratio to apply to all animations
             * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)
             * @param onAnimationLoop defines the callback to call when an animation loops
             * @param isAdditive defines whether the animation should be evaluated additively (false by default)
             * @returns the list of animatables created for all nodes
             */
            beginDirectHierarchyAnimation(target: Node, directDescendantsOnly: boolean, animations: Animation[], from: number, to: number, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void, onAnimationLoop?: () => void, isAdditive?: boolean): Animatable[];
            /**
             * Gets the animatable associated with a specific target
             * @param target defines the target of the animatable
             * @returns the required animatable if found
             */
            getAnimatableByTarget(target: any): Nullable<Animatable>;
            /**
             * Gets all animatables associated with a given target
             * @param target defines the target to look animatables for
             * @returns an array of Animatables
             */
            getAllAnimatablesByTarget(target: any): Array<Animatable>;
            /**
            * Stops and removes all animations that have been applied to the scene
            */
            stopAllAnimations(): void;
            /**
             * Gets the current delta time used by animation engine
             */
            deltaTime: number;
        }
        interface Bone {
            /**
             * Copy an animation range from another bone
             * @param source defines the source bone
             * @param rangeName defines the range name to copy
             * @param frameOffset defines the frame offset
             * @param rescaleAsRequired defines if rescaling must be applied if required
             * @param skelDimensionsRatio defines the scaling ratio
             * @returns true if operation was successful
             */
            copyAnimationRange(source: Bone, rangeName: string, frameOffset: number, rescaleAsRequired: boolean, skelDimensionsRatio: Nullable<Vector3>): boolean;
        }
}
declare module BABYLON {
    /**
     * Class used to handle skinning animations
     * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons
     */
    export class Skeleton implements IAnimatable {
        /** defines the skeleton name */
        name: string;
        /** defines the skeleton Id */
        id: string;
        /**
         * Defines the list of child bones
         */
        bones: Bone[];
        /**
         * Defines an estimate of the dimension of the skeleton at rest
         */
        dimensionsAtRest: Vector3;
        /**
         * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)
         */
        needInitialSkinMatrix: boolean;
        /**
         * Defines a mesh that override the matrix used to get the world matrix (null by default).
         */
        overrideMesh: Nullable<AbstractMesh>;
        /**
         * Gets the list of animations attached to this skeleton
         */
        animations: Array<Animation>;
        private _scene;
        private _isDirty;
        private _transformMatrices;
        private _transformMatrixTexture;
        private _meshesWithPoseMatrix;
        private _animatables;
        private _identity;
        private _synchronizedWithMesh;
        private _ranges;
        private _lastAbsoluteTransformsUpdateId;
        private _canUseTextureForBones;
        private _uniqueId;
        /** @hidden */
        _numBonesWithLinkedTransformNode: number;
        /** @hidden */
        _hasWaitingData: Nullable<boolean>;
        /** @hidden */
        _waitingOverrideMeshId: Nullable<string>;
        /**
         * Specifies if the skeleton should be serialized
         */
        doNotSerialize: boolean;
        private _useTextureToStoreBoneMatrices;
        /**
         * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).
         * Please note that this option is not available if the hardware does not support it
         */
        get useTextureToStoreBoneMatrices(): boolean;
        set useTextureToStoreBoneMatrices(value: boolean);
        private _animationPropertiesOverride;
        /**
         * Gets or sets the animation properties override
         */
        get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride>;
        set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>);
        /**
         * List of inspectable custom properties (used by the Inspector)
         * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility
         */
        inspectableCustomProperties: IInspectable[];
        /**
         * An observable triggered before computing the skeleton's matrices
         */
        onBeforeComputeObservable: Observable<Skeleton>;
        /**
         * Gets a boolean indicating that the skeleton effectively stores matrices into a texture
         */
        get isUsingTextureForMatrices(): boolean;
        /**
         * Gets the unique ID of this skeleton
         */
        get uniqueId(): number;
        /**
         * Creates a new skeleton
         * @param name defines the skeleton name
         * @param id defines the skeleton Id
         * @param scene defines the hosting scene
         */
        constructor(
        /** defines the skeleton name */
        name: string, 
        /** defines the skeleton Id */
        id: string, scene: Scene);
        /**
         * Gets the current object class name.
         * @return the class name
         */
        getClassName(): string;
        /**
         * Returns an array containing the root bones
         * @returns an array containing the root bones
         */
        getChildren(): Array<Bone>;
        /**
         * Gets the list of transform matrices to send to shaders (one matrix per bone)
         * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)
         * @returns a Float32Array containing matrices data
         */
        getTransformMatrices(mesh: AbstractMesh): Float32Array;
        /**
         * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)
         * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)
         * @returns a raw texture containing the data
         */
        getTransformMatrixTexture(mesh: AbstractMesh): Nullable<RawTexture>;
        /**
         * Gets the current hosting scene
         * @returns a scene object
         */
        getScene(): Scene;
        /**
         * Gets a string representing the current skeleton data
         * @param fullDetails defines a boolean indicating if we want a verbose version
         * @returns a string representing the current skeleton data
         */
        toString(fullDetails?: boolean): string;
        /**
        * Get bone's index searching by name
        * @param name defines bone's name to search for
        * @return the indice of the bone. Returns -1 if not found
        */
        getBoneIndexByName(name: string): number;
        /**
         * Creater a new animation range
         * @param name defines the name of the range
         * @param from defines the start key
         * @param to defines the end key
         */
        createAnimationRange(name: string, from: number, to: number): void;
        /**
         * Delete a specific animation range
         * @param name defines the name of the range
         * @param deleteFrames defines if frames must be removed as well
         */
        deleteAnimationRange(name: string, deleteFrames?: boolean): void;
        /**
         * Gets a specific animation range
         * @param name defines the name of the range to look for
         * @returns the requested animation range or null if not found
         */
        getAnimationRange(name: string): Nullable<AnimationRange>;
        /**
         * Gets the list of all animation ranges defined on this skeleton
         * @returns an array
         */
        getAnimationRanges(): Nullable<AnimationRange>[];
        /**
         * Copy animation range from a source skeleton.
         * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences
         * @param source defines the source skeleton
         * @param name defines the name of the range to copy
         * @param rescaleAsRequired defines if rescaling must be applied if required
         * @returns true if operation was successful
         */
        copyAnimationRange(source: Skeleton, name: string, rescaleAsRequired?: boolean): boolean;
        /**
         * Forces the skeleton to go to rest pose
         */
        returnToRest(): void;
        private _getHighestAnimationFrame;
        /**
         * Begin a specific animation range
         * @param name defines the name of the range to start
         * @param loop defines if looping must be turned on (false by default)
         * @param speedRatio defines the speed ratio to apply (1 by default)
         * @param onAnimationEnd defines a callback which will be called when animation will end
         * @returns a new animatable
         */
        beginAnimation(name: string, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void): Nullable<Animatable>;
        /**
         * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.
         * @param skeleton defines the Skeleton containing the animation range to convert
         * @param referenceFrame defines the frame that keyframes in the range will be relative to
         * @param range defines the name of the AnimationRange belonging to the Skeleton to convert
         * @returns the original skeleton
         */
        static MakeAnimationAdditive(skeleton: Skeleton, referenceFrame: number | undefined, range: string): Nullable<Skeleton>;
        /** @hidden */
        _markAsDirty(): void;
        /** @hidden */
        _registerMeshWithPoseMatrix(mesh: AbstractMesh): void;
        /** @hidden */
        _unregisterMeshWithPoseMatrix(mesh: AbstractMesh): void;
        private _computeTransformMatrices;
        /**
         * Build all resources required to render a skeleton
         */
        prepare(): void;
        /**
         * Gets the list of animatables currently running for this skeleton
         * @returns an array of animatables
         */
        getAnimatables(): IAnimatable[];
        /**
         * Clone the current skeleton
         * @param name defines the name of the new skeleton
         * @param id defines the id of the new skeleton
         * @returns the new skeleton
         */
        clone(name: string, id?: string): Skeleton;
        /**
         * Enable animation blending for this skeleton
         * @param blendingSpeed defines the blending speed to apply
         * @see https://doc.babylonjs.com/babylon101/animations#animation-blending
         */
        enableBlending(blendingSpeed?: number): void;
        /**
         * Releases all resources associated with the current skeleton
         */
        dispose(): void;
        /**
         * Serialize the skeleton in a JSON object
         * @returns a JSON object
         */
        serialize(): any;
        /**
         * Creates a new skeleton from serialized data
         * @param parsedSkeleton defines the serialized data
         * @param scene defines the hosting scene
         * @returns a new skeleton
         */
        static Parse(parsedSkeleton: any, scene: Scene): Skeleton;
        /**
         * Compute all node absolute transforms
         * @param forceUpdate defines if computation must be done even if cache is up to date
         */
        computeAbsoluteTransforms(forceUpdate?: boolean): void;
        /**
         * Gets the root pose matrix
         * @returns a matrix
         */
        getPoseMatrix(): Nullable<Matrix>;
        /**
         * Sorts bones per internal index
         */
        sortBones(): void;
        private _sortBones;
    }
}
declare module BABYLON {
    /**
     * Creates an instance based on a source mesh.
     */
    export class InstancedMesh extends AbstractMesh {
        private _sourceMesh;
        private _currentLOD;
        /** @hidden */
        _indexInSourceMeshInstanceArray: number;
        constructor(name: string, source: Mesh);
        /**
         * Returns the string "InstancedMesh".
         */
        getClassName(): string;
        /** Gets the list of lights affecting that mesh */
        get lightSources(): Light[];
        _resyncLightSources(): void;
        _resyncLightSource(light: Light): void;
        _removeLightSource(light: Light, dispose: boolean): void;
        /**
         * If the source mesh receives shadows
         */
        get receiveShadows(): boolean;
        /**
         * The material of the source mesh
         */
        get material(): Nullable<Material>;
        /**
         * Visibility of the source mesh
         */
        get visibility(): number;
        /**
         * Skeleton of the source mesh
         */
        get skeleton(): Nullable<Skeleton>;
        /**
         * Rendering ground id of the source mesh
         */
        get renderingGroupId(): number;
        set renderingGroupId(value: number);
        /**
         * Returns the total number of vertices (integer).
         */
        getTotalVertices(): number;
        /**
         * Returns a positive integer : the total number of indices in this mesh geometry.
         * @returns the numner of indices or zero if the mesh has no geometry.
         */
        getTotalIndices(): number;
        /**
         * The source mesh of the instance
         */
        get sourceMesh(): Mesh;
        /**
         * Creates a new InstancedMesh object from the mesh model.
         * @see https://doc.babylonjs.com/how_to/how_to_use_instances
         * @param name defines the name of the new instance
         * @returns a new InstancedMesh
         */
        createInstance(name: string): InstancedMesh;
        /**
         * Is this node ready to be used/rendered
         * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)
         * @return {boolean} is it ready
         */
        isReady(completeCheck?: boolean): boolean;
        /**
         * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.
         * @param kind kind of verticies to retreive (eg. positons, normals, uvs, etc.)
         * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.
         * @returns a float array or a Float32Array of the requested kind of data : positons, normals, uvs, etc.
         */
        getVerticesData(kind: string, copyWhenShared?: boolean): Nullable<FloatArray>;
        /**
         * Sets the vertex data of the mesh geometry for the requested `kind`.
         * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
         * The `data` are either a numeric array either a Float32Array.
         * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initianilly none) or updater.
         * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).
         * Note that a new underlying VertexBuffer object is created each call.
         * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
         *
         * Possible `kind` values :
         * - VertexBuffer.PositionKind
         * - VertexBuffer.UVKind
         * - VertexBuffer.UV2Kind
         * - VertexBuffer.UV3Kind
         * - VertexBuffer.UV4Kind
         * - VertexBuffer.UV5Kind
         * - VertexBuffer.UV6Kind
         * - VertexBuffer.ColorKind
         * - VertexBuffer.MatricesIndicesKind
         * - VertexBuffer.MatricesIndicesExtraKind
         * - VertexBuffer.MatricesWeightsKind
         * - VertexBuffer.MatricesWeightsExtraKind
         *
         * Returns the Mesh.
         */
        setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh;
        /**
         * Updates the existing vertex data of the mesh geometry for the requested `kind`.
         * If the mesh has no geometry, it is simply returned as it is.
         * The `data` are either a numeric array either a Float32Array.
         * No new underlying VertexBuffer object is created.
         * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
         * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.
         *
         * Possible `kind` values :
         * - VertexBuffer.PositionKind
         * - VertexBuffer.UVKind
         * - VertexBuffer.UV2Kind
         * - VertexBuffer.UV3Kind
         * - VertexBuffer.UV4Kind
         * - VertexBuffer.UV5Kind
         * - VertexBuffer.UV6Kind
         * - VertexBuffer.ColorKind
         * - VertexBuffer.MatricesIndicesKind
         * - VertexBuffer.MatricesIndicesExtraKind
         * - VertexBuffer.MatricesWeightsKind
         * - VertexBuffer.MatricesWeightsExtraKind
         *
         * Returns the Mesh.
         */
        updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): Mesh;
        /**
         * Sets the mesh indices.
         * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).
         * If the mesh has no geometry, a new Geometry object is created and set to the mesh.
         * This method creates a new index buffer each call.
         * Returns the Mesh.
         */
        setIndices(indices: IndicesArray, totalVertices?: Nullable<number>): Mesh;
        /**
         * Boolean : True if the mesh owns the requested kind of data.
         */
        isVerticesDataPresent(kind: string): boolean;
        /**
         * Returns an array of indices (IndicesArray).
         */
        getIndices(): Nullable<IndicesArray>;
        get _positions(): Nullable<Vector3[]>;
        /**
         * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.
         * This means the mesh underlying bounding box and sphere are recomputed.
         * @param applySkeleton defines whether to apply the skeleton before computing the bounding info
         * @returns the current mesh
         */
        refreshBoundingInfo(applySkeleton?: boolean): InstancedMesh;
        /** @hidden */
        _preActivate(): InstancedMesh;
        /** @hidden */
        _activate(renderId: number, intermediateRendering: boolean): boolean;
        /** @hidden */
        _postActivate(): void;
        getWorldMatrix(): Matrix;
        get isAnInstance(): boolean;
        /**
         * Returns the current associated LOD AbstractMesh.
         */
        getLOD(camera: Camera): AbstractMesh;
        /** @hidden */
        _preActivateForIntermediateRendering(renderId: number): Mesh;
        /** @hidden */
        _syncSubMeshes(): InstancedMesh;
        /** @hidden */
        _generatePointsArray(): boolean;
        /** @hidden */
        _updateBoundingInfo(): AbstractMesh;
        /**
         * Creates a new InstancedMesh from the current mesh.
         * - name (string) : the cloned mesh name
         * - newParent (optional Node) : the optional Node to parent the clone to.
         * - doNotCloneChildren (optional boolean, default `false`) : if `true` the model children aren't cloned.
         *
         * Returns the clone.
         */
        clone(name: string, newParent?: Nullable<Node>, doNotCloneChildren?: boolean): InstancedMesh;
        /**
         * Disposes the InstancedMesh.
         * Returns nothing.
         */
        dispose(doNotRecurse?: boolean, disposeMaterialAndTextures?: boolean): void;
    }
        interface Mesh {
            /**
             * Register a custom buffer that will be instanced
             * @see https://doc.babylonjs.com/how_to/how_to_use_instances#custom-buffers
             * @param kind defines the buffer kind
             * @param stride defines the stride in floats
             */
            registerInstancedBuffer(kind: string, stride: number): void;
            /**
             * true to use the edge renderer for all instances of this mesh
             */
            edgesShareWithInstances: boolean;
            /** @hidden */
            _userInstancedBuffersStorage: {
                data: {
                    [key: string]: Float32Array;
                };
                sizes: {
                    [key: string]: number;
                };
                vertexBuffers: {
                    [key: string]: Nullable<VertexBuffer>;
                };
                strides: {
                    [key: string]: number;
                };
            };
        }
        interface AbstractMesh {
            /**
             * Object used to store instanced buffers defined by user
             * @see https://doc.babylonjs.com/how_to/how_to_use_instances#custom-buffers
             */
            instancedBuffers: {
                [key: string]: any;
            };
        }
}
declare module BABYLON {
    /**
     * Defines the options associated with the creation of a shader material.
     */
    export interface IShaderMaterialOptions {
        /**
         * Does the material work in alpha blend mode
         */
        needAlphaBlending: boolean;
        /**
         * Does the material work in alpha test mode
         */
        needAlphaTesting: boolean;
        /**
         * The list of attribute names used in the shader
         */
        attributes: string[];
        /**
         * The list of unifrom names used in the shader
         */
        uniforms: string[];
        /**
         * The list of UBO names used in the shader
         */
        uniformBuffers: string[];
        /**
         * The list of sampler names used in the shader
         */
        samplers: string[];
        /**
         * The list of defines used in the shader
         */
        defines: string[];
    }
    /**
     * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.
     *
     * This returned material effects how the mesh will look based on the code in the shaders.
     *
     * @see https://doc.babylonjs.com/how_to/shader_material
     */
    export class ShaderMaterial extends Material {
        private _shaderPath;
        private _options;
        private _textures;
        private _textureArrays;
        private _floats;
        private _ints;
        private _floatsArrays;
        private _colors3;
        private _colors3Arrays;
        private _colors4;
        private _colors4Arrays;
        private _vectors2;
        private _vectors3;
        private _vectors4;
        private _matrices;
        private _matrixArrays;
        private _matrices3x3;
        private _matrices2x2;
        private _vectors2Arrays;
        private _vectors3Arrays;
        private _vectors4Arrays;
        private _cachedWorldViewMatrix;
        private _cachedWorldViewProjectionMatrix;
        private _renderId;
        private _multiview;
        private _cachedDefines;
        /** Define the Url to load snippets */
        static SnippetUrl: string;
        /** Snippet ID if the material was created from the snippet server */
        snippetId: string;
        /**
         * Instantiate a new shader material.
         * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.
         * This returned material effects how the mesh will look based on the code in the shaders.
         * @see https://doc.babylonjs.com/how_to/shader_material
         * @param name Define the name of the material in the scene
         * @param scene Define the scene the material belongs to
         * @param shaderPath Defines  the route to the shader code in one of three ways:
         *  * object: { vertex: "custom", fragment: "custom" }, used with Effect.ShadersStore["customVertexShader"] and Effect.ShadersStore["customFragmentShader"]
         *  * object: { vertexElement: "vertexShaderCode", fragmentElement: "fragmentShaderCode" }, used with shader code in script tags
         *  * object: { vertexSource: "vertex shader code string", fragmentSource: "fragment shader code string" } using with strings containing the shaders code
         *  * string: "./COMMON_NAME", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.
         * @param options Define the options used to create the shader
         */
        constructor(name: string, scene: Scene, shaderPath: any, options?: Partial<IShaderMaterialOptions>);
        /**
         * Gets the shader path used to define the shader code
         * It can be modified to trigger a new compilation
         */
        get shaderPath(): any;
        /**
         * Sets the shader path used to define the shader code
         * It can be modified to trigger a new compilation
         */
        set shaderPath(shaderPath: any);
        /**
         * Gets the options used to compile the shader.
         * They can be modified to trigger a new compilation
         */
        get options(): IShaderMaterialOptions;
        /**
         * Gets the current class name of the material e.g. "ShaderMaterial"
         * Mainly use in serialization.
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Specifies if the material will require alpha blending
         * @returns a boolean specifying if alpha blending is needed
         */
        needAlphaBlending(): boolean;
        /**
         * Specifies if this material should be rendered in alpha test mode
         * @returns a boolean specifying if an alpha test is needed.
         */
        needAlphaTesting(): boolean;
        private _checkUniform;
        /**
         * Set a texture in the shader.
         * @param name Define the name of the uniform samplers as defined in the shader
         * @param texture Define the texture to bind to this sampler
         * @return the material itself allowing "fluent" like uniform updates
         */
        setTexture(name: string, texture: BaseTexture): ShaderMaterial;
        /**
         * Set a texture array in the shader.
         * @param name Define the name of the uniform sampler array as defined in the shader
         * @param textures Define the list of textures to bind to this sampler
         * @return the material itself allowing "fluent" like uniform updates
         */
        setTextureArray(name: string, textures: BaseTexture[]): ShaderMaterial;
        /**
         * Set a float in the shader.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the material itself allowing "fluent" like uniform updates
         */
        setFloat(name: string, value: number): ShaderMaterial;
        /**
         * Set a int in the shader.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the material itself allowing "fluent" like uniform updates
         */
        setInt(name: string, value: number): ShaderMaterial;
        /**
         * Set an array of floats in the shader.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the material itself allowing "fluent" like uniform updates
         */
        setFloats(name: string, value: number[]): ShaderMaterial;
        /**
         * Set a vec3 in the shader from a Color3.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the material itself allowing "fluent" like uniform updates
         */
        setColor3(name: string, value: Color3): ShaderMaterial;
        /**
         * Set a vec3 array in the shader from a Color3 array.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the material itself allowing "fluent" like uniform updates
         */
        setColor3Array(name: string, value: Color3[]): ShaderMaterial;
        /**
         * Set a vec4 in the shader from a Color4.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the material itself allowing "fluent" like uniform updates
         */
        setColor4(name: string, value: Color4): ShaderMaterial;
        /**
         * Set a vec4 array in the shader from a Color4 array.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the material itself allowing "fluent" like uniform updates
         */
        setColor4Array(name: string, value: Color4[]): ShaderMaterial;
        /**
         * Set a vec2 in the shader from a Vector2.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the material itself allowing "fluent" like uniform updates
         */
        setVector2(name: string, value: Vector2): ShaderMaterial;
        /**
         * Set a vec3 in the shader from a Vector3.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the material itself allowing "fluent" like uniform updates
         */
        setVector3(name: string, value: Vector3): ShaderMaterial;
        /**
         * Set a vec4 in the shader from a Vector4.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the material itself allowing "fluent" like uniform updates
         */
        setVector4(name: string, value: Vector4): ShaderMaterial;
        /**
         * Set a mat4 in the shader from a Matrix.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the material itself allowing "fluent" like uniform updates
         */
        setMatrix(name: string, value: Matrix): ShaderMaterial;
        /**
         * Set a float32Array in the shader from a matrix array.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the material itself allowing "fluent" like uniform updates
         */
        setMatrices(name: string, value: Matrix[]): ShaderMaterial;
        /**
         * Set a mat3 in the shader from a Float32Array.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the material itself allowing "fluent" like uniform updates
         */
        setMatrix3x3(name: string, value: Float32Array | Array<number>): ShaderMaterial;
        /**
         * Set a mat2 in the shader from a Float32Array.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the material itself allowing "fluent" like uniform updates
         */
        setMatrix2x2(name: string, value: Float32Array | Array<number>): ShaderMaterial;
        /**
         * Set a vec2 array in the shader from a number array.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the material itself allowing "fluent" like uniform updates
         */
        setArray2(name: string, value: number[]): ShaderMaterial;
        /**
         * Set a vec3 array in the shader from a number array.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the material itself allowing "fluent" like uniform updates
         */
        setArray3(name: string, value: number[]): ShaderMaterial;
        /**
         * Set a vec4 array in the shader from a number array.
         * @param name Define the name of the uniform as defined in the shader
         * @param value Define the value to give to the uniform
         * @return the material itself allowing "fluent" like uniform updates
         */
        setArray4(name: string, value: number[]): ShaderMaterial;
        private _checkCache;
        /**
         * Specifies that the submesh is ready to be used
         * @param mesh defines the mesh to check
         * @param subMesh defines which submesh to check
         * @param useInstances specifies that instances should be used
         * @returns a boolean indicating that the submesh is ready or not
         */
        isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean;
        /**
         * Checks if the material is ready to render the requested mesh
         * @param mesh Define the mesh to render
         * @param useInstances Define whether or not the material is used with instances
         * @returns true if ready, otherwise false
         */
        isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean;
        /**
         * Binds the world matrix to the material
         * @param world defines the world transformation matrix
         * @param effectOverride - If provided, use this effect instead of internal effect
         */
        bindOnlyWorldMatrix(world: Matrix, effectOverride?: Nullable<Effect>): void;
        /**
         * Binds the submesh to this material by preparing the effect and shader to draw
         * @param world defines the world transformation matrix
         * @param mesh defines the mesh containing the submesh
         * @param subMesh defines the submesh to bind the material to
         */
        bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void;
        /**
         * Binds the material to the mesh
         * @param world defines the world transformation matrix
         * @param mesh defines the mesh to bind the material to
         * @param effectOverride - If provided, use this effect instead of internal effect
         */
        bind(world: Matrix, mesh?: Mesh, effectOverride?: Nullable<Effect>): void;
        protected _afterBind(mesh?: Mesh): void;
        /**
         * Gets the active textures from the material
         * @returns an array of textures
         */
        getActiveTextures(): BaseTexture[];
        /**
         * Specifies if the material uses a texture
         * @param texture defines the texture to check against the material
         * @returns a boolean specifying if the material uses the texture
         */
        hasTexture(texture: BaseTexture): boolean;
        /**
         * Makes a duplicate of the material, and gives it a new name
         * @param name defines the new name for the duplicated material
         * @returns the cloned material
         */
        clone(name: string): ShaderMaterial;
        /**
         * Disposes the material
         * @param forceDisposeEffect specifies if effects should be forcefully disposed
         * @param forceDisposeTextures specifies if textures should be forcefully disposed
         * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh
         */
        dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void;
        /**
         * Serializes this material in a JSON representation
         * @returns the serialized material object
         */
        serialize(): any;
        /**
         * Creates a shader material from parsed shader material data
         * @param source defines the JSON represnetation of the material
         * @param scene defines the hosting scene
         * @param rootUrl defines the root URL to use to load textures and relative dependencies
         * @returns a new material
         */
        static Parse(source: any, scene: Scene, rootUrl: string): ShaderMaterial;
        /**
         * Creates a new ShaderMaterial from a snippet saved in a remote file
         * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)
         * @param url defines the url to load from
         * @param scene defines the hosting scene
         * @param rootUrl defines the root URL to use to load textures and relative dependencies
         * @returns a promise that will resolve to the new ShaderMaterial
         */
        static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, rootUrl?: string): Promise<ShaderMaterial>;
        /**
         * Creates a ShaderMaterial from a snippet saved by the Inspector
         * @param snippetId defines the snippet to load
         * @param scene defines the hosting scene
         * @param rootUrl defines the root URL to use to load textures and relative dependencies
         * @returns a promise that will resolve to the new ShaderMaterial
         */
        static CreateFromSnippetAsync(snippetId: string, scene: Scene, rootUrl?: string): Promise<ShaderMaterial>;
    }
}
declare module BABYLON {
    /** @hidden */
    export var colorPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var colorVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Line mesh
     * @see https://doc.babylonjs.com/babylon101/parametric_shapes
     */
    export class LinesMesh extends Mesh {
        /**
         * If vertex color should be applied to the mesh
         */
        readonly useVertexColor?: boolean | undefined;
        /**
         * If vertex alpha should be applied to the mesh
         */
        readonly useVertexAlpha?: boolean | undefined;
        /**
         * Color of the line (Default: White)
         */
        color: Color3;
        /**
         * Alpha of the line (Default: 1)
         */
        alpha: number;
        /**
         * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.
         * This margin is expressed in world space coordinates, so its value may vary.
         * Default value is 0.1
         */
        intersectionThreshold: number;
        private _colorShader;
        private color4;
        /**
         * Creates a new LinesMesh
         * @param name defines the name
         * @param scene defines the hosting scene
         * @param parent defines the parent mesh if any
         * @param source defines the optional source LinesMesh used to clone data from
         * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.
         * When false, achieved by calling a clone(), also passing False.
         * This will make creation of children, recursive.
         * @param useVertexColor defines if this LinesMesh supports vertex color
         * @param useVertexAlpha defines if this LinesMesh supports vertex alpha
         */
        constructor(name: string, scene?: Nullable<Scene>, parent?: Nullable<Node>, source?: Nullable<LinesMesh>, doNotCloneChildren?: boolean, 
        /**
         * If vertex color should be applied to the mesh
         */
        useVertexColor?: boolean | undefined, 
        /**
         * If vertex alpha should be applied to the mesh
         */
        useVertexAlpha?: boolean | undefined);
        private _addClipPlaneDefine;
        private _removeClipPlaneDefine;
        isReady(): boolean;
        /**
         * Returns the string "LineMesh"
         */
        getClassName(): string;
        /**
         * @hidden
         */
        get material(): Material;
        /**
         * @hidden
         */
        set material(value: Material);
        /**
         * @hidden
         */
        get checkCollisions(): boolean;
        /** @hidden */
        _bind(subMesh: SubMesh, effect: Effect, fillMode: number): Mesh;
        /** @hidden */
        _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number): Mesh;
        /**
         * Disposes of the line mesh
         * @param doNotRecurse If children should be disposed
         */
        dispose(doNotRecurse?: boolean): void;
        /**
         * Returns a new LineMesh object cloned from the current one.
         */
        clone(name: string, newParent?: Nullable<Node>, doNotCloneChildren?: boolean): LinesMesh;
        /**
         * Creates a new InstancedLinesMesh object from the mesh model.
         * @see https://doc.babylonjs.com/how_to/how_to_use_instances
         * @param name defines the name of the new instance
         * @returns a new InstancedLinesMesh
         */
        createInstance(name: string): InstancedLinesMesh;
    }
    /**
     * Creates an instance based on a source LinesMesh
     */
    export class InstancedLinesMesh extends InstancedMesh {
        /**
         * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.
         * This margin is expressed in world space coordinates, so its value may vary.
         * Initilized with the intersectionThreshold value of the source LinesMesh
         */
        intersectionThreshold: number;
        constructor(name: string, source: LinesMesh);
        /**
         * Returns the string "InstancedLinesMesh".
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /** @hidden */
    export var linePixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var lineVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
        interface Scene {
            /** @hidden */
            _edgeRenderLineShader: Nullable<ShaderMaterial>;
        }
        interface AbstractMesh {
            /**
             * Gets the edgesRenderer associated with the mesh
             */
            edgesRenderer: Nullable<EdgesRenderer>;
        }
        interface LinesMesh {
            /**
             * Enables the edge rendering mode on the mesh.
             * This mode makes the mesh edges visible
             * @param epsilon defines the maximal distance between two angles to detect a face
             * @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces
             * @returns the currentAbstractMesh
             * @see https://www.babylonjs-playground.com/#19O9TU#0
             */
            enableEdgesRendering(epsilon?: number, checkVerticesInsteadOfIndices?: boolean): AbstractMesh;
        }
        interface InstancedLinesMesh {
            /**
             * Enables the edge rendering mode on the mesh.
             * This mode makes the mesh edges visible
             * @param epsilon defines the maximal distance between two angles to detect a face
             * @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces
             * @returns the current InstancedLinesMesh
             * @see https://www.babylonjs-playground.com/#19O9TU#0
             */
            enableEdgesRendering(epsilon?: number, checkVerticesInsteadOfIndices?: boolean): InstancedLinesMesh;
        }
    /**
     * Defines the minimum contract an Edges renderer should follow.
     */
    export interface IEdgesRenderer extends IDisposable {
        /**
         * Gets or sets a boolean indicating if the edgesRenderer is active
         */
        isEnabled: boolean;
        /**
         * Renders the edges of the attached mesh,
         */
        render(): void;
        /**
         * Checks wether or not the edges renderer is ready to render.
         * @return true if ready, otherwise false.
         */
        isReady(): boolean;
        /**
         * List of instances to render in case the source mesh has instances
         */
        customInstances: SmartArray<Matrix>;
    }
    /**
     * Defines the additional options of the edges renderer
     */
    export interface IEdgesRendererOptions {
        /**
         * Gets or sets a boolean indicating that the alternate edge finder algorithm must be used
         * If not defined, the default value is true
         */
        useAlternateEdgeFinder?: boolean;
        /**
         * Gets or sets a boolean indicating that the vertex merger fast processing must be used.
         * If not defined, the default value is true.
         * You should normally leave it undefined (or set it to true), except if you see some artifacts in the edges rendering (can happen with complex geometries)
         * This option is used only if useAlternateEdgeFinder = true
         */
        useFastVertexMerger?: boolean;
        /**
         * During edges processing, the vertices are merged if they are close enough: epsilonVertexMerge is the limit whithin which vertices are considered to be equal.
         * The default value is 1e-6
         * This option is used only if useAlternateEdgeFinder = true
         */
        epsilonVertexMerge?: number;
        /**
         * Gets or sets a boolean indicating that tessellation should be applied before finding the edges. You may need to activate this option if your geometry is a bit
         * unusual, like having a vertex of a triangle in-between two vertices of an edge of another triangle. It happens often when using CSG to construct meshes.
         * This option is used only if useAlternateEdgeFinder = true
         */
        applyTessellation?: boolean;
        /**
         * The limit under which 3 vertices are considered to be aligned. 3 vertices PQR are considered aligned if distance(PQ) + distance(QR) - distance(PR) < epsilonVertexAligned
         * The default value is 1e-6
         * This option is used only if useAlternateEdgeFinder = true
         */
        epsilonVertexAligned?: number;
    }
    /**
     * This class is used to generate edges of the mesh that could then easily be rendered in a scene.
     */
    export class EdgesRenderer implements IEdgesRenderer {
        /**
         * Define the size of the edges with an orthographic camera
         */
        edgesWidthScalerForOrthographic: number;
        /**
         * Define the size of the edges with a perspective camera
         */
        edgesWidthScalerForPerspective: number;
        protected _source: AbstractMesh;
        protected _linesPositions: number[];
        protected _linesNormals: number[];
        protected _linesIndices: number[];
        protected _epsilon: number;
        protected _indicesCount: number;
        protected _lineShader: ShaderMaterial;
        protected _ib: DataBuffer;
        protected _buffers: {
            [key: string]: Nullable<VertexBuffer>;
        };
        protected _buffersForInstances: {
            [key: string]: Nullable<VertexBuffer>;
        };
        protected _checkVerticesInsteadOfIndices: boolean;
        protected _options: Nullable<IEdgesRendererOptions>;
        private _meshRebuildObserver;
        private _meshDisposeObserver;
        /** Gets or sets a boolean indicating if the edgesRenderer is active */
        isEnabled: boolean;
        /**
         * List of instances to render in case the source mesh has instances
         */
        customInstances: SmartArray<Matrix>;
        private static GetShader;
        /**
         * Creates an instance of the EdgesRenderer. It is primarily use to display edges of a mesh.
         * Beware when you use this class with complex objects as the adjacencies computation can be really long
         * @param  source Mesh used to create edges
         * @param  epsilon sum of angles in adjacency to check for edge
         * @param  checkVerticesInsteadOfIndices bases the edges detection on vertices vs indices. Note that this parameter is not used if options.useAlternateEdgeFinder = true
         * @param  generateEdgesLines - should generate Lines or only prepare resources.
         * @param  options The options to apply when generating the edges
         */
        constructor(source: AbstractMesh, epsilon?: number, checkVerticesInsteadOfIndices?: boolean, generateEdgesLines?: boolean, options?: IEdgesRendererOptions);
        protected _prepareRessources(): void;
        /** @hidden */
        _rebuild(): void;
        /**
         * Releases the required resources for the edges renderer
         */
        dispose(): void;
        protected _processEdgeForAdjacencies(pa: number, pb: number, p0: number, p1: number, p2: number): number;
        protected _processEdgeForAdjacenciesWithVertices(pa: Vector3, pb: Vector3, p0: Vector3, p1: Vector3, p2: Vector3): number;
        /**
         * Checks if the pair of p0 and p1 is en edge
         * @param faceIndex
         * @param edge
         * @param faceNormals
         * @param  p0
         * @param  p1
         * @private
         */
        protected _checkEdge(faceIndex: number, edge: number, faceNormals: Array<Vector3>, p0: Vector3, p1: Vector3): void;
        /**
         * push line into the position, normal and index buffer
         * @protected
         */
        protected createLine(p0: Vector3, p1: Vector3, offset: number): void;
        /**
         * See https://playground.babylonjs.com/#R3JR6V#1 for a visual display of the algorithm
         */
        private _tessellateTriangle;
        private _generateEdgesLinesAlternate;
        /**
         * Generates lines edges from adjacencjes
         * @private
         */
        _generateEdgesLines(): void;
        /**
         * Checks wether or not the edges renderer is ready to render.
         * @return true if ready, otherwise false.
         */
        isReady(): boolean;
        /**
         * Renders the edges of the attached mesh,
         */
        render(): void;
    }
    /**
     * LineEdgesRenderer for LineMeshes to remove unnecessary triangulation
     */
    export class LineEdgesRenderer extends EdgesRenderer {
        /**
         * This constructor turns off auto generating edges line in Edges Renderer to make it here.
         * @param  source LineMesh used to generate edges
         * @param  epsilon not important (specified angle for edge detection)
         * @param  checkVerticesInsteadOfIndices not important for LineMesh
         */
        constructor(source: AbstractMesh, epsilon?: number, checkVerticesInsteadOfIndices?: boolean);
        /**
         * Generate edges for each line in LinesMesh. Every Line should be rendered as edge.
         */
        _generateEdgesLines(): void;
    }
}
declare module BABYLON {
    /**
     * This represents the object necessary to create a rendering group.
     * This is exclusively used and created by the rendering manager.
     * To modify the behavior, you use the available helpers in your scene or meshes.
     * @hidden
     */
    export class RenderingGroup {
        index: number;
        private static _zeroVector;
        private _scene;
        private _opaqueSubMeshes;
        private _transparentSubMeshes;
        private _alphaTestSubMeshes;
        private _depthOnlySubMeshes;
        private _particleSystems;
        private _spriteManagers;
        private _opaqueSortCompareFn;
        private _alphaTestSortCompareFn;
        private _transparentSortCompareFn;
        private _renderOpaque;
        private _renderAlphaTest;
        private _renderTransparent;
        /** @hidden */
        _edgesRenderers: SmartArrayNoDuplicate<IEdgesRenderer>;
        onBeforeTransparentRendering: () => void;
        /**
         * Set the opaque sort comparison function.
         * If null the sub meshes will be render in the order they were created
         */
        set opaqueSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>);
        /**
         * Set the alpha test sort comparison function.
         * If null the sub meshes will be render in the order they were created
         */
        set alphaTestSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>);
        /**
         * Set the transparent sort comparison function.
         * If null the sub meshes will be render in the order they were created
         */
        set transparentSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>);
        /**
         * Creates a new rendering group.
         * @param index The rendering group index
         * @param opaqueSortCompareFn The opaque sort comparison function. If null no order is applied
         * @param alphaTestSortCompareFn The alpha test sort comparison function. If null no order is applied
         * @param transparentSortCompareFn The transparent sort comparison function. If null back to front + alpha index sort is applied
         */
        constructor(index: number, scene: Scene, opaqueSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>, alphaTestSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>, transparentSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>);
        /**
         * Render all the sub meshes contained in the group.
         * @param customRenderFunction Used to override the default render behaviour of the group.
         * @returns true if rendered some submeshes.
         */
        render(customRenderFunction: Nullable<(opaqueSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>) => void>, renderSprites: boolean, renderParticles: boolean, activeMeshes: Nullable<AbstractMesh[]>): void;
        /**
         * Renders the opaque submeshes in the order from the opaqueSortCompareFn.
         * @param subMeshes The submeshes to render
         */
        private renderOpaqueSorted;
        /**
         * Renders the opaque submeshes in the order from the alphatestSortCompareFn.
         * @param subMeshes The submeshes to render
         */
        private renderAlphaTestSorted;
        /**
         * Renders the opaque submeshes in the order from the transparentSortCompareFn.
         * @param subMeshes The submeshes to render
         */
        private renderTransparentSorted;
        /**
         * Renders the submeshes in a specified order.
         * @param subMeshes The submeshes to sort before render
         * @param sortCompareFn The comparison function use to sort
         * @param cameraPosition The camera position use to preprocess the submeshes to help sorting
         * @param transparent Specifies to activate blending if true
         */
        private static renderSorted;
        /**
         * Renders the submeshes in the order they were dispatched (no sort applied).
         * @param subMeshes The submeshes to render
         */
        private static renderUnsorted;
        /**
         * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
         * are rendered back to front if in the same alpha index.
         *
         * @param a The first submesh
         * @param b The second submesh
         * @returns The result of the comparison
         */
        static defaultTransparentSortCompare(a: SubMesh, b: SubMesh): number;
        /**
         * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
         * are rendered back to front.
         *
         * @param a The first submesh
         * @param b The second submesh
         * @returns The result of the comparison
         */
        static backToFrontSortCompare(a: SubMesh, b: SubMesh): number;
        /**
         * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
         * are rendered front to back (prevent overdraw).
         *
         * @param a The first submesh
         * @param b The second submesh
         * @returns The result of the comparison
         */
        static frontToBackSortCompare(a: SubMesh, b: SubMesh): number;
        /**
         * Resets the different lists of submeshes to prepare a new frame.
         */
        prepare(): void;
        dispose(): void;
        /**
         * Inserts the submesh in its correct queue depending on its material.
         * @param subMesh The submesh to dispatch
         * @param [mesh] Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.
         * @param [material] Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.
         */
        dispatch(subMesh: SubMesh, mesh?: AbstractMesh, material?: Nullable<Material>): void;
        dispatchSprites(spriteManager: ISpriteManager): void;
        dispatchParticles(particleSystem: IParticleSystem): void;
        private _renderParticles;
        private _renderSprites;
    }
}
declare module BABYLON {
    /**
     * Interface describing the different options available in the rendering manager
     * regarding Auto Clear between groups.
     */
    export interface IRenderingManagerAutoClearSetup {
        /**
         * Defines whether or not autoclear is enable.
         */
        autoClear: boolean;
        /**
         * Defines whether or not to autoclear the depth buffer.
         */
        depth: boolean;
        /**
         * Defines whether or not to autoclear the stencil buffer.
         */
        stencil: boolean;
    }
    /**
     * This class is used by the onRenderingGroupObservable
     */
    export class RenderingGroupInfo {
        /**
         * The Scene that being rendered
         */
        scene: Scene;
        /**
         * The camera currently used for the rendering pass
         */
        camera: Nullable<Camera>;
        /**
         * The ID of the renderingGroup being processed
         */
        renderingGroupId: number;
    }
    /**
     * This is the manager responsible of all the rendering for meshes sprites and particles.
     * It is enable to manage the different groups as well as the different necessary sort functions.
     * This should not be used directly aside of the few static configurations
     */
    export class RenderingManager {
        /**
         * The max id used for rendering groups (not included)
         */
        static MAX_RENDERINGGROUPS: number;
        /**
         * The min id used for rendering groups (included)
         */
        static MIN_RENDERINGGROUPS: number;
        /**
         * Used to globally prevent autoclearing scenes.
         */
        static AUTOCLEAR: boolean;
        /**
         * @hidden
         */
        _useSceneAutoClearSetup: boolean;
        private _scene;
        private _renderingGroups;
        private _depthStencilBufferAlreadyCleaned;
        private _autoClearDepthStencil;
        private _customOpaqueSortCompareFn;
        private _customAlphaTestSortCompareFn;
        private _customTransparentSortCompareFn;
        private _renderingGroupInfo;
        /**
         * Instantiates a new rendering group for a particular scene
         * @param scene Defines the scene the groups belongs to
         */
        constructor(scene: Scene);
        private _clearDepthStencilBuffer;
        /**
         * Renders the entire managed groups. This is used by the scene or the different rennder targets.
         * @hidden
         */
        render(customRenderFunction: Nullable<(opaqueSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>) => void>, activeMeshes: Nullable<AbstractMesh[]>, renderParticles: boolean, renderSprites: boolean): void;
        /**
         * Resets the different information of the group to prepare a new frame
         * @hidden
         */
        reset(): void;
        /**
         * Dispose and release the group and its associated resources.
         * @hidden
         */
        dispose(): void;
        /**
         * Clear the info related to rendering groups preventing retention points during dispose.
         */
        freeRenderingGroups(): void;
        private _prepareRenderingGroup;
        /**
         * Add a sprite manager to the rendering manager in order to render it this frame.
         * @param spriteManager Define the sprite manager to render
         */
        dispatchSprites(spriteManager: ISpriteManager): void;
        /**
         * Add a particle system to the rendering manager in order to render it this frame.
         * @param particleSystem Define the particle system to render
         */
        dispatchParticles(particleSystem: IParticleSystem): void;
        /**
         * Add a submesh to the manager in order to render it this frame
         * @param subMesh The submesh to dispatch
         * @param mesh Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.
         * @param material Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.
         */
        dispatch(subMesh: SubMesh, mesh?: AbstractMesh, material?: Nullable<Material>): void;
        /**
         * Overrides the default sort function applied in the renderging group to prepare the meshes.
         * This allowed control for front to back rendering or reversly depending of the special needs.
         *
         * @param renderingGroupId The rendering group id corresponding to its index
         * @param opaqueSortCompareFn The opaque queue comparison function use to sort.
         * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.
         * @param transparentSortCompareFn The transparent queue comparison function use to sort.
         */
        setRenderingOrder(renderingGroupId: number, opaqueSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>, alphaTestSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>, transparentSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>): void;
        /**
         * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
         *
         * @param renderingGroupId The rendering group id corresponding to its index
         * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
         * @param depth Automatically clears depth between groups if true and autoClear is true.
         * @param stencil Automatically clears stencil between groups if true and autoClear is true.
         */
        setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean, depth?: boolean, stencil?: boolean): void;
        /**
         * Gets the current auto clear configuration for one rendering group of the rendering
         * manager.
         * @param index the rendering group index to get the information for
         * @returns The auto clear setup for the requested rendering group
         */
        getAutoClearDepthStencilSetup(index: number): IRenderingManagerAutoClearSetup;
    }
}
declare module BABYLON {
    /**
     * Defines the options associated with the creation of a custom shader for a shadow generator.
     */
    export interface ICustomShaderOptions {
        /**
         * Gets or sets the custom shader name to use
         */
        shaderName: string;
        /**
         * The list of attribute names used in the shader
         */
        attributes?: string[];
        /**
         * The list of unifrom names used in the shader
         */
        uniforms?: string[];
        /**
         * The list of sampler names used in the shader
         */
        samplers?: string[];
        /**
         * The list of defines used in the shader
         */
        defines?: string[];
    }
    /**
     * Interface to implement to create a shadow generator compatible with BJS.
     */
    export interface IShadowGenerator {
        /** Gets or set the id of the shadow generator. It will be the one from the light if not defined */
        id: string;
        /**
         * Gets the main RTT containing the shadow map (usually storing depth from the light point of view).
         * @returns The render target texture if present otherwise, null
         */
        getShadowMap(): Nullable<RenderTargetTexture>;
        /**
         * Determine wheter the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).
         * @param subMesh The submesh we want to render in the shadow map
         * @param useInstances Defines wether will draw in the map using instances
         * @param isTransparent Indicates that isReady is called for a transparent subMesh
         * @returns true if ready otherwise, false
         */
        isReady(subMesh: SubMesh, useInstances: boolean, isTransparent: boolean): boolean;
        /**
         * Prepare all the defines in a material relying on a shadow map at the specified light index.
         * @param defines Defines of the material we want to update
         * @param lightIndex Index of the light in the enabled light list of the material
         */
        prepareDefines(defines: MaterialDefines, lightIndex: number): void;
        /**
         * Binds the shadow related information inside of an effect (information like near, far, darkness...
         * defined in the generator but impacting the effect).
         * It implies the unifroms available on the materials are the standard BJS ones.
         * @param lightIndex Index of the light in the enabled light list of the material owning the effect
         * @param effect The effect we are binfing the information for
         */
        bindShadowLight(lightIndex: string, effect: Effect): void;
        /**
         * Gets the transformation matrix used to project the meshes into the map from the light point of view.
         * (eq to shadow prjection matrix * light transform matrix)
         * @returns The transform matrix used to create the shadow map
         */
        getTransformMatrix(): Matrix;
        /**
         * Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between
         * Cube and 2D textures for instance.
         */
        recreateShadowMap(): void;
        /**
         * Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
         * @param onCompiled Callback triggered at the and of the effects compilation
         * @param options Sets of optional options forcing the compilation with different modes
         */
        forceCompilation(onCompiled?: (generator: IShadowGenerator) => void, options?: Partial<{
            useInstances: boolean;
        }>): void;
        /**
         * Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
         * @param options Sets of optional options forcing the compilation with different modes
         * @returns A promise that resolves when the compilation completes
         */
        forceCompilationAsync(options?: Partial<{
            useInstances: boolean;
        }>): Promise<void>;
        /**
         * Serializes the shadow generator setup to a json object.
         * @returns The serialized JSON object
         */
        serialize(): any;
        /**
         * Disposes the Shadow map and related Textures and effects.
         */
        dispose(): void;
    }
    /**
     * Default implementation IShadowGenerator.
     * This is the main object responsible of generating shadows in the framework.
     * Documentation: https://doc.babylonjs.com/babylon101/shadows
     */
    export class ShadowGenerator implements IShadowGenerator {
        /**
         * Name of the shadow generator class
         */
        static CLASSNAME: string;
        /**
         * Shadow generator mode None: no filtering applied.
         */
        static readonly FILTER_NONE: number;
        /**
         * Shadow generator mode ESM: Exponential Shadow Mapping.
         * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
         */
        static readonly FILTER_EXPONENTIALSHADOWMAP: number;
        /**
         * Shadow generator mode Poisson Sampling: Percentage Closer Filtering.
         * (Multiple Tap around evenly distributed around the pixel are used to evaluate the shadow strength)
         */
        static readonly FILTER_POISSONSAMPLING: number;
        /**
         * Shadow generator mode ESM: Blurred Exponential Shadow Mapping.
         * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
         */
        static readonly FILTER_BLUREXPONENTIALSHADOWMAP: number;
        /**
         * Shadow generator mode ESM: Exponential Shadow Mapping using the inverse of the exponential preventing
         * edge artifacts on steep falloff.
         * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
         */
        static readonly FILTER_CLOSEEXPONENTIALSHADOWMAP: number;
        /**
         * Shadow generator mode ESM: Blurred Exponential Shadow Mapping using the inverse of the exponential preventing
         * edge artifacts on steep falloff.
         * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
         */
        static readonly FILTER_BLURCLOSEEXPONENTIALSHADOWMAP: number;
        /**
         * Shadow generator mode PCF: Percentage Closer Filtering
         * benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1
         * (https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html)
         */
        static readonly FILTER_PCF: number;
        /**
         * Shadow generator mode PCSS: Percentage Closering Soft Shadow.
         * benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1
         * Contact Hardening
         */
        static readonly FILTER_PCSS: number;
        /**
         * Reserved for PCF and PCSS
         * Highest Quality.
         *
         * Execute PCF on a 5*5 kernel improving a lot the shadow aliasing artifacts.
         *
         * Execute PCSS with 32 taps blocker search and 64 taps PCF.
         */
        static readonly QUALITY_HIGH: number;
        /**
         * Reserved for PCF and PCSS
         * Good tradeoff for quality/perf cross devices
         *
         * Execute PCF on a 3*3 kernel.
         *
         * Execute PCSS with 16 taps blocker search and 32 taps PCF.
         */
        static readonly QUALITY_MEDIUM: number;
        /**
         * Reserved for PCF and PCSS
         * The lowest quality but the fastest.
         *
         * Execute PCF on a 1*1 kernel.
         *
         * Execute PCSS with 16 taps blocker search and 16 taps PCF.
         */
        static readonly QUALITY_LOW: number;
        /** Gets or set the id of the shadow generator. It will be the one from the light if not defined */
        id: string;
        /** Gets or sets the custom shader name to use */
        customShaderOptions: ICustomShaderOptions;
        /**
         * Observable triggered before the shadow is rendered. Can be used to update internal effect state
         */
        onBeforeShadowMapRenderObservable: Observable<Effect>;
        /**
         * Observable triggered after the shadow is rendered. Can be used to restore internal effect state
         */
        onAfterShadowMapRenderObservable: Observable<Effect>;
        /**
         * Observable triggered before a mesh is rendered in the shadow map.
         * Can be used to update internal effect state (that you can get from the onBeforeShadowMapRenderObservable)
         */
        onBeforeShadowMapRenderMeshObservable: Observable<Mesh>;
        /**
         * Observable triggered after a mesh is rendered in the shadow map.
         * Can be used to update internal effect state (that you can get from the onAfterShadowMapRenderObservable)
         */
        onAfterShadowMapRenderMeshObservable: Observable<Mesh>;
        protected _bias: number;
        /**
         * Gets the bias: offset applied on the depth preventing acnea (in light direction).
         */
        get bias(): number;
        /**
         * Sets the bias: offset applied on the depth preventing acnea (in light direction).
         */
        set bias(bias: number);
        protected _normalBias: number;
        /**
         * Gets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportinal to the light/normal angle).
         */
        get normalBias(): number;
        /**
         * Sets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportinal to the light/normal angle).
         */
        set normalBias(normalBias: number);
        protected _blurBoxOffset: number;
        /**
         * Gets the blur box offset: offset applied during the blur pass.
         * Only useful if useKernelBlur = false
         */
        get blurBoxOffset(): number;
        /**
         * Sets the blur box offset: offset applied during the blur pass.
         * Only useful if useKernelBlur = false
         */
        set blurBoxOffset(value: number);
        protected _blurScale: number;
        /**
         * Gets the blur scale: scale of the blurred texture compared to the main shadow map.
         * 2 means half of the size.
         */
        get blurScale(): number;
        /**
         * Sets the blur scale: scale of the blurred texture compared to the main shadow map.
         * 2 means half of the size.
         */
        set blurScale(value: number);
        protected _blurKernel: number;
        /**
         * Gets the blur kernel: kernel size of the blur pass.
         * Only useful if useKernelBlur = true
         */
        get blurKernel(): number;
        /**
         * Sets the blur kernel: kernel size of the blur pass.
         * Only useful if useKernelBlur = true
         */
        set blurKernel(value: number);
        protected _useKernelBlur: boolean;
        /**
         * Gets whether the blur pass is a kernel blur (if true) or box blur.
         * Only useful in filtered mode (useBlurExponentialShadowMap...)
         */
        get useKernelBlur(): boolean;
        /**
         * Sets whether the blur pass is a kernel blur (if true) or box blur.
         * Only useful in filtered mode (useBlurExponentialShadowMap...)
         */
        set useKernelBlur(value: boolean);
        protected _depthScale: number;
        /**
         * Gets the depth scale used in ESM mode.
         */
        get depthScale(): number;
        /**
         * Sets the depth scale used in ESM mode.
         * This can override the scale stored on the light.
         */
        set depthScale(value: number);
        protected _validateFilter(filter: number): number;
        protected _filter: number;
        /**
         * Gets the current mode of the shadow generator (normal, PCF, ESM...).
         * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
         */
        get filter(): number;
        /**
         * Sets the current mode of the shadow generator (normal, PCF, ESM...).
         * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
         */
        set filter(value: number);
        /**
         * Gets if the current filter is set to Poisson Sampling.
         */
        get usePoissonSampling(): boolean;
        /**
         * Sets the current filter to Poisson Sampling.
         */
        set usePoissonSampling(value: boolean);
        /**
         * Gets if the current filter is set to ESM.
         */
        get useExponentialShadowMap(): boolean;
        /**
         * Sets the current filter is to ESM.
         */
        set useExponentialShadowMap(value: boolean);
        /**
         * Gets if the current filter is set to filtered ESM.
         */
        get useBlurExponentialShadowMap(): boolean;
        /**
         * Gets if the current filter is set to filtered  ESM.
         */
        set useBlurExponentialShadowMap(value: boolean);
        /**
         * Gets if the current filter is set to "close ESM" (using the inverse of the
         * exponential to prevent steep falloff artifacts).
         */
        get useCloseExponentialShadowMap(): boolean;
        /**
         * Sets the current filter to "close ESM" (using the inverse of the
         * exponential to prevent steep falloff artifacts).
         */
        set useCloseExponentialShadowMap(value: boolean);
        /**
         * Gets if the current filter is set to filtered "close ESM" (using the inverse of the
         * exponential to prevent steep falloff artifacts).
         */
        get useBlurCloseExponentialShadowMap(): boolean;
        /**
         * Sets the current filter to filtered "close ESM" (using the inverse of the
         * exponential to prevent steep falloff artifacts).
         */
        set useBlurCloseExponentialShadowMap(value: boolean);
        /**
         * Gets if the current filter is set to "PCF" (percentage closer filtering).
         */
        get usePercentageCloserFiltering(): boolean;
        /**
         * Sets the current filter to "PCF" (percentage closer filtering).
         */
        set usePercentageCloserFiltering(value: boolean);
        protected _filteringQuality: number;
        /**
         * Gets the PCF or PCSS Quality.
         * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
         */
        get filteringQuality(): number;
        /**
         * Sets the PCF or PCSS Quality.
         * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
         */
        set filteringQuality(filteringQuality: number);
        /**
         * Gets if the current filter is set to "PCSS" (contact hardening).
         */
        get useContactHardeningShadow(): boolean;
        /**
         * Sets the current filter to "PCSS" (contact hardening).
         */
        set useContactHardeningShadow(value: boolean);
        protected _contactHardeningLightSizeUVRatio: number;
        /**
         * Gets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
         * Using a ratio helps keeping shape stability independently of the map size.
         *
         * It does not account for the light projection as it was having too much
         * instability during the light setup or during light position changes.
         *
         * Only valid if useContactHardeningShadow is true.
         */
        get contactHardeningLightSizeUVRatio(): number;
        /**
         * Sets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
         * Using a ratio helps keeping shape stability independently of the map size.
         *
         * It does not account for the light projection as it was having too much
         * instability during the light setup or during light position changes.
         *
         * Only valid if useContactHardeningShadow is true.
         */
        set contactHardeningLightSizeUVRatio(contactHardeningLightSizeUVRatio: number);
        protected _darkness: number;
        /** Gets or sets the actual darkness of a shadow */
        get darkness(): number;
        set darkness(value: number);
        /**
         * Returns the darkness value (float). This can only decrease the actual darkness of a shadow.
         * 0 means strongest and 1 would means no shadow.
         * @returns the darkness.
         */
        getDarkness(): number;
        /**
         * Sets the darkness value (float). This can only decrease the actual darkness of a shadow.
         * @param darkness The darkness value 0 means strongest and 1 would means no shadow.
         * @returns the shadow generator allowing fluent coding.
         */
        setDarkness(darkness: number): ShadowGenerator;
        protected _transparencyShadow: boolean;
        /** Gets or sets the ability to have transparent shadow  */
        get transparencyShadow(): boolean;
        set transparencyShadow(value: boolean);
        /**
         * Sets the ability to have transparent shadow (boolean).
         * @param transparent True if transparent else False
         * @returns the shadow generator allowing fluent coding
         */
        setTransparencyShadow(transparent: boolean): ShadowGenerator;
        /**
         * Enables or disables shadows with varying strength based on the transparency
         * When it is enabled, the strength of the shadow is taken equal to mesh.visibility
         * If you enabled an alpha texture on your material, the alpha value red from the texture is also combined to compute the strength:
         *          mesh.visibility * alphaTexture.a
         * Note that by definition transparencyShadow must be set to true for enableSoftTransparentShadow to work!
         */
        enableSoftTransparentShadow: boolean;
        protected _shadowMap: Nullable<RenderTargetTexture>;
        protected _shadowMap2: Nullable<RenderTargetTexture>;
        /**
         * Gets the main RTT containing the shadow map (usually storing depth from the light point of view).
         * @returns The render target texture if present otherwise, null
         */
        getShadowMap(): Nullable<RenderTargetTexture>;
        /**
         * Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).
         * @returns The render target texture if the shadow map is present otherwise, null
         */
        getShadowMapForRendering(): Nullable<RenderTargetTexture>;
        /**
         * Gets the class name of that object
         * @returns "ShadowGenerator"
         */
        getClassName(): string;
        /**
         * Helper function to add a mesh and its descendants to the list of shadow casters.
         * @param mesh Mesh to add
         * @param includeDescendants boolean indicating if the descendants should be added. Default to true
         * @returns the Shadow Generator itself
         */
        addShadowCaster(mesh: AbstractMesh, includeDescendants?: boolean): ShadowGenerator;
        /**
         * Helper function to remove a mesh and its descendants from the list of shadow casters
         * @param mesh Mesh to remove
         * @param includeDescendants boolean indicating if the descendants should be removed. Default to true
         * @returns the Shadow Generator itself
         */
        removeShadowCaster(mesh: AbstractMesh, includeDescendants?: boolean): ShadowGenerator;
        /**
         * Controls the extent to which the shadows fade out at the edge of the frustum
         */
        frustumEdgeFalloff: number;
        protected _light: IShadowLight;
        /**
         * Returns the associated light object.
         * @returns the light generating the shadow
         */
        getLight(): IShadowLight;
        /**
         * If true the shadow map is generated by rendering the back face of the mesh instead of the front face.
         * This can help with self-shadowing as the geometry making up the back of objects is slightly offset.
         * It might on the other hand introduce peter panning.
         */
        forceBackFacesOnly: boolean;
        protected _scene: Scene;
        protected _lightDirection: Vector3;
        protected _effect: Effect;
        protected _viewMatrix: Matrix;
        protected _projectionMatrix: Matrix;
        protected _transformMatrix: Matrix;
        protected _cachedPosition: Vector3;
        protected _cachedDirection: Vector3;
        protected _cachedDefines: string;
        protected _currentRenderID: number;
        protected _boxBlurPostprocess: Nullable<PostProcess>;
        protected _kernelBlurXPostprocess: Nullable<PostProcess>;
        protected _kernelBlurYPostprocess: Nullable<PostProcess>;
        protected _blurPostProcesses: PostProcess[];
        protected _mapSize: number;
        protected _currentFaceIndex: number;
        protected _currentFaceIndexCache: number;
        protected _textureType: number;
        protected _defaultTextureMatrix: Matrix;
        protected _storedUniqueId: Nullable<number>;
        /** @hidden */
        static _SceneComponentInitialization: (scene: Scene) => void;
        /**
         * Creates a ShadowGenerator object.
         * A ShadowGenerator is the required tool to use the shadows.
         * Each light casting shadows needs to use its own ShadowGenerator.
         * Documentation : https://doc.babylonjs.com/babylon101/shadows
         * @param mapSize The size of the texture what stores the shadows. Example : 1024.
         * @param light The light object generating the shadows.
         * @param usefulFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.
         */
        constructor(mapSize: number, light: IShadowLight, usefulFloatFirst?: boolean);
        protected _initializeGenerator(): void;
        protected _createTargetRenderTexture(): void;
        protected _initializeShadowMap(): void;
        protected _initializeBlurRTTAndPostProcesses(): void;
        protected _renderForShadowMap(opaqueSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>): void;
        protected _bindCustomEffectForRenderSubMeshForShadowMap(subMesh: SubMesh, effect: Effect, matriceNames: any, mesh: AbstractMesh): void;
        protected _renderSubMeshForShadowMap(subMesh: SubMesh, isTransparent?: boolean): void;
        protected _applyFilterValues(): void;
        /**
         * Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
         * @param onCompiled Callback triggered at the and of the effects compilation
         * @param options Sets of optional options forcing the compilation with different modes
         */
        forceCompilation(onCompiled?: (generator: IShadowGenerator) => void, options?: Partial<{
            useInstances: boolean;
        }>): void;
        /**
         * Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
         * @param options Sets of optional options forcing the compilation with different modes
         * @returns A promise that resolves when the compilation completes
         */
        forceCompilationAsync(options?: Partial<{
            useInstances: boolean;
        }>): Promise<void>;
        protected _isReadyCustomDefines(defines: any, subMesh: SubMesh, useInstances: boolean): void;
        private _prepareShadowDefines;
        /**
         * Determine wheter the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).
         * @param subMesh The submesh we want to render in the shadow map
         * @param useInstances Defines wether will draw in the map using instances
         * @param isTransparent Indicates that isReady is called for a transparent subMesh
         * @returns true if ready otherwise, false
         */
        isReady(subMesh: SubMesh, useInstances: boolean, isTransparent: boolean): boolean;
        /**
         * Prepare all the defines in a material relying on a shadow map at the specified light index.
         * @param defines Defines of the material we want to update
         * @param lightIndex Index of the light in the enabled light list of the material
         */
        prepareDefines(defines: any, lightIndex: number): void;
        /**
         * Binds the shadow related information inside of an effect (information like near, far, darkness...
         * defined in the generator but impacting the effect).
         * @param lightIndex Index of the light in the enabled light list of the material owning the effect
         * @param effect The effect we are binfing the information for
         */
        bindShadowLight(lightIndex: string, effect: Effect): void;
        /**
         * Gets the transformation matrix used to project the meshes into the map from the light point of view.
         * (eq to shadow prjection matrix * light transform matrix)
         * @returns The transform matrix used to create the shadow map
         */
        getTransformMatrix(): Matrix;
        /**
         * Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between
         * Cube and 2D textures for instance.
         */
        recreateShadowMap(): void;
        protected _disposeBlurPostProcesses(): void;
        protected _disposeRTTandPostProcesses(): void;
        /**
         * Disposes the ShadowGenerator.
         * Returns nothing.
         */
        dispose(): void;
        /**
         * Serializes the shadow generator setup to a json object.
         * @returns The serialized JSON object
         */
        serialize(): any;
        /**
         * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.
         * @param parsedShadowGenerator The JSON object to parse
         * @param scene The scene to create the shadow map for
         * @param constr A function that builds a shadow generator or undefined to create an instance of the default shadow generator
         * @returns The parsed shadow generator
         */
        static Parse(parsedShadowGenerator: any, scene: Scene, constr?: (mapSize: number, light: IShadowLight) => ShadowGenerator): ShadowGenerator;
    }
}
declare module BABYLON {
    /**
     * Base class of all the lights in Babylon. It groups all the generic information about lights.
     * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.
     * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.
     */
    export abstract class Light extends Node {
        /**
         * Falloff Default: light is falling off following the material specification:
         * standard material is using standard falloff whereas pbr material can request special falloff per materials.
         */
        static readonly FALLOFF_DEFAULT: number;
        /**
         * Falloff Physical: light is falling off following the inverse squared distance law.
         */
        static readonly FALLOFF_PHYSICAL: number;
        /**
         * Falloff gltf: light is falling off as described in the gltf moving to PBR document
         * to enhance interoperability with other engines.
         */
        static readonly FALLOFF_GLTF: number;
        /**
         * Falloff Standard: light is falling off like in the standard material
         * to enhance interoperability with other materials.
         */
        static readonly FALLOFF_STANDARD: number;
        /**
         * If every light affecting the material is in this lightmapMode,
         * material.lightmapTexture adds or multiplies
         * (depends on material.useLightmapAsShadowmap)
         * after every other light calculations.
         */
        static readonly LIGHTMAP_DEFAULT: number;
        /**
         * material.lightmapTexture as only diffuse lighting from this light
         * adds only specular lighting from this light
         * adds dynamic shadows
         */
        static readonly LIGHTMAP_SPECULAR: number;
        /**
         * material.lightmapTexture as only lighting
         * no light calculation from this light
         * only adds dynamic shadows from this light
         */
        static readonly LIGHTMAP_SHADOWSONLY: number;
        /**
         * Each light type uses the default quantity according to its type:
         *      point/spot lights use luminous intensity
         *      directional lights use illuminance
         */
        static readonly INTENSITYMODE_AUTOMATIC: number;
        /**
         * lumen (lm)
         */
        static readonly INTENSITYMODE_LUMINOUSPOWER: number;
        /**
         * candela (lm/sr)
         */
        static readonly INTENSITYMODE_LUMINOUSINTENSITY: number;
        /**
         * lux (lm/m^2)
         */
        static readonly INTENSITYMODE_ILLUMINANCE: number;
        /**
         * nit (cd/m^2)
         */
        static readonly INTENSITYMODE_LUMINANCE: number;
        /**
         * Light type const id of the point light.
         */
        static readonly LIGHTTYPEID_POINTLIGHT: number;
        /**
         * Light type const id of the directional light.
         */
        static readonly LIGHTTYPEID_DIRECTIONALLIGHT: number;
        /**
         * Light type const id of the spot light.
         */
        static readonly LIGHTTYPEID_SPOTLIGHT: number;
        /**
         * Light type const id of the hemispheric light.
         */
        static readonly LIGHTTYPEID_HEMISPHERICLIGHT: number;
        /**
         * Diffuse gives the basic color to an object.
         */
        diffuse: Color3;
        /**
         * Specular produces a highlight color on an object.
         * Note: This is note affecting PBR materials.
         */
        specular: Color3;
        /**
         * Defines the falloff type for this light. This lets overrriding how punctual light are
         * falling off base on range or angle.
         * This can be set to any values in Light.FALLOFF_x.
         *
         * Note: This is only useful for PBR Materials at the moment. This could be extended if required to
         * other types of materials.
         */
        falloffType: number;
        /**
         * Strength of the light.
         * Note: By default it is define in the framework own unit.
         * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.
         */
        intensity: number;
        private _range;
        protected _inverseSquaredRange: number;
        /**
         * Defines how far from the source the light is impacting in scene units.
         * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.
         */
        get range(): number;
        /**
         * Defines how far from the source the light is impacting in scene units.
         * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.
         */
        set range(value: number);
        /**
         * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type
         * of light.
         */
        private _photometricScale;
        private _intensityMode;
        /**
         * Gets the photometric scale used to interpret the intensity.
         * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
         */
        get intensityMode(): number;
        /**
         * Sets the photometric scale used to interpret the intensity.
         * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
         */
        set intensityMode(value: number);
        private _radius;
        /**
         * Gets the light radius used by PBR Materials to simulate soft area lights.
         */
        get radius(): number;
        /**
         * sets the light radius used by PBR Materials to simulate soft area lights.
         */
        set radius(value: number);
        private _renderPriority;
        /**
         * Defines the rendering priority of the lights. It can help in case of fallback or number of lights
         * exceeding the number allowed of the materials.
         */
        renderPriority: number;
        private _shadowEnabled;
        /**
         * Gets wether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching
         * the current shadow generator.
         */
        get shadowEnabled(): boolean;
        /**
         * Sets wether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching
         * the current shadow generator.
         */
        set shadowEnabled(value: boolean);
        private _includedOnlyMeshes;
        /**
         * Gets the only meshes impacted by this light.
         */
        get includedOnlyMeshes(): AbstractMesh[];
        /**
         * Sets the only meshes impacted by this light.
         */
        set includedOnlyMeshes(value: AbstractMesh[]);
        private _excludedMeshes;
        /**
         * Gets the meshes not impacted by this light.
         */
        get excludedMeshes(): AbstractMesh[];
        /**
         * Sets the meshes not impacted by this light.
         */
        set excludedMeshes(value: AbstractMesh[]);
        private _excludeWithLayerMask;
        /**
         * Gets the layer id use to find what meshes are not impacted by the light.
         * Inactive if 0
         */
        get excludeWithLayerMask(): number;
        /**
         * Sets the layer id use to find what meshes are not impacted by the light.
         * Inactive if 0
         */
        set excludeWithLayerMask(value: number);
        private _includeOnlyWithLayerMask;
        /**
         * Gets the layer id use to find what meshes are impacted by the light.
         * Inactive if 0
         */
        get includeOnlyWithLayerMask(): number;
        /**
         * Sets the layer id use to find what meshes are impacted by the light.
         * Inactive if 0
         */
        set includeOnlyWithLayerMask(value: number);
        private _lightmapMode;
        /**
         * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
         */
        get lightmapMode(): number;
        /**
         * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
         */
        set lightmapMode(value: number);
        /**
         * Shadow generator associted to the light.
         * @hidden Internal use only.
         */
        _shadowGenerator: Nullable<IShadowGenerator>;
        /**
         * @hidden Internal use only.
         */
        _excludedMeshesIds: string[];
        /**
         * @hidden Internal use only.
         */
        _includedOnlyMeshesIds: string[];
        /**
         * The current light unifom buffer.
         * @hidden Internal use only.
         */
        _uniformBuffer: UniformBuffer;
        /** @hidden */
        _renderId: number;
        /**
         * Creates a Light object in the scene.
         * Documentation : https://doc.babylonjs.com/babylon101/lights
         * @param name The firendly name of the light
         * @param scene The scene the light belongs too
         */
        constructor(name: string, scene: Scene);
        protected abstract _buildUniformLayout(): void;
        /**
         * Sets the passed Effect "effect" with the Light information.
         * @param effect The effect to update
         * @param lightIndex The index of the light in the effect to update
         * @returns The light
         */
        abstract transferToEffect(effect: Effect, lightIndex: string): Light;
        /**
         * Sets the passed Effect "effect" with the Light textures.
         * @param effect The effect to update
         * @param lightIndex The index of the light in the effect to update
         * @returns The light
         */
        transferTexturesToEffect(effect: Effect, lightIndex: string): Light;
        /**
         * Binds the lights information from the scene to the effect for the given mesh.
         * @param lightIndex Light index
         * @param scene The scene where the light belongs to
         * @param effect The effect we are binding the data to
         * @param useSpecular Defines if specular is supported
         * @param rebuildInParallel Specifies whether the shader is rebuilding in parallel
         */
        _bindLight(lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, rebuildInParallel?: boolean): void;
        /**
         * Sets the passed Effect "effect" with the Light information.
         * @param effect The effect to update
         * @param lightDataUniformName The uniform used to store light data (position or direction)
         * @returns The light
         */
        abstract transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light;
        /**
         * Returns the string "Light".
         * @returns the class name
         */
        getClassName(): string;
        /** @hidden */
        readonly _isLight: boolean;
        /**
         * Converts the light information to a readable string for debug purpose.
         * @param fullDetails Supports for multiple levels of logging within scene loading
         * @returns the human readable light info
         */
        toString(fullDetails?: boolean): string;
        /** @hidden */
        protected _syncParentEnabledState(): void;
        /**
         * Set the enabled state of this node.
         * @param value - the new enabled state
         */
        setEnabled(value: boolean): void;
        /**
         * Returns the Light associated shadow generator if any.
         * @return the associated shadow generator.
         */
        getShadowGenerator(): Nullable<IShadowGenerator>;
        /**
         * Returns a Vector3, the absolute light position in the World.
         * @returns the world space position of the light
         */
        getAbsolutePosition(): Vector3;
        /**
         * Specifies if the light will affect the passed mesh.
         * @param mesh The mesh to test against the light
         * @return true the mesh is affected otherwise, false.
         */
        canAffectMesh(mesh: AbstractMesh): boolean;
        /**
         * Sort function to order lights for rendering.
         * @param a First Light object to compare to second.
         * @param b Second Light object to compare first.
         * @return -1 to reduce's a's index relative to be, 0 for no change, 1 to increase a's index relative to b.
         */
        static CompareLightsPriority(a: Light, b: Light): number;
        /**
         * Releases resources associated with this node.
         * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
         * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
         */
        dispose(doNotRecurse?: boolean, disposeMaterialAndTextures?: boolean): void;
        /**
         * Returns the light type ID (integer).
         * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
         */
        getTypeID(): number;
        /**
         * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.
         * @returns the scaled intensity in intensity mode unit
         */
        getScaledIntensity(): number;
        /**
         * Returns a new Light object, named "name", from the current one.
         * @param name The name of the cloned light
         * @param newParent The parent of this light, if it has one
         * @returns the new created light
         */
        clone(name: string, newParent?: Nullable<Node>): Nullable<Light>;
        /**
         * Serializes the current light into a Serialization object.
         * @returns the serialized object.
         */
        serialize(): any;
        /**
         * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.
         * This new light is named "name" and added to the passed scene.
         * @param type Type according to the types available in Light.LIGHTTYPEID_x
         * @param name The friendly name of the light
         * @param scene The scene the new light will belong to
         * @returns the constructor function
         */
        static GetConstructorFromName(type: number, name: string, scene: Scene): Nullable<() => Light>;
        /**
         * Parses the passed "parsedLight" and returns a new instanced Light from this parsing.
         * @param parsedLight The JSON representation of the light
         * @param scene The scene to create the parsed light in
         * @returns the created light after parsing
         */
        static Parse(parsedLight: any, scene: Scene): Nullable<Light>;
        private _hookArrayForExcluded;
        private _hookArrayForIncludedOnly;
        private _resyncMeshes;
        /**
         * Forces the meshes to update their light related information in their rendering used effects
         * @hidden Internal Use Only
         */
        _markMeshesAsLightDirty(): void;
        /**
         * Recomputes the cached photometric scale if needed.
         */
        private _computePhotometricScale;
        /**
         * Returns the Photometric Scale according to the light type and intensity mode.
         */
        private _getPhotometricScale;
        /**
         * Reorder the light in the scene according to their defined priority.
         * @hidden Internal Use Only
         */
        _reorderLightsInScene(): void;
        /**
         * Prepares the list of defines specific to the light type.
         * @param defines the list of defines
         * @param lightIndex defines the index of the light for the effect
         */
        abstract prepareLightSpecificDefines(defines: any, lightIndex: number): void;
    }
}
declare module BABYLON {
    /**
     * A target camera takes a mesh or position as a target and continues to look at it while it moves.
     * This is the base of the follow, arc rotate cameras and Free camera
     * @see https://doc.babylonjs.com/features/cameras
     */
    export class TargetCamera extends Camera {
        private static _RigCamTransformMatrix;
        private static _TargetTransformMatrix;
        private static _TargetFocalPoint;
        private _tmpUpVector;
        private _tmpTargetVector;
        /**
         * Define the current direction the camera is moving to
         */
        cameraDirection: Vector3;
        /**
         * Define the current rotation the camera is rotating to
         */
        cameraRotation: Vector2;
        /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */
        ignoreParentScaling: boolean;
        /**
         * When set, the up vector of the camera will be updated by the rotation of the camera
         */
        updateUpVectorFromRotation: boolean;
        private _tmpQuaternion;
        /**
         * Define the current rotation of the camera
         */
        rotation: Vector3;
        /**
         * Define the current rotation of the camera as a quaternion to prevent Gimbal lock
         */
        rotationQuaternion: Quaternion;
        /**
         * Define the current speed of the camera
         */
        speed: number;
        /**
         * Add constraint to the camera to prevent it to move freely in all directions and
         * around all axis.
         */
        noRotationConstraint: boolean;
        /**
         * Reverses mouselook direction to 'natural' panning as opposed to traditional direct
         * panning
         */
        invertRotation: boolean;
        /**
         * Speed multiplier for inverse camera panning
         */
        inverseRotationSpeed: number;
        /**
         * Define the current target of the camera as an object or a position.
         */
        lockedTarget: any;
        /** @hidden */
        _currentTarget: Vector3;
        /** @hidden */
        _initialFocalDistance: number;
        /** @hidden */
        _viewMatrix: Matrix;
        /** @hidden */
        _camMatrix: Matrix;
        /** @hidden */
        _cameraTransformMatrix: Matrix;
        /** @hidden */
        _cameraRotationMatrix: Matrix;
        /** @hidden */
        _referencePoint: Vector3;
        /** @hidden */
        _transformedReferencePoint: Vector3;
        /** @hidden */
        _reset: () => void;
        private _defaultUp;
        /**
         * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.
         * This is the base of the follow, arc rotate cameras and Free camera
         * @see https://doc.babylonjs.com/features/cameras
         * @param name Defines the name of the camera in the scene
         * @param position Defines the start position of the camera in the scene
         * @param scene Defines the scene the camera belongs to
         * @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active if not other active cameras have been defined
         */
        constructor(name: string, position: Vector3, scene: Scene, setActiveOnSceneIfNoneActive?: boolean);
        /**
         * Gets the position in front of the camera at a given distance.
         * @param distance The distance from the camera we want the position to be
         * @returns the position
         */
        getFrontPosition(distance: number): Vector3;
        /** @hidden */
        _getLockedTargetPosition(): Nullable<Vector3>;
        private _storedPosition;
        private _storedRotation;
        private _storedRotationQuaternion;
        /**
         * Store current camera state of the camera (fov, position, rotation, etc..)
         * @returns the camera
         */
        storeState(): Camera;
        /**
         * Restored camera state. You must call storeState() first
         * @returns whether it was successful or not
         * @hidden
         */
        _restoreStateValues(): boolean;
        /** @hidden */
        _initCache(): void;
        /** @hidden */
        _updateCache(ignoreParentClass?: boolean): void;
        /** @hidden */
        _isSynchronizedViewMatrix(): boolean;
        /** @hidden */
        _computeLocalCameraSpeed(): number;
        /**
         * Defines the target the camera should look at.
         * @param target Defines the new target as a Vector or a mesh
         */
        setTarget(target: Vector3): void;
        /**
         * Defines the target point of the camera.
         * The camera looks towards it form the radius distance.
         */
        get target(): Vector3;
        set target(value: Vector3);
        /**
         * Return the current target position of the camera. This value is expressed in local space.
         * @returns the target position
         */
        getTarget(): Vector3;
        /** @hidden */
        _decideIfNeedsToMove(): boolean;
        /** @hidden */
        _updatePosition(): void;
        /** @hidden */
        _checkInputs(): void;
        protected _updateCameraRotationMatrix(): void;
        /**
         * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)
         * @returns the current camera
         */
        private _rotateUpVectorWithCameraRotationMatrix;
        private _cachedRotationZ;
        private _cachedQuaternionRotationZ;
        /** @hidden */
        _getViewMatrix(): Matrix;
        protected _computeViewMatrix(position: Vector3, target: Vector3, up: Vector3): void;
        /**
         * @hidden
         */
        createRigCamera(name: string, cameraIndex: number): Nullable<Camera>;
        /**
         * @hidden
         */
        _updateRigCameras(): void;
        private _getRigCamPositionAndTarget;
        /**
         * Gets the current object class name.
         * @return the class name
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /**
     * Gather the list of keyboard event types as constants.
     */
    export class KeyboardEventTypes {
        /**
         * The keydown event is fired when a key becomes active (pressed).
         */
        static readonly KEYDOWN: number;
        /**
         * The keyup event is fired when a key has been released.
         */
        static readonly KEYUP: number;
    }
    /**
     * This class is used to store keyboard related info for the onKeyboardObservable event.
     */
    export class KeyboardInfo {
        /**
         * Defines the type of event (KeyboardEventTypes)
         */
        type: number;
        /**
         * Defines the related dom event
         */
        event: KeyboardEvent;
        /**
         * Instantiates a new keyboard info.
         * This class is used to store keyboard related info for the onKeyboardObservable event.
         * @param type Defines the type of event (KeyboardEventTypes)
         * @param event Defines the related dom event
         */
        constructor(
        /**
         * Defines the type of event (KeyboardEventTypes)
         */
        type: number, 
        /**
         * Defines the related dom event
         */
        event: KeyboardEvent);
    }
    /**
     * This class is used to store keyboard related info for the onPreKeyboardObservable event.
     * Set the skipOnKeyboardObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onKeyboardObservable
     */
    export class KeyboardInfoPre extends KeyboardInfo {
        /**
         * Defines the type of event (KeyboardEventTypes)
         */
        type: number;
        /**
         * Defines the related dom event
         */
        event: KeyboardEvent;
        /**
         * Defines whether the engine should skip the next onKeyboardObservable associated to this pre.
         */
        skipOnPointerObservable: boolean;
        /**
         * Instantiates a new keyboard pre info.
         * This class is used to store keyboard related info for the onPreKeyboardObservable event.
         * @param type Defines the type of event (KeyboardEventTypes)
         * @param event Defines the related dom event
         */
        constructor(
        /**
         * Defines the type of event (KeyboardEventTypes)
         */
        type: number, 
        /**
         * Defines the related dom event
         */
        event: KeyboardEvent);
    }
}
declare module BABYLON {
    /**
     * Manage the keyboard inputs to control the movement of a free camera.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class FreeCameraKeyboardMoveInput implements ICameraInput<FreeCamera> {
        /**
         * Defines the camera the input is attached to.
         */
        camera: FreeCamera;
        /**
         * Gets or Set the list of keyboard keys used to control the forward move of the camera.
         */
        keysUp: number[];
        /**
         * Gets or Set the list of keyboard keys used to control the upward move of the camera.
         */
        keysUpward: number[];
        /**
         * Gets or Set the list of keyboard keys used to control the backward move of the camera.
         */
        keysDown: number[];
        /**
         * Gets or Set the list of keyboard keys used to control the downward move of the camera.
         */
        keysDownward: number[];
        /**
         * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.
         */
        keysLeft: number[];
        /**
         * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.
         */
        keysRight: number[];
        private _keys;
        private _onCanvasBlurObserver;
        private _onKeyboardObserver;
        private _engine;
        private _scene;
        /**
         * Attach the input controls to a specific dom element to get the input from.
         * @param element Defines the element the controls should be listened from
         * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Detach the current controls from the specified dom element.
         * @param element Defines the element to stop listening the inputs from
         */
        detachControl(element: Nullable<HTMLElement>): void;
        /**
         * Update the current camera state depending on the inputs that have been used this frame.
         * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
         */
        checkInputs(): void;
        /**
         * Gets the class name of the current intput.
         * @returns the class name
         */
        getClassName(): string;
        /** @hidden */
        _onLostFocus(): void;
        /**
         * Get the friendly name associated with the input class.
         * @returns the input friendly name
         */
        getSimpleName(): string;
    }
}
declare module BABYLON {
    /**
     * Gather the list of pointer event types as constants.
     */
    export class PointerEventTypes {
        /**
         * The pointerdown event is fired when a pointer becomes active. For mouse, it is fired when the device transitions from no buttons depressed to at least one button depressed. For touch, it is fired when physical contact is made with the digitizer. For pen, it is fired when the stylus makes physical contact with the digitizer.
         */
        static readonly POINTERDOWN: number;
        /**
         * The pointerup event is fired when a pointer is no longer active.
         */
        static readonly POINTERUP: number;
        /**
         * The pointermove event is fired when a pointer changes coordinates.
         */
        static readonly POINTERMOVE: number;
        /**
         * The pointerwheel event is fired when a mouse wheel has been rotated.
         */
        static readonly POINTERWHEEL: number;
        /**
         * The pointerpick event is fired when a mesh or sprite has been picked by the pointer.
         */
        static readonly POINTERPICK: number;
        /**
         * The pointertap event is fired when a the object has been touched and released without drag.
         */
        static readonly POINTERTAP: number;
        /**
         * The pointerdoubletap event is fired when a the object has been touched and released twice without drag.
         */
        static readonly POINTERDOUBLETAP: number;
    }
    /**
     * Base class of pointer info types.
     */
    export class PointerInfoBase {
        /**
         * Defines the type of event (PointerEventTypes)
         */
        type: number;
        /**
         * Defines the related dom event
         */
        event: PointerEvent | MouseWheelEvent;
        /**
         * Instantiates the base class of pointers info.
         * @param type Defines the type of event (PointerEventTypes)
         * @param event Defines the related dom event
         */
        constructor(
        /**
         * Defines the type of event (PointerEventTypes)
         */
        type: number, 
        /**
         * Defines the related dom event
         */
        event: PointerEvent | MouseWheelEvent);
    }
    /**
     * This class is used to store pointer related info for the onPrePointerObservable event.
     * Set the skipOnPointerObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onPointerObservable
     */
    export class PointerInfoPre extends PointerInfoBase {
        /**
         * Ray from a pointer if availible (eg. 6dof controller)
         */
        ray: Nullable<Ray>;
        /**
         * Defines the local position of the pointer on the canvas.
         */
        localPosition: Vector2;
        /**
         * Defines whether the engine should skip the next OnPointerObservable associated to this pre.
         */
        skipOnPointerObservable: boolean;
        /**
         * Instantiates a PointerInfoPre to store pointer related info to the onPrePointerObservable event.
         * @param type Defines the type of event (PointerEventTypes)
         * @param event Defines the related dom event
         * @param localX Defines the local x coordinates of the pointer when the event occured
         * @param localY Defines the local y coordinates of the pointer when the event occured
         */
        constructor(type: number, event: PointerEvent | MouseWheelEvent, localX: number, localY: number);
    }
    /**
     * This type contains all the data related to a pointer event in Babylon.js.
     * The event member is an instance of PointerEvent for all types except PointerWheel and is of type MouseWheelEvent when type equals PointerWheel. The different event types can be found in the PointerEventTypes class.
     */
    export class PointerInfo extends PointerInfoBase {
        /**
         * Defines the picking info associated to the info (if any)\
         */
        pickInfo: Nullable<PickingInfo>;
        /**
         * Instantiates a PointerInfo to store pointer related info to the onPointerObservable event.
         * @param type Defines the type of event (PointerEventTypes)
         * @param event Defines the related dom event
         * @param pickInfo Defines the picking info associated to the info (if any)\
         */
        constructor(type: number, event: PointerEvent | MouseWheelEvent, 
        /**
         * Defines the picking info associated to the info (if any)\
         */
        pickInfo: Nullable<PickingInfo>);
    }
    /**
     * Data relating to a touch event on the screen.
     */
    export interface PointerTouch {
        /**
         * X coordinate of touch.
         */
        x: number;
        /**
         * Y coordinate of touch.
         */
        y: number;
        /**
         * Id of touch. Unique for each finger.
         */
        pointerId: number;
        /**
         * Event type passed from DOM.
         */
        type: any;
    }
}
declare module BABYLON {
    /**
     * Manage the mouse inputs to control the movement of a free camera.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class FreeCameraMouseInput implements ICameraInput<FreeCamera> {
        /**
         * Define if touch is enabled in the mouse input
         */
        touchEnabled: boolean;
        /**
         * Defines the camera the input is attached to.
         */
        camera: FreeCamera;
        /**
         * Defines the buttons associated with the input to handle camera move.
         */
        buttons: number[];
        /**
         * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.
         */
        angularSensibility: number;
        private _pointerInput;
        private _onMouseMove;
        private _observer;
        private previousPosition;
        /**
         * Observable for when a pointer move event occurs containing the move offset
         */
        onPointerMovedObservable: Observable<{
            offsetX: number;
            offsetY: number;
        }>;
        /**
         * @hidden
         * If the camera should be rotated automatically based on pointer movement
         */
        _allowCameraRotation: boolean;
        /**
         * Manage the mouse inputs to control the movement of a free camera.
         * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
         * @param touchEnabled Defines if touch is enabled or not
         */
        constructor(
        /**
         * Define if touch is enabled in the mouse input
         */
        touchEnabled?: boolean);
        /**
         * Attach the input controls to a specific dom element to get the input from.
         * @param element Defines the element the controls should be listened from
         * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Called on JS contextmenu event.
         * Override this method to provide functionality.
         */
        protected onContextMenu(evt: PointerEvent): void;
        /**
         * Detach the current controls from the specified dom element.
         * @param element Defines the element to stop listening the inputs from
         */
        detachControl(element: Nullable<HTMLElement>): void;
        /**
         * Gets the class name of the current intput.
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Get the friendly name associated with the input class.
         * @returns the input friendly name
         */
        getSimpleName(): string;
    }
}
declare module BABYLON {
    /**
     * Manage the touch inputs to control the movement of a free camera.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class FreeCameraTouchInput implements ICameraInput<FreeCamera> {
        /**
         * Define if mouse events can be treated as touch events
         */
        allowMouse: boolean;
        /**
         * Defines the camera the input is attached to.
         */
        camera: FreeCamera;
        /**
         * Defines the touch sensibility for rotation.
         * The higher the faster.
         */
        touchAngularSensibility: number;
        /**
         * Defines the touch sensibility for move.
         * The higher the faster.
         */
        touchMoveSensibility: number;
        private _offsetX;
        private _offsetY;
        private _pointerPressed;
        private _pointerInput;
        private _observer;
        private _onLostFocus;
        /**
         * Manage the touch inputs to control the movement of a free camera.
         * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
         * @param allowMouse Defines if mouse events can be treated as touch events
         */
        constructor(
        /**
         * Define if mouse events can be treated as touch events
         */
        allowMouse?: boolean);
        /**
         * Attach the input controls to a specific dom element to get the input from.
         * @param element Defines the element the controls should be listened from
         * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Detach the current controls from the specified dom element.
         * @param element Defines the element to stop listening the inputs from
         */
        detachControl(element: Nullable<HTMLElement>): void;
        /**
         * Update the current camera state depending on the inputs that have been used this frame.
         * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
         */
        checkInputs(): void;
        /**
         * Gets the class name of the current intput.
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Get the friendly name associated with the input class.
         * @returns the input friendly name
         */
        getSimpleName(): string;
    }
}
declare module BABYLON {
    /**
     * Default Inputs manager for the FreeCamera.
     * It groups all the default supported inputs for ease of use.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class FreeCameraInputsManager extends CameraInputsManager<FreeCamera> {
        /**
         * @hidden
         */
        _mouseInput: Nullable<FreeCameraMouseInput>;
        /**
         * Instantiates a new FreeCameraInputsManager.
         * @param camera Defines the camera the inputs belong to
         */
        constructor(camera: FreeCamera);
        /**
         * Add keyboard input support to the input manager.
         * @returns the current input manager
         */
        addKeyboard(): FreeCameraInputsManager;
        /**
         * Add mouse input support to the input manager.
         * @param touchEnabled if the FreeCameraMouseInput should support touch (default: true)
         * @returns the current input manager
         */
        addMouse(touchEnabled?: boolean): FreeCameraInputsManager;
        /**
         * Removes the mouse input support from the manager
         * @returns the current input manager
         */
        removeMouse(): FreeCameraInputsManager;
        /**
         * Add touch input support to the input manager.
         * @returns the current input manager
         */
        addTouch(): FreeCameraInputsManager;
        /**
         * Remove all attached input methods from a camera
         */
        clear(): void;
    }
}
declare module BABYLON {
    /**
     * This represents a free type of camera. It can be useful in First Person Shooter game for instance.
     * Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.
     * @see https://doc.babylonjs.com/features/cameras#universal-camera
     */
    export class FreeCamera extends TargetCamera {
        /**
         * Define the collision ellipsoid of the camera.
         * This is helpful to simulate a camera body like the player body around the camera
         * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#arcrotatecamera
         */
        ellipsoid: Vector3;
        /**
         * Define an offset for the position of the ellipsoid around the camera.
         * This can be helpful to determine the center of the body near the gravity center of the body
         * instead of its head.
         */
        ellipsoidOffset: Vector3;
        /**
         * Enable or disable collisions of the camera with the rest of the scene objects.
         */
        checkCollisions: boolean;
        /**
         * Enable or disable gravity on the camera.
         */
        applyGravity: boolean;
        /**
         * Define the input manager associated to the camera.
         */
        inputs: FreeCameraInputsManager;
        /**
         * Gets the input sensibility for a mouse input. (default is 2000.0)
         * Higher values reduce sensitivity.
         */
        get angularSensibility(): number;
        /**
         * Sets the input sensibility for a mouse input. (default is 2000.0)
         * Higher values reduce sensitivity.
         */
        set angularSensibility(value: number);
        /**
         * Gets or Set the list of keyboard keys used to control the forward move of the camera.
         */
        get keysUp(): number[];
        set keysUp(value: number[]);
        /**
         * Gets or Set the list of keyboard keys used to control the upward move of the camera.
         */
        get keysUpward(): number[];
        set keysUpward(value: number[]);
        /**
         * Gets or Set the list of keyboard keys used to control the backward move of the camera.
         */
        get keysDown(): number[];
        set keysDown(value: number[]);
        /**
        * Gets or Set the list of keyboard keys used to control the downward move of the camera.
        */
        get keysDownward(): number[];
        set keysDownward(value: number[]);
        /**
         * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.
         */
        get keysLeft(): number[];
        set keysLeft(value: number[]);
        /**
         * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.
         */
        get keysRight(): number[];
        set keysRight(value: number[]);
        /**
         * Event raised when the camera collide with a mesh in the scene.
         */
        onCollide: (collidedMesh: AbstractMesh) => void;
        private _collider;
        private _needMoveForGravity;
        private _oldPosition;
        private _diffPosition;
        private _newPosition;
        /** @hidden */
        _localDirection: Vector3;
        /** @hidden */
        _transformedDirection: Vector3;
        /**
         * Instantiates a Free Camera.
         * This represents a free type of camera. It can be useful in First Person Shooter game for instance.
         * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.
         * @see https://doc.babylonjs.com/features/cameras#universal-camera
         * @param name Define the name of the camera in the scene
         * @param position Define the start position of the camera in the scene
         * @param scene Define the scene the camera belongs to
         * @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active if not other active cameras have been defined
         */
        constructor(name: string, position: Vector3, scene: Scene, setActiveOnSceneIfNoneActive?: boolean);
        /**
         * Attached controls to the current camera.
         * @param element Defines the element the controls should be listened from
         * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Detach the current controls from the camera.
         * The camera will stop reacting to inputs.
         * @param element Defines the element to stop listening the inputs from
         */
        detachControl(element: HTMLElement): void;
        private _collisionMask;
        /**
         * Define a collision mask to limit the list of object the camera can collide with
         */
        get collisionMask(): number;
        set collisionMask(mask: number);
        /** @hidden */
        _collideWithWorld(displacement: Vector3): void;
        private _onCollisionPositionChange;
        /** @hidden */
        _checkInputs(): void;
        /** @hidden */
        _decideIfNeedsToMove(): boolean;
        /** @hidden */
        _updatePosition(): void;
        /**
         * Destroy the camera and release the current resources hold by it.
         */
        dispose(): void;
        /**
         * Gets the current object class name.
         * @return the class name
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /**
     * Represents a gamepad control stick position
     */
    export class StickValues {
        /**
         * The x component of the control stick
         */
        x: number;
        /**
         * The y component of the control stick
         */
        y: number;
        /**
         * Initializes the gamepad x and y control stick values
         * @param x The x component of the gamepad control stick value
         * @param y The y component of the gamepad control stick value
         */
        constructor(
        /**
         * The x component of the control stick
         */
        x: number, 
        /**
         * The y component of the control stick
         */
        y: number);
    }
    /**
     * An interface which manages callbacks for gamepad button changes
     */
    export interface GamepadButtonChanges {
        /**
         * Called when a gamepad has been changed
         */
        changed: boolean;
        /**
         * Called when a gamepad press event has been triggered
         */
        pressChanged: boolean;
        /**
         * Called when a touch event has been triggered
         */
        touchChanged: boolean;
        /**
         * Called when a value has changed
         */
        valueChanged: boolean;
    }
    /**
     * Represents a gamepad
     */
    export class Gamepad {
        /**
         * The id of the gamepad
         */
        id: string;
        /**
         * The index of the gamepad
         */
        index: number;
        /**
         * The browser gamepad
         */
        browserGamepad: any;
        /**
         * Specifies what type of gamepad this represents
         */
        type: number;
        private _leftStick;
        private _rightStick;
        /** @hidden */
        _isConnected: boolean;
        private _leftStickAxisX;
        private _leftStickAxisY;
        private _rightStickAxisX;
        private _rightStickAxisY;
        /**
         * Triggered when the left control stick has been changed
         */
        private _onleftstickchanged;
        /**
         * Triggered when the right control stick has been changed
         */
        private _onrightstickchanged;
        /**
         * Represents a gamepad controller
         */
        static GAMEPAD: number;
        /**
         * Represents a generic controller
         */
        static GENERIC: number;
        /**
         * Represents an XBox controller
         */
        static XBOX: number;
        /**
         * Represents a pose-enabled controller
         */
        static POSE_ENABLED: number;
        /**
         * Represents an Dual Shock controller
         */
        static DUALSHOCK: number;
        /**
         * Specifies whether the left control stick should be Y-inverted
         */
        protected _invertLeftStickY: boolean;
        /**
         * Specifies if the gamepad has been connected
         */
        get isConnected(): boolean;
        /**
         * Initializes the gamepad
         * @param id The id of the gamepad
         * @param index The index of the gamepad
         * @param browserGamepad The browser gamepad
         * @param leftStickX The x component of the left joystick
         * @param leftStickY The y component of the left joystick
         * @param rightStickX The x component of the right joystick
         * @param rightStickY The y component of the right joystick
         */
        constructor(
        /**
         * The id of the gamepad
         */
        id: string, 
        /**
         * The index of the gamepad
         */
        index: number, 
        /**
         * The browser gamepad
         */
        browserGamepad: any, leftStickX?: number, leftStickY?: number, rightStickX?: number, rightStickY?: number);
        /**
         * Callback triggered when the left joystick has changed
         * @param callback
         */
        onleftstickchanged(callback: (values: StickValues) => void): void;
        /**
         * Callback triggered when the right joystick has changed
         * @param callback
         */
        onrightstickchanged(callback: (values: StickValues) => void): void;
        /**
         * Gets the left joystick
         */
        get leftStick(): StickValues;
        /**
         * Sets the left joystick values
         */
        set leftStick(newValues: StickValues);
        /**
         * Gets the right joystick
         */
        get rightStick(): StickValues;
        /**
         * Sets the right joystick value
         */
        set rightStick(newValues: StickValues);
        /**
         * Updates the gamepad joystick positions
         */
        update(): void;
        /**
         * Disposes the gamepad
         */
        dispose(): void;
    }
    /**
     * Represents a generic gamepad
     */
    export class GenericPad extends Gamepad {
        private _buttons;
        private _onbuttondown;
        private _onbuttonup;
        /**
         * Observable triggered when a button has been pressed
         */
        onButtonDownObservable: Observable<number>;
        /**
         * Observable triggered when a button has been released
         */
        onButtonUpObservable: Observable<number>;
        /**
         * Callback triggered when a button has been pressed
         * @param callback Called when a button has been pressed
         */
        onbuttondown(callback: (buttonPressed: number) => void): void;
        /**
         * Callback triggered when a button has been released
         * @param callback Called when a button has been released
         */
        onbuttonup(callback: (buttonReleased: number) => void): void;
        /**
         * Initializes the generic gamepad
         * @param id The id of the generic gamepad
         * @param index The index of the generic gamepad
         * @param browserGamepad The browser gamepad
         */
        constructor(id: string, index: number, browserGamepad: any);
        private _setButtonValue;
        /**
         * Updates the generic gamepad
         */
        update(): void;
        /**
         * Disposes the generic gamepad
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
    * Defines the types of pose enabled controllers that are supported
    */
    export enum PoseEnabledControllerType {
        /**
         * HTC Vive
         */
        VIVE = 0,
        /**
         * Oculus Rift
         */
        OCULUS = 1,
        /**
         * Windows mixed reality
         */
        WINDOWS = 2,
        /**
         * Samsung gear VR
         */
        GEAR_VR = 3,
        /**
         * Google Daydream
         */
        DAYDREAM = 4,
        /**
         * Generic
         */
        GENERIC = 5
    }
    /**
     * Defines the MutableGamepadButton interface for the state of a gamepad button
     */
    export interface MutableGamepadButton {
        /**
         * Value of the button/trigger
         */
        value: number;
        /**
         * If the button/trigger is currently touched
         */
        touched: boolean;
        /**
         * If the button/trigger is currently pressed
         */
        pressed: boolean;
    }
    /**
     * Defines the ExtendedGamepadButton interface for a gamepad button which includes state provided by a pose controller
     * @hidden
     */
    export interface ExtendedGamepadButton extends GamepadButton {
        /**
         * If the button/trigger is currently pressed
         */
        readonly pressed: boolean;
        /**
         * If the button/trigger is currently touched
         */
        readonly touched: boolean;
        /**
         * Value of the button/trigger
         */
        readonly value: number;
    }
    /** @hidden */
    export interface _GamePadFactory {
        /**
         * Returns whether or not the current gamepad can be created for this type of controller.
         * @param gamepadInfo Defines the gamepad info as received from the controller APIs.
         * @returns true if it can be created, otherwise false
         */
        canCreate(gamepadInfo: any): boolean;
        /**
         * Creates a new instance of the Gamepad.
         * @param gamepadInfo Defines the gamepad info as received from the controller APIs.
         * @returns the new gamepad instance
         */
        create(gamepadInfo: any): Gamepad;
    }
    /**
     * Defines the PoseEnabledControllerHelper object that is used initialize a gamepad as the controller type it is specified as (eg. windows mixed reality controller)
     */
    export class PoseEnabledControllerHelper {
        /** @hidden */
        static _ControllerFactories: _GamePadFactory[];
        /** @hidden */
        static _DefaultControllerFactory: Nullable<(gamepadInfo: any) => Gamepad>;
        /**
         * Initializes a gamepad as the controller type it is specified as (eg. windows mixed reality controller)
         * @param vrGamepad the gamepad to initialized
         * @returns a vr controller of the type the gamepad identified as
         */
        static InitiateController(vrGamepad: any): Gamepad;
    }
    /**
     * Defines the PoseEnabledController object that contains state of a vr capable controller
     */
    export class PoseEnabledController extends Gamepad implements PoseControlled {
        /**
         * If the controller is used in a webXR session
         */
        isXR: boolean;
        private _deviceRoomPosition;
        private _deviceRoomRotationQuaternion;
        /**
         * The device position in babylon space
         */
        devicePosition: Vector3;
        /**
         * The device rotation in babylon space
         */
        deviceRotationQuaternion: Quaternion;
        /**
         * The scale factor of the device in babylon space
         */
        deviceScaleFactor: number;
        /**
         * (Likely devicePosition should be used instead) The device position in its room space
         */
        position: Vector3;
        /**
         * (Likely deviceRotationQuaternion should be used instead) The device rotation in its room space
         */
        rotationQuaternion: Quaternion;
        /**
         * The type of controller (Eg. Windows mixed reality)
         */
        controllerType: PoseEnabledControllerType;
        protected _calculatedPosition: Vector3;
        private _calculatedRotation;
        /**
         * The raw pose from the device
         */
        rawPose: DevicePose;
        private _trackPosition;
        private _maxRotationDistFromHeadset;
        private _draggedRoomRotation;
        /**
         * @hidden
         */
        _disableTrackPosition(fixedPosition: Vector3): void;
        /**
         * Internal, the mesh attached to the controller
         * @hidden
         */
        _mesh: Nullable<AbstractMesh>;
        private _poseControlledCamera;
        private _leftHandSystemQuaternion;
        /**
         * Internal, matrix used to convert room space to babylon space
         * @hidden
         */
        _deviceToWorld: Matrix;
        /**
         * Node to be used when casting a ray from the controller
         * @hidden
         */
        _pointingPoseNode: Nullable<TransformNode>;
        /**
         * Name of the child mesh that can be used to cast a ray from the controller
         */
        static readonly POINTING_POSE: string;
        /**
         * Creates a new PoseEnabledController from a gamepad
         * @param browserGamepad the gamepad that the PoseEnabledController should be created from
         */
        constructor(browserGamepad: any);
        private _workingMatrix;
        /**
         * Updates the state of the pose enbaled controller and mesh based on the current position and rotation of the controller
         */
        update(): void;
        /**
         * Updates only the pose device and mesh without doing any button event checking
         */
        protected _updatePoseAndMesh(): void;
        /**
         * Updates the state of the pose enbaled controller based on the raw pose data from the device
         * @param poseData raw pose fromthe device
         */
        updateFromDevice(poseData: DevicePose): void;
        /**
         * @hidden
         */
        _meshAttachedObservable: Observable<AbstractMesh>;
        /**
         * Attaches a mesh to the controller
         * @param mesh the mesh to be attached
         */
        attachToMesh(mesh: AbstractMesh): void;
        /**
         * Attaches the controllers mesh to a camera
         * @param camera the camera the mesh should be attached to
         */
        attachToPoseControlledCamera(camera: TargetCamera): void;
        /**
         * Disposes of the controller
         */
        dispose(): void;
        /**
         * The mesh that is attached to the controller
         */
        get mesh(): Nullable<AbstractMesh>;
        /**
         * Gets the ray of the controller in the direction the controller is pointing
         * @param length the length the resulting ray should be
         * @returns a ray in the direction the controller is pointing
         */
        getForwardRay(length?: number): Ray;
    }
}
declare module BABYLON {
    /**
     * Defines the WebVRController object that represents controllers tracked in 3D space
     */
    export abstract class WebVRController extends PoseEnabledController {
        /**
         * Internal, the default controller model for the controller
         */
        protected _defaultModel: Nullable<AbstractMesh>;
        /**
         * Fired when the trigger state has changed
         */
        onTriggerStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the main button state has changed
         */
        onMainButtonStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the secondary button state has changed
         */
        onSecondaryButtonStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the pad state has changed
         */
        onPadStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when controllers stick values have changed
         */
        onPadValuesChangedObservable: Observable<StickValues>;
        /**
         * Array of button availible on the controller
         */
        protected _buttons: Array<MutableGamepadButton>;
        private _onButtonStateChange;
        /**
         * Fired when a controller button's state has changed
         * @param callback the callback containing the button that was modified
         */
        onButtonStateChange(callback: (controlledIndex: number, buttonIndex: number, state: ExtendedGamepadButton) => void): void;
        /**
         * X and Y axis corresponding to the controllers joystick
         */
        pad: StickValues;
        /**
         * 'left' or 'right', see https://w3c.github.io/gamepad/extensions.html#gamepadhand-enum
         */
        hand: string;
        /**
         * The default controller model for the controller
         */
        get defaultModel(): Nullable<AbstractMesh>;
        /**
         * Creates a new WebVRController from a gamepad
         * @param vrGamepad the gamepad that the WebVRController should be created from
         */
        constructor(vrGamepad: any);
        /**
         * Updates the state of the controller and mesh based on the current position and rotation of the controller
         */
        update(): void;
        /**
         * Function to be called when a button is modified
         */
        protected abstract _handleButtonChange(buttonIdx: number, value: ExtendedGamepadButton, changes: GamepadButtonChanges): void;
        /**
         * Loads a mesh and attaches it to the controller
         * @param scene the scene the mesh should be added to
         * @param meshLoaded callback for when the mesh has been loaded
         */
        abstract initControllerMesh(scene: Scene, meshLoaded?: (mesh: AbstractMesh) => void): void;
        private _setButtonValue;
        private _changes;
        private _checkChanges;
        /**
         * Disposes of th webVRCOntroller
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * The HemisphericLight simulates the ambient environment light,
     * so the passed direction is the light reflection direction, not the incoming direction.
     */
    export class HemisphericLight extends Light {
        /**
         * The groundColor is the light in the opposite direction to the one specified during creation.
         * You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.
         */
        groundColor: Color3;
        /**
         * The light reflection direction, not the incoming direction.
         */
        direction: Vector3;
        /**
         * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).
         * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.
         * The HemisphericLight can't cast shadows.
         * Documentation : https://doc.babylonjs.com/babylon101/lights
         * @param name The friendly name of the light
         * @param direction The direction of the light reflection
         * @param scene The scene the light belongs to
         */
        constructor(name: string, direction: Vector3, scene: Scene);
        protected _buildUniformLayout(): void;
        /**
         * Returns the string "HemisphericLight".
         * @return The class name
         */
        getClassName(): string;
        /**
         * Sets the HemisphericLight direction towards the passed target (Vector3).
         * Returns the updated direction.
         * @param target The target the direction should point to
         * @return The computed direction
         */
        setDirectionToTarget(target: Vector3): Vector3;
        /**
         * Returns the shadow generator associated to the light.
         * @returns Always null for hemispheric lights because it does not support shadows.
         */
        getShadowGenerator(): Nullable<IShadowGenerator>;
        /**
         * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).
         * @param effect The effect to update
         * @param lightIndex The index of the light in the effect to update
         * @returns The hemispheric light
         */
        transferToEffect(effect: Effect, lightIndex: string): HemisphericLight;
        transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): this;
        /**
         * Computes the world matrix of the node
         * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch
         * @param useWasUpdatedFlag defines a reserved property
         * @returns the world matrix
         */
        computeWorldMatrix(): Matrix;
        /**
         * Returns the integer 3.
         * @return The light Type id as a constant defines in Light.LIGHTTYPEID_x
         */
        getTypeID(): number;
        /**
         * Prepares the list of defines specific to the light type.
         * @param defines the list of defines
         * @param lightIndex defines the index of the light for the effect
         */
        prepareLightSpecificDefines(defines: any, lightIndex: number): void;
    }
}
declare module BABYLON {
    /** @hidden */
    export var vrMultiviewToSingleviewPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Renders to multiple views with a single draw call
     * @see https://www.khronos.org/registry/webgl/extensions/WEBGL_multiview/
     */
    export class MultiviewRenderTarget extends RenderTargetTexture {
        /**
         * Creates a multiview render target
         * @param scene scene used with the render target
         * @param size the size of the render target (used for each view)
         */
        constructor(scene: Scene, size?: number | {
            width: number;
            height: number;
        } | {
            ratio: number;
        });
        /**
         * @hidden
         * @param faceIndex the face index, if its a cube texture
         */
        _bindFrameBuffer(faceIndex?: number): void;
        /**
         * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)
         * @returns the view count
         */
        getViewCount(): number;
    }
}
declare module BABYLON {
        interface Engine {
            /**
             * Creates a new multiview render target
             * @param width defines the width of the texture
             * @param height defines the height of the texture
             * @returns the created multiview texture
             */
            createMultiviewRenderTargetTexture(width: number, height: number): InternalTexture;
            /**
             * Binds a multiview framebuffer to be drawn to
             * @param multiviewTexture texture to bind
             */
            bindMultiviewFramebuffer(multiviewTexture: InternalTexture): void;
        }
        interface Camera {
            /**
             * @hidden
             * For cameras that cannot use multiview images to display directly. (e.g. webVR camera will render to multiview texture, then copy to each eye texture and go from there)
             */
            _useMultiviewToSingleView: boolean;
            /**
             * @hidden
             * For cameras that cannot use multiview images to display directly. (e.g. webVR camera will render to multiview texture, then copy to each eye texture and go from there)
             */
            _multiviewTexture: Nullable<RenderTargetTexture>;
            /**
             * @hidden
             * ensures the multiview texture of the camera exists and has the specified width/height
             * @param width height to set on the multiview texture
             * @param height width to set on the multiview texture
             */
            _resizeOrCreateMultiviewTexture(width: number, height: number): void;
        }
        interface Scene {
            /** @hidden */
            _transformMatrixR: Matrix;
            /** @hidden */
            _multiviewSceneUbo: Nullable<UniformBuffer>;
            /** @hidden */
            _createMultiviewUbo(): void;
            /** @hidden */
            _updateMultiviewUbo(viewR?: Matrix, projectionR?: Matrix): void;
            /** @hidden */
            _renderMultiviewToSingleView(camera: Camera): void;
        }
}
declare module BABYLON {
    /**
     * VRMultiviewToSingleview used to convert multiview texture arrays to standard textures for scenarios such as webVR
     * This will not be used for webXR as it supports displaying texture arrays directly
     */
    export class VRMultiviewToSingleviewPostProcess extends PostProcess {
        /**
         * Gets a string identifying the name of the class
         * @returns "VRMultiviewToSingleviewPostProcess" string
         */
        getClassName(): string;
        /**
         * Initializes a VRMultiviewToSingleview
         * @param name name of the post process
         * @param camera camera to be applied to
         * @param scaleFactor scaling factor to the size of the output texture
         */
        constructor(name: string, camera: Camera, scaleFactor: number);
    }
}
declare module BABYLON {
    /**
     * Interface used to define additional presentation attributes
     */
    export interface IVRPresentationAttributes {
        /**
         * Defines a boolean indicating that we want to get 72hz mode on Oculus Browser (default is off eg. 60hz)
         */
        highRefreshRate: boolean;
        /**
         * Enables foveation in VR to improve perf. 0 none, 1 low, 2 medium, 3 high (Default is 1)
         */
        foveationLevel: number;
    }
        interface Engine {
            /** @hidden */
            _vrDisplay: any;
            /** @hidden */
            _vrSupported: boolean;
            /** @hidden */
            _oldSize: Size;
            /** @hidden */
            _oldHardwareScaleFactor: number;
            /** @hidden */
            _vrExclusivePointerMode: boolean;
            /** @hidden */
            _webVRInitPromise: Promise<IDisplayChangedEventArgs>;
            /** @hidden */
            _onVRDisplayPointerRestricted: () => void;
            /** @hidden */
            _onVRDisplayPointerUnrestricted: () => void;
            /** @hidden */
            _onVrDisplayConnect: Nullable<(display: any) => void>;
            /** @hidden */
            _onVrDisplayDisconnect: Nullable<() => void>;
            /** @hidden */
            _onVrDisplayPresentChange: Nullable<() => void>;
            /**
             * Observable signaled when VR display mode changes
             */
            onVRDisplayChangedObservable: Observable<IDisplayChangedEventArgs>;
            /**
             * Observable signaled when VR request present is complete
             */
            onVRRequestPresentComplete: Observable<boolean>;
            /**
             * Observable signaled when VR request present starts
             */
            onVRRequestPresentStart: Observable<Engine>;
            /**
             * Gets a boolean indicating that the engine is currently in VR exclusive mode for the pointers
             * @see https://docs.microsoft.com/en-us/microsoft-edge/webvr/essentials#mouse-input
             */
            isInVRExclusivePointerMode: boolean;
            /**
             * Gets a boolean indicating if a webVR device was detected
             * @returns true if a webVR device was detected
             */
            isVRDevicePresent(): boolean;
            /**
             * Gets the current webVR device
             * @returns the current webVR device (or null)
             */
            getVRDevice(): any;
            /**
             * Initializes a webVR display and starts listening to display change events
             * The onVRDisplayChangedObservable will be notified upon these changes
             * @returns A promise containing a VRDisplay and if vr is supported
             */
            initWebVRAsync(): Promise<IDisplayChangedEventArgs>;
            /** @hidden */
            _getVRDisplaysAsync(): Promise<IDisplayChangedEventArgs>;
            /**
             * Gets or sets the presentation attributes used to configure VR rendering
             */
            vrPresentationAttributes?: IVRPresentationAttributes;
            /**
             * Call this function to switch to webVR mode
             * Will do nothing if webVR is not supported or if there is no webVR device
             * @param options the webvr options provided to the camera. mainly used for multiview
             * @see https://doc.babylonjs.com/how_to/webvr_camera
             */
            enableVR(options: WebVROptions): void;
            /** @hidden */
            _onVRFullScreenTriggered(): void;
        }
}
declare module BABYLON {
    /**
     * This is a copy of VRPose. See https://developer.mozilla.org/en-US/docs/Web/API/VRPose
     * IMPORTANT!! The data is right-hand data.
     * @export
     * @interface DevicePose
     */
    export interface DevicePose {
        /**
         * The position of the device, values in array are [x,y,z].
         */
        readonly position: Nullable<Float32Array>;
        /**
         * The linearVelocity of the device, values in array are [x,y,z].
         */
        readonly linearVelocity: Nullable<Float32Array>;
        /**
         * The linearAcceleration of the device, values in array are [x,y,z].
         */
        readonly linearAcceleration: Nullable<Float32Array>;
        /**
         * The orientation of the device in a quaternion array, values in array are [x,y,z,w].
         */
        readonly orientation: Nullable<Float32Array>;
        /**
         * The angularVelocity of the device, values in array are [x,y,z].
         */
        readonly angularVelocity: Nullable<Float32Array>;
        /**
         * The angularAcceleration of the device, values in array are [x,y,z].
         */
        readonly angularAcceleration: Nullable<Float32Array>;
    }
    /**
    * Interface representing a pose controlled object in Babylon.
    * A pose controlled object has both regular pose values as well as pose values
    * from an external device such as a VR head mounted display
    */
    export interface PoseControlled {
        /**
         * The position of the object in babylon space.
         */
        position: Vector3;
        /**
         * The rotation quaternion of the object in babylon space.
         */
        rotationQuaternion: Quaternion;
        /**
         * The position of the device in babylon space.
         */
        devicePosition?: Vector3;
        /**
         * The rotation quaternion of the device in babylon space.
         */
        deviceRotationQuaternion: Quaternion;
        /**
         * The raw pose coming from the device.
         */
        rawPose: Nullable<DevicePose>;
        /**
         * The scale of the device to be used when translating from device space to babylon space.
         */
        deviceScaleFactor: number;
        /**
         * Updates the poseControlled values based on the input device pose.
         * @param poseData the pose data to update the object with
         */
        updateFromDevice(poseData: DevicePose): void;
    }
    /**
     * Set of options to customize the webVRCamera
     */
    export interface WebVROptions {
        /**
         * Sets if the webVR camera should be tracked to the vrDevice. (default: true)
         */
        trackPosition?: boolean;
        /**
         * Sets the scale of the vrDevice in babylon space. (default: 1)
         */
        positionScale?: number;
        /**
         * If there are more than one VRDisplays, this will choose the display matching this name. (default: pick first vrDisplay)
         */
        displayName?: string;
        /**
         * Should the native controller meshes be initialized. (default: true)
         */
        controllerMeshes?: boolean;
        /**
         * Creating a default HemiLight only on controllers. (default: true)
         */
        defaultLightingOnControllers?: boolean;
        /**
         * If you don't want to use the default VR button of the helper. (default: false)
         */
        useCustomVRButton?: boolean;
        /**
         * If you'd like to provide your own button to the VRHelper. (default: standard babylon vr button)
         */
        customVRButton?: HTMLButtonElement;
        /**
         * To change the length of the ray for gaze/controllers. Will be scaled by positionScale. (default: 100)
         */
        rayLength?: number;
        /**
         * To change the default offset from the ground to account for user's height in meters. Will be scaled by positionScale. (default: 1.7)
         */
        defaultHeight?: number;
        /**
         * If multiview should be used if availible (default: false)
         */
        useMultiview?: boolean;
    }
    /**
     * This represents a WebVR camera.
     * The WebVR camera is Babylon's simple interface to interaction with Windows Mixed Reality, HTC Vive and Oculus Rift.
     * @example https://doc.babylonjs.com/how_to/webvr_camera
     */
    export class WebVRFreeCamera extends FreeCamera implements PoseControlled {
        private webVROptions;
        /**
         * @hidden
         * The vrDisplay tied to the camera. See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay
         */
        _vrDevice: any;
        /**
         * The rawPose of the vrDevice.
         */
        rawPose: Nullable<DevicePose>;
        private _onVREnabled;
        private _specsVersion;
        private _attached;
        private _frameData;
        protected _descendants: Array<Node>;
        private _deviceRoomPosition;
        /** @hidden */
        _deviceRoomRotationQuaternion: Quaternion;
        private _standingMatrix;
        /**
         * Represents device position in babylon space.
         */
        devicePosition: Vector3;
        /**
         * Represents device rotation in babylon space.
         */
        deviceRotationQuaternion: Quaternion;
        /**
         * The scale of the device to be used when translating from device space to babylon space.
         */
        deviceScaleFactor: number;
        private _deviceToWorld;
        private _worldToDevice;
        /**
         * References to the webVR controllers for the vrDevice.
         */
        controllers: Array<WebVRController>;
        /**
         * Emits an event when a controller is attached.
         */
        onControllersAttachedObservable: Observable<WebVRController[]>;
        /**
         * Emits an event when a controller's mesh has been loaded;
         */
        onControllerMeshLoadedObservable: Observable<WebVRController>;
        /**
         * Emits an event when the HMD's pose has been updated.
         */
        onPoseUpdatedFromDeviceObservable: Observable<any>;
        private _poseSet;
        /**
         * If the rig cameras be used as parent instead of this camera.
         */
        rigParenting: boolean;
        private _lightOnControllers;
        private _defaultHeight?;
        /**
         * Instantiates a WebVRFreeCamera.
         * @param name The name of the WebVRFreeCamera
         * @param position The starting anchor position for the camera
         * @param scene The scene the camera belongs to
         * @param webVROptions a set of customizable options for the webVRCamera
         */
        constructor(name: string, position: Vector3, scene: Scene, webVROptions?: WebVROptions);
        /**
         * Gets the device distance from the ground in meters.
         * @returns the distance in meters from the vrDevice to ground in device space. If standing matrix is not supported for the vrDevice 0 is returned.
         */
        deviceDistanceToRoomGround(): number;
        /**
         * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.
         * @param callback will be called when the standing matrix is set. Callback parameter is if the standing matrix is supported.
         */
        useStandingMatrix(callback?: (bool: boolean) => void): void;
        /**
         * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.
         * @returns A promise with a boolean set to if the standing matrix is supported.
         */
        useStandingMatrixAsync(): Promise<boolean>;
        /**
         * Disposes the camera
         */
        dispose(): void;
        /**
         * Gets a vrController by name.
         * @param name The name of the controller to retreive
         * @returns the controller matching the name specified or null if not found
         */
        getControllerByName(name: string): Nullable<WebVRController>;
        private _leftController;
        /**
         * The controller corresponding to the users left hand.
         */
        get leftController(): Nullable<WebVRController>;
        private _rightController;
        /**
         * The controller corresponding to the users right hand.
         */
        get rightController(): Nullable<WebVRController>;
        /**
         * Casts a ray forward from the vrCamera's gaze.
         * @param length Length of the ray (default: 100)
         * @returns the ray corresponding to the gaze
         */
        getForwardRay(length?: number): Ray;
        /**
         * @hidden
         * Updates the camera based on device's frame data
         */
        _checkInputs(): void;
        /**
         * Updates the poseControlled values based on the input device pose.
         * @param poseData Pose coming from the device
         */
        updateFromDevice(poseData: DevicePose): void;
        private _htmlElementAttached;
        private _detachIfAttached;
        /**
         * WebVR's attach control will start broadcasting frames to the device.
         * Note that in certain browsers (chrome for example) this function must be called
         * within a user-interaction callback. Example:
         * <pre> scene.onPointerDown = function() { camera.attachControl(canvas); }</pre>
         *
         * @param element html element to attach the vrDevice to
         * @param noPreventDefault prevent the default html element operation when attaching the vrDevice
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Detaches the camera from the html element and disables VR
         *
         * @param element html element to detach from
         */
        detachControl(element: HTMLElement): void;
        /**
         * @returns the name of this class
         */
        getClassName(): string;
        /**
         * Calls resetPose on the vrDisplay
         * See: https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/resetPose
         */
        resetToCurrentRotation(): void;
        /**
         * @hidden
         * Updates the rig cameras (left and right eye)
         */
        _updateRigCameras(): void;
        private _workingVector;
        private _oneVector;
        private _workingMatrix;
        private updateCacheCalled;
        private _correctPositionIfNotTrackPosition;
        /**
         * @hidden
         * Updates the cached values of the camera
         * @param ignoreParentClass ignores updating the parent class's cache (default: false)
         */
        _updateCache(ignoreParentClass?: boolean): void;
        /**
         * @hidden
         * Get current device position in babylon world
         */
        _computeDevicePosition(): void;
        /**
         * Updates the current device position and rotation in the babylon world
         */
        update(): void;
        /**
         * @hidden
         * Gets the view matrix of this camera (Always set to identity as left and right eye cameras contain the actual view matrix)
         * @returns an identity matrix
         */
        _getViewMatrix(): Matrix;
        private _tmpMatrix;
        /**
         * This function is called by the two RIG cameras.
         * 'this' is the left or right camera (and NOT (!!!) the WebVRFreeCamera instance)
         * @hidden
         */
        _getWebVRViewMatrix(): Matrix;
        /** @hidden */
        _getWebVRProjectionMatrix(): Matrix;
        private _onGamepadConnectedObserver;
        private _onGamepadDisconnectedObserver;
        private _updateCacheWhenTrackingDisabledObserver;
        /**
         * Initializes the controllers and their meshes
         */
        initControllers(): void;
    }
}
declare module BABYLON {
    /**
     * "Static Class" containing the most commonly used helper while dealing with material for rendering purpose.
     *
     * It contains the basic tools to help defining defines, binding uniform for the common part of the materials.
     *
     * This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.
     */
    export class MaterialHelper {
        /**
         * Bind the current view position to an effect.
         * @param effect The effect to be bound
         * @param scene The scene the eyes position is used from
         * @param variableName name of the shader variable that will hold the eye position
         */
        static BindEyePosition(effect: Effect, scene: Scene, variableName?: string): void;
        /**
         * Helps preparing the defines values about the UVs in used in the effect.
         * UVs are shared as much as we can accross channels in the shaders.
         * @param texture The texture we are preparing the UVs for
         * @param defines The defines to update
         * @param key The channel key "diffuse", "specular"... used in the shader
         */
        static PrepareDefinesForMergedUV(texture: BaseTexture, defines: any, key: string): void;
        /**
         * Binds a texture matrix value to its corrsponding uniform
         * @param texture The texture to bind the matrix for
         * @param uniformBuffer The uniform buffer receivin the data
         * @param key The channel key "diffuse", "specular"... used in the shader
         */
        static BindTextureMatrix(texture: BaseTexture, uniformBuffer: UniformBuffer, key: string): void;
        /**
         * Gets the current status of the fog (should it be enabled?)
         * @param mesh defines the mesh to evaluate for fog support
         * @param scene defines the hosting scene
         * @returns true if fog must be enabled
         */
        static GetFogState(mesh: AbstractMesh, scene: Scene): boolean;
        /**
         * Helper used to prepare the list of defines associated with misc. values for shader compilation
         * @param mesh defines the current mesh
         * @param scene defines the current scene
         * @param useLogarithmicDepth defines if logarithmic depth has to be turned on
         * @param pointsCloud defines if point cloud rendering has to be turned on
         * @param fogEnabled defines if fog has to be turned on
         * @param alphaTest defines if alpha testing has to be turned on
         * @param defines defines the current list of defines
         */
        static PrepareDefinesForMisc(mesh: AbstractMesh, scene: Scene, useLogarithmicDepth: boolean, pointsCloud: boolean, fogEnabled: boolean, alphaTest: boolean, defines: any): void;
        /**
         * Helper used to prepare the list of defines associated with frame values for shader compilation
         * @param scene defines the current scene
         * @param engine defines the current engine
         * @param defines specifies the list of active defines
         * @param useInstances defines if instances have to be turned on
         * @param useClipPlane defines if clip plane have to be turned on
         * @param useInstances defines if instances have to be turned on
         * @param useThinInstances defines if thin instances have to be turned on
         */
        static PrepareDefinesForFrameBoundValues(scene: Scene, engine: Engine, defines: any, useInstances: boolean, useClipPlane?: Nullable<boolean>, useThinInstances?: boolean): void;
        /**
         * Prepares the defines for bones
         * @param mesh The mesh containing the geometry data we will draw
         * @param defines The defines to update
         */
        static PrepareDefinesForBones(mesh: AbstractMesh, defines: any): void;
        /**
         * Prepares the defines for morph targets
         * @param mesh The mesh containing the geometry data we will draw
         * @param defines The defines to update
         */
        static PrepareDefinesForMorphTargets(mesh: AbstractMesh, defines: any): void;
        /**
         * Prepares the defines used in the shader depending on the attributes data available in the mesh
         * @param mesh The mesh containing the geometry data we will draw
         * @param defines The defines to update
         * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)
         * @param useBones Precise whether bones should be used or not (override mesh info)
         * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)
         * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)
         * @returns false if defines are considered not dirty and have not been checked
         */
        static PrepareDefinesForAttributes(mesh: AbstractMesh, defines: any, useVertexColor: boolean, useBones: boolean, useMorphTargets?: boolean, useVertexAlpha?: boolean): boolean;
        /**
         * Prepares the defines related to multiview
         * @param scene The scene we are intending to draw
         * @param defines The defines to update
         */
        static PrepareDefinesForMultiview(scene: Scene, defines: any): void;
        /**
         * Prepares the defines related to the prepass
         * @param scene The scene we are intending to draw
         * @param defines The defines to update
         * @param canRenderToMRT Indicates if this material renders to several textures in the prepass
         */
        static PrepareDefinesForPrePass(scene: Scene, defines: any, canRenderToMRT: boolean): void;
        /**
         * Prepares the defines related to the light information passed in parameter
         * @param scene The scene we are intending to draw
         * @param mesh The mesh the effect is compiling for
         * @param light The light the effect is compiling for
         * @param lightIndex The index of the light
         * @param defines The defines to update
         * @param specularSupported Specifies whether specular is supported or not (override lights data)
         * @param state Defines the current state regarding what is needed (normals, etc...)
         */
        static PrepareDefinesForLight(scene: Scene, mesh: AbstractMesh, light: Light, lightIndex: number, defines: any, specularSupported: boolean, state: {
            needNormals: boolean;
            needRebuild: boolean;
            shadowEnabled: boolean;
            specularEnabled: boolean;
            lightmapMode: boolean;
        }): void;
        /**
         * Prepares the defines related to the light information passed in parameter
         * @param scene The scene we are intending to draw
         * @param mesh The mesh the effect is compiling for
         * @param defines The defines to update
         * @param specularSupported Specifies whether specular is supported or not (override lights data)
         * @param maxSimultaneousLights Specfies how manuy lights can be added to the effect at max
         * @param disableLighting Specifies whether the lighting is disabled (override scene and light)
         * @returns true if normals will be required for the rest of the effect
         */
        static PrepareDefinesForLights(scene: Scene, mesh: AbstractMesh, defines: any, specularSupported: boolean, maxSimultaneousLights?: number, disableLighting?: boolean): boolean;
        /**
         * Prepares the uniforms and samplers list to be used in the effect (for a specific light)
         * @param lightIndex defines the light index
         * @param uniformsList The uniform list
         * @param samplersList The sampler list
         * @param projectedLightTexture defines if projected texture must be used
         * @param uniformBuffersList defines an optional list of uniform buffers
         */
        static PrepareUniformsAndSamplersForLight(lightIndex: number, uniformsList: string[], samplersList: string[], projectedLightTexture?: any, uniformBuffersList?: Nullable<string[]>): void;
        /**
         * Prepares the uniforms and samplers list to be used in the effect
         * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the liist and extra information
         * @param samplersList The sampler list
         * @param defines The defines helping in the list generation
         * @param maxSimultaneousLights The maximum number of simultanous light allowed in the effect
         */
        static PrepareUniformsAndSamplersList(uniformsListOrOptions: string[] | IEffectCreationOptions, samplersList?: string[], defines?: any, maxSimultaneousLights?: number): void;
        /**
         * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)
         * @param defines The defines to update while falling back
         * @param fallbacks The authorized effect fallbacks
         * @param maxSimultaneousLights The maximum number of lights allowed
         * @param rank the current rank of the Effect
         * @returns The newly affected rank
         */
        static HandleFallbacksForShadows(defines: any, fallbacks: EffectFallbacks, maxSimultaneousLights?: number, rank?: number): number;
        private static _TmpMorphInfluencers;
        /**
         * Prepares the list of attributes required for morph targets according to the effect defines.
         * @param attribs The current list of supported attribs
         * @param mesh The mesh to prepare the morph targets attributes for
         * @param influencers The number of influencers
         */
        static PrepareAttributesForMorphTargetsInfluencers(attribs: string[], mesh: AbstractMesh, influencers: number): void;
        /**
         * Prepares the list of attributes required for morph targets according to the effect defines.
         * @param attribs The current list of supported attribs
         * @param mesh The mesh to prepare the morph targets attributes for
         * @param defines The current Defines of the effect
         */
        static PrepareAttributesForMorphTargets(attribs: string[], mesh: AbstractMesh, defines: any): void;
        /**
         * Prepares the list of attributes required for bones according to the effect defines.
         * @param attribs The current list of supported attribs
         * @param mesh The mesh to prepare the bones attributes for
         * @param defines The current Defines of the effect
         * @param fallbacks The current efffect fallback strategy
         */
        static PrepareAttributesForBones(attribs: string[], mesh: AbstractMesh, defines: any, fallbacks: EffectFallbacks): void;
        /**
         * Check and prepare the list of attributes required for instances according to the effect defines.
         * @param attribs The current list of supported attribs
         * @param defines The current MaterialDefines of the effect
         */
        static PrepareAttributesForInstances(attribs: string[], defines: MaterialDefines): void;
        /**
         * Add the list of attributes required for instances to the attribs array.
         * @param attribs The current list of supported attribs
         */
        static PushAttributesForInstances(attribs: string[]): void;
        /**
         * Binds the light information to the effect.
         * @param light The light containing the generator
         * @param effect The effect we are binding the data to
         * @param lightIndex The light index in the effect used to render
         */
        static BindLightProperties(light: Light, effect: Effect, lightIndex: number): void;
        /**
         * Binds the lights information from the scene to the effect for the given mesh.
         * @param light Light to bind
         * @param lightIndex Light index
         * @param scene The scene where the light belongs to
         * @param effect The effect we are binding the data to
         * @param useSpecular Defines if specular is supported
         * @param rebuildInParallel Specifies whether the shader is rebuilding in parallel
         */
        static BindLight(light: Light, lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, rebuildInParallel?: boolean): void;
        /**
         * Binds the lights information from the scene to the effect for the given mesh.
         * @param scene The scene the lights belongs to
         * @param mesh The mesh we are binding the information to render
         * @param effect The effect we are binding the data to
         * @param defines The generated defines for the effect
         * @param maxSimultaneousLights The maximum number of light that can be bound to the effect
         * @param rebuildInParallel Specifies whether the shader is rebuilding in parallel
         */
        static BindLights(scene: Scene, mesh: AbstractMesh, effect: Effect, defines: any, maxSimultaneousLights?: number, rebuildInParallel?: boolean): void;
        private static _tempFogColor;
        /**
         * Binds the fog information from the scene to the effect for the given mesh.
         * @param scene The scene the lights belongs to
         * @param mesh The mesh we are binding the information to render
         * @param effect The effect we are binding the data to
         * @param linearSpace Defines if the fog effect is applied in linear space
         */
        static BindFogParameters(scene: Scene, mesh: AbstractMesh, effect: Effect, linearSpace?: boolean): void;
        /**
         * Binds the bones information from the mesh to the effect.
         * @param mesh The mesh we are binding the information to render
         * @param effect The effect we are binding the data to
         */
        static BindBonesParameters(mesh?: AbstractMesh, effect?: Effect): void;
        /**
         * Binds the morph targets information from the mesh to the effect.
         * @param abstractMesh The mesh we are binding the information to render
         * @param effect The effect we are binding the data to
         */
        static BindMorphTargetParameters(abstractMesh: AbstractMesh, effect: Effect): void;
        /**
         * Binds the logarithmic depth information from the scene to the effect for the given defines.
         * @param defines The generated defines used in the effect
         * @param effect The effect we are binding the data to
         * @param scene The scene we are willing to render with logarithmic scale for
         */
        static BindLogDepth(defines: any, effect: Effect, scene: Scene): void;
        /**
         * Binds the clip plane information from the scene to the effect.
         * @param scene The scene the clip plane information are extracted from
         * @param effect The effect we are binding the data to
         */
        static BindClipPlane(effect: Effect, scene: Scene): void;
    }
}
declare module BABYLON {
    /**
     * Block used to expose an input value
     */
    export class InputBlock extends NodeMaterialBlock {
        private _mode;
        private _associatedVariableName;
        private _storedValue;
        private _valueCallback;
        private _type;
        private _animationType;
        /** Gets or set a value used to limit the range of float values */
        min: number;
        /** Gets or set a value used to limit the range of float values */
        max: number;
        /** Gets or set a value indicating that this input can only get 0 and 1 values */
        isBoolean: boolean;
        /** Gets or sets a value used by the Node Material editor to determine how to configure the current value if it is a matrix */
        matrixMode: number;
        /** @hidden */
        _systemValue: Nullable<NodeMaterialSystemValues>;
        /** Gets or sets a boolean indicating that the value of this input will not change after a build */
        isConstant: boolean;
        /** Gets or sets the group to use to display this block in the Inspector */
        groupInInspector: string;
        /** Gets an observable raised when the value is changed */
        onValueChangedObservable: Observable<InputBlock>;
        /**
         * Gets or sets the connection point type (default is float)
         */
        get type(): NodeMaterialBlockConnectionPointTypes;
        /**
         * Creates a new InputBlock
         * @param name defines the block name
         * @param target defines the target of that block (Vertex by default)
         * @param type defines the type of the input (can be set to NodeMaterialBlockConnectionPointTypes.AutoDetect)
         */
        constructor(name: string, target?: NodeMaterialBlockTargets, type?: NodeMaterialBlockConnectionPointTypes);
        /**
        * Validates if a name is a reserve word.
        * @param newName the new name to be given to the node.
        * @returns false if the name is a reserve word, else true.
        */
        validateBlockName(newName: string): boolean;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        /**
         * Set the source of this connection point to a vertex attribute
         * @param attributeName defines the attribute name (position, uv, normal, etc...). If not specified it will take the connection point name
         * @returns the current connection point
         */
        setAsAttribute(attributeName?: string): InputBlock;
        /**
         * Set the source of this connection point to a system value
         * @param value define the system value to use (world, view, etc...) or null to switch to manual value
         * @returns the current connection point
         */
        setAsSystemValue(value: Nullable<NodeMaterialSystemValues>): InputBlock;
        /**
         * Gets or sets the value of that point.
         * Please note that this value will be ignored if valueCallback is defined
         */
        get value(): any;
        set value(value: any);
        /**
         * Gets or sets a callback used to get the value of that point.
         * Please note that setting this value will force the connection point to ignore the value property
         */
        get valueCallback(): () => any;
        set valueCallback(value: () => any);
        /**
         * Gets or sets the associated variable name in the shader
         */
        get associatedVariableName(): string;
        set associatedVariableName(value: string);
        /** Gets or sets the type of animation applied to the input */
        get animationType(): AnimatedInputBlockTypes;
        set animationType(value: AnimatedInputBlockTypes);
        /**
         * Gets a boolean indicating that this connection point not defined yet
         */
        get isUndefined(): boolean;
        /**
         * Gets or sets a boolean indicating that this connection point is coming from an uniform.
         * In this case the connection point name must be the name of the uniform to use.
         * Can only be set on inputs
         */
        get isUniform(): boolean;
        set isUniform(value: boolean);
        /**
         * Gets or sets a boolean indicating that this connection point is coming from an attribute.
         * In this case the connection point name must be the name of the attribute to use
         * Can only be set on inputs
         */
        get isAttribute(): boolean;
        set isAttribute(value: boolean);
        /**
         * Gets or sets a boolean indicating that this connection point is generating a varying variable.
         * Can only be set on exit points
         */
        get isVarying(): boolean;
        set isVarying(value: boolean);
        /**
         * Gets a boolean indicating that the current connection point is a system value
         */
        get isSystemValue(): boolean;
        /**
         * Gets or sets the current well known value or null if not defined as a system value
         */
        get systemValue(): Nullable<NodeMaterialSystemValues>;
        set systemValue(value: Nullable<NodeMaterialSystemValues>);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Animate the input if animationType !== None
         * @param scene defines the rendering scene
         */
        animate(scene: Scene): void;
        private _emitDefine;
        initialize(state: NodeMaterialBuildState): void;
        /**
         * Set the input block to its default value (based on its type)
         */
        setDefaultValue(): void;
        private _emitConstant;
        /** @hidden */
        get _noContextSwitch(): boolean;
        private _emit;
        /** @hidden */
        _transmitWorld(effect: Effect, world: Matrix, worldView: Matrix, worldViewProjection: Matrix): void;
        /** @hidden */
        _transmit(effect: Effect, scene: Scene): void;
        protected _buildBlock(state: NodeMaterialBuildState): void;
        protected _dumpPropertiesCode(): string;
        dispose(): void;
        serialize(): any;
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * Enum used to define the compatibility state between two connection points
     */
    export enum NodeMaterialConnectionPointCompatibilityStates {
        /** Points are compatibles */
        Compatible = 0,
        /** Points are incompatible because of their types */
        TypeIncompatible = 1,
        /** Points are incompatible because of their targets (vertex vs fragment) */
        TargetIncompatible = 2
    }
    /**
     * Defines the direction of a connection point
     */
    export enum NodeMaterialConnectionPointDirection {
        /** Input */
        Input = 0,
        /** Output */
        Output = 1
    }
    /**
     * Defines a connection point for a block
     */
    export class NodeMaterialConnectionPoint {
        /** @hidden */
        _ownerBlock: NodeMaterialBlock;
        /** @hidden */
        _connectedPoint: Nullable<NodeMaterialConnectionPoint>;
        private _endpoints;
        private _associatedVariableName;
        private _direction;
        /** @hidden */
        _typeConnectionSource: Nullable<NodeMaterialConnectionPoint>;
        /** @hidden */
        _linkedConnectionSource: Nullable<NodeMaterialConnectionPoint>;
        private _type;
        /** @hidden */
        _enforceAssociatedVariableName: boolean;
        /** Gets the direction of the point */
        get direction(): NodeMaterialConnectionPointDirection;
        /** Indicates that this connection point needs dual validation before being connected to another point */
        needDualDirectionValidation: boolean;
        /**
         * Gets or sets the additional types supported by this connection point
         */
        acceptedConnectionPointTypes: NodeMaterialBlockConnectionPointTypes[];
        /**
         * Gets or sets the additional types excluded by this connection point
         */
        excludedConnectionPointTypes: NodeMaterialBlockConnectionPointTypes[];
        /**
         * Observable triggered when this point is connected
         */
        onConnectionObservable: Observable<NodeMaterialConnectionPoint>;
        /**
         * Gets or sets the associated variable name in the shader
         */
        get associatedVariableName(): string;
        set associatedVariableName(value: string);
        /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */
        get innerType(): NodeMaterialBlockConnectionPointTypes;
        /**
         * Gets or sets the connection point type (default is float)
         */
        get type(): NodeMaterialBlockConnectionPointTypes;
        set type(value: NodeMaterialBlockConnectionPointTypes);
        /**
         * Gets or sets the connection point name
         */
        name: string;
        /**
         * Gets or sets the connection point name
         */
        displayName: string;
        /**
         * Gets or sets a boolean indicating that this connection point can be omitted
         */
        isOptional: boolean;
        /**
         * Gets or sets a boolean indicating that this connection point is exposed on a frame
         */
        isExposedOnFrame: boolean;
        /**
         * Gets or sets a string indicating that this uniform must be defined under a #ifdef
         */
        define: string;
        /** @hidden */
        _prioritizeVertex: boolean;
        private _target;
        /** Gets or sets the target of that connection point */
        get target(): NodeMaterialBlockTargets;
        set target(value: NodeMaterialBlockTargets);
        /**
         * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock
         */
        get isConnected(): boolean;
        /**
         * Gets a boolean indicating that the current point is connected to an input block
         */
        get isConnectedToInputBlock(): boolean;
        /**
         * Gets a the connected input block (if any)
         */
        get connectInputBlock(): Nullable<InputBlock>;
        /** Get the other side of the connection (if any) */
        get connectedPoint(): Nullable<NodeMaterialConnectionPoint>;
        /** Get the block that owns this connection point */
        get ownerBlock(): NodeMaterialBlock;
        /** Get the block connected on the other side of this connection (if any) */
        get sourceBlock(): Nullable<NodeMaterialBlock>;
        /** Get the block connected on the endpoints of this connection (if any) */
        get connectedBlocks(): Array<NodeMaterialBlock>;
        /** Gets the list of connected endpoints */
        get endpoints(): NodeMaterialConnectionPoint[];
        /** Gets a boolean indicating if that output point is connected to at least one input */
        get hasEndpoints(): boolean;
        /** Gets a boolean indicating that this connection will be used in the vertex shader */
        get isConnectedInVertexShader(): boolean;
        /** Gets a boolean indicating that this connection will be used in the fragment shader */
        get isConnectedInFragmentShader(): boolean;
        /**
         * Creates a block suitable to be used as an input for this input point.
         * If null is returned, a block based on the point type will be created.
         * @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input
         */
        createCustomInputBlock(): Nullable<[NodeMaterialBlock, string]>;
        /**
         * Creates a new connection point
         * @param name defines the connection point name
         * @param ownerBlock defines the block hosting this connection point
         * @param direction defines the direction of the connection point
         */
        constructor(name: string, ownerBlock: NodeMaterialBlock, direction: NodeMaterialConnectionPointDirection);
        /**
         * Gets the current class name e.g. "NodeMaterialConnectionPoint"
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets a boolean indicating if the current point can be connected to another point
         * @param connectionPoint defines the other connection point
         * @returns a boolean
         */
        canConnectTo(connectionPoint: NodeMaterialConnectionPoint): boolean;
        /**
         * Gets a number indicating if the current point can be connected to another point
         * @param connectionPoint defines the other connection point
         * @returns a number defining the compatibility state
         */
        checkCompatibilityState(connectionPoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPointCompatibilityStates;
        /**
         * Connect this point to another connection point
         * @param connectionPoint defines the other connection point
         * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)
         * @returns the current connection point
         */
        connectTo(connectionPoint: NodeMaterialConnectionPoint, ignoreConstraints?: boolean): NodeMaterialConnectionPoint;
        /**
         * Disconnect this point from one of his endpoint
         * @param endpoint defines the other connection point
         * @returns the current connection point
         */
        disconnectFrom(endpoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPoint;
        /**
         * Serializes this point in a JSON representation
         * @param isInput defines if the connection point is an input (default is true)
         * @returns the serialized point object
         */
        serialize(isInput?: boolean): any;
        /**
         * Release resources
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * Enum used to define the material modes
     */
    export enum NodeMaterialModes {
        /** Regular material */
        Material = 0,
        /** For post process */
        PostProcess = 1,
        /** For particle system */
        Particle = 2,
        /** For procedural texture */
        ProceduralTexture = 3
    }
}
declare module BABYLON {
    /**
     * Block used to read a texture from a sampler
     */
    export class TextureBlock extends NodeMaterialBlock {
        private _defineName;
        private _linearDefineName;
        private _gammaDefineName;
        private _tempTextureRead;
        private _samplerName;
        private _transformedUVName;
        private _textureTransformName;
        private _textureInfoName;
        private _mainUVName;
        private _mainUVDefineName;
        private _fragmentOnly;
        /**
         * Gets or sets the texture associated with the node
         */
        texture: Nullable<Texture>;
        /**
         * Gets or sets a boolean indicating if content needs to be converted to gamma space
         */
        convertToGammaSpace: boolean;
        /**
         * Gets or sets a boolean indicating if content needs to be converted to linear space
         */
        convertToLinearSpace: boolean;
        /**
         * Create a new TextureBlock
         * @param name defines the block name
         */
        constructor(name: string, fragmentOnly?: boolean);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the uv input component
         */
        get uv(): NodeMaterialConnectionPoint;
        /**
         * Gets the rgba output component
         */
        get rgba(): NodeMaterialConnectionPoint;
        /**
         * Gets the rgb output component
         */
        get rgb(): NodeMaterialConnectionPoint;
        /**
         * Gets the r output component
         */
        get r(): NodeMaterialConnectionPoint;
        /**
         * Gets the g output component
         */
        get g(): NodeMaterialConnectionPoint;
        /**
         * Gets the b output component
         */
        get b(): NodeMaterialConnectionPoint;
        /**
         * Gets the a output component
         */
        get a(): NodeMaterialConnectionPoint;
        get target(): NodeMaterialBlockTargets;
        autoConfigure(material: NodeMaterial): void;
        initializeDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances?: boolean): void;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
        isReady(): boolean;
        bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh): void;
        private get _isMixed();
        private _injectVertexCode;
        private _writeTextureRead;
        private _writeOutput;
        protected _buildBlock(state: NodeMaterialBuildState): this | undefined;
        protected _dumpPropertiesCode(): string;
        serialize(): any;
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /** @hidden */
    export var reflectionFunction: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Base block used to read a reflection texture from a sampler
     */
    export abstract class ReflectionTextureBaseBlock extends NodeMaterialBlock {
        /** @hidden */
        _define3DName: string;
        /** @hidden */
        _defineCubicName: string;
        /** @hidden */
        _defineExplicitName: string;
        /** @hidden */
        _defineProjectionName: string;
        /** @hidden */
        _defineLocalCubicName: string;
        /** @hidden */
        _defineSphericalName: string;
        /** @hidden */
        _definePlanarName: string;
        /** @hidden */
        _defineEquirectangularName: string;
        /** @hidden */
        _defineMirroredEquirectangularFixedName: string;
        /** @hidden */
        _defineEquirectangularFixedName: string;
        /** @hidden */
        _defineSkyboxName: string;
        /** @hidden */
        _defineOppositeZ: string;
        /** @hidden */
        _cubeSamplerName: string;
        /** @hidden */
        _2DSamplerName: string;
        protected _positionUVWName: string;
        protected _directionWName: string;
        protected _reflectionVectorName: string;
        /** @hidden */
        _reflectionCoordsName: string;
        /** @hidden */
        _reflectionMatrixName: string;
        protected _reflectionColorName: string;
        /**
         * Gets or sets the texture associated with the node
         */
        texture: Nullable<BaseTexture>;
        /**
         * Create a new ReflectionTextureBaseBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the world position input component
         */
        abstract get position(): NodeMaterialConnectionPoint;
        /**
         * Gets the world position input component
         */
        abstract get worldPosition(): NodeMaterialConnectionPoint;
        /**
         * Gets the world normal input component
         */
        abstract get worldNormal(): NodeMaterialConnectionPoint;
        /**
         * Gets the world input component
         */
        abstract get world(): NodeMaterialConnectionPoint;
        /**
        * Gets the camera (or eye) position component
        */
        abstract get cameraPosition(): NodeMaterialConnectionPoint;
        /**
         * Gets the view input component
         */
        abstract get view(): NodeMaterialConnectionPoint;
        protected _getTexture(): Nullable<BaseTexture>;
        autoConfigure(material: NodeMaterial): void;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
        isReady(): boolean;
        bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh): void;
        /**
         * Gets the code to inject in the vertex shader
         * @param state current state of the node material building
         * @returns the shader code
         */
        handleVertexSide(state: NodeMaterialBuildState): string;
        /**
         * Handles the inits for the fragment code path
         * @param state node material build state
         */
        handleFragmentSideInits(state: NodeMaterialBuildState): void;
        /**
         * Generates the reflection coords code for the fragment code path
         * @param worldNormalVarName name of the world normal variable
         * @param worldPos name of the world position variable. If not provided, will use the world position connected to this block
         * @param onlyReflectionVector if true, generates code only for the reflection vector computation, not for the reflection coordinates
         * @returns the shader code
         */
        handleFragmentSideCodeReflectionCoords(worldNormalVarName: string, worldPos?: string, onlyReflectionVector?: boolean): string;
        /**
         * Generates the reflection color code for the fragment code path
         * @param lodVarName name of the lod variable
         * @param swizzleLookupTexture swizzle to use for the final color variable
         * @returns the shader code
         */
        handleFragmentSideCodeReflectionColor(lodVarName?: string, swizzleLookupTexture?: string): string;
        /**
         * Generates the code corresponding to the connected output points
         * @param state node material build state
         * @param varName name of the variable to output
         * @returns the shader code
         */
        writeOutputs(state: NodeMaterialBuildState, varName: string): string;
        protected _buildBlock(state: NodeMaterialBuildState): this;
        protected _dumpPropertiesCode(): string;
        serialize(): any;
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * Defines a connection point to be used for points with a custom object type
     */
    export class NodeMaterialConnectionPointCustomObject<T extends NodeMaterialBlock> extends NodeMaterialConnectionPoint {
        private _blockType;
        private _blockName;
        private _nameForCheking?;
        /**
         * Creates a new connection point
         * @param name defines the connection point name
         * @param ownerBlock defines the block hosting this connection point
         * @param direction defines the direction of the connection point
         */
        constructor(name: string, ownerBlock: NodeMaterialBlock, direction: NodeMaterialConnectionPointDirection, _blockType: new (...args: any[]) => T, _blockName: string, _nameForCheking?: string | undefined);
        /**
         * Gets a number indicating if the current point can be connected to another point
         * @param connectionPoint defines the other connection point
         * @returns a number defining the compatibility state
         */
        checkCompatibilityState(connectionPoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPointCompatibilityStates;
        /**
         * Creates a block suitable to be used as an input for this input point.
         * If null is returned, a block based on the point type will be created.
         * @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input
         */
        createCustomInputBlock(): Nullable<[NodeMaterialBlock, string]>;
    }
}
declare module BABYLON {
    /**
     * Enum defining the type of properties that can be edited in the property pages in the NME
     */
    export enum PropertyTypeForEdition {
        /** property is a boolean */
        Boolean = 0,
        /** property is a float */
        Float = 1,
        /** property is a Vector2 */
        Vector2 = 2,
        /** property is a list of values */
        List = 3
    }
    /**
     * Interface that defines an option in a variable of type list
     */
    export interface IEditablePropertyListOption {
        /** label of the option */
        "label": string;
        /** value of the option */
        "value": number;
    }
    /**
     * Interface that defines the options available for an editable property
     */
    export interface IEditablePropertyOption {
        /** min value */
        "min"?: number;
        /** max value */
        "max"?: number;
        /** notifiers: indicates which actions to take when the property is changed */
        "notifiers"?: {
            /** the material should be rebuilt */
            "rebuild"?: boolean;
            /** the preview should be updated */
            "update"?: boolean;
        };
        /** list of the options for a variable of type list */
        "options"?: IEditablePropertyListOption[];
    }
    /**
     * Interface that describes an editable property
     */
    export interface IPropertyDescriptionForEdition {
        /** name of the property */
        "propertyName": string;
        /** display name of the property */
        "displayName": string;
        /** type of the property */
        "type": PropertyTypeForEdition;
        /** group of the property - all properties with the same group value will be displayed in a specific section */
        "groupName": string;
        /** options for the property */
        "options": IEditablePropertyOption;
    }
    /**
     * Decorator that flags a property in a node material block as being editable
     */
    export function editableInPropertyPage(displayName: string, propertyType?: PropertyTypeForEdition, groupName?: string, options?: IEditablePropertyOption): (target: any, propertyKey: string) => void;
}
declare module BABYLON {
    /**
     * Block used to implement the refraction part of the sub surface module of the PBR material
     */
    export class RefractionBlock extends NodeMaterialBlock {
        /** @hidden */
        _define3DName: string;
        /** @hidden */
        _refractionMatrixName: string;
        /** @hidden */
        _defineLODRefractionAlpha: string;
        /** @hidden */
        _defineLinearSpecularRefraction: string;
        /** @hidden */
        _defineOppositeZ: string;
        /** @hidden */
        _cubeSamplerName: string;
        /** @hidden */
        _2DSamplerName: string;
        /** @hidden */
        _vRefractionMicrosurfaceInfosName: string;
        /** @hidden */
        _vRefractionInfosName: string;
        private _scene;
        /**
         * This parameters will make the material used its opacity to control how much it is refracting aginst not.
         * Materials half opaque for instance using refraction could benefit from this control.
         */
        linkRefractionWithTransparency: boolean;
        /**
         * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.
         */
        invertRefractionY: boolean;
        /**
         * Gets or sets the texture associated with the node
         */
        texture: Nullable<BaseTexture>;
        /**
         * Create a new RefractionBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the intensity input component
         */
        get intensity(): NodeMaterialConnectionPoint;
        /**
         * Gets the index of refraction input component
         */
        get indexOfRefraction(): NodeMaterialConnectionPoint;
        /**
         * Gets the tint at distance input component
         */
        get tintAtDistance(): NodeMaterialConnectionPoint;
        /**
         * Gets the view input component
         */
        get view(): NodeMaterialConnectionPoint;
        /**
         * Gets the refraction object output component
         */
        get refraction(): NodeMaterialConnectionPoint;
        /**
         * Returns true if the block has a texture
         */
        get hasTexture(): boolean;
        protected _getTexture(): Nullable<BaseTexture>;
        autoConfigure(material: NodeMaterial): void;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
        isReady(): boolean;
        bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh, subMesh?: SubMesh): void;
        /**
         * Gets the main code of the block (fragment side)
         * @param state current state of the node material building
         * @returns the shader code
         */
        getCode(state: NodeMaterialBuildState): string;
        protected _buildBlock(state: NodeMaterialBuildState): this;
        protected _dumpPropertiesCode(): string;
        serialize(): any;
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * Base block used as input for post process
     */
    export class CurrentScreenBlock extends NodeMaterialBlock {
        private _samplerName;
        private _linearDefineName;
        private _gammaDefineName;
        private _mainUVName;
        private _tempTextureRead;
        /**
         * Gets or sets the texture associated with the node
         */
        texture: Nullable<BaseTexture>;
        /**
         * Gets or sets a boolean indicating if content needs to be converted to gamma space
         */
        convertToGammaSpace: boolean;
        /**
         * Gets or sets a boolean indicating if content needs to be converted to linear space
         */
        convertToLinearSpace: boolean;
        /**
         * Create a new CurrentScreenBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the uv input component
         */
        get uv(): NodeMaterialConnectionPoint;
        /**
         * Gets the rgba output component
         */
        get rgba(): NodeMaterialConnectionPoint;
        /**
         * Gets the rgb output component
         */
        get rgb(): NodeMaterialConnectionPoint;
        /**
         * Gets the r output component
         */
        get r(): NodeMaterialConnectionPoint;
        /**
         * Gets the g output component
         */
        get g(): NodeMaterialConnectionPoint;
        /**
         * Gets the b output component
         */
        get b(): NodeMaterialConnectionPoint;
        /**
         * Gets the a output component
         */
        get a(): NodeMaterialConnectionPoint;
        /**
         * Initialize the block and prepare the context for build
         * @param state defines the state that will be used for the build
         */
        initialize(state: NodeMaterialBuildState): void;
        get target(): NodeMaterialBlockTargets;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
        isReady(): boolean;
        private _injectVertexCode;
        private _writeTextureRead;
        private _writeOutput;
        protected _buildBlock(state: NodeMaterialBuildState): this | undefined;
        serialize(): any;
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * Base block used for the particle texture
     */
    export class ParticleTextureBlock extends NodeMaterialBlock {
        private _samplerName;
        private _linearDefineName;
        private _gammaDefineName;
        private _tempTextureRead;
        /**
         * Gets or sets the texture associated with the node
         */
        texture: Nullable<BaseTexture>;
        /**
         * Gets or sets a boolean indicating if content needs to be converted to gamma space
         */
        convertToGammaSpace: boolean;
        /**
         * Gets or sets a boolean indicating if content needs to be converted to linear space
         */
        convertToLinearSpace: boolean;
        /**
         * Create a new ParticleTextureBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the uv input component
         */
        get uv(): NodeMaterialConnectionPoint;
        /**
         * Gets the rgba output component
         */
        get rgba(): NodeMaterialConnectionPoint;
        /**
         * Gets the rgb output component
         */
        get rgb(): NodeMaterialConnectionPoint;
        /**
         * Gets the r output component
         */
        get r(): NodeMaterialConnectionPoint;
        /**
         * Gets the g output component
         */
        get g(): NodeMaterialConnectionPoint;
        /**
         * Gets the b output component
         */
        get b(): NodeMaterialConnectionPoint;
        /**
         * Gets the a output component
         */
        get a(): NodeMaterialConnectionPoint;
        /**
         * Initialize the block and prepare the context for build
         * @param state defines the state that will be used for the build
         */
        initialize(state: NodeMaterialBuildState): void;
        autoConfigure(material: NodeMaterial): void;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
        isReady(): boolean;
        private _writeOutput;
        protected _buildBlock(state: NodeMaterialBuildState): this | undefined;
        serialize(): any;
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * Class used to store shared data between 2 NodeMaterialBuildState
     */
    export class NodeMaterialBuildStateSharedData {
        /**
        * Gets the list of emitted varyings
        */
        temps: string[];
        /**
         * Gets the list of emitted varyings
         */
        varyings: string[];
        /**
         * Gets the varying declaration string
         */
        varyingDeclaration: string;
        /**
         * Input blocks
         */
        inputBlocks: InputBlock[];
        /**
         * Input blocks
         */
        textureBlocks: (TextureBlock | ReflectionTextureBaseBlock | RefractionBlock | CurrentScreenBlock | ParticleTextureBlock)[];
        /**
         * Bindable blocks (Blocks that need to set data to the effect)
         */
        bindableBlocks: NodeMaterialBlock[];
        /**
         * List of blocks that can provide a compilation fallback
         */
        blocksWithFallbacks: NodeMaterialBlock[];
        /**
         * List of blocks that can provide a define update
         */
        blocksWithDefines: NodeMaterialBlock[];
        /**
        * List of blocks that can provide a repeatable content
        */
        repeatableContentBlocks: NodeMaterialBlock[];
        /**
        * List of blocks that can provide a dynamic list of uniforms
        */
        dynamicUniformBlocks: NodeMaterialBlock[];
        /**
         * List of blocks that can block the isReady function for the material
         */
        blockingBlocks: NodeMaterialBlock[];
        /**
         * Gets the list of animated inputs
         */
        animatedInputs: InputBlock[];
        /**
         * Build Id used to avoid multiple recompilations
         */
        buildId: number;
        /** List of emitted variables */
        variableNames: {
            [key: string]: number;
        };
        /** List of emitted defines */
        defineNames: {
            [key: string]: number;
        };
        /** Should emit comments? */
        emitComments: boolean;
        /** Emit build activity */
        verbose: boolean;
        /** Gets or sets the hosting scene */
        scene: Scene;
        /**
         * Gets the compilation hints emitted at compilation time
         */
        hints: {
            needWorldViewMatrix: boolean;
            needWorldViewProjectionMatrix: boolean;
            needAlphaBlending: boolean;
            needAlphaTesting: boolean;
        };
        /**
         * List of compilation checks
         */
        checks: {
            emitVertex: boolean;
            emitFragment: boolean;
            notConnectedNonOptionalInputs: NodeMaterialConnectionPoint[];
        };
        /**
         * Is vertex program allowed to be empty?
         */
        allowEmptyVertexProgram: boolean;
        /** Creates a new shared data */
        constructor();
        /**
         * Emits console errors and exceptions if there is a failing check
         */
        emitErrors(): void;
    }
}
declare module BABYLON {
    /**
     * Class used to store node based material build state
     */
    export class NodeMaterialBuildState {
        /** Gets or sets a boolean indicating if the current state can emit uniform buffers */
        supportUniformBuffers: boolean;
        /**
         * Gets the list of emitted attributes
         */
        attributes: string[];
        /**
         * Gets the list of emitted uniforms
         */
        uniforms: string[];
        /**
        * Gets the list of emitted constants
        */
        constants: string[];
        /**
         * Gets the list of emitted samplers
         */
        samplers: string[];
        /**
         * Gets the list of emitted functions
         */
        functions: {
            [key: string]: string;
        };
        /**
         * Gets the list of emitted extensions
         */
        extensions: {
            [key: string]: string;
        };
        /**
         * Gets the target of the compilation state
         */
        target: NodeMaterialBlockTargets;
        /**
         * Gets the list of emitted counters
         */
        counters: {
            [key: string]: number;
        };
        /**
         * Shared data between multiple NodeMaterialBuildState instances
         */
        sharedData: NodeMaterialBuildStateSharedData;
        /** @hidden */
        _vertexState: NodeMaterialBuildState;
        /** @hidden */
        _attributeDeclaration: string;
        /** @hidden */
        _uniformDeclaration: string;
        /** @hidden */
        _constantDeclaration: string;
        /** @hidden */
        _samplerDeclaration: string;
        /** @hidden */
        _varyingTransfer: string;
        /** @hidden */
        _injectAtEnd: string;
        private _repeatableContentAnchorIndex;
        /** @hidden */
        _builtCompilationString: string;
        /**
         * Gets the emitted compilation strings
         */
        compilationString: string;
        /**
         * Finalize the compilation strings
         * @param state defines the current compilation state
         */
        finalize(state: NodeMaterialBuildState): void;
        /** @hidden */
        get _repeatableContentAnchor(): string;
        /** @hidden */
        _getFreeVariableName(prefix: string): string;
        /** @hidden */
        _getFreeDefineName(prefix: string): string;
        /** @hidden */
        _excludeVariableName(name: string): void;
        /** @hidden */
        _emit2DSampler(name: string): void;
        /** @hidden */
        _getGLType(type: NodeMaterialBlockConnectionPointTypes): string;
        /** @hidden */
        _emitExtension(name: string, extension: string, define?: string): void;
        /** @hidden */
        _emitFunction(name: string, code: string, comments: string): void;
        /** @hidden */
        _emitCodeFromInclude(includeName: string, comments: string, options?: {
            replaceStrings?: {
                search: RegExp;
                replace: string;
            }[];
            repeatKey?: string;
        }): string;
        /** @hidden */
        _emitFunctionFromInclude(includeName: string, comments: string, options?: {
            repeatKey?: string;
            removeAttributes?: boolean;
            removeUniforms?: boolean;
            removeVaryings?: boolean;
            removeIfDef?: boolean;
            replaceStrings?: {
                search: RegExp;
                replace: string;
            }[];
        }, storeKey?: string): void;
        /** @hidden */
        _registerTempVariable(name: string): boolean;
        /** @hidden */
        _emitVaryingFromString(name: string, type: string, define?: string, notDefine?: boolean): boolean;
        /** @hidden */
        _emitUniformFromString(name: string, type: string, define?: string, notDefine?: boolean): void;
        /** @hidden */
        _emitFloat(value: number): string;
    }
}
declare module BABYLON {
    /**
     * Helper class used to generate session unique ID
     */
    export class UniqueIdGenerator {
        private static _UniqueIdCounter;
        /**
         * Gets an unique (relatively to the current scene) Id
         */
        static get UniqueId(): number;
    }
}
declare module BABYLON {
    /**
     * Defines a block that can be used inside a node based material
     */
    export class NodeMaterialBlock {
        private _buildId;
        private _buildTarget;
        private _target;
        private _isFinalMerger;
        private _isInput;
        private _name;
        protected _isUnique: boolean;
        /** Gets or sets a boolean indicating that only one input can be connected at a time */
        inputsAreExclusive: boolean;
        /** @hidden */
        _codeVariableName: string;
        /** @hidden */
        _inputs: NodeMaterialConnectionPoint[];
        /** @hidden */
        _outputs: NodeMaterialConnectionPoint[];
        /** @hidden */
        _preparationId: number;
        /**
         * Gets the name of the block
         */
        get name(): string;
        /**
         * Sets the name of the block. Will check if the name is valid.
         */
        set name(newName: string);
        /**
         * Gets or sets the unique id of the node
         */
        uniqueId: number;
        /**
         * Gets or sets the comments associated with this block
         */
        comments: string;
        /**
         * Gets a boolean indicating that this block can only be used once per NodeMaterial
         */
        get isUnique(): boolean;
        /**
         * Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)
         */
        get isFinalMerger(): boolean;
        /**
         * Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)
         */
        get isInput(): boolean;
        /**
         * Gets or sets the build Id
         */
        get buildId(): number;
        set buildId(value: number);
        /**
         * Gets or sets the target of the block
         */
        get target(): NodeMaterialBlockTargets;
        set target(value: NodeMaterialBlockTargets);
        /**
         * Gets the list of input points
         */
        get inputs(): NodeMaterialConnectionPoint[];
        /** Gets the list of output points */
        get outputs(): NodeMaterialConnectionPoint[];
        /**
         * Find an input by its name
         * @param name defines the name of the input to look for
         * @returns the input or null if not found
         */
        getInputByName(name: string): Nullable<NodeMaterialConnectionPoint>;
        /**
         * Find an output by its name
         * @param name defines the name of the outputto look for
         * @returns the output or null if not found
         */
        getOutputByName(name: string): Nullable<NodeMaterialConnectionPoint>;
        /** Gets or sets a boolean indicating that this input can be edited in the Inspector (false by default) */
        visibleInInspector: boolean;
        /**
         * Creates a new NodeMaterialBlock
         * @param name defines the block name
         * @param target defines the target of that block (Vertex by default)
         * @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false
         * @param isInput defines a boolean indicating that this block is an input (e.g. it sends data to the shader). Default is false
         */
        constructor(name: string, target?: NodeMaterialBlockTargets, isFinalMerger?: boolean, isInput?: boolean);
        /**
         * Initialize the block and prepare the context for build
         * @param state defines the state that will be used for the build
         */
        initialize(state: NodeMaterialBuildState): void;
        /**
         * Bind data to effect. Will only be called for blocks with isBindable === true
         * @param effect defines the effect to bind data to
         * @param nodeMaterial defines the hosting NodeMaterial
         * @param mesh defines the mesh that will be rendered
         * @param subMesh defines the submesh that will be rendered
         */
        bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh, subMesh?: SubMesh): void;
        protected _declareOutput(output: NodeMaterialConnectionPoint, state: NodeMaterialBuildState): string;
        protected _writeVariable(currentPoint: NodeMaterialConnectionPoint): string;
        protected _writeFloat(value: number): string;
        /**
         * Gets the current class name e.g. "NodeMaterialBlock"
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Register a new input. Must be called inside a block constructor
         * @param name defines the connection point name
         * @param type defines the connection point type
         * @param isOptional defines a boolean indicating that this input can be omitted
         * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)
         * @param point an already created connection point. If not provided, create a new one
         * @returns the current block
         */
        registerInput(name: string, type: NodeMaterialBlockConnectionPointTypes, isOptional?: boolean, target?: NodeMaterialBlockTargets, point?: NodeMaterialConnectionPoint): this;
        /**
         * Register a new output. Must be called inside a block constructor
         * @param name defines the connection point name
         * @param type defines the connection point type
         * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)
         * @param point an already created connection point. If not provided, create a new one
         * @returns the current block
         */
        registerOutput(name: string, type: NodeMaterialBlockConnectionPointTypes, target?: NodeMaterialBlockTargets, point?: NodeMaterialConnectionPoint): this;
        /**
         * Will return the first available input e.g. the first one which is not an uniform or an attribute
         * @param forOutput defines an optional connection point to check compatibility with
         * @returns the first available input or null
         */
        getFirstAvailableInput(forOutput?: Nullable<NodeMaterialConnectionPoint>): Nullable<NodeMaterialConnectionPoint>;
        /**
         * Will return the first available output e.g. the first one which is not yet connected and not a varying
         * @param forBlock defines an optional block to check compatibility with
         * @returns the first available input or null
         */
        getFirstAvailableOutput(forBlock?: Nullable<NodeMaterialBlock>): Nullable<NodeMaterialConnectionPoint>;
        /**
         * Gets the sibling of the given output
         * @param current defines the current output
         * @returns the next output in the list or null
         */
        getSiblingOutput(current: NodeMaterialConnectionPoint): Nullable<NodeMaterialConnectionPoint>;
        /**
         * Connect current block with another block
         * @param other defines the block to connect with
         * @param options define the various options to help pick the right connections
         * @returns the current block
         */
        connectTo(other: NodeMaterialBlock, options?: {
            input?: string;
            output?: string;
            outputSwizzle?: string;
        }): this | undefined;
        protected _buildBlock(state: NodeMaterialBuildState): void;
        /**
         * Add uniforms, samplers and uniform buffers at compilation time
         * @param state defines the state to update
         * @param nodeMaterial defines the node material requesting the update
         * @param defines defines the material defines to update
         * @param uniformBuffers defines the list of uniform buffer names
         */
        updateUniformsAndSamples(state: NodeMaterialBuildState, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, uniformBuffers: string[]): void;
        /**
         * Add potential fallbacks if shader compilation fails
         * @param mesh defines the mesh to be rendered
         * @param fallbacks defines the current prioritized list of fallbacks
         */
        provideFallbacks(mesh: AbstractMesh, fallbacks: EffectFallbacks): void;
        /**
         * Initialize defines for shader compilation
         * @param mesh defines the mesh to be rendered
         * @param nodeMaterial defines the node material requesting the update
         * @param defines defines the material defines to update
         * @param useInstances specifies that instances should be used
         */
        initializeDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances?: boolean): void;
        /**
         * Update defines for shader compilation
         * @param mesh defines the mesh to be rendered
         * @param nodeMaterial defines the node material requesting the update
         * @param defines defines the material defines to update
         * @param useInstances specifies that instances should be used
         * @param subMesh defines which submesh to render
         */
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances?: boolean, subMesh?: SubMesh): void;
        /**
         * Lets the block try to connect some inputs automatically
         * @param material defines the hosting NodeMaterial
         */
        autoConfigure(material: NodeMaterial): void;
        /**
         * Function called when a block is declared as repeatable content generator
         * @param vertexShaderState defines the current compilation state for the vertex shader
         * @param fragmentShaderState defines the current compilation state for the fragment shader
         * @param mesh defines the mesh to be rendered
         * @param defines defines the material defines to update
         */
        replaceRepeatableContent(vertexShaderState: NodeMaterialBuildState, fragmentShaderState: NodeMaterialBuildState, mesh: AbstractMesh, defines: NodeMaterialDefines): void;
        /**
         * Checks if the block is ready
         * @param mesh defines the mesh to be rendered
         * @param nodeMaterial defines the node material requesting the update
         * @param defines defines the material defines to update
         * @param useInstances specifies that instances should be used
         * @returns true if the block is ready
         */
        isReady(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances?: boolean): boolean;
        protected _linkConnectionTypes(inputIndex0: number, inputIndex1: number): void;
        private _processBuild;
        /**
        * Validates the new name for the block node.
        * @param newName the new name to be given to the node.
        * @returns false if the name is a reserve word, else true.
        */
        validateBlockName(newName: string): boolean;
        /**
         * Compile the current node and generate the shader code
         * @param state defines the current compilation state (uniforms, samplers, current string)
         * @param activeBlocks defines the list of active blocks (i.e. blocks to compile)
         * @returns true if already built
         */
        build(state: NodeMaterialBuildState, activeBlocks: NodeMaterialBlock[]): boolean;
        protected _inputRename(name: string): string;
        protected _outputRename(name: string): string;
        protected _dumpPropertiesCode(): string;
        /** @hidden */
        _dumpCode(uniqueNames: string[], alreadyDumped: NodeMaterialBlock[]): string;
        /** @hidden */
        _dumpCodeForOutputConnections(alreadyDumped: NodeMaterialBlock[]): string;
        /**
         * Clone the current block to a new identical block
         * @param scene defines the hosting scene
         * @param rootUrl defines the root URL to use to load textures and relative dependencies
         * @returns a copy of the current block
         */
        clone(scene: Scene, rootUrl?: string): Nullable<NodeMaterialBlock>;
        /**
         * Serializes this block in a JSON representation
         * @returns the serialized block object
         */
        serialize(): any;
        /** @hidden */
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
        private _deserializePortDisplayNamesAndExposedOnFrame;
        /**
         * Release resources
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * Base class of materials working in push mode in babylon JS
     * @hidden
     */
    export class PushMaterial extends Material {
        protected _activeEffect: Effect;
        protected _normalMatrix: Matrix;
        constructor(name: string, scene: Scene);
        getEffect(): Effect;
        isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean;
        protected _isReadyForSubMesh(subMesh: SubMesh): boolean;
        /**
        * Binds the given world matrix to the active effect
        *
        * @param world the matrix to bind
        */
        bindOnlyWorldMatrix(world: Matrix): void;
        /**
         * Binds the given normal matrix to the active effect
         *
         * @param normalMatrix the matrix to bind
         */
        bindOnlyNormalMatrix(normalMatrix: Matrix): void;
        bind(world: Matrix, mesh?: Mesh): void;
        protected _afterBind(mesh: Mesh, effect?: Nullable<Effect>): void;
        protected _mustRebind(scene: Scene, effect: Effect, visibility?: number): boolean;
    }
}
declare module BABYLON {
    /**
     * Root class for all node material optimizers
     */
    export class NodeMaterialOptimizer {
        /**
         * Function used to optimize a NodeMaterial graph
         * @param vertexOutputNodes defines the list of output nodes for the vertex shader
         * @param fragmentOutputNodes defines the list of output nodes for the fragment shader
         */
        optimize(vertexOutputNodes: NodeMaterialBlock[], fragmentOutputNodes: NodeMaterialBlock[]): void;
    }
}
declare module BABYLON {
    /**
     * Block used to transform a vector (2, 3 or 4) with a matrix. It will generate a Vector4
     */
    export class TransformBlock extends NodeMaterialBlock {
        /**
         * Defines the value to use to complement W value to transform it to a Vector4
         */
        complementW: number;
        /**
         * Defines the value to use to complement z value to transform it to a Vector4
         */
        complementZ: number;
        /**
         * Creates a new TransformBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the vector input
         */
        get vector(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        /**
         * Gets the xyz output component
         */
        get xyz(): NodeMaterialConnectionPoint;
        /**
         * Gets the matrix transform input
         */
        get transform(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
        /**
         * Update defines for shader compilation
         * @param mesh defines the mesh to be rendered
         * @param nodeMaterial defines the node material requesting the update
         * @param defines defines the material defines to update
         * @param useInstances specifies that instances should be used
         * @param subMesh defines which submesh to render
         */
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances?: boolean, subMesh?: SubMesh): void;
        serialize(): any;
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
        protected _dumpPropertiesCode(): string;
    }
}
declare module BABYLON {
    /**
     * Block used to output the vertex position
     */
    export class VertexOutputBlock extends NodeMaterialBlock {
        /**
         * Creates a new VertexOutputBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the vector input component
         */
        get vector(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to output the final color
     */
    export class FragmentOutputBlock extends NodeMaterialBlock {
        /**
         * Create a new FragmentOutputBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the rgba input component
         */
        get rgba(): NodeMaterialConnectionPoint;
        /**
         * Gets the rgb input component
         */
        get rgb(): NodeMaterialConnectionPoint;
        /**
         * Gets the a input component
         */
        get a(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used for the particle ramp gradient section
     */
    export class ParticleRampGradientBlock extends NodeMaterialBlock {
        /**
         * Create a new ParticleRampGradientBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the color input component
         */
        get color(): NodeMaterialConnectionPoint;
        /**
         * Gets the rampColor output component
         */
        get rampColor(): NodeMaterialConnectionPoint;
        /**
         * Initialize the block and prepare the context for build
         * @param state defines the state that will be used for the build
         */
        initialize(state: NodeMaterialBuildState): void;
        protected _buildBlock(state: NodeMaterialBuildState): this | undefined;
    }
}
declare module BABYLON {
    /**
      * Block used for the particle blend multiply section
      */
    export class ParticleBlendMultiplyBlock extends NodeMaterialBlock {
        /**
         * Create a new ParticleBlendMultiplyBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the color input component
         */
        get color(): NodeMaterialConnectionPoint;
        /**
         * Gets the alphaTexture input component
         */
        get alphaTexture(): NodeMaterialConnectionPoint;
        /**
         * Gets the alphaColor input component
         */
        get alphaColor(): NodeMaterialConnectionPoint;
        /**
         * Gets the blendColor output component
         */
        get blendColor(): NodeMaterialConnectionPoint;
        /**
         * Initialize the block and prepare the context for build
         * @param state defines the state that will be used for the build
         */
        initialize(state: NodeMaterialBuildState): void;
        protected _buildBlock(state: NodeMaterialBuildState): this | undefined;
    }
}
declare module BABYLON {
    /**
     * Block used to create a Vector2/3/4 out of individual inputs (one for each component)
     */
    export class VectorMergerBlock extends NodeMaterialBlock {
        /**
         * Create a new VectorMergerBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the xyz component (input)
         */
        get xyzIn(): NodeMaterialConnectionPoint;
        /**
         * Gets the xy component (input)
         */
        get xyIn(): NodeMaterialConnectionPoint;
        /**
         * Gets the x component (input)
         */
        get x(): NodeMaterialConnectionPoint;
        /**
         * Gets the y component (input)
         */
        get y(): NodeMaterialConnectionPoint;
        /**
         * Gets the z component (input)
         */
        get z(): NodeMaterialConnectionPoint;
        /**
         * Gets the w component (input)
         */
        get w(): NodeMaterialConnectionPoint;
        /**
         * Gets the xyzw component (output)
         */
        get xyzw(): NodeMaterialConnectionPoint;
        /**
         * Gets the xyz component (output)
         */
        get xyzOut(): NodeMaterialConnectionPoint;
        /**
         * Gets the xy component (output)
         */
        get xyOut(): NodeMaterialConnectionPoint;
        /**
         * Gets the xy component (output)
         * @deprecated Please use xyOut instead.
         */
        get xy(): NodeMaterialConnectionPoint;
        /**
         * Gets the xyz component (output)
         * @deprecated Please use xyzOut instead.
         */
        get xyz(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to remap a float from a range to a new one
     */
    export class RemapBlock extends NodeMaterialBlock {
        /**
         * Gets or sets the source range
         */
        sourceRange: Vector2;
        /**
         * Gets or sets the target range
         */
        targetRange: Vector2;
        /**
         * Creates a new RemapBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the input component
         */
        get input(): NodeMaterialConnectionPoint;
        /**
         * Gets the source min input component
         */
        get sourceMin(): NodeMaterialConnectionPoint;
        /**
         * Gets the source max input component
         */
        get sourceMax(): NodeMaterialConnectionPoint;
        /**
         * Gets the target min input component
         */
        get targetMin(): NodeMaterialConnectionPoint;
        /**
         * Gets the target max input component
         */
        get targetMax(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
        protected _dumpPropertiesCode(): string;
        serialize(): any;
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * Block used to multiply 2 values
     */
    export class MultiplyBlock extends NodeMaterialBlock {
        /**
         * Creates a new MultiplyBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the left operand input component
         */
        get left(): NodeMaterialConnectionPoint;
        /**
         * Gets the right operand input component
         */
        get right(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to expand a Color3/4 into 4 outputs (one for each component)
     */
    export class ColorSplitterBlock extends NodeMaterialBlock {
        /**
         * Create a new ColorSplitterBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the rgba component (input)
         */
        get rgba(): NodeMaterialConnectionPoint;
        /**
         * Gets the rgb component (input)
         */
        get rgbIn(): NodeMaterialConnectionPoint;
        /**
         * Gets the rgb component (output)
         */
        get rgbOut(): NodeMaterialConnectionPoint;
        /**
         * Gets the r component (output)
         */
        get r(): NodeMaterialConnectionPoint;
        /**
         * Gets the g component (output)
         */
        get g(): NodeMaterialConnectionPoint;
        /**
         * Gets the b component (output)
         */
        get b(): NodeMaterialConnectionPoint;
        /**
         * Gets the a component (output)
         */
        get a(): NodeMaterialConnectionPoint;
        protected _inputRename(name: string): string;
        protected _outputRename(name: string): string;
        protected _buildBlock(state: NodeMaterialBuildState): this | undefined;
    }
}
declare module BABYLON {
    /**
     * Operations supported by the Trigonometry block
     */
    export enum TrigonometryBlockOperations {
        /** Cos */
        Cos = 0,
        /** Sin */
        Sin = 1,
        /** Abs */
        Abs = 2,
        /** Exp */
        Exp = 3,
        /** Exp2 */
        Exp2 = 4,
        /** Round */
        Round = 5,
        /** Floor */
        Floor = 6,
        /** Ceiling */
        Ceiling = 7,
        /** Square root */
        Sqrt = 8,
        /** Log */
        Log = 9,
        /** Tangent */
        Tan = 10,
        /** Arc tangent */
        ArcTan = 11,
        /** Arc cosinus */
        ArcCos = 12,
        /** Arc sinus */
        ArcSin = 13,
        /** Fraction */
        Fract = 14,
        /** Sign */
        Sign = 15,
        /** To radians (from degrees) */
        Radians = 16,
        /** To degrees (from radians) */
        Degrees = 17
    }
    /**
     * Block used to apply trigonometry operation to floats
     */
    export class TrigonometryBlock extends NodeMaterialBlock {
        /**
         * Gets or sets the operation applied by the block
         */
        operation: TrigonometryBlockOperations;
        /**
         * Creates a new TrigonometryBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the input component
         */
        get input(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
        serialize(): any;
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
        protected _dumpPropertiesCode(): string;
    }
}
declare module BABYLON {
    /**
     * Interface used to configure the node material editor
     */
    export interface INodeMaterialEditorOptions {
        /** Define the URl to load node editor script */
        editorURL?: string;
    }
    /** @hidden */
    export class NodeMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {
        NORMAL: boolean;
        TANGENT: boolean;
        UV1: boolean;
        /** BONES */
        NUM_BONE_INFLUENCERS: number;
        BonesPerMesh: number;
        BONETEXTURE: boolean;
        /** MORPH TARGETS */
        MORPHTARGETS: boolean;
        MORPHTARGETS_NORMAL: boolean;
        MORPHTARGETS_TANGENT: boolean;
        MORPHTARGETS_UV: boolean;
        NUM_MORPH_INFLUENCERS: number;
        /** IMAGE PROCESSING */
        IMAGEPROCESSING: boolean;
        VIGNETTE: boolean;
        VIGNETTEBLENDMODEMULTIPLY: boolean;
        VIGNETTEBLENDMODEOPAQUE: boolean;
        TONEMAPPING: boolean;
        TONEMAPPING_ACES: boolean;
        CONTRAST: boolean;
        EXPOSURE: boolean;
        COLORCURVES: boolean;
        COLORGRADING: boolean;
        COLORGRADING3D: boolean;
        SAMPLER3DGREENDEPTH: boolean;
        SAMPLER3DBGRMAP: boolean;
        IMAGEPROCESSINGPOSTPROCESS: boolean;
        /** MISC. */
        BUMPDIRECTUV: number;
        constructor();
        setValue(name: string, value: any, markAsUnprocessedIfDirty?: boolean): void;
    }
    /**
     * Class used to configure NodeMaterial
     */
    export interface INodeMaterialOptions {
        /**
         * Defines if blocks should emit comments
         */
        emitComments: boolean;
    }
    /**
     * Class used to create a node based material built by assembling shader blocks
     */
    export class NodeMaterial extends PushMaterial {
        private static _BuildIdGenerator;
        private _options;
        private _vertexCompilationState;
        private _fragmentCompilationState;
        private _sharedData;
        private _buildId;
        private _buildWasSuccessful;
        private _cachedWorldViewMatrix;
        private _cachedWorldViewProjectionMatrix;
        private _optimizers;
        private _animationFrame;
        /** Define the Url to load node editor script */
        static EditorURL: string;
        /** Define the Url to load snippets */
        static SnippetUrl: string;
        /** Gets or sets a boolean indicating that node materials should not deserialize textures from json / snippet content */
        static IgnoreTexturesAtLoadTime: boolean;
        private BJSNODEMATERIALEDITOR;
        /** Get the inspector from bundle or global */
        private _getGlobalNodeMaterialEditor;
        /**
         * Snippet ID if the material was created from the snippet server
         */
        snippetId: string;
        /**
         * Gets or sets data used by visual editor
         * @see https://nme.babylonjs.com
         */
        editorData: any;
        /**
         * Gets or sets a boolean indicating that alpha value must be ignored (This will turn alpha blending off even if an alpha value is produced by the material)
         */
        ignoreAlpha: boolean;
        /**
        * Defines the maximum number of lights that can be used in the material
        */
        maxSimultaneousLights: number;
        /**
         * Observable raised when the material is built
         */
        onBuildObservable: Observable<NodeMaterial>;
        /**
         * Gets or sets the root nodes of the material vertex shader
         */
        _vertexOutputNodes: NodeMaterialBlock[];
        /**
         * Gets or sets the root nodes of the material fragment (pixel) shader
         */
        _fragmentOutputNodes: NodeMaterialBlock[];
        /** Gets or sets options to control the node material overall behavior */
        get options(): INodeMaterialOptions;
        set options(options: INodeMaterialOptions);
        /**
         * Default configuration related to image processing available in the standard Material.
         */
        protected _imageProcessingConfiguration: ImageProcessingConfiguration;
        /**
         * Gets the image processing configuration used either in this material.
         */
        get imageProcessingConfiguration(): ImageProcessingConfiguration;
        /**
         * Sets the Default image processing configuration used either in the this material.
         *
         * If sets to null, the scene one is in use.
         */
        set imageProcessingConfiguration(value: ImageProcessingConfiguration);
        /**
         * Gets an array of blocks that needs to be serialized even if they are not yet connected
         */
        attachedBlocks: NodeMaterialBlock[];
        /**
         * Specifies the mode of the node material
         * @hidden
         */
        _mode: NodeMaterialModes;
        /**
         * Gets the mode property
         */
        get mode(): NodeMaterialModes;
        /**
         * Create a new node based material
         * @param name defines the material name
         * @param scene defines the hosting scene
         * @param options defines creation option
         */
        constructor(name: string, scene?: Scene, options?: Partial<INodeMaterialOptions>);
        /**
         * Gets the current class name of the material e.g. "NodeMaterial"
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Keep track of the image processing observer to allow dispose and replace.
         */
        private _imageProcessingObserver;
        /**
         * Attaches a new image processing configuration to the Standard Material.
         * @param configuration
         */
        protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void;
        /**
         * Get a block by its name
         * @param name defines the name of the block to retrieve
         * @returns the required block or null if not found
         */
        getBlockByName(name: string): Nullable<NodeMaterialBlock>;
        /**
         * Get a block by its name
         * @param predicate defines the predicate used to find the good candidate
         * @returns the required block or null if not found
         */
        getBlockByPredicate(predicate: (block: NodeMaterialBlock) => boolean): Nullable<NodeMaterialBlock>;
        /**
         * Get an input block by its name
         * @param predicate defines the predicate used to find the good candidate
         * @returns the required input block or null if not found
         */
        getInputBlockByPredicate(predicate: (block: InputBlock) => boolean): Nullable<InputBlock>;
        /**
         * Gets the list of input blocks attached to this material
         * @returns an array of InputBlocks
         */
        getInputBlocks(): InputBlock[];
        /**
         * Adds a new optimizer to the list of optimizers
         * @param optimizer defines the optimizers to add
         * @returns the current material
         */
        registerOptimizer(optimizer: NodeMaterialOptimizer): this | undefined;
        /**
         * Remove an optimizer from the list of optimizers
         * @param optimizer defines the optimizers to remove
         * @returns the current material
         */
        unregisterOptimizer(optimizer: NodeMaterialOptimizer): this | undefined;
        /**
         * Add a new block to the list of output nodes
         * @param node defines the node to add
         * @returns the current material
         */
        addOutputNode(node: NodeMaterialBlock): this;
        /**
         * Remove a block from the list of root nodes
         * @param node defines the node to remove
         * @returns the current material
         */
        removeOutputNode(node: NodeMaterialBlock): this;
        private _addVertexOutputNode;
        private _removeVertexOutputNode;
        private _addFragmentOutputNode;
        private _removeFragmentOutputNode;
        /**
         * Specifies if the material will require alpha blending
         * @returns a boolean specifying if alpha blending is needed
         */
        needAlphaBlending(): boolean;
        /**
         * Specifies if this material should be rendered in alpha test mode
         * @returns a boolean specifying if an alpha test is needed.
         */
        needAlphaTesting(): boolean;
        private _initializeBlock;
        private _resetDualBlocks;
        /**
         * Remove a block from the current node material
         * @param block defines the block to remove
         */
        removeBlock(block: NodeMaterialBlock): void;
        /**
         * Build the material and generates the inner effect
         * @param verbose defines if the build should log activity
         */
        build(verbose?: boolean): void;
        /**
         * Runs an otpimization phase to try to improve the shader code
         */
        optimize(): void;
        private _prepareDefinesForAttributes;
        /**
         * Create a post process from the material
         * @param camera The camera to apply the render pass to.
         * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)
         * @returns the post process created
         */
        createPostProcess(camera: Nullable<Camera>, options?: number | PostProcessOptions, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, textureFormat?: number): Nullable<PostProcess>;
        /**
         * Create the post process effect from the material
         * @param postProcess The post process to create the effect for
         */
        createEffectForPostProcess(postProcess: PostProcess): void;
        private _createEffectForPostProcess;
        /**
         * Create a new procedural texture based on this node material
         * @param size defines the size of the texture
         * @param scene defines the hosting scene
         * @returns the new procedural texture attached to this node material
         */
        createProceduralTexture(size: number | {
            width: number;
            height: number;
            layers?: number;
        }, scene: Scene): Nullable<ProceduralTexture>;
        private _createEffectForParticles;
        private _checkInternals;
        /**
         * Create the effect to be used as the custom effect for a particle system
         * @param particleSystem Particle system to create the effect for
         * @param onCompiled defines a function to call when the effect creation is successful
         * @param onError defines a function to call when the effect creation has failed
         */
        createEffectForParticles(particleSystem: IParticleSystem, onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void): void;
        private _processDefines;
        /**
          * Get if the submesh is ready to be used and all its information available.
          * Child classes can use it to update shaders
          * @param mesh defines the mesh to check
          * @param subMesh defines which submesh to check
          * @param useInstances specifies that instances should be used
          * @returns a boolean indicating that the submesh is ready or not
          */
        isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean;
        /**
         * Get a string representing the shaders built by the current node graph
         */
        get compiledShaders(): string;
        /**
         * Binds the world matrix to the material
         * @param world defines the world transformation matrix
         */
        bindOnlyWorldMatrix(world: Matrix): void;
        /**
         * Binds the submesh to this material by preparing the effect and shader to draw
         * @param world defines the world transformation matrix
         * @param mesh defines the mesh containing the submesh
         * @param subMesh defines the submesh to bind the material to
         */
        bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void;
        /**
         * Gets the active textures from the material
         * @returns an array of textures
         */
        getActiveTextures(): BaseTexture[];
        /**
         * Gets the list of texture blocks
         * @returns an array of texture blocks
         */
        getTextureBlocks(): (TextureBlock | ReflectionTextureBaseBlock | RefractionBlock | CurrentScreenBlock | ParticleTextureBlock)[];
        /**
         * Specifies if the material uses a texture
         * @param texture defines the texture to check against the material
         * @returns a boolean specifying if the material uses the texture
         */
        hasTexture(texture: BaseTexture): boolean;
        /**
         * Disposes the material
         * @param forceDisposeEffect specifies if effects should be forcefully disposed
         * @param forceDisposeTextures specifies if textures should be forcefully disposed
         * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh
         */
        dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void;
        /** Creates the node editor window. */
        private _createNodeEditor;
        /**
         * Launch the node material editor
         * @param config Define the configuration of the editor
         * @return a promise fulfilled when the node editor is visible
         */
        edit(config?: INodeMaterialEditorOptions): Promise<void>;
        /**
         * Clear the current material
         */
        clear(): void;
        /**
         * Clear the current material and set it to a default state
         */
        setToDefault(): void;
        /**
         * Clear the current material and set it to a default state for post process
         */
        setToDefaultPostProcess(): void;
        /**
         * Clear the current material and set it to a default state for procedural texture
         */
        setToDefaultProceduralTexture(): void;
        /**
         * Clear the current material and set it to a default state for particle
         */
        setToDefaultParticle(): void;
        /**
         * Loads the current Node Material from a url pointing to a file save by the Node Material Editor
         * @param url defines the url to load from
         * @returns a promise that will fullfil when the material is fully loaded
         */
        loadAsync(url: string): Promise<void>;
        private _gatherBlocks;
        /**
         * Generate a string containing the code declaration required to create an equivalent of this material
         * @returns a string
         */
        generateCode(): string;
        /**
         * Serializes this material in a JSON representation
         * @returns the serialized material object
         */
        serialize(selectedBlocks?: NodeMaterialBlock[]): any;
        private _restoreConnections;
        /**
         * Clear the current graph and load a new one from a serialization object
         * @param source defines the JSON representation of the material
         * @param rootUrl defines the root URL to use to load textures and relative dependencies
         * @param merge defines whether or not the source must be merged or replace the current content
         */
        loadFromSerialization(source: any, rootUrl?: string, merge?: boolean): void;
        /**
         * Makes a duplicate of the current material.
         * @param name - name to use for the new material.
         */
        clone(name: string): NodeMaterial;
        /**
         * Creates a node material from parsed material data
         * @param source defines the JSON representation of the material
         * @param scene defines the hosting scene
         * @param rootUrl defines the root URL to use to load textures and relative dependencies
         * @returns a new node material
         */
        static Parse(source: any, scene: Scene, rootUrl?: string): NodeMaterial;
        /**
         * Creates a node material from a snippet saved in a remote file
         * @param name defines the name of the material to create
         * @param url defines the url to load from
         * @param scene defines the hosting scene
         * @returns a promise that will resolve to the new node material
         */
        static ParseFromFileAsync(name: string, url: string, scene: Scene): Promise<NodeMaterial>;
        /**
         * Creates a node material from a snippet saved by the node material editor
         * @param snippetId defines the snippet to load
         * @param scene defines the hosting scene
         * @param rootUrl defines the root URL to use to load textures and relative dependencies
         * @param nodeMaterial defines a node material to update (instead of creating a new one)
         * @returns a promise that will resolve to the new node material
         */
        static ParseFromSnippetAsync(snippetId: string, scene: Scene, rootUrl?: string, nodeMaterial?: NodeMaterial): Promise<NodeMaterial>;
        /**
         * Creates a new node material set to default basic configuration
         * @param name defines the name of the material
         * @param scene defines the hosting scene
         * @returns a new NodeMaterial
         */
        static CreateDefault(name: string, scene?: Scene): NodeMaterial;
    }
}
declare module BABYLON {
    /**
     * Size options for a post process
     */
    export type PostProcessOptions = {
        width: number;
        height: number;
    };
    /**
     * PostProcess can be used to apply a shader to a texture after it has been rendered
     * See https://doc.babylonjs.com/how_to/how_to_use_postprocesses
     */
    export class PostProcess {
        /**
         * Gets or sets the unique id of the post process
         */
        uniqueId: number;
        /** Name of the PostProcess. */
        name: string;
        /**
        * Width of the texture to apply the post process on
        */
        width: number;
        /**
        * Height of the texture to apply the post process on
        */
        height: number;
        /**
         * Gets the node material used to create this postprocess (null if the postprocess was manually created)
         */
        nodeMaterialSource: Nullable<NodeMaterial>;
        /**
        * Internal, reference to the location where this postprocess was output to. (Typically the texture on the next postprocess in the chain)
        * @hidden
        */
        _outputTexture: Nullable<InternalTexture>;
        /**
        * Sampling mode used by the shader
        * See https://doc.babylonjs.com/classes/3.1/texture
        */
        renderTargetSamplingMode: number;
        /**
        * Clear color to use when screen clearing
        */
        clearColor: Color4;
        /**
        * If the buffer needs to be cleared before applying the post process. (default: true)
        * Should be set to false if shader will overwrite all previous pixels.
        */
        autoClear: boolean;
        /**
        * Type of alpha mode to use when performing the post process (default: Engine.ALPHA_DISABLE)
        */
        alphaMode: number;
        /**
        * Sets the setAlphaBlendConstants of the babylon engine
        */
        alphaConstants: Color4;
        /**
        * Animations to be used for the post processing
        */
        animations: Animation[];
        /**
         * Enable Pixel Perfect mode where texture is not scaled to be power of 2.
         * Can only be used on a single postprocess or on the last one of a chain. (default: false)
         */
        enablePixelPerfectMode: boolean;
        /**
         * Force the postprocess to be applied without taking in account viewport
         */
        forceFullscreenViewport: boolean;
        /**
         * List of inspectable custom properties (used by the Inspector)
         * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility
         */
        inspectableCustomProperties: IInspectable[];
        /**
         * Scale mode for the post process (default: Engine.SCALEMODE_FLOOR)
         *
         * | Value | Type                                | Description |
         * | ----- | ----------------------------------- | ----------- |
         * | 1     | SCALEMODE_FLOOR                     | [engine.scalemode_floor](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_floor) |
         * | 2     | SCALEMODE_NEAREST                   | [engine.scalemode_nearest](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_nearest) |
         * | 3     | SCALEMODE_CEILING                   | [engine.scalemode_ceiling](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_ceiling) |
         *
         */
        scaleMode: number;
        /**
        * Force textures to be a power of two (default: false)
        */
        alwaysForcePOT: boolean;
        private _samples;
        /**
        * Number of sample textures (default: 1)
        */
        get samples(): number;
        set samples(n: number);
        /**
        * Modify the scale of the post process to be the same as the viewport (default: false)
        */
        adaptScaleToCurrentViewport: boolean;
        private _camera;
        protected _scene: Scene;
        private _engine;
        private _options;
        private _reusable;
        private _textureType;
        private _textureFormat;
        /**
        * Smart array of input and output textures for the post process.
        * @hidden
        */
        _textures: SmartArray<InternalTexture>;
        /**
        * The index in _textures that corresponds to the output texture.
        * @hidden
        */
        _currentRenderTextureInd: number;
        private _effect;
        private _samplers;
        private _fragmentUrl;
        private _vertexUrl;
        private _parameters;
        private _scaleRatio;
        protected _indexParameters: any;
        private _shareOutputWithPostProcess;
        private _texelSize;
        private _forcedOutputTexture;
        /**
         * Returns the fragment url or shader name used in the post process.
         * @returns the fragment url or name in the shader store.
         */
        getEffectName(): string;
        /**
        * An event triggered when the postprocess is activated.
        */
        onActivateObservable: Observable<Camera>;
        private _onActivateObserver;
        /**
        * A function that is added to the onActivateObservable
        */
        set onActivate(callback: Nullable<(camera: Camera) => void>);
        /**
        * An event triggered when the postprocess changes its size.
        */
        onSizeChangedObservable: Observable<PostProcess>;
        private _onSizeChangedObserver;
        /**
        * A function that is added to the onSizeChangedObservable
        */
        set onSizeChanged(callback: (postProcess: PostProcess) => void);
        /**
        * An event triggered when the postprocess applies its effect.
        */
        onApplyObservable: Observable<Effect>;
        private _onApplyObserver;
        /**
        * A function that is added to the onApplyObservable
        */
        set onApply(callback: (effect: Effect) => void);
        /**
        * An event triggered before rendering the postprocess
        */
        onBeforeRenderObservable: Observable<Effect>;
        private _onBeforeRenderObserver;
        /**
        * A function that is added to the onBeforeRenderObservable
        */
        set onBeforeRender(callback: (effect: Effect) => void);
        /**
        * An event triggered after rendering the postprocess
        */
        onAfterRenderObservable: Observable<Effect>;
        private _onAfterRenderObserver;
        /**
        * A function that is added to the onAfterRenderObservable
        */
        set onAfterRender(callback: (efect: Effect) => void);
        /**
        * The input texture for this post process and the output texture of the previous post process. When added to a pipeline the previous post process will
        * render it's output into this texture and this texture will be used as textureSampler in the fragment shader of this post process.
        */
        get inputTexture(): InternalTexture;
        set inputTexture(value: InternalTexture);
        /**
        * Since inputTexture should always be defined, if we previously manually set `inputTexture`,
        * the only way to unset it is to use this function to restore its internal state
        */
        restoreDefaultInputTexture(): void;
        /**
        * Gets the camera which post process is applied to.
        * @returns The camera the post process is applied to.
        */
        getCamera(): Camera;
        /**
        * Gets the texel size of the postprocess.
        * See https://en.wikipedia.org/wiki/Texel_(graphics)
        */
        get texelSize(): Vector2;
        /**
         * Creates a new instance PostProcess
         * @param name The name of the PostProcess.
         * @param fragmentUrl The url of the fragment shader to be used.
         * @param parameters Array of the names of uniform non-sampler2D variables that will be passed to the shader.
         * @param samplers Array of the names of uniform sampler2D variables that will be passed to the shader.
         * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param defines String of defines that will be set when running the fragment shader. (default: null)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param vertexUrl The url of the vertex shader to be used. (default: "postprocess")
         * @param indexParameters The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx
         * @param blockCompilation If the shader should not be compiled immediatly. (default: false)
         * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)
         */
        constructor(name: string, fragmentUrl: string, parameters: Nullable<string[]>, samplers: Nullable<string[]>, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, defines?: Nullable<string>, textureType?: number, vertexUrl?: string, indexParameters?: any, blockCompilation?: boolean, textureFormat?: number);
        /**
         * Gets a string identifying the name of the class
         * @returns "PostProcess" string
         */
        getClassName(): string;
        /**
         * Gets the engine which this post process belongs to.
         * @returns The engine the post process was enabled with.
         */
        getEngine(): Engine;
        /**
         * The effect that is created when initializing the post process.
         * @returns The created effect corresponding the the postprocess.
         */
        getEffect(): Effect;
        /**
         * To avoid multiple redundant textures for multiple post process, the output the output texture for this post process can be shared with another.
         * @param postProcess The post process to share the output with.
         * @returns This post process.
         */
        shareOutputWith(postProcess: PostProcess): PostProcess;
        /**
         * Reverses the effect of calling shareOutputWith and returns the post process back to its original state.
         * This should be called if the post process that shares output with this post process is disabled/disposed.
         */
        useOwnOutput(): void;
        /**
         * Updates the effect with the current post process compile time values and recompiles the shader.
         * @param defines Define statements that should be added at the beginning of the shader. (default: null)
         * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)
         * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)
         * @param indexParameters The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx
         * @param onCompiled Called when the shader has been compiled.
         * @param onError Called if there is an error when compiling a shader.
         * @param vertexUrl The url of the vertex shader to be used (default: the one given at construction time)
         * @param fragmentUrl The url of the fragment shader to be used (default: the one given at construction time)
         */
        updateEffect(defines?: Nullable<string>, uniforms?: Nullable<string[]>, samplers?: Nullable<string[]>, indexParameters?: any, onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void, vertexUrl?: string, fragmentUrl?: string): void;
        /**
         * The post process is reusable if it can be used multiple times within one frame.
         * @returns If the post process is reusable
         */
        isReusable(): boolean;
        /** invalidate frameBuffer to hint the postprocess to create a depth buffer */
        markTextureDirty(): void;
        /**
         * Activates the post process by intializing the textures to be used when executed. Notifies onActivateObservable.
         * When this post process is used in a pipeline, this is call will bind the input texture of this post process to the output of the previous.
         * @param camera The camera that will be used in the post process. This camera will be used when calling onActivateObservable.
         * @param sourceTexture The source texture to be inspected to get the width and height if not specified in the post process constructor. (default: null)
         * @param forceDepthStencil If true, a depth and stencil buffer will be generated. (default: false)
         * @returns The target texture that was bound to be written to.
         */
        activate(camera: Nullable<Camera>, sourceTexture?: Nullable<InternalTexture>, forceDepthStencil?: boolean): InternalTexture;
        /**
         * If the post process is supported.
         */
        get isSupported(): boolean;
        /**
         * The aspect ratio of the output texture.
         */
        get aspectRatio(): number;
        /**
         * Get a value indicating if the post-process is ready to be used
         * @returns true if the post-process is ready (shader is compiled)
         */
        isReady(): boolean;
        /**
         * Binds all textures and uniforms to the shader, this will be run on every pass.
         * @returns the effect corresponding to this post process. Null if not compiled or not ready.
         */
        apply(): Nullable<Effect>;
        private _disposeTextures;
        /**
         * Disposes the post process.
         * @param camera The camera to dispose the post process on.
         */
        dispose(camera?: Camera): void;
        /**
         * Serializes the particle system to a JSON object
         * @returns the JSON object
         */
        serialize(): any;
        /**
         * Creates a material from parsed material data
         * @param parsedPostProcess defines parsed post process data
         * @param scene defines the hosting scene
         * @param rootUrl defines the root URL to use to load textures
         * @returns a new post process
         */
        static Parse(parsedPostProcess: any, scene: Scene, rootUrl: string): Nullable<PostProcess>;
    }
}
declare module BABYLON {
    /** @hidden */
    export var kernelBlurVaryingDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var kernelBlurFragment: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var kernelBlurFragment2: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var kernelBlurPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var kernelBlurVertex: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var kernelBlurVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * The Blur Post Process which blurs an image based on a kernel and direction.
     * Can be used twice in x and y directions to perform a guassian blur in two passes.
     */
    export class BlurPostProcess extends PostProcess {
        private blockCompilation;
        protected _kernel: number;
        protected _idealKernel: number;
        protected _packedFloat: boolean;
        private _staticDefines;
        /** The direction in which to blur the image. */
        direction: Vector2;
        /**
         * Sets the length in pixels of the blur sample region
         */
        set kernel(v: number);
        /**
         * Gets the length in pixels of the blur sample region
         */
        get kernel(): number;
        /**
         * Sets wether or not the blur needs to unpack/repack floats
         */
        set packedFloat(v: boolean);
        /**
         * Gets wether or not the blur is unpacking/repacking floats
         */
        get packedFloat(): boolean;
        /**
         * Gets a string identifying the name of the class
         * @returns "BlurPostProcess" string
         */
        getClassName(): string;
        /**
         * Creates a new instance BlurPostProcess
         * @param name The name of the effect.
         * @param direction The direction in which to blur the image.
         * @param kernel The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.
         * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, direction: Vector2, kernel: number, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, defines?: string, blockCompilation?: boolean);
        /**
         * Updates the effect with the current post process compile time values and recompiles the shader.
         * @param defines Define statements that should be added at the beginning of the shader. (default: null)
         * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)
         * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)
         * @param indexParameters The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx
         * @param onCompiled Called when the shader has been compiled.
         * @param onError Called if there is an error when compiling a shader.
         */
        updateEffect(defines?: Nullable<string>, uniforms?: Nullable<string[]>, samplers?: Nullable<string[]>, indexParameters?: any, onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void): void;
        protected _updateParameters(onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void): void;
        /**
         * Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.
         * Other odd kernels optimize correctly but require proportionally more samples, even kernels are
         * possible but will produce minor visual artifacts. Since each new kernel requires a new shader we
         * want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.
         * The gaps between physical kernels are compensated for in the weighting of the samples
         * @param idealKernel Ideal blur kernel.
         * @return Nearest best kernel.
         */
        protected _nearestBestKernel(idealKernel: number): number;
        /**
         * Calculates the value of a Gaussian distribution with sigma 3 at a given point.
         * @param x The point on the Gaussian distribution to sample.
         * @return the value of the Gaussian function at x.
         */
        protected _gaussianWeight(x: number): number;
        /**
          * Generates a string that can be used as a floating point number in GLSL.
          * @param x Value to print.
          * @param decimalFigures Number of decimal places to print the number to (excluding trailing 0s).
          * @return GLSL float string.
          */
        protected _glslFloat(x: number, decimalFigures?: number): string;
        /** @hidden */
        static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<BlurPostProcess>;
    }
}
declare module BABYLON {
    /**
     * Mirror texture can be used to simulate the view from a mirror in a scene.
     * It will dynamically be rendered every frame to adapt to the camera point of view.
     * You can then easily use it as a reflectionTexture on a flat surface.
     * In case the surface is not a plane, please consider relying on reflection probes.
     * @see https://doc.babylonjs.com/how_to/reflect#mirrors
     */
    export class MirrorTexture extends RenderTargetTexture {
        private scene;
        /**
         * Define the reflection plane we want to use. The mirrorPlane is usually set to the constructed reflector.
         * It is possible to directly set the mirrorPlane by directly using a Plane(a, b, c, d) where a, b and c give the plane normal vector (a, b, c) and d is a scalar displacement from the mirrorPlane to the origin. However in all but the very simplest of situations it is more straight forward to set it to the reflector as stated in the doc.
         * @see https://doc.babylonjs.com/how_to/reflect#mirrors
         */
        mirrorPlane: Plane;
        /**
         * Define the blur ratio used to blur the reflection if needed.
         */
        set blurRatio(value: number);
        get blurRatio(): number;
        /**
         * Define the adaptive blur kernel used to blur the reflection if needed.
         * This will autocompute the closest best match for the `blurKernel`
         */
        set adaptiveBlurKernel(value: number);
        /**
         * Define the blur kernel used to blur the reflection if needed.
         * Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.
         */
        set blurKernel(value: number);
        /**
         * Define the blur kernel on the X Axis used to blur the reflection if needed.
         * Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.
         */
        set blurKernelX(value: number);
        get blurKernelX(): number;
        /**
         * Define the blur kernel on the Y Axis used to blur the reflection if needed.
         * Please consider using `adaptiveBlurKernel` as it could find the closest best value for you.
         */
        set blurKernelY(value: number);
        get blurKernelY(): number;
        private _autoComputeBlurKernel;
        protected _onRatioRescale(): void;
        private _updateGammaSpace;
        private _imageProcessingConfigChangeObserver;
        private _transformMatrix;
        private _mirrorMatrix;
        private _savedViewMatrix;
        private _blurX;
        private _blurY;
        private _adaptiveBlurKernel;
        private _blurKernelX;
        private _blurKernelY;
        private _blurRatio;
        /**
         * Instantiates a Mirror Texture.
         * Mirror texture can be used to simulate the view from a mirror in a scene.
         * It will dynamically be rendered every frame to adapt to the camera point of view.
         * You can then easily use it as a reflectionTexture on a flat surface.
         * In case the surface is not a plane, please consider relying on reflection probes.
         * @see https://doc.babylonjs.com/how_to/reflect#mirrors
         * @param name
         * @param size
         * @param scene
         * @param generateMipMaps
         * @param type
         * @param samplingMode
         * @param generateDepthBuffer
         */
        constructor(name: string, size: number | {
            width: number;
            height: number;
        } | {
            ratio: number;
        }, scene: Scene, generateMipMaps?: boolean, type?: number, samplingMode?: number, generateDepthBuffer?: boolean);
        private _preparePostProcesses;
        /**
         * Clone the mirror texture.
         * @returns the cloned texture
         */
        clone(): MirrorTexture;
        /**
         * Serialize the texture to a JSON representation you could use in Parse later on
         * @returns the serialized JSON representation
         */
        serialize(): any;
        /**
         * Dispose the texture and release its associated resources.
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.
     * @see https://doc.babylonjs.com/babylon101/materials#texture
     */
    export class Texture extends BaseTexture {
        /**
         * Gets or sets a general boolean used to indicate that textures containing direct data (buffers) must be saved as part of the serialization process
         */
        static SerializeBuffers: boolean;
        /** @hidden */
        static _CubeTextureParser: (jsonTexture: any, scene: Scene, rootUrl: string) => CubeTexture;
        /** @hidden */
        static _CreateMirror: (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean) => MirrorTexture;
        /** @hidden */
        static _CreateRenderTargetTexture: (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean) => RenderTargetTexture;
        /** nearest is mag = nearest and min = nearest and mip = linear */
        static readonly NEAREST_SAMPLINGMODE: number;
        /** nearest is mag = nearest and min = nearest and mip = linear */
        static readonly NEAREST_NEAREST_MIPLINEAR: number;
        /** Bilinear is mag = linear and min = linear and mip = nearest */
        static readonly BILINEAR_SAMPLINGMODE: number;
        /** Bilinear is mag = linear and min = linear and mip = nearest */
        static readonly LINEAR_LINEAR_MIPNEAREST: number;
        /** Trilinear is mag = linear and min = linear and mip = linear */
        static readonly TRILINEAR_SAMPLINGMODE: number;
        /** Trilinear is mag = linear and min = linear and mip = linear */
        static readonly LINEAR_LINEAR_MIPLINEAR: number;
        /** mag = nearest and min = nearest and mip = nearest */
        static readonly NEAREST_NEAREST_MIPNEAREST: number;
        /** mag = nearest and min = linear and mip = nearest */
        static readonly NEAREST_LINEAR_MIPNEAREST: number;
        /** mag = nearest and min = linear and mip = linear */
        static readonly NEAREST_LINEAR_MIPLINEAR: number;
        /** mag = nearest and min = linear and mip = none */
        static readonly NEAREST_LINEAR: number;
        /** mag = nearest and min = nearest and mip = none */
        static readonly NEAREST_NEAREST: number;
        /** mag = linear and min = nearest and mip = nearest */
        static readonly LINEAR_NEAREST_MIPNEAREST: number;
        /** mag = linear and min = nearest and mip = linear */
        static readonly LINEAR_NEAREST_MIPLINEAR: number;
        /** mag = linear and min = linear and mip = none */
        static readonly LINEAR_LINEAR: number;
        /** mag = linear and min = nearest and mip = none */
        static readonly LINEAR_NEAREST: number;
        /** Explicit coordinates mode */
        static readonly EXPLICIT_MODE: number;
        /** Spherical coordinates mode */
        static readonly SPHERICAL_MODE: number;
        /** Planar coordinates mode */
        static readonly PLANAR_MODE: number;
        /** Cubic coordinates mode */
        static readonly CUBIC_MODE: number;
        /** Projection coordinates mode */
        static readonly PROJECTION_MODE: number;
        /** Inverse Cubic coordinates mode */
        static readonly SKYBOX_MODE: number;
        /** Inverse Cubic coordinates mode */
        static readonly INVCUBIC_MODE: number;
        /** Equirectangular coordinates mode */
        static readonly EQUIRECTANGULAR_MODE: number;
        /** Equirectangular Fixed coordinates mode */
        static readonly FIXED_EQUIRECTANGULAR_MODE: number;
        /** Equirectangular Fixed Mirrored coordinates mode */
        static readonly FIXED_EQUIRECTANGULAR_MIRRORED_MODE: number;
        /** Texture is not repeating outside of 0..1 UVs */
        static readonly CLAMP_ADDRESSMODE: number;
        /** Texture is repeating outside of 0..1 UVs */
        static readonly WRAP_ADDRESSMODE: number;
        /** Texture is repeating and mirrored */
        static readonly MIRROR_ADDRESSMODE: number;
        /**
         * Gets or sets a boolean which defines if the texture url must be build from the serialized URL instead of just using the name and loading them side by side with the scene file
         */
        static UseSerializedUrlIfAny: boolean;
        /**
         * Define the url of the texture.
         */
        url: Nullable<string>;
        /**
         * Define an offset on the texture to offset the u coordinates of the UVs
         * @see https://doc.babylonjs.com/how_to/more_materials#offsetting
         */
        uOffset: number;
        /**
         * Define an offset on the texture to offset the v coordinates of the UVs
         * @see https://doc.babylonjs.com/how_to/more_materials#offsetting
         */
        vOffset: number;
        /**
         * Define an offset on the texture to scale the u coordinates of the UVs
         * @see https://doc.babylonjs.com/how_to/more_materials#tiling
         */
        uScale: number;
        /**
         * Define an offset on the texture to scale the v coordinates of the UVs
         * @see https://doc.babylonjs.com/how_to/more_materials#tiling
         */
        vScale: number;
        /**
         * Define an offset on the texture to rotate around the u coordinates of the UVs
         * @see https://doc.babylonjs.com/how_to/more_materials
         */
        uAng: number;
        /**
         * Define an offset on the texture to rotate around the v coordinates of the UVs
         * @see https://doc.babylonjs.com/how_to/more_materials
         */
        vAng: number;
        /**
         * Define an offset on the texture to rotate around the w coordinates of the UVs (in case of 3d texture)
         * @see https://doc.babylonjs.com/how_to/more_materials
         */
        wAng: number;
        /**
         * Defines the center of rotation (U)
         */
        uRotationCenter: number;
        /**
         * Defines the center of rotation (V)
         */
        vRotationCenter: number;
        /**
         * Defines the center of rotation (W)
         */
        wRotationCenter: number;
        /**
         * Are mip maps generated for this texture or not.
         */
        get noMipmap(): boolean;
        /**
         * List of inspectable custom properties (used by the Inspector)
         * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility
         */
        inspectableCustomProperties: Nullable<IInspectable[]>;
        private _noMipmap;
        /** @hidden */
        _invertY: boolean;
        private _rowGenerationMatrix;
        private _cachedTextureMatrix;
        private _projectionModeMatrix;
        private _t0;
        private _t1;
        private _t2;
        private _cachedUOffset;
        private _cachedVOffset;
        private _cachedUScale;
        private _cachedVScale;
        private _cachedUAng;
        private _cachedVAng;
        private _cachedWAng;
        private _cachedProjectionMatrixId;
        private _cachedCoordinatesMode;
        /** @hidden */
        protected _initialSamplingMode: number;
        /** @hidden */
        _buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap>;
        private _deleteBuffer;
        protected _format: Nullable<number>;
        private _delayedOnLoad;
        private _delayedOnError;
        private _mimeType?;
        /** Returns the texture mime type if it was defined by a loader (undefined else) */
        get mimeType(): string | undefined;
        /**
         * Observable triggered once the texture has been loaded.
         */
        onLoadObservable: Observable<Texture>;
        protected _isBlocking: boolean;
        /**
         * Is the texture preventing material to render while loading.
         * If false, a default texture will be used instead of the loading one during the preparation step.
         */
        set isBlocking(value: boolean);
        get isBlocking(): boolean;
        /**
         * Get the current sampling mode associated with the texture.
         */
        get samplingMode(): number;
        /**
         * Gets a boolean indicating if the texture needs to be inverted on the y axis during loading
         */
        get invertY(): boolean;
        /**
         * Instantiates a new texture.
         * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.
         * @see https://doc.babylonjs.com/babylon101/materials#texture
         * @param url defines the url of the picture to load as a texture
         * @param sceneOrEngine defines the scene or engine the texture will belong to
         * @param noMipmap defines if the texture will require mip maps or not
         * @param invertY defines if the texture needs to be inverted on the y axis during loading
         * @param samplingMode defines the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)
         * @param onLoad defines a callback triggered when the texture has been loaded
         * @param onError defines a callback triggered when an error occurred during the loading session
         * @param buffer defines the buffer to load the texture from in case the texture is loaded from a buffer representation
         * @param deleteBuffer defines if the buffer we are loading the texture from should be deleted after load
         * @param format defines the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)
         * @param mimeType defines an optional mime type information
         */
        constructor(url: Nullable<string>, sceneOrEngine: Nullable<Scene | ThinEngine>, noMipmap?: boolean, invertY?: boolean, samplingMode?: number, onLoad?: Nullable<() => void>, onError?: Nullable<(message?: string, exception?: any) => void>, buffer?: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap>, deleteBuffer?: boolean, format?: number, mimeType?: string);
        /**
         * Update the url (and optional buffer) of this texture if url was null during construction.
         * @param url the url of the texture
         * @param buffer the buffer of the texture (defaults to null)
         * @param onLoad callback called when the texture is loaded  (defaults to null)
         */
        updateURL(url: string, buffer?: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob>, onLoad?: () => void): void;
        /**
         * Finish the loading sequence of a texture flagged as delayed load.
         * @hidden
         */
        delayLoad(): void;
        private _prepareRowForTextureGeneration;
        /**
         * Get the current texture matrix which includes the requested offsetting, tiling and rotation components.
         * @returns the transform matrix of the texture.
         */
        getTextureMatrix(uBase?: number): Matrix;
        /**
         * Get the current matrix used to apply reflection. This is useful to rotate an environment texture for instance.
         * @returns The reflection texture transform
         */
        getReflectionTextureMatrix(): Matrix;
        /**
         * Clones the texture.
         * @returns the cloned texture
         */
        clone(): Texture;
        /**
         * Serialize the texture to a JSON representation we can easily use in the resepective Parse function.
         * @returns The JSON representation of the texture
         */
        serialize(): any;
        /**
         * Get the current class name of the texture useful for serialization or dynamic coding.
         * @returns "Texture"
         */
        getClassName(): string;
        /**
         * Dispose the texture and release its associated resources.
         */
        dispose(): void;
        /**
         * Parse the JSON representation of a texture in order to recreate the texture in the given scene.
         * @param parsedTexture Define the JSON representation of the texture
         * @param scene Define the scene the parsed texture should be instantiated in
         * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies
         * @returns The parsed texture if successful
         */
        static Parse(parsedTexture: any, scene: Scene, rootUrl: string): Nullable<BaseTexture>;
        /**
         * Creates a texture from its base 64 representation.
         * @param data Define the base64 payload without the data: prefix
         * @param name Define the name of the texture in the scene useful fo caching purpose for instance
         * @param scene Define the scene the texture should belong to
         * @param noMipmap Forces the texture to not create mip map information if true
         * @param invertY define if the texture needs to be inverted on the y axis during loading
         * @param samplingMode define the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)
         * @param onLoad define a callback triggered when the texture has been loaded
         * @param onError define a callback triggered when an error occurred during the loading session
         * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)
         * @returns the created texture
         */
        static CreateFromBase64String(data: string, name: string, scene: Scene, noMipmap?: boolean, invertY?: boolean, samplingMode?: number, onLoad?: Nullable<() => void>, onError?: Nullable<() => void>, format?: number): Texture;
        /**
         * Creates a texture from its data: representation. (data: will be added in case only the payload has been passed in)
         * @param data Define the base64 payload without the data: prefix
         * @param name Define the name of the texture in the scene useful fo caching purpose for instance
         * @param buffer define the buffer to load the texture from in case the texture is loaded from a buffer representation
         * @param scene Define the scene the texture should belong to
         * @param deleteBuffer define if the buffer we are loading the texture from should be deleted after load
         * @param noMipmap Forces the texture to not create mip map information if true
         * @param invertY define if the texture needs to be inverted on the y axis during loading
         * @param samplingMode define the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)
         * @param onLoad define a callback triggered when the texture has been loaded
         * @param onError define a callback triggered when an error occurred during the loading session
         * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)
         * @returns the created texture
         */
        static LoadFromDataString(name: string, buffer: any, scene: Scene, deleteBuffer?: boolean, noMipmap?: boolean, invertY?: boolean, samplingMode?: number, onLoad?: Nullable<() => void>, onError?: Nullable<(message?: string, exception?: any) => void>, format?: number): Texture;
    }
}
declare module BABYLON {
    /**
     * PostProcessManager is used to manage one or more post processes or post process pipelines
     * See https://doc.babylonjs.com/how_to/how_to_use_postprocesses
     */
    export class PostProcessManager {
        private _scene;
        private _indexBuffer;
        private _vertexBuffers;
        /**
         * Creates a new instance PostProcess
         * @param scene The scene that the post process is associated with.
         */
        constructor(scene: Scene);
        private _prepareBuffers;
        private _buildIndexBuffer;
        /**
         * Rebuilds the vertex buffers of the manager.
         * @hidden
         */
        _rebuild(): void;
        /**
         * Prepares a frame to be run through a post process.
         * @param sourceTexture The input texture to the post procesess. (default: null)
         * @param postProcesses An array of post processes to be run. (default: null)
         * @returns True if the post processes were able to be run.
         * @hidden
         */
        _prepareFrame(sourceTexture?: Nullable<InternalTexture>, postProcesses?: Nullable<PostProcess[]>): boolean;
        /**
         * Manually render a set of post processes to a texture.
         * Please note, the frame buffer won't be unbound after the call in case you have more render to do.
         * @param postProcesses An array of post processes to be run.
         * @param targetTexture The target texture to render to.
         * @param forceFullscreenViewport force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight
         * @param faceIndex defines the face to render to if a cubemap is defined as the target
         * @param lodLevel defines which lod of the texture to render to
         * @param doNotBindFrambuffer If set to true, assumes that the framebuffer has been bound previously
         */
        directRender(postProcesses: PostProcess[], targetTexture?: Nullable<InternalTexture>, forceFullscreenViewport?: boolean, faceIndex?: number, lodLevel?: number, doNotBindFrambuffer?: boolean): void;
        /**
         * Finalize the result of the output of the postprocesses.
         * @param doNotPresent If true the result will not be displayed to the screen.
         * @param targetTexture The target texture to render to.
         * @param faceIndex The index of the face to bind the target texture to.
         * @param postProcesses The array of post processes to render.
         * @param forceFullscreenViewport force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight (default: false)
         * @hidden
         */
        _finalizeFrame(doNotPresent?: boolean, targetTexture?: InternalTexture, faceIndex?: number, postProcesses?: Array<PostProcess>, forceFullscreenViewport?: boolean): void;
        /**
         * Disposes of the post process manager.
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * This Helps creating a texture that will be created from a camera in your scene.
     * It is basically a dynamic texture that could be used to create special effects for instance.
     * Actually, It is the base of lot of effects in the framework like post process, shadows, effect layers and rendering pipelines...
     */
    export class RenderTargetTexture extends Texture {
        /**
         * The texture will only be rendered once which can be useful to improve performance if everything in your render is static for instance.
         */
        static readonly REFRESHRATE_RENDER_ONCE: number;
        /**
         * The texture will only be rendered rendered every frame and is recomended for dynamic contents.
         */
        static readonly REFRESHRATE_RENDER_ONEVERYFRAME: number;
        /**
         * The texture will be rendered every 2 frames which could be enough if your dynamic objects are not
         * the central point of your effect and can save a lot of performances.
         */
        static readonly REFRESHRATE_RENDER_ONEVERYTWOFRAMES: number;
        /**
        * Use this predicate to dynamically define the list of mesh you want to render.
        * If set, the renderList property will be overwritten.
        */
        renderListPredicate: (AbstractMesh: AbstractMesh) => boolean;
        private _renderList;
        /**
        * Use this list to define the list of mesh you want to render.
        */
        get renderList(): Nullable<Array<AbstractMesh>>;
        set renderList(value: Nullable<Array<AbstractMesh>>);
        /**
         * Use this function to overload the renderList array at rendering time.
         * Return null to render with the curent renderList, else return the list of meshes to use for rendering.
         * For 2DArray RTT, layerOrFace is the index of the layer that is going to be rendered, else it is the faceIndex of
         * the cube (if the RTT is a cube, else layerOrFace=0).
         * The renderList passed to the function is the current render list (the one that will be used if the function returns null).
         * The length of this list is passed through renderListLength: don't use renderList.length directly because the array can
         * hold dummy elements!
        */
        getCustomRenderList: (layerOrFace: number, renderList: Nullable<Immutable<Array<AbstractMesh>>>, renderListLength: number) => Nullable<Array<AbstractMesh>>;
        private _hookArray;
        /**
         * Define if particles should be rendered in your texture.
         */
        renderParticles: boolean;
        /**
         * Define if sprites should be rendered in your texture.
         */
        renderSprites: boolean;
        /**
         * Define the camera used to render the texture.
         */
        activeCamera: Nullable<Camera>;
        /**
         * Override the mesh isReady function with your own one.
         */
        customIsReadyFunction: (mesh: AbstractMesh, refreshRate: number) => boolean;
        /**
         * Override the render function of the texture with your own one.
         */
        customRenderFunction: (opaqueSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>, beforeTransparents?: () => void) => void;
        /**
         * Define if camera post processes should be use while rendering the texture.
         */
        useCameraPostProcesses: boolean;
        /**
         * Define if the camera viewport should be respected while rendering the texture or if the render should be done to the entire texture.
         */
        ignoreCameraViewport: boolean;
        private _postProcessManager;
        private _postProcesses;
        private _resizeObserver;
        /**
        * An event triggered when the texture is unbind.
        */
        onBeforeBindObservable: Observable<RenderTargetTexture>;
        /**
        * An event triggered when the texture is unbind.
        */
        onAfterUnbindObservable: Observable<RenderTargetTexture>;
        private _onAfterUnbindObserver;
        /**
         * Set a after unbind callback in the texture.
         * This has been kept for backward compatibility and use of onAfterUnbindObservable is recommended.
         */
        set onAfterUnbind(callback: () => void);
        /**
        * An event triggered before rendering the texture
        */
        onBeforeRenderObservable: Observable<number>;
        private _onBeforeRenderObserver;
        /**
         * Set a before render callback in the texture.
         * This has been kept for backward compatibility and use of onBeforeRenderObservable is recommended.
         */
        set onBeforeRender(callback: (faceIndex: number) => void);
        /**
        * An event triggered after rendering the texture
        */
        onAfterRenderObservable: Observable<number>;
        private _onAfterRenderObserver;
        /**
         * Set a after render callback in the texture.
         * This has been kept for backward compatibility and use of onAfterRenderObservable is recommended.
         */
        set onAfterRender(callback: (faceIndex: number) => void);
        /**
        * An event triggered after the texture clear
        */
        onClearObservable: Observable<Engine>;
        private _onClearObserver;
        /**
         * Set a clear callback in the texture.
         * This has been kept for backward compatibility and use of onClearObservable is recommended.
         */
        set onClear(callback: (Engine: Engine) => void);
        /**
         * An event triggered when the texture is resized.
         */
        onResizeObservable: Observable<RenderTargetTexture>;
        /**
         * Define the clear color of the Render Target if it should be different from the scene.
         */
        clearColor: Color4;
        protected _size: number | {
            width: number;
            height: number;
            layers?: number;
        };
        protected _initialSizeParameter: number | {
            width: number;
            height: number;
        } | {
            ratio: number;
        };
        protected _sizeRatio: Nullable<number>;
        /** @hidden */
        _generateMipMaps: boolean;
        protected _renderingManager: RenderingManager;
        /** @hidden */
        _waitingRenderList?: string[];
        protected _doNotChangeAspectRatio: boolean;
        protected _currentRefreshId: number;
        protected _refreshRate: number;
        protected _textureMatrix: Matrix;
        protected _samples: number;
        protected _renderTargetOptions: RenderTargetCreationOptions;
        /**
         * Gets render target creation options that were used.
         */
        get renderTargetOptions(): RenderTargetCreationOptions;
        protected _onRatioRescale(): void;
        /**
         * Gets or sets the center of the bounding box associated with the texture (when in cube mode)
         * It must define where the camera used to render the texture is set
         */
        boundingBoxPosition: Vector3;
        private _boundingBoxSize;
        /**
         * Gets or sets the size of the bounding box associated with the texture (when in cube mode)
         * When defined, the cubemap will switch to local mode
         * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity
         * @example https://www.babylonjs-playground.com/#RNASML
         */
        set boundingBoxSize(value: Vector3);
        get boundingBoxSize(): Vector3;
        /**
         * In case the RTT has been created with a depth texture, get the associated
         * depth texture.
         * Otherwise, return null.
         */
        get depthStencilTexture(): Nullable<InternalTexture>;
        /**
         * Instantiate a render target texture. This is mainly used to render of screen the scene to for instance apply post processse
         * or used a shadow, depth texture...
         * @param name The friendly name of the texture
         * @param size The size of the RTT (number if square, or {width: number, height:number} or {ratio:} to define a ratio from the main scene)
         * @param scene The scene the RTT belongs to. The latest created scene will be used if not precised.
         * @param generateMipMaps True if mip maps need to be generated after render.
         * @param doNotChangeAspectRatio True to not change the aspect ratio of the scene in the RTT
         * @param type The type of the buffer in the RTT (int, half float, float...)
         * @param isCube True if a cube texture needs to be created
         * @param samplingMode The sampling mode to be usedwith the render target (Linear, Nearest...)
         * @param generateDepthBuffer True to generate a depth buffer
         * @param generateStencilBuffer True to generate a stencil buffer
         * @param isMulti True if multiple textures need to be created (Draw Buffers)
         * @param format The internal format of the buffer in the RTT (RED, RG, RGB, RGBA, ALPHA...)
         * @param delayAllocation if the texture allocation should be delayed (default: false)
         */
        constructor(name: string, size: number | {
            width: number;
            height: number;
            layers?: number;
        } | {
            ratio: number;
        }, scene: Nullable<Scene>, generateMipMaps?: boolean, doNotChangeAspectRatio?: boolean, type?: number, isCube?: boolean, samplingMode?: number, generateDepthBuffer?: boolean, generateStencilBuffer?: boolean, isMulti?: boolean, format?: number, delayAllocation?: boolean);
        /**
         * Creates a depth stencil texture.
         * This is only available in WebGL 2 or with the depth texture extension available.
         * @param comparisonFunction Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode
         * @param bilinearFiltering Specifies whether or not bilinear filtering is enable on the texture
         * @param generateStencil Specifies whether or not a stencil should be allocated in the texture
         */
        createDepthStencilTexture(comparisonFunction?: number, bilinearFiltering?: boolean, generateStencil?: boolean): void;
        private _processSizeParameter;
        /**
         * Define the number of samples to use in case of MSAA.
         * It defaults to one meaning no MSAA has been enabled.
         */
        get samples(): number;
        set samples(value: number);
        /**
         * Resets the refresh counter of the texture and start bak from scratch.
         * Could be useful to regenerate the texture if it is setup to render only once.
         */
        resetRefreshCounter(): void;
        /**
         * Define the refresh rate of the texture or the rendering frequency.
         * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...
         */
        get refreshRate(): number;
        set refreshRate(value: number);
        /**
         * Adds a post process to the render target rendering passes.
         * @param postProcess define the post process to add
         */
        addPostProcess(postProcess: PostProcess): void;
        /**
         * Clear all the post processes attached to the render target
         * @param dispose define if the cleared post processesshould also be disposed (false by default)
         */
        clearPostProcesses(dispose?: boolean): void;
        /**
         * Remove one of the post process from the list of attached post processes to the texture
         * @param postProcess define the post process to remove from the list
         */
        removePostProcess(postProcess: PostProcess): void;
        /** @hidden */
        _shouldRender(): boolean;
        /**
         * Gets the actual render size of the texture.
         * @returns the width of the render size
         */
        getRenderSize(): number;
        /**
         * Gets the actual render width of the texture.
         * @returns the width of the render size
         */
        getRenderWidth(): number;
        /**
         * Gets the actual render height of the texture.
         * @returns the height of the render size
         */
        getRenderHeight(): number;
        /**
         * Gets the actual number of layers of the texture.
         * @returns the number of layers
         */
        getRenderLayers(): number;
        /**
         * Get if the texture can be rescaled or not.
         */
        get canRescale(): boolean;
        /**
         * Resize the texture using a ratio.
         * @param ratio the ratio to apply to the texture size in order to compute the new target size
         */
        scale(ratio: number): void;
        /**
         * Get the texture reflection matrix used to rotate/transform the reflection.
         * @returns the reflection matrix
         */
        getReflectionTextureMatrix(): Matrix;
        /**
         * Resize the texture to a new desired size.
         * Be carrefull as it will recreate all the data in the new texture.
         * @param size Define the new size. It can be:
         *   - a number for squared texture,
         *   - an object containing { width: number, height: number }
         *   - or an object containing a ratio { ratio: number }
         */
        resize(size: number | {
            width: number;
            height: number;
        } | {
            ratio: number;
        }): void;
        private _defaultRenderListPrepared;
        /**
         * Renders all the objects from the render list into the texture.
         * @param useCameraPostProcess Define if camera post processes should be used during the rendering
         * @param dumpForDebug Define if the rendering result should be dumped (copied) for debugging purpose
         */
        render(useCameraPostProcess?: boolean, dumpForDebug?: boolean): void;
        private _bestReflectionRenderTargetDimension;
        private _prepareRenderingManager;
        /**
         * @hidden
         * @param faceIndex face index to bind to if this is a cubetexture
         * @param layer defines the index of the texture to bind in the array
         */
        _bindFrameBuffer(faceIndex?: number, layer?: number): void;
        protected unbindFrameBuffer(engine: Engine, faceIndex: number): void;
        private renderToTarget;
        /**
         * Overrides the default sort function applied in the renderging group to prepare the meshes.
         * This allowed control for front to back rendering or reversly depending of the special needs.
         *
         * @param renderingGroupId The rendering group id corresponding to its index
         * @param opaqueSortCompareFn The opaque queue comparison function use to sort.
         * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.
         * @param transparentSortCompareFn The transparent queue comparison function use to sort.
         */
        setRenderingOrder(renderingGroupId: number, opaqueSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>, alphaTestSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>, transparentSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>): void;
        /**
         * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
         *
         * @param renderingGroupId The rendering group id corresponding to its index
         * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
         */
        setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean): void;
        /**
         * Clones the texture.
         * @returns the cloned texture
         */
        clone(): RenderTargetTexture;
        /**
         * Serialize the texture to a JSON representation we can easily use in the resepective Parse function.
         * @returns The JSON representation of the texture
         */
        serialize(): any;
        /**
         *  This will remove the attached framebuffer objects. The texture will not be able to be used as render target anymore
         */
        disposeFramebufferObjects(): void;
        /**
         * Dispose the texture and release its associated resources.
         */
        dispose(): void;
        /** @hidden */
        _rebuild(): void;
        /**
         * Clear the info related to rendering groups preventing retention point in material dispose.
         */
        freeRenderingGroups(): void;
        /**
         * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)
         * @returns the view count
         */
        getViewCount(): number;
    }
}
declare module BABYLON {
    /**
     * Class used to manipulate GUIDs
     */
    export class GUID {
        /**
         * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
         * Be aware Math.random() could cause collisions, but:
         * "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
         * @returns a pseudo random id
         */
        static RandomId(): string;
    }
}
declare module BABYLON {
    /**
     * Options to be used when creating a shadow depth material
     */
    export interface IIOptionShadowDepthMaterial {
        /** Variables in the vertex shader code that need to have their names remapped.
         * The format is: ["var_name", "var_remapped_name", "var_name", "var_remapped_name", ...]
         * "var_name" should be either: worldPos or vNormalW
         * So, if the variable holding the world position in your vertex shader is not named worldPos, you must tell the system
         * the name to use instead by using: ["worldPos", "myWorldPosVar"] assuming the variable is named myWorldPosVar in your code.
         * If the normal must also be remapped: ["worldPos", "myWorldPosVar", "vNormalW", "myWorldNormal"]
        */
        remappedVariables?: string[];
        /** Set standalone to true if the base material wrapped by ShadowDepthMaterial is not used for a regular object but for depth shadow generation only */
        standalone?: boolean;
    }
    /**
     * Class that can be used to wrap a base material to generate accurate shadows when using custom vertex/fragment code in the base material
     */
    export class ShadowDepthWrapper {
        private _scene;
        private _options?;
        private _baseMaterial;
        private _onEffectCreatedObserver;
        private _subMeshToEffect;
        private _subMeshToDepthEffect;
        private _meshes;
        /** @hidden */
        _matriceNames: any;
        /** Gets the standalone status of the wrapper */
        get standalone(): boolean;
        /** Gets the base material the wrapper is built upon */
        get baseMaterial(): Material;
        /**
         * Instantiate a new shadow depth wrapper.
         * It works by injecting some specific code in the vertex/fragment shaders of the base material and is used by a shadow generator to
         * generate the shadow depth map. For more information, please refer to the documentation:
         * https://doc.babylonjs.com/babylon101/shadows
         * @param baseMaterial Material to wrap
         * @param scene Define the scene the material belongs to
         * @param options Options used to create the wrapper
         */
        constructor(baseMaterial: Material, scene: Scene, options?: IIOptionShadowDepthMaterial);
        /**
         * Gets the effect to use to generate the depth map
         * @param subMesh subMesh to get the effect for
         * @param shadowGenerator shadow generator to get the effect for
         * @returns the effect to use to generate the depth map for the subMesh + shadow generator specified
         */
        getEffect(subMesh: Nullable<SubMesh>, shadowGenerator: ShadowGenerator): Nullable<Effect>;
        /**
         * Specifies that the submesh is ready to be used for depth rendering
         * @param subMesh submesh to check
         * @param defines the list of defines to take into account when checking the effect
         * @param shadowGenerator combined with subMesh, it defines the effect to check
         * @param useInstances specifies that instances should be used
         * @returns a boolean indicating that the submesh is ready or not
         */
        isReadyForSubMesh(subMesh: SubMesh, defines: string[], shadowGenerator: ShadowGenerator, useInstances: boolean): boolean;
        /**
         * Disposes the resources
         */
        dispose(): void;
        private _makeEffect;
    }
}
declare module BABYLON {
        interface ThinEngine {
            /**
             * Unbind a list of render target textures from the webGL context
             * This is used only when drawBuffer extension or webGL2 are active
             * @param textures defines the render target textures to unbind
             * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated
             * @param onBeforeUnbind defines a function which will be called before the effective unbind
             */
            unBindMultiColorAttachmentFramebuffer(textures: InternalTexture[], disableGenerateMipMaps: boolean, onBeforeUnbind?: () => void): void;
            /**
             * Create a multi render target texture
             * @see https://doc.babylonjs.com/features/webgl2#multiple-render-target
             * @param size defines the size of the texture
             * @param options defines the creation options
             * @returns the cube texture as an InternalTexture
             */
            createMultipleRenderTarget(size: any, options: IMultiRenderTargetOptions): InternalTexture[];
            /**
             * Update the sample count for a given multiple render target texture
             * @see https://doc.babylonjs.com/features/webgl2#multisample-render-targets
             * @param textures defines the textures to update
             * @param samples defines the sample count to set
             * @returns the effective sample count (could be 0 if multisample render targets are not supported)
             */
            updateMultipleRenderTargetTextureSampleCount(textures: Nullable<InternalTexture[]>, samples: number): number;
            /**
             * Select a subsets of attachments to draw to.
             * @param attachments gl attachments
             */
            bindAttachments(attachments: number[]): void;
        }
}
declare module BABYLON {
    /**
     * Creation options of the multi render target texture.
     */
    export interface IMultiRenderTargetOptions {
        /**
         * Define if the texture needs to create mip maps after render.
         */
        generateMipMaps?: boolean;
        /**
         * Define the types of all the draw buffers we want to create
         */
        types?: number[];
        /**
         * Define the sampling modes of all the draw buffers we want to create
         */
        samplingModes?: number[];
        /**
         * Define if a depth buffer is required
         */
        generateDepthBuffer?: boolean;
        /**
         * Define if a stencil buffer is required
         */
        generateStencilBuffer?: boolean;
        /**
         * Define if a depth texture is required instead of a depth buffer
         */
        generateDepthTexture?: boolean;
        /**
         * Define the number of desired draw buffers
         */
        textureCount?: number;
        /**
         * Define if aspect ratio should be adapted to the texture or stay the scene one
         */
        doNotChangeAspectRatio?: boolean;
        /**
         * Define the default type of the buffers we are creating
         */
        defaultType?: number;
    }
    /**
     * A multi render target, like a render target provides the ability to render to a texture.
     * Unlike the render target, it can render to several draw buffers in one draw.
     * This is specially interesting in deferred rendering or for any effects requiring more than
     * just one color from a single pass.
     */
    export class MultiRenderTarget extends RenderTargetTexture {
        private _internalTextures;
        private _textures;
        private _multiRenderTargetOptions;
        private _count;
        /**
         * Get if draw buffers are currently supported by the used hardware and browser.
         */
        get isSupported(): boolean;
        /**
         * Get the list of textures generated by the multi render target.
         */
        get textures(): Texture[];
        /**
         * Gets the number of textures in this MRT. This number can be different from `_textures.length` in case a depth texture is generated.
         */
        get count(): number;
        /**
         * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set
         */
        get depthTexture(): Texture;
        /**
         * Set the wrapping mode on U of all the textures we are rendering to.
         * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)
         */
        set wrapU(wrap: number);
        /**
         * Set the wrapping mode on V of all the textures we are rendering to.
         * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)
         */
        set wrapV(wrap: number);
        /**
         * Instantiate a new multi render target texture.
         * A multi render target, like a render target provides the ability to render to a texture.
         * Unlike the render target, it can render to several draw buffers in one draw.
         * This is specially interesting in deferred rendering or for any effects requiring more than
         * just one color from a single pass.
         * @param name Define the name of the texture
         * @param size Define the size of the buffers to render to
         * @param count Define the number of target we are rendering into
         * @param scene Define the scene the texture belongs to
         * @param options Define the options used to create the multi render target
         */
        constructor(name: string, size: any, count: number, scene: Scene, options?: IMultiRenderTargetOptions);
        /** @hidden */
        _rebuild(): void;
        private _createInternalTextures;
        private _createTextures;
        /**
         * Define the number of samples used if MSAA is enabled.
         */
        get samples(): number;
        set samples(value: number);
        /**
         * Resize all the textures in the multi render target.
         * Be carrefull as it will recreate all the data in the new texture.
         * @param size Define the new size
         */
        resize(size: any): void;
        protected unbindFrameBuffer(engine: Engine, faceIndex: number): void;
        /**
         * Dispose the render targets and their associated resources
         */
        dispose(): void;
        /**
         * Release all the underlying texture used as draw buffers.
         */
        releaseInternalTextures(): void;
    }
}
declare module BABYLON {
    /** @hidden */
    export var imageProcessingPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * ImageProcessingPostProcess
     * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#imageprocessing
     */
    export class ImageProcessingPostProcess extends PostProcess {
        /**
         * Default configuration related to image processing available in the PBR Material.
         */
        protected _imageProcessingConfiguration: ImageProcessingConfiguration;
        /**
         * Gets the image processing configuration used either in this material.
         */
        get imageProcessingConfiguration(): ImageProcessingConfiguration;
        /**
         * Sets the Default image processing configuration used either in the this material.
         *
         * If sets to null, the scene one is in use.
         */
        set imageProcessingConfiguration(value: ImageProcessingConfiguration);
        /**
         * Keep track of the image processing observer to allow dispose and replace.
         */
        private _imageProcessingObserver;
        /**
         * Attaches a new image processing configuration to the PBR Material.
         * @param configuration
         */
        protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>, doNotBuild?: boolean): void;
        /**
         * If the post process is supported.
         */
        get isSupported(): boolean;
        /**
         * Gets Color curves setup used in the effect if colorCurvesEnabled is set to true .
         */
        get colorCurves(): Nullable<ColorCurves>;
        /**
         * Sets Color curves setup used in the effect if colorCurvesEnabled is set to true .
         */
        set colorCurves(value: Nullable<ColorCurves>);
        /**
         * Gets wether the color curves effect is enabled.
         */
        get colorCurvesEnabled(): boolean;
        /**
         * Sets wether the color curves effect is enabled.
         */
        set colorCurvesEnabled(value: boolean);
        /**
         * Gets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.
         */
        get colorGradingTexture(): Nullable<BaseTexture>;
        /**
         * Sets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.
         */
        set colorGradingTexture(value: Nullable<BaseTexture>);
        /**
         * Gets wether the color grading effect is enabled.
         */
        get colorGradingEnabled(): boolean;
        /**
         * Gets wether the color grading effect is enabled.
         */
        set colorGradingEnabled(value: boolean);
        /**
         * Gets exposure used in the effect.
         */
        get exposure(): number;
        /**
         * Sets exposure used in the effect.
         */
        set exposure(value: number);
        /**
         * Gets wether tonemapping is enabled or not.
         */
        get toneMappingEnabled(): boolean;
        /**
         * Sets wether tonemapping is enabled or not
         */
        set toneMappingEnabled(value: boolean);
        /**
         * Gets the type of tone mapping effect.
         */
        get toneMappingType(): number;
        /**
         * Sets the type of tone mapping effect.
         */
        set toneMappingType(value: number);
        /**
         * Gets contrast used in the effect.
         */
        get contrast(): number;
        /**
         * Sets contrast used in the effect.
         */
        set contrast(value: number);
        /**
         * Gets Vignette stretch size.
         */
        get vignetteStretch(): number;
        /**
         * Sets Vignette stretch size.
         */
        set vignetteStretch(value: number);
        /**
         * Gets Vignette centre X Offset.
         */
        get vignetteCentreX(): number;
        /**
         * Sets Vignette centre X Offset.
         */
        set vignetteCentreX(value: number);
        /**
         * Gets Vignette centre Y Offset.
         */
        get vignetteCentreY(): number;
        /**
         * Sets Vignette centre Y Offset.
         */
        set vignetteCentreY(value: number);
        /**
         * Gets Vignette weight or intensity of the vignette effect.
         */
        get vignetteWeight(): number;
        /**
         * Sets Vignette weight or intensity of the vignette effect.
         */
        set vignetteWeight(value: number);
        /**
         * Gets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
         * if vignetteEnabled is set to true.
         */
        get vignetteColor(): Color4;
        /**
         * Sets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
         * if vignetteEnabled is set to true.
         */
        set vignetteColor(value: Color4);
        /**
         * Gets Camera field of view used by the Vignette effect.
         */
        get vignetteCameraFov(): number;
        /**
         * Sets Camera field of view used by the Vignette effect.
         */
        set vignetteCameraFov(value: number);
        /**
         * Gets the vignette blend mode allowing different kind of effect.
         */
        get vignetteBlendMode(): number;
        /**
         * Sets the vignette blend mode allowing different kind of effect.
         */
        set vignetteBlendMode(value: number);
        /**
         * Gets wether the vignette effect is enabled.
         */
        get vignetteEnabled(): boolean;
        /**
         * Sets wether the vignette effect is enabled.
         */
        set vignetteEnabled(value: boolean);
        private _fromLinearSpace;
        /**
         * Gets wether the input of the processing is in Gamma or Linear Space.
         */
        get fromLinearSpace(): boolean;
        /**
         * Sets wether the input of the processing is in Gamma or Linear Space.
         */
        set fromLinearSpace(value: boolean);
        /**
         * Defines cache preventing GC.
         */
        private _defines;
        constructor(name: string, options: number | PostProcessOptions, camera?: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, imageProcessingConfiguration?: ImageProcessingConfiguration);
        /**
         *  "ImageProcessingPostProcess"
         * @returns "ImageProcessingPostProcess"
         */
        getClassName(): string;
        /**
         * @hidden
         */
        _updateParameters(): void;
        dispose(camera?: Camera): void;
    }
}
declare module BABYLON {
    /** @hidden */
    export var fibonacci: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var subSurfaceScatteringFunctions: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var diffusionProfile: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var subSurfaceScatteringPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Sub surface scattering post process
     */
    export class SubSurfaceScatteringPostProcess extends PostProcess {
        /**
         * Gets a string identifying the name of the class
         * @returns "SubSurfaceScatteringPostProcess" string
         */
        getClassName(): string;
        constructor(name: string, scene: Scene, options: number | PostProcessOptions, camera?: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number);
    }
}
declare module BABYLON {
    /**
     * Interface for defining prepass effects in the prepass post-process pipeline
     */
    export interface PrePassEffectConfiguration {
        /**
         * Post process to attach for this effect
         */
        postProcess: PostProcess;
        /**
         * Is the effect enabled
         */
        enabled: boolean;
        /**
         * Disposes the effect configuration
         */
        dispose(): void;
        /**
         * Disposes the effect configuration
         */
        createPostProcess: () => PostProcess;
    }
}
declare module BABYLON {
    /**
     * Contains all parameters needed for the prepass to perform
     * screen space subsurface scattering
     */
    export class SubSurfaceConfiguration implements PrePassEffectConfiguration {
        private _ssDiffusionS;
        private _ssFilterRadii;
        private _ssDiffusionD;
        /**
         * Post process to attach for screen space subsurface scattering
         */
        postProcess: SubSurfaceScatteringPostProcess;
        /**
         * Diffusion profile color for subsurface scattering
         */
        get ssDiffusionS(): number[];
        /**
         * Diffusion profile max color channel value for subsurface scattering
         */
        get ssDiffusionD(): number[];
        /**
         * Diffusion profile filter radius for subsurface scattering
         */
        get ssFilterRadii(): number[];
        /**
         * Is subsurface enabled
         */
        enabled: boolean;
        /**
         * Diffusion profile colors for subsurface scattering
         * You can add one diffusion color using `addDiffusionProfile` on `scene.prePassRenderer`
         * See ...
         * Note that you can only store up to 5 of them
         */
        ssDiffusionProfileColors: Color3[];
        /**
         * Defines the ratio real world => scene units.
         * Used for subsurface scattering
         */
        metersPerUnit: number;
        private _scene;
        /**
         * Builds a subsurface configuration object
         * @param scene The scene
         */
        constructor(scene: Scene);
        /**
         * Adds a new diffusion profile.
         * Useful for more realistic subsurface scattering on diverse materials.
         * @param color The color of the diffusion profile. Should be the average color of the material.
         * @return The index of the diffusion profile for the material subsurface configuration
         */
        addDiffusionProfile(color: Color3): number;
        /**
         * Creates the sss post process
         * @return The created post process
         */
        createPostProcess(): SubSurfaceScatteringPostProcess;
        /**
         * Deletes all diffusion profiles.
         * Note that in order to render subsurface scattering, you should have at least 1 diffusion profile.
         */
        clearAllDiffusionProfiles(): void;
        /**
         * Disposes this object
         */
        dispose(): void;
        /**
         * @hidden
         * https://zero-radiance.github.io/post/sampling-diffusion/
         *
         * Importance sample the normalized diffuse reflectance profile for the computed value of 's'.
         * ------------------------------------------------------------------------------------
         * R[r, phi, s]   = s * (Exp[-r * s] + Exp[-r * s / 3]) / (8 * Pi * r)
         * PDF[r, phi, s] = r * R[r, phi, s]
         * CDF[r, s]      = 1 - 1/4 * Exp[-r * s] - 3/4 * Exp[-r * s / 3]
         * ------------------------------------------------------------------------------------
         * We importance sample the color channel with the widest scattering distance.
         */
        getDiffusionProfileParameters(color: Color3): number;
        /**
         * Performs sampling of a Normalized Burley diffusion profile in polar coordinates.
         * 'u' is the random number (the value of the CDF): [0, 1).
         * rcp(s) = 1 / ShapeParam = ScatteringDistance.
         * Returns the sampled radial distance, s.t. (u = 0 -> r = 0) and (u = 1 -> r = Inf).
         */
        private _sampleBurleyDiffusionProfile;
    }
}
declare module BABYLON {
    /**
     * Renders a pre pass of the scene
     * This means every mesh in the scene will be rendered to a render target texture
     * And then this texture will be composited to the rendering canvas with post processes
     * It is necessary for effects like subsurface scattering or deferred shading
     */
    export class PrePassRenderer {
        /** @hidden */
        static _SceneComponentInitialization: (scene: Scene) => void;
        private _scene;
        private _engine;
        private _isDirty;
        /**
         * Number of textures in the multi render target texture where the scene is directly rendered
         */
        readonly mrtCount: number;
        /**
         * The render target where the scene is directly rendered
         */
        prePassRT: MultiRenderTarget;
        private _mrtTypes;
        private _multiRenderAttachments;
        private _defaultAttachments;
        private _clearAttachments;
        private _postProcesses;
        private readonly _clearColor;
        /**
         * Image processing post process for composition
         */
        imageProcessingPostProcess: ImageProcessingPostProcess;
        /**
         * Configuration for sub surface scattering post process
         */
        subSurfaceConfiguration: SubSurfaceConfiguration;
        /**
         * Should materials render their geometry on the MRT
         */
        materialsShouldRenderGeometry: boolean;
        /**
         * Should materials render the irradiance information on the MRT
         */
        materialsShouldRenderIrradiance: boolean;
        private _enabled;
        /**
         * Indicates if the prepass is enabled
         */
        get enabled(): boolean;
        /**
         * How many samples are used for MSAA of the scene render target
         */
        get samples(): number;
        set samples(n: number);
        /**
         * Instanciates a prepass renderer
         * @param scene The scene
         */
        constructor(scene: Scene);
        private _initializeAttachments;
        private _createCompositionEffect;
        /**
         * Indicates if rendering a prepass is supported
         */
        get isSupported(): boolean;
        /**
         * Sets the proper output textures to draw in the engine.
         * @param effect The effect that is drawn. It can be or not be compatible with drawing to several output textures.
         */
        bindAttachmentsForEffect(effect: Effect): void;
        /**
         * @hidden
         */
        _beforeCameraDraw(): void;
        /**
         * @hidden
         */
        _afterCameraDraw(): void;
        private _checkRTSize;
        private _bindFrameBuffer;
        /**
         * Clears the scene render target (in the sense of settings pixels to the scene clear color value)
         */
        clear(): void;
        private _setState;
        private _enable;
        private _disable;
        private _resetPostProcessChain;
        private _bindPostProcessChain;
        /**
         * Marks the prepass renderer as dirty, triggering a check if the prepass is necessary for the next rendering.
         */
        markAsDirty(): void;
        private _update;
        /**
         * Disposes the prepass renderer.
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * Options for compiling materials.
     */
    export interface IMaterialCompilationOptions {
        /**
         * Defines whether clip planes are enabled.
         */
        clipPlane: boolean;
        /**
         * Defines whether instances are enabled.
         */
        useInstances: boolean;
    }
    /**
     * Options passed when calling customShaderNameResolve
     */
    export interface ICustomShaderNameResolveOptions {
        /**
         * If provided, will be called two times with the vertex and fragment code so that this code can be updated before it is compiled by the GPU
         */
        processFinalCode?: Nullable<(shaderType: string, code: string) => string>;
    }
    /**
     * Base class for the main features of a material in Babylon.js
     */
    export class Material implements IAnimatable {
        /**
         * Returns the triangle fill mode
         */
        static readonly TriangleFillMode: number;
        /**
         * Returns the wireframe mode
         */
        static readonly WireFrameFillMode: number;
        /**
         * Returns the point fill mode
         */
        static readonly PointFillMode: number;
        /**
         * Returns the point list draw mode
         */
        static readonly PointListDrawMode: number;
        /**
         * Returns the line list draw mode
         */
        static readonly LineListDrawMode: number;
        /**
         * Returns the line loop draw mode
         */
        static readonly LineLoopDrawMode: number;
        /**
         * Returns the line strip draw mode
         */
        static readonly LineStripDrawMode: number;
        /**
         * Returns the triangle strip draw mode
         */
        static readonly TriangleStripDrawMode: number;
        /**
         * Returns the triangle fan draw mode
         */
        static readonly TriangleFanDrawMode: number;
        /**
         * Stores the clock-wise side orientation
         */
        static readonly ClockWiseSideOrientation: number;
        /**
         * Stores the counter clock-wise side orientation
         */
        static readonly CounterClockWiseSideOrientation: number;
        /**
         * The dirty texture flag value
         */
        static readonly TextureDirtyFlag: number;
        /**
         * The dirty light flag value
         */
        static readonly LightDirtyFlag: number;
        /**
         * The dirty fresnel flag value
         */
        static readonly FresnelDirtyFlag: number;
        /**
         * The dirty attribute flag value
         */
        static readonly AttributesDirtyFlag: number;
        /**
         * The dirty misc flag value
         */
        static readonly MiscDirtyFlag: number;
        /**
         * The all dirty flag value
         */
        static readonly AllDirtyFlag: number;
        /**
         * MaterialTransparencyMode: No transparency mode, Alpha channel is not use.
         */
        static readonly MATERIAL_OPAQUE: number;
        /**
         * MaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.
         */
        static readonly MATERIAL_ALPHATEST: number;
        /**
         * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
         */
        static readonly MATERIAL_ALPHABLEND: number;
        /**
         * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
         * They are also discarded below the alpha cutoff threshold to improve performances.
         */
        static readonly MATERIAL_ALPHATESTANDBLEND: number;
        /**
         * The Whiteout method is used to blend normals.
         * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/
         */
        static readonly MATERIAL_NORMALBLENDMETHOD_WHITEOUT: number;
        /**
         * The Reoriented Normal Mapping method is used to blend normals.
         * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/
         */
        static readonly MATERIAL_NORMALBLENDMETHOD_RNM: number;
        /**
         * Custom callback helping to override the default shader used in the material.
         */
        customShaderNameResolve: (shaderName: string, uniforms: string[], uniformBuffers: string[], samplers: string[], defines: MaterialDefines | string[], attributes?: string[], options?: ICustomShaderNameResolveOptions) => string;
        /**
         * Custom shadow depth material to use for shadow rendering instead of the in-built one
         */
        shadowDepthWrapper: Nullable<ShadowDepthWrapper>;
        /**
         * Gets or sets a boolean indicating that the material is allowed (if supported) to do shader hot swapping.
         * This means that the material can keep using a previous shader while a new one is being compiled.
         * This is mostly used when shader parallel compilation is supported (true by default)
         */
        allowShaderHotSwapping: boolean;
        /**
         * The ID of the material
         */
        id: string;
        /**
         * Gets or sets the unique id of the material
         */
        uniqueId: number;
        /**
         * The name of the material
         */
        name: string;
        /**
         * Gets or sets user defined metadata
         */
        metadata: any;
        /**
         * For internal use only. Please do not use.
         */
        reservedDataStore: any;
        /**
         * Specifies if the ready state should be checked on each call
         */
        checkReadyOnEveryCall: boolean;
        /**
         * Specifies if the ready state should be checked once
         */
        checkReadyOnlyOnce: boolean;
        /**
         * The state of the material
         */
        state: string;
        /**
         * If the material can be rendered to several textures with MRT extension
         */
        get canRenderToMRT(): boolean;
        /**
         * The alpha value of the material
         */
        protected _alpha: number;
        /**
         * List of inspectable custom properties (used by the Inspector)
         * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility
         */
        inspectableCustomProperties: IInspectable[];
        /**
         * Sets the alpha value of the material
         */
        set alpha(value: number);
        /**
         * Gets the alpha value of the material
         */
        get alpha(): number;
        /**
         * Specifies if back face culling is enabled
         */
        protected _backFaceCulling: boolean;
        /**
         * Sets the back-face culling state
         */
        set backFaceCulling(value: boolean);
        /**
         * Gets the back-face culling state
         */
        get backFaceCulling(): boolean;
        /**
         * Stores the value for side orientation
         */
        sideOrientation: number;
        /**
         * Callback triggered when the material is compiled
         */
        onCompiled: Nullable<(effect: Effect) => void>;
        /**
         * Callback triggered when an error occurs
         */
        onError: Nullable<(effect: Effect, errors: string) => void>;
        /**
         * Callback triggered to get the render target textures
         */
        getRenderTargetTextures: Nullable<() => SmartArray<RenderTargetTexture>>;
        /**
         * Gets a boolean indicating that current material needs to register RTT
         */
        get hasRenderTargetTextures(): boolean;
        /**
         * Specifies if the material should be serialized
         */
        doNotSerialize: boolean;
        /**
         * @hidden
         */
        _storeEffectOnSubMeshes: boolean;
        /**
         * Stores the animations for the material
         */
        animations: Nullable<Array<Animation>>;
        /**
        * An event triggered when the material is disposed
        */
        onDisposeObservable: Observable<Material>;
        /**
         * An observer which watches for dispose events
         */
        private _onDisposeObserver;
        private _onUnBindObservable;
        /**
         * Called during a dispose event
         */
        set onDispose(callback: () => void);
        private _onBindObservable;
        /**
        * An event triggered when the material is bound
        */
        get onBindObservable(): Observable<AbstractMesh>;
        /**
         * An observer which watches for bind events
         */
        private _onBindObserver;
        /**
         * Called during a bind event
         */
        set onBind(callback: (Mesh: AbstractMesh) => void);
        /**
        * An event triggered when the material is unbound
        */
        get onUnBindObservable(): Observable<Material>;
        protected _onEffectCreatedObservable: Nullable<Observable<{
            effect: Effect;
            subMesh: Nullable<SubMesh>;
        }>>;
        /**
        * An event triggered when the effect is (re)created
        */
        get onEffectCreatedObservable(): Observable<{
            effect: Effect;
            subMesh: Nullable<SubMesh>;
        }>;
        /**
         * Stores the value of the alpha mode
         */
        private _alphaMode;
        /**
         * Sets the value of the alpha mode.
         *
         * | Value | Type | Description |
         * | --- | --- | --- |
         * | 0 | ALPHA_DISABLE |   |
         * | 1 | ALPHA_ADD |   |
         * | 2 | ALPHA_COMBINE |   |
         * | 3 | ALPHA_SUBTRACT |   |
         * | 4 | ALPHA_MULTIPLY |   |
         * | 5 | ALPHA_MAXIMIZED |   |
         * | 6 | ALPHA_ONEONE |   |
         * | 7 | ALPHA_PREMULTIPLIED |   |
         * | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF |   |
         * | 9 | ALPHA_INTERPOLATE |   |
         * | 10 | ALPHA_SCREENMODE |   |
         *
         */
        set alphaMode(value: number);
        /**
         * Gets the value of the alpha mode
         */
        get alphaMode(): number;
        /**
         * Stores the state of the need depth pre-pass value
         */
        private _needDepthPrePass;
        /**
         * Sets the need depth pre-pass value
         */
        set needDepthPrePass(value: boolean);
        /**
         * Gets the depth pre-pass value
         */
        get needDepthPrePass(): boolean;
        /**
         * Specifies if depth writing should be disabled
         */
        disableDepthWrite: boolean;
        /**
         * Specifies if color writing should be disabled
         */
        disableColorWrite: boolean;
        /**
         * Specifies if depth writing should be forced
         */
        forceDepthWrite: boolean;
        /**
         * Specifies the depth function that should be used. 0 means the default engine function
         */
        depthFunction: number;
        /**
         * Specifies if there should be a separate pass for culling
         */
        separateCullingPass: boolean;
        /**
         * Stores the state specifing if fog should be enabled
         */
        private _fogEnabled;
        /**
         * Sets the state for enabling fog
         */
        set fogEnabled(value: boolean);
        /**
         * Gets the value of the fog enabled state
         */
        get fogEnabled(): boolean;
        /**
         * Stores the size of points
         */
        pointSize: number;
        /**
         * Stores the z offset value
         */
        zOffset: number;
        get wireframe(): boolean;
        /**
         * Sets the state of wireframe mode
         */
        set wireframe(value: boolean);
        /**
         * Gets the value specifying if point clouds are enabled
         */
        get pointsCloud(): boolean;
        /**
         * Sets the state of point cloud mode
         */
        set pointsCloud(value: boolean);
        /**
         * Gets the material fill mode
         */
        get fillMode(): number;
        /**
         * Sets the material fill mode
         */
        set fillMode(value: number);
        /**
         * @hidden
         * Stores the effects for the material
         */
        _effect: Nullable<Effect>;
        /**
         * Specifies if uniform buffers should be used
         */
        private _useUBO;
        /**
         * Stores a reference to the scene
         */
        private _scene;
        /**
         * Stores the fill mode state
         */
        private _fillMode;
        /**
         * Specifies if the depth write state should be cached
         */
        private _cachedDepthWriteState;
        /**
         * Specifies if the color write state should be cached
         */
        private _cachedColorWriteState;
        /**
         * Specifies if the depth function state should be cached
         */
        private _cachedDepthFunctionState;
        /**
         * Stores the uniform buffer
         */
        protected _uniformBuffer: UniformBuffer;
        /** @hidden */
        _indexInSceneMaterialArray: number;
        /** @hidden */
        meshMap: Nullable<{
            [id: string]: AbstractMesh | undefined;
        }>;
        /**
         * Creates a material instance
         * @param name defines the name of the material
         * @param scene defines the scene to reference
         * @param doNotAdd specifies if the material should be added to the scene
         */
        constructor(name: string, scene: Scene, doNotAdd?: boolean);
        /**
         * Returns a string representation of the current material
         * @param fullDetails defines a boolean indicating which levels of logging is desired
         * @returns a string with material information
         */
        toString(fullDetails?: boolean): string;
        /**
         * Gets the class name of the material
         * @returns a string with the class name of the material
         */
        getClassName(): string;
        /**
         * Specifies if updates for the material been locked
         */
        get isFrozen(): boolean;
        /**
         * Locks updates for the material
         */
        freeze(): void;
        /**
         * Unlocks updates for the material
         */
        unfreeze(): void;
        /**
         * Specifies if the material is ready to be used
         * @param mesh defines the mesh to check
         * @param useInstances specifies if instances should be used
         * @returns a boolean indicating if the material is ready to be used
         */
        isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean;
        /**
         * Specifies that the submesh is ready to be used
         * @param mesh defines the mesh to check
         * @param subMesh defines which submesh to check
         * @param useInstances specifies that instances should be used
         * @returns a boolean indicating that the submesh is ready or not
         */
        isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean;
        /**
         * Returns the material effect
         * @returns the effect associated with the material
         */
        getEffect(): Nullable<Effect>;
        /**
         * Returns the current scene
         * @returns a Scene
         */
        getScene(): Scene;
        /**
         * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.
         */
        protected _forceAlphaTest: boolean;
        /**
         * The transparency mode of the material.
         */
        protected _transparencyMode: Nullable<number>;
        /**
         * Gets the current transparency mode.
         */
        get transparencyMode(): Nullable<number>;
        /**
         * Sets the transparency mode of the material.
         *
         * | Value | Type                                | Description |
         * | ----- | ----------------------------------- | ----------- |
         * | 0     | OPAQUE                              |             |
         * | 1     | ALPHATEST                           |             |
         * | 2     | ALPHABLEND                          |             |
         * | 3     | ALPHATESTANDBLEND                   |             |
         *
         */
        set transparencyMode(value: Nullable<number>);
        /**
         * Returns true if alpha blending should be disabled.
         */
        protected get _disableAlphaBlending(): boolean;
        /**
         * Specifies whether or not this material should be rendered in alpha blend mode.
         * @returns a boolean specifying if alpha blending is needed
         */
        needAlphaBlending(): boolean;
        /**
         * Specifies if the mesh will require alpha blending
         * @param mesh defines the mesh to check
         * @returns a boolean specifying if alpha blending is needed for the mesh
         */
        needAlphaBlendingForMesh(mesh: AbstractMesh): boolean;
        /**
         * Specifies whether or not this material should be rendered in alpha test mode.
         * @returns a boolean specifying if an alpha test is needed.
         */
        needAlphaTesting(): boolean;
        /**
         * Specifies if material alpha testing should be turned on for the mesh
         * @param mesh defines the mesh to check
         */
        protected _shouldTurnAlphaTestOn(mesh: AbstractMesh): boolean;
        /**
         * Gets the texture used for the alpha test
         * @returns the texture to use for alpha testing
         */
        getAlphaTestTexture(): Nullable<BaseTexture>;
        /**
         * Marks the material to indicate that it needs to be re-calculated
         */
        markDirty(): void;
        /** @hidden */
        _preBind(effect?: Effect, overrideOrientation?: Nullable<number>): boolean;
        /**
         * Binds the material to the mesh
         * @param world defines the world transformation matrix
         * @param mesh defines the mesh to bind the material to
         */
        bind(world: Matrix, mesh?: Mesh): void;
        /**
         * Binds the submesh to the material
         * @param world defines the world transformation matrix
         * @param mesh defines the mesh containing the submesh
         * @param subMesh defines the submesh to bind the material to
         */
        bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void;
        /**
         * Binds the world matrix to the material
         * @param world defines the world transformation matrix
         */
        bindOnlyWorldMatrix(world: Matrix): void;
        /**
         * Binds the scene's uniform buffer to the effect.
         * @param effect defines the effect to bind to the scene uniform buffer
         * @param sceneUbo defines the uniform buffer storing scene data
         */
        bindSceneUniformBuffer(effect: Effect, sceneUbo: UniformBuffer): void;
        /**
         * Binds the view matrix to the effect
         * @param effect defines the effect to bind the view matrix to
         */
        bindView(effect: Effect): void;
        /**
         * Binds the view projection matrix to the effect
         * @param effect defines the effect to bind the view projection matrix to
         */
        bindViewProjection(effect: Effect): void;
        /**
         * Processes to execute after binding the material to a mesh
         * @param mesh defines the rendered mesh
         */
        protected _afterBind(mesh?: Mesh): void;
        /**
         * Unbinds the material from the mesh
         */
        unbind(): void;
        /**
         * Gets the active textures from the material
         * @returns an array of textures
         */
        getActiveTextures(): BaseTexture[];
        /**
         * Specifies if the material uses a texture
         * @param texture defines the texture to check against the material
         * @returns a boolean specifying if the material uses the texture
         */
        hasTexture(texture: BaseTexture): boolean;
        /**
         * Makes a duplicate of the material, and gives it a new name
         * @param name defines the new name for the duplicated material
         * @returns the cloned material
         */
        clone(name: string): Nullable<Material>;
        /**
         * Gets the meshes bound to the material
         * @returns an array of meshes bound to the material
         */
        getBindedMeshes(): AbstractMesh[];
        /**
         * Force shader compilation
         * @param mesh defines the mesh associated with this material
         * @param onCompiled defines a function to execute once the material is compiled
         * @param options defines the options to configure the compilation
         * @param onError defines a function to execute if the material fails compiling
         */
        forceCompilation(mesh: AbstractMesh, onCompiled?: (material: Material) => void, options?: Partial<IMaterialCompilationOptions>, onError?: (reason: string) => void): void;
        /**
         * Force shader compilation
         * @param mesh defines the mesh that will use this material
         * @param options defines additional options for compiling the shaders
         * @returns a promise that resolves when the compilation completes
         */
        forceCompilationAsync(mesh: AbstractMesh, options?: Partial<IMaterialCompilationOptions>): Promise<void>;
        private static readonly _AllDirtyCallBack;
        private static readonly _ImageProcessingDirtyCallBack;
        private static readonly _TextureDirtyCallBack;
        private static readonly _FresnelDirtyCallBack;
        private static readonly _MiscDirtyCallBack;
        private static readonly _LightsDirtyCallBack;
        private static readonly _AttributeDirtyCallBack;
        private static _FresnelAndMiscDirtyCallBack;
        private static _TextureAndMiscDirtyCallBack;
        private static readonly _DirtyCallbackArray;
        private static readonly _RunDirtyCallBacks;
        /**
         * Marks a define in the material to indicate that it needs to be re-computed
         * @param flag defines a flag used to determine which parts of the material have to be marked as dirty
         */
        markAsDirty(flag: number): void;
        /**
         * Marks all submeshes of a material to indicate that their material defines need to be re-calculated
         * @param func defines a function which checks material defines against the submeshes
         */
        protected _markAllSubMeshesAsDirty(func: (defines: MaterialDefines) => void): void;
        /**
         * Indicates that the scene should check if the rendering now needs a prepass
         */
        protected _markScenePrePassDirty(): void;
        /**
         * Indicates that we need to re-calculated for all submeshes
         */
        protected _markAllSubMeshesAsAllDirty(): void;
        /**
         * Indicates that image processing needs to be re-calculated for all submeshes
         */
        protected _markAllSubMeshesAsImageProcessingDirty(): void;
        /**
         * Indicates that textures need to be re-calculated for all submeshes
         */
        protected _markAllSubMeshesAsTexturesDirty(): void;
        /**
         * Indicates that fresnel needs to be re-calculated for all submeshes
         */
        protected _markAllSubMeshesAsFresnelDirty(): void;
        /**
         * Indicates that fresnel and misc need to be re-calculated for all submeshes
         */
        protected _markAllSubMeshesAsFresnelAndMiscDirty(): void;
        /**
         * Indicates that lights need to be re-calculated for all submeshes
         */
        protected _markAllSubMeshesAsLightsDirty(): void;
        /**
         * Indicates that attributes need to be re-calculated for all submeshes
         */
        protected _markAllSubMeshesAsAttributesDirty(): void;
        /**
         * Indicates that misc needs to be re-calculated for all submeshes
         */
        protected _markAllSubMeshesAsMiscDirty(): void;
        /**
         * Indicates that textures and misc need to be re-calculated for all submeshes
         */
        protected _markAllSubMeshesAsTexturesAndMiscDirty(): void;
        /**
         * Sets the required values to the prepass renderer.
         * @param prePassRenderer defines the prepass renderer to setup.
         * @returns true if the pre pass is needed.
         */
        setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean;
        /**
         * Disposes the material
         * @param forceDisposeEffect specifies if effects should be forcefully disposed
         * @param forceDisposeTextures specifies if textures should be forcefully disposed
         * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh
         */
        dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void;
        /** @hidden */
        private releaseVertexArrayObject;
        /**
         * Serializes this material
         * @returns the serialized material object
         */
        serialize(): any;
        /**
         * Creates a material from parsed material data
         * @param parsedMaterial defines parsed material data
         * @param scene defines the hosting scene
         * @param rootUrl defines the root URL to use to load textures
         * @returns a new material
         */
        static Parse(parsedMaterial: any, scene: Scene, rootUrl: string): Nullable<Material>;
    }
}
declare module BABYLON {
    /**
     * A multi-material is used to apply different materials to different parts of the same object without the need of
     * separate meshes. This can be use to improve performances.
     * @see https://doc.babylonjs.com/how_to/multi_materials
     */
    export class MultiMaterial extends Material {
        private _subMaterials;
        /**
         * Gets or Sets the list of Materials used within the multi material.
         * They need to be ordered according to the submeshes order in the associated mesh
         */
        get subMaterials(): Nullable<Material>[];
        set subMaterials(value: Nullable<Material>[]);
        /**
         * Function used to align with Node.getChildren()
         * @returns the list of Materials used within the multi material
         */
        getChildren(): Nullable<Material>[];
        /**
         * Instantiates a new Multi Material
         * A multi-material is used to apply different materials to different parts of the same object without the need of
         * separate meshes. This can be use to improve performances.
         * @see https://doc.babylonjs.com/how_to/multi_materials
         * @param name Define the name in the scene
         * @param scene Define the scene the material belongs to
         */
        constructor(name: string, scene: Scene);
        private _hookArray;
        /**
         * Get one of the submaterial by its index in the submaterials array
         * @param index The index to look the sub material at
         * @returns The Material if the index has been defined
         */
        getSubMaterial(index: number): Nullable<Material>;
        /**
         * Get the list of active textures for the whole sub materials list.
         * @returns All the textures that will be used during the rendering
         */
        getActiveTextures(): BaseTexture[];
        /**
         * Gets the current class name of the material e.g. "MultiMaterial"
         * Mainly use in serialization.
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Checks if the material is ready to render the requested sub mesh
         * @param mesh Define the mesh the submesh belongs to
         * @param subMesh Define the sub mesh to look readyness for
         * @param useInstances Define whether or not the material is used with instances
         * @returns true if ready, otherwise false
         */
        isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean;
        /**
         * Clones the current material and its related sub materials
         * @param name Define the name of the newly cloned material
         * @param cloneChildren Define if submaterial will be cloned or shared with the parent instance
         * @returns the cloned material
         */
        clone(name: string, cloneChildren?: boolean): MultiMaterial;
        /**
         * Serializes the materials into a JSON representation.
         * @returns the JSON representation
         */
        serialize(): any;
        /**
         * Dispose the material and release its associated resources
         * @param forceDisposeEffect Define if we want to force disposing the associated effect (if false the shader is not released and could be reuse later on)
         * @param forceDisposeTextures Define if we want to force disposing the associated textures (if false, they will not be disposed and can still be use elsewhere in the app)
         * @param forceDisposeChildren Define if we want to force disposing the associated submaterials (if false, they will not be disposed and can still be use elsewhere in the app)
         */
        dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, forceDisposeChildren?: boolean): void;
        /**
         * Creates a MultiMaterial from parsed MultiMaterial data.
         * @param parsedMultiMaterial defines parsed MultiMaterial data.
         * @param scene defines the hosting scene
         * @returns a new MultiMaterial
         */
        static ParseMultiMaterial(parsedMultiMaterial: any, scene: Scene): MultiMaterial;
    }
}
declare module BABYLON {
    /**
     * Defines a subdivision inside a mesh
     */
    export class SubMesh implements ICullable {
        /** the material index to use */
        materialIndex: number;
        /** vertex index start */
        verticesStart: number;
        /** vertices count */
        verticesCount: number;
        /** index start */
        indexStart: number;
        /** indices count */
        indexCount: number;
        /** @hidden */
        _materialDefines: Nullable<MaterialDefines>;
        /** @hidden */
        _materialEffect: Nullable<Effect>;
        /** @hidden */
        _effectOverride: Nullable<Effect>;
        /**
         * Gets material defines used by the effect associated to the sub mesh
         */
        get materialDefines(): Nullable<MaterialDefines>;
        /**
         * Sets material defines used by the effect associated to the sub mesh
         */
        set materialDefines(defines: Nullable<MaterialDefines>);
        /**
         * Gets associated effect
         */
        get effect(): Nullable<Effect>;
        /**
         * Sets associated effect (effect used to render this submesh)
         * @param effect defines the effect to associate with
         * @param defines defines the set of defines used to compile this effect
         */
        setEffect(effect: Nullable<Effect>, defines?: Nullable<MaterialDefines>): void;
        /** @hidden */
        _linesIndexCount: number;
        private _mesh;
        private _renderingMesh;
        private _boundingInfo;
        private _linesIndexBuffer;
        /** @hidden */
        _lastColliderWorldVertices: Nullable<Vector3[]>;
        /** @hidden */
        _trianglePlanes: Plane[];
        /** @hidden */
        _lastColliderTransformMatrix: Nullable<Matrix>;
        /** @hidden */
        _renderId: number;
        /** @hidden */
        _alphaIndex: number;
        /** @hidden */
        _distanceToCamera: number;
        /** @hidden */
        _id: number;
        private _currentMaterial;
        /**
         * Add a new submesh to a mesh
         * @param materialIndex defines the material index to use
         * @param verticesStart defines vertex index start
         * @param verticesCount defines vertices count
         * @param indexStart defines index start
         * @param indexCount defines indices count
         * @param mesh defines the parent mesh
         * @param renderingMesh defines an optional rendering mesh
         * @param createBoundingBox defines if bounding box should be created for this submesh
         * @returns the new submesh
         */
        static AddToMesh(materialIndex: number, verticesStart: number, verticesCount: number, indexStart: number, indexCount: number, mesh: AbstractMesh, renderingMesh?: Mesh, createBoundingBox?: boolean): SubMesh;
        /**
         * Creates a new submesh
         * @param materialIndex defines the material index to use
         * @param verticesStart defines vertex index start
         * @param verticesCount defines vertices count
         * @param indexStart defines index start
         * @param indexCount defines indices count
         * @param mesh defines the parent mesh
         * @param renderingMesh defines an optional rendering mesh
         * @param createBoundingBox defines if bounding box should be created for this submesh
         * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)
         */
        constructor(
        /** the material index to use */
        materialIndex: number, 
        /** vertex index start */
        verticesStart: number, 
        /** vertices count */
        verticesCount: number, 
        /** index start */
        indexStart: number, 
        /** indices count */
        indexCount: number, mesh: AbstractMesh, renderingMesh?: Mesh, createBoundingBox?: boolean, addToMesh?: boolean);
        /**
         * Returns true if this submesh covers the entire parent mesh
         * @ignorenaming
         */
        get IsGlobal(): boolean;
        /**
         * Returns the submesh BoudingInfo object
         * @returns current bounding info (or mesh's one if the submesh is global)
         */
        getBoundingInfo(): BoundingInfo;
        /**
         * Sets the submesh BoundingInfo
         * @param boundingInfo defines the new bounding info to use
         * @returns the SubMesh
         */
        setBoundingInfo(boundingInfo: BoundingInfo): SubMesh;
        /**
         * Returns the mesh of the current submesh
         * @return the parent mesh
         */
        getMesh(): AbstractMesh;
        /**
         * Returns the rendering mesh of the submesh
         * @returns the rendering mesh (could be different from parent mesh)
         */
        getRenderingMesh(): Mesh;
        /**
         * Returns the replacement mesh of the submesh
         * @returns the replacement mesh (could be different from parent mesh)
         */
        getReplacementMesh(): Nullable<AbstractMesh>;
        /**
         * Returns the effective mesh of the submesh
         * @returns the effective mesh (could be different from parent mesh)
         */
        getEffectiveMesh(): AbstractMesh;
        /**
         * Returns the submesh material
         * @returns null or the current material
         */
        getMaterial(): Nullable<Material>;
        private _IsMultiMaterial;
        /**
         * Sets a new updated BoundingInfo object to the submesh
         * @param data defines an optional position array to use to determine the bounding info
         * @returns the SubMesh
         */
        refreshBoundingInfo(data?: Nullable<FloatArray>): SubMesh;
        /** @hidden */
        _checkCollision(collider: Collider): boolean;
        /**
         * Updates the submesh BoundingInfo
         * @param world defines the world matrix to use to update the bounding info
         * @returns the submesh
         */
        updateBoundingInfo(world: DeepImmutable<Matrix>): SubMesh;
        /**
         * True is the submesh bounding box intersects the frustum defined by the passed array of planes.
         * @param frustumPlanes defines the frustum planes
         * @returns true if the submesh is intersecting with the frustum
         */
        isInFrustum(frustumPlanes: Plane[]): boolean;
        /**
         * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes
         * @param frustumPlanes defines the frustum planes
         * @returns true if the submesh is inside the frustum
         */
        isCompletelyInFrustum(frustumPlanes: Plane[]): boolean;
        /**
         * Renders the submesh
         * @param enableAlphaMode defines if alpha needs to be used
         * @returns the submesh
         */
        render(enableAlphaMode: boolean): SubMesh;
        /**
         * @hidden
         */
        _getLinesIndexBuffer(indices: IndicesArray, engine: Engine): DataBuffer;
        /**
         * Checks if the submesh intersects with a ray
         * @param ray defines the ray to test
         * @returns true is the passed ray intersects the submesh bounding box
         */
        canIntersects(ray: Ray): boolean;
        /**
         * Intersects current submesh with a ray
         * @param ray defines the ray to test
         * @param positions defines mesh's positions array
         * @param indices defines mesh's indices array
         * @param fastCheck defines if the first intersection will be used (and not the closest)
         * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
         * @returns intersection info or null if no intersection
         */
        intersects(ray: Ray, positions: Vector3[], indices: IndicesArray, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<IntersectionInfo>;
        /** @hidden */
        private _intersectLines;
        /** @hidden */
        private _intersectUnIndexedLines;
        /** @hidden */
        private _intersectTriangles;
        /** @hidden */
        private _intersectUnIndexedTriangles;
        /** @hidden */
        _rebuild(): void;
        /**
         * Creates a new submesh from the passed mesh
         * @param newMesh defines the new hosting mesh
         * @param newRenderingMesh defines an optional rendering mesh
         * @returns the new submesh
         */
        clone(newMesh: AbstractMesh, newRenderingMesh?: Mesh): SubMesh;
        /**
         * Release associated resources
         */
        dispose(): void;
        /**
         * Gets the class name
         * @returns the string "SubMesh".
         */
        getClassName(): string;
        /**
         * Creates a new submesh from indices data
         * @param materialIndex the index of the main mesh material
         * @param startIndex the index where to start the copy in the mesh indices array
         * @param indexCount the number of indices to copy then from the startIndex
         * @param mesh the main mesh to create the submesh from
         * @param renderingMesh the optional rendering mesh
         * @returns a new submesh
         */
        static CreateFromIndices(materialIndex: number, startIndex: number, indexCount: number, mesh: AbstractMesh, renderingMesh?: Mesh): SubMesh;
    }
}
declare module BABYLON {
    /**
     * Class used to represent data loading progression
     */
    export class SceneLoaderFlags {
        private static _ForceFullSceneLoadingForIncremental;
        private static _ShowLoadingScreen;
        private static _CleanBoneMatrixWeights;
        private static _loggingLevel;
        /**
         * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data
         */
        static get ForceFullSceneLoadingForIncremental(): boolean;
        static set ForceFullSceneLoadingForIncremental(value: boolean);
        /**
         * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene
         */
        static get ShowLoadingScreen(): boolean;
        static set ShowLoadingScreen(value: boolean);
        /**
         * Defines the current logging level (while loading the scene)
         * @ignorenaming
         */
        static get loggingLevel(): number;
        static set loggingLevel(value: number);
        /**
         * Gets or set a boolean indicating if matrix weights must be cleaned upon loading
         */
        static get CleanBoneMatrixWeights(): boolean;
        static set CleanBoneMatrixWeights(value: boolean);
    }
}
declare module BABYLON {
    /**
     * Class used to store geometry data (vertex buffers + index buffer)
     */
    export class Geometry implements IGetSetVerticesData {
        /**
         * Gets or sets the ID of the geometry
         */
        id: string;
        /**
         * Gets or sets the unique ID of the geometry
         */
        uniqueId: number;
        /**
         * Gets the delay loading state of the geometry (none by default which means not delayed)
         */
        delayLoadState: number;
        /**
         * Gets the file containing the data to load when running in delay load state
         */
        delayLoadingFile: Nullable<string>;
        /**
         * Callback called when the geometry is updated
         */
        onGeometryUpdated: (geometry: Geometry, kind?: string) => void;
        private _scene;
        private _engine;
        private _meshes;
        private _totalVertices;
        /** @hidden */
        _indices: IndicesArray;
        /** @hidden */
        _vertexBuffers: {
            [key: string]: VertexBuffer;
        };
        private _isDisposed;
        private _extend;
        private _boundingBias;
        /** @hidden */
        _delayInfo: Array<string>;
        private _indexBuffer;
        private _indexBufferIsUpdatable;
        /** @hidden */
        _boundingInfo: Nullable<BoundingInfo>;
        /** @hidden */
        _delayLoadingFunction: Nullable<(any: any, geometry: Geometry) => void>;
        /** @hidden */
        _softwareSkinningFrameId: number;
        private _vertexArrayObjects;
        private _updatable;
        /** @hidden */
        _positions: Nullable<Vector3[]>;
        /**
         *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y
         */
        get boundingBias(): Vector2;
        /**
         *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y
         */
        set boundingBias(value: Vector2);
        /**
         * Static function used to attach a new empty geometry to a mesh
         * @param mesh defines the mesh to attach the geometry to
         * @returns the new Geometry
         */
        static CreateGeometryForMesh(mesh: Mesh): Geometry;
        /** Get the list of meshes using this geometry */
        get meshes(): Mesh[];
        /**
         * If set to true (false by defaut), the bounding info applied to the meshes sharing this geometry will be the bounding info defined at the class level
         * and won't be computed based on the vertex positions (which is what we get when useBoundingInfoFromGeometry = false)
         */
        useBoundingInfoFromGeometry: boolean;
        /**
         * Creates a new geometry
         * @param id defines the unique ID
         * @param scene defines the hosting scene
         * @param vertexData defines the VertexData used to get geometry data
         * @param updatable defines if geometry must be updatable (false by default)
         * @param mesh defines the mesh that will be associated with the geometry
         */
        constructor(id: string, scene: Scene, vertexData?: VertexData, updatable?: boolean, mesh?: Nullable<Mesh>);
        /**
         * Gets the current extend of the geometry
         */
        get extend(): {
            minimum: Vector3;
            maximum: Vector3;
        };
        /**
         * Gets the hosting scene
         * @returns the hosting Scene
         */
        getScene(): Scene;
        /**
         * Gets the hosting engine
         * @returns the hosting Engine
         */
        getEngine(): Engine;
        /**
         * Defines if the geometry is ready to use
         * @returns true if the geometry is ready to be used
         */
        isReady(): boolean;
        /**
         * Gets a value indicating that the geometry should not be serialized
         */
        get doNotSerialize(): boolean;
        /** @hidden */
        _rebuild(): void;
        /**
         * Affects all geometry data in one call
         * @param vertexData defines the geometry data
         * @param updatable defines if the geometry must be flagged as updatable (false as default)
         */
        setAllVerticesData(vertexData: VertexData, updatable?: boolean): void;
        /**
         * Set specific vertex data
         * @param kind defines the data kind (Position, normal, etc...)
         * @param data defines the vertex data to use
         * @param updatable defines if the vertex must be flagged as updatable (false as default)
         * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified
         */
        setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): void;
        /**
         * Removes a specific vertex data
         * @param kind defines the data kind (Position, normal, etc...)
         */
        removeVerticesData(kind: string): void;
        /**
         * Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data
         * @param buffer defines the vertex buffer to use
         * @param totalVertices defines the total number of vertices for position kind (could be null)
         */
        setVerticesBuffer(buffer: VertexBuffer, totalVertices?: Nullable<number>): void;
        /**
         * Update a specific vertex buffer
         * This function will directly update the underlying DataBuffer according to the passed numeric array or Float32Array
         * It will do nothing if the buffer is not updatable
         * @param kind defines the data kind (Position, normal, etc...)
         * @param data defines the data to use
         * @param offset defines the offset in the target buffer where to store the data
         * @param useBytes set to true if the offset is in bytes
         */
        updateVerticesDataDirectly(kind: string, data: DataArray, offset: number, useBytes?: boolean): void;
        /**
         * Update a specific vertex buffer
         * This function will create a new buffer if the current one is not updatable
         * @param kind defines the data kind (Position, normal, etc...)
         * @param data defines the data to use
         * @param updateExtends defines if the geometry extends must be recomputed (false by default)
         */
        updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean): void;
        private _updateBoundingInfo;
        /** @hidden */
        _bind(effect: Nullable<Effect>, indexToBind?: Nullable<DataBuffer>): void;
        /**
         * Gets total number of vertices
         * @returns the total number of vertices
         */
        getTotalVertices(): number;
        /**
         * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.
         * @param kind defines the data kind (Position, normal, etc...)
         * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes
         * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it
         * @returns a float array containing vertex data
         */
        getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray>;
        /**
         * Returns a boolean defining if the vertex data for the requested `kind` is updatable
         * @param kind defines the data kind (Position, normal, etc...)
         * @returns true if the vertex buffer with the specified kind is updatable
         */
        isVertexBufferUpdatable(kind: string): boolean;
        /**
         * Gets a specific vertex buffer
         * @param kind defines the data kind (Position, normal, etc...)
         * @returns a VertexBuffer
         */
        getVertexBuffer(kind: string): Nullable<VertexBuffer>;
        /**
         * Returns all vertex buffers
         * @return an object holding all vertex buffers indexed by kind
         */
        getVertexBuffers(): Nullable<{
            [key: string]: VertexBuffer;
        }>;
        /**
         * Gets a boolean indicating if specific vertex buffer is present
         * @param kind defines the data kind (Position, normal, etc...)
         * @returns true if data is present
         */
        isVerticesDataPresent(kind: string): boolean;
        /**
         * Gets a list of all attached data kinds (Position, normal, etc...)
         * @returns a list of string containing all kinds
         */
        getVerticesDataKinds(): string[];
        /**
         * Update index buffer
         * @param indices defines the indices to store in the index buffer
         * @param offset defines the offset in the target buffer where to store the data
         * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)
         */
        updateIndices(indices: IndicesArray, offset?: number, gpuMemoryOnly?: boolean): void;
        /**
         * Creates a new index buffer
         * @param indices defines the indices to store in the index buffer
         * @param totalVertices defines the total number of vertices (could be null)
         * @param updatable defines if the index buffer must be flagged as updatable (false by default)
         */
        setIndices(indices: IndicesArray, totalVertices?: Nullable<number>, updatable?: boolean): void;
        /**
         * Return the total number of indices
         * @returns the total number of indices
         */
        getTotalIndices(): number;
        /**
         * Gets the index buffer array
         * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes
         * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it
         * @returns the index buffer array
         */
        getIndices(copyWhenShared?: boolean, forceCopy?: boolean): Nullable<IndicesArray>;
        /**
         * Gets the index buffer
         * @return the index buffer
         */
        getIndexBuffer(): Nullable<DataBuffer>;
        /** @hidden */
        _releaseVertexArrayObject(effect?: Nullable<Effect>): void;
        /**
         * Release the associated resources for a specific mesh
         * @param mesh defines the source mesh
         * @param shouldDispose defines if the geometry must be disposed if there is no more mesh pointing to it
         */
        releaseForMesh(mesh: Mesh, shouldDispose?: boolean): void;
        /**
         * Apply current geometry to a given mesh
         * @param mesh defines the mesh to apply geometry to
         */
        applyToMesh(mesh: Mesh): void;
        private _updateExtend;
        private _applyToMesh;
        private notifyUpdate;
        /**
         * Load the geometry if it was flagged as delay loaded
         * @param scene defines the hosting scene
         * @param onLoaded defines a callback called when the geometry is loaded
         */
        load(scene: Scene, onLoaded?: () => void): void;
        private _queueLoad;
        /**
         * Invert the geometry to move from a right handed system to a left handed one.
         */
        toLeftHanded(): void;
        /** @hidden */
        _resetPointsArrayCache(): void;
        /** @hidden */
        _generatePointsArray(): boolean;
        /**
         * Gets a value indicating if the geometry is disposed
         * @returns true if the geometry was disposed
         */
        isDisposed(): boolean;
        private _disposeVertexArrayObjects;
        /**
         * Free all associated resources
         */
        dispose(): void;
        /**
         * Clone the current geometry into a new geometry
         * @param id defines the unique ID of the new geometry
         * @returns a new geometry object
         */
        copy(id: string): Geometry;
        /**
         * Serialize the current geometry info (and not the vertices data) into a JSON object
         * @return a JSON representation of the current geometry data (without the vertices data)
         */
        serialize(): any;
        private toNumberArray;
        /**
         * Serialize all vertices data into a JSON oject
         * @returns a JSON representation of the current geometry data
         */
        serializeVerticeData(): any;
        /**
         * Extracts a clone of a mesh geometry
         * @param mesh defines the source mesh
         * @param id defines the unique ID of the new geometry object
         * @returns the new geometry object
         */
        static ExtractFromMesh(mesh: Mesh, id: string): Nullable<Geometry>;
        /**
         * You should now use Tools.RandomId(), this method is still here for legacy reasons.
         * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
         * Be aware Math.random() could cause collisions, but:
         * "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
         * @returns a string containing a new GUID
         */
        static RandomId(): string;
        /** @hidden */
        static _ImportGeometry(parsedGeometry: any, mesh: Mesh): void;
        private static _CleanMatricesWeights;
        /**
         * Create a new geometry from persisted data (Using .babylon file format)
         * @param parsedVertexData defines the persisted data
         * @param scene defines the hosting scene
         * @param rootUrl defines the root url to use to load assets (like delayed data)
         * @returns the new geometry object
         */
        static Parse(parsedVertexData: any, scene: Scene, rootUrl: string): Nullable<Geometry>;
    }
}
declare module BABYLON {
    /**
     * Define an interface for all classes that will get and set the data on vertices
     */
    export interface IGetSetVerticesData {
        /**
         * Gets a boolean indicating if specific vertex data is present
         * @param kind defines the vertex data kind to use
         * @returns true is data kind is present
         */
        isVerticesDataPresent(kind: string): boolean;
        /**
         * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.
         * @param kind defines the data kind (Position, normal, etc...)
         * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes
         * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it
         * @returns a float array containing vertex data
         */
        getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray>;
        /**
         * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.
         * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.
         * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it
         * @returns the indices array or an empty array if the mesh has no geometry
         */
        getIndices(copyWhenShared?: boolean, forceCopy?: boolean): Nullable<IndicesArray>;
        /**
         * Set specific vertex data
         * @param kind defines the data kind (Position, normal, etc...)
         * @param data defines the vertex data to use
         * @param updatable defines if the vertex must be flagged as updatable (false as default)
         * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified
         */
        setVerticesData(kind: string, data: FloatArray, updatable: boolean): void;
        /**
         * Update a specific associated vertex buffer
         * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :
         * - VertexBuffer.PositionKind
         * - VertexBuffer.UVKind
         * - VertexBuffer.UV2Kind
         * - VertexBuffer.UV3Kind
         * - VertexBuffer.UV4Kind
         * - VertexBuffer.UV5Kind
         * - VertexBuffer.UV6Kind
         * - VertexBuffer.ColorKind
         * - VertexBuffer.MatricesIndicesKind
         * - VertexBuffer.MatricesIndicesExtraKind
         * - VertexBuffer.MatricesWeightsKind
         * - VertexBuffer.MatricesWeightsExtraKind
         * @param data defines the data source
         * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for "position" kind
         * @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)
         */
        updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): void;
        /**
         * Creates a new index buffer
         * @param indices defines the indices to store in the index buffer
         * @param totalVertices defines the total number of vertices (could be null)
         * @param updatable defines if the index buffer must be flagged as updatable (false by default)
         */
        setIndices(indices: IndicesArray, totalVertices: Nullable<number>, updatable?: boolean): void;
    }
    /**
     * This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance
     */
    export class VertexData {
        /**
         * Mesh side orientation : usually the external or front surface
         */
        static readonly FRONTSIDE: number;
        /**
         * Mesh side orientation : usually the internal or back surface
         */
        static readonly BACKSIDE: number;
        /**
         * Mesh side orientation : both internal and external or front and back surfaces
         */
        static readonly DOUBLESIDE: number;
        /**
         * Mesh side orientation : by default, `FRONTSIDE`
         */
        static readonly DEFAULTSIDE: number;
        /**
         * An array of the x, y, z position of each vertex  [...., x, y, z, .....]
         */
        positions: Nullable<FloatArray>;
        /**
         * An array of the x, y, z normal vector of each vertex  [...., x, y, z, .....]
         */
        normals: Nullable<FloatArray>;
        /**
         * An array of the x, y, z tangent vector of each vertex  [...., x, y, z, .....]
         */
        tangents: Nullable<FloatArray>;
        /**
         * An array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
         */
        uvs: Nullable<FloatArray>;
        /**
         * A second array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
         */
        uvs2: Nullable<FloatArray>;
        /**
         * A third array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
         */
        uvs3: Nullable<FloatArray>;
        /**
         * A fourth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
         */
        uvs4: Nullable<FloatArray>;
        /**
         * A fifth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
         */
        uvs5: Nullable<FloatArray>;
        /**
         * A sixth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
         */
        uvs6: Nullable<FloatArray>;
        /**
         * An array of the r, g, b, a, color of each vertex  [...., r, g, b, a, .....]
         */
        colors: Nullable<FloatArray>;
        /**
         * An array containing the list of indices to the array of matrices produced by bones, each vertex have up to 4 indices (8 if the matricesIndicesExtra is set).
         */
        matricesIndices: Nullable<FloatArray>;
        /**
         * An array containing the list of weights defining the weight of each indexed matrix in the final computation
         */
        matricesWeights: Nullable<FloatArray>;
        /**
         * An array extending the number of possible indices
         */
        matricesIndicesExtra: Nullable<FloatArray>;
        /**
         * An array extending the number of possible weights when the number of indices is extended
         */
        matricesWeightsExtra: Nullable<FloatArray>;
        /**
         * An array of i, j, k the three vertex indices required for each triangular facet  [...., i, j, k .....]
         */
        indices: Nullable<IndicesArray>;
        /**
         * Uses the passed data array to set the set the values for the specified kind of data
         * @param data a linear array of floating numbers
         * @param kind the type of data that is being set, eg positions, colors etc
         */
        set(data: FloatArray, kind: string): void;
        /**
         * Associates the vertexData to the passed Mesh.
         * Sets it as updatable or not (default `false`)
         * @param mesh the mesh the vertexData is applied to
         * @param updatable when used and having the value true allows new data to update the vertexData
         * @returns the VertexData
         */
        applyToMesh(mesh: Mesh, updatable?: boolean): VertexData;
        /**
         * Associates the vertexData to the passed Geometry.
         * Sets it as updatable or not (default `false`)
         * @param geometry the geometry the vertexData is applied to
         * @param updatable when used and having the value true allows new data to update the vertexData
         * @returns VertexData
         */
        applyToGeometry(geometry: Geometry, updatable?: boolean): VertexData;
        /**
         * Updates the associated mesh
         * @param mesh the mesh to be updated
         * @param updateExtends when true the mesh BoundingInfo will be renewed when and if position kind is updated, optional with default false
         * @param makeItUnique when true, and when and if position kind is updated, a new global geometry will be  created from these positions and set to the mesh, optional with default false
         * @returns VertexData
         */
        updateMesh(mesh: Mesh): VertexData;
        /**
         * Updates the associated geometry
         * @param geometry the geometry to be updated
         * @param updateExtends when true BoundingInfo will be renewed when and if position kind is updated, optional with default false
         * @param makeItUnique when true, and when and if position kind is updated, a new global geometry will be created from these positions and set to the mesh, optional with default false
         * @returns VertexData.
         */
        updateGeometry(geometry: Geometry): VertexData;
        private _applyTo;
        private _update;
        /**
         * Transforms each position and each normal of the vertexData according to the passed Matrix
         * @param matrix the transforming matrix
         * @returns the VertexData
         */
        transform(matrix: Matrix): VertexData;
        /**
         * Merges the passed VertexData into the current one
         * @param other the VertexData to be merged into the current one
         * @param use32BitsIndices defines a boolean indicating if indices must be store in a 32 bits array
         * @returns the modified VertexData
         */
        merge(other: VertexData, use32BitsIndices?: boolean): VertexData;
        private _mergeElement;
        private _validate;
        /**
         * Serializes the VertexData
         * @returns a serialized object
         */
        serialize(): any;
        /**
         * Extracts the vertexData from a mesh
         * @param mesh the mesh from which to extract the VertexData
         * @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false
         * @param forceCopy indicating that the VertexData must be cloned, optional, default false
         * @returns the object VertexData associated to the passed mesh
         */
        static ExtractFromMesh(mesh: Mesh, copyWhenShared?: boolean, forceCopy?: boolean): VertexData;
        /**
         * Extracts the vertexData from the geometry
         * @param geometry the geometry from which to extract the VertexData
         * @param copyWhenShared defines if the VertexData must be cloned when the geometrty is shared between multiple meshes, optional, default false
         * @param forceCopy indicating that the VertexData must be cloned, optional, default false
         * @returns the object VertexData associated to the passed mesh
         */
        static ExtractFromGeometry(geometry: Geometry, copyWhenShared?: boolean, forceCopy?: boolean): VertexData;
        private static _ExtractFrom;
        /**
         * Creates the VertexData for a Ribbon
         * @param options an object used to set the following optional parameters for the ribbon, required but can be empty
          * * pathArray array of paths, each of which an array of successive Vector3
          * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false
          * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false
          * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length
          * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
          * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
          * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
          * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false
          * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional
          * * colors a linear array, of length 4 * number of vertices, of custom color values, optional
         * @returns the VertexData of the ribbon
         */
        static CreateRibbon(options: {
            pathArray: Vector3[][];
            closeArray?: boolean;
            closePath?: boolean;
            offset?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            invertUV?: boolean;
            uvs?: Vector2[];
            colors?: Color4[];
        }): VertexData;
        /**
         * Creates the VertexData for a box
         * @param options an object used to set the following optional parameters for the box, required but can be empty
          * * size sets the width, height and depth of the box to the value of size, optional default 1
          * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size
          * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size
          * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size
          * * faceUV an array of 6 Vector4 elements used to set different images to each box side
          * * faceColors an array of 6 Color3 elements used to set different colors to each box side
          * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
          * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
          * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @returns the VertexData of the box
         */
        static CreateBox(options: {
            size?: number;
            width?: number;
            height?: number;
            depth?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }): VertexData;
        /**
         * Creates the VertexData for a tiled box
         * @param options an object used to set the following optional parameters for the box, required but can be empty
          * * faceTiles sets the pattern, tile size and number of tiles for a face
          * * faceUV an array of 6 Vector4 elements used to set different images to each box side
          * * faceColors an array of 6 Color3 elements used to set different colors to each box side
          * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
         * @returns the VertexData of the box
         */
        static CreateTiledBox(options: {
            pattern?: number;
            width?: number;
            height?: number;
            depth?: number;
            tileSize?: number;
            tileWidth?: number;
            tileHeight?: number;
            alignHorizontal?: number;
            alignVertical?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            sideOrientation?: number;
        }): VertexData;
        /**
         * Creates the VertexData for a tiled plane
         * @param options an object used to set the following optional parameters for the box, required but can be empty
          * * pattern a limited pattern arrangement depending on the number
          * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1
          * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size
          * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size
          * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
          * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
          * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @returns the VertexData of the tiled plane
         */
        static CreateTiledPlane(options: {
            pattern?: number;
            tileSize?: number;
            tileWidth?: number;
            tileHeight?: number;
            size?: number;
            width?: number;
            height?: number;
            alignHorizontal?: number;
            alignVertical?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }): VertexData;
        /**
         * Creates the VertexData for an ellipsoid, defaults to a sphere
         * @param options an object used to set the following optional parameters for the box, required but can be empty
          * * segments sets the number of horizontal strips optional, default 32
          * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1
          * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter
          * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter
          * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter
          * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1
          * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1
          * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
          * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
          * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @returns the VertexData of the ellipsoid
         */
        static CreateSphere(options: {
            segments?: number;
            diameter?: number;
            diameterX?: number;
            diameterY?: number;
            diameterZ?: number;
            arc?: number;
            slice?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }): VertexData;
        /**
         * Creates the VertexData for a cylinder, cone or prism
         * @param options an object used to set the following optional parameters for the box, required but can be empty
          * * height sets the height (y direction) of the cylinder, optional, default 2
          * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter
          * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter
          * * diameter sets the diameter of the top and bottom of the cone, optional default 1
          * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24
          * * subdivisions` the number of rings along the cylinder height, optional, default 1
          * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1
          * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
          * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
          * * hasRings when true makes each subdivision independantly treated as a face for faceUV and faceColors, optional, default false
          * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake
          * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
          * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
          * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @returns the VertexData of the cylinder, cone or prism
         */
        static CreateCylinder(options: {
            height?: number;
            diameterTop?: number;
            diameterBottom?: number;
            diameter?: number;
            tessellation?: number;
            subdivisions?: number;
            arc?: number;
            faceColors?: Color4[];
            faceUV?: Vector4[];
            hasRings?: boolean;
            enclose?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }): VertexData;
        /**
         * Creates the VertexData for a torus
         * @param options an object used to set the following optional parameters for the box, required but can be empty
          * * diameter the diameter of the torus, optional default 1
          * * thickness the diameter of the tube forming the torus, optional default 0.5
          * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24
          * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
          * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
          * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @returns the VertexData of the torus
         */
        static CreateTorus(options: {
            diameter?: number;
            thickness?: number;
            tessellation?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }): VertexData;
        /**
         * Creates the VertexData of the LineSystem
         * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty
         *  - lines an array of lines, each line being an array of successive Vector3
         *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point
         * @returns the VertexData of the LineSystem
         */
        static CreateLineSystem(options: {
            lines: Vector3[][];
            colors?: Nullable<Color4[][]>;
        }): VertexData;
        /**
         * Create the VertexData for a DashedLines
         * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty
         *  - points an array successive Vector3
         *  - dashSize the size of the dashes relative to the dash number, optional, default 3
         *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1
         *  - dashNb the intended total number of dashes, optional, default 200
         * @returns the VertexData for the DashedLines
         */
        static CreateDashedLines(options: {
            points: Vector3[];
            dashSize?: number;
            gapSize?: number;
            dashNb?: number;
        }): VertexData;
        /**
         * Creates the VertexData for a Ground
         * @param options an object used to set the following optional parameters for the Ground, required but can be empty
         *  - width the width (x direction) of the ground, optional, default 1
         *  - height the height (z direction) of the ground, optional, default 1
         *  - subdivisions the number of subdivisions per side, optional, default 1
         * @returns the VertexData of the Ground
         */
        static CreateGround(options: {
            width?: number;
            height?: number;
            subdivisions?: number;
            subdivisionsX?: number;
            subdivisionsY?: number;
        }): VertexData;
        /**
         * Creates the VertexData for a TiledGround by subdividing the ground into tiles
         * @param options an object used to set the following optional parameters for the Ground, required but can be empty
          * * xmin the ground minimum X coordinate, optional, default -1
          * * zmin the ground minimum Z coordinate, optional, default -1
          * * xmax the ground maximum X coordinate, optional, default 1
          * * zmax the ground maximum Z coordinate, optional, default 1
          * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}
          * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}
         * @returns the VertexData of the TiledGround
         */
        static CreateTiledGround(options: {
            xmin: number;
            zmin: number;
            xmax: number;
            zmax: number;
            subdivisions?: {
                w: number;
                h: number;
            };
            precision?: {
                w: number;
                h: number;
            };
        }): VertexData;
        /**
         * Creates the VertexData of the Ground designed from a heightmap
         * @param options an object used to set the following parameters for the Ground, required and provided by MeshBuilder.CreateGroundFromHeightMap
          * * width the width (x direction) of the ground
          * * height the height (z direction) of the ground
          * * subdivisions the number of subdivisions per side
          * * minHeight the minimum altitude on the ground, optional, default 0
          * * maxHeight the maximum altitude on the ground, optional default 1
          * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)
          * * buffer the array holding the image color data
          * * bufferWidth the width of image
          * * bufferHeight the height of image
          * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)
         * @returns the VertexData of the Ground designed from a heightmap
         */
        static CreateGroundFromHeightMap(options: {
            width: number;
            height: number;
            subdivisions: number;
            minHeight: number;
            maxHeight: number;
            colorFilter: Color3;
            buffer: Uint8Array;
            bufferWidth: number;
            bufferHeight: number;
            alphaFilter: number;
        }): VertexData;
        /**
         * Creates the VertexData for a Plane
         * @param options an object used to set the following optional parameters for the plane, required but can be empty
          * * size sets the width and height of the plane to the value of size, optional default 1
          * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size
          * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size
          * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
          * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
          * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @returns the VertexData of the box
         */
        static CreatePlane(options: {
            size?: number;
            width?: number;
            height?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }): VertexData;
        /**
         * Creates the VertexData of the Disc or regular Polygon
         * @param options an object used to set the following optional parameters for the disc, required but can be empty
          * * radius the radius of the disc, optional default 0.5
          * * tessellation the number of polygon sides, optional, default 64
          * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1
          * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
          * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
          * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @returns the VertexData of the box
         */
        static CreateDisc(options: {
            radius?: number;
            tessellation?: number;
            arc?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }): VertexData;
        /**
         * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()
         * All parameters are provided by MeshBuilder.CreatePolygon as needed
         * @param polygon a mesh built from polygonTriangulation.build()
         * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
         * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
         * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
         * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
         * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @param wrap a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side
         * @returns the VertexData of the Polygon
         */
        static CreatePolygon(polygon: Mesh, sideOrientation: number, fUV?: Vector4[], fColors?: Color4[], frontUVs?: Vector4, backUVs?: Vector4, wrap?: boolean): VertexData;
        /**
         * Creates the VertexData of the IcoSphere
         * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty
          * * radius the radius of the IcoSphere, optional default 1
          * * radiusX allows stretching in the x direction, optional, default radius
          * * radiusY allows stretching in the y direction, optional, default radius
          * * radiusZ allows stretching in the z direction, optional, default radius
          * * flat when true creates a flat shaded mesh, optional, default true
          * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4
          * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
          * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
          * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @returns the VertexData of the IcoSphere
         */
        static CreateIcoSphere(options: {
            radius?: number;
            radiusX?: number;
            radiusY?: number;
            radiusZ?: number;
            flat?: boolean;
            subdivisions?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }): VertexData;
        /**
         * Creates the VertexData for a Polyhedron
         * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty
         * * type provided types are:
         *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)
         *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)
         * * size the size of the IcoSphere, optional default 1
         * * sizeX allows stretching in the x direction, optional, default size
         * * sizeY allows stretching in the y direction, optional, default size
         * * sizeZ allows stretching in the z direction, optional, default size
         * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor
         * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
         * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
         * * flat when true creates a flat shaded mesh, optional, default true
         * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4
         * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
         * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
         * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @returns the VertexData of the Polyhedron
         */
        static CreatePolyhedron(options: {
            type?: number;
            size?: number;
            sizeX?: number;
            sizeY?: number;
            sizeZ?: number;
            custom?: any;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            flat?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }): VertexData;
        /**
         * Creates the VertexData for a Capsule, inspired from https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js
         * @param options an object used to set the following optional parameters for the capsule, required but can be empty
         * @returns the VertexData of the Capsule
         */
        static CreateCapsule(options?: ICreateCapsuleOptions): VertexData;
        /**
         * Creates the VertexData for a TorusKnot
         * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty
          * * radius the radius of the torus knot, optional, default 2
          * * tube the thickness of the tube, optional, default 0.5
          * * radialSegments the number of sides on each tube segments, optional, default 32
          * * tubularSegments the number of tubes to decompose the knot into, optional, default 32
          * * p the number of windings around the z axis, optional,  default 2
          * * q the number of windings around the x axis, optional,  default 3
          * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
          * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
          * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @returns the VertexData of the Torus Knot
         */
        static CreateTorusKnot(options: {
            radius?: number;
            tube?: number;
            radialSegments?: number;
            tubularSegments?: number;
            p?: number;
            q?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }): VertexData;
        /**
         * Compute normals for given positions and indices
         * @param positions an array of vertex positions, [...., x, y, z, ......]
         * @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]
         * @param normals an array of vertex normals, [...., x, y, z, ......]
         * @param options an object used to set the following optional parameters for the TorusKnot, optional
          * * facetNormals : optional array of facet normals (vector3)
          * * facetPositions : optional array of facet positions (vector3)
          * * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation
          * * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation
          * * bInfo : optional bounding info, required for facetPartitioning computation
          * * bbSize : optional bounding box size data, required for facetPartitioning computation
          * * subDiv : optional partitioning data about subdivsions on  each axis (int), required for facetPartitioning computation
          * * useRightHandedSystem: optional boolean to for right handed system computation
          * * depthSort : optional boolean to enable the facet depth sort computation
          * * distanceTo : optional Vector3 to compute the facet depth from this location
          * * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location
         */
        static ComputeNormals(positions: any, indices: any, normals: any, options?: {
            facetNormals?: any;
            facetPositions?: any;
            facetPartitioning?: any;
            ratio?: number;
            bInfo?: any;
            bbSize?: Vector3;
            subDiv?: any;
            useRightHandedSystem?: boolean;
            depthSort?: boolean;
            distanceTo?: Vector3;
            depthSortedFacets?: any;
        }): void;
        /** @hidden */
        static _ComputeSides(sideOrientation: number, positions: FloatArray, indices: FloatArray, normals: FloatArray, uvs: FloatArray, frontUVs?: Vector4, backUVs?: Vector4): void;
        /**
         * Applies VertexData created from the imported parameters to the geometry
         * @param parsedVertexData the parsed data from an imported file
         * @param geometry the geometry to apply the VertexData to
         */
        static ImportVertexData(parsedVertexData: any, geometry: Geometry): void;
    }
}
declare module BABYLON {
    /**
     * Defines a target to use with MorphTargetManager
     * @see https://doc.babylonjs.com/how_to/how_to_use_morphtargets
     */
    export class MorphTarget implements IAnimatable {
        /** defines the name of the target */
        name: string;
        /**
         * Gets or sets the list of animations
         */
        animations: Animation[];
        private _scene;
        private _positions;
        private _normals;
        private _tangents;
        private _uvs;
        private _influence;
        private _uniqueId;
        /**
         * Observable raised when the influence changes
         */
        onInfluenceChanged: Observable<boolean>;
        /** @hidden */
        _onDataLayoutChanged: Observable<void>;
        /**
         * Gets or sets the influence of this target (ie. its weight in the overall morphing)
         */
        get influence(): number;
        set influence(influence: number);
        /**
         * Gets or sets the id of the morph Target
         */
        id: string;
        private _animationPropertiesOverride;
        /**
         * Gets or sets the animation properties override
         */
        get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride>;
        set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>);
        /**
         * Creates a new MorphTarget
         * @param name defines the name of the target
         * @param influence defines the influence to use
         * @param scene defines the scene the morphtarget belongs to
         */
        constructor(
        /** defines the name of the target */
        name: string, influence?: number, scene?: Nullable<Scene>);
        /**
         * Gets the unique ID of this manager
         */
        get uniqueId(): number;
        /**
         * Gets a boolean defining if the target contains position data
         */
        get hasPositions(): boolean;
        /**
         * Gets a boolean defining if the target contains normal data
         */
        get hasNormals(): boolean;
        /**
         * Gets a boolean defining if the target contains tangent data
         */
        get hasTangents(): boolean;
        /**
         * Gets a boolean defining if the target contains texture coordinates data
         */
        get hasUVs(): boolean;
        /**
         * Affects position data to this target
         * @param data defines the position data to use
         */
        setPositions(data: Nullable<FloatArray>): void;
        /**
         * Gets the position data stored in this target
         * @returns a FloatArray containing the position data (or null if not present)
         */
        getPositions(): Nullable<FloatArray>;
        /**
         * Affects normal data to this target
         * @param data defines the normal data to use
         */
        setNormals(data: Nullable<FloatArray>): void;
        /**
         * Gets the normal data stored in this target
         * @returns a FloatArray containing the normal data (or null if not present)
         */
        getNormals(): Nullable<FloatArray>;
        /**
         * Affects tangent data to this target
         * @param data defines the tangent data to use
         */
        setTangents(data: Nullable<FloatArray>): void;
        /**
         * Gets the tangent data stored in this target
         * @returns a FloatArray containing the tangent data (or null if not present)
         */
        getTangents(): Nullable<FloatArray>;
        /**
         * Affects texture coordinates data to this target
         * @param data defines the texture coordinates data to use
         */
        setUVs(data: Nullable<FloatArray>): void;
        /**
         * Gets the texture coordinates data stored in this target
         * @returns a FloatArray containing the texture coordinates data (or null if not present)
         */
        getUVs(): Nullable<FloatArray>;
        /**
         * Clone the current target
         * @returns a new MorphTarget
         */
        clone(): MorphTarget;
        /**
         * Serializes the current target into a Serialization object
         * @returns the serialized object
         */
        serialize(): any;
        /**
         * Returns the string "MorphTarget"
         * @returns "MorphTarget"
         */
        getClassName(): string;
        /**
         * Creates a new target from serialized data
         * @param serializationObject defines the serialized data to use
         * @returns a new MorphTarget
         */
        static Parse(serializationObject: any): MorphTarget;
        /**
         * Creates a MorphTarget from mesh data
         * @param mesh defines the source mesh
         * @param name defines the name to use for the new target
         * @param influence defines the influence to attach to the target
         * @returns a new MorphTarget
         */
        static FromMesh(mesh: AbstractMesh, name?: string, influence?: number): MorphTarget;
    }
}
declare module BABYLON {
    /**
     * This class is used to deform meshes using morphing between different targets
     * @see https://doc.babylonjs.com/how_to/how_to_use_morphtargets
     */
    export class MorphTargetManager {
        private _targets;
        private _targetInfluenceChangedObservers;
        private _targetDataLayoutChangedObservers;
        private _activeTargets;
        private _scene;
        private _influences;
        private _supportsNormals;
        private _supportsTangents;
        private _supportsUVs;
        private _vertexCount;
        private _uniqueId;
        private _tempInfluences;
        /**
         * Gets or sets a boolean indicating if normals must be morphed
         */
        enableNormalMorphing: boolean;
        /**
         * Gets or sets a boolean indicating if tangents must be morphed
         */
        enableTangentMorphing: boolean;
        /**
         * Gets or sets a boolean indicating if UV must be morphed
         */
        enableUVMorphing: boolean;
        /**
         * Creates a new MorphTargetManager
         * @param scene defines the current scene
         */
        constructor(scene?: Nullable<Scene>);
        /**
         * Gets the unique ID of this manager
         */
        get uniqueId(): number;
        /**
         * Gets the number of vertices handled by this manager
         */
        get vertexCount(): number;
        /**
         * Gets a boolean indicating if this manager supports morphing of normals
         */
        get supportsNormals(): boolean;
        /**
         * Gets a boolean indicating if this manager supports morphing of tangents
         */
        get supportsTangents(): boolean;
        /**
         * Gets a boolean indicating if this manager supports morphing of texture coordinates
         */
        get supportsUVs(): boolean;
        /**
         * Gets the number of targets stored in this manager
         */
        get numTargets(): number;
        /**
         * Gets the number of influencers (ie. the number of targets with influences > 0)
         */
        get numInfluencers(): number;
        /**
         * Gets the list of influences (one per target)
         */
        get influences(): Float32Array;
        /**
         * Gets the active target at specified index. An active target is a target with an influence > 0
         * @param index defines the index to check
         * @returns the requested target
         */
        getActiveTarget(index: number): MorphTarget;
        /**
         * Gets the target at specified index
         * @param index defines the index to check
         * @returns the requested target
         */
        getTarget(index: number): MorphTarget;
        /**
         * Add a new target to this manager
         * @param target defines the target to add
         */
        addTarget(target: MorphTarget): void;
        /**
         * Removes a target from the manager
         * @param target defines the target to remove
         */
        removeTarget(target: MorphTarget): void;
        /**
         * Clone the current manager
         * @returns a new MorphTargetManager
         */
        clone(): MorphTargetManager;
        /**
         * Serializes the current manager into a Serialization object
         * @returns the serialized object
         */
        serialize(): any;
        private _syncActiveTargets;
        /**
         * Syncrhonize the targets with all the meshes using this morph target manager
         */
        synchronize(): void;
        /**
         * Creates a new MorphTargetManager from serialized data
         * @param serializationObject defines the serialized data
         * @param scene defines the hosting scene
         * @returns the new MorphTargetManager
         */
        static Parse(serializationObject: any, scene: Scene): MorphTargetManager;
    }
}
declare module BABYLON {
    /**
     * Class used to represent a specific level of detail of a mesh
     * @see https://doc.babylonjs.com/how_to/how_to_use_lod
     */
    export class MeshLODLevel {
        /** Defines the distance where this level should start being displayed */
        distance: number;
        /** Defines the mesh to use to render this level */
        mesh: Nullable<Mesh>;
        /**
         * Creates a new LOD level
         * @param distance defines the distance where this level should star being displayed
         * @param mesh defines the mesh to use to render this level
         */
        constructor(
        /** Defines the distance where this level should start being displayed */
        distance: number, 
        /** Defines the mesh to use to render this level */
        mesh: Nullable<Mesh>);
    }
}
declare module BABYLON {
    /**
     * Helper class used to generate a canvas to manipulate images
     */
    export class CanvasGenerator {
        /**
         * Create a new canvas (or offscreen canvas depending on the context)
         * @param width defines the expected width
         * @param height defines the expected height
         * @return a new canvas or offscreen canvas
         */
        static CreateCanvas(width: number, height: number): HTMLCanvasElement | OffscreenCanvas;
    }
}
declare module BABYLON {
    /**
     * Mesh representing the gorund
     */
    export class GroundMesh extends Mesh {
        /** If octree should be generated */
        generateOctree: boolean;
        private _heightQuads;
        /** @hidden */
        _subdivisionsX: number;
        /** @hidden */
        _subdivisionsY: number;
        /** @hidden */
        _width: number;
        /** @hidden */
        _height: number;
        /** @hidden */
        _minX: number;
        /** @hidden */
        _maxX: number;
        /** @hidden */
        _minZ: number;
        /** @hidden */
        _maxZ: number;
        constructor(name: string, scene: Scene);
        /**
         * "GroundMesh"
         * @returns "GroundMesh"
         */
        getClassName(): string;
        /**
         * The minimum of x and y subdivisions
         */
        get subdivisions(): number;
        /**
         * X subdivisions
         */
        get subdivisionsX(): number;
        /**
         * Y subdivisions
         */
        get subdivisionsY(): number;
        /**
         * This function will update an octree to help to select the right submeshes for rendering, picking and collision computations.
         * Please note that you must have a decent number of submeshes to get performance improvements when using an octree
         * @param chunksCount the number of subdivisions for x and y
         * @param octreeBlocksSize (Default: 32)
         */
        optimize(chunksCount: number, octreeBlocksSize?: number): void;
        /**
         * Returns a height (y) value in the Worl system :
         * the ground altitude at the coordinates (x, z) expressed in the World system.
         * @param x x coordinate
         * @param z z coordinate
         * @returns the ground y position if (x, z) are outside the ground surface.
         */
        getHeightAtCoordinates(x: number, z: number): number;
        /**
         * Returns a normalized vector (Vector3) orthogonal to the ground
         * at the ground coordinates (x, z) expressed in the World system.
         * @param x x coordinate
         * @param z z coordinate
         * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.
         */
        getNormalAtCoordinates(x: number, z: number): Vector3;
        /**
         * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground
         * at the ground coordinates (x, z) expressed in the World system.
         * Doesn't uptade the reference Vector3 if (x, z) are outside the ground surface.
         * @param x x coordinate
         * @param z z coordinate
         * @param ref vector to store the result
         * @returns the GroundMesh.
         */
        getNormalAtCoordinatesToRef(x: number, z: number, ref: Vector3): GroundMesh;
        /**
        * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()
        * if the ground has been updated.
        * This can be used in the render loop.
        * @returns the GroundMesh.
        */
        updateCoordinateHeights(): GroundMesh;
        private _getFacetAt;
        private _initHeightQuads;
        private _computeHeightQuads;
        /**
         * Serializes this ground mesh
         * @param serializationObject object to write serialization to
         */
        serialize(serializationObject: any): void;
        /**
         * Parses a serialized ground mesh
         * @param parsedMesh the serialized mesh
         * @param scene the scene to create the ground mesh in
         * @returns the created ground mesh
         */
        static Parse(parsedMesh: any, scene: Scene): GroundMesh;
    }
}
declare module BABYLON {
    /**
     * Interface for Physics-Joint data
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
     */
    export interface PhysicsJointData {
        /**
         * The main pivot of the joint
         */
        mainPivot?: Vector3;
        /**
         * The connected pivot of the joint
         */
        connectedPivot?: Vector3;
        /**
         * The main axis of the joint
         */
        mainAxis?: Vector3;
        /**
         * The connected axis of the joint
         */
        connectedAxis?: Vector3;
        /**
         * The collision of the joint
         */
        collision?: boolean;
        /**
         * Native Oimo/Cannon/Energy data
         */
        nativeParams?: any;
    }
    /**
     * This is a holder class for the physics joint created by the physics plugin
     * It holds a set of functions to control the underlying joint
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
     */
    export class PhysicsJoint {
        /**
         * The type of the physics joint
         */
        type: number;
        /**
         * The data for the physics joint
         */
        jointData: PhysicsJointData;
        private _physicsJoint;
        protected _physicsPlugin: IPhysicsEnginePlugin;
        /**
         * Initializes the physics joint
         * @param type The type of the physics joint
         * @param jointData The data for the physics joint
         */
        constructor(
        /**
         * The type of the physics joint
         */
        type: number, 
        /**
         * The data for the physics joint
         */
        jointData: PhysicsJointData);
        /**
         * Gets the physics joint
         */
        get physicsJoint(): any;
        /**
         * Sets the physics joint
         */
        set physicsJoint(newJoint: any);
        /**
         * Sets the physics plugin
         */
        set physicsPlugin(physicsPlugin: IPhysicsEnginePlugin);
        /**
         * Execute a function that is physics-plugin specific.
         * @param {Function} func the function that will be executed.
         *                        It accepts two parameters: the physics world and the physics joint
         */
        executeNativeFunction(func: (world: any, physicsJoint: any) => void): void;
        /**
         * Distance-Joint type
         */
        static DistanceJoint: number;
        /**
         * Hinge-Joint type
         */
        static HingeJoint: number;
        /**
         * Ball-and-Socket joint type
         */
        static BallAndSocketJoint: number;
        /**
         * Wheel-Joint type
         */
        static WheelJoint: number;
        /**
         * Slider-Joint type
         */
        static SliderJoint: number;
        /**
         * Prismatic-Joint type
         */
        static PrismaticJoint: number;
        /**
         * Universal-Joint type
         * ENERGY FTW! (compare with this - @see http://ode-wiki.org/wiki/index.php?title=Manual:_Joint_Types_and_Functions)
         */
        static UniversalJoint: number;
        /**
         * Hinge-Joint 2 type
         */
        static Hinge2Joint: number;
        /**
         * Point to Point Joint type.  Similar to a Ball-Joint.  Different in parameters
         */
        static PointToPointJoint: number;
        /**
         * Spring-Joint type
         */
        static SpringJoint: number;
        /**
         * Lock-Joint type
         */
        static LockJoint: number;
    }
    /**
     * A class representing a physics distance joint
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
     */
    export class DistanceJoint extends PhysicsJoint {
        /**
         *
         * @param jointData The data for the Distance-Joint
         */
        constructor(jointData: DistanceJointData);
        /**
         * Update the predefined distance.
         * @param maxDistance The maximum preferred distance
         * @param minDistance The minimum preferred distance
         */
        updateDistance(maxDistance: number, minDistance?: number): void;
    }
    /**
     * Represents a Motor-Enabled Joint
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
     */
    export class MotorEnabledJoint extends PhysicsJoint implements IMotorEnabledJoint {
        /**
         * Initializes the Motor-Enabled Joint
         * @param type The type of the joint
         * @param jointData The physica joint data for the joint
         */
        constructor(type: number, jointData: PhysicsJointData);
        /**
         * Set the motor values.
         * Attention, this function is plugin specific. Engines won't react 100% the same.
         * @param force the force to apply
         * @param maxForce max force for this motor.
         */
        setMotor(force?: number, maxForce?: number): void;
        /**
         * Set the motor's limits.
         * Attention, this function is plugin specific. Engines won't react 100% the same.
         * @param upperLimit The upper limit of the motor
         * @param lowerLimit The lower limit of the motor
         */
        setLimit(upperLimit: number, lowerLimit?: number): void;
    }
    /**
     * This class represents a single physics Hinge-Joint
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
     */
    export class HingeJoint extends MotorEnabledJoint {
        /**
         * Initializes the Hinge-Joint
         * @param jointData The joint data for the Hinge-Joint
         */
        constructor(jointData: PhysicsJointData);
        /**
         * Set the motor values.
         * Attention, this function is plugin specific. Engines won't react 100% the same.
         * @param {number} force the force to apply
         * @param {number} maxForce max force for this motor.
         */
        setMotor(force?: number, maxForce?: number): void;
        /**
         * Set the motor's limits.
         * Attention, this function is plugin specific. Engines won't react 100% the same.
         * @param upperLimit The upper limit of the motor
         * @param lowerLimit The lower limit of the motor
         */
        setLimit(upperLimit: number, lowerLimit?: number): void;
    }
    /**
     * This class represents a dual hinge physics joint (same as wheel joint)
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
     */
    export class Hinge2Joint extends MotorEnabledJoint {
        /**
         * Initializes the Hinge2-Joint
         * @param jointData The joint data for the Hinge2-Joint
         */
        constructor(jointData: PhysicsJointData);
        /**
        * Set the motor values.
        * Attention, this function is plugin specific. Engines won't react 100% the same.
        * @param {number} targetSpeed the speed the motor is to reach
        * @param {number} maxForce max force for this motor.
        * @param {motorIndex} the motor's index, 0 or 1.
        */
        setMotor(targetSpeed?: number, maxForce?: number, motorIndex?: number): void;
        /**
         * Set the motor limits.
         * Attention, this function is plugin specific. Engines won't react 100% the same.
         * @param {number} upperLimit the upper limit
         * @param {number} lowerLimit lower limit
         * @param {motorIndex} the motor's index, 0 or 1.
         */
        setLimit(upperLimit: number, lowerLimit?: number, motorIndex?: number): void;
    }
    /**
     * Interface for a motor enabled joint
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
     */
    export interface IMotorEnabledJoint {
        /**
         * Physics joint
         */
        physicsJoint: any;
        /**
         * Sets the motor of the motor-enabled joint
         * @param force The force of the motor
         * @param maxForce The maximum force of the motor
         * @param motorIndex The index of the motor
         */
        setMotor(force?: number, maxForce?: number, motorIndex?: number): void;
        /**
         * Sets the limit of the motor
         * @param upperLimit The upper limit of the motor
         * @param lowerLimit The lower limit of the motor
         * @param motorIndex The index of the motor
         */
        setLimit(upperLimit: number, lowerLimit?: number, motorIndex?: number): void;
    }
    /**
     * Joint data for a Distance-Joint
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
     */
    export interface DistanceJointData extends PhysicsJointData {
        /**
         * Max distance the 2 joint objects can be apart
         */
        maxDistance: number;
    }
    /**
     * Joint data from a spring joint
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
     */
    export interface SpringJointData extends PhysicsJointData {
        /**
         * Length of the spring
         */
        length: number;
        /**
         * Stiffness of the spring
         */
        stiffness: number;
        /**
         * Damping of the spring
         */
        damping: number;
        /** this callback will be called when applying the force to the impostors. */
        forceApplicationCallback: () => void;
    }
}
declare module BABYLON {
    /**
     * Holds the data for the raycast result
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
     */
    export class PhysicsRaycastResult {
        private _hasHit;
        private _hitDistance;
        private _hitNormalWorld;
        private _hitPointWorld;
        private _rayFromWorld;
        private _rayToWorld;
        /**
         * Gets if there was a hit
         */
        get hasHit(): boolean;
        /**
         * Gets the distance from the hit
         */
        get hitDistance(): number;
        /**
         * Gets the hit normal/direction in the world
         */
        get hitNormalWorld(): Vector3;
        /**
         * Gets the hit point in the world
         */
        get hitPointWorld(): Vector3;
        /**
         * Gets the ray "start point" of the ray in the world
         */
        get rayFromWorld(): Vector3;
        /**
         * Gets the ray "end point" of the ray in the world
         */
        get rayToWorld(): Vector3;
        /**
         * Sets the hit data (normal & point in world space)
         * @param hitNormalWorld defines the normal in world space
         * @param hitPointWorld defines the point in world space
         */
        setHitData(hitNormalWorld: IXYZ, hitPointWorld: IXYZ): void;
        /**
         * Sets the distance from the start point to the hit point
         * @param distance
         */
        setHitDistance(distance: number): void;
        /**
         * Calculates the distance manually
         */
        calculateHitDistance(): void;
        /**
         * Resets all the values to default
         * @param from The from point on world space
         * @param to The to point on world space
         */
        reset(from?: Vector3, to?: Vector3): void;
    }
    /**
     * Interface for the size containing width and height
     */
    interface IXYZ {
        /**
         * X
         */
        x: number;
        /**
         * Y
         */
        y: number;
        /**
         * Z
         */
        z: number;
    }
}
declare module BABYLON {
    /**
     * Interface used to describe a physics joint
     */
    export interface PhysicsImpostorJoint {
        /** Defines the main impostor to which the joint is linked */
        mainImpostor: PhysicsImpostor;
        /** Defines the impostor that is connected to the main impostor using this joint */
        connectedImpostor: PhysicsImpostor;
        /** Defines the joint itself */
        joint: PhysicsJoint;
    }
    /** @hidden */
    export interface IPhysicsEnginePlugin {
        world: any;
        name: string;
        setGravity(gravity: Vector3): void;
        setTimeStep(timeStep: number): void;
        getTimeStep(): number;
        executeStep(delta: number, impostors: Array<PhysicsImpostor>): void;
        applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3): void;
        applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3): void;
        generatePhysicsBody(impostor: PhysicsImpostor): void;
        removePhysicsBody(impostor: PhysicsImpostor): void;
        generateJoint(joint: PhysicsImpostorJoint): void;
        removeJoint(joint: PhysicsImpostorJoint): void;
        isSupported(): boolean;
        setTransformationFromPhysicsBody(impostor: PhysicsImpostor): void;
        setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion): void;
        setLinearVelocity(impostor: PhysicsImpostor, velocity: Nullable<Vector3>): void;
        setAngularVelocity(impostor: PhysicsImpostor, velocity: Nullable<Vector3>): void;
        getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3>;
        getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3>;
        setBodyMass(impostor: PhysicsImpostor, mass: number): void;
        getBodyMass(impostor: PhysicsImpostor): number;
        getBodyFriction(impostor: PhysicsImpostor): number;
        setBodyFriction(impostor: PhysicsImpostor, friction: number): void;
        getBodyRestitution(impostor: PhysicsImpostor): number;
        setBodyRestitution(impostor: PhysicsImpostor, restitution: number): void;
        getBodyPressure?(impostor: PhysicsImpostor): number;
        setBodyPressure?(impostor: PhysicsImpostor, pressure: number): void;
        getBodyStiffness?(impostor: PhysicsImpostor): number;
        setBodyStiffness?(impostor: PhysicsImpostor, stiffness: number): void;
        getBodyVelocityIterations?(impostor: PhysicsImpostor): number;
        setBodyVelocityIterations?(impostor: PhysicsImpostor, velocityIterations: number): void;
        getBodyPositionIterations?(impostor: PhysicsImpostor): number;
        setBodyPositionIterations?(impostor: PhysicsImpostor, positionIterations: number): void;
        appendAnchor?(impostor: PhysicsImpostor, otherImpostor: PhysicsImpostor, width: number, height: number, influence: number, noCollisionBetweenLinkedBodies: boolean): void;
        appendHook?(impostor: PhysicsImpostor, otherImpostor: PhysicsImpostor, length: number, influence: number, noCollisionBetweenLinkedBodies: boolean): void;
        sleepBody(impostor: PhysicsImpostor): void;
        wakeUpBody(impostor: PhysicsImpostor): void;
        raycast(from: Vector3, to: Vector3): PhysicsRaycastResult;
        updateDistanceJoint(joint: PhysicsJoint, maxDistance: number, minDistance?: number): void;
        setMotor(joint: IMotorEnabledJoint, speed: number, maxForce?: number, motorIndex?: number): void;
        setLimit(joint: IMotorEnabledJoint, upperLimit: number, lowerLimit?: number, motorIndex?: number): void;
        getRadius(impostor: PhysicsImpostor): number;
        getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void;
        syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor): void;
        dispose(): void;
    }
    /**
     * Interface used to define a physics engine
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
     */
    export interface IPhysicsEngine {
        /**
         * Gets the gravity vector used by the simulation
         */
        gravity: Vector3;
        /**
         * Sets the gravity vector used by the simulation
         * @param gravity defines the gravity vector to use
         */
        setGravity(gravity: Vector3): void;
        /**
         * Set the time step of the physics engine.
         * Default is 1/60.
         * To slow it down, enter 1/600 for example.
         * To speed it up, 1/30
         * @param newTimeStep the new timestep to apply to this world.
         */
        setTimeStep(newTimeStep: number): void;
        /**
         * Get the time step of the physics engine.
         * @returns the current time step
         */
        getTimeStep(): number;
        /**
         * Set the sub time step of the physics engine.
         * Default is 0 meaning there is no sub steps
         * To increase physics resolution precision, set a small value (like 1 ms)
         * @param subTimeStep defines the new sub timestep used for physics resolution.
         */
        setSubTimeStep(subTimeStep: number): void;
        /**
         * Get the sub time step of the physics engine.
         * @returns the current sub time step
         */
        getSubTimeStep(): number;
        /**
         * Release all resources
         */
        dispose(): void;
        /**
         * Gets the name of the current physics plugin
         * @returns the name of the plugin
         */
        getPhysicsPluginName(): string;
        /**
         * Adding a new impostor for the impostor tracking.
         * This will be done by the impostor itself.
         * @param impostor the impostor to add
         */
        addImpostor(impostor: PhysicsImpostor): void;
        /**
         * Remove an impostor from the engine.
         * This impostor and its mesh will not longer be updated by the physics engine.
         * @param impostor the impostor to remove
         */
        removeImpostor(impostor: PhysicsImpostor): void;
        /**
         * Add a joint to the physics engine
         * @param mainImpostor defines the main impostor to which the joint is added.
         * @param connectedImpostor defines the impostor that is connected to the main impostor using this joint
         * @param joint defines the joint that will connect both impostors.
         */
        addJoint(mainImpostor: PhysicsImpostor, connectedImpostor: PhysicsImpostor, joint: PhysicsJoint): void;
        /**
         * Removes a joint from the simulation
         * @param mainImpostor defines the impostor used with the joint
         * @param connectedImpostor defines the other impostor connected to the main one by the joint
         * @param joint defines the joint to remove
         */
        removeJoint(mainImpostor: PhysicsImpostor, connectedImpostor: PhysicsImpostor, joint: PhysicsJoint): void;
        /**
         * Gets the current plugin used to run the simulation
         * @returns current plugin
         */
        getPhysicsPlugin(): IPhysicsEnginePlugin;
        /**
         * Gets the list of physic impostors
         * @returns an array of PhysicsImpostor
         */
        getImpostors(): Array<PhysicsImpostor>;
        /**
         * Gets the impostor for a physics enabled object
         * @param object defines the object impersonated by the impostor
         * @returns the PhysicsImpostor or null if not found
         */
        getImpostorForPhysicsObject(object: IPhysicsEnabledObject): Nullable<PhysicsImpostor>;
        /**
         * Gets the impostor for a physics body object
         * @param body defines physics body used by the impostor
         * @returns the PhysicsImpostor or null if not found
         */
        getImpostorWithPhysicsBody(body: any): Nullable<PhysicsImpostor>;
        /**
         * Does a raycast in the physics world
         * @param from when should the ray start?
         * @param to when should the ray end?
         * @returns PhysicsRaycastResult
         */
        raycast(from: Vector3, to: Vector3): PhysicsRaycastResult;
        /**
         * Called by the scene. No need to call it.
         * @param delta defines the timespam between frames
         */
        _step(delta: number): void;
    }
}
declare module BABYLON {
    /**
     * The interface for the physics imposter parameters
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
     */
    export interface PhysicsImpostorParameters {
        /**
         * The mass of the physics imposter
         */
        mass: number;
        /**
         * The friction of the physics imposter
         */
        friction?: number;
        /**
         * The coefficient of restitution of the physics imposter
         */
        restitution?: number;
        /**
         * The native options of the physics imposter
         */
        nativeOptions?: any;
        /**
         * Specifies if the parent should be ignored
         */
        ignoreParent?: boolean;
        /**
         * Specifies if bi-directional transformations should be disabled
         */
        disableBidirectionalTransformation?: boolean;
        /**
         * The pressure inside the physics imposter, soft object only
         */
        pressure?: number;
        /**
         * The stiffness the physics imposter, soft object only
         */
        stiffness?: number;
        /**
         * The number of iterations used in maintaining consistent vertex velocities, soft object only
         */
        velocityIterations?: number;
        /**
         * The number of iterations used in maintaining consistent vertex positions, soft object only
         */
        positionIterations?: number;
        /**
         * The number used to fix points on a cloth (0, 1, 2, 4, 8) or rope (0, 1, 2) only
         * 0 None, 1, back left or top, 2, back right or bottom, 4, front left, 8, front right
         * Add to fix multiple points
         */
        fixedPoints?: number;
        /**
         * The collision margin around a soft object
         */
        margin?: number;
        /**
         * The collision margin around a soft object
         */
        damping?: number;
        /**
         * The path for a rope based on an extrusion
         */
        path?: any;
        /**
         * The shape of an extrusion used for a rope based on an extrusion
         */
        shape?: any;
    }
    /**
     * Interface for a physics-enabled object
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
     */
    export interface IPhysicsEnabledObject {
        /**
         * The position of the physics-enabled object
         */
        position: Vector3;
        /**
         * The rotation of the physics-enabled object
         */
        rotationQuaternion: Nullable<Quaternion>;
        /**
         * The scale of the physics-enabled object
         */
        scaling: Vector3;
        /**
         * The rotation of the physics-enabled object
         */
        rotation?: Vector3;
        /**
         * The parent of the physics-enabled object
         */
        parent?: any;
        /**
         * The bounding info of the physics-enabled object
         * @returns The bounding info of the physics-enabled object
         */
        getBoundingInfo(): BoundingInfo;
        /**
         * Computes the world matrix
         * @param force Specifies if the world matrix should be computed by force
         * @returns A world matrix
         */
        computeWorldMatrix(force: boolean): Matrix;
        /**
         * Gets the world matrix
         * @returns A world matrix
         */
        getWorldMatrix?(): Matrix;
        /**
         * Gets the child meshes
         * @param directDescendantsOnly Specifies if only direct-descendants should be obtained
         * @returns An array of abstract meshes
         */
        getChildMeshes?(directDescendantsOnly?: boolean): Array<AbstractMesh>;
        /**
         * Gets the vertex data
         * @param kind The type of vertex data
         * @returns A nullable array of numbers, or a float32 array
         */
        getVerticesData(kind: string): Nullable<Array<number> | Float32Array>;
        /**
         * Gets the indices from the mesh
         * @returns A nullable array of index arrays
         */
        getIndices?(): Nullable<IndicesArray>;
        /**
         * Gets the scene from the mesh
         * @returns the indices array or null
         */
        getScene?(): Scene;
        /**
         * Gets the absolute position from the mesh
         * @returns the absolute position
         */
        getAbsolutePosition(): Vector3;
        /**
         * Gets the absolute pivot point from the mesh
         * @returns the absolute pivot point
         */
        getAbsolutePivotPoint(): Vector3;
        /**
         * Rotates the mesh
         * @param axis The axis of rotation
         * @param amount The amount of rotation
         * @param space The space of the rotation
         * @returns The rotation transform node
         */
        rotate(axis: Vector3, amount: number, space?: Space): TransformNode;
        /**
         * Translates the mesh
         * @param axis The axis of translation
         * @param distance The distance of translation
         * @param space The space of the translation
         * @returns The transform node
         */
        translate(axis: Vector3, distance: number, space?: Space): TransformNode;
        /**
         * Sets the absolute position of the mesh
         * @param absolutePosition The absolute position of the mesh
         * @returns The transform node
         */
        setAbsolutePosition(absolutePosition: Vector3): TransformNode;
        /**
         * Gets the class name of the mesh
         * @returns The class name
         */
        getClassName(): string;
    }
    /**
     * Represents a physics imposter
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
     */
    export class PhysicsImpostor {
        /**
         * The physics-enabled object used as the physics imposter
         */
        object: IPhysicsEnabledObject;
        /**
         * The type of the physics imposter
         */
        type: number;
        private _options;
        private _scene?;
        /**
         * The default object size of the imposter
         */
        static DEFAULT_OBJECT_SIZE: Vector3;
        /**
         * The identity quaternion of the imposter
         */
        static IDENTITY_QUATERNION: Quaternion;
        /** @hidden */
        _pluginData: any;
        private _physicsEngine;
        private _physicsBody;
        private _bodyUpdateRequired;
        private _onBeforePhysicsStepCallbacks;
        private _onAfterPhysicsStepCallbacks;
        /** @hidden */
        _onPhysicsCollideCallbacks: Array<{
            callback: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor) => void;
            otherImpostors: Array<PhysicsImpostor>;
        }>;
        private _deltaPosition;
        private _deltaRotation;
        private _deltaRotationConjugated;
        /** @hidden */
        _isFromLine: boolean;
        private _parent;
        private _isDisposed;
        private static _tmpVecs;
        private static _tmpQuat;
        /**
         * Specifies if the physics imposter is disposed
         */
        get isDisposed(): boolean;
        /**
         * Gets the mass of the physics imposter
         */
        get mass(): number;
        set mass(value: number);
        /**
         * Gets the coefficient of friction
         */
        get friction(): number;
        /**
         * Sets the coefficient of friction
         */
        set friction(value: number);
        /**
         * Gets the coefficient of restitution
         */
        get restitution(): number;
        /**
         * Sets the coefficient of restitution
         */
        set restitution(value: number);
        /**
         * Gets the pressure of a soft body; only supported by the AmmoJSPlugin
         */
        get pressure(): number;
        /**
         * Sets the pressure of a soft body; only supported by the AmmoJSPlugin
         */
        set pressure(value: number);
        /**
         * Gets the stiffness of a soft body; only supported by the AmmoJSPlugin
         */
        get stiffness(): number;
        /**
         * Sets the stiffness of a soft body; only supported by the AmmoJSPlugin
         */
        set stiffness(value: number);
        /**
         * Gets the velocityIterations of a soft body; only supported by the AmmoJSPlugin
         */
        get velocityIterations(): number;
        /**
         * Sets the velocityIterations of a soft body; only supported by the AmmoJSPlugin
         */
        set velocityIterations(value: number);
        /**
         * Gets the positionIterations of a soft body; only supported by the AmmoJSPlugin
         */
        get positionIterations(): number;
        /**
         * Sets the positionIterations of a soft body; only supported by the AmmoJSPlugin
         */
        set positionIterations(value: number);
        /**
         * The unique id of the physics imposter
         * set by the physics engine when adding this impostor to the array
         */
        uniqueId: number;
        /**
         * @hidden
         */
        soft: boolean;
        /**
         * @hidden
         */
        segments: number;
        private _joints;
        /**
         * Initializes the physics imposter
         * @param object The physics-enabled object used as the physics imposter
         * @param type The type of the physics imposter
         * @param _options The options for the physics imposter
         * @param _scene The Babylon scene
         */
        constructor(
        /**
         * The physics-enabled object used as the physics imposter
         */
        object: IPhysicsEnabledObject, 
        /**
         * The type of the physics imposter
         */
        type: number, _options?: PhysicsImpostorParameters, _scene?: Scene | undefined);
        /**
         * This function will completly initialize this impostor.
         * It will create a new body - but only if this mesh has no parent.
         * If it has, this impostor will not be used other than to define the impostor
         * of the child mesh.
         * @hidden
         */
        _init(): void;
        private _getPhysicsParent;
        /**
         * Should a new body be generated.
         * @returns boolean specifying if body initialization is required
         */
        isBodyInitRequired(): boolean;
        /**
         * Sets the updated scaling
         * @param updated Specifies if the scaling is updated
         */
        setScalingUpdated(): void;
        /**
         * Force a regeneration of this or the parent's impostor's body.
         * Use under cautious - This will remove all joints already implemented.
         */
        forceUpdate(): void;
        /**
         * Gets the body that holds this impostor. Either its own, or its parent.
         */
        get physicsBody(): any;
        /**
         * Get the parent of the physics imposter
         * @returns Physics imposter or null
         */
        get parent(): Nullable<PhysicsImpostor>;
        /**
         * Sets the parent of the physics imposter
         */
        set parent(value: Nullable<PhysicsImpostor>);
        /**
         * Set the physics body. Used mainly by the physics engine/plugin
         */
        set physicsBody(physicsBody: any);
        /**
         * Resets the update flags
         */
        resetUpdateFlags(): void;
        /**
         * Gets the object extend size
         * @returns the object extend size
         */
        getObjectExtendSize(): Vector3;
        /**
         * Gets the object center
         * @returns The object center
         */
        getObjectCenter(): Vector3;
        /**
         * Get a specific parameter from the options parameters
         * @param paramName The object parameter name
         * @returns The object parameter
         */
        getParam(paramName: string): any;
        /**
         * Sets a specific parameter in the options given to the physics plugin
         * @param paramName The parameter name
         * @param value The value of the parameter
         */
        setParam(paramName: string, value: number): void;
        /**
         * Specifically change the body's mass option. Won't recreate the physics body object
         * @param mass The mass of the physics imposter
         */
        setMass(mass: number): void;
        /**
         * Gets the linear velocity
         * @returns  linear velocity or null
         */
        getLinearVelocity(): Nullable<Vector3>;
        /**
         * Sets the linear velocity
         * @param velocity  linear velocity or null
         */
        setLinearVelocity(velocity: Nullable<Vector3>): void;
        /**
         * Gets the angular velocity
         * @returns angular velocity or null
         */
        getAngularVelocity(): Nullable<Vector3>;
        /**
         * Sets the angular velocity
         * @param velocity The velocity or null
         */
        setAngularVelocity(velocity: Nullable<Vector3>): void;
        /**
         * Execute a function with the physics plugin native code
         * Provide a function the will have two variables - the world object and the physics body object
         * @param func The function to execute with the physics plugin native code
         */
        executeNativeFunction(func: (world: any, physicsBody: any) => void): void;
        /**
         * Register a function that will be executed before the physics world is stepping forward
         * @param func The function to execute before the physics world is stepped forward
         */
        registerBeforePhysicsStep(func: (impostor: PhysicsImpostor) => void): void;
        /**
         * Unregister a function that will be executed before the physics world is stepping forward
         * @param func The function to execute before the physics world is stepped forward
         */
        unregisterBeforePhysicsStep(func: (impostor: PhysicsImpostor) => void): void;
        /**
         * Register a function that will be executed after the physics step
         * @param func The function to execute after physics step
         */
        registerAfterPhysicsStep(func: (impostor: PhysicsImpostor) => void): void;
        /**
         * Unregisters a function that will be executed after the physics step
         * @param func The function to execute after physics step
         */
        unregisterAfterPhysicsStep(func: (impostor: PhysicsImpostor) => void): void;
        /**
         * register a function that will be executed when this impostor collides against a different body
         * @param collideAgainst Physics imposter, or array of physics imposters to collide against
         * @param func Callback that is executed on collision
         */
        registerOnPhysicsCollide(collideAgainst: PhysicsImpostor | Array<PhysicsImpostor>, func: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor) => void): void;
        /**
         * Unregisters the physics imposter on contact
         * @param collideAgainst The physics object to collide against
         * @param func Callback to execute on collision
         */
        unregisterOnPhysicsCollide(collideAgainst: PhysicsImpostor | Array<PhysicsImpostor>, func: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor | Array<PhysicsImpostor>) => void): void;
        private _tmpQuat;
        private _tmpQuat2;
        /**
         * Get the parent rotation
         * @returns The parent rotation
         */
        getParentsRotation(): Quaternion;
        /**
         * this function is executed by the physics engine.
         */
        beforeStep: () => void;
        /**
         * this function is executed by the physics engine
         */
        afterStep: () => void;
        /**
         * Legacy collision detection event support
         */
        onCollideEvent: Nullable<(collider: PhysicsImpostor, collidedWith: PhysicsImpostor) => void>;
        /**
         * event and body object due to cannon's event-based architecture.
         */
        onCollide: (e: {
            body: any;
        }) => void;
        /**
         * Apply a force
         * @param force The force to apply
         * @param contactPoint The contact point for the force
         * @returns The physics imposter
         */
        applyForce(force: Vector3, contactPoint: Vector3): PhysicsImpostor;
        /**
         * Apply an impulse
         * @param force The impulse force
         * @param contactPoint The contact point for the impulse force
         * @returns The physics imposter
         */
        applyImpulse(force: Vector3, contactPoint: Vector3): PhysicsImpostor;
        /**
         * A help function to create a joint
         * @param otherImpostor A physics imposter used to create a joint
         * @param jointType The type of joint
         * @param jointData The data for the joint
         * @returns The physics imposter
         */
        createJoint(otherImpostor: PhysicsImpostor, jointType: number, jointData: PhysicsJointData): PhysicsImpostor;
        /**
         * Add a joint to this impostor with a different impostor
         * @param otherImpostor A physics imposter used to add a joint
         * @param joint The joint to add
         * @returns The physics imposter
         */
        addJoint(otherImpostor: PhysicsImpostor, joint: PhysicsJoint): PhysicsImpostor;
        /**
         * Add an anchor to a cloth impostor
         * @param otherImpostor rigid impostor to anchor to
         * @param width ratio across width from 0 to 1
         * @param height ratio up height from 0 to 1
         * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little strech
         * @param noCollisionBetweenLinkedBodies when true collisions between cloth impostor and anchor are ignored; default false
         * @returns impostor the soft imposter
         */
        addAnchor(otherImpostor: PhysicsImpostor, width: number, height: number, influence: number, noCollisionBetweenLinkedBodies: boolean): PhysicsImpostor;
        /**
         * Add a hook to a rope impostor
         * @param otherImpostor rigid impostor to anchor to
         * @param length ratio across rope from 0 to 1
         * @param influence the elasticity between rope impostor and anchor from 0, very stretchy to 1, little strech
         * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false
         * @returns impostor the rope imposter
         */
        addHook(otherImpostor: PhysicsImpostor, length: number, influence: number, noCollisionBetweenLinkedBodies: boolean): PhysicsImpostor;
        /**
         * Will keep this body still, in a sleep mode.
         * @returns the physics imposter
         */
        sleep(): PhysicsImpostor;
        /**
         * Wake the body up.
         * @returns The physics imposter
         */
        wakeUp(): PhysicsImpostor;
        /**
         * Clones the physics imposter
         * @param newObject The physics imposter clones to this physics-enabled object
         * @returns A nullable physics imposter
         */
        clone(newObject: IPhysicsEnabledObject): Nullable<PhysicsImpostor>;
        /**
         * Disposes the physics imposter
         */
        dispose(): void;
        /**
         * Sets the delta position
         * @param position The delta position amount
         */
        setDeltaPosition(position: Vector3): void;
        /**
         * Sets the delta rotation
         * @param rotation The delta rotation amount
         */
        setDeltaRotation(rotation: Quaternion): void;
        /**
         * Gets the box size of the physics imposter and stores the result in the input parameter
         * @param result Stores the box size
         * @returns The physics imposter
         */
        getBoxSizeToRef(result: Vector3): PhysicsImpostor;
        /**
         * Gets the radius of the physics imposter
         * @returns Radius of the physics imposter
         */
        getRadius(): number;
        /**
         * Sync a bone with this impostor
         * @param bone The bone to sync to the impostor.
         * @param boneMesh The mesh that the bone is influencing.
         * @param jointPivot The pivot of the joint / bone in local space.
         * @param distToJoint Optional distance from the impostor to the joint.
         * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.
         */
        syncBoneWithImpostor(bone: Bone, boneMesh: AbstractMesh, jointPivot: Vector3, distToJoint?: number, adjustRotation?: Quaternion): void;
        /**
         * Sync impostor to a bone
         * @param bone The bone that the impostor will be synced to.
         * @param boneMesh The mesh that the bone is influencing.
         * @param jointPivot The pivot of the joint / bone in local space.
         * @param distToJoint Optional distance from the impostor to the joint.
         * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.
         * @param boneAxis Optional vector3 axis the bone is aligned with
         */
        syncImpostorWithBone(bone: Bone, boneMesh: AbstractMesh, jointPivot: Vector3, distToJoint?: number, adjustRotation?: Quaternion, boneAxis?: Vector3): void;
        /**
         * No-Imposter type
         */
        static NoImpostor: number;
        /**
         * Sphere-Imposter type
         */
        static SphereImpostor: number;
        /**
         * Box-Imposter type
         */
        static BoxImpostor: number;
        /**
         * Plane-Imposter type
         */
        static PlaneImpostor: number;
        /**
         * Mesh-imposter type
         */
        static MeshImpostor: number;
        /**
         * Capsule-Impostor type (Ammo.js plugin only)
         */
        static CapsuleImpostor: number;
        /**
         * Cylinder-Imposter type
         */
        static CylinderImpostor: number;
        /**
         * Particle-Imposter type
         */
        static ParticleImpostor: number;
        /**
         * Heightmap-Imposter type
         */
        static HeightmapImpostor: number;
        /**
         * ConvexHull-Impostor type (Ammo.js plugin only)
         */
        static ConvexHullImpostor: number;
        /**
         * Custom-Imposter type (Ammo.js plugin only)
         */
        static CustomImpostor: number;
        /**
         * Rope-Imposter type
         */
        static RopeImpostor: number;
        /**
         * Cloth-Imposter type
         */
        static ClothImpostor: number;
        /**
         * Softbody-Imposter type
         */
        static SoftbodyImpostor: number;
    }
}
declare module BABYLON {
    /**
     * @hidden
     **/
    export class _CreationDataStorage {
        closePath?: boolean;
        closeArray?: boolean;
        idx: number[];
        dashSize: number;
        gapSize: number;
        path3D: Path3D;
        pathArray: Vector3[][];
        arc: number;
        radius: number;
        cap: number;
        tessellation: number;
    }
    /**
     * @hidden
     **/
    class _InstanceDataStorage {
        visibleInstances: any;
        batchCache: _InstancesBatch;
        instancesBufferSize: number;
        instancesBuffer: Nullable<Buffer>;
        instancesData: Float32Array;
        overridenInstanceCount: number;
        isFrozen: boolean;
        previousBatch: Nullable<_InstancesBatch>;
        hardwareInstancedRendering: boolean;
        sideOrientation: number;
        manualUpdate: boolean;
        previousRenderId: number;
    }
    /**
     * @hidden
     **/
    export class _InstancesBatch {
        mustReturn: boolean;
        visibleInstances: Nullable<InstancedMesh[]>[];
        renderSelf: boolean[];
        hardwareInstancedRendering: boolean[];
    }
    /**
     * @hidden
     **/
    class _ThinInstanceDataStorage {
        instancesCount: number;
        matrixBuffer: Nullable<Buffer>;
        matrixBufferSize: number;
        matrixData: Nullable<Float32Array>;
        boundingVectors: Array<Vector3>;
        worldMatrices: Nullable<Matrix[]>;
    }
    /**
     * Class used to represent renderable models
     */
    export class Mesh extends AbstractMesh implements IGetSetVerticesData {
        /**
         * Mesh side orientation : usually the external or front surface
         */
        static readonly FRONTSIDE: number;
        /**
         * Mesh side orientation : usually the internal or back surface
         */
        static readonly BACKSIDE: number;
        /**
         * Mesh side orientation : both internal and external or front and back surfaces
         */
        static readonly DOUBLESIDE: number;
        /**
         * Mesh side orientation : by default, `FRONTSIDE`
         */
        static readonly DEFAULTSIDE: number;
        /**
         * Mesh cap setting : no cap
         */
        static readonly NO_CAP: number;
        /**
         * Mesh cap setting : one cap at the beginning of the mesh
         */
        static readonly CAP_START: number;
        /**
         * Mesh cap setting : one cap at the end of the mesh
         */
        static readonly CAP_END: number;
        /**
         * Mesh cap setting : two caps, one at the beginning  and one at the end of the mesh
         */
        static readonly CAP_ALL: number;
        /**
         * Mesh pattern setting : no flip or rotate
         */
        static readonly NO_FLIP: number;
        /**
         * Mesh pattern setting : flip (reflect in y axis) alternate tiles on each row or column
         */
        static readonly FLIP_TILE: number;
        /**
         * Mesh pattern setting : rotate (180degs) alternate tiles on each row or column
         */
        static readonly ROTATE_TILE: number;
        /**
         * Mesh pattern setting : flip (reflect in y axis) all tiles on alternate rows
         */
        static readonly FLIP_ROW: number;
        /**
         * Mesh pattern setting : rotate (180degs) all tiles on alternate rows
         */
        static readonly ROTATE_ROW: number;
        /**
         * Mesh pattern setting : flip and rotate alternate tiles on each row or column
         */
        static readonly FLIP_N_ROTATE_TILE: number;
        /**
         * Mesh pattern setting : rotate pattern and rotate
         */
        static readonly FLIP_N_ROTATE_ROW: number;
        /**
         * Mesh tile positioning : part tiles same on left/right or top/bottom
         */
        static readonly CENTER: number;
        /**
         * Mesh tile positioning : part tiles on left
         */
        static readonly LEFT: number;
        /**
         * Mesh tile positioning : part tiles on right
         */
        static readonly RIGHT: number;
        /**
         * Mesh tile positioning : part tiles on top
         */
        static readonly TOP: number;
        /**
         * Mesh tile positioning : part tiles on bottom
         */
        static readonly BOTTOM: number;
        /**
         * Gets the default side orientation.
         * @param orientation the orientation to value to attempt to get
         * @returns the default orientation
         * @hidden
         */
        static _GetDefaultSideOrientation(orientation?: number): number;
        private _internalMeshDataInfo;
        get computeBonesUsingShaders(): boolean;
        set computeBonesUsingShaders(value: boolean);
        /**
         * An event triggered before rendering the mesh
         */
        get onBeforeRenderObservable(): Observable<Mesh>;
        /**
         * An event triggered before binding the mesh
         */
        get onBeforeBindObservable(): Observable<Mesh>;
        /**
        * An event triggered after rendering the mesh
        */
        get onAfterRenderObservable(): Observable<Mesh>;
        /**
        * An event triggered before drawing the mesh
        */
        get onBeforeDrawObservable(): Observable<Mesh>;
        private _onBeforeDrawObserver;
        /**
         * Sets a callback to call before drawing the mesh. It is recommended to use onBeforeDrawObservable instead
         */
        set onBeforeDraw(callback: () => void);
        get hasInstances(): boolean;
        get hasThinInstances(): boolean;
        /**
         * Gets the delay loading state of the mesh (when delay loading is turned on)
         * @see https://doc.babylonjs.com/how_to/using_the_incremental_loading_system
         */
        delayLoadState: number;
        /**
         * Gets the list of instances created from this mesh
         * it is not supposed to be modified manually.
         * Note also that the order of the InstancedMesh wihin the array is not significant and might change.
         * @see https://doc.babylonjs.com/how_to/how_to_use_instances
         */
        instances: InstancedMesh[];
        /**
         * Gets the file containing delay loading data for this mesh
         */
        delayLoadingFile: string;
        /** @hidden */
        _binaryInfo: any;
        /**
         * User defined function used to change how LOD level selection is done
         * @see https://doc.babylonjs.com/how_to/how_to_use_lod
         */
        onLODLevelSelection: (distance: number, mesh: Mesh, selectedLevel: Nullable<Mesh>) => void;
        /**
         * Gets or sets the morph target manager
         * @see https://doc.babylonjs.com/how_to/how_to_use_morphtargets
         */
        get morphTargetManager(): Nullable<MorphTargetManager>;
        set morphTargetManager(value: Nullable<MorphTargetManager>);
        /** @hidden */
        _creationDataStorage: Nullable<_CreationDataStorage>;
        /** @hidden */
        _geometry: Nullable<Geometry>;
        /** @hidden */
        _delayInfo: Array<string>;
        /** @hidden */
        _delayLoadingFunction: (any: any, mesh: Mesh) => void;
        /** @hidden */
        _instanceDataStorage: _InstanceDataStorage;
        /** @hidden */
        _thinInstanceDataStorage: _ThinInstanceDataStorage;
        private _effectiveMaterial;
        /** @hidden */
        _shouldGenerateFlatShading: boolean;
        /** @hidden */
        _originalBuilderSideOrientation: number;
        /**
         * Use this property to change the original side orientation defined at construction time
         */
        overrideMaterialSideOrientation: Nullable<number>;
        /**
         * Gets the source mesh (the one used to clone this one from)
         */
        get source(): Nullable<Mesh>;
        /**
         * Gets the list of clones of this mesh
         * The scene must have been constructed with useClonedMeshMap=true for this to work!
         * Note that useClonedMeshMap=true is the default setting
         */
        get cloneMeshMap(): Nullable<{
            [id: string]: Mesh | undefined;
        }>;
        /**
         * Gets or sets a boolean indicating that this mesh does not use index buffer
         */
        get isUnIndexed(): boolean;
        set isUnIndexed(value: boolean);
        /** Gets the array buffer used to store the instanced buffer used for instances' world matrices */
        get worldMatrixInstancedBuffer(): Float32Array;
        /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices is manual */
        get manualUpdateOfWorldMatrixInstancedBuffer(): boolean;
        set manualUpdateOfWorldMatrixInstancedBuffer(value: boolean);
        /**
         * @constructor
         * @param name The value used by scene.getMeshByName() to do a lookup.
         * @param scene The scene to add this mesh to.
         * @param parent The parent of this mesh, if it has one
         * @param source An optional Mesh from which geometry is shared, cloned.
         * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.
         *                  When false, achieved by calling a clone(), also passing False.
         *                  This will make creation of children, recursive.
         * @param clonePhysicsImpostor When cloning, include cloning mesh physics impostor, default True.
         */
        constructor(name: string, scene?: Nullable<Scene>, parent?: Nullable<Node>, source?: Nullable<Mesh>, doNotCloneChildren?: boolean, clonePhysicsImpostor?: boolean);
        instantiateHierarchy(newParent?: Nullable<TransformNode>, options?: {
            doNotInstantiate: boolean;
        }, onNewNodeCreated?: (source: TransformNode, clone: TransformNode) => void): Nullable<TransformNode>;
        /**
         * Gets the class name
         * @returns the string "Mesh".
         */
        getClassName(): string;
        /** @hidden */
        get _isMesh(): boolean;
        /**
         * Returns a description of this mesh
         * @param fullDetails define if full details about this mesh must be used
         * @returns a descriptive string representing this mesh
         */
        toString(fullDetails?: boolean): string;
        /** @hidden */
        _unBindEffect(): void;
        /**
         * Gets a boolean indicating if this mesh has LOD
         */
        get hasLODLevels(): boolean;
        /**
         * Gets the list of MeshLODLevel associated with the current mesh
         * @returns an array of MeshLODLevel
         */
        getLODLevels(): MeshLODLevel[];
        private _sortLODLevels;
        /**
         * Add a mesh as LOD level triggered at the given distance.
         * @see https://doc.babylonjs.com/how_to/how_to_use_lod
         * @param distance The distance from the center of the object to show this level
         * @param mesh The mesh to be added as LOD level (can be null)
         * @return This mesh (for chaining)
         */
        addLODLevel(distance: number, mesh: Nullable<Mesh>): Mesh;
        /**
         * Returns the LOD level mesh at the passed distance or null if not found.
         * @see https://doc.babylonjs.com/how_to/how_to_use_lod
         * @param distance The distance from the center of the object to show this level
         * @returns a Mesh or `null`
         */
        getLODLevelAtDistance(distance: number): Nullable<Mesh>;
        /**
         * Remove a mesh from the LOD array
         * @see https://doc.babylonjs.com/how_to/how_to_use_lod
         * @param mesh defines the mesh to be removed
         * @return This mesh (for chaining)
         */
        removeLODLevel(mesh: Mesh): Mesh;
        /**
         * Returns the registered LOD mesh distant from the parameter `camera` position if any, else returns the current mesh.
         * @see https://doc.babylonjs.com/how_to/how_to_use_lod
         * @param camera defines the camera to use to compute distance
         * @param boundingSphere defines a custom bounding sphere to use instead of the one from this mesh
         * @return This mesh (for chaining)
         */
        getLOD(camera: Camera, boundingSphere?: BoundingSphere): Nullable<AbstractMesh>;
        /**
         * Gets the mesh internal Geometry object
         */
        get geometry(): Nullable<Geometry>;
        /**
         * Returns the total number of vertices within the mesh geometry or zero if the mesh has no geometry.
         * @returns the total number of vertices
         */
        getTotalVertices(): number;
        /**
         * Returns the content of an associated vertex buffer
         * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :
         * - VertexBuffer.PositionKind
         * - VertexBuffer.UVKind
         * - VertexBuffer.UV2Kind
         * - VertexBuffer.UV3Kind
         * - VertexBuffer.UV4Kind
         * - VertexBuffer.UV5Kind
         * - VertexBuffer.UV6Kind
         * - VertexBuffer.ColorKind
         * - VertexBuffer.MatricesIndicesKind
         * - VertexBuffer.MatricesIndicesExtraKind
         * - VertexBuffer.MatricesWeightsKind
         * - VertexBuffer.MatricesWeightsExtraKind
         * @param copyWhenShared defines a boolean indicating that if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one
         * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is
         * @returns a FloatArray or null if the mesh has no geometry or no vertex buffer for this kind.
         */
        getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray>;
        /**
         * Returns the mesh VertexBuffer object from the requested `kind`
         * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :
         * - VertexBuffer.PositionKind
         * - VertexBuffer.NormalKind
         * - VertexBuffer.UVKind
         * - VertexBuffer.UV2Kind
         * - VertexBuffer.UV3Kind
         * - VertexBuffer.UV4Kind
         * - VertexBuffer.UV5Kind
         * - VertexBuffer.UV6Kind
         * - VertexBuffer.ColorKind
         * - VertexBuffer.MatricesIndicesKind
         * - VertexBuffer.MatricesIndicesExtraKind
         * - VertexBuffer.MatricesWeightsKind
         * - VertexBuffer.MatricesWeightsExtraKind
         * @returns a FloatArray or null if the mesh has no vertex buffer for this kind.
         */
        getVertexBuffer(kind: string): Nullable<VertexBuffer>;
        /**
         * Tests if a specific vertex buffer is associated with this mesh
         * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :
         * - VertexBuffer.PositionKind
         * - VertexBuffer.NormalKind
         * - VertexBuffer.UVKind
         * - VertexBuffer.UV2Kind
         * - VertexBuffer.UV3Kind
         * - VertexBuffer.UV4Kind
         * - VertexBuffer.UV5Kind
         * - VertexBuffer.UV6Kind
         * - VertexBuffer.ColorKind
         * - VertexBuffer.MatricesIndicesKind
         * - VertexBuffer.MatricesIndicesExtraKind
         * - VertexBuffer.MatricesWeightsKind
         * - VertexBuffer.MatricesWeightsExtraKind
         * @returns a boolean
         */
        isVerticesDataPresent(kind: string): boolean;
        /**
         * Returns a boolean defining if the vertex data for the requested `kind` is updatable.
         * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :
         * - VertexBuffer.PositionKind
         * - VertexBuffer.UVKind
         * - VertexBuffer.UV2Kind
         * - VertexBuffer.UV3Kind
         * - VertexBuffer.UV4Kind
         * - VertexBuffer.UV5Kind
         * - VertexBuffer.UV6Kind
         * - VertexBuffer.ColorKind
         * - VertexBuffer.MatricesIndicesKind
         * - VertexBuffer.MatricesIndicesExtraKind
         * - VertexBuffer.MatricesWeightsKind
         * - VertexBuffer.MatricesWeightsExtraKind
         * @returns a boolean
         */
        isVertexBufferUpdatable(kind: string): boolean;
        /**
         * Returns a string which contains the list of existing `kinds` of Vertex Data associated with this mesh.
         * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :
         * - VertexBuffer.PositionKind
         * - VertexBuffer.NormalKind
         * - VertexBuffer.UVKind
         * - VertexBuffer.UV2Kind
         * - VertexBuffer.UV3Kind
         * - VertexBuffer.UV4Kind
         * - VertexBuffer.UV5Kind
         * - VertexBuffer.UV6Kind
         * - VertexBuffer.ColorKind
         * - VertexBuffer.MatricesIndicesKind
         * - VertexBuffer.MatricesIndicesExtraKind
         * - VertexBuffer.MatricesWeightsKind
         * - VertexBuffer.MatricesWeightsExtraKind
         * @returns an array of strings
         */
        getVerticesDataKinds(): string[];
        /**
         * Returns a positive integer : the total number of indices in this mesh geometry.
         * @returns the numner of indices or zero if the mesh has no geometry.
         */
        getTotalIndices(): number;
        /**
         * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.
         * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.
         * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it
         * @returns the indices array or an empty array if the mesh has no geometry
         */
        getIndices(copyWhenShared?: boolean, forceCopy?: boolean): Nullable<IndicesArray>;
        get isBlocked(): boolean;
        /**
         * Determine if the current mesh is ready to be rendered
         * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)
         * @param forceInstanceSupport will check if the mesh will be ready when used with instances (false by default)
         * @returns true if all associated assets are ready (material, textures, shaders)
         */
        isReady(completeCheck?: boolean, forceInstanceSupport?: boolean): boolean;
        /**
         * Gets a boolean indicating if the normals aren't to be recomputed on next mesh `positions` array update. This property is pertinent only for updatable parametric shapes.
         */
        get areNormalsFrozen(): boolean;
        /**
         * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It prevents the mesh normals from being recomputed on next `positions` array update.
         * @returns the current mesh
         */
        freezeNormals(): Mesh;
        /**
         * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It reactivates the mesh normals computation if it was previously frozen
         * @returns the current mesh
         */
        unfreezeNormals(): Mesh;
        /**
         * Sets a value overriding the instance count. Only applicable when custom instanced InterleavedVertexBuffer are used rather than InstancedMeshs
         */
        set overridenInstanceCount(count: number);
        /** @hidden */
        _preActivate(): Mesh;
        /** @hidden */
        _preActivateForIntermediateRendering(renderId: number): Mesh;
        /** @hidden */
        _registerInstanceForRenderId(instance: InstancedMesh, renderId: number): Mesh;
        protected _afterComputeWorldMatrix(): void;
        /** @hidden */
        _postActivate(): void;
        /**
         * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.
         * This means the mesh underlying bounding box and sphere are recomputed.
         * @param applySkeleton defines whether to apply the skeleton before computing the bounding info
         * @returns the current mesh
         */
        refreshBoundingInfo(applySkeleton?: boolean): Mesh;
        /** @hidden */
        _createGlobalSubMesh(force: boolean): Nullable<SubMesh>;
        /**
         * This function will subdivide the mesh into multiple submeshes
         * @param count defines the expected number of submeshes
         */
        subdivide(count: number): void;
        /**
         * Copy a FloatArray into a specific associated vertex buffer
         * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :
         * - VertexBuffer.PositionKind
         * - VertexBuffer.UVKind
         * - VertexBuffer.UV2Kind
         * - VertexBuffer.UV3Kind
         * - VertexBuffer.UV4Kind
         * - VertexBuffer.UV5Kind
         * - VertexBuffer.UV6Kind
         * - VertexBuffer.ColorKind
         * - VertexBuffer.MatricesIndicesKind
         * - VertexBuffer.MatricesIndicesExtraKind
         * - VertexBuffer.MatricesWeightsKind
         * - VertexBuffer.MatricesWeightsExtraKind
         * @param data defines the data source
         * @param updatable defines if the updated vertex buffer must be flagged as updatable
         * @param stride defines the data stride size (can be null)
         * @returns the current mesh
         */
        setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh;
        /**
         * Delete a vertex buffer associated with this mesh
         * @param kind defines which buffer to delete (positions, indices, normals, etc). Possible `kind` values :
         * - VertexBuffer.PositionKind
         * - VertexBuffer.UVKind
         * - VertexBuffer.UV2Kind
         * - VertexBuffer.UV3Kind
         * - VertexBuffer.UV4Kind
         * - VertexBuffer.UV5Kind
         * - VertexBuffer.UV6Kind
         * - VertexBuffer.ColorKind
         * - VertexBuffer.MatricesIndicesKind
         * - VertexBuffer.MatricesIndicesExtraKind
         * - VertexBuffer.MatricesWeightsKind
         * - VertexBuffer.MatricesWeightsExtraKind
         */
        removeVerticesData(kind: string): void;
        /**
         * Flags an associated vertex buffer as updatable
         * @param kind defines which buffer to use (positions, indices, normals, etc). Possible `kind` values :
         * - VertexBuffer.PositionKind
         * - VertexBuffer.UVKind
         * - VertexBuffer.UV2Kind
         * - VertexBuffer.UV3Kind
         * - VertexBuffer.UV4Kind
         * - VertexBuffer.UV5Kind
         * - VertexBuffer.UV6Kind
         * - VertexBuffer.ColorKind
         * - VertexBuffer.MatricesIndicesKind
         * - VertexBuffer.MatricesIndicesExtraKind
         * - VertexBuffer.MatricesWeightsKind
         * - VertexBuffer.MatricesWeightsExtraKind
         * @param updatable defines if the updated vertex buffer must be flagged as updatable
         */
        markVerticesDataAsUpdatable(kind: string, updatable?: boolean): void;
        /**
         * Sets the mesh global Vertex Buffer
         * @param buffer defines the buffer to use
         * @returns the current mesh
         */
        setVerticesBuffer(buffer: VertexBuffer): Mesh;
        /**
         * Update a specific associated vertex buffer
         * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :
         * - VertexBuffer.PositionKind
         * - VertexBuffer.UVKind
         * - VertexBuffer.UV2Kind
         * - VertexBuffer.UV3Kind
         * - VertexBuffer.UV4Kind
         * - VertexBuffer.UV5Kind
         * - VertexBuffer.UV6Kind
         * - VertexBuffer.ColorKind
         * - VertexBuffer.MatricesIndicesKind
         * - VertexBuffer.MatricesIndicesExtraKind
         * - VertexBuffer.MatricesWeightsKind
         * - VertexBuffer.MatricesWeightsExtraKind
         * @param data defines the data source
         * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for "position" kind
         * @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)
         * @returns the current mesh
         */
        updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): AbstractMesh;
        /**
         * This method updates the vertex positions of an updatable mesh according to the `positionFunction` returned values.
         * @see https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#other-shapes-updatemeshpositions
         * @param positionFunction is a simple JS function what is passed the mesh `positions` array. It doesn't need to return anything
         * @param computeNormals is a boolean (default true) to enable/disable the mesh normal recomputation after the vertex position update
         * @returns the current mesh
         */
        updateMeshPositions(positionFunction: (data: FloatArray) => void, computeNormals?: boolean): Mesh;
        /**
         * Creates a un-shared specific occurence of the geometry for the mesh.
         * @returns the current mesh
         */
        makeGeometryUnique(): Mesh;
        /**
         * Set the index buffer of this mesh
         * @param indices defines the source data
         * @param totalVertices defines the total number of vertices referenced by this index data (can be null)
         * @param updatable defines if the updated index buffer must be flagged as updatable (default is false)
         * @returns the current mesh
         */
        setIndices(indices: IndicesArray, totalVertices?: Nullable<number>, updatable?: boolean): AbstractMesh;
        /**
         * Update the current index buffer
         * @param indices defines the source data
         * @param offset defines the offset in the index buffer where to store the new data (can be null)
         * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)
         * @returns the current mesh
         */
        updateIndices(indices: IndicesArray, offset?: number, gpuMemoryOnly?: boolean): AbstractMesh;
        /**
         * Invert the geometry to move from a right handed system to a left handed one.
         * @returns the current mesh
         */
        toLeftHanded(): Mesh;
        /** @hidden */
        _bind(subMesh: SubMesh, effect: Effect, fillMode: number): Mesh;
        /** @hidden */
        _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number): Mesh;
        /**
         * Registers for this mesh a javascript function called just before the rendering process
         * @param func defines the function to call before rendering this mesh
         * @returns the current mesh
         */
        registerBeforeRender(func: (mesh: AbstractMesh) => void): Mesh;
        /**
         * Disposes a previously registered javascript function called before the rendering
         * @param func defines the function to remove
         * @returns the current mesh
         */
        unregisterBeforeRender(func: (mesh: AbstractMesh) => void): Mesh;
        /**
         * Registers for this mesh a javascript function called just after the rendering is complete
         * @param func defines the function to call after rendering this mesh
         * @returns the current mesh
         */
        registerAfterRender(func: (mesh: AbstractMesh) => void): Mesh;
        /**
         * Disposes a previously registered javascript function called after the rendering.
         * @param func defines the function to remove
         * @returns the current mesh
         */
        unregisterAfterRender(func: (mesh: AbstractMesh) => void): Mesh;
        /** @hidden */
        _getInstancesRenderList(subMeshId: number, isReplacementMode?: boolean): _InstancesBatch;
        /** @hidden */
        _renderWithInstances(subMesh: SubMesh, fillMode: number, batch: _InstancesBatch, effect: Effect, engine: Engine): Mesh;
        /** @hidden */
        _renderWithThinInstances(subMesh: SubMesh, fillMode: number, effect: Effect, engine: Engine): void;
        /** @hidden */
        _processInstancedBuffers(visibleInstances: InstancedMesh[], renderSelf: boolean): void;
        /** @hidden */
        _processRendering(renderingMesh: AbstractMesh, subMesh: SubMesh, effect: Effect, fillMode: number, batch: _InstancesBatch, hardwareInstancedRendering: boolean, onBeforeDraw: (isInstance: boolean, world: Matrix, effectiveMaterial?: Material) => void, effectiveMaterial?: Material): Mesh;
        /** @hidden */
        _rebuild(): void;
        /** @hidden */
        _freeze(): void;
        /** @hidden */
        _unFreeze(): void;
        /**
         * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager
         * @param subMesh defines the subMesh to render
         * @param enableAlphaMode defines if alpha mode can be changed
         * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering
         * @returns the current mesh
         */
        render(subMesh: SubMesh, enableAlphaMode: boolean, effectiveMeshReplacement?: AbstractMesh): Mesh;
        private _onBeforeDraw;
        /**
         *   Renormalize the mesh and patch it up if there are no weights
         *   Similar to normalization by adding the weights compute the reciprocal and multiply all elements, this wil ensure that everything adds to 1.
         *   However in the case of zero weights then we set just a single influence to 1.
         *   We check in the function for extra's present and if so we use the normalizeSkinWeightsWithExtras rather than the FourWeights version.
         */
        cleanMatrixWeights(): void;
        private normalizeSkinFourWeights;
        private normalizeSkinWeightsAndExtra;
        /**
         * ValidateSkinning is used to determine that a mesh has valid skinning data along with skin metrics, if missing weights,
         * or not normalized it is returned as invalid mesh the string can be used for console logs, or on screen messages to let
         * the user know there was an issue with importing the mesh
         * @returns a validation object with skinned, valid and report string
         */
        validateSkinning(): {
            skinned: boolean;
            valid: boolean;
            report: string;
        };
        /** @hidden */
        _checkDelayState(): Mesh;
        private _queueLoad;
        /**
         * Returns `true` if the mesh is within the frustum defined by the passed array of planes.
         * A mesh is in the frustum if its bounding box intersects the frustum
         * @param frustumPlanes defines the frustum to test
         * @returns true if the mesh is in the frustum planes
         */
        isInFrustum(frustumPlanes: Plane[]): boolean;
        /**
         * Sets the mesh material by the material or multiMaterial `id` property
         * @param id is a string identifying the material or the multiMaterial
         * @returns the current mesh
         */
        setMaterialByID(id: string): Mesh;
        /**
         * Returns as a new array populated with the mesh material and/or skeleton, if any.
         * @returns an array of IAnimatable
         */
        getAnimatables(): IAnimatable[];
        /**
         * Modifies the mesh geometry according to the passed transformation matrix.
         * This method returns nothing but it really modifies the mesh even if it's originally not set as updatable.
         * The mesh normals are modified using the same transformation.
         * Note that, under the hood, this method sets a new VertexBuffer each call.
         * @param transform defines the transform matrix to use
         * @see https://doc.babylonjs.com/resources/baking_transformations
         * @returns the current mesh
         */
        bakeTransformIntoVertices(transform: Matrix): Mesh;
        /**
         * Modifies the mesh geometry according to its own current World Matrix.
         * The mesh World Matrix is then reset.
         * This method returns nothing but really modifies the mesh even if it's originally not set as updatable.
         * Note that, under the hood, this method sets a new VertexBuffer each call.
         * @see https://doc.babylonjs.com/resources/baking_transformations
         * @param bakeIndependenlyOfChildren indicates whether to preserve all child nodes' World Matrix during baking
         * @returns the current mesh
         */
        bakeCurrentTransformIntoVertices(bakeIndependenlyOfChildren?: boolean): Mesh;
        /** @hidden */
        get _positions(): Nullable<Vector3[]>;
        /** @hidden */
        _resetPointsArrayCache(): Mesh;
        /** @hidden */
        _generatePointsArray(): boolean;
        /**
         * Returns a new Mesh object generated from the current mesh properties.
         * This method must not get confused with createInstance()
         * @param name is a string, the name given to the new mesh
         * @param newParent can be any Node object (default `null`)
         * @param doNotCloneChildren allows/denies the recursive cloning of the original mesh children if any (default `false`)
         * @param clonePhysicsImpostor allows/denies the cloning in the same time of the original mesh `body` used by the physics engine, if any (default `true`)
         * @returns a new mesh
         */
        clone(name?: string, newParent?: Nullable<Node>, doNotCloneChildren?: boolean, clonePhysicsImpostor?: boolean): Mesh;
        /**
         * Releases resources associated with this mesh.
         * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
         * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
         */
        dispose(doNotRecurse?: boolean, disposeMaterialAndTextures?: boolean): void;
        /** @hidden */
        _disposeInstanceSpecificData(): void;
        /** @hidden */
        _disposeThinInstanceSpecificData(): void;
        /**
         * Modifies the mesh geometry according to a displacement map.
         * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.
         * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.
         * @param url is a string, the URL from the image file is to be downloaded.
         * @param minHeight is the lower limit of the displacement.
         * @param maxHeight is the upper limit of the displacement.
         * @param onSuccess is an optional Javascript function to be called just after the mesh is modified. It is passed the modified mesh and must return nothing.
         * @param uvOffset is an optional vector2 used to offset UV.
         * @param uvScale is an optional vector2 used to scale UV.
         * @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.
         * @returns the Mesh.
         */
        applyDisplacementMap(url: string, minHeight: number, maxHeight: number, onSuccess?: (mesh: Mesh) => void, uvOffset?: Vector2, uvScale?: Vector2, forceUpdate?: boolean): Mesh;
        /**
         * Modifies the mesh geometry according to a displacementMap buffer.
         * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.
         * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.
         * @param buffer is a `Uint8Array` buffer containing series of `Uint8` lower than 255, the red, green, blue and alpha values of each successive pixel.
         * @param heightMapWidth is the width of the buffer image.
         * @param heightMapHeight is the height of the buffer image.
         * @param minHeight is the lower limit of the displacement.
         * @param maxHeight is the upper limit of the displacement.
         * @param onSuccess is an optional Javascript function to be called just after the mesh is modified. It is passed the modified mesh and must return nothing.
         * @param uvOffset is an optional vector2 used to offset UV.
         * @param uvScale is an optional vector2 used to scale UV.
         * @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.
         * @returns the Mesh.
         */
        applyDisplacementMapFromBuffer(buffer: Uint8Array, heightMapWidth: number, heightMapHeight: number, minHeight: number, maxHeight: number, uvOffset?: Vector2, uvScale?: Vector2, forceUpdate?: boolean): Mesh;
        /**
         * Modify the mesh to get a flat shading rendering.
         * This means each mesh facet will then have its own normals. Usually new vertices are added in the mesh geometry to get this result.
         * Warning : the mesh is really modified even if not set originally as updatable and, under the hood, a new VertexBuffer is allocated.
         * @returns current mesh
         */
        convertToFlatShadedMesh(): Mesh;
        /**
         * This method removes all the mesh indices and add new vertices (duplication) in order to unfold facets into buffers.
         * In other words, more vertices, no more indices and a single bigger VBO.
         * The mesh is really modified even if not set originally as updatable. Under the hood, a new VertexBuffer is allocated.
         * @returns current mesh
         */
        convertToUnIndexedMesh(): Mesh;
        /**
         * Inverses facet orientations.
         * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.
         * @param flipNormals will also inverts the normals
         * @returns current mesh
         */
        flipFaces(flipNormals?: boolean): Mesh;
        /**
         * Increase the number of facets and hence vertices in a mesh
         * Vertex normals are interpolated from existing vertex normals
         * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.
         * @param numberPerEdge the number of new vertices to add to each edge of a facet, optional default 1
         */
        increaseVertices(numberPerEdge: number): void;
        /**
         * Force adjacent facets to share vertices and remove any facets that have all vertices in a line
         * This will undo any application of covertToFlatShadedMesh
         * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.
         */
        forceSharedVertices(): void;
        /** @hidden */
        static _instancedMeshFactory(name: string, mesh: Mesh): InstancedMesh;
        /** @hidden */
        static _PhysicsImpostorParser(scene: Scene, physicObject: IPhysicsEnabledObject, jsonObject: any): PhysicsImpostor;
        /**
         * Creates a new InstancedMesh object from the mesh model.
         * @see https://doc.babylonjs.com/how_to/how_to_use_instances
         * @param name defines the name of the new instance
         * @returns a new InstancedMesh
         */
        createInstance(name: string): InstancedMesh;
        /**
         * Synchronises all the mesh instance submeshes to the current mesh submeshes, if any.
         * After this call, all the mesh instances have the same submeshes than the current mesh.
         * @returns the current mesh
         */
        synchronizeInstances(): Mesh;
        /**
         * Optimization of the mesh's indices, in case a mesh has duplicated vertices.
         * The function will only reorder the indices and will not remove unused vertices to avoid problems with submeshes.
         * This should be used together with the simplification to avoid disappearing triangles.
         * @param successCallback an optional success callback to be called after the optimization finished.
         * @returns the current mesh
         */
        optimizeIndices(successCallback?: (mesh?: Mesh) => void): Mesh;
        /**
         * Serialize current mesh
         * @param serializationObject defines the object which will receive the serialization data
         */
        serialize(serializationObject: any): void;
        /** @hidden */
        _syncGeometryWithMorphTargetManager(): void;
        /** @hidden */
        static _GroundMeshParser: (parsedMesh: any, scene: Scene) => Mesh;
        /**
         * Returns a new Mesh object parsed from the source provided.
         * @param parsedMesh is the source
         * @param scene defines the hosting scene
         * @param rootUrl is the root URL to prefix the `delayLoadingFile` property with
         * @returns a new Mesh
         */
        static Parse(parsedMesh: any, scene: Scene, rootUrl: string): Mesh;
        /**
         * Creates a ribbon mesh. Please consider using the same method from the MeshBuilder class instead
         * @see https://doc.babylonjs.com/how_to/parametric_shapes
         * @param name defines the name of the mesh to create
         * @param pathArray is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry.
         * @param closeArray creates a seam between the first and the last paths of the path array (default is false)
         * @param closePath creates a seam between the first and the last points of each path of the path array
         * @param offset is taken in account only if the `pathArray` is containing a single path
         * @param scene defines the hosting scene
         * @param updatable defines if the mesh must be flagged as updatable
         * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
         * @param instance defines an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter (https://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#ribbon)
         * @returns a new Mesh
         */
        static CreateRibbon(name: string, pathArray: Vector3[][], closeArray: boolean, closePath: boolean, offset: number, scene?: Scene, updatable?: boolean, sideOrientation?: number, instance?: Mesh): Mesh;
        /**
          * Creates a plane polygonal mesh.  By default, this is a disc. Please consider using the same method from the MeshBuilder class instead
          * @param name defines the name of the mesh to create
          * @param radius sets the radius size (float) of the polygon (default 0.5)
          * @param tessellation sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc
          * @param scene defines the hosting scene
          * @param updatable defines if the mesh must be flagged as updatable
          * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
          * @returns a new Mesh
          */
        static CreateDisc(name: string, radius: number, tessellation: number, scene?: Nullable<Scene>, updatable?: boolean, sideOrientation?: number): Mesh;
        /**
         * Creates a box mesh. Please consider using the same method from the MeshBuilder class instead
         * @param name defines the name of the mesh to create
         * @param size sets the size (float) of each box side (default 1)
         * @param scene defines the hosting scene
         * @param updatable defines if the mesh must be flagged as updatable
         * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
         * @returns a new Mesh
         */
        static CreateBox(name: string, size: number, scene?: Nullable<Scene>, updatable?: boolean, sideOrientation?: number): Mesh;
        /**
          * Creates a sphere mesh. Please consider using the same method from the MeshBuilder class instead
          * @param name defines the name of the mesh to create
          * @param segments sets the sphere number of horizontal stripes (positive integer, default 32)
          * @param diameter sets the diameter size (float) of the sphere (default 1)
          * @param scene defines the hosting scene
          * @param updatable defines if the mesh must be flagged as updatable
          * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
          * @returns a new Mesh
          */
        static CreateSphere(name: string, segments: number, diameter: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh;
        /**
          * Creates a hemisphere mesh. Please consider using the same method from the MeshBuilder class instead
          * @param name defines the name of the mesh to create
          * @param segments sets the sphere number of horizontal stripes (positive integer, default 32)
          * @param diameter sets the diameter size (float) of the sphere (default 1)
          * @param scene defines the hosting scene
          * @returns a new Mesh
          */
        static CreateHemisphere(name: string, segments: number, diameter: number, scene?: Scene): Mesh;
        /**
         * Creates a cylinder or a cone mesh. Please consider using the same method from the MeshBuilder class instead
         * @param name defines the name of the mesh to create
         * @param height sets the height size (float) of the cylinder/cone (float, default 2)
         * @param diameterTop set the top cap diameter (floats, default 1)
         * @param diameterBottom set the bottom cap diameter (floats, default 1). This value can't be zero
         * @param tessellation sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance
         * @param subdivisions sets the number of rings along the cylinder height (positive integer, default 1)
         * @param scene defines the hosting scene
         * @param updatable defines if the mesh must be flagged as updatable
         * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
         * @returns a new Mesh
         */
        static CreateCylinder(name: string, height: number, diameterTop: number, diameterBottom: number, tessellation: number, subdivisions: any, scene?: Scene, updatable?: any, sideOrientation?: number): Mesh;
        /**
         * Creates a torus mesh. Please consider using the same method from the MeshBuilder class instead
         * @param name defines the name of the mesh to create
         * @param diameter sets the diameter size (float) of the torus (default 1)
         * @param thickness sets the diameter size of the tube of the torus (float, default 0.5)
         * @param tessellation sets the number of torus sides (postive integer, default 16)
         * @param scene defines the hosting scene
         * @param updatable defines if the mesh must be flagged as updatable
         * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
         * @returns a new Mesh
         */
        static CreateTorus(name: string, diameter: number, thickness: number, tessellation: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh;
        /**
         * Creates a torus knot mesh. Please consider using the same method from the MeshBuilder class instead
         * @param name defines the name of the mesh to create
         * @param radius sets the global radius size (float) of the torus knot (default 2)
         * @param tube sets the diameter size of the tube of the torus (float, default 0.5)
         * @param radialSegments sets the number of sides on each tube segments (positive integer, default 32)
         * @param tubularSegments sets the number of tubes to decompose the knot into (positive integer, default 32)
         * @param p the number of windings on X axis (positive integers, default 2)
         * @param q the number of windings on Y axis (positive integers, default 3)
         * @param scene defines the hosting scene
         * @param updatable defines if the mesh must be flagged as updatable
         * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
         * @returns a new Mesh
         */
        static CreateTorusKnot(name: string, radius: number, tube: number, radialSegments: number, tubularSegments: number, p: number, q: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh;
        /**
         * Creates a line mesh. Please consider using the same method from the MeshBuilder class instead.
         * @param name defines the name of the mesh to create
         * @param points is an array successive Vector3
         * @param scene defines the hosting scene
         * @param updatable defines if the mesh must be flagged as updatable
         * @param instance is an instance of an existing LineMesh object to be updated with the passed `points` parameter (https://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#lines-and-dashedlines).
         * @returns a new Mesh
         */
        static CreateLines(name: string, points: Vector3[], scene?: Nullable<Scene>, updatable?: boolean, instance?: Nullable<LinesMesh>): LinesMesh;
        /**
         * Creates a dashed line mesh. Please consider using the same method from the MeshBuilder class instead
         * @param name defines the name of the mesh to create
         * @param points is an array successive Vector3
         * @param dashSize is the size of the dashes relatively the dash number (positive float, default 3)
         * @param gapSize is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)
         * @param dashNb is the intended total number of dashes (positive integer, default 200)
         * @param scene defines the hosting scene
         * @param updatable defines if the mesh must be flagged as updatable
         * @param instance is an instance of an existing LineMesh object to be updated with the passed `points` parameter (https://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#lines-and-dashedlines)
         * @returns a new Mesh
         */
        static CreateDashedLines(name: string, points: Vector3[], dashSize: number, gapSize: number, dashNb: number, scene?: Nullable<Scene>, updatable?: boolean, instance?: LinesMesh): LinesMesh;
        /**
         * Creates a polygon mesh.Please consider using the same method from the MeshBuilder class instead
         * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh.
         * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors.
         * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         * Remember you can only change the shape positions, not their number when updating a polygon.
         * @see https://doc.babylonjs.com/how_to/parametric_shapes#non-regular-polygon
         * @param name defines the name of the mesh to create
         * @param shape is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors
         * @param scene defines the hosting scene
         * @param holes is a required array of arrays of successive Vector3 used to defines holes in the polygon
         * @param updatable defines if the mesh must be flagged as updatable
         * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
         * @param earcutInjection can be used to inject your own earcut reference
         * @returns a new Mesh
         */
        static CreatePolygon(name: string, shape: Vector3[], scene: Scene, holes?: Vector3[][], updatable?: boolean, sideOrientation?: number, earcutInjection?: any): Mesh;
        /**
         * Creates an extruded polygon mesh, with depth in the Y direction. Please consider using the same method from the MeshBuilder class instead.
         * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-non-regular-polygon
         * @param name defines the name of the mesh to create
         * @param shape is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors
         * @param depth defines the height of extrusion
         * @param scene defines the hosting scene
         * @param holes is a required array of arrays of successive Vector3 used to defines holes in the polygon
         * @param updatable defines if the mesh must be flagged as updatable
         * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
         * @param earcutInjection can be used to inject your own earcut reference
         * @returns a new Mesh
         */
        static ExtrudePolygon(name: string, shape: Vector3[], depth: number, scene: Scene, holes?: Vector3[][], updatable?: boolean, sideOrientation?: number, earcutInjection?: any): Mesh;
        /**
         * Creates an extruded shape mesh.
         * The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters. Please consider using the same method from the MeshBuilder class instead
         * @see https://doc.babylonjs.com/how_to/parametric_shapes
         * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
         * @param name defines the name of the mesh to create
         * @param shape is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis
         * @param path is a required array of successive Vector3. This is the axis curve the shape is extruded along
         * @param scale is the value to scale the shape
         * @param rotation is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve
         * @param cap sets the way the extruded shape is capped. Possible values : Mesh.NO_CAP (default), Mesh.CAP_START, Mesh.CAP_END, Mesh.CAP_ALL
         * @param scene defines the hosting scene
         * @param updatable defines if the mesh must be flagged as updatable
         * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
         * @param instance is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters (https://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#extruded-shape)
         * @returns a new Mesh
         */
        static ExtrudeShape(name: string, shape: Vector3[], path: Vector3[], scale: number, rotation: number, cap: number, scene?: Nullable<Scene>, updatable?: boolean, sideOrientation?: number, instance?: Mesh): Mesh;
        /**
         * Creates an custom extruded shape mesh.
         * The custom extrusion is a parametric shape.
         * It has no predefined shape. Its final shape will depend on the input parameters.
         * Please consider using the same method from the MeshBuilder class instead
         * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
         * @param name defines the name of the mesh to create
         * @param shape is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis
         * @param path is a required array of successive Vector3. This is the axis curve the shape is extruded along
         * @param scaleFunction is a custom Javascript function called on each path point
         * @param rotationFunction is a custom Javascript function called on each path point
         * @param ribbonCloseArray forces the extrusion underlying ribbon to close all the paths in its `pathArray`
         * @param ribbonClosePath forces the extrusion underlying ribbon to close its `pathArray`
         * @param cap sets the way the extruded shape is capped. Possible values : Mesh.NO_CAP (default), Mesh.CAP_START, Mesh.CAP_END, Mesh.CAP_ALL
         * @param scene defines the hosting scene
         * @param updatable defines if the mesh must be flagged as updatable
         * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
         * @param instance is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters (https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape)
         * @returns a new Mesh
         */
        static ExtrudeShapeCustom(name: string, shape: Vector3[], path: Vector3[], scaleFunction: Function, rotationFunction: Function, ribbonCloseArray: boolean, ribbonClosePath: boolean, cap: number, scene: Scene, updatable?: boolean, sideOrientation?: number, instance?: Mesh): Mesh;
        /**
         * Creates lathe mesh.
         * The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe.
         * Please consider using the same method from the MeshBuilder class instead
         * @param name defines the name of the mesh to create
         * @param shape is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero
         * @param radius is the radius value of the lathe
         * @param tessellation is the side number of the lathe.
         * @param scene defines the hosting scene
         * @param updatable defines if the mesh must be flagged as updatable
         * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
         * @returns a new Mesh
         */
        static CreateLathe(name: string, shape: Vector3[], radius: number, tessellation: number, scene: Scene, updatable?: boolean, sideOrientation?: number): Mesh;
        /**
         * Creates a plane mesh. Please consider using the same method from the MeshBuilder class instead
         * @param name defines the name of the mesh to create
         * @param size sets the size (float) of both sides of the plane at once (default 1)
         * @param scene defines the hosting scene
         * @param updatable defines if the mesh must be flagged as updatable
         * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
         * @returns a new Mesh
         */
        static CreatePlane(name: string, size: number, scene: Scene, updatable?: boolean, sideOrientation?: number): Mesh;
        /**
         * Creates a ground mesh.
         * Please consider using the same method from the MeshBuilder class instead
         * @param name defines the name of the mesh to create
         * @param width set the width of the ground
         * @param height set the height of the ground
         * @param subdivisions sets the number of subdivisions per side
         * @param scene defines the hosting scene
         * @param updatable defines if the mesh must be flagged as updatable
         * @returns a new Mesh
         */
        static CreateGround(name: string, width: number, height: number, subdivisions: number, scene?: Scene, updatable?: boolean): Mesh;
        /**
         * Creates a tiled ground mesh.
         * Please consider using the same method from the MeshBuilder class instead
         * @param name defines the name of the mesh to create
         * @param xmin set the ground minimum X coordinate
         * @param zmin set the ground minimum Y coordinate
         * @param xmax set the ground maximum X coordinate
         * @param zmax set the ground maximum Z coordinate
         * @param subdivisions is an object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile
         * @param precision is an object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile
         * @param scene defines the hosting scene
         * @param updatable defines if the mesh must be flagged as updatable
         * @returns a new Mesh
         */
        static CreateTiledGround(name: string, xmin: number, zmin: number, xmax: number, zmax: number, subdivisions: {
            w: number;
            h: number;
        }, precision: {
            w: number;
            h: number;
        }, scene: Scene, updatable?: boolean): Mesh;
        /**
         * Creates a ground mesh from a height map.
         * Please consider using the same method from the MeshBuilder class instead
         * @see https://doc.babylonjs.com/babylon101/height_map
         * @param name defines the name of the mesh to create
         * @param url sets the URL of the height map image resource
         * @param width set the ground width size
         * @param height set the ground height size
         * @param subdivisions sets the number of subdivision per side
         * @param minHeight is the minimum altitude on the ground
         * @param maxHeight is the maximum altitude on the ground
         * @param scene defines the hosting scene
         * @param updatable defines if the mesh must be flagged as updatable
         * @param onReady  is a callback function that will be called  once the mesh is built (the height map download can last some time)
         * @param alphaFilter will filter any data where the alpha channel is below this value, defaults 0 (all data visible)
         * @returns a new Mesh
         */
        static CreateGroundFromHeightMap(name: string, url: string, width: number, height: number, subdivisions: number, minHeight: number, maxHeight: number, scene: Scene, updatable?: boolean, onReady?: (mesh: GroundMesh) => void, alphaFilter?: number): GroundMesh;
        /**
         * Creates a tube mesh.
         * The tube is a parametric shape.
         * It has no predefined shape. Its final shape will depend on the input parameters.
         * Please consider using the same method from the MeshBuilder class instead
         * @see https://doc.babylonjs.com/how_to/parametric_shapes
         * @param name defines the name of the mesh to create
         * @param path is a required array of successive Vector3. It is the curve used as the axis of the tube
         * @param radius sets the tube radius size
         * @param tessellation is the number of sides on the tubular surface
         * @param radiusFunction is a custom function. If it is not null, it overwrittes the parameter `radius`. This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path
         * @param cap sets the way the extruded shape is capped. Possible values : Mesh.NO_CAP (default), Mesh.CAP_START, Mesh.CAP_END, Mesh.CAP_ALL
         * @param scene defines the hosting scene
         * @param updatable defines if the mesh must be flagged as updatable
         * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation)
         * @param instance is an instance of an existing Tube object to be updated with the passed `pathArray` parameter (https://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#tube)
         * @returns a new Mesh
         */
        static CreateTube(name: string, path: Vector3[], radius: number, tessellation: number, radiusFunction: {
            (i: number, distance: number): number;
        }, cap: number, scene: Scene, updatable?: boolean, sideOrientation?: number, instance?: Mesh): Mesh;
        /**
          * Creates a polyhedron mesh.
          * Please consider using the same method from the MeshBuilder class instead.
          * * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type
          * * The parameter `size` (positive float, default 1) sets the polygon size
          * * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)
          * * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`
          * * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron
          * * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)
          * * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
          * * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored
          * * You can also set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
          * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
          * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
          * @param name defines the name of the mesh to create
          * @param options defines the options used to create the mesh
          * @param scene defines the hosting scene
          * @returns a new Mesh
          */
        static CreatePolyhedron(name: string, options: {
            type?: number;
            size?: number;
            sizeX?: number;
            sizeY?: number;
            sizeZ?: number;
            custom?: any;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            updatable?: boolean;
            sideOrientation?: number;
        }, scene: Scene): Mesh;
        /**
         * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided
         * * The parameter `radius` sets the radius size (float) of the icosphere (default 1)
         * * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value than `radius`)
         * * The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size
         * * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface
         * * You can also set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns a new Mesh
         * @see https://doc.babylonjs.com/how_to/polyhedra_shapes#icosphere
         */
        static CreateIcoSphere(name: string, options: {
            radius?: number;
            flat?: boolean;
            subdivisions?: number;
            sideOrientation?: number;
            updatable?: boolean;
        }, scene: Scene): Mesh;
        /**
         * Creates a decal mesh.
         * Please consider using the same method from the MeshBuilder class instead.
         * A decal is a mesh usually applied as a model onto the surface of another mesh
         * @param name  defines the name of the mesh
         * @param sourceMesh defines the mesh receiving the decal
         * @param position sets the position of the decal in world coordinates
         * @param normal sets the normal of the mesh where the decal is applied onto in world coordinates
         * @param size sets the decal scaling
         * @param angle sets the angle to rotate the decal
         * @returns a new Mesh
         */
        static CreateDecal(name: string, sourceMesh: AbstractMesh, position: Vector3, normal: Vector3, size: Vector3, angle: number): Mesh;
        /** Creates a Capsule Mesh
         * @param name defines the name of the mesh.
         * @param options the constructors options used to shape the mesh.
         * @param scene defines the scene the mesh is scoped to.
         * @returns the capsule mesh
         * @see https://doc.babylonjs.com/how_to/capsule_shape
         */
        static CreateCapsule(name: string, options: ICreateCapsuleOptions, scene: Scene): Mesh;
        /**
         * Prepare internal position array for software CPU skinning
         * @returns original positions used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh
         */
        setPositionsForCPUSkinning(): Float32Array;
        /**
         * Prepare internal normal array for software CPU skinning
         * @returns original normals used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh.
         */
        setNormalsForCPUSkinning(): Float32Array;
        /**
         * Updates the vertex buffer by applying transformation from the bones
         * @param skeleton defines the skeleton to apply to current mesh
         * @returns the current mesh
         */
        applySkeleton(skeleton: Skeleton): Mesh;
        /**
         * Returns an object containing a min and max Vector3 which are the minimum and maximum vectors of each mesh bounding box from the passed array, in the world coordinates
         * @param meshes defines the list of meshes to scan
         * @returns an object `{min:` Vector3`, max:` Vector3`}`
         */
        static MinMax(meshes: AbstractMesh[]): {
            min: Vector3;
            max: Vector3;
        };
        /**
         * Returns the center of the `{min:` Vector3`, max:` Vector3`}` or the center of MinMax vector3 computed from a mesh array
         * @param meshesOrMinMaxVector could be an array of meshes or a `{min:` Vector3`, max:` Vector3`}` object
         * @returns a vector3
         */
        static Center(meshesOrMinMaxVector: {
            min: Vector3;
            max: Vector3;
        } | AbstractMesh[]): Vector3;
        /**
         * Merge the array of meshes into a single mesh for performance reasons.
         * @param meshes defines he vertices source.  They should all be of the same material.  Entries can empty
         * @param disposeSource when true (default), dispose of the vertices from the source meshes
         * @param allow32BitsIndices when the sum of the vertices > 64k, this must be set to true
         * @param meshSubclass when set, vertices inserted into this Mesh.  Meshes can then be merged into a Mesh sub-class.
         * @param subdivideWithSubMeshes when true (false default), subdivide mesh to his subMesh array with meshes source.
         * @param multiMultiMaterials when true (false default), subdivide mesh and accept multiple multi materials, ignores subdivideWithSubMeshes.
         * @returns a new mesh
         */
        static MergeMeshes(meshes: Array<Mesh>, disposeSource?: boolean, allow32BitsIndices?: boolean, meshSubclass?: Mesh, subdivideWithSubMeshes?: boolean, multiMultiMaterials?: boolean): Nullable<Mesh>;
        /** @hidden */
        addInstance(instance: InstancedMesh): void;
        /** @hidden */
        removeInstance(instance: InstancedMesh): void;
    }
}
declare module BABYLON {
    /**
     * This is the base class of all the camera used in the application.
     * @see https://doc.babylonjs.com/features/cameras
     */
    export class Camera extends Node {
        /** @hidden */
        static _createDefaultParsedCamera: (name: string, scene: Scene) => Camera;
        /**
         * This is the default projection mode used by the cameras.
         * It helps recreating a feeling of perspective and better appreciate depth.
         * This is the best way to simulate real life cameras.
         */
        static readonly PERSPECTIVE_CAMERA: number;
        /**
         * This helps creating camera with an orthographic mode.
         * Orthographic is commonly used in engineering as a means to produce object specifications that communicate dimensions unambiguously, each line of 1 unit length (cm, meter..whatever) will appear to have the same length everywhere on the drawing. This allows the drafter to dimension only a subset of lines and let the reader know that other lines of that length on the drawing are also that length in reality. Every parallel line in the drawing is also parallel in the object.
         */
        static readonly ORTHOGRAPHIC_CAMERA: number;
        /**
         * This is the default FOV mode for perspective cameras.
         * This setting aligns the upper and lower bounds of the viewport to the upper and lower bounds of the camera frustum.
         */
        static readonly FOVMODE_VERTICAL_FIXED: number;
        /**
         * This setting aligns the left and right bounds of the viewport to the left and right bounds of the camera frustum.
         */
        static readonly FOVMODE_HORIZONTAL_FIXED: number;
        /**
         * This specifies ther is no need for a camera rig.
         * Basically only one eye is rendered corresponding to the camera.
         */
        static readonly RIG_MODE_NONE: number;
        /**
         * Simulates a camera Rig with one blue eye and one red eye.
         * This can be use with 3d blue and red glasses.
         */
        static readonly RIG_MODE_STEREOSCOPIC_ANAGLYPH: number;
        /**
         * Defines that both eyes of the camera will be rendered side by side with a parallel target.
         */
        static readonly RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL: number;
        /**
         * Defines that both eyes of the camera will be rendered side by side with a none parallel target.
         */
        static readonly RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED: number;
        /**
         * Defines that both eyes of the camera will be rendered over under each other.
         */
        static readonly RIG_MODE_STEREOSCOPIC_OVERUNDER: number;
        /**
         * Defines that both eyes of the camera will be rendered on successive lines interlaced for passive 3d monitors.
         */
        static readonly RIG_MODE_STEREOSCOPIC_INTERLACED: number;
        /**
         * Defines that both eyes of the camera should be renderered in a VR mode (carbox).
         */
        static readonly RIG_MODE_VR: number;
        /**
         * Defines that both eyes of the camera should be renderered in a VR mode (webVR).
         */
        static readonly RIG_MODE_WEBVR: number;
        /**
         * Custom rig mode allowing rig cameras to be populated manually with any number of cameras
         */
        static readonly RIG_MODE_CUSTOM: number;
        /**
         * Defines if by default attaching controls should prevent the default javascript event to continue.
         */
        static ForceAttachControlToAlwaysPreventDefault: boolean;
        /**
         * Define the input manager associated with the camera.
         */
        inputs: CameraInputsManager<Camera>;
        /** @hidden */
        _position: Vector3;
        /**
         * Define the current local position of the camera in the scene
         */
        get position(): Vector3;
        set position(newPosition: Vector3);
        protected _upVector: Vector3;
        /**
         * The vector the camera should consider as up.
         * (default is Vector3(0, 1, 0) aka Vector3.Up())
         */
        set upVector(vec: Vector3);
        get upVector(): Vector3;
        /**
         * Define the current limit on the left side for an orthographic camera
         * In scene unit
         */
        orthoLeft: Nullable<number>;
        /**
         * Define the current limit on the right side for an orthographic camera
         * In scene unit
         */
        orthoRight: Nullable<number>;
        /**
         * Define the current limit on the bottom side for an orthographic camera
         * In scene unit
         */
        orthoBottom: Nullable<number>;
        /**
         * Define the current limit on the top side for an orthographic camera
         * In scene unit
         */
        orthoTop: Nullable<number>;
        /**
         * Field Of View is set in Radians. (default is 0.8)
         */
        fov: number;
        /**
         * Define the minimum distance the camera can see from.
         * This is important to note that the depth buffer are not infinite and the closer it starts
         * the more your scene might encounter depth fighting issue.
         */
        minZ: number;
        /**
         * Define the maximum distance the camera can see to.
         * This is important to note that the depth buffer are not infinite and the further it end
         * the more your scene might encounter depth fighting issue.
         */
        maxZ: number;
        /**
         * Define the default inertia of the camera.
         * This helps giving a smooth feeling to the camera movement.
         */
        inertia: number;
        /**
         * Define the mode of the camera (Camera.PERSPECTIVE_CAMERA or Camera.ORTHOGRAPHIC_CAMERA)
         */
        mode: number;
        /**
         * Define whether the camera is intermediate.
         * This is useful to not present the output directly to the screen in case of rig without post process for instance
         */
        isIntermediate: boolean;
        /**
         * Define the viewport of the camera.
         * This correspond to the portion of the screen the camera will render to in normalized 0 to 1 unit.
         */
        viewport: Viewport;
        /**
         * Restricts the camera to viewing objects with the same layerMask.
         * A camera with a layerMask of 1 will render mesh.layerMask & camera.layerMask!== 0
         */
        layerMask: number;
        /**
         * fovMode sets the camera frustum bounds to the viewport bounds. (default is FOVMODE_VERTICAL_FIXED)
         */
        fovMode: number;
        /**
         * Rig mode of the camera.
         * This is useful to create the camera with two "eyes" instead of one to create VR or stereoscopic scenes.
         * This is normally controlled byt the camera themselves as internal use.
         */
        cameraRigMode: number;
        /**
         * Defines the distance between both "eyes" in case of a RIG
         */
        interaxialDistance: number;
        /**
         * Defines if stereoscopic rendering is done side by side or over under.
         */
        isStereoscopicSideBySide: boolean;
        /**
         * Defines the list of custom render target which are rendered to and then used as the input to this camera's render. Eg. display another camera view on a TV in the main scene
         * This is pretty helpfull if you wish to make a camera render to a texture you could reuse somewhere
         * else in the scene. (Eg. security camera)
         *
         * To change the final output target of the camera, camera.outputRenderTarget should be used instead (eg. webXR renders to a render target corrisponding to an HMD)
         */
        customRenderTargets: RenderTargetTexture[];
        /**
         * When set, the camera will render to this render target instead of the default canvas
         *
         * If the desire is to use the output of a camera as a texture in the scene consider using camera.customRenderTargets instead
         */
        outputRenderTarget: Nullable<RenderTargetTexture>;
        /**
         * Observable triggered when the camera view matrix has changed.
         */
        onViewMatrixChangedObservable: Observable<Camera>;
        /**
         * Observable triggered when the camera Projection matrix has changed.
         */
        onProjectionMatrixChangedObservable: Observable<Camera>;
        /**
         * Observable triggered when the inputs have been processed.
         */
        onAfterCheckInputsObservable: Observable<Camera>;
        /**
         * Observable triggered when reset has been called and applied to the camera.
         */
        onRestoreStateObservable: Observable<Camera>;
        /**
         * Is this camera a part of a rig system?
         */
        isRigCamera: boolean;
        /**
         * If isRigCamera set to true this will be set with the parent camera.
         * The parent camera is not (!) necessarily the .parent of this camera (like in the case of XR)
         */
        rigParent?: Camera;
        /** @hidden */
        _cameraRigParams: any;
        /** @hidden */
        _rigCameras: Camera[];
        /** @hidden */
        _rigPostProcess: Nullable<PostProcess>;
        protected _webvrViewMatrix: Matrix;
        /** @hidden */
        _skipRendering: boolean;
        /** @hidden */
        _projectionMatrix: Matrix;
        /** @hidden */
        _postProcesses: Nullable<PostProcess>[];
        /** @hidden */
        _activeMeshes: SmartArray<AbstractMesh>;
        protected _globalPosition: Vector3;
        /** @hidden */
        _computedViewMatrix: Matrix;
        private _doNotComputeProjectionMatrix;
        private _transformMatrix;
        private _frustumPlanes;
        private _refreshFrustumPlanes;
        private _storedFov;
        private _stateStored;
        /**
         * Instantiates a new camera object.
         * This should not be used directly but through the inherited cameras: ArcRotate, Free...
         * @see https://doc.babylonjs.com/features/cameras
         * @param name Defines the name of the camera in the scene
         * @param position Defines the position of the camera
         * @param scene Defines the scene the camera belongs too
         * @param setActiveOnSceneIfNoneActive Defines if the camera should be set as active after creation if no other camera have been defined in the scene
         */
        constructor(name: string, position: Vector3, scene: Scene, setActiveOnSceneIfNoneActive?: boolean);
        /**
         * Store current camera state (fov, position, etc..)
         * @returns the camera
         */
        storeState(): Camera;
        /**
         * Restores the camera state values if it has been stored. You must call storeState() first
         */
        protected _restoreStateValues(): boolean;
        /**
         * Restored camera state. You must call storeState() first.
         * @returns true if restored and false otherwise
         */
        restoreState(): boolean;
        /**
         * Gets the class name of the camera.
         * @returns the class name
         */
        getClassName(): string;
        /** @hidden */
        readonly _isCamera: boolean;
        /**
         * Gets a string representation of the camera useful for debug purpose.
         * @param fullDetails Defines that a more verboe level of logging is required
         * @returns the string representation
         */
        toString(fullDetails?: boolean): string;
        /**
         * Gets the current world space position of the camera.
         */
        get globalPosition(): Vector3;
        /**
         * Gets the list of active meshes this frame (meshes no culled or excluded by lod s in the frame)
         * @returns the active meshe list
         */
        getActiveMeshes(): SmartArray<AbstractMesh>;
        /**
         * Check whether a mesh is part of the current active mesh list of the camera
         * @param mesh Defines the mesh to check
         * @returns true if active, false otherwise
         */
        isActiveMesh(mesh: Mesh): boolean;
        /**
         * Is this camera ready to be used/rendered
         * @param completeCheck defines if a complete check (including post processes) has to be done (false by default)
         * @return true if the camera is ready
         */
        isReady(completeCheck?: boolean): boolean;
        /** @hidden */
        _initCache(): void;
        /** @hidden */
        _updateCache(ignoreParentClass?: boolean): void;
        /** @hidden */
        _isSynchronized(): boolean;
        /** @hidden */
        _isSynchronizedViewMatrix(): boolean;
        /** @hidden */
        _isSynchronizedProjectionMatrix(): boolean;
        /**
         * Attach the input controls to a specific dom element to get the input from.
         * @param element Defines the element the controls should be listened from
         * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Detach the current controls from the specified dom element.
         * @param element Defines the element to stop listening the inputs from
         */
        detachControl(element: HTMLElement): void;
        /**
         * Update the camera state according to the different inputs gathered during the frame.
         */
        update(): void;
        /** @hidden */
        _checkInputs(): void;
        /** @hidden */
        get rigCameras(): Camera[];
        /**
         * Gets the post process used by the rig cameras
         */
        get rigPostProcess(): Nullable<PostProcess>;
        /**
         * Internal, gets the first post proces.
         * @returns the first post process to be run on this camera.
         */
        _getFirstPostProcess(): Nullable<PostProcess>;
        private _cascadePostProcessesToRigCams;
        /**
         * Attach a post process to the camera.
         * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#attach-postprocess
         * @param postProcess The post process to attach to the camera
         * @param insertAt The position of the post process in case several of them are in use in the scene
         * @returns the position the post process has been inserted at
         */
        attachPostProcess(postProcess: PostProcess, insertAt?: Nullable<number>): number;
        /**
         * Detach a post process to the camera.
         * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#attach-postprocess
         * @param postProcess The post process to detach from the camera
         */
        detachPostProcess(postProcess: PostProcess): void;
        /**
         * Gets the current world matrix of the camera
         */
        getWorldMatrix(): Matrix;
        /** @hidden */
        _getViewMatrix(): Matrix;
        /**
         * Gets the current view matrix of the camera.
         * @param force forces the camera to recompute the matrix without looking at the cached state
         * @returns the view matrix
         */
        getViewMatrix(force?: boolean): Matrix;
        /**
         * Freeze the projection matrix.
         * It will prevent the cache check of the camera projection compute and can speed up perf
         * if no parameter of the camera are meant to change
         * @param projection Defines manually a projection if necessary
         */
        freezeProjectionMatrix(projection?: Matrix): void;
        /**
         * Unfreeze the projection matrix if it has previously been freezed by freezeProjectionMatrix.
         */
        unfreezeProjectionMatrix(): void;
        /**
         * Gets the current projection matrix of the camera.
         * @param force forces the camera to recompute the matrix without looking at the cached state
         * @returns the projection matrix
         */
        getProjectionMatrix(force?: boolean): Matrix;
        /**
         * Gets the transformation matrix (ie. the multiplication of view by projection matrices)
         * @returns a Matrix
         */
        getTransformationMatrix(): Matrix;
        private _updateFrustumPlanes;
        /**
         * Checks if a cullable object (mesh...) is in the camera frustum
         * This checks the bounding box center. See isCompletelyInFrustum for a full bounding check
         * @param target The object to check
         * @param checkRigCameras If the rig cameras should be checked (eg. with webVR camera both eyes should be checked) (Default: false)
         * @returns true if the object is in frustum otherwise false
         */
        isInFrustum(target: ICullable, checkRigCameras?: boolean): boolean;
        /**
         * Checks if a cullable object (mesh...) is in the camera frustum
         * Unlike isInFrustum this cheks the full bounding box
         * @param target The object to check
         * @returns true if the object is in frustum otherwise false
         */
        isCompletelyInFrustum(target: ICullable): boolean;
        /**
         * Gets a ray in the forward direction from the camera.
         * @param length Defines the length of the ray to create
         * @param transform Defines the transform to apply to the ray, by default the world matrx is used to create a workd space ray
         * @param origin Defines the start point of the ray which defaults to the camera position
         * @returns the forward ray
         */
        getForwardRay(length?: number, transform?: Matrix, origin?: Vector3): Ray;
        /**
         * Gets a ray in the forward direction from the camera.
         * @param refRay the ray to (re)use when setting the values
         * @param length Defines the length of the ray to create
         * @param transform Defines the transform to apply to the ray, by default the world matrx is used to create a workd space ray
         * @param origin Defines the start point of the ray which defaults to the camera position
         * @returns the forward ray
         */
        getForwardRayToRef(refRay: Ray, length?: number, transform?: Matrix, origin?: Vector3): Ray;
        /**
         * Releases resources associated with this node.
         * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
         * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
         */
        dispose(doNotRecurse?: boolean, disposeMaterialAndTextures?: boolean): void;
        /** @hidden */
        _isLeftCamera: boolean;
        /**
         * Gets the left camera of a rig setup in case of Rigged Camera
         */
        get isLeftCamera(): boolean;
        /** @hidden */
        _isRightCamera: boolean;
        /**
         * Gets the right camera of a rig setup in case of Rigged Camera
         */
        get isRightCamera(): boolean;
        /**
         * Gets the left camera of a rig setup in case of Rigged Camera
         */
        get leftCamera(): Nullable<FreeCamera>;
        /**
         * Gets the right camera of a rig setup in case of Rigged Camera
         */
        get rightCamera(): Nullable<FreeCamera>;
        /**
         * Gets the left camera target of a rig setup in case of Rigged Camera
         * @returns the target position
         */
        getLeftTarget(): Nullable<Vector3>;
        /**
         * Gets the right camera target of a rig setup in case of Rigged Camera
         * @returns the target position
         */
        getRightTarget(): Nullable<Vector3>;
        /**
         * @hidden
         */
        setCameraRigMode(mode: number, rigParams: any): void;
        /** @hidden */
        static _setStereoscopicRigMode(camera: Camera): void;
        /** @hidden */
        static _setStereoscopicAnaglyphRigMode(camera: Camera): void;
        /** @hidden */
        static _setVRRigMode(camera: Camera, rigParams: any): void;
        /** @hidden */
        static _setWebVRRigMode(camera: Camera, rigParams: any): void;
        /** @hidden */
        _getVRProjectionMatrix(): Matrix;
        protected _updateCameraRotationMatrix(): void;
        protected _updateWebVRCameraRotationMatrix(): void;
        /**
         * This function MUST be overwritten by the different WebVR cameras available.
         * The context in which it is running is the RIG camera. So 'this' is the TargetCamera, left or right.
         * @hidden
         */
        _getWebVRProjectionMatrix(): Matrix;
        /**
         * This function MUST be overwritten by the different WebVR cameras available.
         * The context in which it is running is the RIG camera. So 'this' is the TargetCamera, left or right.
         * @hidden
         */
        _getWebVRViewMatrix(): Matrix;
        /** @hidden */
        setCameraRigParameter(name: string, value: any): void;
        /**
         * needs to be overridden by children so sub has required properties to be copied
         * @hidden
         */
        createRigCamera(name: string, cameraIndex: number): Nullable<Camera>;
        /**
         * May need to be overridden by children
         * @hidden
         */
        _updateRigCameras(): void;
        /** @hidden */
        _setupInputs(): void;
        /**
         * Serialiaze the camera setup to a json represention
         * @returns the JSON representation
         */
        serialize(): any;
        /**
         * Clones the current camera.
         * @param name The cloned camera name
         * @returns the cloned camera
         */
        clone(name: string): Camera;
        /**
         * Gets the direction of the camera relative to a given local axis.
         * @param localAxis Defines the reference axis to provide a relative direction.
         * @return the direction
         */
        getDirection(localAxis: Vector3): Vector3;
        /**
         * Returns the current camera absolute rotation
         */
        get absoluteRotation(): Quaternion;
        /**
         * Gets the direction of the camera relative to a given local axis into a passed vector.
         * @param localAxis Defines the reference axis to provide a relative direction.
         * @param result Defines the vector to store the result in
         */
        getDirectionToRef(localAxis: Vector3, result: Vector3): void;
        /**
         * Gets a camera constructor for a given camera type
         * @param type The type of the camera to construct (should be equal to one of the camera class name)
         * @param name The name of the camera the result will be able to instantiate
         * @param scene The scene the result will construct the camera in
         * @param interaxial_distance In case of stereoscopic setup, the distance between both eyes
         * @param isStereoscopicSideBySide In case of stereoscopic setup, should the sereo be side b side
         * @returns a factory method to construc the camera
         */
        static GetConstructorFromName(type: string, name: string, scene: Scene, interaxial_distance?: number, isStereoscopicSideBySide?: boolean): () => Camera;
        /**
         * Compute the world  matrix of the camera.
         * @returns the camera world matrix
         */
        computeWorldMatrix(): Matrix;
        /**
         * Parse a JSON and creates the camera from the parsed information
         * @param parsedCamera The JSON to parse
         * @param scene The scene to instantiate the camera in
         * @returns the newly constructed camera
         */
        static Parse(parsedCamera: any, scene: Scene): Camera;
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class DiscBuilder {
        /**
         * Creates a plane polygonal mesh.  By default, this is a disc
         * * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)
         * * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc
         * * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the plane polygonal mesh
         * @see https://doc.babylonjs.com/how_to/set_shapes#disc-or-regular-polygon
         */
        static CreateDisc(name: string, options: {
            radius?: number;
            tessellation?: number;
            arc?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }, scene?: Nullable<Scene>): Mesh;
    }
}
declare module BABYLON {
    /**
     * Options to be used when creating a FresnelParameters.
     */
    export type IFresnelParametersCreationOptions = {
        /**
         * Define the color used on edges (grazing angle)
         */
        leftColor?: Color3;
        /**
         * Define the color used on center
         */
        rightColor?: Color3;
        /**
         * Define bias applied to computed fresnel term
         */
        bias?: number;
        /**
         * Defined the power exponent applied to fresnel term
         */
        power?: number;
        /**
         * Define if the fresnel effect is enable or not.
         */
        isEnabled?: boolean;
    };
    /**
     * Serialized format for FresnelParameters.
     */
    export type IFresnelParametersSerialized = {
        /**
         * Define the color used on edges (grazing angle) [as an array]
         */
        leftColor: number[];
        /**
         * Define the color used on center [as an array]
         */
        rightColor: number[];
        /**
         * Define bias applied to computed fresnel term
         */
        bias: number;
        /**
         * Defined the power exponent applied to fresnel term
         */
        power?: number;
        /**
         * Define if the fresnel effect is enable or not.
         */
        isEnabled: boolean;
    };
    /**
     * This represents all the required information to add a fresnel effect on a material:
     * @see https://doc.babylonjs.com/how_to/how_to_use_fresnelparameters
     */
    export class FresnelParameters {
        private _isEnabled;
        /**
         * Define if the fresnel effect is enable or not.
         */
        get isEnabled(): boolean;
        set isEnabled(value: boolean);
        /**
         * Define the color used on edges (grazing angle)
         */
        leftColor: Color3;
        /**
         * Define the color used on center
         */
        rightColor: Color3;
        /**
         * Define bias applied to computed fresnel term
         */
        bias: number;
        /**
         * Defined the power exponent applied to fresnel term
         */
        power: number;
        /**
         * Creates a new FresnelParameters object.
         *
         * @param options provide your own settings to optionally to override defaults
         */
        constructor(options?: IFresnelParametersCreationOptions);
        /**
         * Clones the current fresnel and its valuues
         * @returns a clone fresnel configuration
         */
        clone(): FresnelParameters;
        /**
         * Determines equality between FresnelParameters objects
         * @param otherFresnelParameters defines the second operand
         * @returns true if the power, bias, leftColor, rightColor and isEnabled values are equal to the given ones
         */
        equals(otherFresnelParameters: DeepImmutable<FresnelParameters>): boolean;
        /**
         * Serializes the current fresnel parameters to a JSON representation.
         * @return the JSON serialization
         */
        serialize(): IFresnelParametersSerialized;
        /**
         * Parse a JSON object and deserialize it to a new Fresnel parameter object.
         * @param parsedFresnelParameters Define the JSON representation
         * @returns the parsed parameters
         */
        static Parse(parsedFresnelParameters: IFresnelParametersSerialized): FresnelParameters;
    }
}
declare module BABYLON {
    /**
     * This groups all the flags used to control the materials channel.
     */
    export class MaterialFlags {
        private static _DiffuseTextureEnabled;
        /**
         * Are diffuse textures enabled in the application.
         */
        static get DiffuseTextureEnabled(): boolean;
        static set DiffuseTextureEnabled(value: boolean);
        private static _DetailTextureEnabled;
        /**
         * Are detail textures enabled in the application.
         */
        static get DetailTextureEnabled(): boolean;
        static set DetailTextureEnabled(value: boolean);
        private static _AmbientTextureEnabled;
        /**
         * Are ambient textures enabled in the application.
         */
        static get AmbientTextureEnabled(): boolean;
        static set AmbientTextureEnabled(value: boolean);
        private static _OpacityTextureEnabled;
        /**
         * Are opacity textures enabled in the application.
         */
        static get OpacityTextureEnabled(): boolean;
        static set OpacityTextureEnabled(value: boolean);
        private static _ReflectionTextureEnabled;
        /**
         * Are reflection textures enabled in the application.
         */
        static get ReflectionTextureEnabled(): boolean;
        static set ReflectionTextureEnabled(value: boolean);
        private static _EmissiveTextureEnabled;
        /**
         * Are emissive textures enabled in the application.
         */
        static get EmissiveTextureEnabled(): boolean;
        static set EmissiveTextureEnabled(value: boolean);
        private static _SpecularTextureEnabled;
        /**
         * Are specular textures enabled in the application.
         */
        static get SpecularTextureEnabled(): boolean;
        static set SpecularTextureEnabled(value: boolean);
        private static _BumpTextureEnabled;
        /**
         * Are bump textures enabled in the application.
         */
        static get BumpTextureEnabled(): boolean;
        static set BumpTextureEnabled(value: boolean);
        private static _LightmapTextureEnabled;
        /**
         * Are lightmap textures enabled in the application.
         */
        static get LightmapTextureEnabled(): boolean;
        static set LightmapTextureEnabled(value: boolean);
        private static _RefractionTextureEnabled;
        /**
         * Are refraction textures enabled in the application.
         */
        static get RefractionTextureEnabled(): boolean;
        static set RefractionTextureEnabled(value: boolean);
        private static _ColorGradingTextureEnabled;
        /**
         * Are color grading textures enabled in the application.
         */
        static get ColorGradingTextureEnabled(): boolean;
        static set ColorGradingTextureEnabled(value: boolean);
        private static _FresnelEnabled;
        /**
         * Are fresnels enabled in the application.
         */
        static get FresnelEnabled(): boolean;
        static set FresnelEnabled(value: boolean);
        private static _ClearCoatTextureEnabled;
        /**
         * Are clear coat textures enabled in the application.
         */
        static get ClearCoatTextureEnabled(): boolean;
        static set ClearCoatTextureEnabled(value: boolean);
        private static _ClearCoatBumpTextureEnabled;
        /**
         * Are clear coat bump textures enabled in the application.
         */
        static get ClearCoatBumpTextureEnabled(): boolean;
        static set ClearCoatBumpTextureEnabled(value: boolean);
        private static _ClearCoatTintTextureEnabled;
        /**
         * Are clear coat tint textures enabled in the application.
         */
        static get ClearCoatTintTextureEnabled(): boolean;
        static set ClearCoatTintTextureEnabled(value: boolean);
        private static _SheenTextureEnabled;
        /**
         * Are sheen textures enabled in the application.
         */
        static get SheenTextureEnabled(): boolean;
        static set SheenTextureEnabled(value: boolean);
        private static _AnisotropicTextureEnabled;
        /**
         * Are anisotropic textures enabled in the application.
         */
        static get AnisotropicTextureEnabled(): boolean;
        static set AnisotropicTextureEnabled(value: boolean);
        private static _ThicknessTextureEnabled;
        /**
         * Are thickness textures enabled in the application.
         */
        static get ThicknessTextureEnabled(): boolean;
        static set ThicknessTextureEnabled(value: boolean);
    }
}
declare module BABYLON {
    /** @hidden */
    export var defaultFragmentDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var defaultUboDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var prePassDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var lightFragmentDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var lightUboDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var lightsFragmentFunctions: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var shadowsFragmentFunctions: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var fresnelFunction: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var bumpFragmentMainFunctions: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var bumpFragmentFunctions: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var logDepthDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var bumpFragment: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var depthPrePass: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var lightFragment: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var logDepthFragment: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var defaultPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var defaultVertexDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var bumpVertexDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var bumpVertex: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var fogVertex: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var shadowsVertex: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pointCloudVertex: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var logDepthVertex: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var defaultVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * @hidden
     */
    export interface IMaterialDetailMapDefines {
        DETAIL: boolean;
        DETAILDIRECTUV: number;
        DETAIL_NORMALBLENDMETHOD: number;
        /** @hidden */
        _areTexturesDirty: boolean;
    }
    /**
     * Define the code related to the detail map parameters of a material
     *
     * Inspired from:
     *   Unity: https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@9.0/manual/Mask-Map-and-Detail-Map.html and https://docs.unity3d.com/Manual/StandardShaderMaterialParameterDetail.html
     *   Unreal: https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/HowTo/DetailTexturing/index.html
     *   Cryengine: https://docs.cryengine.com/display/SDKDOC2/Detail+Maps
     */
    export class DetailMapConfiguration {
        private _texture;
        /**
         * The detail texture of the material.
         */
        texture: Nullable<BaseTexture>;
        /**
         * Defines how strongly the detail diffuse/albedo channel is blended with the regular diffuse/albedo texture
         * Bigger values mean stronger blending
         */
        diffuseBlendLevel: number;
        /**
         * Defines how strongly the detail roughness channel is blended with the regular roughness value
         * Bigger values mean stronger blending. Only used with PBR materials
         */
        roughnessBlendLevel: number;
        /**
         * Defines how strong the bump effect from the detail map is
         * Bigger values mean stronger effect
         */
        bumpLevel: number;
        private _normalBlendMethod;
        /**
         * The method used to blend the bump and detail normals together
         */
        normalBlendMethod: number;
        private _isEnabled;
        /**
         * Enable or disable the detail map on this material
         */
        isEnabled: boolean;
        /** @hidden */
        private _internalMarkAllSubMeshesAsTexturesDirty;
        /** @hidden */
        _markAllSubMeshesAsTexturesDirty(): void;
        /**
         * Instantiate a new detail map
         * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty
         */
        constructor(markAllSubMeshesAsTexturesDirty: () => void);
        /**
         * Gets whether the submesh is ready to be used or not.
         * @param defines the list of "defines" to update.
         * @param scene defines the scene the material belongs to.
         * @returns - boolean indicating that the submesh is ready or not.
         */
        isReadyForSubMesh(defines: IMaterialDetailMapDefines, scene: Scene): boolean;
        /**
         * Update the defines for detail map usage
         * @param defines the list of "defines" to update.
         * @param scene defines the scene the material belongs to.
         */
        prepareDefines(defines: IMaterialDetailMapDefines, scene: Scene): void;
        /**
         * Binds the material data.
         * @param uniformBuffer defines the Uniform buffer to fill in.
         * @param scene defines the scene the material belongs to.
         * @param isFrozen defines whether the material is frozen or not.
         */
        bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, isFrozen: boolean): void;
        /**
         * Checks to see if a texture is used in the material.
         * @param texture - Base texture to use.
         * @returns - Boolean specifying if a texture is used in the material.
         */
        hasTexture(texture: BaseTexture): boolean;
        /**
         * Returns an array of the actively used textures.
         * @param activeTextures Array of BaseTextures
         */
        getActiveTextures(activeTextures: BaseTexture[]): void;
        /**
         * Returns the animatable textures.
         * @param animatables Array of animatable textures.
         */
        getAnimatables(animatables: IAnimatable[]): void;
        /**
         * Disposes the resources of the material.
         * @param forceDisposeTextures - Forces the disposal of all textures.
         */
        dispose(forceDisposeTextures?: boolean): void;
        /**
        * Get the current class name useful for serialization or dynamic coding.
        * @returns "DetailMap"
        */
        getClassName(): string;
        /**
         * Add the required uniforms to the current list.
         * @param uniforms defines the current uniform list.
         */
        static AddUniforms(uniforms: string[]): void;
        /**
         * Add the required samplers to the current list.
         * @param samplers defines the current sampler list.
         */
        static AddSamplers(samplers: string[]): void;
        /**
         * Add the required uniforms to the current buffer.
         * @param uniformBuffer defines the current uniform buffer.
         */
        static PrepareUniformBuffer(uniformBuffer: UniformBuffer): void;
        /**
         * Makes a duplicate of the current instance into another one.
         * @param detailMap define the instance where to copy the info
         */
        copyTo(detailMap: DetailMapConfiguration): void;
        /**
         * Serializes this detail map instance
         * @returns - An object with the serialized instance.
         */
        serialize(): any;
        /**
         * Parses a detail map setting from a serialized object.
         * @param source - Serialized object.
         * @param scene Defines the scene we are parsing for
         * @param rootUrl Defines the rootUrl to load from
         */
        parse(source: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /** @hidden */
    export class StandardMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines, IMaterialDetailMapDefines {
        MAINUV1: boolean;
        MAINUV2: boolean;
        DIFFUSE: boolean;
        DIFFUSEDIRECTUV: number;
        DETAIL: boolean;
        DETAILDIRECTUV: number;
        DETAIL_NORMALBLENDMETHOD: number;
        AMBIENT: boolean;
        AMBIENTDIRECTUV: number;
        OPACITY: boolean;
        OPACITYDIRECTUV: number;
        OPACITYRGB: boolean;
        REFLECTION: boolean;
        EMISSIVE: boolean;
        EMISSIVEDIRECTUV: number;
        SPECULAR: boolean;
        SPECULARDIRECTUV: number;
        BUMP: boolean;
        BUMPDIRECTUV: number;
        PARALLAX: boolean;
        PARALLAXOCCLUSION: boolean;
        SPECULAROVERALPHA: boolean;
        CLIPPLANE: boolean;
        CLIPPLANE2: boolean;
        CLIPPLANE3: boolean;
        CLIPPLANE4: boolean;
        CLIPPLANE5: boolean;
        CLIPPLANE6: boolean;
        ALPHATEST: boolean;
        DEPTHPREPASS: boolean;
        ALPHAFROMDIFFUSE: boolean;
        POINTSIZE: boolean;
        FOG: boolean;
        SPECULARTERM: boolean;
        DIFFUSEFRESNEL: boolean;
        OPACITYFRESNEL: boolean;
        REFLECTIONFRESNEL: boolean;
        REFRACTIONFRESNEL: boolean;
        EMISSIVEFRESNEL: boolean;
        FRESNEL: boolean;
        NORMAL: boolean;
        UV1: boolean;
        UV2: boolean;
        VERTEXCOLOR: boolean;
        VERTEXALPHA: boolean;
        NUM_BONE_INFLUENCERS: number;
        BonesPerMesh: number;
        BONETEXTURE: boolean;
        INSTANCES: boolean;
        THIN_INSTANCES: boolean;
        GLOSSINESS: boolean;
        ROUGHNESS: boolean;
        EMISSIVEASILLUMINATION: boolean;
        LINKEMISSIVEWITHDIFFUSE: boolean;
        REFLECTIONFRESNELFROMSPECULAR: boolean;
        LIGHTMAP: boolean;
        LIGHTMAPDIRECTUV: number;
        OBJECTSPACE_NORMALMAP: boolean;
        USELIGHTMAPASSHADOWMAP: boolean;
        REFLECTIONMAP_3D: boolean;
        REFLECTIONMAP_SPHERICAL: boolean;
        REFLECTIONMAP_PLANAR: boolean;
        REFLECTIONMAP_CUBIC: boolean;
        USE_LOCAL_REFLECTIONMAP_CUBIC: boolean;
        REFLECTIONMAP_PROJECTION: boolean;
        REFLECTIONMAP_SKYBOX: boolean;
        REFLECTIONMAP_EXPLICIT: boolean;
        REFLECTIONMAP_EQUIRECTANGULAR: boolean;
        REFLECTIONMAP_EQUIRECTANGULAR_FIXED: boolean;
        REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED: boolean;
        INVERTCUBICMAP: boolean;
        LOGARITHMICDEPTH: boolean;
        REFRACTION: boolean;
        REFRACTIONMAP_3D: boolean;
        REFLECTIONOVERALPHA: boolean;
        TWOSIDEDLIGHTING: boolean;
        SHADOWFLOAT: boolean;
        MORPHTARGETS: boolean;
        MORPHTARGETS_NORMAL: boolean;
        MORPHTARGETS_TANGENT: boolean;
        MORPHTARGETS_UV: boolean;
        NUM_MORPH_INFLUENCERS: number;
        NONUNIFORMSCALING: boolean;
        PREMULTIPLYALPHA: boolean;
        ALPHATEST_AFTERALLALPHACOMPUTATIONS: boolean;
        ALPHABLEND: boolean;
        PREPASS: boolean;
        SCENE_MRT_COUNT: number;
        RGBDLIGHTMAP: boolean;
        RGBDREFLECTION: boolean;
        RGBDREFRACTION: boolean;
        IMAGEPROCESSING: boolean;
        VIGNETTE: boolean;
        VIGNETTEBLENDMODEMULTIPLY: boolean;
        VIGNETTEBLENDMODEOPAQUE: boolean;
        TONEMAPPING: boolean;
        TONEMAPPING_ACES: boolean;
        CONTRAST: boolean;
        COLORCURVES: boolean;
        COLORGRADING: boolean;
        COLORGRADING3D: boolean;
        SAMPLER3DGREENDEPTH: boolean;
        SAMPLER3DBGRMAP: boolean;
        IMAGEPROCESSINGPOSTPROCESS: boolean;
        MULTIVIEW: boolean;
        /**
         * If the reflection texture on this material is in linear color space
         * @hidden
         */
        IS_REFLECTION_LINEAR: boolean;
        /**
         * If the refraction texture on this material is in linear color space
         * @hidden
         */
        IS_REFRACTION_LINEAR: boolean;
        EXPOSURE: boolean;
        constructor();
        setReflectionMode(modeToEnable: string): void;
    }
    /**
     * This is the default material used in Babylon. It is the best trade off between quality
     * and performances.
     * @see https://doc.babylonjs.com/babylon101/materials
     */
    export class StandardMaterial extends PushMaterial {
        private _diffuseTexture;
        /**
         * The basic texture of the material as viewed under a light.
         */
        diffuseTexture: Nullable<BaseTexture>;
        private _ambientTexture;
        /**
         * AKA Occlusion Texture in other nomenclature, it helps adding baked shadows into your material.
         */
        ambientTexture: Nullable<BaseTexture>;
        private _opacityTexture;
        /**
         * Define the transparency of the material from a texture.
         * The final alpha value can be read either from the red channel (if texture.getAlphaFromRGB is false)
         * or from the luminance or the current texel (if texture.getAlphaFromRGB is true)
         */
        opacityTexture: Nullable<BaseTexture>;
        private _reflectionTexture;
        /**
         * Define the texture used to display the reflection.
         * @see https://doc.babylonjs.com/how_to/reflect#how-to-obtain-reflections-and-refractions
         */
        reflectionTexture: Nullable<BaseTexture>;
        private _emissiveTexture;
        /**
         * Define texture of the material as if self lit.
         * This will be mixed in the final result even in the absence of light.
         */
        emissiveTexture: Nullable<BaseTexture>;
        private _specularTexture;
        /**
         * Define how the color and intensity of the highlight given by the light in the material.
         */
        specularTexture: Nullable<BaseTexture>;
        private _bumpTexture;
        /**
         * Bump mapping is a technique to simulate bump and dents on a rendered surface.
         * These are made by creating a normal map from an image. The means to do this can be found on the web, a search for 'normal map generator' will bring up free and paid for methods of doing this.
         * @see https://doc.babylonjs.com/how_to/more_materials#bump-map
         */
        bumpTexture: Nullable<BaseTexture>;
        private _lightmapTexture;
        /**
         * Complex lighting can be computationally expensive to compute at runtime.
         * To save on computation, lightmaps may be used to store calculated lighting in a texture which will be applied to a given mesh.
         * @see https://doc.babylonjs.com/babylon101/lights#lightmaps
         */
        lightmapTexture: Nullable<BaseTexture>;
        private _refractionTexture;
        /**
         * Define the texture used to display the refraction.
         * @see https://doc.babylonjs.com/how_to/reflect#how-to-obtain-reflections-and-refractions
         */
        refractionTexture: Nullable<BaseTexture>;
        /**
         * The color of the material lit by the environmental background lighting.
         * @see https://doc.babylonjs.com/babylon101/materials#ambient-color-example
         */
        ambientColor: Color3;
        /**
         * The basic color of the material as viewed under a light.
         */
        diffuseColor: Color3;
        /**
         * Define how the color and intensity of the highlight given by the light in the material.
         */
        specularColor: Color3;
        /**
         * Define the color of the material as if self lit.
         * This will be mixed in the final result even in the absence of light.
         */
        emissiveColor: Color3;
        /**
         * Defines how sharp are the highlights in the material.
         * The bigger the value the sharper giving a more glossy feeling to the result.
         * Reversely, the smaller the value the blurrier giving a more rough feeling to the result.
         */
        specularPower: number;
        private _useAlphaFromDiffuseTexture;
        /**
         * Does the transparency come from the diffuse texture alpha channel.
         */
        useAlphaFromDiffuseTexture: boolean;
        private _useEmissiveAsIllumination;
        /**
         * If true, the emissive value is added into the end result, otherwise it is multiplied in.
         */
        useEmissiveAsIllumination: boolean;
        private _linkEmissiveWithDiffuse;
        /**
         * If true, some kind of energy conservation will prevent the end result to be more than 1 by reducing
         * the emissive level when the final color is close to one.
         */
        linkEmissiveWithDiffuse: boolean;
        private _useSpecularOverAlpha;
        /**
         * Specifies that the material will keep the specular highlights over a transparent surface (only the most limunous ones).
         * A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.
         */
        useSpecularOverAlpha: boolean;
        private _useReflectionOverAlpha;
        /**
         * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).
         * A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.
         */
        useReflectionOverAlpha: boolean;
        private _disableLighting;
        /**
         * Does lights from the scene impacts this material.
         * It can be a nice trick for performance to disable lighting on a fully emissive material.
         */
        disableLighting: boolean;
        private _useObjectSpaceNormalMap;
        /**
         * Allows using an object space normal map (instead of tangent space).
         */
        useObjectSpaceNormalMap: boolean;
        private _useParallax;
        /**
         * Is parallax enabled or not.
         * @see https://doc.babylonjs.com/how_to/using_parallax_mapping
         */
        useParallax: boolean;
        private _useParallaxOcclusion;
        /**
         * Is parallax occlusion enabled or not.
         * If true, the outcome is way more realistic than traditional Parallax but you can expect a performance hit that worthes consideration.
         * @see https://doc.babylonjs.com/how_to/using_parallax_mapping
         */
        useParallaxOcclusion: boolean;
        /**
         * Apply a scaling factor that determine which "depth" the height map should reprensent. A value between 0.05 and 0.1 is reasonnable in Parallax, you can reach 0.2 using Parallax Occlusion.
         */
        parallaxScaleBias: number;
        private _roughness;
        /**
         * Helps to define how blurry the reflections should appears in the material.
         */
        roughness: number;
        /**
         * In case of refraction, define the value of the index of refraction.
         * @see https://doc.babylonjs.com/how_to/reflect#how-to-obtain-reflections-and-refractions
         */
        indexOfRefraction: number;
        /**
         * Invert the refraction texture alongside the y axis.
         * It can be useful with procedural textures or probe for instance.
         * @see https://doc.babylonjs.com/how_to/reflect#how-to-obtain-reflections-and-refractions
         */
        invertRefractionY: boolean;
        /**
         * Defines the alpha limits in alpha test mode.
         */
        alphaCutOff: number;
        private _useLightmapAsShadowmap;
        /**
         * In case of light mapping, define whether the map contains light or shadow informations.
         */
        useLightmapAsShadowmap: boolean;
        private _diffuseFresnelParameters;
        /**
         * Define the diffuse fresnel parameters of the material.
         * @see https://doc.babylonjs.com/how_to/how_to_use_fresnelparameters
         */
        diffuseFresnelParameters: FresnelParameters;
        private _opacityFresnelParameters;
        /**
         * Define the opacity fresnel parameters of the material.
         * @see https://doc.babylonjs.com/how_to/how_to_use_fresnelparameters
         */
        opacityFresnelParameters: FresnelParameters;
        private _reflectionFresnelParameters;
        /**
         * Define the reflection fresnel parameters of the material.
         * @see https://doc.babylonjs.com/how_to/how_to_use_fresnelparameters
         */
        reflectionFresnelParameters: FresnelParameters;
        private _refractionFresnelParameters;
        /**
         * Define the refraction fresnel parameters of the material.
         * @see https://doc.babylonjs.com/how_to/how_to_use_fresnelparameters
         */
        refractionFresnelParameters: FresnelParameters;
        private _emissiveFresnelParameters;
        /**
         * Define the emissive fresnel parameters of the material.
         * @see https://doc.babylonjs.com/how_to/how_to_use_fresnelparameters
         */
        emissiveFresnelParameters: FresnelParameters;
        private _useReflectionFresnelFromSpecular;
        /**
         * If true automatically deducts the fresnels values from the material specularity.
         * @see https://doc.babylonjs.com/how_to/how_to_use_fresnelparameters
         */
        useReflectionFresnelFromSpecular: boolean;
        private _useGlossinessFromSpecularMapAlpha;
        /**
         * Defines if the glossiness/roughness of the material should be read from the specular map alpha channel
         */
        useGlossinessFromSpecularMapAlpha: boolean;
        private _maxSimultaneousLights;
        /**
         * Defines the maximum number of lights that can be used in the material
         */
        maxSimultaneousLights: number;
        private _invertNormalMapX;
        /**
         * If sets to true, x component of normal map value will invert (x = 1.0 - x).
         */
        invertNormalMapX: boolean;
        private _invertNormalMapY;
        /**
         * If sets to true, y component of normal map value will invert (y = 1.0 - y).
         */
        invertNormalMapY: boolean;
        private _twoSidedLighting;
        /**
         * If sets to true and backfaceCulling is false, normals will be flipped on the backside.
         */
        twoSidedLighting: boolean;
        /**
         * Default configuration related to image processing available in the standard Material.
         */
        protected _imageProcessingConfiguration: ImageProcessingConfiguration;
        /**
         * Gets the image processing configuration used either in this material.
         */
        get imageProcessingConfiguration(): ImageProcessingConfiguration;
        /**
         * Sets the Default image processing configuration used either in the this material.
         *
         * If sets to null, the scene one is in use.
         */
        set imageProcessingConfiguration(value: ImageProcessingConfiguration);
        /**
         * Keep track of the image processing observer to allow dispose and replace.
         */
        private _imageProcessingObserver;
        /**
         * Attaches a new image processing configuration to the Standard Material.
         * @param configuration
         */
        protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void;
        /**
         * Gets wether the color curves effect is enabled.
         */
        get cameraColorCurvesEnabled(): boolean;
        /**
         * Sets wether the color curves effect is enabled.
         */
        set cameraColorCurvesEnabled(value: boolean);
        /**
         * Gets wether the color grading effect is enabled.
         */
        get cameraColorGradingEnabled(): boolean;
        /**
         * Gets wether the color grading effect is enabled.
         */
        set cameraColorGradingEnabled(value: boolean);
        /**
         * Gets wether tonemapping is enabled or not.
         */
        get cameraToneMappingEnabled(): boolean;
        /**
         * Sets wether tonemapping is enabled or not
         */
        set cameraToneMappingEnabled(value: boolean);
        /**
         * The camera exposure used on this material.
         * This property is here and not in the camera to allow controlling exposure without full screen post process.
         * This corresponds to a photographic exposure.
         */
        get cameraExposure(): number;
        /**
         * The camera exposure used on this material.
         * This property is here and not in the camera to allow controlling exposure without full screen post process.
         * This corresponds to a photographic exposure.
         */
        set cameraExposure(value: number);
        /**
         * Gets The camera contrast used on this material.
         */
        get cameraContrast(): number;
        /**
         * Sets The camera contrast used on this material.
         */
        set cameraContrast(value: number);
        /**
         * Gets the Color Grading 2D Lookup Texture.
         */
        get cameraColorGradingTexture(): Nullable<BaseTexture>;
        /**
         * Sets the Color Grading 2D Lookup Texture.
         */
        set cameraColorGradingTexture(value: Nullable<BaseTexture>);
        /**
         * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
         * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
         * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
         * corresponding to low luminance, medium luminance, and high luminance areas respectively.
         */
        get cameraColorCurves(): Nullable<ColorCurves>;
        /**
         * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
         * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
         * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
         * corresponding to low luminance, medium luminance, and high luminance areas respectively.
         */
        set cameraColorCurves(value: Nullable<ColorCurves>);
        /**
         * Can this material render to several textures at once
         */
        get canRenderToMRT(): boolean;
        /**
         * Defines the detail map parameters for the material.
         */
        readonly detailMap: DetailMapConfiguration;
        protected _renderTargets: SmartArray<RenderTargetTexture>;
        protected _worldViewProjectionMatrix: Matrix;
        protected _globalAmbientColor: Color3;
        protected _useLogarithmicDepth: boolean;
        protected _rebuildInParallel: boolean;
        /**
         * Instantiates a new standard material.
         * This is the default material used in Babylon. It is the best trade off between quality
         * and performances.
         * @see https://doc.babylonjs.com/babylon101/materials
         * @param name Define the name of the material in the scene
         * @param scene Define the scene the material belong to
         */
        constructor(name: string, scene: Scene);
        /**
         * Gets a boolean indicating that current material needs to register RTT
         */
        get hasRenderTargetTextures(): boolean;
        /**
         * Gets the current class name of the material e.g. "StandardMaterial"
         * Mainly use in serialization.
         * @returns the class name
         */
        getClassName(): string;
        /**
         * In case the depth buffer does not allow enough depth precision for your scene (might be the case in large scenes)
         * You can try switching to logarithmic depth.
         * @see https://doc.babylonjs.com/how_to/using_logarithmic_depth_buffer
         */
        get useLogarithmicDepth(): boolean;
        set useLogarithmicDepth(value: boolean);
        /**
         * Specifies if the material will require alpha blending
         * @returns a boolean specifying if alpha blending is needed
         */
        needAlphaBlending(): boolean;
        /**
         * Specifies if this material should be rendered in alpha test mode
         * @returns a boolean specifying if an alpha test is needed.
         */
        needAlphaTesting(): boolean;
        protected _shouldUseAlphaFromDiffuseTexture(): boolean;
        /**
         * Get the texture used for alpha test purpose.
         * @returns the diffuse texture in case of the standard material.
         */
        getAlphaTestTexture(): Nullable<BaseTexture>;
        /**
         * Get if the submesh is ready to be used and all its information available.
         * Child classes can use it to update shaders
         * @param mesh defines the mesh to check
         * @param subMesh defines which submesh to check
         * @param useInstances specifies that instances should be used
         * @returns a boolean indicating that the submesh is ready or not
         */
        isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean;
        /**
         * Builds the material UBO layouts.
         * Used internally during the effect preparation.
         */
        buildUniformLayout(): void;
        /**
         * Unbinds the material from the mesh
         */
        unbind(): void;
        /**
         * Binds the submesh to this material by preparing the effect and shader to draw
         * @param world defines the world transformation matrix
         * @param mesh defines the mesh containing the submesh
         * @param subMesh defines the submesh to bind the material to
         */
        bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void;
        /**
         * Get the list of animatables in the material.
         * @returns the list of animatables object used in the material
         */
        getAnimatables(): IAnimatable[];
        /**
         * Gets the active textures from the material
         * @returns an array of textures
         */
        getActiveTextures(): BaseTexture[];
        /**
         * Specifies if the material uses a texture
         * @param texture defines the texture to check against the material
         * @returns a boolean specifying if the material uses the texture
         */
        hasTexture(texture: BaseTexture): boolean;
        /**
         * Disposes the material
         * @param forceDisposeEffect specifies if effects should be forcefully disposed
         * @param forceDisposeTextures specifies if textures should be forcefully disposed
         */
        dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean): void;
        /**
         * Makes a duplicate of the material, and gives it a new name
         * @param name defines the new name for the duplicated material
         * @returns the cloned material
         */
        clone(name: string): StandardMaterial;
        /**
         * Serializes this material in a JSON representation
         * @returns the serialized material object
         */
        serialize(): any;
        /**
         * Creates a standard material from parsed material data
         * @param source defines the JSON representation of the material
         * @param scene defines the hosting scene
         * @param rootUrl defines the root URL to use to load textures and relative dependencies
         * @returns a new standard material
         */
        static Parse(source: any, scene: Scene, rootUrl: string): StandardMaterial;
        /**
         * Are diffuse textures enabled in the application.
         */
        static get DiffuseTextureEnabled(): boolean;
        static set DiffuseTextureEnabled(value: boolean);
        /**
         * Are detail textures enabled in the application.
         */
        static get DetailTextureEnabled(): boolean;
        static set DetailTextureEnabled(value: boolean);
        /**
         * Are ambient textures enabled in the application.
         */
        static get AmbientTextureEnabled(): boolean;
        static set AmbientTextureEnabled(value: boolean);
        /**
         * Are opacity textures enabled in the application.
         */
        static get OpacityTextureEnabled(): boolean;
        static set OpacityTextureEnabled(value: boolean);
        /**
         * Are reflection textures enabled in the application.
         */
        static get ReflectionTextureEnabled(): boolean;
        static set ReflectionTextureEnabled(value: boolean);
        /**
         * Are emissive textures enabled in the application.
         */
        static get EmissiveTextureEnabled(): boolean;
        static set EmissiveTextureEnabled(value: boolean);
        /**
         * Are specular textures enabled in the application.
         */
        static get SpecularTextureEnabled(): boolean;
        static set SpecularTextureEnabled(value: boolean);
        /**
         * Are bump textures enabled in the application.
         */
        static get BumpTextureEnabled(): boolean;
        static set BumpTextureEnabled(value: boolean);
        /**
         * Are lightmap textures enabled in the application.
         */
        static get LightmapTextureEnabled(): boolean;
        static set LightmapTextureEnabled(value: boolean);
        /**
         * Are refraction textures enabled in the application.
         */
        static get RefractionTextureEnabled(): boolean;
        static set RefractionTextureEnabled(value: boolean);
        /**
         * Are color grading textures enabled in the application.
         */
        static get ColorGradingTextureEnabled(): boolean;
        static set ColorGradingTextureEnabled(value: boolean);
        /**
         * Are fresnels enabled in the application.
         */
        static get FresnelEnabled(): boolean;
        static set FresnelEnabled(value: boolean);
    }
}
declare module BABYLON {
    /**
     * The SPS is a single updatable mesh. The solid particles are simply separate parts or faces fo this big mesh.
     *As it is just a mesh, the SPS has all the same properties than any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.
     * The SPS is also a particle system. It provides some methods to manage the particles.
     * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.
     *
     * Full documentation here : https://doc.babylonjs.com/how_to/Solid_Particle_System
     */
    export class SolidParticleSystem implements IDisposable {
        /**
         *  The SPS array of Solid Particle objects. Just access each particle as with any classic array.
         *  Example : var p = SPS.particles[i];
         */
        particles: SolidParticle[];
        /**
         * The SPS total number of particles. Read only. Use SPS.counter instead if you need to set your own value.
         */
        nbParticles: number;
        /**
         * If the particles must ever face the camera (default false). Useful for planar particles.
         */
        billboard: boolean;
        /**
         * Recompute normals when adding a shape
         */
        recomputeNormals: boolean;
        /**
         * This a counter ofr your own usage. It's not set by any SPS functions.
         */
        counter: number;
        /**
         * The SPS name. This name is also given to the underlying mesh.
         */
        name: string;
        /**
         * The SPS mesh. It's a standard BJS Mesh, so all the methods from the Mesh class are avalaible.
         */
        mesh: Mesh;
        /**
         * This empty object is intended to store some SPS specific or temporary values in order to lower the Garbage Collector activity.
         * Please read : https://doc.babylonjs.com/how_to/Solid_Particle_System#garbage-collector-concerns
         */
        vars: any;
        /**
         * This array is populated when the SPS is set as 'pickable'.
         * Each key of this array is a `faceId` value that you can get from a pickResult object.
         * Each element of this array is an object `{idx: int, faceId: int}`.
         * `idx` is the picked particle index in the `SPS.particles` array
         * `faceId` is the picked face index counted within this particle.
         * This array is the first element of the pickedBySubMesh array : sps.pickBySubMesh[0].
         * It's not pertinent to use it when using a SPS with the support for MultiMaterial enabled.
         * Use the method SPS.pickedParticle(pickingInfo) instead.
         * Please read : https://doc.babylonjs.com/how_to/Solid_Particle_System#pickable-particles
         */
        pickedParticles: {
            idx: number;
            faceId: number;
        }[];
        /**
         * This array is populated when the SPS is set as 'pickable'
         * Each key of this array is a submesh index.
         * Each element of this array is a second array defined like this :
         * Each key of this second array is a `faceId` value that you can get from a pickResult object.
         * Each element of this second array is an object `{idx: int, faceId: int}`.
         * `idx` is the picked particle index in the `SPS.particles` array
         * `faceId` is the picked face index counted within this particle.
         * It's better to use the method SPS.pickedParticle(pickingInfo) rather than using directly this array.
         * Please read : https://doc.babylonjs.com/how_to/Solid_Particle_System#pickable-particles
         */
        pickedBySubMesh: {
            idx: number;
            faceId: number;
        }[][];
        /**
         * This array is populated when `enableDepthSort` is set to true.
         * Each element of this array is an instance of the class DepthSortedParticle.
         */
        depthSortedParticles: DepthSortedParticle[];
        /**
         * If the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster). (Internal use only)
         * @hidden
         */
        _bSphereOnly: boolean;
        /**
         * A number to multiply the boundind sphere radius by in order to reduce it for instance. (Internal use only)
         * @hidden
         */
        _bSphereRadiusFactor: number;
        private _scene;
        private _positions;
        private _indices;
        private _normals;
        private _colors;
        private _uvs;
        private _indices32;
        private _positions32;
        private _normals32;
        private _fixedNormal32;
        private _colors32;
        private _uvs32;
        private _index;
        private _updatable;
        private _pickable;
        private _isVisibilityBoxLocked;
        private _alwaysVisible;
        private _depthSort;
        private _expandable;
        private _shapeCounter;
        private _copy;
        private _color;
        private _computeParticleColor;
        private _computeParticleTexture;
        private _computeParticleRotation;
        private _computeParticleVertex;
        private _computeBoundingBox;
        private _depthSortParticles;
        private _camera;
        private _mustUnrotateFixedNormals;
        private _particlesIntersect;
        private _needs32Bits;
        private _isNotBuilt;
        private _lastParticleId;
        private _idxOfId;
        private _multimaterialEnabled;
        private _useModelMaterial;
        private _indicesByMaterial;
        private _materialIndexes;
        private _depthSortFunction;
        private _materialSortFunction;
        private _materials;
        private _multimaterial;
        private _materialIndexesById;
        private _defaultMaterial;
        private _autoUpdateSubMeshes;
        private _tmpVertex;
        /**
         * Creates a SPS (Solid Particle System) object.
         * @param name (String) is the SPS name, this will be the underlying mesh name.
         * @param scene (Scene) is the scene in which the SPS is added.
         * @param options defines the options of the sps e.g.
         * * updatable (optional boolean, default true) : if the SPS must be updatable or immutable.
         * * isPickable (optional boolean, default false) : if the solid particles must be pickable.
         * * enableDepthSort (optional boolean, default false) : if the solid particles must be sorted in the geometry according to their distance to the camera.
         * * useModelMaterial (optional boolean, defaut false) : if the model materials must be used to create the SPS multimaterial. This enables the multimaterial supports of the SPS.
         * * enableMultiMaterial (optional boolean, default false) : if the solid particles can be given different materials.
         * * expandable (optional boolean, default false) : if particles can still be added after the initial SPS mesh creation.
         * * particleIntersection (optional boolean, default false) : if the solid particle intersections must be computed.
         * * boundingSphereOnly (optional boolean, default false) : if the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster).
         * * bSphereRadiusFactor (optional float, default 1.0) : a number to multiply the boundind sphere radius by in order to reduce it for instance.
         * @example bSphereRadiusFactor = 1.0 / Math.sqrt(3.0) => the bounding sphere exactly matches a spherical mesh.
         */
        constructor(name: string, scene: Scene, options?: {
            updatable?: boolean;
            isPickable?: boolean;
            enableDepthSort?: boolean;
            particleIntersection?: boolean;
            boundingSphereOnly?: boolean;
            bSphereRadiusFactor?: number;
            expandable?: boolean;
            useModelMaterial?: boolean;
            enableMultiMaterial?: boolean;
        });
        /**
         * Builds the SPS underlying mesh. Returns a standard Mesh.
         * If no model shape was added to the SPS, the returned mesh is just a single triangular plane.
         * @returns the created mesh
         */
        buildMesh(): Mesh;
        /**
         * Digests the mesh and generates as many solid particles in the system as wanted. Returns the SPS.
         * These particles will have the same geometry than the mesh parts and will be positioned at the same localisation than the mesh original places.
         * Thus the particles generated from `digest()` have their property `position` set yet.
         * @param mesh ( Mesh ) is the mesh to be digested
         * @param options {facetNb} (optional integer, default 1) is the number of mesh facets per particle, this parameter is overriden by the parameter `number` if any
         * {delta} (optional integer, default 0) is the random extra number of facets per particle , each particle will have between `facetNb` and `facetNb + delta` facets
         * {number} (optional positive integer) is the wanted number of particles : each particle is built with `mesh_total_facets / number` facets
         * {storage} (optional existing array) is an array where the particles will be stored for a further use instead of being inserted in the SPS.
         * @returns the current SPS
         */
        digest(mesh: Mesh, options?: {
            facetNb?: number;
            number?: number;
            delta?: number;
            storage?: [];
        }): SolidParticleSystem;
        /**
         * Unrotate the fixed normals in case the mesh was built with pre-rotated particles, ex : use of positionFunction in addShape()
         * @hidden
         */
        private _unrotateFixedNormals;
        /**
         * Resets the temporary working copy particle
         * @hidden
         */
        private _resetCopy;
        /**
         * Inserts the shape model geometry in the global SPS mesh by updating the positions, indices, normals, colors, uvs arrays
         * @param p the current index in the positions array to be updated
         * @param ind the current index in the indices array
         * @param shape a Vector3 array, the shape geometry
         * @param positions the positions array to be updated
         * @param meshInd the shape indices array
         * @param indices the indices array to be updated
         * @param meshUV the shape uv array
         * @param uvs the uv array to be updated
         * @param meshCol the shape color array
         * @param colors the color array to be updated
         * @param meshNor the shape normals array
         * @param normals the normals array to be updated
         * @param idx the particle index
         * @param idxInShape the particle index in its shape
         * @param options the addShape() method  passed options
         * @model the particle model
         * @hidden
         */
        private _meshBuilder;
        /**
         * Returns a shape Vector3 array from positions float array
         * @param positions float array
         * @returns a vector3 array
         * @hidden
         */
        private _posToShape;
        /**
         * Returns a shapeUV array from a float uvs (array deep copy)
         * @param uvs as a float array
         * @returns a shapeUV array
         * @hidden
         */
        private _uvsToShapeUV;
        /**
         * Adds a new particle object in the particles array
         * @param idx particle index in particles array
         * @param id particle id
         * @param idxpos positionIndex : the starting index of the particle vertices in the SPS "positions" array
         * @param idxind indiceIndex : he starting index of the particle indices in the SPS "indices" array
         * @param model particle ModelShape object
         * @param shapeId model shape identifier
         * @param idxInShape index of the particle in the current model
         * @param bInfo model bounding info object
         * @param storage target storage array, if any
         * @hidden
         */
        private _addParticle;
        /**
         * Adds some particles to the SPS from the model shape. Returns the shape id.
         * Please read the doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#create-an-immutable-sps
         * @param mesh is any Mesh object that will be used as a model for the solid particles.
         * @param nb (positive integer) the number of particles to be created from this model
         * @param options {positionFunction} is an optional javascript function to called for each particle on SPS creation.
         * {vertexFunction} is an optional javascript function to called for each vertex of each particle on SPS creation
         * {storage} (optional existing array) is an array where the particles will be stored for a further use instead of being inserted in the SPS.
         * @returns the number of shapes in the system
         */
        addShape(mesh: Mesh, nb: number, options?: {
            positionFunction?: any;
            vertexFunction?: any;
            storage?: [];
        }): number;
        /**
         * Rebuilds a particle back to its just built status : if needed, recomputes the custom positions and vertices
         * @hidden
         */
        private _rebuildParticle;
        /**
         * Rebuilds the whole mesh and updates the VBO : custom positions and vertices are recomputed if needed.
         * @param reset boolean, default false : if the particles must be reset at position and rotation zero, scaling 1, color white, initial UVs and not parented.
         * @returns the SPS.
         */
        rebuildMesh(reset?: boolean): SolidParticleSystem;
        /** Removes the particles from the start-th to the end-th included from an expandable SPS (required).
         *  Returns an array with the removed particles.
         *  If the number of particles to remove is lower than zero or greater than the global remaining particle number, then an empty array is returned.
         *  The SPS can't be empty so at least one particle needs to remain in place.
         *  Under the hood, the VertexData array, so the VBO buffer, is recreated each call.
         * @param start index of the first particle to remove
         * @param end index of the last particle to remove (included)
         * @returns an array populated with the removed particles
         */
        removeParticles(start: number, end: number): SolidParticle[];
        /**
         * Inserts some pre-created particles in the solid particle system so that they can be managed by setParticles().
         * @param solidParticleArray an array populated with Solid Particles objects
         * @returns the SPS
         */
        insertParticlesFromArray(solidParticleArray: SolidParticle[]): SolidParticleSystem;
        /**
         * Creates a new particle and modifies the SPS mesh geometry :
         * - calls _meshBuilder() to increase the SPS mesh geometry step by step
         * - calls _addParticle() to populate the particle array
         * factorized code from addShape() and insertParticlesFromArray()
         * @param idx particle index in the particles array
         * @param i particle index in its shape
         * @param modelShape particle ModelShape object
         * @param shape shape vertex array
         * @param meshInd shape indices array
         * @param meshUV shape uv array
         * @param meshCol shape color array
         * @param meshNor shape normals array
         * @param bbInfo shape bounding info
         * @param storage target particle storage
         * @options addShape() passed options
         * @hidden
         */
        private _insertNewParticle;
        /**
         *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.
         *  This method calls `updateParticle()` for each particle of the SPS.
         *  For an animated SPS, it is usually called within the render loop.
         * This methods does nothing if called on a non updatable or not yet built SPS. Example : buildMesh() not called after having added or removed particles from an expandable SPS.
         * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_
         * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_
         * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_
         * @returns the SPS.
         */
        setParticles(start?: number, end?: number, update?: boolean): SolidParticleSystem;
        /**
        * Disposes the SPS.
        */
        dispose(): void;
        /** Returns an object {idx: numbern faceId: number} for the picked particle from the passed pickingInfo object.
         * idx is the particle index in the SPS
         * faceId is the picked face index counted within this particle.
         * Returns null if the pickInfo can't identify a picked particle.
         * @param pickingInfo (PickingInfo object)
         * @returns {idx: number, faceId: number} or null
         */
        pickedParticle(pickingInfo: PickingInfo): Nullable<{
            idx: number;
            faceId: number;
        }>;
        /**
         * Returns a SolidParticle object from its identifier : particle.id
         * @param id (integer) the particle Id
         * @returns the searched particle or null if not found in the SPS.
         */
        getParticleById(id: number): Nullable<SolidParticle>;
        /**
         * Returns a new array populated with the particles having the passed shapeId.
         * @param shapeId (integer) the shape identifier
         * @returns a new solid particle array
         */
        getParticlesByShapeId(shapeId: number): SolidParticle[];
        /**
         * Populates the passed array "ref" with the particles having the passed shapeId.
         * @param shapeId the shape identifier
         * @returns the SPS
         * @param ref
         */
        getParticlesByShapeIdToRef(shapeId: number, ref: SolidParticle[]): SolidParticleSystem;
        /**
         * Computes the required SubMeshes according the materials assigned to the particles.
         * @returns the solid particle system.
         * Does nothing if called before the SPS mesh is built.
         */
        computeSubMeshes(): SolidParticleSystem;
        /**
         * Sorts the solid particles by material when MultiMaterial is enabled.
         * Updates the indices32 array.
         * Updates the indicesByMaterial array.
         * Updates the mesh indices array.
         * @returns the SPS
         * @hidden
         */
        private _sortParticlesByMaterial;
        /**
         * Sets the material indexes by id materialIndexesById[id] = materialIndex
         * @hidden
         */
        private _setMaterialIndexesById;
        /**
         * Returns an array with unique values of Materials from the passed array
         * @param array the material array to be checked and filtered
         * @hidden
         */
        private _filterUniqueMaterialId;
        /**
         * Sets a new Standard Material as _defaultMaterial if not already set.
         * @hidden
         */
        private _setDefaultMaterial;
        /**
         * Visibilty helper : Recomputes the visible size according to the mesh bounding box
         * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility
         * @returns the SPS.
         */
        refreshVisibleSize(): SolidParticleSystem;
        /**
         * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.
         * @param size the size (float) of the visibility box
         * note : this doesn't lock the SPS mesh bounding box.
         * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility
         */
        setVisibilityBox(size: number): void;
        /**
         * Gets whether the SPS as always visible or not
         * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility
         */
        get isAlwaysVisible(): boolean;
        /**
         * Sets the SPS as always visible or not
         * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility
         */
        set isAlwaysVisible(val: boolean);
        /**
         * Sets the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.
         * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility
         */
        set isVisibilityBoxLocked(val: boolean);
        /**
         * Gets if the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.
         * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility
         */
        get isVisibilityBoxLocked(): boolean;
        /**
         * Tells to `setParticles()` to compute the particle rotations or not.
         * Default value : true. The SPS is faster when it's set to false.
         * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.
         */
        set computeParticleRotation(val: boolean);
        /**
         * Tells to `setParticles()` to compute the particle colors or not.
         * Default value : true. The SPS is faster when it's set to false.
         * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.
         */
        set computeParticleColor(val: boolean);
        set computeParticleTexture(val: boolean);
        /**
         * Tells to `setParticles()` to call the vertex function for each vertex of each particle, or not.
         * Default value : false. The SPS is faster when it's set to false.
         * Note : the particle custom vertex positions aren't stored values.
         */
        set computeParticleVertex(val: boolean);
        /**
         * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.
         */
        set computeBoundingBox(val: boolean);
        /**
         * Tells to `setParticles()` to sort or not the distance between each particle and the camera.
         * Skipped when `enableDepthSort` is set to `false` (default) at construction time.
         * Default : `true`
         */
        set depthSortParticles(val: boolean);
        /**
         * Gets if `setParticles()` computes the particle rotations or not.
         * Default value : true. The SPS is faster when it's set to false.
         * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.
         */
        get computeParticleRotation(): boolean;
        /**
         * Gets if `setParticles()` computes the particle colors or not.
         * Default value : true. The SPS is faster when it's set to false.
         * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.
         */
        get computeParticleColor(): boolean;
        /**
         * Gets if `setParticles()` computes the particle textures or not.
         * Default value : true. The SPS is faster when it's set to false.
         * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.
         */
        get computeParticleTexture(): boolean;
        /**
         * Gets if `setParticles()` calls the vertex function for each vertex of each particle, or not.
         * Default value : false. The SPS is faster when it's set to false.
         * Note : the particle custom vertex positions aren't stored values.
         */
        get computeParticleVertex(): boolean;
        /**
         * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.
         */
        get computeBoundingBox(): boolean;
        /**
         * Gets if `setParticles()` sorts or not the distance between each particle and the camera.
         * Skipped when `enableDepthSort` is set to `false` (default) at construction time.
         * Default : `true`
         */
        get depthSortParticles(): boolean;
        /**
         * Gets if the SPS is created as expandable at construction time.
         * Default : `false`
         */
        get expandable(): boolean;
        /**
         * Gets if the SPS supports the Multi Materials
         */
        get multimaterialEnabled(): boolean;
        /**
         * Gets if the SPS uses the model materials for its own multimaterial.
         */
        get useModelMaterial(): boolean;
        /**
         * The SPS used material array.
        */
        get materials(): Material[];
        /**
         * Sets the SPS MultiMaterial from the passed materials.
         * Note : the passed array is internally copied and not used then by reference.
         * @param materials an array of material objects. This array indexes are the materialIndex values of the particles.
         */
        setMultiMaterial(materials: Material[]): void;
        /**
         * The SPS computed multimaterial object
         */
        get multimaterial(): MultiMaterial;
        set multimaterial(mm: MultiMaterial);
        /**
         * If the subMeshes must be updated on the next call to setParticles()
         */
        get autoUpdateSubMeshes(): boolean;
        set autoUpdateSubMeshes(val: boolean);
        /**
         * This function does nothing. It may be overwritten to set all the particle first values.
         * The SPS doesn't call this function, you may have to call it by your own.
         * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management
         */
        initParticles(): void;
        /**
         * This function does nothing. It may be overwritten to recycle a particle.
         * The SPS doesn't call this function, you may have to call it by your own.
         * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management
         * @param particle The particle to recycle
         * @returns the recycled particle
         */
        recycleParticle(particle: SolidParticle): SolidParticle;
        /**
         * Updates a particle : this function should  be overwritten by the user.
         * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.
         * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management
         * @example : just set a particle position or velocity and recycle conditions
         * @param particle The particle to update
         * @returns the updated particle
         */
        updateParticle(particle: SolidParticle): SolidParticle;
        /**
         * Updates a vertex of a particle : it can be overwritten by the user.
         * This will be called on each vertex particle by `setParticles()` if `computeParticleVertex` is set to true only.
         * @param particle the current particle
         * @param vertex the current vertex of the current particle : a SolidParticleVertex object
         * @param pt the index of the current vertex in the particle shape
         * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#update-each-particle-shape
         * @example : just set a vertex particle position or color
         * @returns the sps
         */
        updateParticleVertex(particle: SolidParticle, vertex: SolidParticleVertex, pt: number): SolidParticleSystem;
        /**
         * This will be called before any other treatment by `setParticles()` and will be passed three parameters.
         * This does nothing and may be overwritten by the user.
         * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
         * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
         * @param update the boolean update value actually passed to setParticles()
         */
        beforeUpdateParticles(start?: number, stop?: number, update?: boolean): void;
        /**
         * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.
         * This will be passed three parameters.
         * This does nothing and may be overwritten by the user.
         * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
         * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
         * @param update the boolean update value actually passed to setParticles()
         */
        afterUpdateParticles(start?: number, stop?: number, update?: boolean): void;
    }
}
declare module BABYLON {
    /**
     * Represents one particle of a solid particle system.
     */
    export class SolidParticle {
        /**
         * particle global index
         */
        idx: number;
        /**
         * particle identifier
         */
        id: number;
        /**
         * The color of the particle
         */
        color: Nullable<Color4>;
        /**
         * The world space position of the particle.
         */
        position: Vector3;
        /**
         * The world space rotation of the particle. (Not use if rotationQuaternion is set)
         */
        rotation: Vector3;
        /**
         * The world space rotation quaternion of the particle.
         */
        rotationQuaternion: Nullable<Quaternion>;
        /**
         * The scaling of the particle.
         */
        scaling: Vector3;
        /**
         * The uvs of the particle.
         */
        uvs: Vector4;
        /**
         * The current speed of the particle.
         */
        velocity: Vector3;
        /**
         * The pivot point in the particle local space.
         */
        pivot: Vector3;
        /**
         * Must the particle be translated from its pivot point in its local space ?
         * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.
         * Default : false
         */
        translateFromPivot: boolean;
        /**
         * Is the particle active or not ?
         */
        alive: boolean;
        /**
         * Is the particle visible or not ?
         */
        isVisible: boolean;
        /**
         * Index of this particle in the global "positions" array (Internal use)
         * @hidden
         */
        _pos: number;
        /**
         * @hidden Index of this particle in the global "indices" array (Internal use)
         */
        _ind: number;
        /**
         * @hidden ModelShape of this particle (Internal use)
         */
        _model: ModelShape;
        /**
         * ModelShape id of this particle
         */
        shapeId: number;
        /**
         * Index of the particle in its shape id
         */
        idxInShape: number;
        /**
         * @hidden Reference to the shape model BoundingInfo object (Internal use)
         */
        _modelBoundingInfo: BoundingInfo;
        /**
         * @hidden Particle BoundingInfo object (Internal use)
         */
        _boundingInfo: BoundingInfo;
        /**
         * @hidden Reference to the SPS what the particle belongs to (Internal use)
         */
        _sps: SolidParticleSystem;
        /**
         * @hidden Still set as invisible in order to skip useless computations (Internal use)
         */
        _stillInvisible: boolean;
        /**
         * @hidden Last computed particle rotation matrix
         */
        _rotationMatrix: number[];
        /**
         * Parent particle Id, if any.
         * Default null.
         */
        parentId: Nullable<number>;
        /**
         * The particle material identifier (integer) when MultiMaterials are enabled in the SPS.
         */
        materialIndex: Nullable<number>;
        /**
         * Custom object or properties.
         */
        props: Nullable<any>;
        /**
         * The culling strategy to use to check whether the solid particle must be culled or not when using isInFrustum().
         * The possible values are :
         * - AbstractMesh.CULLINGSTRATEGY_STANDARD
         * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY
         * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION
         * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY
         * The default value for solid particles is AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY
         * Please read each static variable documentation in the class AbstractMesh to get details about the culling process.
         * */
        cullingStrategy: number;
        /**
         * @hidden Internal global position in the SPS.
         */
        _globalPosition: Vector3;
        /**
         * Creates a Solid Particle object.
         * Don't create particles manually, use instead the Solid Particle System internal tools like _addParticle()
         * @param particleIndex (integer) is the particle index in the Solid Particle System pool.
         * @param particleId (integer) is the particle identifier. Unless some particles are removed from the SPS, it's the same value than the particle idx.
         * @param positionIndex (integer) is the starting index of the particle vertices in the SPS "positions" array.
         * @param indiceIndex (integer) is the starting index of the particle indices in the SPS "indices" array.
         * @param model (ModelShape) is a reference to the model shape on what the particle is designed.
         * @param shapeId (integer) is the model shape identifier in the SPS.
         * @param idxInShape (integer) is the index of the particle in the current model (ex: the 10th box of addShape(box, 30))
         * @param sps defines the sps it is associated to
         * @param modelBoundingInfo is the reference to the model BoundingInfo used for intersection computations.
         * @param materialIndex is the particle material identifier (integer) when the MultiMaterials are enabled in the SPS.
         */
        constructor(particleIndex: number, particleId: number, positionIndex: number, indiceIndex: number, model: Nullable<ModelShape>, shapeId: number, idxInShape: number, sps: SolidParticleSystem, modelBoundingInfo?: Nullable<BoundingInfo>, materialIndex?: Nullable<number>);
        /**
         * Copies the particle property values into the existing target : position, rotation, scaling, uvs, colors, pivot, parent, visibility, alive
         * @param target the particle target
         * @returns the current particle
         */
        copyToRef(target: SolidParticle): SolidParticle;
        /**
         * Legacy support, changed scale to scaling
         */
        get scale(): Vector3;
        /**
         * Legacy support, changed scale to scaling
         */
        set scale(scale: Vector3);
        /**
         * Legacy support, changed quaternion to rotationQuaternion
         */
        get quaternion(): Nullable<Quaternion>;
        /**
         * Legacy support, changed quaternion to rotationQuaternion
         */
        set quaternion(q: Nullable<Quaternion>);
        /**
         * Returns a boolean. True if the particle intersects another particle or another mesh, else false.
         * The intersection is computed on the particle bounding sphere and Axis Aligned Bounding Box (AABB)
         * @param target is the object (solid particle or mesh) what the intersection is computed against.
         * @returns true if it intersects
         */
        intersectsMesh(target: Mesh | SolidParticle): boolean;
        /**
         * Returns `true` if the solid particle is within the frustum defined by the passed array of planes.
         * A particle is in the frustum if its bounding box intersects the frustum
         * @param frustumPlanes defines the frustum to test
         * @returns true if the particle is in the frustum planes
         */
        isInFrustum(frustumPlanes: Plane[]): boolean;
        /**
         * get the rotation matrix of the particle
         * @hidden
         */
        getRotationMatrix(m: Matrix): void;
    }
    /**
     * Represents the shape of the model used by one particle of a solid particle system.
     * SPS internal tool, don't use it manually.
     */
    export class ModelShape {
        /**
         * The shape id
         * @hidden
         */
        shapeID: number;
        /**
         * flat array of model positions (internal use)
         * @hidden
         */
        _shape: Vector3[];
        /**
         * flat array of model UVs (internal use)
         * @hidden
         */
        _shapeUV: number[];
        /**
         * color array of the model
         * @hidden
         */
        _shapeColors: number[];
        /**
         * indices array of the model
         * @hidden
         */
        _indices: number[];
        /**
         * normals array of the model
         * @hidden
         */
        _normals: number[];
        /**
         * length of the shape in the model indices array (internal use)
         * @hidden
         */
        _indicesLength: number;
        /**
         * Custom position function (internal use)
         * @hidden
         */
        _positionFunction: Nullable<(particle: SolidParticle, i: number, s: number) => void>;
        /**
         * Custom vertex function (internal use)
         * @hidden
         */
        _vertexFunction: Nullable<(particle: SolidParticle, vertex: Vector3, i: number) => void>;
        /**
         * Model material (internal use)
         * @hidden
         */
        _material: Nullable<Material>;
        /**
         * Creates a ModelShape object. This is an internal simplified reference to a mesh used as for a model to replicate particles from by the SPS.
         * SPS internal tool, don't use it manually.
         * @hidden
         */
        constructor(id: number, shape: Vector3[], indices: number[], normals: number[], colors: number[], shapeUV: number[], posFunction: Nullable<(particle: SolidParticle, i: number, s: number) => void>, vtxFunction: Nullable<(particle: SolidParticle, vertex: Vector3, i: number) => void>, material: Nullable<Material>);
    }
    /**
     * Represents a Depth Sorted Particle in the solid particle system.
     * @hidden
     */
    export class DepthSortedParticle {
        /**
         * Particle index
         */
        idx: number;
        /**
         * Index of the particle in the "indices" array
         */
        ind: number;
        /**
         * Length of the particle shape in the "indices" array
         */
        indicesLength: number;
        /**
         * Squared distance from the particle to the camera
         */
        sqDistance: number;
        /**
         * Material index when used with MultiMaterials
         */
        materialIndex: number;
        /**
         * Creates a new sorted particle
         * @param materialIndex
         */
        constructor(idx: number, ind: number, indLength: number, materialIndex: number);
    }
    /**
     * Represents a solid particle vertex
     */
    export class SolidParticleVertex {
        /**
         * Vertex position
         */
        position: Vector3;
        /**
         * Vertex color
         */
        color: Color4;
        /**
         * Vertex UV
         */
        uv: Vector2;
        /**
         * Creates a new solid particle vertex
         */
        constructor();
        /** Vertex x coordinate */
        get x(): number;
        set x(val: number);
        /** Vertex y coordinate */
        get y(): number;
        set y(val: number);
        /** Vertex z coordinate */
        get z(): number;
        set z(val: number);
    }
}
declare module BABYLON {
    /**
     * @hidden
     */
    export class _MeshCollisionData {
        _checkCollisions: boolean;
        _collisionMask: number;
        _collisionGroup: number;
        _surroundingMeshes: Nullable<AbstractMesh[]>;
        _collider: Nullable<Collider>;
        _oldPositionForCollisions: Vector3;
        _diffPositionForCollisions: Vector3;
        _onCollideObserver: Nullable<Observer<AbstractMesh>>;
        _onCollisionPositionChangeObserver: Nullable<Observer<Vector3>>;
        _collisionResponse: boolean;
    }
}
declare module BABYLON {
    /** @hidden */
    class _FacetDataStorage {
        facetPositions: Vector3[];
        facetNormals: Vector3[];
        facetPartitioning: number[][];
        facetNb: number;
        partitioningSubdivisions: number;
        partitioningBBoxRatio: number;
        facetDataEnabled: boolean;
        facetParameters: any;
        bbSize: Vector3;
        subDiv: {
            max: number;
            X: number;
            Y: number;
            Z: number;
        };
        facetDepthSort: boolean;
        facetDepthSortEnabled: boolean;
        depthSortedIndices: IndicesArray;
        depthSortedFacets: {
            ind: number;
            sqDistance: number;
        }[];
        facetDepthSortFunction: (f1: {
            ind: number;
            sqDistance: number;
        }, f2: {
            ind: number;
            sqDistance: number;
        }) => number;
        facetDepthSortFrom: Vector3;
        facetDepthSortOrigin: Vector3;
        invertedMatrix: Matrix;
    }
    /**
     * @hidden
     **/
    class _InternalAbstractMeshDataInfo {
        _hasVertexAlpha: boolean;
        _useVertexColors: boolean;
        _numBoneInfluencers: number;
        _applyFog: boolean;
        _receiveShadows: boolean;
        _facetData: _FacetDataStorage;
        _visibility: number;
        _skeleton: Nullable<Skeleton>;
        _layerMask: number;
        _computeBonesUsingShaders: boolean;
        _isActive: boolean;
        _onlyForInstances: boolean;
        _isActiveIntermediate: boolean;
        _onlyForInstancesIntermediate: boolean;
        _actAsRegularMesh: boolean;
    }
    /**
     * Class used to store all common mesh properties
     */
    export class AbstractMesh extends TransformNode implements IDisposable, ICullable, IGetSetVerticesData {
        /** No occlusion */
        static OCCLUSION_TYPE_NONE: number;
        /** Occlusion set to optimisitic */
        static OCCLUSION_TYPE_OPTIMISTIC: number;
        /** Occlusion set to strict */
        static OCCLUSION_TYPE_STRICT: number;
        /** Use an accurante occlusion algorithm */
        static OCCLUSION_ALGORITHM_TYPE_ACCURATE: number;
        /** Use a conservative occlusion algorithm */
        static OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE: number;
        /** Default culling strategy : this is an exclusion test and it's the more accurate.
         *  Test order :
         *  Is the bounding sphere outside the frustum ?
         *  If not, are the bounding box vertices outside the frustum ?
         *  It not, then the cullable object is in the frustum.
         */
        static readonly CULLINGSTRATEGY_STANDARD: number;
        /** Culling strategy : Bounding Sphere Only.
         *  This is an exclusion test. It's faster than the standard strategy because the bounding box is not tested.
         *  It's also less accurate than the standard because some not visible objects can still be selected.
         *  Test : is the bounding sphere outside the frustum ?
         *  If not, then the cullable object is in the frustum.
         */
        static readonly CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY: number;
        /** Culling strategy : Optimistic Inclusion.
         *  This in an inclusion test first, then the standard exclusion test.
         *  This can be faster when a cullable object is expected to be almost always in the camera frustum.
         *  This could also be a little slower than the standard test when the tested object center is not the frustum but one of its bounding box vertex is still inside.
         *  Anyway, it's as accurate as the standard strategy.
         *  Test :
         *  Is the cullable object bounding sphere center in the frustum ?
         *  If not, apply the default culling strategy.
         */
        static readonly CULLINGSTRATEGY_OPTIMISTIC_INCLUSION: number;
        /** Culling strategy : Optimistic Inclusion then Bounding Sphere Only.
         *  This in an inclusion test first, then the bounding sphere only exclusion test.
         *  This can be the fastest test when a cullable object is expected to be almost always in the camera frustum.
         *  This could also be a little slower than the BoundingSphereOnly strategy when the tested object center is not in the frustum but its bounding sphere still intersects it.
         *  It's less accurate than the standard strategy and as accurate as the BoundingSphereOnly strategy.
         *  Test :
         *  Is the cullable object bounding sphere center in the frustum ?
         *  If not, apply the Bounding Sphere Only strategy. No Bounding Box is tested here.
         */
        static readonly CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY: number;
        /**
         * No billboard
         */
        static get BILLBOARDMODE_NONE(): number;
        /** Billboard on X axis */
        static get BILLBOARDMODE_X(): number;
        /** Billboard on Y axis */
        static get BILLBOARDMODE_Y(): number;
        /** Billboard on Z axis */
        static get BILLBOARDMODE_Z(): number;
        /** Billboard on all axes */
        static get BILLBOARDMODE_ALL(): number;
        /** Billboard on using position instead of orientation */
        static get BILLBOARDMODE_USE_POSITION(): number;
        /** @hidden */
        _internalAbstractMeshDataInfo: _InternalAbstractMeshDataInfo;
        /**
         * The culling strategy to use to check whether the mesh must be rendered or not.
         * This value can be changed at any time and will be used on the next render mesh selection.
         * The possible values are :
         * - AbstractMesh.CULLINGSTRATEGY_STANDARD
         * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY
         * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION
         * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY
         * Please read each static variable documentation to get details about the culling process.
         * */
        cullingStrategy: number;
        /**
         * Gets the number of facets in the mesh
         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet
         */
        get facetNb(): number;
        /**
         * Gets or set the number (integer) of subdivisions per axis in the partioning space
         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning
         */
        get partitioningSubdivisions(): number;
        set partitioningSubdivisions(nb: number);
        /**
         * The ratio (float) to apply to the bouding box size to set to the partioning space.
         * Ex : 1.01 (default) the partioning space is 1% bigger than the bounding box
         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning
         */
        get partitioningBBoxRatio(): number;
        set partitioningBBoxRatio(ratio: number);
        /**
         * Gets or sets a boolean indicating that the facets must be depth sorted on next call to `updateFacetData()`.
         * Works only for updatable meshes.
         * Doesn't work with multi-materials
         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort
         */
        get mustDepthSortFacets(): boolean;
        set mustDepthSortFacets(sort: boolean);
        /**
         * The location (Vector3) where the facet depth sort must be computed from.
         * By default, the active camera position.
         * Used only when facet depth sort is enabled
         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort
         */
        get facetDepthSortFrom(): Vector3;
        set facetDepthSortFrom(location: Vector3);
        /**
         * gets a boolean indicating if facetData is enabled
         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet
         */
        get isFacetDataEnabled(): boolean;
        /** @hidden */
        _updateNonUniformScalingState(value: boolean): boolean;
        /**
        * An event triggered when this mesh collides with another one
        */
        onCollideObservable: Observable<AbstractMesh>;
        /** Set a function to call when this mesh collides with another one */
        set onCollide(callback: () => void);
        /**
        * An event triggered when the collision's position changes
        */
        onCollisionPositionChangeObservable: Observable<Vector3>;
        /** Set a function to call when the collision's position changes */
        set onCollisionPositionChange(callback: () => void);
        /**
        * An event triggered when material is changed
        */
        onMaterialChangedObservable: Observable<AbstractMesh>;
        /**
         * Gets or sets the orientation for POV movement & rotation
         */
        definedFacingForward: boolean;
        /** @hidden */
        _occlusionQuery: Nullable<WebGLQuery>;
        /** @hidden */
        _renderingGroup: Nullable<RenderingGroup>;
        /**
         * Gets or sets mesh visibility between 0 and 1 (default is 1)
         */
        get visibility(): number;
        /**
         * Gets or sets mesh visibility between 0 and 1 (default is 1)
         */
        set visibility(value: number);
        /** Gets or sets the alpha index used to sort transparent meshes
         * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#alpha-index
         */
        alphaIndex: number;
        /**
         * Gets or sets a boolean indicating if the mesh is visible (renderable). Default is true
         */
        isVisible: boolean;
        /**
         * Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true
         */
        isPickable: boolean;
        /** Gets or sets a boolean indicating that bounding boxes of subMeshes must be rendered as well (false by default) */
        showSubMeshesBoundingBox: boolean;
        /** Gets or sets a boolean indicating if the mesh must be considered as a ray blocker for lens flares (false by default)
         * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares
         */
        isBlocker: boolean;
        /**
         * Gets or sets a boolean indicating that pointer move events must be supported on this mesh (false by default)
         */
        enablePointerMoveEvents: boolean;
        private _renderingGroupId;
        /**
         * Specifies the rendering group id for this mesh (0 by default)
         * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#rendering-groups
         */
        get renderingGroupId(): number;
        set renderingGroupId(value: number);
        private _material;
        /** Gets or sets current material */
        get material(): Nullable<Material>;
        set material(value: Nullable<Material>);
        /**
         * Gets or sets a boolean indicating that this mesh can receive realtime shadows
         * @see https://doc.babylonjs.com/babylon101/shadows
         */
        get receiveShadows(): boolean;
        set receiveShadows(value: boolean);
        /** Defines color to use when rendering outline */
        outlineColor: Color3;
        /** Define width to use when rendering outline */
        outlineWidth: number;
        /** Defines color to use when rendering overlay */
        overlayColor: Color3;
        /** Defines alpha to use when rendering overlay */
        overlayAlpha: number;
        /** Gets or sets a boolean indicating that this mesh contains vertex color data with alpha values */
        get hasVertexAlpha(): boolean;
        set hasVertexAlpha(value: boolean);
        /** Gets or sets a boolean indicating that this mesh needs to use vertex color data to render (if this kind of vertex data is available in the geometry) */
        get useVertexColors(): boolean;
        set useVertexColors(value: boolean);
        /**
         * Gets or sets a boolean indicating that bone animations must be computed by the CPU (false by default)
         */
        get computeBonesUsingShaders(): boolean;
        set computeBonesUsingShaders(value: boolean);
        /** Gets or sets the number of allowed bone influences per vertex (4 by default) */
        get numBoneInfluencers(): number;
        set numBoneInfluencers(value: number);
        /** Gets or sets a boolean indicating that this mesh will allow fog to be rendered on it (true by default) */
        get applyFog(): boolean;
        set applyFog(value: boolean);
        /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes selection (true by default) */
        useOctreeForRenderingSelection: boolean;
        /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes picking (true by default) */
        useOctreeForPicking: boolean;
        /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes collision (true by default) */
        useOctreeForCollisions: boolean;
        /**
         * Gets or sets the current layer mask (default is 0x0FFFFFFF)
         * @see https://doc.babylonjs.com/how_to/layermasks_and_multi-cam_textures
         */
        get layerMask(): number;
        set layerMask(value: number);
        /**
         * True if the mesh must be rendered in any case (this will shortcut the frustum clipping phase)
         */
        alwaysSelectAsActiveMesh: boolean;
        /**
         * Gets or sets a boolean indicating that the bounding info does not need to be kept in sync (for performance reason)
         */
        doNotSyncBoundingInfo: boolean;
        /**
         * Gets or sets the current action manager
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions
         */
        actionManager: Nullable<AbstractActionManager>;
        private _meshCollisionData;
        /**
         * Gets or sets the ellipsoid used to impersonate this mesh when using collision engine (default is (0.5, 1, 0.5))
         * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
         */
        ellipsoid: Vector3;
        /**
         * Gets or sets the ellipsoid offset used to impersonate this mesh when using collision engine (default is (0, 0, 0))
         * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
         */
        ellipsoidOffset: Vector3;
        /**
         * Gets or sets a collision mask used to mask collisions (default is -1).
         * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0
         */
        get collisionMask(): number;
        set collisionMask(mask: number);
        /**
         * Gets or sets a collision response flag (default is true).
         * when collisionResponse is false, events are still triggered but colliding entity has no response
         * This helps creating trigger volume when user wants collision feedback events but not position/velocity
         * to respond to the collision.
         */
        get collisionResponse(): boolean;
        set collisionResponse(response: boolean);
        /**
         * Gets or sets the current collision group mask (-1 by default).
         * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0
         */
        get collisionGroup(): number;
        set collisionGroup(mask: number);
        /**
         * Gets or sets current surrounding meshes (null by default).
         *
         * By default collision detection is tested against every mesh in the scene.
         * It is possible to set surroundingMeshes to a defined list of meshes and then only these specified
         * meshes will be tested for the collision.
         *
         * Note: if set to an empty array no collision will happen when this mesh is moved.
         */
        get surroundingMeshes(): Nullable<AbstractMesh[]>;
        set surroundingMeshes(meshes: Nullable<AbstractMesh[]>);
        /**
         * Defines edge width used when edgesRenderer is enabled
         * @see https://www.babylonjs-playground.com/#10OJSG#13
         */
        edgesWidth: number;
        /**
         * Defines edge color used when edgesRenderer is enabled
         * @see https://www.babylonjs-playground.com/#10OJSG#13
         */
        edgesColor: Color4;
        /** @hidden */
        _edgesRenderer: Nullable<IEdgesRenderer>;
        /** @hidden */
        _masterMesh: Nullable<AbstractMesh>;
        /** @hidden */
        _boundingInfo: Nullable<BoundingInfo>;
        /** @hidden */
        _renderId: number;
        /**
         * Gets or sets the list of subMeshes
         * @see https://doc.babylonjs.com/how_to/multi_materials
         */
        subMeshes: SubMesh[];
        /** @hidden */
        _intersectionsInProgress: AbstractMesh[];
        /** @hidden */
        _unIndexed: boolean;
        /** @hidden */
        _lightSources: Light[];
        /** Gets the list of lights affecting that mesh */
        get lightSources(): Light[];
        /** @hidden */
        get _positions(): Nullable<Vector3[]>;
        /** @hidden */
        _waitingData: {
            lods: Nullable<any>;
            actions: Nullable<any>;
            freezeWorldMatrix: Nullable<boolean>;
        };
        /** @hidden */
        _bonesTransformMatrices: Nullable<Float32Array>;
        /** @hidden */
        _transformMatrixTexture: Nullable<RawTexture>;
        /**
         * Gets or sets a skeleton to apply skining transformations
         * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons
         */
        set skeleton(value: Nullable<Skeleton>);
        get skeleton(): Nullable<Skeleton>;
        /**
         * An event triggered when the mesh is rebuilt.
         */
        onRebuildObservable: Observable<AbstractMesh>;
        /**
         * Creates a new AbstractMesh
         * @param name defines the name of the mesh
         * @param scene defines the hosting scene
         */
        constructor(name: string, scene?: Nullable<Scene>);
        /**
         * Returns the string "AbstractMesh"
         * @returns "AbstractMesh"
         */
        getClassName(): string;
        /**
         * Gets a string representation of the current mesh
         * @param fullDetails defines a boolean indicating if full details must be included
         * @returns a string representation of the current mesh
         */
        toString(fullDetails?: boolean): string;
        /**
         * @hidden
         */
        protected _getEffectiveParent(): Nullable<Node>;
        /** @hidden */
        _getActionManagerForTrigger(trigger?: number, initialCall?: boolean): Nullable<AbstractActionManager>;
        /** @hidden */
        _rebuild(): void;
        /** @hidden */
        _resyncLightSources(): void;
        /** @hidden */
        _resyncLightSource(light: Light): void;
        /** @hidden */
        _unBindEffect(): void;
        /** @hidden */
        _removeLightSource(light: Light, dispose: boolean): void;
        private _markSubMeshesAsDirty;
        /** @hidden */
        _markSubMeshesAsLightDirty(dispose?: boolean): void;
        /** @hidden */
        _markSubMeshesAsAttributesDirty(): void;
        /** @hidden */
        _markSubMeshesAsMiscDirty(): void;
        /**
        * Gets or sets a Vector3 depicting the mesh scaling along each local axis X, Y, Z.  Default is (1.0, 1.0, 1.0)
        */
        get scaling(): Vector3;
        set scaling(newScaling: Vector3);
        /**
         * Returns true if the mesh is blocked. Implemented by child classes
         */
        get isBlocked(): boolean;
        /**
         * Returns the mesh itself by default. Implemented by child classes
         * @param camera defines the camera to use to pick the right LOD level
         * @returns the currentAbstractMesh
         */
        getLOD(camera: Camera): Nullable<AbstractMesh>;
        /**
         * Returns 0 by default. Implemented by child classes
         * @returns an integer
         */
        getTotalVertices(): number;
        /**
         * Returns a positive integer : the total number of indices in this mesh geometry.
         * @returns the numner of indices or zero if the mesh has no geometry.
         */
        getTotalIndices(): number;
        /**
         * Returns null by default. Implemented by child classes
         * @returns null
         */
        getIndices(): Nullable<IndicesArray>;
        /**
         * Returns the array of the requested vertex data kind. Implemented by child classes
         * @param kind defines the vertex data kind to use
         * @returns null
         */
        getVerticesData(kind: string): Nullable<FloatArray>;
        /**
         * Sets the vertex data of the mesh geometry for the requested `kind`.
         * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
         * Note that a new underlying VertexBuffer object is created each call.
         * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
         * @param kind defines vertex data kind:
         * * VertexBuffer.PositionKind
         * * VertexBuffer.UVKind
         * * VertexBuffer.UV2Kind
         * * VertexBuffer.UV3Kind
         * * VertexBuffer.UV4Kind
         * * VertexBuffer.UV5Kind
         * * VertexBuffer.UV6Kind
         * * VertexBuffer.ColorKind
         * * VertexBuffer.MatricesIndicesKind
         * * VertexBuffer.MatricesIndicesExtraKind
         * * VertexBuffer.MatricesWeightsKind
         * * VertexBuffer.MatricesWeightsExtraKind
         * @param data defines the data source
         * @param updatable defines if the data must be flagged as updatable (or static)
         * @param stride defines the vertex stride (size of an entire vertex). Can be null and in this case will be deduced from vertex data kind
         * @returns the current mesh
         */
        setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh;
        /**
         * Updates the existing vertex data of the mesh geometry for the requested `kind`.
         * If the mesh has no geometry, it is simply returned as it is.
         * @param kind defines vertex data kind:
         * * VertexBuffer.PositionKind
         * * VertexBuffer.UVKind
         * * VertexBuffer.UV2Kind
         * * VertexBuffer.UV3Kind
         * * VertexBuffer.UV4Kind
         * * VertexBuffer.UV5Kind
         * * VertexBuffer.UV6Kind
         * * VertexBuffer.ColorKind
         * * VertexBuffer.MatricesIndicesKind
         * * VertexBuffer.MatricesIndicesExtraKind
         * * VertexBuffer.MatricesWeightsKind
         * * VertexBuffer.MatricesWeightsExtraKind
         * @param data defines the data source
         * @param updateExtends If `kind` is `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed
         * @param makeItUnique If true, a new global geometry is created from this data and is set to the mesh
         * @returns the current mesh
         */
        updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): AbstractMesh;
        /**
         * Sets the mesh indices,
         * If the mesh has no geometry, a new Geometry object is created and set to the mesh.
         * @param indices Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array)
         * @param totalVertices Defines the total number of vertices
         * @returns the current mesh
         */
        setIndices(indices: IndicesArray, totalVertices: Nullable<number>): AbstractMesh;
        /**
         * Gets a boolean indicating if specific vertex data is present
         * @param kind defines the vertex data kind to use
         * @returns true is data kind is present
         */
        isVerticesDataPresent(kind: string): boolean;
        /**
         * Returns the mesh BoundingInfo object or creates a new one and returns if it was undefined.
         * Note that it returns a shallow bounding of the mesh (i.e. it does not include children).
         * To get the full bounding of all children, call `getHierarchyBoundingVectors` instead.
         * @returns a BoundingInfo
         */
        getBoundingInfo(): BoundingInfo;
        /**
         * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)
         * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false
         * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false
         * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling
         * @returns the current mesh
         */
        normalizeToUnitCube(includeDescendants?: boolean, ignoreRotation?: boolean, predicate?: Nullable<(node: AbstractMesh) => boolean>): AbstractMesh;
        /**
         * Overwrite the current bounding info
         * @param boundingInfo defines the new bounding info
         * @returns the current mesh
         */
        setBoundingInfo(boundingInfo: BoundingInfo): AbstractMesh;
        /** Gets a boolean indicating if this mesh has skinning data and an attached skeleton */
        get useBones(): boolean;
        /** @hidden */
        _preActivate(): void;
        /** @hidden */
        _preActivateForIntermediateRendering(renderId: number): void;
        /** @hidden */
        _activate(renderId: number, intermediateRendering: boolean): boolean;
        /** @hidden */
        _postActivate(): void;
        /** @hidden */
        _freeze(): void;
        /** @hidden */
        _unFreeze(): void;
        /**
         * Gets the current world matrix
         * @returns a Matrix
         */
        getWorldMatrix(): Matrix;
        /** @hidden */
        _getWorldMatrixDeterminant(): number;
        /**
         * Gets a boolean indicating if this mesh is an instance or a regular mesh
         */
        get isAnInstance(): boolean;
        /**
         * Gets a boolean indicating if this mesh has instances
         */
        get hasInstances(): boolean;
        /**
         * Gets a boolean indicating if this mesh has thin instances
         */
        get hasThinInstances(): boolean;
        /**
         * Perform relative position change from the point of view of behind the front of the mesh.
         * This is performed taking into account the meshes current rotation, so you do not have to care.
         * Supports definition of mesh facing forward or backward
         * @param amountRight defines the distance on the right axis
         * @param amountUp defines the distance on the up axis
         * @param amountForward defines the distance on the forward axis
         * @returns the current mesh
         */
        movePOV(amountRight: number, amountUp: number, amountForward: number): AbstractMesh;
        /**
         * Calculate relative position change from the point of view of behind the front of the mesh.
         * This is performed taking into account the meshes current rotation, so you do not have to care.
         * Supports definition of mesh facing forward or backward
         * @param amountRight defines the distance on the right axis
         * @param amountUp defines the distance on the up axis
         * @param amountForward defines the distance on the forward axis
         * @returns the new displacement vector
         */
        calcMovePOV(amountRight: number, amountUp: number, amountForward: number): Vector3;
        /**
         * Perform relative rotation change from the point of view of behind the front of the mesh.
         * Supports definition of mesh facing forward or backward
         * @param flipBack defines the flip
         * @param twirlClockwise defines the twirl
         * @param tiltRight defines the tilt
         * @returns the current mesh
         */
        rotatePOV(flipBack: number, twirlClockwise: number, tiltRight: number): AbstractMesh;
        /**
         * Calculate relative rotation change from the point of view of behind the front of the mesh.
         * Supports definition of mesh facing forward or backward.
         * @param flipBack defines the flip
         * @param twirlClockwise defines the twirl
         * @param tiltRight defines the tilt
         * @returns the new rotation vector
         */
        calcRotatePOV(flipBack: number, twirlClockwise: number, tiltRight: number): Vector3;
        /**
         * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.
         * This means the mesh underlying bounding box and sphere are recomputed.
         * @param applySkeleton defines whether to apply the skeleton before computing the bounding info
         * @returns the current mesh
         */
        refreshBoundingInfo(applySkeleton?: boolean): AbstractMesh;
        /** @hidden */
        _refreshBoundingInfo(data: Nullable<FloatArray>, bias: Nullable<Vector2>): void;
        /** @hidden */
        _getPositionData(applySkeleton: boolean): Nullable<FloatArray>;
        /** @hidden */
        _updateBoundingInfo(): AbstractMesh;
        /** @hidden */
        _updateSubMeshesBoundingInfo(matrix: DeepImmutable<Matrix>): AbstractMesh;
        /** @hidden */
        protected _afterComputeWorldMatrix(): void;
        /** @hidden */
        get _effectiveMesh(): AbstractMesh;
        /**
         * Returns `true` if the mesh is within the frustum defined by the passed array of planes.
         * A mesh is in the frustum if its bounding box intersects the frustum
         * @param frustumPlanes defines the frustum to test
         * @returns true if the mesh is in the frustum planes
         */
        isInFrustum(frustumPlanes: Plane[]): boolean;
        /**
         * Returns `true` if the mesh is completely in the frustum defined be the passed array of planes.
         * A mesh is completely in the frustum if its bounding box it completely inside the frustum.
         * @param frustumPlanes defines the frustum to test
         * @returns true if the mesh is completely in the frustum planes
         */
        isCompletelyInFrustum(frustumPlanes: Plane[]): boolean;
        /**
         * True if the mesh intersects another mesh or a SolidParticle object
         * @param mesh defines a target mesh or SolidParticle to test
         * @param precise Unless the parameter `precise` is set to `true` the intersection is computed according to Axis Aligned Bounding Boxes (AABB), else according to OBB (Oriented BBoxes)
         * @param includeDescendants Can be set to true to test if the mesh defined in parameters intersects with the current mesh or any child meshes
         * @returns true if there is an intersection
         */
        intersectsMesh(mesh: AbstractMesh | SolidParticle, precise?: boolean, includeDescendants?: boolean): boolean;
        /**
         * Returns true if the passed point (Vector3) is inside the mesh bounding box
         * @param point defines the point to test
         * @returns true if there is an intersection
         */
        intersectsPoint(point: Vector3): boolean;
        /**
         * Gets or sets a boolean indicating that this mesh can be used in the collision engine
         * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
         */
        get checkCollisions(): boolean;
        set checkCollisions(collisionEnabled: boolean);
        /**
         * Gets Collider object used to compute collisions (not physics)
         * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
         */
        get collider(): Nullable<Collider>;
        /**
         * Move the mesh using collision engine
         * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
         * @param displacement defines the requested displacement vector
         * @returns the current mesh
         */
        moveWithCollisions(displacement: Vector3): AbstractMesh;
        private _onCollisionPositionChange;
        /** @hidden */
        _collideForSubMesh(subMesh: SubMesh, transformMatrix: Matrix, collider: Collider): AbstractMesh;
        /** @hidden */
        _processCollisionsForSubMeshes(collider: Collider, transformMatrix: Matrix): AbstractMesh;
        /** @hidden */
        _checkCollision(collider: Collider): AbstractMesh;
        /** @hidden */
        _generatePointsArray(): boolean;
        /**
         * Checks if the passed Ray intersects with the mesh
         * @param ray defines the ray to use
         * @param fastCheck defines if fast mode (but less precise) must be used (false by default)
         * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
         * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)
         * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point
         * @returns the picking info
         * @see https://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh
         */
        intersects(ray: Ray, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate, onlyBoundingInfo?: boolean, worldToUse?: Matrix): PickingInfo;
        /**
         * Clones the current mesh
         * @param name defines the mesh name
         * @param newParent defines the new mesh parent
         * @param doNotCloneChildren defines a boolean indicating that children must not be cloned (false by default)
         * @returns the new mesh
         */
        clone(name: string, newParent: Nullable<Node>, doNotCloneChildren?: boolean): Nullable<AbstractMesh>;
        /**
         * Disposes all the submeshes of the current meshnp
         * @returns the current mesh
         */
        releaseSubMeshes(): AbstractMesh;
        /**
         * Releases resources associated with this abstract mesh.
         * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
         * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
         */
        dispose(doNotRecurse?: boolean, disposeMaterialAndTextures?: boolean): void;
        /**
         * Adds the passed mesh as a child to the current mesh
         * @param mesh defines the child mesh
         * @returns the current mesh
         */
        addChild(mesh: AbstractMesh): AbstractMesh;
        /**
         * Removes the passed mesh from the current mesh children list
         * @param mesh defines the child mesh
         * @returns the current mesh
         */
        removeChild(mesh: AbstractMesh): AbstractMesh;
        /** @hidden */
        private _initFacetData;
        /**
         * Updates the mesh facetData arrays and the internal partitioning when the mesh is morphed or updated.
         * This method can be called within the render loop.
         * You don't need to call this method by yourself in the render loop when you update/morph a mesh with the methods CreateXXX() as they automatically manage this computation
         * @returns the current mesh
         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        updateFacetData(): AbstractMesh;
        /**
         * Returns the facetLocalNormals array.
         * The normals are expressed in the mesh local spac
         * @returns an array of Vector3
         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getFacetLocalNormals(): Vector3[];
        /**
         * Returns the facetLocalPositions array.
         * The facet positions are expressed in the mesh local space
         * @returns an array of Vector3
         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getFacetLocalPositions(): Vector3[];
        /**
         * Returns the facetLocalPartioning array
         * @returns an array of array of numbers
         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getFacetLocalPartitioning(): number[][];
        /**
         * Returns the i-th facet position in the world system.
         * This method allocates a new Vector3 per call
         * @param i defines the facet index
         * @returns a new Vector3
         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getFacetPosition(i: number): Vector3;
        /**
         * Sets the reference Vector3 with the i-th facet position in the world system
         * @param i defines the facet index
         * @param ref defines the target vector
         * @returns the current mesh
         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getFacetPositionToRef(i: number, ref: Vector3): AbstractMesh;
        /**
         * Returns the i-th facet normal in the world system.
         * This method allocates a new Vector3 per call
         * @param i defines the facet index
         * @returns a new Vector3
         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getFacetNormal(i: number): Vector3;
        /**
         * Sets the reference Vector3 with the i-th facet normal in the world system
         * @param i defines the facet index
         * @param ref defines the target vector
         * @returns the current mesh
         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getFacetNormalToRef(i: number, ref: Vector3): this;
        /**
         * Returns the facets (in an array) in the same partitioning block than the one the passed coordinates are located (expressed in the mesh local system)
         * @param x defines x coordinate
         * @param y defines y coordinate
         * @param z defines z coordinate
         * @returns the array of facet indexes
         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getFacetsAtLocalCoordinates(x: number, y: number, z: number): Nullable<number[]>;
        /**
         * Returns the closest mesh facet index at (x,y,z) World coordinates, null if not found
         * @param projected sets as the (x,y,z) world projection on the facet
         * @param checkFace if true (default false), only the facet "facing" to (x,y,z) or only the ones "turning their backs", according to the parameter "facing" are returned
         * @param facing if facing and checkFace are true, only the facet "facing" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet "turning their backs" to (x, y, z) are returned : negative dot (x, y, z) * facet position
         * @param x defines x coordinate
         * @param y defines y coordinate
         * @param z defines z coordinate
         * @returns the face index if found (or null instead)
         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getClosestFacetAtCoordinates(x: number, y: number, z: number, projected?: Vector3, checkFace?: boolean, facing?: boolean): Nullable<number>;
        /**
         * Returns the closest mesh facet index at (x,y,z) local coordinates, null if not found
         * @param projected sets as the (x,y,z) local projection on the facet
         * @param checkFace if true (default false), only the facet "facing" to (x,y,z) or only the ones "turning their backs", according to the parameter "facing" are returned
         * @param facing if facing and checkFace are true, only the facet "facing" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet "turning their backs" to (x, y, z) are returned : negative dot (x, y, z) * facet position
         * @param x defines x coordinate
         * @param y defines y coordinate
         * @param z defines z coordinate
         * @returns the face index if found (or null instead)
         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getClosestFacetAtLocalCoordinates(x: number, y: number, z: number, projected?: Vector3, checkFace?: boolean, facing?: boolean): Nullable<number>;
        /**
         * Returns the object "parameter" set with all the expected parameters for facetData computation by ComputeNormals()
         * @returns the parameters
         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getFacetDataParameters(): any;
        /**
         * Disables the feature FacetData and frees the related memory
         * @returns the current mesh
         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        disableFacetData(): AbstractMesh;
        /**
         * Updates the AbstractMesh indices array
         * @param indices defines the data source
         * @param offset defines the offset in the index buffer where to store the new data (can be null)
         * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)
         * @returns the current mesh
         */
        updateIndices(indices: IndicesArray, offset?: number, gpuMemoryOnly?: boolean): AbstractMesh;
        /**
         * Creates new normals data for the mesh
         * @param updatable defines if the normal vertex buffer must be flagged as updatable
         * @returns the current mesh
         */
        createNormals(updatable: boolean): AbstractMesh;
        /**
         * Align the mesh with a normal
         * @param normal defines the normal to use
         * @param upDirection can be used to redefined the up vector to use (will use the (0, 1, 0) by default)
         * @returns the current mesh
         */
        alignWithNormal(normal: Vector3, upDirection?: Vector3): AbstractMesh;
        /** @hidden */
        _checkOcclusionQuery(): boolean;
        /**
         * Disables the mesh edge rendering mode
         * @returns the currentAbstractMesh
         */
        disableEdgesRendering(): AbstractMesh;
        /**
         * Enables the edge rendering mode on the mesh.
         * This mode makes the mesh edges visible
         * @param epsilon defines the maximal distance between two angles to detect a face
         * @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces
         * @returns the currentAbstractMesh
         * @see https://www.babylonjs-playground.com/#19O9TU#0
         */
        enableEdgesRendering(epsilon?: number, checkVerticesInsteadOfIndices?: boolean): AbstractMesh;
        /**
         * This function returns all of the particle systems in the scene that use the mesh as an emitter.
         * @returns an array of particle systems in the scene that use the mesh as an emitter
         */
        getConnectedParticleSystems(): IParticleSystem[];
    }
}
declare module BABYLON {
    /**
     * Interface used to define ActionEvent
     */
    export interface IActionEvent {
        /** The mesh or sprite that triggered the action */
        source: any;
        /** The X mouse cursor position at the time of the event */
        pointerX: number;
        /** The Y mouse cursor position at the time of the event */
        pointerY: number;
        /** The mesh that is currently pointed at (can be null) */
        meshUnderPointer: Nullable<AbstractMesh>;
        /** the original (browser) event that triggered the ActionEvent */
        sourceEvent?: any;
        /** additional data for the event */
        additionalData?: any;
    }
    /**
     * ActionEvent is the event being sent when an action is triggered.
     */
    export class ActionEvent implements IActionEvent {
        /** The mesh or sprite that triggered the action */
        source: any;
        /** The X mouse cursor position at the time of the event */
        pointerX: number;
        /** The Y mouse cursor position at the time of the event */
        pointerY: number;
        /** The mesh that is currently pointed at (can be null) */
        meshUnderPointer: Nullable<AbstractMesh>;
        /** the original (browser) event that triggered the ActionEvent */
        sourceEvent?: any;
        /** additional data for the event */
        additionalData?: any;
        /**
         * Creates a new ActionEvent
         * @param source The mesh or sprite that triggered the action
         * @param pointerX The X mouse cursor position at the time of the event
         * @param pointerY The Y mouse cursor position at the time of the event
         * @param meshUnderPointer The mesh that is currently pointed at (can be null)
         * @param sourceEvent the original (browser) event that triggered the ActionEvent
         * @param additionalData additional data for the event
         */
        constructor(
        /** The mesh or sprite that triggered the action */
        source: any, 
        /** The X mouse cursor position at the time of the event */
        pointerX: number, 
        /** The Y mouse cursor position at the time of the event */
        pointerY: number, 
        /** The mesh that is currently pointed at (can be null) */
        meshUnderPointer: Nullable<AbstractMesh>, 
        /** the original (browser) event that triggered the ActionEvent */
        sourceEvent?: any, 
        /** additional data for the event */
        additionalData?: any);
        /**
         * Helper function to auto-create an ActionEvent from a source mesh.
         * @param source The source mesh that triggered the event
         * @param evt The original (browser) event
         * @param additionalData additional data for the event
         * @returns the new ActionEvent
         */
        static CreateNew(source: AbstractMesh, evt?: Event, additionalData?: any): ActionEvent;
        /**
         * Helper function to auto-create an ActionEvent from a source sprite
         * @param source The source sprite that triggered the event
         * @param scene Scene associated with the sprite
         * @param evt The original (browser) event
         * @param additionalData additional data for the event
         * @returns the new ActionEvent
         */
        static CreateNewFromSprite(source: Sprite, scene: Scene, evt?: Event, additionalData?: any): ActionEvent;
        /**
         * Helper function to auto-create an ActionEvent from a scene. If triggered by a mesh use ActionEvent.CreateNew
         * @param scene the scene where the event occurred
         * @param evt The original (browser) event
         * @returns the new ActionEvent
         */
        static CreateNewFromScene(scene: Scene, evt: Event): ActionEvent;
        /**
         * Helper function to auto-create an ActionEvent from a primitive
         * @param prim defines the target primitive
         * @param pointerPos defines the pointer position
         * @param evt The original (browser) event
         * @param additionalData additional data for the event
         * @returns the new ActionEvent
         */
        static CreateNewFromPrimitive(prim: any, pointerPos: Vector2, evt?: Event, additionalData?: any): ActionEvent;
    }
}
declare module BABYLON {
    /**
     * Abstract class used to decouple action Manager from scene and meshes.
     * Do not instantiate.
     * @see https://doc.babylonjs.com/how_to/how_to_use_actions
     */
    export abstract class AbstractActionManager implements IDisposable {
        /** Gets the list of active triggers */
        static Triggers: {
            [key: string]: number;
        };
        /** Gets the cursor to use when hovering items */
        hoverCursor: string;
        /** Gets the list of actions */
        actions: IAction[];
        /**
         * Gets or sets a boolean indicating that the manager is recursive meaning that it can trigger action from children
         */
        isRecursive: boolean;
        /**
         * Releases all associated resources
         */
        abstract dispose(): void;
        /**
         * Does this action manager has pointer triggers
         */
        abstract get hasPointerTriggers(): boolean;
        /**
         * Does this action manager has pick triggers
         */
        abstract get hasPickTriggers(): boolean;
        /**
         * Process a specific trigger
         * @param trigger defines the trigger to process
         * @param evt defines the event details to be processed
         */
        abstract processTrigger(trigger: number, evt?: IActionEvent): void;
        /**
         * Does this action manager handles actions of any of the given triggers
         * @param triggers defines the triggers to be tested
         * @return a boolean indicating whether one (or more) of the triggers is handled
         */
        abstract hasSpecificTriggers(triggers: number[]): boolean;
        /**
         * Does this action manager handles actions of any of the given triggers. This function takes two arguments for
         * speed.
         * @param triggerA defines the trigger to be tested
         * @param triggerB defines the trigger to be tested
         * @return a boolean indicating whether one (or more) of the triggers is handled
         */
        abstract hasSpecificTriggers2(triggerA: number, triggerB: number): boolean;
        /**
         * Does this action manager handles actions of a given trigger
         * @param trigger defines the trigger to be tested
         * @param parameterPredicate defines an optional predicate to filter triggers by parameter
         * @return whether the trigger is handled
         */
        abstract hasSpecificTrigger(trigger: number, parameterPredicate?: (parameter: any) => boolean): boolean;
        /**
         * Serialize this manager to a JSON object
         * @param name defines the property name to store this manager
         * @returns a JSON representation of this manager
         */
        abstract serialize(name: string): any;
        /**
         * Registers an action to this action manager
         * @param action defines the action to be registered
         * @return the action amended (prepared) after registration
         */
        abstract registerAction(action: IAction): Nullable<IAction>;
        /**
         * Unregisters an action to this action manager
         * @param action defines the action to be unregistered
         * @return a boolean indicating whether the action has been unregistered
         */
        abstract unregisterAction(action: IAction): Boolean;
        /**
         * Does exist one action manager with at least one trigger
         **/
        static get HasTriggers(): boolean;
        /**
         * Does exist one action manager with at least one pick trigger
         **/
        static get HasPickTriggers(): boolean;
        /**
         * Does exist one action manager that handles actions of a given trigger
         * @param trigger defines the trigger to be tested
         * @return a boolean indicating whether the trigger is handeled by at least one action manager
        **/
        static HasSpecificTrigger(trigger: number): boolean;
    }
}
declare module BABYLON {
    /**
     * Defines how a node can be built from a string name.
     */
    export type NodeConstructor = (name: string, scene: Scene, options?: any) => () => Node;
    /**
     * Node is the basic class for all scene objects (Mesh, Light, Camera.)
     */
    export class Node implements IBehaviorAware<Node> {
        /** @hidden */
        static _AnimationRangeFactory: (name: string, from: number, to: number) => AnimationRange;
        private static _NodeConstructors;
        /**
         * Add a new node constructor
         * @param type defines the type name of the node to construct
         * @param constructorFunc defines the constructor function
         */
        static AddNodeConstructor(type: string, constructorFunc: NodeConstructor): void;
        /**
         * Returns a node constructor based on type name
         * @param type defines the type name
         * @param name defines the new node name
         * @param scene defines the hosting scene
         * @param options defines optional options to transmit to constructors
         * @returns the new constructor or null
         */
        static Construct(type: string, name: string, scene: Scene, options?: any): Nullable<() => Node>;
        /**
         * Gets or sets the name of the node
         */
        name: string;
        /**
         * Gets or sets the id of the node
         */
        id: string;
        /**
         * Gets or sets the unique id of the node
         */
        uniqueId: number;
        /**
         * Gets or sets a string used to store user defined state for the node
         */
        state: string;
        /**
         * Gets or sets an object used to store user defined information for the node
         */
        metadata: any;
        /**
         * For internal use only. Please do not use.
         */
        reservedDataStore: any;
        /**
         * List of inspectable custom properties (used by the Inspector)
         * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility
         */
        inspectableCustomProperties: IInspectable[];
        private _doNotSerialize;
        /**
         * Gets or sets a boolean used to define if the node must be serialized
         */
        get doNotSerialize(): boolean;
        set doNotSerialize(value: boolean);
        /** @hidden */
        _isDisposed: boolean;
        /**
         * Gets a list of Animations associated with the node
         */
        animations: Animation[];
        protected _ranges: {
            [name: string]: Nullable<AnimationRange>;
        };
        /**
         * Callback raised when the node is ready to be used
         */
        onReady: Nullable<(node: Node) => void>;
        private _isEnabled;
        private _isParentEnabled;
        private _isReady;
        /** @hidden */
        _currentRenderId: number;
        private _parentUpdateId;
        /** @hidden */
        _childUpdateId: number;
        /** @hidden */
        _waitingParentId: Nullable<string>;
        /** @hidden */
        _scene: Scene;
        /** @hidden */
        _cache: any;
        private _parentNode;
        private _children;
        /** @hidden */
        _worldMatrix: Matrix;
        /** @hidden */
        _worldMatrixDeterminant: number;
        /** @hidden */
        _worldMatrixDeterminantIsDirty: boolean;
        /** @hidden */
        private _sceneRootNodesIndex;
        /**
         * Gets a boolean indicating if the node has been disposed
         * @returns true if the node was disposed
         */
        isDisposed(): boolean;
        /**
         * Gets or sets the parent of the node (without keeping the current position in the scene)
         * @see https://doc.babylonjs.com/how_to/parenting
         */
        set parent(parent: Nullable<Node>);
        get parent(): Nullable<Node>;
        /** @hidden */
        _addToSceneRootNodes(): void;
        /** @hidden */
        _removeFromSceneRootNodes(): void;
        private _animationPropertiesOverride;
        /**
         * Gets or sets the animation properties override
         */
        get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride>;
        set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>);
        /**
         * Gets a string identifying the name of the class
         * @returns "Node" string
         */
        getClassName(): string;
        /** @hidden */
        readonly _isNode: boolean;
        /**
        * An event triggered when the mesh is disposed
        */
        onDisposeObservable: Observable<Node>;
        private _onDisposeObserver;
        /**
         * Sets a callback that will be raised when the node will be disposed
         */
        set onDispose(callback: () => void);
        /**
         * Creates a new Node
         * @param name the name and id to be given to this node
         * @param scene the scene this node will be added to
         */
        constructor(name: string, scene?: Nullable<Scene>);
        /**
         * Gets the scene of the node
         * @returns a scene
         */
        getScene(): Scene;
        /**
         * Gets the engine of the node
         * @returns a Engine
         */
        getEngine(): Engine;
        private _behaviors;
        /**
         * Attach a behavior to the node
         * @see https://doc.babylonjs.com/features/behaviour
         * @param behavior defines the behavior to attach
         * @param attachImmediately defines that the behavior must be attached even if the scene is still loading
         * @returns the current Node
         */
        addBehavior(behavior: Behavior<Node>, attachImmediately?: boolean): Node;
        /**
         * Remove an attached behavior
         * @see https://doc.babylonjs.com/features/behaviour
         * @param behavior defines the behavior to attach
         * @returns the current Node
         */
        removeBehavior(behavior: Behavior<Node>): Node;
        /**
         * Gets the list of attached behaviors
         * @see https://doc.babylonjs.com/features/behaviour
         */
        get behaviors(): Behavior<Node>[];
        /**
         * Gets an attached behavior by name
         * @param name defines the name of the behavior to look for
         * @see https://doc.babylonjs.com/features/behaviour
         * @returns null if behavior was not found else the requested behavior
         */
        getBehaviorByName(name: string): Nullable<Behavior<Node>>;
        /**
         * Returns the latest update of the World matrix
         * @returns a Matrix
         */
        getWorldMatrix(): Matrix;
        /** @hidden */
        _getWorldMatrixDeterminant(): number;
        /**
         * Returns directly the latest state of the mesh World matrix.
         * A Matrix is returned.
         */
        get worldMatrixFromCache(): Matrix;
        /** @hidden */
        _initCache(): void;
        /** @hidden */
        updateCache(force?: boolean): void;
        /** @hidden */
        _getActionManagerForTrigger(trigger?: number, initialCall?: boolean): Nullable<AbstractActionManager>;
        /** @hidden */
        _updateCache(ignoreParentClass?: boolean): void;
        /** @hidden */
        _isSynchronized(): boolean;
        /** @hidden */
        _markSyncedWithParent(): void;
        /** @hidden */
        isSynchronizedWithParent(): boolean;
        /** @hidden */
        isSynchronized(): boolean;
        /**
         * Is this node ready to be used/rendered
         * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)
         * @return true if the node is ready
         */
        isReady(completeCheck?: boolean): boolean;
        /**
         * Is this node enabled?
         * If the node has a parent, all ancestors will be checked and false will be returned if any are false (not enabled), otherwise will return true
         * @param checkAncestors indicates if this method should check the ancestors. The default is to check the ancestors. If set to false, the method will return the value of this node without checking ancestors
         * @return whether this node (and its parent) is enabled
         */
        isEnabled(checkAncestors?: boolean): boolean;
        /** @hidden */
        protected _syncParentEnabledState(): void;
        /**
         * Set the enabled state of this node
         * @param value defines the new enabled state
         */
        setEnabled(value: boolean): void;
        /**
         * Is this node a descendant of the given node?
         * The function will iterate up the hierarchy until the ancestor was found or no more parents defined
         * @param ancestor defines the parent node to inspect
         * @returns a boolean indicating if this node is a descendant of the given node
         */
        isDescendantOf(ancestor: Node): boolean;
        /** @hidden */
        _getDescendants(results: Node[], directDescendantsOnly?: boolean, predicate?: (node: Node) => boolean): void;
        /**
         * Will return all nodes that have this node as ascendant
         * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered
         * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
         * @return all children nodes of all types
         */
        getDescendants(directDescendantsOnly?: boolean, predicate?: (node: Node) => boolean): Node[];
        /**
         * Get all child-meshes of this node
         * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered (Default: false)
         * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
         * @returns an array of AbstractMesh
         */
        getChildMeshes(directDescendantsOnly?: boolean, predicate?: (node: Node) => boolean): AbstractMesh[];
        /**
         * Get all direct children of this node
         * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
         * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered (Default: true)
         * @returns an array of Node
         */
        getChildren(predicate?: (node: Node) => boolean, directDescendantsOnly?: boolean): Node[];
        /** @hidden */
        _setReady(state: boolean): void;
        /**
         * Get an animation by name
         * @param name defines the name of the animation to look for
         * @returns null if not found else the requested animation
         */
        getAnimationByName(name: string): Nullable<Animation>;
        /**
         * Creates an animation range for this node
         * @param name defines the name of the range
         * @param from defines the starting key
         * @param to defines the end key
         */
        createAnimationRange(name: string, from: number, to: number): void;
        /**
         * Delete a specific animation range
         * @param name defines the name of the range to delete
         * @param deleteFrames defines if animation frames from the range must be deleted as well
         */
        deleteAnimationRange(name: string, deleteFrames?: boolean): void;
        /**
         * Get an animation range by name
         * @param name defines the name of the animation range to look for
         * @returns null if not found else the requested animation range
         */
        getAnimationRange(name: string): Nullable<AnimationRange>;
        /**
         * Gets the list of all animation ranges defined on this node
         * @returns an array
         */
        getAnimationRanges(): Nullable<AnimationRange>[];
        /**
         * Will start the animation sequence
         * @param name defines the range frames for animation sequence
         * @param loop defines if the animation should loop (false by default)
         * @param speedRatio defines the speed factor in which to run the animation (1 by default)
         * @param onAnimationEnd defines a function to be executed when the animation ended (undefined by default)
         * @returns the object created for this animation. If range does not exist, it will return null
         */
        beginAnimation(name: string, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void): Nullable<Animatable>;
        /**
         * Serialize animation ranges into a JSON compatible object
         * @returns serialization object
         */
        serializeAnimationRanges(): any;
        /**
         * Computes the world matrix of the node
         * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch
         * @returns the world matrix
         */
        computeWorldMatrix(force?: boolean): Matrix;
        /**
         * Releases resources associated with this node.
         * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
         * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
         */
        dispose(doNotRecurse?: boolean, disposeMaterialAndTextures?: boolean): void;
        /**
         * Parse animation range data from a serialization object and store them into a given node
         * @param node defines where to store the animation ranges
         * @param parsedNode defines the serialization object to read data from
         * @param scene defines the hosting scene
         */
        static ParseAnimationRanges(node: Node, parsedNode: any, scene: Scene): void;
        /**
     * Return the minimum and maximum world vectors of the entire hierarchy under current node
     * @param includeDescendants Include bounding info from descendants as well (true by default)
     * @param predicate defines a callback function that can be customize to filter what meshes should be included in the list used to compute the bounding vectors
     * @returns the new bounding vectors
     */
        getHierarchyBoundingVectors(includeDescendants?: boolean, predicate?: Nullable<(abstractMesh: AbstractMesh) => boolean>): {
            min: Vector3;
            max: Vector3;
        };
    }
}
declare module BABYLON {
    /**
     * @hidden
     */
    export class _IAnimationState {
        key: number;
        repeatCount: number;
        workValue?: any;
        loopMode?: number;
        offsetValue?: any;
        highLimitValue?: any;
    }
    /**
     * Class used to store any kind of animation
     */
    export class Animation {
        /**Name of the animation */
        name: string;
        /**Property to animate */
        targetProperty: string;
        /**The frames per second of the animation */
        framePerSecond: number;
        /**The data type of the animation */
        dataType: number;
        /**The loop mode of the animation */
        loopMode?: number | undefined;
        /**Specifies if blending should be enabled */
        enableBlending?: boolean | undefined;
        /**
         * Use matrix interpolation instead of using direct key value when animating matrices
         */
        static AllowMatricesInterpolation: boolean;
        /**
         * When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower
         */
        static AllowMatrixDecomposeForInterpolation: boolean;
        /** Define the Url to load snippets */
        static SnippetUrl: string;
        /** Snippet ID if the animation was created from the snippet server */
        snippetId: string;
        /**
         * Stores the key frames of the animation
         */
        private _keys;
        /**
         * Stores the easing function of the animation
         */
        private _easingFunction;
        /**
         * @hidden Internal use only
         */
        _runtimeAnimations: RuntimeAnimation[];
        /**
         * The set of event that will be linked to this animation
         */
        private _events;
        /**
         * Stores an array of target property paths
         */
        targetPropertyPath: string[];
        /**
         * Stores the blending speed of the animation
         */
        blendingSpeed: number;
        /**
         * Stores the animation ranges for the animation
         */
        private _ranges;
        /**
         * @hidden Internal use
         */
        static _PrepareAnimation(name: string, targetProperty: string, framePerSecond: number, totalFrame: number, from: any, to: any, loopMode?: number, easingFunction?: EasingFunction): Nullable<Animation>;
        /**
         * Sets up an animation
         * @param property The property to animate
         * @param animationType The animation type to apply
         * @param framePerSecond The frames per second of the animation
         * @param easingFunction The easing function used in the animation
         * @returns The created animation
         */
        static CreateAnimation(property: string, animationType: number, framePerSecond: number, easingFunction: EasingFunction): Animation;
        /**
         * Create and start an animation on a node
         * @param name defines the name of the global animation that will be run on all nodes
         * @param node defines the root node where the animation will take place
         * @param targetProperty defines property to animate
         * @param framePerSecond defines the number of frame per second yo use
         * @param totalFrame defines the number of frames in total
         * @param from defines the initial value
         * @param to defines the final value
         * @param loopMode defines which loop mode you want to use (off by default)
         * @param easingFunction defines the easing function to use (linear by default)
         * @param onAnimationEnd defines the callback to call when animation end
         * @returns the animatable created for this animation
         */
        static CreateAndStartAnimation(name: string, node: Node, targetProperty: string, framePerSecond: number, totalFrame: number, from: any, to: any, loopMode?: number, easingFunction?: EasingFunction, onAnimationEnd?: () => void): Nullable<Animatable>;
        /**
         * Create and start an animation on a node and its descendants
         * @param name defines the name of the global animation that will be run on all nodes
         * @param node defines the root node where the animation will take place
         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used
         * @param targetProperty defines property to animate
         * @param framePerSecond defines the number of frame per second to use
         * @param totalFrame defines the number of frames in total
         * @param from defines the initial value
         * @param to defines the final value
         * @param loopMode defines which loop mode you want to use (off by default)
         * @param easingFunction defines the easing function to use (linear by default)
         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)
         * @returns the list of animatables created for all nodes
         * @example https://www.babylonjs-playground.com/#MH0VLI
         */
        static CreateAndStartHierarchyAnimation(name: string, node: Node, directDescendantsOnly: boolean, targetProperty: string, framePerSecond: number, totalFrame: number, from: any, to: any, loopMode?: number, easingFunction?: EasingFunction, onAnimationEnd?: () => void): Nullable<Animatable[]>;
        /**
         * Creates a new animation, merges it with the existing animations and starts it
         * @param name Name of the animation
         * @param node Node which contains the scene that begins the animations
         * @param targetProperty Specifies which property to animate
         * @param framePerSecond The frames per second of the animation
         * @param totalFrame The total number of frames
         * @param from The frame at the beginning of the animation
         * @param to The frame at the end of the animation
         * @param loopMode Specifies the loop mode of the animation
         * @param easingFunction (Optional) The easing function of the animation, which allow custom mathematical formulas for animations
         * @param onAnimationEnd Callback to run once the animation is complete
         * @returns Nullable animation
         */
        static CreateMergeAndStartAnimation(name: string, node: Node, targetProperty: string, framePerSecond: number, totalFrame: number, from: any, to: any, loopMode?: number, easingFunction?: EasingFunction, onAnimationEnd?: () => void): Nullable<Animatable>;
        /**
         * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.
         * @param sourceAnimation defines the Animation containing keyframes to convert
         * @param referenceFrame defines the frame that keyframes in the range will be relative to
         * @param range defines the name of the AnimationRange belonging to the Animation to convert
         * @param cloneOriginal defines whether or not to clone the animation and convert the clone or convert the original animation (default is false)
         * @param clonedName defines the name of the resulting cloned Animation if cloneOriginal is true
         * @returns a new Animation if cloneOriginal is true or the original Animation if cloneOriginal is false
         */
        static MakeAnimationAdditive(sourceAnimation: Animation, referenceFrame?: number, range?: string, cloneOriginal?: boolean, clonedName?: string): Animation;
        /**
         * Transition property of an host to the target Value
         * @param property The property to transition
         * @param targetValue The target Value of the property
         * @param host The object where the property to animate belongs
         * @param scene Scene used to run the animation
         * @param frameRate Framerate (in frame/s) to use
         * @param transition The transition type we want to use
         * @param duration The duration of the animation, in milliseconds
         * @param onAnimationEnd Callback trigger at the end of the animation
         * @returns Nullable animation
         */
        static TransitionTo(property: string, targetValue: any, host: any, scene: Scene, frameRate: number, transition: Animation, duration: number, onAnimationEnd?: Nullable<() => void>): Nullable<Animatable>;
        /**
         * Return the array of runtime animations currently using this animation
         */
        get runtimeAnimations(): RuntimeAnimation[];
        /**
         * Specifies if any of the runtime animations are currently running
         */
        get hasRunningRuntimeAnimations(): boolean;
        /**
         * Initializes the animation
         * @param name Name of the animation
         * @param targetProperty Property to animate
         * @param framePerSecond The frames per second of the animation
         * @param dataType The data type of the animation
         * @param loopMode The loop mode of the animation
         * @param enableBlending Specifies if blending should be enabled
         */
        constructor(
        /**Name of the animation */
        name: string, 
        /**Property to animate */
        targetProperty: string, 
        /**The frames per second of the animation */
        framePerSecond: number, 
        /**The data type of the animation */
        dataType: number, 
        /**The loop mode of the animation */
        loopMode?: number | undefined, 
        /**Specifies if blending should be enabled */
        enableBlending?: boolean | undefined);
        /**
         * Converts the animation to a string
         * @param fullDetails support for multiple levels of logging within scene loading
         * @returns String form of the animation
         */
        toString(fullDetails?: boolean): string;
        /**
         * Add an event to this animation
         * @param event Event to add
         */
        addEvent(event: AnimationEvent): void;
        /**
         * Remove all events found at the given frame
         * @param frame The frame to remove events from
         */
        removeEvents(frame: number): void;
        /**
         * Retrieves all the events from the animation
         * @returns Events from the animation
         */
        getEvents(): AnimationEvent[];
        /**
         * Creates an animation range
         * @param name Name of the animation range
         * @param from Starting frame of the animation range
         * @param to Ending frame of the animation
         */
        createRange(name: string, from: number, to: number): void;
        /**
         * Deletes an animation range by name
         * @param name Name of the animation range to delete
         * @param deleteFrames Specifies if the key frames for the range should also be deleted (true) or not (false)
         */
        deleteRange(name: string, deleteFrames?: boolean): void;
        /**
         * Gets the animation range by name, or null if not defined
         * @param name Name of the animation range
         * @returns Nullable animation range
         */
        getRange(name: string): Nullable<AnimationRange>;
        /**
         * Gets the key frames from the animation
         * @returns The key frames of the animation
         */
        getKeys(): Array<IAnimationKey>;
        /**
         * Gets the highest frame rate of the animation
         * @returns Highest frame rate of the animation
         */
        getHighestFrame(): number;
        /**
         * Gets the easing function of the animation
         * @returns Easing function of the animation
         */
        getEasingFunction(): IEasingFunction;
        /**
         * Sets the easing function of the animation
         * @param easingFunction A custom mathematical formula for animation
         */
        setEasingFunction(easingFunction: EasingFunction): void;
        /**
         * Interpolates a scalar linearly
         * @param startValue Start value of the animation curve
         * @param endValue End value of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns Interpolated scalar value
         */
        floatInterpolateFunction(startValue: number, endValue: number, gradient: number): number;
        /**
         * Interpolates a scalar cubically
         * @param startValue Start value of the animation curve
         * @param outTangent End tangent of the animation
         * @param endValue End value of the animation curve
         * @param inTangent Start tangent of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns Interpolated scalar value
         */
        floatInterpolateFunctionWithTangents(startValue: number, outTangent: number, endValue: number, inTangent: number, gradient: number): number;
        /**
         * Interpolates a quaternion using a spherical linear interpolation
         * @param startValue Start value of the animation curve
         * @param endValue End value of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns Interpolated quaternion value
         */
        quaternionInterpolateFunction(startValue: Quaternion, endValue: Quaternion, gradient: number): Quaternion;
        /**
         * Interpolates a quaternion cubically
         * @param startValue Start value of the animation curve
         * @param outTangent End tangent of the animation curve
         * @param endValue End value of the animation curve
         * @param inTangent Start tangent of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns Interpolated quaternion value
         */
        quaternionInterpolateFunctionWithTangents(startValue: Quaternion, outTangent: Quaternion, endValue: Quaternion, inTangent: Quaternion, gradient: number): Quaternion;
        /**
         * Interpolates a Vector3 linearl
         * @param startValue Start value of the animation curve
         * @param endValue End value of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns Interpolated scalar value
         */
        vector3InterpolateFunction(startValue: Vector3, endValue: Vector3, gradient: number): Vector3;
        /**
         * Interpolates a Vector3 cubically
         * @param startValue Start value of the animation curve
         * @param outTangent End tangent of the animation
         * @param endValue End value of the animation curve
         * @param inTangent Start tangent of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns InterpolatedVector3 value
         */
        vector3InterpolateFunctionWithTangents(startValue: Vector3, outTangent: Vector3, endValue: Vector3, inTangent: Vector3, gradient: number): Vector3;
        /**
         * Interpolates a Vector2 linearly
         * @param startValue Start value of the animation curve
         * @param endValue End value of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns Interpolated Vector2 value
         */
        vector2InterpolateFunction(startValue: Vector2, endValue: Vector2, gradient: number): Vector2;
        /**
         * Interpolates a Vector2 cubically
         * @param startValue Start value of the animation curve
         * @param outTangent End tangent of the animation
         * @param endValue End value of the animation curve
         * @param inTangent Start tangent of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns Interpolated Vector2 value
         */
        vector2InterpolateFunctionWithTangents(startValue: Vector2, outTangent: Vector2, endValue: Vector2, inTangent: Vector2, gradient: number): Vector2;
        /**
         * Interpolates a size linearly
         * @param startValue Start value of the animation curve
         * @param endValue End value of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns Interpolated Size value
         */
        sizeInterpolateFunction(startValue: Size, endValue: Size, gradient: number): Size;
        /**
         * Interpolates a Color3 linearly
         * @param startValue Start value of the animation curve
         * @param endValue End value of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns Interpolated Color3 value
         */
        color3InterpolateFunction(startValue: Color3, endValue: Color3, gradient: number): Color3;
        /**
         * Interpolates a Color4 linearly
         * @param startValue Start value of the animation curve
         * @param endValue End value of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns Interpolated Color3 value
         */
        color4InterpolateFunction(startValue: Color4, endValue: Color4, gradient: number): Color4;
        /**
         * @hidden Internal use only
         */
        _getKeyValue(value: any): any;
        /**
         * @hidden Internal use only
         */
        _interpolate(currentFrame: number, state: _IAnimationState): any;
        /**
         * Defines the function to use to interpolate matrices
         * @param startValue defines the start matrix
         * @param endValue defines the end matrix
         * @param gradient defines the gradient between both matrices
         * @param result defines an optional target matrix where to store the interpolation
         * @returns the interpolated matrix
         */
        matrixInterpolateFunction(startValue: Matrix, endValue: Matrix, gradient: number, result?: Matrix): Matrix;
        /**
         * Makes a copy of the animation
         * @returns Cloned animation
         */
        clone(): Animation;
        /**
         * Sets the key frames of the animation
         * @param values The animation key frames to set
         */
        setKeys(values: Array<IAnimationKey>): void;
        /**
         * Serializes the animation to an object
         * @returns Serialized object
         */
        serialize(): any;
        /**
         * Float animation type
         */
        static readonly ANIMATIONTYPE_FLOAT: number;
        /**
         * Vector3 animation type
         */
        static readonly ANIMATIONTYPE_VECTOR3: number;
        /**
         * Quaternion animation type
         */
        static readonly ANIMATIONTYPE_QUATERNION: number;
        /**
         * Matrix animation type
         */
        static readonly ANIMATIONTYPE_MATRIX: number;
        /**
         * Color3 animation type
         */
        static readonly ANIMATIONTYPE_COLOR3: number;
        /**
         * Color3 animation type
         */
        static readonly ANIMATIONTYPE_COLOR4: number;
        /**
         * Vector2 animation type
         */
        static readonly ANIMATIONTYPE_VECTOR2: number;
        /**
         * Size animation type
         */
        static readonly ANIMATIONTYPE_SIZE: number;
        /**
         * Relative Loop Mode
         */
        static readonly ANIMATIONLOOPMODE_RELATIVE: number;
        /**
         * Cycle Loop Mode
         */
        static readonly ANIMATIONLOOPMODE_CYCLE: number;
        /**
         * Constant Loop Mode
         */
        static readonly ANIMATIONLOOPMODE_CONSTANT: number;
        /** @hidden */
        static _UniversalLerp(left: any, right: any, amount: number): any;
        /**
         * Parses an animation object and creates an animation
         * @param parsedAnimation Parsed animation object
         * @returns Animation object
         */
        static Parse(parsedAnimation: any): Animation;
        /**
         * Appends the serialized animations from the source animations
         * @param source Source containing the animations
         * @param destination Target to store the animations
         */
        static AppendSerializedAnimations(source: IAnimatable, destination: any): void;
        /**
         * Creates a new animation or an array of animations from a snippet saved in a remote file
         * @param name defines the name of the animation to create (can be null or empty to use the one from the json data)
         * @param url defines the url to load from
         * @returns a promise that will resolve to the new animation or an array of animations
         */
        static ParseFromFileAsync(name: Nullable<string>, url: string): Promise<Animation | Array<Animation>>;
        /**
         * Creates an animation or an array of animations from a snippet saved by the Inspector
         * @param snippetId defines the snippet to load
         * @returns a promise that will resolve to the new animation or a new array of animations
         */
        static CreateFromSnippetAsync(snippetId: string): Promise<Animation | Array<Animation>>;
    }
}
declare module BABYLON {
    /**
     * Interface containing an array of animations
     */
    export interface IAnimatable {
        /**
         * Array of animations
         */
        animations: Nullable<Array<Animation>>;
    }
}
declare module BABYLON {
    export function expandToProperty(callback: string, targetKey?: Nullable<string>): (target: any, propertyKey: string) => void;
    export function serialize(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    export function serializeAsTexture(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    export function serializeAsColor3(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    export function serializeAsFresnelParameters(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    export function serializeAsVector2(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    export function serializeAsVector3(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    export function serializeAsMeshReference(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    export function serializeAsColorCurves(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    export function serializeAsColor4(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    export function serializeAsImageProcessingConfiguration(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    export function serializeAsQuaternion(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    export function serializeAsMatrix(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    /**
     * Decorator used to define property that can be serialized as reference to a camera
     * @param sourceName defines the name of the property to decorate
     */
    export function serializeAsCameraReference(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    /**
     * Class used to help serialization objects
     */
    export class SerializationHelper {
        /** @hidden */
        static _ImageProcessingConfigurationParser: (sourceProperty: any) => ImageProcessingConfiguration;
        /** @hidden */
        static _FresnelParametersParser: (sourceProperty: any) => FresnelParameters;
        /** @hidden */
        static _ColorCurvesParser: (sourceProperty: any) => ColorCurves;
        /** @hidden */
        static _TextureParser: (sourceProperty: any, scene: Scene, rootUrl: string) => Nullable<BaseTexture>;
        /**
         * Appends the serialized animations from the source animations
         * @param source Source containing the animations
         * @param destination Target to store the animations
         */
        static AppendSerializedAnimations(source: IAnimatable, destination: any): void;
        /**
         * Static function used to serialized a specific entity
         * @param entity defines the entity to serialize
         * @param serializationObject defines the optional target obecjt where serialization data will be stored
         * @returns a JSON compatible object representing the serialization of the entity
         */
        static Serialize<T>(entity: T, serializationObject?: any): any;
        /**
         * Creates a new entity from a serialization data object
         * @param creationFunction defines a function used to instanciated the new entity
         * @param source defines the source serialization data
         * @param scene defines the hosting scene
         * @param rootUrl defines the root url for resources
         * @returns a new entity
         */
        static Parse<T>(creationFunction: () => T, source: any, scene: Nullable<Scene>, rootUrl?: Nullable<string>): T;
        /**
         * Clones an object
         * @param creationFunction defines the function used to instanciate the new object
         * @param source defines the source object
         * @returns the cloned object
         */
        static Clone<T>(creationFunction: () => T, source: T): T;
        /**
         * Instanciates a new object based on a source one (some data will be shared between both object)
         * @param creationFunction defines the function used to instanciate the new object
         * @param source defines the source object
         * @returns the new object
         */
        static Instanciate<T>(creationFunction: () => T, source: T): T;
    }
}
declare module BABYLON {
    /**
     * Base class of all the textures in babylon.
     * It groups all the common properties the materials, post process, lights... might need
     * in order to make a correct use of the texture.
     */
    export class BaseTexture implements IAnimatable {
        /**
         * Default anisotropic filtering level for the application.
         * It is set to 4 as a good tradeoff between perf and quality.
         */
        static DEFAULT_ANISOTROPIC_FILTERING_LEVEL: number;
        /**
         * Gets or sets the unique id of the texture
         */
        uniqueId: number;
        /**
         * Define the name of the texture.
         */
        name: string;
        /**
         * Gets or sets an object used to store user defined information.
         */
        metadata: any;
        /**
         * For internal use only. Please do not use.
         */
        reservedDataStore: any;
        private _hasAlpha;
        /**
         * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).
         */
        set hasAlpha(value: boolean);
        get hasAlpha(): boolean;
        /**
         * Defines if the alpha value should be determined via the rgb values.
         * If true the luminance of the pixel might be used to find the corresponding alpha value.
         */
        getAlphaFromRGB: boolean;
        /**
         * Intensity or strength of the texture.
         * It is commonly used by materials to fine tune the intensity of the texture
         */
        level: number;
        /**
         * Define the UV chanel to use starting from 0 and defaulting to 0.
         * This is part of the texture as textures usually maps to one uv set.
         */
        coordinatesIndex: number;
        protected _coordinatesMode: number;
        /**
        * How a texture is mapped.
        *
        * | Value | Type                                | Description |
        * | ----- | ----------------------------------- | ----------- |
        * | 0     | EXPLICIT_MODE                       |             |
        * | 1     | SPHERICAL_MODE                      |             |
        * | 2     | PLANAR_MODE                         |             |
        * | 3     | CUBIC_MODE                          |             |
        * | 4     | PROJECTION_MODE                     |             |
        * | 5     | SKYBOX_MODE                         |             |
        * | 6     | INVCUBIC_MODE                       |             |
        * | 7     | EQUIRECTANGULAR_MODE                |             |
        * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |
        * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |
        */
        set coordinatesMode(value: number);
        get coordinatesMode(): number;
        private _wrapU;
        /**
        * | Value | Type               | Description |
        * | ----- | ------------------ | ----------- |
        * | 0     | CLAMP_ADDRESSMODE  |             |
        * | 1     | WRAP_ADDRESSMODE   |             |
        * | 2     | MIRROR_ADDRESSMODE |             |
        */
        get wrapU(): number;
        set wrapU(value: number);
        private _wrapV;
        /**
        * | Value | Type               | Description |
        * | ----- | ------------------ | ----------- |
        * | 0     | CLAMP_ADDRESSMODE  |             |
        * | 1     | WRAP_ADDRESSMODE   |             |
        * | 2     | MIRROR_ADDRESSMODE |             |
        */
        get wrapV(): number;
        set wrapV(value: number);
        /**
        * | Value | Type               | Description |
        * | ----- | ------------------ | ----------- |
        * | 0     | CLAMP_ADDRESSMODE  |             |
        * | 1     | WRAP_ADDRESSMODE   |             |
        * | 2     | MIRROR_ADDRESSMODE |             |
        */
        wrapR: number;
        /**
         * With compliant hardware and browser (supporting anisotropic filtering)
         * this defines the level of anisotropic filtering in the texture.
         * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.
         */
        anisotropicFilteringLevel: number;
        /**
         * Define if the texture is a cube texture or if false a 2d texture.
         */
        get isCube(): boolean;
        set isCube(value: boolean);
        /**
         * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.
         */
        get is3D(): boolean;
        set is3D(value: boolean);
        /**
         * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.
         */
        get is2DArray(): boolean;
        set is2DArray(value: boolean);
        private _gammaSpace;
        /**
         * Define if the texture contains data in gamma space (most of the png/jpg aside bump).
         * HDR texture are usually stored in linear space.
         * This only impacts the PBR and Background materials
         */
        get gammaSpace(): boolean;
        set gammaSpace(gamma: boolean);
        /**
         * Gets or sets whether or not the texture contains RGBD data.
         */
        get isRGBD(): boolean;
        set isRGBD(value: boolean);
        /**
         * Is Z inverted in the texture (useful in a cube texture).
         */
        invertZ: boolean;
        /**
         * Are mip maps generated for this texture or not.
         */
        get noMipmap(): boolean;
        /**
         * @hidden
         */
        lodLevelInAlpha: boolean;
        /**
         * With prefiltered texture, defined the offset used during the prefiltering steps.
         */
        get lodGenerationOffset(): number;
        set lodGenerationOffset(value: number);
        /**
         * With prefiltered texture, defined the scale used during the prefiltering steps.
         */
        get lodGenerationScale(): number;
        set lodGenerationScale(value: number);
        /**
         * With prefiltered texture, defined if the specular generation is based on a linear ramp.
         * By default we are using a log2 of the linear roughness helping to keep a better resolution for
         * average roughness values.
         */
        get linearSpecularLOD(): boolean;
        set linearSpecularLOD(value: boolean);
        /**
         * In case a better definition than spherical harmonics is required for the diffuse part of the environment.
         * You can set the irradiance texture to rely on a texture instead of the spherical approach.
         * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).
         */
        get irradianceTexture(): Nullable<BaseTexture>;
        set irradianceTexture(value: Nullable<BaseTexture>);
        /**
         * Define if the texture is a render target.
         */
        isRenderTarget: boolean;
        /**
         * Define the unique id of the texture in the scene.
         */
        get uid(): string;
        /** @hidden */
        _prefiltered: boolean;
        /**
         * Return a string representation of the texture.
         * @returns the texture as a string
         */
        toString(): string;
        /**
         * Get the class name of the texture.
         * @returns "BaseTexture"
         */
        getClassName(): string;
        /**
         * Define the list of animation attached to the texture.
         */
        animations: Animation[];
        /**
        * An event triggered when the texture is disposed.
        */
        onDisposeObservable: Observable<BaseTexture>;
        private _onDisposeObserver;
        /**
         * Callback triggered when the texture has been disposed.
         * Kept for back compatibility, you can use the onDisposeObservable instead.
         */
        set onDispose(callback: () => void);
        /**
         * Define the current state of the loading sequence when in delayed load mode.
         */
        delayLoadState: number;
        protected _scene: Nullable<Scene>;
        protected _engine: Nullable<ThinEngine>;
        /** @hidden */
        _texture: Nullable<InternalTexture>;
        private _uid;
        /**
         * Define if the texture is preventinga material to render or not.
         * If not and the texture is not ready, the engine will use a default black texture instead.
         */
        get isBlocking(): boolean;
        /**
         * Instantiates a new BaseTexture.
         * Base class of all the textures in babylon.
         * It groups all the common properties the materials, post process, lights... might need
         * in order to make a correct use of the texture.
         * @param sceneOrEngine Define the scene or engine the texture blongs to
         */
        constructor(sceneOrEngine: Nullable<Scene | ThinEngine>);
        /**
         * Get the scene the texture belongs to.
         * @returns the scene or null if undefined
         */
        getScene(): Nullable<Scene>;
        /** @hidden */
        protected _getEngine(): Nullable<ThinEngine>;
        /**
         * Get the texture transform matrix used to offset tile the texture for istance.
         * @returns the transformation matrix
         */
        getTextureMatrix(): Matrix;
        /**
         * Get the texture reflection matrix used to rotate/transform the reflection.
         * @returns the reflection matrix
         */
        getReflectionTextureMatrix(): Matrix;
        /**
         * Get the underlying lower level texture from Babylon.
         * @returns the insternal texture
         */
        getInternalTexture(): Nullable<InternalTexture>;
        /**
         * Get if the texture is ready to be consumed (either it is ready or it is not blocking)
         * @returns true if ready or not blocking
         */
        isReadyOrNotBlocking(): boolean;
        /**
         * Get if the texture is ready to be used (downloaded, converted, mip mapped...).
         * @returns true if fully ready
         */
        isReady(): boolean;
        private _cachedSize;
        /**
         * Get the size of the texture.
         * @returns the texture size.
         */
        getSize(): ISize;
        /**
         * Get the base size of the texture.
         * It can be different from the size if the texture has been resized for POT for instance
         * @returns the base size
         */
        getBaseSize(): ISize;
        /**
         * Update the sampling mode of the texture.
         * Default is Trilinear mode.
         *
         * | Value | Type               | Description |
         * | ----- | ------------------ | ----------- |
         * | 1     | NEAREST_SAMPLINGMODE or NEAREST_NEAREST_MIPLINEAR  | Nearest is: mag = nearest, min = nearest, mip = linear |
         * | 2     | BILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPNEAREST | Bilinear is: mag = linear, min = linear, mip = nearest |
         * | 3     | TRILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPLINEAR | Trilinear is: mag = linear, min = linear, mip = linear |
         * | 4     | NEAREST_NEAREST_MIPNEAREST |             |
         * | 5    | NEAREST_LINEAR_MIPNEAREST |             |
         * | 6    | NEAREST_LINEAR_MIPLINEAR |             |
         * | 7    | NEAREST_LINEAR |             |
         * | 8    | NEAREST_NEAREST |             |
         * | 9   | LINEAR_NEAREST_MIPNEAREST |             |
         * | 10   | LINEAR_NEAREST_MIPLINEAR |             |
         * | 11   | LINEAR_LINEAR |             |
         * | 12   | LINEAR_NEAREST |             |
         *
         *    > _mag_: magnification filter (close to the viewer)
         *    > _min_: minification filter (far from the viewer)
         *    > _mip_: filter used between mip map levels
         *@param samplingMode Define the new sampling mode of the texture
         */
        updateSamplingMode(samplingMode: number): void;
        /**
         * Scales the texture if is `canRescale()`
         * @param ratio the resize factor we want to use to rescale
         */
        scale(ratio: number): void;
        /**
         * Get if the texture can rescale.
         */
        get canRescale(): boolean;
        /** @hidden */
        _getFromCache(url: Nullable<string>, noMipmap: boolean, sampling?: number, invertY?: boolean): Nullable<InternalTexture>;
        /** @hidden */
        _rebuild(): void;
        /**
         * Triggers the load sequence in delayed load mode.
         */
        delayLoad(): void;
        /**
         * Clones the texture.
         * @returns the cloned texture
         */
        clone(): Nullable<BaseTexture>;
        /**
         * Get the texture underlying type (INT, FLOAT...)
         */
        get textureType(): number;
        /**
         * Get the texture underlying format (RGB, RGBA...)
         */
        get textureFormat(): number;
        /**
         * Indicates that textures need to be re-calculated for all materials
         */
        protected _markAllSubMeshesAsTexturesDirty(): void;
        /**
         * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.
         * This will returns an RGBA array buffer containing either in values (0-255) or
         * float values (0-1) depending of the underlying buffer type.
         * @param faceIndex defines the face of the texture to read (in case of cube texture)
         * @param level defines the LOD level of the texture to read (in case of Mip Maps)
         * @param buffer defines a user defined buffer to fill with data (can be null)
         * @returns The Array buffer containing the pixels data.
         */
        readPixels(faceIndex?: number, level?: number, buffer?: Nullable<ArrayBufferView>): Nullable<ArrayBufferView>;
        /**
         * Release and destroy the underlying lower level texture aka internalTexture.
         */
        releaseInternalTexture(): void;
        /** @hidden */
        get _lodTextureHigh(): Nullable<BaseTexture>;
        /** @hidden */
        get _lodTextureMid(): Nullable<BaseTexture>;
        /** @hidden */
        get _lodTextureLow(): Nullable<BaseTexture>;
        /**
         * Dispose the texture and release its associated resources.
         */
        dispose(): void;
        /**
         * Serialize the texture into a JSON representation that can be parsed later on.
         * @returns the JSON representation of the texture
         */
        serialize(): any;
        /**
         * Helper function to be called back once a list of texture contains only ready textures.
         * @param textures Define the list of textures to wait for
         * @param callback Define the callback triggered once the entire list will be ready
         */
        static WhenAllReady(textures: BaseTexture[], callback: () => void): void;
        private static _isScene;
    }
}
declare module BABYLON {
    /**
     * Options to be used when creating an effect.
     */
    export interface IEffectCreationOptions {
        /**
         * Atrributes that will be used in the shader.
         */
        attributes: string[];
        /**
         * Uniform varible names that will be set in the shader.
         */
        uniformsNames: string[];
        /**
         * Uniform buffer variable names that will be set in the shader.
         */
        uniformBuffersNames: string[];
        /**
         * Sampler texture variable names that will be set in the shader.
         */
        samplers: string[];
        /**
         * Define statements that will be set in the shader.
         */
        defines: any;
        /**
         * Possible fallbacks for this effect to improve performance when needed.
         */
        fallbacks: Nullable<IEffectFallbacks>;
        /**
         * Callback that will be called when the shader is compiled.
         */
        onCompiled: Nullable<(effect: Effect) => void>;
        /**
         * Callback that will be called if an error occurs during shader compilation.
         */
        onError: Nullable<(effect: Effect, errors: string) => void>;
        /**
         * Parameters to be used with Babylons include syntax to iterate over an array (eg. {lights: 10})
         */
        indexParameters?: any;
        /**
         * Max number of lights that can be used in the shader.
         */
        maxSimultaneousLights?: number;
        /**
         * See https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/transformFeedbackVaryings
         */
        transformFeedbackVaryings?: Nullable<string[]>;
        /**
         * If provided, will be called two times with the vertex and fragment code so that this code can be updated before it is compiled by the GPU
         */
        processFinalCode?: Nullable<(shaderType: string, code: string) => string>;
        /**
         * Is this effect rendering to several color attachments ?
         */
        multiTarget?: boolean;
    }
    /**
     * Effect containing vertex and fragment shader that can be executed on an object.
     */
    export class Effect implements IDisposable {
        /**
         * Gets or sets the relative url used to load shaders if using the engine in non-minified mode
         */
        static ShadersRepository: string;
        /**
         * Enable logging of the shader code when a compilation error occurs
         */
        static LogShaderCodeOnCompilationError: boolean;
        /**
         * Name of the effect.
         */
        name: any;
        /**
         * String container all the define statements that should be set on the shader.
         */
        defines: string;
        /**
         * Callback that will be called when the shader is compiled.
         */
        onCompiled: Nullable<(effect: Effect) => void>;
        /**
         * Callback that will be called if an error occurs during shader compilation.
         */
        onError: Nullable<(effect: Effect, errors: string) => void>;
        /**
         * Callback that will be called when effect is bound.
         */
        onBind: Nullable<(effect: Effect) => void>;
        /**
         * Unique ID of the effect.
         */
        uniqueId: number;
        /**
         * Observable that will be called when the shader is compiled.
         * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.
         */
        onCompileObservable: Observable<Effect>;
        /**
         * Observable that will be called if an error occurs during shader compilation.
         */
        onErrorObservable: Observable<Effect>;
        /** @hidden */
        _onBindObservable: Nullable<Observable<Effect>>;
        /**
         * @hidden
         * Specifies if the effect was previously ready
         */
        _wasPreviouslyReady: boolean;
        /**
         * Observable that will be called when effect is bound.
         */
        get onBindObservable(): Observable<Effect>;
        /** @hidden */
        _bonesComputationForcedToCPU: boolean;
        /** @hidden */
        _multiTarget: boolean;
        private static _uniqueIdSeed;
        private _engine;
        private _uniformBuffersNames;
        private _uniformBuffersNamesList;
        private _uniformsNames;
        private _samplerList;
        private _samplers;
        private _isReady;
        private _compilationError;
        private _allFallbacksProcessed;
        private _attributesNames;
        private _attributes;
        private _attributeLocationByName;
        private _uniforms;
        /**
         * Key for the effect.
         * @hidden
         */
        _key: string;
        private _indexParameters;
        private _fallbacks;
        private _vertexSourceCode;
        private _fragmentSourceCode;
        private _vertexSourceCodeOverride;
        private _fragmentSourceCodeOverride;
        private _transformFeedbackVaryings;
        /**
         * Compiled shader to webGL program.
         * @hidden
         */
        _pipelineContext: Nullable<IPipelineContext>;
        private _valueCache;
        private static _baseCache;
        /**
         * Instantiates an effect.
         * An effect can be used to create/manage/execute vertex and fragment shaders.
         * @param baseName Name of the effect.
         * @param attributesNamesOrOptions List of attribute names that will be passed to the shader or set of all options to create the effect.
         * @param uniformsNamesOrEngine List of uniform variable names that will be passed to the shader or the engine that will be used to render effect.
         * @param samplers List of sampler variables that will be passed to the shader.
         * @param engine Engine to be used to render the effect
         * @param defines Define statements to be added to the shader.
         * @param fallbacks Possible fallbacks for this effect to improve performance when needed.
         * @param onCompiled Callback that will be called when the shader is compiled.
         * @param onError Callback that will be called if an error occurs during shader compilation.
         * @param indexParameters Parameters to be used with Babylons include syntax to iterate over an array (eg. {lights: 10})
         */
        constructor(baseName: any, attributesNamesOrOptions: string[] | IEffectCreationOptions, uniformsNamesOrEngine: string[] | ThinEngine, samplers?: Nullable<string[]>, engine?: ThinEngine, defines?: Nullable<string>, fallbacks?: Nullable<IEffectFallbacks>, onCompiled?: Nullable<(effect: Effect) => void>, onError?: Nullable<(effect: Effect, errors: string) => void>, indexParameters?: any);
        private _useFinalCode;
        /**
         * Unique key for this effect
         */
        get key(): string;
        /**
         * If the effect has been compiled and prepared.
         * @returns if the effect is compiled and prepared.
         */
        isReady(): boolean;
        private _isReadyInternal;
        /**
         * The engine the effect was initialized with.
         * @returns the engine.
         */
        getEngine(): Engine;
        /**
         * The pipeline context for this effect
         * @returns the associated pipeline context
         */
        getPipelineContext(): Nullable<IPipelineContext>;
        /**
         * The set of names of attribute variables for the shader.
         * @returns An array of attribute names.
         */
        getAttributesNames(): string[];
        /**
         * Returns the attribute at the given index.
         * @param index The index of the attribute.
         * @returns The location of the attribute.
         */
        getAttributeLocation(index: number): number;
        /**
         * Returns the attribute based on the name of the variable.
         * @param name of the attribute to look up.
         * @returns the attribute location.
         */
        getAttributeLocationByName(name: string): number;
        /**
         * The number of attributes.
         * @returns the numnber of attributes.
         */
        getAttributesCount(): number;
        /**
         * Gets the index of a uniform variable.
         * @param uniformName of the uniform to look up.
         * @returns the index.
         */
        getUniformIndex(uniformName: string): number;
        /**
         * Returns the attribute based on the name of the variable.
         * @param uniformName of the uniform to look up.
         * @returns the location of the uniform.
         */
        getUniform(uniformName: string): Nullable<WebGLUniformLocation>;
        /**
         * Returns an array of sampler variable names
         * @returns The array of sampler variable names.
         */
        getSamplers(): string[];
        /**
         * Returns an array of uniform variable names
         * @returns The array of uniform variable names.
         */
        getUniformNames(): string[];
        /**
         * Returns an array of uniform buffer variable names
         * @returns The array of uniform buffer variable names.
         */
        getUniformBuffersNames(): string[];
        /**
         * Returns the index parameters used to create the effect
         * @returns The index parameters object
         */
        getIndexParameters(): any;
        /**
         * The error from the last compilation.
         * @returns the error string.
         */
        getCompilationError(): string;
        /**
         * Gets a boolean indicating that all fallbacks were used during compilation
         * @returns true if all fallbacks were used
         */
        allFallbacksProcessed(): boolean;
        /**
         * Adds a callback to the onCompiled observable and call the callback imediatly if already ready.
         * @param func The callback to be used.
         */
        executeWhenCompiled(func: (effect: Effect) => void): void;
        private _checkIsReady;
        private _loadShader;
        /**
         * Gets the vertex shader source code of this effect
         */
        get vertexSourceCode(): string;
        /**
         * Gets the fragment shader source code of this effect
         */
        get fragmentSourceCode(): string;
        /**
         * Recompiles the webGL program
         * @param vertexSourceCode The source code for the vertex shader.
         * @param fragmentSourceCode The source code for the fragment shader.
         * @param onCompiled Callback called when completed.
         * @param onError Callback called on error.
         * @hidden
         */
        _rebuildProgram(vertexSourceCode: string, fragmentSourceCode: string, onCompiled: (pipelineContext: IPipelineContext) => void, onError: (message: string) => void): void;
        /**
         * Prepares the effect
         * @hidden
         */
        _prepareEffect(): void;
        private _getShaderCodeAndErrorLine;
        private _processCompilationErrors;
        /**
         * Checks if the effect is supported. (Must be called after compilation)
         */
        get isSupported(): boolean;
        /**
         * Binds a texture to the engine to be used as output of the shader.
         * @param channel Name of the output variable.
         * @param texture Texture to bind.
         * @hidden
         */
        _bindTexture(channel: string, texture: Nullable<InternalTexture>): void;
        /**
         * Sets a texture on the engine to be used in the shader.
         * @param channel Name of the sampler variable.
         * @param texture Texture to set.
         */
        setTexture(channel: string, texture: Nullable<BaseTexture>): void;
        /**
         * Sets a depth stencil texture from a render target on the engine to be used in the shader.
         * @param channel Name of the sampler variable.
         * @param texture Texture to set.
         */
        setDepthStencilTexture(channel: string, texture: Nullable<RenderTargetTexture>): void;
        /**
         * Sets an array of textures on the engine to be used in the shader.
         * @param channel Name of the variable.
         * @param textures Textures to set.
         */
        setTextureArray(channel: string, textures: BaseTexture[]): void;
        /**
         * Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)
         * @param channel Name of the sampler variable.
         * @param postProcess Post process to get the input texture from.
         */
        setTextureFromPostProcess(channel: string, postProcess: Nullable<PostProcess>): void;
        /**
         * (Warning! setTextureFromPostProcessOutput may be desired instead)
         * Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)
         * @param channel Name of the sampler variable.
         * @param postProcess Post process to get the output texture from.
         */
        setTextureFromPostProcessOutput(channel: string, postProcess: Nullable<PostProcess>): void;
        /** @hidden */
        _cacheMatrix(uniformName: string, matrix: IMatrixLike): boolean;
        /** @hidden */
        _cacheFloat2(uniformName: string, x: number, y: number): boolean;
        /** @hidden */
        _cacheFloat3(uniformName: string, x: number, y: number, z: number): boolean;
        /** @hidden */
        _cacheFloat4(uniformName: string, x: number, y: number, z: number, w: number): boolean;
        /**
         * Binds a buffer to a uniform.
         * @param buffer Buffer to bind.
         * @param name Name of the uniform variable to bind to.
         */
        bindUniformBuffer(buffer: DataBuffer, name: string): void;
        /**
         * Binds block to a uniform.
         * @param blockName Name of the block to bind.
         * @param index Index to bind.
         */
        bindUniformBlock(blockName: string, index: number): void;
        /**
         * Sets an interger value on a uniform variable.
         * @param uniformName Name of the variable.
         * @param value Value to be set.
         * @returns this effect.
         */
        setInt(uniformName: string, value: number): Effect;
        /**
         * Sets an int array on a uniform variable.
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setIntArray(uniformName: string, array: Int32Array): Effect;
        /**
         * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setIntArray2(uniformName: string, array: Int32Array): Effect;
        /**
         * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setIntArray3(uniformName: string, array: Int32Array): Effect;
        /**
         * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setIntArray4(uniformName: string, array: Int32Array): Effect;
        /**
         * Sets an float array on a uniform variable.
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setFloatArray(uniformName: string, array: Float32Array): Effect;
        /**
         * Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setFloatArray2(uniformName: string, array: Float32Array): Effect;
        /**
         * Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setFloatArray3(uniformName: string, array: Float32Array): Effect;
        /**
         * Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setFloatArray4(uniformName: string, array: Float32Array): Effect;
        /**
         * Sets an array on a uniform variable.
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setArray(uniformName: string, array: number[]): Effect;
        /**
         * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setArray2(uniformName: string, array: number[]): Effect;
        /**
         * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setArray3(uniformName: string, array: number[]): Effect;
        /**
         * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setArray4(uniformName: string, array: number[]): Effect;
        /**
         * Sets matrices on a uniform variable.
         * @param uniformName Name of the variable.
         * @param matrices matrices to be set.
         * @returns this effect.
         */
        setMatrices(uniformName: string, matrices: Float32Array | Array<number>): Effect;
        /**
         * Sets matrix on a uniform variable.
         * @param uniformName Name of the variable.
         * @param matrix matrix to be set.
         * @returns this effect.
         */
        setMatrix(uniformName: string, matrix: IMatrixLike): Effect;
        /**
         * Sets a 3x3 matrix on a uniform variable. (Speicified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)
         * @param uniformName Name of the variable.
         * @param matrix matrix to be set.
         * @returns this effect.
         */
        setMatrix3x3(uniformName: string, matrix: Float32Array | Array<number>): Effect;
        /**
         * Sets a 2x2 matrix on a uniform variable. (Speicified as [1,2,3,4] will result in [1,2][3,4] matrix)
         * @param uniformName Name of the variable.
         * @param matrix matrix to be set.
         * @returns this effect.
         */
        setMatrix2x2(uniformName: string, matrix: Float32Array | Array<number>): Effect;
        /**
         * Sets a float on a uniform variable.
         * @param uniformName Name of the variable.
         * @param value value to be set.
         * @returns this effect.
         */
        setFloat(uniformName: string, value: number): Effect;
        /**
         * Sets a boolean on a uniform variable.
         * @param uniformName Name of the variable.
         * @param bool value to be set.
         * @returns this effect.
         */
        setBool(uniformName: string, bool: boolean): Effect;
        /**
         * Sets a Vector2 on a uniform variable.
         * @param uniformName Name of the variable.
         * @param vector2 vector2 to be set.
         * @returns this effect.
         */
        setVector2(uniformName: string, vector2: IVector2Like): Effect;
        /**
         * Sets a float2 on a uniform variable.
         * @param uniformName Name of the variable.
         * @param x First float in float2.
         * @param y Second float in float2.
         * @returns this effect.
         */
        setFloat2(uniformName: string, x: number, y: number): Effect;
        /**
         * Sets a Vector3 on a uniform variable.
         * @param uniformName Name of the variable.
         * @param vector3 Value to be set.
         * @returns this effect.
         */
        setVector3(uniformName: string, vector3: IVector3Like): Effect;
        /**
         * Sets a float3 on a uniform variable.
         * @param uniformName Name of the variable.
         * @param x First float in float3.
         * @param y Second float in float3.
         * @param z Third float in float3.
         * @returns this effect.
         */
        setFloat3(uniformName: string, x: number, y: number, z: number): Effect;
        /**
         * Sets a Vector4 on a uniform variable.
         * @param uniformName Name of the variable.
         * @param vector4 Value to be set.
         * @returns this effect.
         */
        setVector4(uniformName: string, vector4: IVector4Like): Effect;
        /**
         * Sets a float4 on a uniform variable.
         * @param uniformName Name of the variable.
         * @param x First float in float4.
         * @param y Second float in float4.
         * @param z Third float in float4.
         * @param w Fourth float in float4.
         * @returns this effect.
         */
        setFloat4(uniformName: string, x: number, y: number, z: number, w: number): Effect;
        /**
         * Sets a Color3 on a uniform variable.
         * @param uniformName Name of the variable.
         * @param color3 Value to be set.
         * @returns this effect.
         */
        setColor3(uniformName: string, color3: IColor3Like): Effect;
        /**
         * Sets a Color4 on a uniform variable.
         * @param uniformName Name of the variable.
         * @param color3 Value to be set.
         * @param alpha Alpha value to be set.
         * @returns this effect.
         */
        setColor4(uniformName: string, color3: IColor3Like, alpha: number): Effect;
        /**
         * Sets a Color4 on a uniform variable
         * @param uniformName defines the name of the variable
         * @param color4 defines the value to be set
         * @returns this effect.
         */
        setDirectColor4(uniformName: string, color4: IColor4Like): Effect;
        /** Release all associated resources */
        dispose(): void;
        /**
         * This function will add a new shader to the shader store
         * @param name the name of the shader
         * @param pixelShader optional pixel shader content
         * @param vertexShader optional vertex shader content
         */
        static RegisterShader(name: string, pixelShader?: string, vertexShader?: string): void;
        /**
         * Store of each shader (The can be looked up using effect.key)
         */
        static ShadersStore: {
            [key: string]: string;
        };
        /**
         * Store of each included file for a shader (The can be looked up using effect.key)
         */
        static IncludesShadersStore: {
            [key: string]: string;
        };
        /**
         * Resets the cache of effects.
         */
        static ResetCache(): void;
    }
}
declare module BABYLON {
    /**
     * Interface used to describe the capabilities of the engine relatively to the current browser
     */
    export interface EngineCapabilities {
        /** Maximum textures units per fragment shader */
        maxTexturesImageUnits: number;
        /** Maximum texture units per vertex shader */
        maxVertexTextureImageUnits: number;
        /** Maximum textures units in the entire pipeline */
        maxCombinedTexturesImageUnits: number;
        /** Maximum texture size */
        maxTextureSize: number;
        /** Maximum texture samples */
        maxSamples?: number;
        /** Maximum cube texture size */
        maxCubemapTextureSize: number;
        /** Maximum render texture size */
        maxRenderTextureSize: number;
        /** Maximum number of vertex attributes */
        maxVertexAttribs: number;
        /** Maximum number of varyings */
        maxVaryingVectors: number;
        /** Maximum number of uniforms per vertex shader */
        maxVertexUniformVectors: number;
        /** Maximum number of uniforms per fragment shader */
        maxFragmentUniformVectors: number;
        /** Defines if standard derivates (dx/dy) are supported */
        standardDerivatives: boolean;
        /** Defines if s3tc texture compression is supported */
        s3tc?: WEBGL_compressed_texture_s3tc;
        /** Defines if pvrtc texture compression is supported */
        pvrtc: any;
        /** Defines if etc1 texture compression is supported */
        etc1: any;
        /** Defines if etc2 texture compression is supported */
        etc2: any;
        /** Defines if astc texture compression is supported */
        astc: any;
        /** Defines if bptc texture compression is supported */
        bptc: any;
        /** Defines if float textures are supported */
        textureFloat: boolean;
        /** Defines if vertex array objects are supported */
        vertexArrayObject: boolean;
        /** Gets the webgl extension for anisotropic filtering (null if not supported) */
        textureAnisotropicFilterExtension?: EXT_texture_filter_anisotropic;
        /** Gets the maximum level of anisotropy supported */
        maxAnisotropy: number;
        /** Defines if instancing is supported */
        instancedArrays: boolean;
        /** Defines if 32 bits indices are supported */
        uintIndices: boolean;
        /** Defines if high precision shaders are supported */
        highPrecisionShaderSupported: boolean;
        /** Defines if depth reading in the fragment shader is supported */
        fragmentDepthSupported: boolean;
        /** Defines if float texture linear filtering is supported*/
        textureFloatLinearFiltering: boolean;
        /** Defines if rendering to float textures is supported */
        textureFloatRender: boolean;
        /** Defines if half float textures are supported*/
        textureHalfFloat: boolean;
        /** Defines if half float texture linear filtering is supported*/
        textureHalfFloatLinearFiltering: boolean;
        /** Defines if rendering to half float textures is supported */
        textureHalfFloatRender: boolean;
        /** Defines if textureLOD shader command is supported */
        textureLOD: boolean;
        /** Defines if draw buffers extension is supported */
        drawBuffersExtension: boolean;
        /** Defines if depth textures are supported */
        depthTextureExtension: boolean;
        /** Defines if float color buffer are supported */
        colorBufferFloat: boolean;
        /** Gets disjoint timer query extension (null if not supported) */
        timerQuery?: EXT_disjoint_timer_query;
        /** Defines if timestamp can be used with timer query */
        canUseTimestampForTimerQuery: boolean;
        /** Defines if multiview is supported (https://www.khronos.org/registry/webgl/extensions/WEBGL_multiview/) */
        multiview?: any;
        /** Defines if oculus multiview is supported (https://developer.oculus.com/documentation/oculus-browser/latest/concepts/browser-multiview/) */
        oculusMultiview?: any;
        /** Function used to let the system compiles shaders in background */
        parallelShaderCompile?: {
            COMPLETION_STATUS_KHR: number;
        };
        /** Max number of texture samples for MSAA */
        maxMSAASamples: number;
        /** Defines if the blend min max extension is supported */
        blendMinMax: boolean;
    }
}
declare module BABYLON {
    /**
     * @hidden
     **/
    export class DepthCullingState {
        private _isDepthTestDirty;
        private _isDepthMaskDirty;
        private _isDepthFuncDirty;
        private _isCullFaceDirty;
        private _isCullDirty;
        private _isZOffsetDirty;
        private _isFrontFaceDirty;
        private _depthTest;
        private _depthMask;
        private _depthFunc;
        private _cull;
        private _cullFace;
        private _zOffset;
        private _frontFace;
        /**
         * Initializes the state.
         */
        constructor();
        get isDirty(): boolean;
        get zOffset(): number;
        set zOffset(value: number);
        get cullFace(): Nullable<number>;
        set cullFace(value: Nullable<number>);
        get cull(): Nullable<boolean>;
        set cull(value: Nullable<boolean>);
        get depthFunc(): Nullable<number>;
        set depthFunc(value: Nullable<number>);
        get depthMask(): boolean;
        set depthMask(value: boolean);
        get depthTest(): boolean;
        set depthTest(value: boolean);
        get frontFace(): Nullable<number>;
        set frontFace(value: Nullable<number>);
        reset(): void;
        apply(gl: WebGLRenderingContext): void;
    }
}
declare module BABYLON {
    /**
     * @hidden
     **/
    export class StencilState {
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn */
        static readonly ALWAYS: number;
        /** Passed to stencilOperation to specify that stencil value must be kept */
        static readonly KEEP: number;
        /** Passed to stencilOperation to specify that stencil value must be replaced */
        static readonly REPLACE: number;
        private _isStencilTestDirty;
        private _isStencilMaskDirty;
        private _isStencilFuncDirty;
        private _isStencilOpDirty;
        private _stencilTest;
        private _stencilMask;
        private _stencilFunc;
        private _stencilFuncRef;
        private _stencilFuncMask;
        private _stencilOpStencilFail;
        private _stencilOpDepthFail;
        private _stencilOpStencilDepthPass;
        get isDirty(): boolean;
        get stencilFunc(): number;
        set stencilFunc(value: number);
        get stencilFuncRef(): number;
        set stencilFuncRef(value: number);
        get stencilFuncMask(): number;
        set stencilFuncMask(value: number);
        get stencilOpStencilFail(): number;
        set stencilOpStencilFail(value: number);
        get stencilOpDepthFail(): number;
        set stencilOpDepthFail(value: number);
        get stencilOpStencilDepthPass(): number;
        set stencilOpStencilDepthPass(value: number);
        get stencilMask(): number;
        set stencilMask(value: number);
        get stencilTest(): boolean;
        set stencilTest(value: boolean);
        constructor();
        reset(): void;
        apply(gl: WebGLRenderingContext): void;
    }
}
declare module BABYLON {
    /**
     * @hidden
     **/
    export class AlphaState {
        private _isAlphaBlendDirty;
        private _isBlendFunctionParametersDirty;
        private _isBlendEquationParametersDirty;
        private _isBlendConstantsDirty;
        private _alphaBlend;
        private _blendFunctionParameters;
        private _blendEquationParameters;
        private _blendConstants;
        /**
         * Initializes the state.
         */
        constructor();
        get isDirty(): boolean;
        get alphaBlend(): boolean;
        set alphaBlend(value: boolean);
        setAlphaBlendConstants(r: number, g: number, b: number, a: number): void;
        setAlphaBlendFunctionParameters(value0: number, value1: number, value2: number, value3: number): void;
        setAlphaEquationParameters(rgb: number, alpha: number): void;
        reset(): void;
        apply(gl: WebGLRenderingContext): void;
    }
}
declare module BABYLON {
    /** @hidden */
    export class WebGL2ShaderProcessor implements IShaderProcessor {
        attributeProcessor(attribute: string): string;
        varyingProcessor(varying: string, isFragment: boolean): string;
        postProcessor(code: string, defines: string[], isFragment: boolean): string;
    }
}
declare module BABYLON {
    /**
     * Interface for attribute information associated with buffer instanciation
     */
    export interface InstancingAttributeInfo {
        /**
         * Name of the GLSL attribute
         * if attribute index is not specified, this is used to retrieve the index from the effect
         */
        attributeName: string;
        /**
         * Index/offset of the attribute in the vertex shader
         * if not specified, this will be computes from the name.
         */
        index?: number;
        /**
         * size of the attribute, 1, 2, 3 or 4
         */
        attributeSize: number;
        /**
         * Offset of the data in the Vertex Buffer acting as the instancing buffer
         */
        offset: number;
        /**
         * Modifies the rate at which generic vertex attributes advance when rendering multiple instances
         * default to 1
         */
        divisor?: number;
        /**
         * type of the attribute, gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.FIXED, gl.FLOAT.
         * default is FLOAT
         */
        attributeType?: number;
        /**
         * normalization of fixed-point data. behavior unclear, use FALSE, default is FALSE
         */
        normalized?: boolean;
    }
}
declare module BABYLON {
        interface ThinEngine {
            /**
             * Update a video texture
             * @param texture defines the texture to update
             * @param video defines the video element to use
             * @param invertY defines if data must be stored with Y axis inverted
             */
            updateVideoTexture(texture: Nullable<InternalTexture>, video: HTMLVideoElement, invertY: boolean): void;
        }
}
declare module BABYLON {
        interface ThinEngine {
            /**
             * Creates a dynamic texture
             * @param width defines the width of the texture
             * @param height defines the height of the texture
             * @param generateMipMaps defines if the engine should generate the mip levels
             * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)
             * @returns the dynamic texture inside an InternalTexture
             */
            createDynamicTexture(width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture;
            /**
             * Update the content of a dynamic texture
             * @param texture defines the texture to update
             * @param canvas defines the canvas containing the source
             * @param invertY defines if data must be stored with Y axis inverted
             * @param premulAlpha defines if alpha is stored as premultiplied
             * @param format defines the format of the data
             * @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)
             */
            updateDynamicTexture(texture: Nullable<InternalTexture>, canvas: HTMLCanvasElement | OffscreenCanvas, invertY: boolean, premulAlpha?: boolean, format?: number, forceBindTexture?: boolean): void;
        }
}
declare module BABYLON {
    /**
     * Settings for finer control over video usage
     */
    export interface VideoTextureSettings {
        /**
         * Applies `autoplay` to video, if specified
         */
        autoPlay?: boolean;
        /**
         * Applies `loop` to video, if specified
         */
        loop?: boolean;
        /**
         * Automatically updates internal texture from video at every frame in the render loop
         */
        autoUpdateTexture: boolean;
        /**
         * Image src displayed during the video loading or until the user interacts with the video.
         */
        poster?: string;
    }
    /**
     * If you want to display a video in your scene, this is the special texture for that.
     * This special texture works similar to other textures, with the exception of a few parameters.
     * @see https://doc.babylonjs.com/how_to/video_texture
     */
    export class VideoTexture extends Texture {
        /**
         * Tells whether textures will be updated automatically or user is required to call `updateTexture` manually
         */
        readonly autoUpdateTexture: boolean;
        /**
         * The video instance used by the texture internally
         */
        readonly video: HTMLVideoElement;
        private _onUserActionRequestedObservable;
        /**
         * Event triggerd when a dom action is required by the user to play the video.
         * This happens due to recent changes in browser policies preventing video to auto start.
         */
        get onUserActionRequestedObservable(): Observable<Texture>;
        private _generateMipMaps;
        private _stillImageCaptured;
        private _displayingPosterTexture;
        private _settings;
        private _createInternalTextureOnEvent;
        private _frameId;
        private _currentSrc;
        /**
         * Creates a video texture.
         * If you want to display a video in your scene, this is the special texture for that.
         * This special texture works similar to other textures, with the exception of a few parameters.
         * @see https://doc.babylonjs.com/how_to/video_texture
         * @param name optional name, will detect from video source, if not defined
         * @param src can be used to provide an url, array of urls or an already setup HTML video element.
         * @param scene is obviously the current scene.
         * @param generateMipMaps can be used to turn on mipmaps (Can be expensive for videoTextures because they are often updated).
         * @param invertY is false by default but can be used to invert video on Y axis
         * @param samplingMode controls the sampling method and is set to TRILINEAR_SAMPLINGMODE by default
         * @param settings allows finer control over video usage
         */
        constructor(name: Nullable<string>, src: string | string[] | HTMLVideoElement, scene: Nullable<Scene>, generateMipMaps?: boolean, invertY?: boolean, samplingMode?: number, settings?: VideoTextureSettings);
        private _getName;
        private _getVideo;
        private _createInternalTexture;
        private reset;
        /**
         * @hidden Internal method to initiate `update`.
         */
        _rebuild(): void;
        /**
         * Update Texture in the `auto` mode. Does not do anything if `settings.autoUpdateTexture` is false.
         */
        update(): void;
        /**
         * Update Texture in `manual` mode. Does not do anything if not visible or paused.
         * @param isVisible Visibility state, detected by user using `scene.getActiveMeshes()` or othervise.
         */
        updateTexture(isVisible: boolean): void;
        protected _updateInternalTexture: () => void;
        /**
         * Change video content. Changing video instance or setting multiple urls (as in constructor) is not supported.
         * @param url New url.
         */
        updateURL(url: string): void;
        /**
         * Clones the texture.
         * @returns the cloned texture
         */
        clone(): VideoTexture;
        /**
         * Dispose the texture and release its associated resources.
         */
        dispose(): void;
        /**
         * Creates a video texture straight from a stream.
         * @param scene Define the scene the texture should be created in
         * @param stream Define the stream the texture should be created from
         * @returns The created video texture as a promise
         */
        static CreateFromStreamAsync(scene: Scene, stream: MediaStream): Promise<VideoTexture>;
        /**
         * Creates a video texture straight from your WebCam video feed.
         * @param scene Define the scene the texture should be created in
         * @param constraints Define the constraints to use to create the web cam feed from WebRTC
         * @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC
         * @returns The created video texture as a promise
         */
        static CreateFromWebCamAsync(scene: Scene, constraints: {
            minWidth: number;
            maxWidth: number;
            minHeight: number;
            maxHeight: number;
            deviceId: string;
        } & MediaTrackConstraints, audioConstaints?: boolean | MediaTrackConstraints): Promise<VideoTexture>;
        /**
         * Creates a video texture straight from your WebCam video feed.
         * @param scene Define the scene the texture should be created in
         * @param onReady Define a callback to triggered once the texture will be ready
         * @param constraints Define the constraints to use to create the web cam feed from WebRTC
         * @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC
         */
        static CreateFromWebCam(scene: Scene, onReady: (videoTexture: VideoTexture) => void, constraints: {
            minWidth: number;
            maxWidth: number;
            minHeight: number;
            maxHeight: number;
            deviceId: string;
        } & MediaTrackConstraints, audioConstaints?: boolean | MediaTrackConstraints): void;
    }
}
declare module BABYLON {
    /**
     * Defines the interface used by objects working like Scene
     * @hidden
     */
    export interface ISceneLike {
        _addPendingData(data: any): void;
        _removePendingData(data: any): void;
        offlineProvider: IOfflineProvider;
    }
    /**
     * Information about the current host
     */
    export interface HostInformation {
        /**
         * Defines if the current host is a mobile
         */
        isMobile: boolean;
    }
    /** Interface defining initialization parameters for Engine class */
    export interface EngineOptions extends WebGLContextAttributes {
        /**
         * Defines if the engine should no exceed a specified device ratio
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio
         */
        limitDeviceRatio?: number;
        /**
         * Defines if webvr should be enabled automatically
         * @see https://doc.babylonjs.com/how_to/webvr_camera
         */
        autoEnableWebVR?: boolean;
        /**
         * Defines if webgl2 should be turned off even if supported
         * @see https://doc.babylonjs.com/features/webgl2
         */
        disableWebGL2Support?: boolean;
        /**
         * Defines if webaudio should be initialized as well
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music
         */
        audioEngine?: boolean;
        /**
         * Defines if animations should run using a deterministic lock step
         * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         */
        deterministicLockstep?: boolean;
        /** Defines the maximum steps to use with deterministic lock step mode */
        lockstepMaxSteps?: number;
        /** Defines the seconds between each deterministic lock step */
        timeStep?: number;
        /**
         * Defines that engine should ignore context lost events
         * If this event happens when this parameter is true, you will have to reload the page to restore rendering
         */
        doNotHandleContextLost?: boolean;
        /**
         * Defines that engine should ignore modifying touch action attribute and style
         * If not handle, you might need to set it up on your side for expected touch devices behavior.
         */
        doNotHandleTouchAction?: boolean;
        /**
         * Defines that engine should compile shaders with high precision floats (if supported). True by default
         */
        useHighPrecisionFloats?: boolean;
        /**
         * Make the canvas XR Compatible for XR sessions
         */
        xrCompatible?: boolean;
        /**
         * Make the matrix computations to be performed in 64 bits instead of 32 bits. False by default
         */
        useHighPrecisionMatrix?: boolean;
    }
    /**
     * The base engine class (root of all engines)
     */
    export class ThinEngine {
        /** Use this array to turn off some WebGL2 features on known buggy browsers version */
        static ExceptionList: ({
            key: string;
            capture: string;
            captureConstraint: number;
            targets: string[];
        } | {
            key: string;
            capture: null;
            captureConstraint: null;
            targets: string[];
        })[];
        /** @hidden */
        static _TextureLoaders: IInternalTextureLoader[];
        /**
         * Returns the current npm package of the sdk
         */
        static get NpmPackage(): string;
        /**
         * Returns the current version of the framework
         */
        static get Version(): string;
        /**
         * Returns a string describing the current engine
         */
        get description(): string;
        /**
         * Gets or sets the epsilon value used by collision engine
         */
        static CollisionsEpsilon: number;
        /**
         * Gets or sets the relative url used to load shaders if using the engine in non-minified mode
         */
        static get ShadersRepository(): string;
        static set ShadersRepository(value: string);
        /** @hidden */
        _shaderProcessor: IShaderProcessor;
        /**
         * Gets or sets a boolean that indicates if textures must be forced to power of 2 size even if not required
         */
        forcePOTTextures: boolean;
        /**
         * Gets a boolean indicating if the engine is currently rendering in fullscreen mode
         */
        isFullscreen: boolean;
        /**
         * Gets or sets a boolean indicating if back faces must be culled (true by default)
         */
        cullBackFaces: boolean;
        /**
         * Gets or sets a boolean indicating if the engine must keep rendering even if the window is not in foregroun
         */
        renderEvenInBackground: boolean;
        /**
         * Gets or sets a boolean indicating that cache can be kept between frames
         */
        preventCacheWipeBetweenFrames: boolean;
        /** Gets or sets a boolean indicating if the engine should validate programs after compilation */
        validateShaderPrograms: boolean;
        /**
         * Gets or sets a boolean indicating if depth buffer should be reverse, going from far to near.
         * This can provide greater z depth for distant objects.
         */
        useReverseDepthBuffer: boolean;
        /**
         * Gets or sets a boolean indicating that uniform buffers must be disabled even if they are supported
         */
        disableUniformBuffers: boolean;
        /** @hidden */
        _uniformBuffers: UniformBuffer[];
        /**
         * Gets a boolean indicating that the engine supports uniform buffers
         * @see https://doc.babylonjs.com/features/webgl2#uniform-buffer-objets
         */
        get supportsUniformBuffers(): boolean;
        /** @hidden */
        _gl: WebGLRenderingContext;
        /** @hidden */
        _webGLVersion: number;
        protected _renderingCanvas: Nullable<HTMLCanvasElement>;
        protected _windowIsBackground: boolean;
        protected _creationOptions: EngineOptions;
        protected _highPrecisionShadersAllowed: boolean;
        /** @hidden */
        get _shouldUseHighPrecisionShader(): boolean;
        /**
         * Gets a boolean indicating that only power of 2 textures are supported
         * Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them
         */
        get needPOTTextures(): boolean;
        /** @hidden */
        _badOS: boolean;
        /** @hidden */
        _badDesktopOS: boolean;
        private _hardwareScalingLevel;
        /** @hidden */
        _caps: EngineCapabilities;
        private _isStencilEnable;
        private _glVersion;
        private _glRenderer;
        private _glVendor;
        /** @hidden */
        _videoTextureSupported: boolean;
        protected _renderingQueueLaunched: boolean;
        protected _activeRenderLoops: (() => void)[];
        /**
         * Observable signaled when a context lost event is raised
         */
        onContextLostObservable: Observable<ThinEngine>;
        /**
         * Observable signaled when a context restored event is raised
         */
        onContextRestoredObservable: Observable<ThinEngine>;
        private _onContextLost;
        private _onContextRestored;
        protected _contextWasLost: boolean;
        /** @hidden */
        _doNotHandleContextLost: boolean;
        /**
         * Gets or sets a boolean indicating if resources should be retained to be able to handle context lost events
         * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#handling-webgl-context-lost
         */
        get doNotHandleContextLost(): boolean;
        set doNotHandleContextLost(value: boolean);
        /**
         * Gets or sets a boolean indicating that vertex array object must be disabled even if they are supported
         */
        disableVertexArrayObjects: boolean;
        /** @hidden */
        protected _colorWrite: boolean;
        /** @hidden */
        protected _colorWriteChanged: boolean;
        /** @hidden */
        protected _depthCullingState: DepthCullingState;
        /** @hidden */
        protected _stencilState: StencilState;
        /** @hidden */
        _alphaState: AlphaState;
        /** @hidden */
        _alphaMode: number;
        /** @hidden */
        _alphaEquation: number;
        /** @hidden */
        _internalTexturesCache: InternalTexture[];
        /** @hidden */
        protected _activeChannel: number;
        private _currentTextureChannel;
        /** @hidden */
        protected _boundTexturesCache: {
            [key: string]: Nullable<InternalTexture>;
        };
        /** @hidden */
        protected _currentEffect: Nullable<Effect>;
        /** @hidden */
        protected _currentProgram: Nullable<WebGLProgram>;
        private _compiledEffects;
        private _vertexAttribArraysEnabled;
        /** @hidden */
        protected _cachedViewport: Nullable<IViewportLike>;
        private _cachedVertexArrayObject;
        /** @hidden */
        protected _cachedVertexBuffers: any;
        /** @hidden */
        protected _cachedIndexBuffer: Nullable<DataBuffer>;
        /** @hidden */
        protected _cachedEffectForVertexBuffers: Nullable<Effect>;
        /** @hidden */
        _currentRenderTarget: Nullable<InternalTexture>;
        private _uintIndicesCurrentlySet;
        protected _currentBoundBuffer: Nullable<WebGLBuffer>[];
        /** @hidden */
        _currentFramebuffer: Nullable<WebGLFramebuffer>;
        /** @hidden */
        _dummyFramebuffer: Nullable<WebGLFramebuffer>;
        private _currentBufferPointers;
        private _currentInstanceLocations;
        private _currentInstanceBuffers;
        private _textureUnits;
        /** @hidden */
        _workingCanvas: Nullable<HTMLCanvasElement | OffscreenCanvas>;
        /** @hidden */
        _workingContext: Nullable<CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D>;
        /** @hidden */
        _boundRenderFunction: any;
        private _vaoRecordInProgress;
        private _mustWipeVertexAttributes;
        private _emptyTexture;
        private _emptyCubeTexture;
        private _emptyTexture3D;
        private _emptyTexture2DArray;
        /** @hidden */
        _frameHandler: number;
        private _nextFreeTextureSlots;
        private _maxSimultaneousTextures;
        private _activeRequests;
        /** @hidden */
        _transformTextureUrl: Nullable<(url: string) => string>;
        /**
         * Gets information about the current host
         */
        hostInformation: HostInformation;
        protected get _supportsHardwareTextureRescaling(): boolean;
        private _framebufferDimensionsObject;
        /**
         * sets the object from which width and height will be taken from when getting render width and height
         * Will fallback to the gl object
         * @param dimensions the framebuffer width and height that will be used.
         */
        set framebufferDimensionsObject(dimensions: Nullable<{
            framebufferWidth: number;
            framebufferHeight: number;
        }>);
        /**
         * Gets the current viewport
         */
        get currentViewport(): Nullable<IViewportLike>;
        /**
         * Gets the default empty texture
         */
        get emptyTexture(): InternalTexture;
        /**
         * Gets the default empty 3D texture
         */
        get emptyTexture3D(): InternalTexture;
        /**
         * Gets the default empty 2D array texture
         */
        get emptyTexture2DArray(): InternalTexture;
        /**
         * Gets the default empty cube texture
         */
        get emptyCubeTexture(): InternalTexture;
        /**
         * Defines whether the engine has been created with the premultipliedAlpha option on or not.
         */
        readonly premultipliedAlpha: boolean;
        /**
         * Observable event triggered before each texture is initialized
         */
        onBeforeTextureInitObservable: Observable<Texture>;
        /**
         * Creates a new engine
         * @param canvasOrContext defines the canvas or WebGL context to use for rendering. If you provide a WebGL context, Babylon.js will not hook events on the canvas (like pointers, keyboards, etc...) so no event observables will be available. This is mostly used when Babylon.js is used as a plugin on a system which alreay used the WebGL context
         * @param antialias defines enable antialiasing (default: false)
         * @param options defines further options to be sent to the getContext() function
         * @param adaptToDeviceRatio defines whether to adapt to the device's viewport characteristics (default: false)
         */
        constructor(canvasOrContext: Nullable<HTMLCanvasElement | WebGLRenderingContext | WebGL2RenderingContext>, antialias?: boolean, options?: EngineOptions, adaptToDeviceRatio?: boolean);
        private _rebuildInternalTextures;
        private _rebuildEffects;
        /**
         * Gets a boolean indicating if all created effects are ready
         * @returns true if all effects are ready
         */
        areAllEffectsReady(): boolean;
        protected _rebuildBuffers(): void;
        protected _initGLContext(): void;
        /**
         * Gets version of the current webGL context
         */
        get webGLVersion(): number;
        /**
         * Gets a string identifying the name of the class
         * @returns "Engine" string
         */
        getClassName(): string;
        /**
         * Returns true if the stencil buffer has been enabled through the creation option of the context.
         */
        get isStencilEnable(): boolean;
        /** @hidden */
        _prepareWorkingCanvas(): void;
        /**
         * Reset the texture cache to empty state
         */
        resetTextureCache(): void;
        /**
         * Gets an object containing information about the current webGL context
         * @returns an object containing the vender, the renderer and the version of the current webGL context
         */
        getGlInfo(): {
            vendor: string;
            renderer: string;
            version: string;
        };
        /**
         * Defines the hardware scaling level.
         * By default the hardware scaling level is computed from the window device ratio.
         * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.
         * @param level defines the level to use
         */
        setHardwareScalingLevel(level: number): void;
        /**
         * Gets the current hardware scaling level.
         * By default the hardware scaling level is computed from the window device ratio.
         * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.
         * @returns a number indicating the current hardware scaling level
         */
        getHardwareScalingLevel(): number;
        /**
         * Gets the list of loaded textures
         * @returns an array containing all loaded textures
         */
        getLoadedTexturesCache(): InternalTexture[];
        /**
         * Gets the object containing all engine capabilities
         * @returns the EngineCapabilities object
         */
        getCaps(): EngineCapabilities;
        /**
         * stop executing a render loop function and remove it from the execution array
         * @param renderFunction defines the function to be removed. If not provided all functions will be removed.
         */
        stopRenderLoop(renderFunction?: () => void): void;
        /** @hidden */
        _renderLoop(): void;
        /**
         * Gets the HTML canvas attached with the current webGL context
         * @returns a HTML canvas
         */
        getRenderingCanvas(): Nullable<HTMLCanvasElement>;
        /**
         * Gets host window
         * @returns the host window object
         */
        getHostWindow(): Nullable<Window>;
        /**
         * Gets the current render width
         * @param useScreen defines if screen size must be used (or the current render target if any)
         * @returns a number defining the current render width
         */
        getRenderWidth(useScreen?: boolean): number;
        /**
         * Gets the current render height
         * @param useScreen defines if screen size must be used (or the current render target if any)
         * @returns a number defining the current render height
         */
        getRenderHeight(useScreen?: boolean): number;
        /**
         * Can be used to override the current requestAnimationFrame requester.
         * @hidden
         */
        protected _queueNewFrame(bindedRenderFunction: any, requester?: any): number;
        /**
         * Register and execute a render loop. The engine can have more than one render function
         * @param renderFunction defines the function to continuously execute
         */
        runRenderLoop(renderFunction: () => void): void;
        /**
         * Clear the current render buffer or the current render target (if any is set up)
         * @param color defines the color to use
         * @param backBuffer defines if the back buffer must be cleared
         * @param depth defines if the depth buffer must be cleared
         * @param stencil defines if the stencil buffer must be cleared
         */
        clear(color: Nullable<IColor4Like>, backBuffer: boolean, depth: boolean, stencil?: boolean): void;
        private _viewportCached;
        /** @hidden */
        _viewport(x: number, y: number, width: number, height: number): void;
        /**
         * Set the WebGL's viewport
         * @param viewport defines the viewport element to be used
         * @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used
         * @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used
         */
        setViewport(viewport: IViewportLike, requiredWidth?: number, requiredHeight?: number): void;
        /**
         * Begin a new frame
         */
        beginFrame(): void;
        /**
         * Enf the current frame
         */
        endFrame(): void;
        /**
         * Resize the view according to the canvas' size
         */
        resize(): void;
        /**
         * Force a specific size of the canvas
         * @param width defines the new canvas' width
         * @param height defines the new canvas' height
         * @returns true if the size was changed
         */
        setSize(width: number, height: number): boolean;
        /**
         * Binds the frame buffer to the specified texture.
         * @param texture The texture to render to or null for the default canvas
         * @param faceIndex The face of the texture to render to in case of cube texture
         * @param requiredWidth The width of the target to render to
         * @param requiredHeight The height of the target to render to
         * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true
         * @param lodLevel defines the lod level to bind to the frame buffer
         * @param layer defines the 2d array index to bind to frame buffer to
         */
        bindFramebuffer(texture: InternalTexture, faceIndex?: number, requiredWidth?: number, requiredHeight?: number, forceFullscreenViewport?: boolean, lodLevel?: number, layer?: number): void;
        /** @hidden */
        _bindUnboundFramebuffer(framebuffer: Nullable<WebGLFramebuffer>): void;
        /**
         * Unbind the current render target texture from the webGL context
         * @param texture defines the render target texture to unbind
         * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated
         * @param onBeforeUnbind defines a function which will be called before the effective unbind
         */
        unBindFramebuffer(texture: InternalTexture, disableGenerateMipMaps?: boolean, onBeforeUnbind?: () => void): void;
        /**
         * Force a webGL flush (ie. a flush of all waiting webGL commands)
         */
        flushFramebuffer(): void;
        /**
         * Unbind the current render target and bind the default framebuffer
         */
        restoreDefaultFramebuffer(): void;
        /** @hidden */
        protected _resetVertexBufferBinding(): void;
        /**
         * Creates a vertex buffer
         * @param data the data for the vertex buffer
         * @returns the new WebGL static buffer
         */
        createVertexBuffer(data: DataArray): DataBuffer;
        private _createVertexBuffer;
        /**
         * Creates a dynamic vertex buffer
         * @param data the data for the dynamic vertex buffer
         * @returns the new WebGL dynamic buffer
         */
        createDynamicVertexBuffer(data: DataArray): DataBuffer;
        protected _resetIndexBufferBinding(): void;
        /**
         * Creates a new index buffer
         * @param indices defines the content of the index buffer
         * @param updatable defines if the index buffer must be updatable
         * @returns a new webGL buffer
         */
        createIndexBuffer(indices: IndicesArray, updatable?: boolean): DataBuffer;
        protected _normalizeIndexData(indices: IndicesArray): Uint16Array | Uint32Array;
        /**
         * Bind a webGL buffer to the webGL context
         * @param buffer defines the buffer to bind
         */
        bindArrayBuffer(buffer: Nullable<DataBuffer>): void;
        protected bindIndexBuffer(buffer: Nullable<DataBuffer>): void;
        private bindBuffer;
        /**
         * update the bound buffer with the given data
         * @param data defines the data to update
         */
        updateArrayBuffer(data: Float32Array): void;
        private _vertexAttribPointer;
        /** @hidden */
        _bindIndexBufferWithCache(indexBuffer: Nullable<DataBuffer>): void;
        private _bindVertexBuffersAttributes;
        /**
         * Records a vertex array object
         * @see https://doc.babylonjs.com/features/webgl2#vertex-array-objects
         * @param vertexBuffers defines the list of vertex buffers to store
         * @param indexBuffer defines the index buffer to store
         * @param effect defines the effect to store
         * @returns the new vertex array object
         */
        recordVertexArrayObject(vertexBuffers: {
            [key: string]: VertexBuffer;
        }, indexBuffer: Nullable<DataBuffer>, effect: Effect): WebGLVertexArrayObject;
        /**
         * Bind a specific vertex array object
         * @see https://doc.babylonjs.com/features/webgl2#vertex-array-objects
         * @param vertexArrayObject defines the vertex array object to bind
         * @param indexBuffer defines the index buffer to bind
         */
        bindVertexArrayObject(vertexArrayObject: WebGLVertexArrayObject, indexBuffer: Nullable<DataBuffer>): void;
        /**
         * Bind webGl buffers directly to the webGL context
         * @param vertexBuffer defines the vertex buffer to bind
         * @param indexBuffer defines the index buffer to bind
         * @param vertexDeclaration defines the vertex declaration to use with the vertex buffer
         * @param vertexStrideSize defines the vertex stride of the vertex buffer
         * @param effect defines the effect associated with the vertex buffer
         */
        bindBuffersDirectly(vertexBuffer: DataBuffer, indexBuffer: DataBuffer, vertexDeclaration: number[], vertexStrideSize: number, effect: Effect): void;
        private _unbindVertexArrayObject;
        /**
         * Bind a list of vertex buffers to the webGL context
         * @param vertexBuffers defines the list of vertex buffers to bind
         * @param indexBuffer defines the index buffer to bind
         * @param effect defines the effect associated with the vertex buffers
         */
        bindBuffers(vertexBuffers: {
            [key: string]: Nullable<VertexBuffer>;
        }, indexBuffer: Nullable<DataBuffer>, effect: Effect): void;
        /**
         * Unbind all instance attributes
         */
        unbindInstanceAttributes(): void;
        /**
         * Release and free the memory of a vertex array object
         * @param vao defines the vertex array object to delete
         */
        releaseVertexArrayObject(vao: WebGLVertexArrayObject): void;
        /** @hidden */
        _releaseBuffer(buffer: DataBuffer): boolean;
        protected _deleteBuffer(buffer: DataBuffer): void;
        /**
         * Update the content of a webGL buffer used with instanciation and bind it to the webGL context
         * @param instancesBuffer defines the webGL buffer to update and bind
         * @param data defines the data to store in the buffer
         * @param offsetLocations defines the offsets or attributes information used to determine where data must be stored in the buffer
         */
        updateAndBindInstancesBuffer(instancesBuffer: DataBuffer, data: Float32Array, offsetLocations: number[] | InstancingAttributeInfo[]): void;
        /**
         * Bind the content of a webGL buffer used with instantiation
         * @param instancesBuffer defines the webGL buffer to bind
         * @param attributesInfo defines the offsets or attributes information used to determine where data must be stored in the buffer
         * @param computeStride defines Whether to compute the strides from the info or use the default 0
         */
        bindInstancesBuffer(instancesBuffer: DataBuffer, attributesInfo: InstancingAttributeInfo[], computeStride?: boolean): void;
        /**
         * Disable the instance attribute corresponding to the name in parameter
         * @param name defines the name of the attribute to disable
         */
        disableInstanceAttributeByName(name: string): void;
        /**
         * Disable the instance attribute corresponding to the location in parameter
         * @param attributeLocation defines the attribute location of the attribute to disable
         */
        disableInstanceAttribute(attributeLocation: number): void;
        /**
         * Disable the attribute corresponding to the location in parameter
         * @param attributeLocation defines the attribute location of the attribute to disable
         */
        disableAttributeByIndex(attributeLocation: number): void;
        /**
         * Send a draw order
         * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)
         * @param indexStart defines the starting index
         * @param indexCount defines the number of index to draw
         * @param instancesCount defines the number of instances to draw (if instanciation is enabled)
         */
        draw(useTriangles: boolean, indexStart: number, indexCount: number, instancesCount?: number): void;
        /**
         * Draw a list of points
         * @param verticesStart defines the index of first vertex to draw
         * @param verticesCount defines the count of vertices to draw
         * @param instancesCount defines the number of instances to draw (if instanciation is enabled)
         */
        drawPointClouds(verticesStart: number, verticesCount: number, instancesCount?: number): void;
        /**
         * Draw a list of unindexed primitives
         * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)
         * @param verticesStart defines the index of first vertex to draw
         * @param verticesCount defines the count of vertices to draw
         * @param instancesCount defines the number of instances to draw (if instanciation is enabled)
         */
        drawUnIndexed(useTriangles: boolean, verticesStart: number, verticesCount: number, instancesCount?: number): void;
        /**
         * Draw a list of indexed primitives
         * @param fillMode defines the primitive to use
         * @param indexStart defines the starting index
         * @param indexCount defines the number of index to draw
         * @param instancesCount defines the number of instances to draw (if instanciation is enabled)
         */
        drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount?: number): void;
        /**
         * Draw a list of unindexed primitives
         * @param fillMode defines the primitive to use
         * @param verticesStart defines the index of first vertex to draw
         * @param verticesCount defines the count of vertices to draw
         * @param instancesCount defines the number of instances to draw (if instanciation is enabled)
         */
        drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount?: number): void;
        private _drawMode;
        /** @hidden */
        protected _reportDrawCall(): void;
        /** @hidden */
        _releaseEffect(effect: Effect): void;
        /** @hidden */
        _deletePipelineContext(pipelineContext: IPipelineContext): void;
        /**
         * Create a new effect (used to store vertex/fragment shaders)
         * @param baseName defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)
         * @param attributesNamesOrOptions defines either a list of attribute names or an IEffectCreationOptions object
         * @param uniformsNamesOrEngine defines either a list of uniform names or the engine to use
         * @param samplers defines an array of string used to represent textures
         * @param defines defines the string containing the defines to use to compile the shaders
         * @param fallbacks defines the list of potential fallbacks to use if shader conmpilation fails
         * @param onCompiled defines a function to call when the effect creation is successful
         * @param onError defines a function to call when the effect creation has failed
         * @param indexParameters defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)
         * @returns the new Effect
         */
        createEffect(baseName: any, attributesNamesOrOptions: string[] | IEffectCreationOptions, uniformsNamesOrEngine: string[] | ThinEngine, samplers?: string[], defines?: string, fallbacks?: IEffectFallbacks, onCompiled?: Nullable<(effect: Effect) => void>, onError?: Nullable<(effect: Effect, errors: string) => void>, indexParameters?: any): Effect;
        protected static _ConcatenateShader(source: string, defines: Nullable<string>, shaderVersion?: string): string;
        private _compileShader;
        private _compileRawShader;
        /** @hidden */
        _getShaderSource(shader: WebGLShader): Nullable<string>;
        /**
         * Directly creates a webGL program
         * @param pipelineContext  defines the pipeline context to attach to
         * @param vertexCode defines the vertex shader code to use
         * @param fragmentCode defines the fragment shader code to use
         * @param context defines the webGL context to use (if not set, the current one will be used)
         * @param transformFeedbackVaryings defines the list of transform feedback varyings to use
         * @returns the new webGL program
         */
        createRawShaderProgram(pipelineContext: IPipelineContext, vertexCode: string, fragmentCode: string, context?: WebGLRenderingContext, transformFeedbackVaryings?: Nullable<string[]>): WebGLProgram;
        /**
         * Creates a webGL program
         * @param pipelineContext  defines the pipeline context to attach to
         * @param vertexCode  defines the vertex shader code to use
         * @param fragmentCode defines the fragment shader code to use
         * @param defines defines the string containing the defines to use to compile the shaders
         * @param context defines the webGL context to use (if not set, the current one will be used)
         * @param transformFeedbackVaryings defines the list of transform feedback varyings to use
         * @returns the new webGL program
         */
        createShaderProgram(pipelineContext: IPipelineContext, vertexCode: string, fragmentCode: string, defines: Nullable<string>, context?: WebGLRenderingContext, transformFeedbackVaryings?: Nullable<string[]>): WebGLProgram;
        /**
         * Creates a new pipeline context
         * @returns the new pipeline
         */
        createPipelineContext(): IPipelineContext;
        protected _createShaderProgram(pipelineContext: WebGLPipelineContext, vertexShader: WebGLShader, fragmentShader: WebGLShader, context: WebGLRenderingContext, transformFeedbackVaryings?: Nullable<string[]>): WebGLProgram;
        protected _finalizePipelineContext(pipelineContext: WebGLPipelineContext): void;
        /** @hidden */
        _preparePipelineContext(pipelineContext: IPipelineContext, vertexSourceCode: string, fragmentSourceCode: string, createAsRaw: boolean, rebuildRebind: any, defines: Nullable<string>, transformFeedbackVaryings: Nullable<string[]>): void;
        /** @hidden */
        _isRenderingStateCompiled(pipelineContext: IPipelineContext): boolean;
        /** @hidden */
        _executeWhenRenderingStateIsCompiled(pipelineContext: IPipelineContext, action: () => void): void;
        /**
         * Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names
         * @param pipelineContext defines the pipeline context to use
         * @param uniformsNames defines the list of uniform names
         * @returns an array of webGL uniform locations
         */
        getUniforms(pipelineContext: IPipelineContext, uniformsNames: string[]): Nullable<WebGLUniformLocation>[];
        /**
         * Gets the lsit of active attributes for a given webGL program
         * @param pipelineContext defines the pipeline context to use
         * @param attributesNames defines the list of attribute names to get
         * @returns an array of indices indicating the offset of each attribute
         */
        getAttributes(pipelineContext: IPipelineContext, attributesNames: string[]): number[];
        /**
         * Activates an effect, mkaing it the current one (ie. the one used for rendering)
         * @param effect defines the effect to activate
         */
        enableEffect(effect: Nullable<Effect>): void;
        /**
         * Set the value of an uniform to a number (int)
         * @param uniform defines the webGL uniform location where to store the value
         * @param value defines the int number to store
         */
        setInt(uniform: Nullable<WebGLUniformLocation>, value: number): void;
        /**
         * Set the value of an uniform to an array of int32
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of int32 to store
         */
        setIntArray(uniform: Nullable<WebGLUniformLocation>, array: Int32Array): void;
        /**
         * Set the value of an uniform to an array of int32 (stored as vec2)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of int32 to store
         */
        setIntArray2(uniform: Nullable<WebGLUniformLocation>, array: Int32Array): void;
        /**
         * Set the value of an uniform to an array of int32 (stored as vec3)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of int32 to store
         */
        setIntArray3(uniform: Nullable<WebGLUniformLocation>, array: Int32Array): void;
        /**
         * Set the value of an uniform to an array of int32 (stored as vec4)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of int32 to store
         */
        setIntArray4(uniform: Nullable<WebGLUniformLocation>, array: Int32Array): void;
        /**
         * Set the value of an uniform to an array of number
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of number to store
         */
        setArray(uniform: Nullable<WebGLUniformLocation>, array: number[] | Float32Array): void;
        /**
         * Set the value of an uniform to an array of number (stored as vec2)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of number to store
         */
        setArray2(uniform: Nullable<WebGLUniformLocation>, array: number[] | Float32Array): void;
        /**
         * Set the value of an uniform to an array of number (stored as vec3)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of number to store
         */
        setArray3(uniform: Nullable<WebGLUniformLocation>, array: number[] | Float32Array): void;
        /**
         * Set the value of an uniform to an array of number (stored as vec4)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of number to store
         */
        setArray4(uniform: Nullable<WebGLUniformLocation>, array: number[] | Float32Array): void;
        /**
         * Set the value of an uniform to an array of float32 (stored as matrices)
         * @param uniform defines the webGL uniform location where to store the value
         * @param matrices defines the array of float32 to store
         */
        setMatrices(uniform: Nullable<WebGLUniformLocation>, matrices: Float32Array): void;
        /**
         * Set the value of an uniform to a matrix (3x3)
         * @param uniform defines the webGL uniform location where to store the value
         * @param matrix defines the Float32Array representing the 3x3 matrix to store
         */
        setMatrix3x3(uniform: Nullable<WebGLUniformLocation>, matrix: Float32Array): void;
        /**
         * Set the value of an uniform to a matrix (2x2)
         * @param uniform defines the webGL uniform location where to store the value
         * @param matrix defines the Float32Array representing the 2x2 matrix to store
         */
        setMatrix2x2(uniform: Nullable<WebGLUniformLocation>, matrix: Float32Array): void;
        /**
         * Set the value of an uniform to a number (float)
         * @param uniform defines the webGL uniform location where to store the value
         * @param value defines the float number to store
         */
        setFloat(uniform: Nullable<WebGLUniformLocation>, value: number): void;
        /**
         * Set the value of an uniform to a vec2
         * @param uniform defines the webGL uniform location where to store the value
         * @param x defines the 1st component of the value
         * @param y defines the 2nd component of the value
         */
        setFloat2(uniform: Nullable<WebGLUniformLocation>, x: number, y: number): void;
        /**
         * Set the value of an uniform to a vec3
         * @param uniform defines the webGL uniform location where to store the value
         * @param x defines the 1st component of the value
         * @param y defines the 2nd component of the value
         * @param z defines the 3rd component of the value
         */
        setFloat3(uniform: Nullable<WebGLUniformLocation>, x: number, y: number, z: number): void;
        /**
         * Set the value of an uniform to a vec4
         * @param uniform defines the webGL uniform location where to store the value
         * @param x defines the 1st component of the value
         * @param y defines the 2nd component of the value
         * @param z defines the 3rd component of the value
         * @param w defines the 4th component of the value
         */
        setFloat4(uniform: Nullable<WebGLUniformLocation>, x: number, y: number, z: number, w: number): void;
        /**
         * Apply all cached states (depth, culling, stencil and alpha)
         */
        applyStates(): void;
        /**
         * Enable or disable color writing
         * @param enable defines the state to set
         */
        setColorWrite(enable: boolean): void;
        /**
         * Gets a boolean indicating if color writing is enabled
         * @returns the current color writing state
         */
        getColorWrite(): boolean;
        /**
         * Gets the depth culling state manager
         */
        get depthCullingState(): DepthCullingState;
        /**
         * Gets the alpha state manager
         */
        get alphaState(): AlphaState;
        /**
         * Gets the stencil state manager
         */
        get stencilState(): StencilState;
        /**
         * Clears the list of texture accessible through engine.
         * This can help preventing texture load conflict due to name collision.
         */
        clearInternalTexturesCache(): void;
        /**
         * Force the entire cache to be cleared
         * You should not have to use this function unless your engine needs to share the webGL context with another engine
         * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)
         */
        wipeCaches(bruteForce?: boolean): void;
        /** @hidden */
        _getSamplingParameters(samplingMode: number, generateMipMaps: boolean): {
            min: number;
            mag: number;
        };
        /** @hidden */
        _createTexture(): WebGLTexture;
        /**
         * Usually called from Texture.ts.
         * Passed information to create a WebGLTexture
         * @param url defines a value which contains one of the following:
         * * A conventional http URL, e.g. 'http://...' or 'file://...'
         * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'
         * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'
         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file
         * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)
         * @param scene needed for loading to the correct scene
         * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)
         * @param onLoad optional callback to be called upon successful completion
         * @param onError optional callback to be called upon failure
         * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob
         * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities
         * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures
         * @param forcedExtension defines the extension to use to pick the right loader
         * @param mimeType defines an optional mime type
         * @returns a InternalTexture for assignment back into BABYLON.Texture
         */
        createTexture(url: Nullable<string>, noMipmap: boolean, invertY: boolean, scene: Nullable<ISceneLike>, samplingMode?: number, onLoad?: Nullable<() => void>, onError?: Nullable<(message: string, exception: any) => void>, buffer?: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap>, fallback?: Nullable<InternalTexture>, format?: Nullable<number>, forcedExtension?: Nullable<string>, mimeType?: string): InternalTexture;
        /**
         * Loads an image as an HTMLImageElement.
         * @param input url string, ArrayBuffer, or Blob to load
         * @param onLoad callback called when the image successfully loads
         * @param onError callback called when the image fails to load
         * @param offlineProvider offline provider for caching
         * @param mimeType optional mime type
         * @returns the HTMLImageElement of the loaded image
         * @hidden
         */
        static _FileToolsLoadImage(input: string | ArrayBuffer | ArrayBufferView | Blob, onLoad: (img: HTMLImageElement | ImageBitmap) => void, onError: (message?: string, exception?: any) => void, offlineProvider: Nullable<IOfflineProvider>, mimeType?: string): Nullable<HTMLImageElement>;
        /**
         * @hidden
         */
        _rescaleTexture(source: InternalTexture, destination: InternalTexture, scene: Nullable<any>, internalFormat: number, onComplete: () => void): void;
        private _unpackFlipYCached;
        /**
         * In case you are sharing the context with other applications, it might
         * be interested to not cache the unpack flip y state to ensure a consistent
         * value would be set.
         */
        enableUnpackFlipYCached: boolean;
        /** @hidden */
        _unpackFlipY(value: boolean): void;
        /** @hidden */
        _getUnpackAlignement(): number;
        private _getTextureTarget;
        /**
         * Update the sampling mode of a given texture
         * @param samplingMode defines the required sampling mode
         * @param texture defines the texture to update
         * @param generateMipMaps defines whether to generate mipmaps for the texture
         */
        updateTextureSamplingMode(samplingMode: number, texture: InternalTexture, generateMipMaps?: boolean): void;
        /**
         * Update the sampling mode of a given texture
         * @param texture defines the texture to update
         * @param wrapU defines the texture wrap mode of the u coordinates
         * @param wrapV defines the texture wrap mode of the v coordinates
         * @param wrapR defines the texture wrap mode of the r coordinates
         */
        updateTextureWrappingMode(texture: InternalTexture, wrapU: Nullable<number>, wrapV?: Nullable<number>, wrapR?: Nullable<number>): void;
        /** @hidden */
        _setupDepthStencilTexture(internalTexture: InternalTexture, size: number | {
            width: number;
            height: number;
            layers?: number;
        }, generateStencil: boolean, bilinearFiltering: boolean, comparisonFunction: number): void;
        /** @hidden */
        _uploadCompressedDataToTextureDirectly(texture: InternalTexture, internalFormat: number, width: number, height: number, data: ArrayBufferView, faceIndex?: number, lod?: number): void;
        /** @hidden */
        _uploadDataToTextureDirectly(texture: InternalTexture, imageData: ArrayBufferView, faceIndex?: number, lod?: number, babylonInternalFormat?: number, useTextureWidthAndHeight?: boolean): void;
        /**
         * Update a portion of an internal texture
         * @param texture defines the texture to update
         * @param imageData defines the data to store into the texture
         * @param xOffset defines the x coordinates of the update rectangle
         * @param yOffset defines the y coordinates of the update rectangle
         * @param width defines the width of the update rectangle
         * @param height defines the height of the update rectangle
         * @param faceIndex defines the face index if texture is a cube (0 by default)
         * @param lod defines the lod level to update (0 by default)
         */
        updateTextureData(texture: InternalTexture, imageData: ArrayBufferView, xOffset: number, yOffset: number, width: number, height: number, faceIndex?: number, lod?: number): void;
        /** @hidden */
        _uploadArrayBufferViewToTexture(texture: InternalTexture, imageData: ArrayBufferView, faceIndex?: number, lod?: number): void;
        protected _prepareWebGLTextureContinuation(texture: InternalTexture, scene: Nullable<ISceneLike>, noMipmap: boolean, isCompressed: boolean, samplingMode: number): void;
        private _prepareWebGLTexture;
        /** @hidden */
        _setupFramebufferDepthAttachments(generateStencilBuffer: boolean, generateDepthBuffer: boolean, width: number, height: number, samples?: number): Nullable<WebGLRenderbuffer>;
        private _getDepthStencilBuffer;
        /** @hidden */
        _releaseFramebufferObjects(texture: InternalTexture): void;
        /** @hidden */
        _releaseTexture(texture: InternalTexture): void;
        protected _deleteTexture(texture: Nullable<WebGLTexture>): void;
        protected _setProgram(program: WebGLProgram): void;
        protected _boundUniforms: {
            [key: number]: WebGLUniformLocation;
        };
        /**
         * Binds an effect to the webGL context
         * @param effect defines the effect to bind
         */
        bindSamplers(effect: Effect): void;
        private _activateCurrentTexture;
        /** @hidden */
        _bindTextureDirectly(target: number, texture: Nullable<InternalTexture>, forTextureDataUpdate?: boolean, force?: boolean): boolean;
        /** @hidden */
        _bindTexture(channel: number, texture: Nullable<InternalTexture>): void;
        /**
         * Unbind all textures from the webGL context
         */
        unbindAllTextures(): void;
        /**
         * Sets a texture to the according uniform.
         * @param channel The texture channel
         * @param uniform The uniform to set
         * @param texture The texture to apply
         */
        setTexture(channel: number, uniform: Nullable<WebGLUniformLocation>, texture: Nullable<BaseTexture>): void;
        private _bindSamplerUniformToChannel;
        private _getTextureWrapMode;
        protected _setTexture(channel: number, texture: Nullable<BaseTexture>, isPartOfTextureArray?: boolean, depthStencilTexture?: boolean): boolean;
        /**
         * Sets an array of texture to the webGL context
         * @param channel defines the channel where the texture array must be set
         * @param uniform defines the associated uniform location
         * @param textures defines the array of textures to bind
         */
        setTextureArray(channel: number, uniform: Nullable<WebGLUniformLocation>, textures: BaseTexture[]): void;
        /** @hidden */
        _setAnisotropicLevel(target: number, internalTexture: InternalTexture, anisotropicFilteringLevel: number): void;
        private _setTextureParameterFloat;
        private _setTextureParameterInteger;
        /**
         * Unbind all vertex attributes from the webGL context
         */
        unbindAllAttributes(): void;
        /**
         * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled
         */
        releaseEffects(): void;
        /**
         * Dispose and release all associated resources
         */
        dispose(): void;
        /**
         * Attach a new callback raised when context lost event is fired
         * @param callback defines the callback to call
         */
        attachContextLostEvent(callback: ((event: WebGLContextEvent) => void)): void;
        /**
         * Attach a new callback raised when context restored event is fired
         * @param callback defines the callback to call
         */
        attachContextRestoredEvent(callback: ((event: WebGLContextEvent) => void)): void;
        /**
         * Get the current error code of the webGL context
         * @returns the error code
         * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError
         */
        getError(): number;
        private _canRenderToFloatFramebuffer;
        private _canRenderToHalfFloatFramebuffer;
        private _canRenderToFramebuffer;
        /** @hidden */
        _getWebGLTextureType(type: number): number;
        /** @hidden */
        _getInternalFormat(format: number): number;
        /** @hidden */
        _getRGBABufferInternalSizedFormat(type: number, format?: number): number;
        /** @hidden */
        _getRGBAMultiSampleBufferFormat(type: number): number;
        /** @hidden */
        _loadFile(url: string, onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void, onProgress?: (data: any) => void, offlineProvider?: IOfflineProvider, useArrayBuffer?: boolean, onError?: (request?: IWebRequest, exception?: any) => void): IFileRequest;
        /**
         * Loads a file from a url
         * @param url url to load
         * @param onSuccess callback called when the file successfully loads
         * @param onProgress callback called while file is loading (if the server supports this mode)
         * @param offlineProvider defines the offline provider for caching
         * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer
         * @param onError callback called when the file fails to load
         * @returns a file request object
         * @hidden
         */
        static _FileToolsLoadFile(url: string, onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void, onProgress?: (ev: ProgressEvent) => void, offlineProvider?: IOfflineProvider, useArrayBuffer?: boolean, onError?: (request?: WebRequest, exception?: LoadFileError) => void): IFileRequest;
        /**
         * Reads pixels from the current frame buffer. Please note that this function can be slow
         * @param x defines the x coordinate of the rectangle where pixels must be read
         * @param y defines the y coordinate of the rectangle where pixels must be read
         * @param width defines the width of the rectangle where pixels must be read
         * @param height defines the height of the rectangle where pixels must be read
         * @param hasAlpha defines whether the output should have alpha or not (defaults to true)
         * @returns a Uint8Array containing RGBA colors
         */
        readPixels(x: number, y: number, width: number, height: number, hasAlpha?: boolean): Uint8Array;
        private static _isSupported;
        /**
         * Gets a boolean indicating if the engine can be instanciated (ie. if a webGL context can be found)
         * @returns true if the engine can be created
         * @ignorenaming
         */
        static isSupported(): boolean;
        /**
         * Find the next highest power of two.
         * @param x Number to start search from.
         * @return Next highest power of two.
         */
        static CeilingPOT(x: number): number;
        /**
         * Find the next lowest power of two.
         * @param x Number to start search from.
         * @return Next lowest power of two.
         */
        static FloorPOT(x: number): number;
        /**
         * Find the nearest power of two.
         * @param x Number to start search from.
         * @return Next nearest power of two.
         */
        static NearestPOT(x: number): number;
        /**
         * Get the closest exponent of two
         * @param value defines the value to approximate
         * @param max defines the maximum value to return
         * @param mode defines how to define the closest value
         * @returns closest exponent of two of the given value
         */
        static GetExponentOfTwo(value: number, max: number, mode?: number): number;
        /**
         * Queue a new function into the requested animation frame pool (ie. this function will be executed byt the browser for the next frame)
         * @param func - the function to be called
         * @param requester - the object that will request the next frame. Falls back to window.
         * @returns frame number
         */
        static QueueNewFrame(func: () => void, requester?: any): number;
        /**
         * Gets host document
         * @returns the host document object
         */
        getHostDocument(): Nullable<Document>;
    }
}
declare module BABYLON {
    /**
     * Class representing spherical harmonics coefficients to the 3rd degree
     */
    export class SphericalHarmonics {
        /**
         * Defines whether or not the harmonics have been prescaled for rendering.
         */
        preScaled: boolean;
        /**
         * The l0,0 coefficients of the spherical harmonics
         */
        l00: Vector3;
        /**
         * The l1,-1 coefficients of the spherical harmonics
         */
        l1_1: Vector3;
        /**
         * The l1,0 coefficients of the spherical harmonics
         */
        l10: Vector3;
        /**
         * The l1,1 coefficients of the spherical harmonics
         */
        l11: Vector3;
        /**
         * The l2,-2 coefficients of the spherical harmonics
         */
        l2_2: Vector3;
        /**
         * The l2,-1 coefficients of the spherical harmonics
         */
        l2_1: Vector3;
        /**
         * The l2,0 coefficients of the spherical harmonics
         */
        l20: Vector3;
        /**
         * The l2,1 coefficients of the spherical harmonics
         */
        l21: Vector3;
        /**
         * The l2,2 coefficients of the spherical harmonics
         */
        l22: Vector3;
        /**
         * Adds a light to the spherical harmonics
         * @param direction the direction of the light
         * @param color the color of the light
         * @param deltaSolidAngle the delta solid angle of the light
         */
        addLight(direction: Vector3, color: Color3, deltaSolidAngle: number): void;
        /**
         * Scales the spherical harmonics by the given amount
         * @param scale the amount to scale
         */
        scaleInPlace(scale: number): void;
        /**
         * Convert from incident radiance (Li) to irradiance (E) by applying convolution with the cosine-weighted hemisphere.
         *
         * ```
         * E_lm = A_l * L_lm
         * ```
         *
         * In spherical harmonics this convolution amounts to scaling factors for each frequency band.
         * This corresponds to equation 5 in "An Efficient Representation for Irradiance Environment Maps", where
         * the scaling factors are given in equation 9.
         */
        convertIncidentRadianceToIrradiance(): void;
        /**
         * Convert from irradiance to outgoing radiance for Lambertian BDRF, suitable for efficient shader evaluation.
         *
         * ```
         * L = (1/pi) * E * rho
         * ```
         *
         * This is done by an additional scale by 1/pi, so is a fairly trivial operation but important conceptually.
         */
        convertIrradianceToLambertianRadiance(): void;
        /**
         * Integrates the reconstruction coefficients directly in to the SH preventing further
         * required operations at run time.
         *
         * This is simply done by scaling back the SH with Ylm constants parameter.
         * The trigonometric part being applied by the shader at run time.
         */
        preScaleForRendering(): void;
        /**
         * Constructs a spherical harmonics from an array.
         * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)
         * @returns the spherical harmonics
         */
        static FromArray(data: ArrayLike<ArrayLike<number>>): SphericalHarmonics;
        /**
         * Gets the spherical harmonics from polynomial
         * @param polynomial the spherical polynomial
         * @returns the spherical harmonics
         */
        static FromPolynomial(polynomial: SphericalPolynomial): SphericalHarmonics;
    }
    /**
     * Class representing spherical polynomial coefficients to the 3rd degree
     */
    export class SphericalPolynomial {
        private _harmonics;
        /**
         * The spherical harmonics used to create the polynomials.
         */
        get preScaledHarmonics(): SphericalHarmonics;
        /**
         * The x coefficients of the spherical polynomial
         */
        x: Vector3;
        /**
         * The y coefficients of the spherical polynomial
         */
        y: Vector3;
        /**
         * The z coefficients of the spherical polynomial
         */
        z: Vector3;
        /**
         * The xx coefficients of the spherical polynomial
         */
        xx: Vector3;
        /**
         * The yy coefficients of the spherical polynomial
         */
        yy: Vector3;
        /**
         * The zz coefficients of the spherical polynomial
         */
        zz: Vector3;
        /**
         * The xy coefficients of the spherical polynomial
         */
        xy: Vector3;
        /**
         * The yz coefficients of the spherical polynomial
         */
        yz: Vector3;
        /**
         * The zx coefficients of the spherical polynomial
         */
        zx: Vector3;
        /**
         * Adds an ambient color to the spherical polynomial
         * @param color the color to add
         */
        addAmbient(color: Color3): void;
        /**
         * Scales the spherical polynomial by the given amount
         * @param scale the amount to scale
         */
        scaleInPlace(scale: number): void;
        /**
         * Gets the spherical polynomial from harmonics
         * @param harmonics the spherical harmonics
         * @returns the spherical polynomial
         */
        static FromHarmonics(harmonics: SphericalHarmonics): SphericalPolynomial;
        /**
         * Constructs a spherical polynomial from an array.
         * @param data defines the 9x3 coefficients (x, y, z, xx, yy, zz, yz, zx, xy)
         * @returns the spherical polynomial
         */
        static FromArray(data: ArrayLike<ArrayLike<number>>): SphericalPolynomial;
    }
}
declare module BABYLON {
    /**
     * Defines the source of the internal texture
     */
    export enum InternalTextureSource {
        /**
         * The source of the texture data is unknown
         */
        Unknown = 0,
        /**
        * Texture data comes from an URL
        */
        Url = 1,
        /**
         * Texture data is only used for temporary storage
         */
        Temp = 2,
        /**
         * Texture data comes from raw data (ArrayBuffer)
         */
        Raw = 3,
        /**
         * Texture content is dynamic (video or dynamic texture)
         */
        Dynamic = 4,
        /**
         * Texture content is generated by rendering to it
         */
        RenderTarget = 5,
        /**
         * Texture content is part of a multi render target process
         */
        MultiRenderTarget = 6,
        /**
         * Texture data comes from a cube data file
         */
        Cube = 7,
        /**
         * Texture data comes from a raw cube data
         */
        CubeRaw = 8,
        /**
         * Texture data come from a prefiltered cube data file
         */
        CubePrefiltered = 9,
        /**
         * Texture content is raw 3D data
         */
        Raw3D = 10,
        /**
         * Texture content is raw 2D array data
         */
        Raw2DArray = 11,
        /**
         * Texture content is a depth texture
         */
        Depth = 12,
        /**
         * Texture data comes from a raw cube data encoded with RGBD
         */
        CubeRawRGBD = 13
    }
    /**
     * Class used to store data associated with WebGL texture data for the engine
     * This class should not be used directly
     */
    export class InternalTexture {
        /** @hidden */
        static _UpdateRGBDAsync: (internalTexture: InternalTexture, data: ArrayBufferView[][], sphericalPolynomial: Nullable<SphericalPolynomial>, lodScale: number, lodOffset: number) => Promise<void>;
        /**
         * Defines if the texture is ready
         */
        isReady: boolean;
        /**
         * Defines if the texture is a cube texture
         */
        isCube: boolean;
        /**
         * Defines if the texture contains 3D data
         */
        is3D: boolean;
        /**
         * Defines if the texture contains 2D array data
         */
        is2DArray: boolean;
        /**
         * Defines if the texture contains multiview data
         */
        isMultiview: boolean;
        /**
         * Gets the URL used to load this texture
         */
        url: string;
        /**
         * Gets the sampling mode of the texture
         */
        samplingMode: number;
        /**
         * Gets a boolean indicating if the texture needs mipmaps generation
         */
        generateMipMaps: boolean;
        /**
         * Gets the number of samples used by the texture (WebGL2+ only)
         */
        samples: number;
        /**
         * Gets the type of the texture (int, float...)
         */
        type: number;
        /**
         * Gets the format of the texture (RGB, RGBA...)
         */
        format: number;
        /**
         * Observable called when the texture is loaded
         */
        onLoadedObservable: Observable<InternalTexture>;
        /**
         * Gets the width of the texture
         */
        width: number;
        /**
         * Gets the height of the texture
         */
        height: number;
        /**
         * Gets the depth of the texture
         */
        depth: number;
        /**
         * Gets the initial width of the texture (It could be rescaled if the current system does not support non power of two textures)
         */
        baseWidth: number;
        /**
         * Gets the initial height of the texture (It could be rescaled if the current system does not support non power of two textures)
         */
        baseHeight: number;
        /**
         * Gets the initial depth of the texture (It could be rescaled if the current system does not support non power of two textures)
         */
        baseDepth: number;
        /**
         * Gets a boolean indicating if the texture is inverted on Y axis
         */
        invertY: boolean;
        /** @hidden */
        _invertVScale: boolean;
        /** @hidden */
        _associatedChannel: number;
        /** @hidden */
        _source: InternalTextureSource;
        /** @hidden */
        _buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap>;
        /** @hidden */
        _bufferView: Nullable<ArrayBufferView>;
        /** @hidden */
        _bufferViewArray: Nullable<ArrayBufferView[]>;
        /** @hidden */
        _bufferViewArrayArray: Nullable<ArrayBufferView[][]>;
        /** @hidden */
        _size: number;
        /** @hidden */
        _extension: string;
        /** @hidden */
        _files: Nullable<string[]>;
        /** @hidden */
        _workingCanvas: Nullable<HTMLCanvasElement | OffscreenCanvas>;
        /** @hidden */
        _workingContext: Nullable<CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D>;
        /** @hidden */
        _framebuffer: Nullable<WebGLFramebuffer>;
        /** @hidden */
        _depthStencilBuffer: Nullable<WebGLRenderbuffer>;
        /** @hidden */
        _MSAAFramebuffer: Nullable<WebGLFramebuffer>;
        /** @hidden */
        _MSAARenderBuffer: Nullable<WebGLRenderbuffer>;
        /** @hidden */
        _attachments: Nullable<number[]>;
        /** @hidden */
        _textureArray: Nullable<InternalTexture[]>;
        /** @hidden */
        _cachedCoordinatesMode: Nullable<number>;
        /** @hidden */
        _cachedWrapU: Nullable<number>;
        /** @hidden */
        _cachedWrapV: Nullable<number>;
        /** @hidden */
        _cachedWrapR: Nullable<number>;
        /** @hidden */
        _cachedAnisotropicFilteringLevel: Nullable<number>;
        /** @hidden */
        _isDisabled: boolean;
        /** @hidden */
        _compression: Nullable<string>;
        /** @hidden */
        _generateStencilBuffer: boolean;
        /** @hidden */
        _generateDepthBuffer: boolean;
        /** @hidden */
        _comparisonFunction: number;
        /** @hidden */
        _sphericalPolynomial: Nullable<SphericalPolynomial>;
        /** @hidden */
        _lodGenerationScale: number;
        /** @hidden */
        _lodGenerationOffset: number;
        /** @hidden */
        _depthStencilTexture: Nullable<InternalTexture>;
        /** @hidden */
        _colorTextureArray: Nullable<WebGLTexture>;
        /** @hidden */
        _depthStencilTextureArray: Nullable<WebGLTexture>;
        /** @hidden */
        _lodTextureHigh: Nullable<BaseTexture>;
        /** @hidden */
        _lodTextureMid: Nullable<BaseTexture>;
        /** @hidden */
        _lodTextureLow: Nullable<BaseTexture>;
        /** @hidden */
        _isRGBD: boolean;
        /** @hidden */
        _linearSpecularLOD: boolean;
        /** @hidden */
        _irradianceTexture: Nullable<BaseTexture>;
        /** @hidden */
        _webGLTexture: Nullable<WebGLTexture>;
        /** @hidden */
        _references: number;
        /** @hidden */
        _gammaSpace: Nullable<boolean>;
        private _engine;
        /**
         * Gets the Engine the texture belongs to.
         * @returns The babylon engine
         */
        getEngine(): ThinEngine;
        /**
         * Gets the data source type of the texture
         */
        get source(): InternalTextureSource;
        /**
         * Creates a new InternalTexture
         * @param engine defines the engine to use
         * @param source defines the type of data that will be used
         * @param delayAllocation if the texture allocation should be delayed (default: false)
         */
        constructor(engine: ThinEngine, source: InternalTextureSource, delayAllocation?: boolean);
        /**
         * Increments the number of references (ie. the number of Texture that point to it)
         */
        incrementReferences(): void;
        /**
         * Change the size of the texture (not the size of the content)
         * @param width defines the new width
         * @param height defines the new height
         * @param depth defines the new depth (1 by default)
         */
        updateSize(width: int, height: int, depth?: int): void;
        /** @hidden */
        _rebuild(): void;
        /** @hidden */
        _swapAndDie(target: InternalTexture): void;
        /**
         * Dispose the current allocated resources
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * Class used to work with sound analyzer using fast fourier transform (FFT)
     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music
     */
    export class Analyser {
        /**
         * Gets or sets the smoothing
         * @ignorenaming
         */
        SMOOTHING: number;
        /**
         * Gets or sets the FFT table size
         * @ignorenaming
         */
        FFT_SIZE: number;
        /**
         * Gets or sets the bar graph amplitude
         * @ignorenaming
         */
        BARGRAPHAMPLITUDE: number;
        /**
         * Gets or sets the position of the debug canvas
         * @ignorenaming
         */
        DEBUGCANVASPOS: {
            x: number;
            y: number;
        };
        /**
         * Gets or sets the debug canvas size
         * @ignorenaming
         */
        DEBUGCANVASSIZE: {
            width: number;
            height: number;
        };
        private _byteFreqs;
        private _byteTime;
        private _floatFreqs;
        private _webAudioAnalyser;
        private _debugCanvas;
        private _debugCanvasContext;
        private _scene;
        private _registerFunc;
        private _audioEngine;
        /**
         * Creates a new analyser
         * @param scene defines hosting scene
         */
        constructor(scene: Scene);
        /**
         * Get the number of data values you will have to play with for the visualization
         * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/frequencyBinCount
         * @returns a number
         */
        getFrequencyBinCount(): number;
        /**
         * Gets the current frequency data as a byte array
         * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData
         * @returns a Uint8Array
         */
        getByteFrequencyData(): Uint8Array;
        /**
         * Gets the current waveform as a byte array
         * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteTimeDomainData
         * @returns a Uint8Array
         */
        getByteTimeDomainData(): Uint8Array;
        /**
         * Gets the current frequency data as a float array
         * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData
         * @returns a Float32Array
         */
        getFloatFrequencyData(): Float32Array;
        /**
         * Renders the debug canvas
         */
        drawDebugCanvas(): void;
        /**
         * Stops rendering the debug canvas and removes it
         */
        stopDebugCanvas(): void;
        /**
         * Connects two audio nodes
         * @param inputAudioNode defines first node to connect
         * @param outputAudioNode defines second node to connect
         */
        connectAudioNodes(inputAudioNode: AudioNode, outputAudioNode: AudioNode): void;
        /**
         * Releases all associated resources
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * This represents an audio engine and it is responsible
     * to play, synchronize and analyse sounds throughout the application.
     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music
     */
    export interface IAudioEngine extends IDisposable {
        /**
         * Gets whether the current host supports Web Audio and thus could create AudioContexts.
         */
        readonly canUseWebAudio: boolean;
        /**
         * Gets the current AudioContext if available.
         */
        readonly audioContext: Nullable<AudioContext>;
        /**
         * The master gain node defines the global audio volume of your audio engine.
         */
        readonly masterGain: GainNode;
        /**
         * Gets whether or not mp3 are supported by your browser.
         */
        readonly isMP3supported: boolean;
        /**
         * Gets whether or not ogg are supported by your browser.
         */
        readonly isOGGsupported: boolean;
        /**
         * Defines if Babylon should emit a warning if WebAudio is not supported.
         * @ignoreNaming
         */
        WarnedWebAudioUnsupported: boolean;
        /**
         * Defines if the audio engine relies on a custom unlocked button.
         * In this case, the embedded button will not be displayed.
         */
        useCustomUnlockedButton: boolean;
        /**
         * Gets whether or not the audio engine is unlocked (require first a user gesture on some browser).
         */
        readonly unlocked: boolean;
        /**
         * Event raised when audio has been unlocked on the browser.
         */
        onAudioUnlockedObservable: Observable<AudioEngine>;
        /**
         * Event raised when audio has been locked on the browser.
         */
        onAudioLockedObservable: Observable<AudioEngine>;
        /**
         * Flags the audio engine in Locked state.
         * This happens due to new browser policies preventing audio to autoplay.
         */
        lock(): void;
        /**
         * Unlocks the audio engine once a user action has been done on the dom.
         * This is helpful to resume play once browser policies have been satisfied.
         */
        unlock(): void;
        /**
         * Gets the global volume sets on the master gain.
         * @returns the global volume if set or -1 otherwise
         */
        getGlobalVolume(): number;
        /**
         * Sets the global volume of your experience (sets on the master gain).
         * @param newVolume Defines the new global volume of the application
         */
        setGlobalVolume(newVolume: number): void;
        /**
         * Connect the audio engine to an audio analyser allowing some amazing
         * synchornization between the sounds/music and your visualization (VuMeter for instance).
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#using-the-analyser
         * @param analyser The analyser to connect to the engine
         */
        connectToAnalyser(analyser: Analyser): void;
    }
    /**
     * This represents the default audio engine used in babylon.
     * It is responsible to play, synchronize and analyse sounds throughout the  application.
     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music
     */
    export class AudioEngine implements IAudioEngine {
        private _audioContext;
        private _audioContextInitialized;
        private _muteButton;
        private _hostElement;
        /**
         * Gets whether the current host supports Web Audio and thus could create AudioContexts.
         */
        canUseWebAudio: boolean;
        /**
         * The master gain node defines the global audio volume of your audio engine.
         */
        masterGain: GainNode;
        /**
         * Defines if Babylon should emit a warning if WebAudio is not supported.
         * @ignoreNaming
         */
        WarnedWebAudioUnsupported: boolean;
        /**
         * Gets whether or not mp3 are supported by your browser.
         */
        isMP3supported: boolean;
        /**
         * Gets whether or not ogg are supported by your browser.
         */
        isOGGsupported: boolean;
        /**
         * Gets whether audio has been unlocked on the device.
         * Some Browsers have strong restrictions about Audio and won t autoplay unless
         * a user interaction has happened.
         */
        unlocked: boolean;
        /**
         * Defines if the audio engine relies on a custom unlocked button.
         * In this case, the embedded button will not be displayed.
         */
        useCustomUnlockedButton: boolean;
        /**
         * Event raised when audio has been unlocked on the browser.
         */
        onAudioUnlockedObservable: Observable<AudioEngine>;
        /**
         * Event raised when audio has been locked on the browser.
         */
        onAudioLockedObservable: Observable<AudioEngine>;
        /**
         * Gets the current AudioContext if available.
         */
        get audioContext(): Nullable<AudioContext>;
        private _connectedAnalyser;
        /**
         * Instantiates a new audio engine.
         *
         * There should be only one per page as some browsers restrict the number
         * of audio contexts you can create.
         * @param hostElement defines the host element where to display the mute icon if necessary
         */
        constructor(hostElement?: Nullable<HTMLElement>);
        /**
         * Flags the audio engine in Locked state.
         * This happens due to new browser policies preventing audio to autoplay.
         */
        lock(): void;
        /**
         * Unlocks the audio engine once a user action has been done on the dom.
         * This is helpful to resume play once browser policies have been satisfied.
         */
        unlock(): void;
        private _resumeAudioContext;
        private _initializeAudioContext;
        private _tryToRun;
        private _triggerRunningState;
        private _triggerSuspendedState;
        private _displayMuteButton;
        private _moveButtonToTopLeft;
        private _onResize;
        private _hideMuteButton;
        /**
         * Destroy and release the resources associated with the audio ccontext.
         */
        dispose(): void;
        /**
         * Gets the global volume sets on the master gain.
         * @returns the global volume if set or -1 otherwise
         */
        getGlobalVolume(): number;
        /**
         * Sets the global volume of your experience (sets on the master gain).
         * @param newVolume Defines the new global volume of the application
         */
        setGlobalVolume(newVolume: number): void;
        /**
         * Connect the audio engine to an audio analyser allowing some amazing
         * synchornization between the sounds/music and your visualization (VuMeter for instance).
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#using-the-analyser
         * @param analyser The analyser to connect to the engine
         */
        connectToAnalyser(analyser: Analyser): void;
    }
}
declare module BABYLON {
    /**
     * Interface used to present a loading screen while loading a scene
     * @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
     */
    export interface ILoadingScreen {
        /**
         * Function called to display the loading screen
         */
        displayLoadingUI: () => void;
        /**
         * Function called to hide the loading screen
         */
        hideLoadingUI: () => void;
        /**
         * Gets or sets the color to use for the background
         */
        loadingUIBackgroundColor: string;
        /**
         * Gets or sets the text to display while loading
         */
        loadingUIText: string;
    }
    /**
     * Class used for the default loading screen
     * @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
     */
    export class DefaultLoadingScreen implements ILoadingScreen {
        private _renderingCanvas;
        private _loadingText;
        private _loadingDivBackgroundColor;
        private _loadingDiv;
        private _loadingTextDiv;
        /** Gets or sets the logo url to use for the default loading screen */
        static DefaultLogoUrl: string;
        /** Gets or sets the spinner url to use for the default loading screen */
        static DefaultSpinnerUrl: string;
        /**
         * Creates a new default loading screen
         * @param _renderingCanvas defines the canvas used to render the scene
         * @param _loadingText defines the default text to display
         * @param _loadingDivBackgroundColor defines the default background color
         */
        constructor(_renderingCanvas: HTMLCanvasElement, _loadingText?: string, _loadingDivBackgroundColor?: string);
        /**
         * Function called to display the loading screen
         */
        displayLoadingUI(): void;
        /**
         * Function called to hide the loading screen
         */
        hideLoadingUI(): void;
        /**
         * Gets or sets the text to display while loading
         */
        set loadingUIText(text: string);
        get loadingUIText(): string;
        /**
         * Gets or sets the color to use for the background
         */
        get loadingUIBackgroundColor(): string;
        set loadingUIBackgroundColor(color: string);
        private _resizeLoadingUI;
    }
}
declare module BABYLON {
    /**
     * Interface for any object that can request an animation frame
     */
    export interface ICustomAnimationFrameRequester {
        /**
         * This function will be called when the render loop is ready. If this is not populated, the engine's renderloop function will be called
         */
        renderFunction?: Function;
        /**
         * Called to request the next frame to render to
         * @see https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame
         */
        requestAnimationFrame: Function;
        /**
         * You can pass this value to cancelAnimationFrame() to cancel the refresh callback request
         * @see https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame#Return_value
         */
        requestID?: number;
    }
}
declare module BABYLON {
    /**
     * Performance monitor tracks rolling average frame-time and frame-time variance over a user defined sliding-window
     */
    export class PerformanceMonitor {
        private _enabled;
        private _rollingFrameTime;
        private _lastFrameTimeMs;
        /**
         * constructor
         * @param frameSampleSize The number of samples required to saturate the sliding window
         */
        constructor(frameSampleSize?: number);
        /**
         * Samples current frame
         * @param timeMs A timestamp in milliseconds of the current frame to compare with other frames
         */
        sampleFrame(timeMs?: number): void;
        /**
         * Returns the average frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
         */
        get averageFrameTime(): number;
        /**
         * Returns the variance frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
         */
        get averageFrameTimeVariance(): number;
        /**
         * Returns the frame time of the most recent frame
         */
        get instantaneousFrameTime(): number;
        /**
         * Returns the average framerate in frames per second over the sliding window (or the subset of frames sampled so far)
         */
        get averageFPS(): number;
        /**
         * Returns the average framerate in frames per second using the most recent frame time
         */
        get instantaneousFPS(): number;
        /**
         * Returns true if enough samples have been taken to completely fill the sliding window
         */
        get isSaturated(): boolean;
        /**
         * Enables contributions to the sliding window sample set
         */
        enable(): void;
        /**
         * Disables contributions to the sliding window sample set
         * Samples will not be interpolated over the disabled period
         */
        disable(): void;
        /**
         * Returns true if sampling is enabled
         */
        get isEnabled(): boolean;
        /**
         * Resets performance monitor
         */
        reset(): void;
    }
    /**
     * RollingAverage
     *
     * Utility to efficiently compute the rolling average and variance over a sliding window of samples
     */
    export class RollingAverage {
        /**
         * Current average
         */
        average: number;
        /**
         * Current variance
         */
        variance: number;
        protected _samples: Array<number>;
        protected _sampleCount: number;
        protected _pos: number;
        protected _m2: number;
        /**
         * constructor
         * @param length The number of samples required to saturate the sliding window
         */
        constructor(length: number);
        /**
         * Adds a sample to the sample set
         * @param v The sample value
         */
        add(v: number): void;
        /**
         * Returns previously added values or null if outside of history or outside the sliding window domain
         * @param i Index in history. For example, pass 0 for the most recent value and 1 for the value before that
         * @return Value previously recorded with add() or null if outside of range
         */
        history(i: number): number;
        /**
         * Returns true if enough samples have been taken to completely fill the sliding window
         * @return true if sample-set saturated
         */
        isSaturated(): boolean;
        /**
         * Resets the rolling average (equivalent to 0 samples taken so far)
         */
        reset(): void;
        /**
         * Wraps a value around the sample range boundaries
         * @param i Position in sample range, for example if the sample length is 5, and i is -3, then 2 will be returned.
         * @return Wrapped position in sample range
         */
        protected _wrapPosition(i: number): number;
    }
}
declare module BABYLON {
    /**
     * This class is used to track a performance counter which is number based.
     * The user has access to many properties which give statistics of different nature.
     *
     * The implementer can track two kinds of Performance Counter: time and count.
     * For time you can optionally call fetchNewFrame() to notify the start of a new frame to monitor, then call beginMonitoring() to start and endMonitoring() to record the lapsed time. endMonitoring takes a newFrame parameter for you to specify if the monitored time should be set for a new frame or accumulated to the current frame being monitored.
     * For count you first have to call fetchNewFrame() to notify the start of a new frame to monitor, then call addCount() how many time required to increment the count value you monitor.
     */
    export class PerfCounter {
        /**
         * Gets or sets a global boolean to turn on and off all the counters
         */
        static Enabled: boolean;
        /**
         * Returns the smallest value ever
         */
        get min(): number;
        /**
         * Returns the biggest value ever
         */
        get max(): number;
        /**
         * Returns the average value since the performance counter is running
         */
        get average(): number;
        /**
         * Returns the average value of the last second the counter was monitored
         */
        get lastSecAverage(): number;
        /**
         * Returns the current value
         */
        get current(): number;
        /**
         * Gets the accumulated total
         */
        get total(): number;
        /**
         * Gets the total value count
         */
        get count(): number;
        /**
         * Creates a new counter
         */
        constructor();
        /**
         * Call this method to start monitoring a new frame.
         * This scenario is typically used when you accumulate monitoring time many times for a single frame, you call this method at the start of the frame, then beginMonitoring to start recording and endMonitoring(false) to accumulated the recorded time to the PerfCounter or addCount() to accumulate a monitored count.
         */
        fetchNewFrame(): void;
        /**
         * Call this method to monitor a count of something (e.g. mesh drawn in viewport count)
         * @param newCount the count value to add to the monitored count
         * @param fetchResult true when it's the last time in the frame you add to the counter and you wish to update the statistics properties (min/max/average), false if you only want to update statistics.
         */
        addCount(newCount: number, fetchResult: boolean): void;
        /**
         * Start monitoring this performance counter
         */
        beginMonitoring(): void;
        /**
         * Compute the time lapsed since the previous beginMonitoring() call.
         * @param newFrame true by default to fetch the result and monitor a new frame, if false the time monitored will be added to the current frame counter
         */
        endMonitoring(newFrame?: boolean): void;
        private _fetchResult;
        private _startMonitoringTime;
        private _min;
        private _max;
        private _average;
        private _current;
        private _totalValueCount;
        private _totalAccumulated;
        private _lastSecAverage;
        private _lastSecAccumulated;
        private _lastSecTime;
        private _lastSecValueCount;
    }
}
declare module BABYLON {
        interface ThinEngine {
            /** @hidden */
            _readTexturePixels(texture: InternalTexture, width: number, height: number, faceIndex?: number, level?: number, buffer?: Nullable<ArrayBufferView>): ArrayBufferView;
        }
}
declare module BABYLON {
    /**
     * Defines the interface used by display changed events
     */
    export interface IDisplayChangedEventArgs {
        /** Gets the vrDisplay object (if any) */
        vrDisplay: Nullable<any>;
        /** Gets a boolean indicating if webVR is supported */
        vrSupported: boolean;
    }
    /**
     * Defines the interface used by objects containing a viewport (like a camera)
     */
    interface IViewportOwnerLike {
        /**
         * Gets or sets the viewport
         */
        viewport: IViewportLike;
    }
    /**
     * The engine class is responsible for interfacing with all lower-level APIs such as WebGL and Audio
     */
    export class Engine extends ThinEngine {
        /** Defines that alpha blending is disabled */
        static readonly ALPHA_DISABLE: number;
        /** Defines that alpha blending to SRC ALPHA * SRC + DEST */
        static readonly ALPHA_ADD: number;
        /** Defines that alpha blending to SRC ALPHA * SRC + (1 - SRC ALPHA) * DEST */
        static readonly ALPHA_COMBINE: number;
        /** Defines that alpha blending to DEST - SRC * DEST */
        static readonly ALPHA_SUBTRACT: number;
        /** Defines that alpha blending to SRC * DEST */
        static readonly ALPHA_MULTIPLY: number;
        /** Defines that alpha blending to SRC ALPHA * SRC + (1 - SRC) * DEST */
        static readonly ALPHA_MAXIMIZED: number;
        /** Defines that alpha blending to SRC + DEST */
        static readonly ALPHA_ONEONE: number;
        /** Defines that alpha blending to SRC + (1 - SRC ALPHA) * DEST */
        static readonly ALPHA_PREMULTIPLIED: number;
        /**
         * Defines that alpha blending to SRC + (1 - SRC ALPHA) * DEST
         * Alpha will be set to (1 - SRC ALPHA) * DEST ALPHA
         */
        static readonly ALPHA_PREMULTIPLIED_PORTERDUFF: number;
        /** Defines that alpha blending to CST * SRC + (1 - CST) * DEST */
        static readonly ALPHA_INTERPOLATE: number;
        /**
         * Defines that alpha blending to SRC + (1 - SRC) * DEST
         * Alpha will be set to SRC ALPHA + (1 - SRC ALPHA) * DEST ALPHA
         */
        static readonly ALPHA_SCREENMODE: number;
        /** Defines that the ressource is not delayed*/
        static readonly DELAYLOADSTATE_NONE: number;
        /** Defines that the ressource was successfully delay loaded */
        static readonly DELAYLOADSTATE_LOADED: number;
        /** Defines that the ressource is currently delay loading */
        static readonly DELAYLOADSTATE_LOADING: number;
        /** Defines that the ressource is delayed and has not started loading */
        static readonly DELAYLOADSTATE_NOTLOADED: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will never pass. i.e. Nothing will be drawn */
        static readonly NEVER: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn */
        static readonly ALWAYS: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than the stored value */
        static readonly LESS: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is equals to the stored value */
        static readonly EQUAL: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than or equal to the stored value */
        static readonly LEQUAL: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than the stored value */
        static readonly GREATER: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than or equal to the stored value */
        static readonly GEQUAL: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is not equal to the stored value */
        static readonly NOTEQUAL: number;
        /** Passed to stencilOperation to specify that stencil value must be kept */
        static readonly KEEP: number;
        /** Passed to stencilOperation to specify that stencil value must be replaced */
        static readonly REPLACE: number;
        /** Passed to stencilOperation to specify that stencil value must be incremented */
        static readonly INCR: number;
        /** Passed to stencilOperation to specify that stencil value must be decremented */
        static readonly DECR: number;
        /** Passed to stencilOperation to specify that stencil value must be inverted */
        static readonly INVERT: number;
        /** Passed to stencilOperation to specify that stencil value must be incremented with wrapping */
        static readonly INCR_WRAP: number;
        /** Passed to stencilOperation to specify that stencil value must be decremented with wrapping */
        static readonly DECR_WRAP: number;
        /** Texture is not repeating outside of 0..1 UVs */
        static readonly TEXTURE_CLAMP_ADDRESSMODE: number;
        /** Texture is repeating outside of 0..1 UVs */
        static readonly TEXTURE_WRAP_ADDRESSMODE: number;
        /** Texture is repeating and mirrored */
        static readonly TEXTURE_MIRROR_ADDRESSMODE: number;
        /** ALPHA */
        static readonly TEXTUREFORMAT_ALPHA: number;
        /** LUMINANCE */
        static readonly TEXTUREFORMAT_LUMINANCE: number;
        /** LUMINANCE_ALPHA */
        static readonly TEXTUREFORMAT_LUMINANCE_ALPHA: number;
        /** RGB */
        static readonly TEXTUREFORMAT_RGB: number;
        /** RGBA */
        static readonly TEXTUREFORMAT_RGBA: number;
        /** RED */
        static readonly TEXTUREFORMAT_RED: number;
        /** RED (2nd reference) */
        static readonly TEXTUREFORMAT_R: number;
        /** RG */
        static readonly TEXTUREFORMAT_RG: number;
        /** RED_INTEGER */
        static readonly TEXTUREFORMAT_RED_INTEGER: number;
        /** RED_INTEGER (2nd reference) */
        static readonly TEXTUREFORMAT_R_INTEGER: number;
        /** RG_INTEGER */
        static readonly TEXTUREFORMAT_RG_INTEGER: number;
        /** RGB_INTEGER */
        static readonly TEXTUREFORMAT_RGB_INTEGER: number;
        /** RGBA_INTEGER */
        static readonly TEXTUREFORMAT_RGBA_INTEGER: number;
        /** UNSIGNED_BYTE */
        static readonly TEXTURETYPE_UNSIGNED_BYTE: number;
        /** UNSIGNED_BYTE (2nd reference) */
        static readonly TEXTURETYPE_UNSIGNED_INT: number;
        /** FLOAT */
        static readonly TEXTURETYPE_FLOAT: number;
        /** HALF_FLOAT */
        static readonly TEXTURETYPE_HALF_FLOAT: number;
        /** BYTE */
        static readonly TEXTURETYPE_BYTE: number;
        /** SHORT */
        static readonly TEXTURETYPE_SHORT: number;
        /** UNSIGNED_SHORT */
        static readonly TEXTURETYPE_UNSIGNED_SHORT: number;
        /** INT */
        static readonly TEXTURETYPE_INT: number;
        /** UNSIGNED_INT */
        static readonly TEXTURETYPE_UNSIGNED_INTEGER: number;
        /** UNSIGNED_SHORT_4_4_4_4 */
        static readonly TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4: number;
        /** UNSIGNED_SHORT_5_5_5_1 */
        static readonly TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1: number;
        /** UNSIGNED_SHORT_5_6_5 */
        static readonly TEXTURETYPE_UNSIGNED_SHORT_5_6_5: number;
        /** UNSIGNED_INT_2_10_10_10_REV */
        static readonly TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV: number;
        /** UNSIGNED_INT_24_8 */
        static readonly TEXTURETYPE_UNSIGNED_INT_24_8: number;
        /** UNSIGNED_INT_10F_11F_11F_REV */
        static readonly TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV: number;
        /** UNSIGNED_INT_5_9_9_9_REV */
        static readonly TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV: number;
        /** FLOAT_32_UNSIGNED_INT_24_8_REV */
        static readonly TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV: number;
        /** nearest is mag = nearest and min = nearest and mip = linear */
        static readonly TEXTURE_NEAREST_SAMPLINGMODE: number;
        /** Bilinear is mag = linear and min = linear and mip = nearest */
        static readonly TEXTURE_BILINEAR_SAMPLINGMODE: number;
        /** Trilinear is mag = linear and min = linear and mip = linear */
        static readonly TEXTURE_TRILINEAR_SAMPLINGMODE: number;
        /** nearest is mag = nearest and min = nearest and mip = linear */
        static readonly TEXTURE_NEAREST_NEAREST_MIPLINEAR: number;
        /** Bilinear is mag = linear and min = linear and mip = nearest */
        static readonly TEXTURE_LINEAR_LINEAR_MIPNEAREST: number;
        /** Trilinear is mag = linear and min = linear and mip = linear */
        static readonly TEXTURE_LINEAR_LINEAR_MIPLINEAR: number;
        /** mag = nearest and min = nearest and mip = nearest */
        static readonly TEXTURE_NEAREST_NEAREST_MIPNEAREST: number;
        /** mag = nearest and min = linear and mip = nearest */
        static readonly TEXTURE_NEAREST_LINEAR_MIPNEAREST: number;
        /** mag = nearest and min = linear and mip = linear */
        static readonly TEXTURE_NEAREST_LINEAR_MIPLINEAR: number;
        /** mag = nearest and min = linear and mip = none */
        static readonly TEXTURE_NEAREST_LINEAR: number;
        /** mag = nearest and min = nearest and mip = none */
        static readonly TEXTURE_NEAREST_NEAREST: number;
        /** mag = linear and min = nearest and mip = nearest */
        static readonly TEXTURE_LINEAR_NEAREST_MIPNEAREST: number;
        /** mag = linear and min = nearest and mip = linear */
        static readonly TEXTURE_LINEAR_NEAREST_MIPLINEAR: number;
        /** mag = linear and min = linear and mip = none */
        static readonly TEXTURE_LINEAR_LINEAR: number;
        /** mag = linear and min = nearest and mip = none */
        static readonly TEXTURE_LINEAR_NEAREST: number;
        /** Explicit coordinates mode */
        static readonly TEXTURE_EXPLICIT_MODE: number;
        /** Spherical coordinates mode */
        static readonly TEXTURE_SPHERICAL_MODE: number;
        /** Planar coordinates mode */
        static readonly TEXTURE_PLANAR_MODE: number;
        /** Cubic coordinates mode */
        static readonly TEXTURE_CUBIC_MODE: number;
        /** Projection coordinates mode */
        static readonly TEXTURE_PROJECTION_MODE: number;
        /** Skybox coordinates mode */
        static readonly TEXTURE_SKYBOX_MODE: number;
        /** Inverse Cubic coordinates mode */
        static readonly TEXTURE_INVCUBIC_MODE: number;
        /** Equirectangular coordinates mode */
        static readonly TEXTURE_EQUIRECTANGULAR_MODE: number;
        /** Equirectangular Fixed coordinates mode */
        static readonly TEXTURE_FIXED_EQUIRECTANGULAR_MODE: number;
        /** Equirectangular Fixed Mirrored coordinates mode */
        static readonly TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE: number;
        /** Defines that texture rescaling will use a floor to find the closer power of 2 size */
        static readonly SCALEMODE_FLOOR: number;
        /** Defines that texture rescaling will look for the nearest power of 2 size */
        static readonly SCALEMODE_NEAREST: number;
        /** Defines that texture rescaling will use a ceil to find the closer power of 2 size */
        static readonly SCALEMODE_CEILING: number;
        /**
         * Returns the current npm package of the sdk
         */
        static get NpmPackage(): string;
        /**
         * Returns the current version of the framework
         */
        static get Version(): string;
        /** Gets the list of created engines */
        static get Instances(): Engine[];
        /**
         * Gets the latest created engine
         */
        static get LastCreatedEngine(): Nullable<Engine>;
        /**
         * Gets the latest created scene
         */
        static get LastCreatedScene(): Nullable<Scene>;
        /**
         * Will flag all materials in all scenes in all engines as dirty to trigger new shader compilation
         * @param flag defines which part of the materials must be marked as dirty
         * @param predicate defines a predicate used to filter which materials should be affected
         */
        static MarkAllMaterialsAsDirty(flag: number, predicate?: (mat: Material) => boolean): void;
        /**
         * Method called to create the default loading screen.
         * This can be overriden in your own app.
         * @param canvas The rendering canvas element
         * @returns The loading screen
         */
        static DefaultLoadingScreenFactory(canvas: HTMLCanvasElement): ILoadingScreen;
        /**
         * Method called to create the default rescale post process on each engine.
         */
        static _RescalePostProcessFactory: Nullable<(engine: Engine) => PostProcess>;
        /**
         * Gets or sets a boolean to enable/disable IndexedDB support and avoid XHR on .manifest
         **/
        enableOfflineSupport: boolean;
        /**
         * Gets or sets a boolean to enable/disable checking manifest if IndexedDB support is enabled (js will always consider the database is up to date)
         **/
        disableManifestCheck: boolean;
        /**
         * Gets the list of created scenes
         */
        scenes: Scene[];
        /**
         * Event raised when a new scene is created
         */
        onNewSceneAddedObservable: Observable<Scene>;
        /**
         * Gets the list of created postprocesses
         */
        postProcesses: PostProcess[];
        /**
         * Gets a boolean indicating if the pointer is currently locked
         */
        isPointerLock: boolean;
        /**
         * Observable event triggered each time the rendering canvas is resized
         */
        onResizeObservable: Observable<Engine>;
        /**
         * Observable event triggered each time the canvas loses focus
         */
        onCanvasBlurObservable: Observable<Engine>;
        /**
         * Observable event triggered each time the canvas gains focus
         */
        onCanvasFocusObservable: Observable<Engine>;
        /**
         * Observable event triggered each time the canvas receives pointerout event
         */
        onCanvasPointerOutObservable: Observable<PointerEvent>;
        /**
         * Observable raised when the engine begins a new frame
         */
        onBeginFrameObservable: Observable<Engine>;
        /**
         * If set, will be used to request the next animation frame for the render loop
         */
        customAnimationFrameRequester: Nullable<ICustomAnimationFrameRequester>;
        /**
         * Observable raised when the engine ends the current frame
         */
        onEndFrameObservable: Observable<Engine>;
        /**
         * Observable raised when the engine is about to compile a shader
         */
        onBeforeShaderCompilationObservable: Observable<Engine>;
        /**
         * Observable raised when the engine has jsut compiled a shader
         */
        onAfterShaderCompilationObservable: Observable<Engine>;
        /**
         * Gets the audio engine
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music
         * @ignorenaming
         */
        static audioEngine: IAudioEngine;
        /**
         * Default AudioEngine factory responsible of creating the Audio Engine.
         * By default, this will create a BabylonJS Audio Engine if the workload has been embedded.
         */
        static AudioEngineFactory: (hostElement: Nullable<HTMLElement>) => IAudioEngine;
        /**
         * Default offline support factory responsible of creating a tool used to store data locally.
         * By default, this will create a Database object if the workload has been embedded.
         */
        static OfflineProviderFactory: (urlToScene: string, callbackManifestChecked: (checked: boolean) => any, disableManifestCheck: boolean) => IOfflineProvider;
        private _loadingScreen;
        private _pointerLockRequested;
        private _rescalePostProcess;
        private _deterministicLockstep;
        private _lockstepMaxSteps;
        private _timeStep;
        protected get _supportsHardwareTextureRescaling(): boolean;
        private _fps;
        private _deltaTime;
        /** @hidden */
        _drawCalls: PerfCounter;
        /** Gets or sets the tab index to set to the rendering canvas. 1 is the minimum value to set to be able to capture keyboard events */
        canvasTabIndex: number;
        /**
         * Turn this value on if you want to pause FPS computation when in background
         */
        disablePerformanceMonitorInBackground: boolean;
        private _performanceMonitor;
        /**
         * Gets the performance monitor attached to this engine
         * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#engineinstrumentation
         */
        get performanceMonitor(): PerformanceMonitor;
        private _onFocus;
        private _onBlur;
        private _onCanvasPointerOut;
        private _onCanvasBlur;
        private _onCanvasFocus;
        private _onFullscreenChange;
        private _onPointerLockChange;
        /**
         * Gets the HTML element used to attach event listeners
         * @returns a HTML element
         */
        getInputElement(): Nullable<HTMLElement>;
        /**
         * Creates a new engine
         * @param canvasOrContext defines the canvas or WebGL context to use for rendering. If you provide a WebGL context, Babylon.js will not hook events on the canvas (like pointers, keyboards, etc...) so no event observables will be available. This is mostly used when Babylon.js is used as a plugin on a system which alreay used the WebGL context
         * @param antialias defines enable antialiasing (default: false)
         * @param options defines further options to be sent to the getContext() function
         * @param adaptToDeviceRatio defines whether to adapt to the device's viewport characteristics (default: false)
         */
        constructor(canvasOrContext: Nullable<HTMLCanvasElement | WebGLRenderingContext>, antialias?: boolean, options?: EngineOptions, adaptToDeviceRatio?: boolean);
        /**
         * Gets current aspect ratio
         * @param viewportOwner defines the camera to use to get the aspect ratio
         * @param useScreen defines if screen size must be used (or the current render target if any)
         * @returns a number defining the aspect ratio
         */
        getAspectRatio(viewportOwner: IViewportOwnerLike, useScreen?: boolean): number;
        /**
         * Gets current screen aspect ratio
         * @returns a number defining the aspect ratio
         */
        getScreenAspectRatio(): number;
        /**
         * Gets the client rect of the HTML canvas attached with the current webGL context
         * @returns a client rectanglee
         */
        getRenderingCanvasClientRect(): Nullable<ClientRect>;
        /**
         * Gets the client rect of the HTML element used for events
         * @returns a client rectanglee
         */
        getInputElementClientRect(): Nullable<ClientRect>;
        /**
         * Gets a boolean indicating that the engine is running in deterministic lock step mode
         * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         * @returns true if engine is in deterministic lock step mode
         */
        isDeterministicLockStep(): boolean;
        /**
         * Gets the max steps when engine is running in deterministic lock step
         * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         * @returns the max steps
         */
        getLockstepMaxSteps(): number;
        /**
         * Returns the time in ms between steps when using deterministic lock step.
         * @returns time step in (ms)
         */
        getTimeStep(): number;
        /**
         * Force the mipmap generation for the given render target texture
         * @param texture defines the render target texture to use
         * @param unbind defines whether or not to unbind the texture after generation. Defaults to true.
         */
        generateMipMapsForCubemap(texture: InternalTexture, unbind?: boolean): void;
        /** States */
        /**
         * Set various states to the webGL context
         * @param culling defines backface culling state
         * @param zOffset defines the value to apply to zOffset (0 by default)
         * @param force defines if states must be applied even if cache is up to date
         * @param reverseSide defines if culling must be reversed (CCW instead of CW and CW instead of CCW)
         */
        setState(culling: boolean, zOffset?: number, force?: boolean, reverseSide?: boolean): void;
        /**
         * Set the z offset to apply to current rendering
         * @param value defines the offset to apply
         */
        setZOffset(value: number): void;
        /**
         * Gets the current value of the zOffset
         * @returns the current zOffset state
         */
        getZOffset(): number;
        /**
         * Enable or disable depth buffering
         * @param enable defines the state to set
         */
        setDepthBuffer(enable: boolean): void;
        /**
         * Gets a boolean indicating if depth writing is enabled
         * @returns the current depth writing state
         */
        getDepthWrite(): boolean;
        /**
         * Enable or disable depth writing
         * @param enable defines the state to set
         */
        setDepthWrite(enable: boolean): void;
        /**
         * Gets a boolean indicating if stencil buffer is enabled
         * @returns the current stencil buffer state
         */
        getStencilBuffer(): boolean;
        /**
         * Enable or disable the stencil buffer
         * @param enable defines if the stencil buffer must be enabled or disabled
         */
        setStencilBuffer(enable: boolean): void;
        /**
         * Gets the current stencil mask
         * @returns a number defining the new stencil mask to use
         */
        getStencilMask(): number;
        /**
         * Sets the current stencil mask
         * @param mask defines the new stencil mask to use
         */
        setStencilMask(mask: number): void;
        /**
         * Gets the current stencil function
         * @returns a number defining the stencil function to use
         */
        getStencilFunction(): number;
        /**
         * Gets the current stencil reference value
         * @returns a number defining the stencil reference value to use
         */
        getStencilFunctionReference(): number;
        /**
         * Gets the current stencil mask
         * @returns a number defining the stencil mask to use
         */
        getStencilFunctionMask(): number;
        /**
         * Sets the current stencil function
         * @param stencilFunc defines the new stencil function to use
         */
        setStencilFunction(stencilFunc: number): void;
        /**
         * Sets the current stencil reference
         * @param reference defines the new stencil reference to use
         */
        setStencilFunctionReference(reference: number): void;
        /**
         * Sets the current stencil mask
         * @param mask defines the new stencil mask to use
         */
        setStencilFunctionMask(mask: number): void;
        /**
         * Gets the current stencil operation when stencil fails
         * @returns a number defining stencil operation to use when stencil fails
         */
        getStencilOperationFail(): number;
        /**
         * Gets the current stencil operation when depth fails
         * @returns a number defining stencil operation to use when depth fails
         */
        getStencilOperationDepthFail(): number;
        /**
         * Gets the current stencil operation when stencil passes
         * @returns a number defining stencil operation to use when stencil passes
         */
        getStencilOperationPass(): number;
        /**
         * Sets the stencil operation to use when stencil fails
         * @param operation defines the stencil operation to use when stencil fails
         */
        setStencilOperationFail(operation: number): void;
        /**
         * Sets the stencil operation to use when depth fails
         * @param operation defines the stencil operation to use when depth fails
         */
        setStencilOperationDepthFail(operation: number): void;
        /**
         * Sets the stencil operation to use when stencil passes
         * @param operation defines the stencil operation to use when stencil passes
         */
        setStencilOperationPass(operation: number): void;
        /**
         * Sets a boolean indicating if the dithering state is enabled or disabled
         * @param value defines the dithering state
         */
        setDitheringState(value: boolean): void;
        /**
         * Sets a boolean indicating if the rasterizer state is enabled or disabled
         * @param value defines the rasterizer state
         */
        setRasterizerState(value: boolean): void;
        /**
         * Gets the current depth function
         * @returns a number defining the depth function
         */
        getDepthFunction(): Nullable<number>;
        /**
         * Sets the current depth function
         * @param depthFunc defines the function to use
         */
        setDepthFunction(depthFunc: number): void;
        /**
         * Sets the current depth function to GREATER
         */
        setDepthFunctionToGreater(): void;
        /**
         * Sets the current depth function to GEQUAL
         */
        setDepthFunctionToGreaterOrEqual(): void;
        /**
         * Sets the current depth function to LESS
         */
        setDepthFunctionToLess(): void;
        /**
         * Sets the current depth function to LEQUAL
         */
        setDepthFunctionToLessOrEqual(): void;
        private _cachedStencilBuffer;
        private _cachedStencilFunction;
        private _cachedStencilMask;
        private _cachedStencilOperationPass;
        private _cachedStencilOperationFail;
        private _cachedStencilOperationDepthFail;
        private _cachedStencilReference;
        /**
         * Caches the the state of the stencil buffer
         */
        cacheStencilState(): void;
        /**
         * Restores the state of the stencil buffer
         */
        restoreStencilState(): void;
        /**
         * Directly set the WebGL Viewport
         * @param x defines the x coordinate of the viewport (in screen space)
         * @param y defines the y coordinate of the viewport (in screen space)
         * @param width defines the width of the viewport (in screen space)
         * @param height defines the height of the viewport (in screen space)
         * @return the current viewport Object (if any) that is being replaced by this call. You can restore this viewport later on to go back to the original state
         */
        setDirectViewport(x: number, y: number, width: number, height: number): Nullable<IViewportLike>;
        /**
         * Executes a scissor clear (ie. a clear on a specific portion of the screen)
         * @param x defines the x-coordinate of the top left corner of the clear rectangle
         * @param y defines the y-coordinate of the corner of the clear rectangle
         * @param width defines the width of the clear rectangle
         * @param height defines the height of the clear rectangle
         * @param clearColor defines the clear color
         */
        scissorClear(x: number, y: number, width: number, height: number, clearColor: IColor4Like): void;
        /**
         * Enable scissor test on a specific rectangle (ie. render will only be executed on a specific portion of the screen)
         * @param x defines the x-coordinate of the top left corner of the clear rectangle
         * @param y defines the y-coordinate of the corner of the clear rectangle
         * @param width defines the width of the clear rectangle
         * @param height defines the height of the clear rectangle
         */
        enableScissor(x: number, y: number, width: number, height: number): void;
        /**
         * Disable previously set scissor test rectangle
         */
        disableScissor(): void;
        protected _reportDrawCall(): void;
        /**
         * Initializes a webVR display and starts listening to display change events
         * The onVRDisplayChangedObservable will be notified upon these changes
         * @returns The onVRDisplayChangedObservable
         */
        initWebVR(): Observable<IDisplayChangedEventArgs>;
        /** @hidden */
        _prepareVRComponent(): void;
        /** @hidden */
        _connectVREvents(canvas?: HTMLCanvasElement, document?: any): void;
        /** @hidden */
        _submitVRFrame(): void;
        /**
         * Call this function to leave webVR mode
         * Will do nothing if webVR is not supported or if there is no webVR device
         * @see https://doc.babylonjs.com/how_to/webvr_camera
         */
        disableVR(): void;
        /**
         * Gets a boolean indicating that the system is in VR mode and is presenting
         * @returns true if VR mode is engaged
         */
        isVRPresenting(): boolean;
        /** @hidden */
        _requestVRFrame(): void;
        /** @hidden */
        _loadFileAsync(url: string, offlineProvider?: IOfflineProvider, useArrayBuffer?: boolean): Promise<string | ArrayBuffer>;
        /**
        * Gets the source code of the vertex shader associated with a specific webGL program
        * @param program defines the program to use
        * @returns a string containing the source code of the vertex shader associated with the program
        */
        getVertexShaderSource(program: WebGLProgram): Nullable<string>;
        /**
         * Gets the source code of the fragment shader associated with a specific webGL program
         * @param program defines the program to use
         * @returns a string containing the source code of the fragment shader associated with the program
         */
        getFragmentShaderSource(program: WebGLProgram): Nullable<string>;
        /**
         * Sets a depth stencil texture from a render target to the according uniform.
         * @param channel The texture channel
         * @param uniform The uniform to set
         * @param texture The render target texture containing the depth stencil texture to apply
         */
        setDepthStencilTexture(channel: number, uniform: Nullable<WebGLUniformLocation>, texture: Nullable<RenderTargetTexture>): void;
        /**
         * Sets a texture to the webGL context from a postprocess
         * @param channel defines the channel to use
         * @param postProcess defines the source postprocess
         */
        setTextureFromPostProcess(channel: number, postProcess: Nullable<PostProcess>): void;
        /**
         * Binds the output of the passed in post process to the texture channel specified
         * @param channel The channel the texture should be bound to
         * @param postProcess The post process which's output should be bound
         */
        setTextureFromPostProcessOutput(channel: number, postProcess: Nullable<PostProcess>): void;
        protected _rebuildBuffers(): void;
        /** @hidden */
        _renderFrame(): void;
        _renderLoop(): void;
        /** @hidden */
        _renderViews(): boolean;
        /**
         * Toggle full screen mode
         * @param requestPointerLock defines if a pointer lock should be requested from the user
         */
        switchFullscreen(requestPointerLock: boolean): void;
        /**
         * Enters full screen mode
         * @param requestPointerLock defines if a pointer lock should be requested from the user
         */
        enterFullscreen(requestPointerLock: boolean): void;
        /**
         * Exits full screen mode
         */
        exitFullscreen(): void;
        /**
         * Enters Pointerlock mode
         */
        enterPointerlock(): void;
        /**
         * Exits Pointerlock mode
         */
        exitPointerlock(): void;
        /**
         * Begin a new frame
         */
        beginFrame(): void;
        /**
         * Enf the current frame
         */
        endFrame(): void;
        resize(): void;
        /**
         * Force a specific size of the canvas
         * @param width defines the new canvas' width
         * @param height defines the new canvas' height
         * @returns true if the size was changed
         */
        setSize(width: number, height: number): boolean;
        _deletePipelineContext(pipelineContext: IPipelineContext): void;
        createShaderProgram(pipelineContext: IPipelineContext, vertexCode: string, fragmentCode: string, defines: Nullable<string>, context?: WebGLRenderingContext, transformFeedbackVaryings?: Nullable<string[]>): WebGLProgram;
        protected _createShaderProgram(pipelineContext: WebGLPipelineContext, vertexShader: WebGLShader, fragmentShader: WebGLShader, context: WebGLRenderingContext, transformFeedbackVaryings?: Nullable<string[]>): WebGLProgram;
        _releaseTexture(texture: InternalTexture): void;
        /**
         * @hidden
         * Rescales a texture
         * @param source input texutre
         * @param destination destination texture
         * @param scene scene to use to render the resize
         * @param internalFormat format to use when resizing
         * @param onComplete callback to be called when resize has completed
         */
        _rescaleTexture(source: InternalTexture, destination: InternalTexture, scene: Nullable<any>, internalFormat: number, onComplete: () => void): void;
        /**
         * Gets the current framerate
         * @returns a number representing the framerate
         */
        getFps(): number;
        /**
         * Gets the time spent between current and previous frame
         * @returns a number representing the delta time in ms
         */
        getDeltaTime(): number;
        private _measureFps;
        /** @hidden */
        _uploadImageToTexture(texture: InternalTexture, image: HTMLImageElement | ImageBitmap, faceIndex?: number, lod?: number): void;
        /**
         * Updates the sample count of a render target texture
         * @see https://doc.babylonjs.com/features/webgl2#multisample-render-targets
         * @param texture defines the texture to update
         * @param samples defines the sample count to set
         * @returns the effective sample count (could be 0 if multisample render targets are not supported)
         */
        updateRenderTargetTextureSampleCount(texture: Nullable<InternalTexture>, samples: number): number;
        /**
         * Updates a depth texture Comparison Mode and Function.
         * If the comparison Function is equal to 0, the mode will be set to none.
         * Otherwise, this only works in webgl 2 and requires a shadow sampler in the shader.
         * @param texture The texture to set the comparison function for
         * @param comparisonFunction The comparison function to set, 0 if no comparison required
         */
        updateTextureComparisonFunction(texture: InternalTexture, comparisonFunction: number): void;
        /**
         * Creates a webGL buffer to use with instanciation
         * @param capacity defines the size of the buffer
         * @returns the webGL buffer
         */
        createInstancesBuffer(capacity: number): DataBuffer;
        /**
         * Delete a webGL buffer used with instanciation
         * @param buffer defines the webGL buffer to delete
         */
        deleteInstancesBuffer(buffer: WebGLBuffer): void;
        private _clientWaitAsync;
        /** @hidden */
        _readPixelsAsync(x: number, y: number, w: number, h: number, format: number, type: number, outputBuffer: ArrayBufferView): Promise<ArrayBufferView> | null;
        dispose(): void;
        private _disableTouchAction;
        /**
         * Display the loading screen
         * @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
         */
        displayLoadingUI(): void;
        /**
         * Hide the loading screen
         * @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
         */
        hideLoadingUI(): void;
        /**
         * Gets the current loading screen object
         * @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
         */
        get loadingScreen(): ILoadingScreen;
        /**
         * Sets the current loading screen object
         * @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
         */
        set loadingScreen(loadingScreen: ILoadingScreen);
        /**
         * Sets the current loading screen text
         * @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
         */
        set loadingUIText(text: string);
        /**
         * Sets the current loading screen background color
         * @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
         */
        set loadingUIBackgroundColor(color: string);
        /** Pointerlock and fullscreen */
        /**
         * Ask the browser to promote the current element to pointerlock mode
         * @param element defines the DOM element to promote
         */
        static _RequestPointerlock(element: HTMLElement): void;
        /**
         * Asks the browser to exit pointerlock mode
         */
        static _ExitPointerlock(): void;
        /**
         * Ask the browser to promote the current element to fullscreen rendering mode
         * @param element defines the DOM element to promote
         */
        static _RequestFullscreen(element: HTMLElement): void;
        /**
         * Asks the browser to exit fullscreen mode
         */
        static _ExitFullscreen(): void;
    }
}
declare module BABYLON {
    /**
     * The engine store class is responsible to hold all the instances of Engine and Scene created
     * during the life time of the application.
     */
    export class EngineStore {
        /** Gets the list of created engines */
        static Instances: Engine[];
        /** @hidden */
        static _LastCreatedScene: Nullable<Scene>;
        /**
         * Gets the latest created engine
         */
        static get LastCreatedEngine(): Nullable<Engine>;
        /**
         * Gets the latest created scene
         */
        static get LastCreatedScene(): Nullable<Scene>;
        /**
         * Gets or sets a global variable indicating if fallback texture must be used when a texture cannot be loaded
         * @ignorenaming
         */
        static UseFallbackTexture: boolean;
        /**
         * Texture content used if a texture cannot loaded
         * @ignorenaming
         */
        static FallbackTexture: string;
    }
}
declare module BABYLON {
    /**
     * Helper class that provides a small promise polyfill
     */
    export class PromisePolyfill {
        /**
         * Static function used to check if the polyfill is required
         * If this is the case then the function will inject the polyfill to window.Promise
         * @param force defines a boolean used to force the injection (mostly for testing purposes)
         */
        static Apply(force?: boolean): void;
    }
}
declare module BABYLON {
    /**
     * Interface for screenshot methods with describe argument called `size` as object with options
     * @link https://doc.babylonjs.com/api/classes/babylon.screenshottools
     */
    export interface IScreenshotSize {
        /**
         * number in pixels for canvas height
         */
        height?: number;
        /**
         * multiplier allowing render at a higher or lower resolution
         * If value is defined then height and width will be ignored and taken from camera
         */
        precision?: number;
        /**
         * number in pixels for canvas width
         */
        width?: number;
    }
}
declare module BABYLON {
    interface IColor4Like {
        r: float;
        g: float;
        b: float;
        a: float;
    }
    /**
     * Class containing a set of static utilities functions
     */
    export class Tools {
        /**
         * Gets or sets the base URL to use to load assets
         */
        static get BaseUrl(): string;
        static set BaseUrl(value: string);
        /**
         * Enable/Disable Custom HTTP Request Headers globally.
         * default = false
         * @see CustomRequestHeaders
         */
        static UseCustomRequestHeaders: boolean;
        /**
         * Custom HTTP Request Headers to be sent with XMLHttpRequests
         * i.e. when loading files, where the server/service expects an Authorization header
         */
        static CustomRequestHeaders: {
            [key: string]: string;
        };
        /**
         * Gets or sets the retry strategy to apply when an error happens while loading an asset
         */
        static get DefaultRetryStrategy(): (url: string, request: WebRequest, retryIndex: number) => number;
        static set DefaultRetryStrategy(strategy: (url: string, request: WebRequest, retryIndex: number) => number);
        /**
         * Default behaviour for cors in the application.
         * It can be a string if the expected behavior is identical in the entire app.
         * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)
         */
        static get CorsBehavior(): string | ((url: string | string[]) => string);
        static set CorsBehavior(value: string | ((url: string | string[]) => string));
        /**
         * Gets or sets a global variable indicating if fallback texture must be used when a texture cannot be loaded
         * @ignorenaming
         */
        static get UseFallbackTexture(): boolean;
        static set UseFallbackTexture(value: boolean);
        /**
         * Use this object to register external classes like custom textures or material
         * to allow the laoders to instantiate them
         */
        static get RegisteredExternalClasses(): {
            [key: string]: Object;
        };
        static set RegisteredExternalClasses(classes: {
            [key: string]: Object;
        });
        /**
         * Texture content used if a texture cannot loaded
         * @ignorenaming
         */
        static get fallbackTexture(): string;
        static set fallbackTexture(value: string);
        /**
         * Read the content of a byte array at a specified coordinates (taking in account wrapping)
         * @param u defines the coordinate on X axis
         * @param v defines the coordinate on Y axis
         * @param width defines the width of the source data
         * @param height defines the height of the source data
         * @param pixels defines the source byte array
         * @param color defines the output color
         */
        static FetchToRef(u: number, v: number, width: number, height: number, pixels: Uint8Array, color: IColor4Like): void;
        /**
         * Interpolates between a and b via alpha
         * @param a The lower value (returned when alpha = 0)
         * @param b The upper value (returned when alpha = 1)
         * @param alpha The interpolation-factor
         * @return The mixed value
         */
        static Mix(a: number, b: number, alpha: number): number;
        /**
         * Tries to instantiate a new object from a given class name
         * @param className defines the class name to instantiate
         * @returns the new object or null if the system was not able to do the instantiation
         */
        static Instantiate(className: string): any;
        /**
         * Provides a slice function that will work even on IE
         * @param data defines the array to slice
         * @param start defines the start of the data (optional)
         * @param end defines the end of the data (optional)
         * @returns the new sliced array
         */
        static Slice<T>(data: T, start?: number, end?: number): T;
        /**
         * Polyfill for setImmediate
         * @param action defines the action to execute after the current execution block
         */
        static SetImmediate(action: () => void): void;
        /**
         * Function indicating if a number is an exponent of 2
         * @param value defines the value to test
         * @returns true if the value is an exponent of 2
         */
        static IsExponentOfTwo(value: number): boolean;
        private static _tmpFloatArray;
        /**
         * Returns the nearest 32-bit single precision float representation of a Number
         * @param value A Number.  If the parameter is of a different type, it will get converted
         * to a number or to NaN if it cannot be converted
         * @returns number
         */
        static FloatRound(value: number): number;
        /**
         * Extracts the filename from a path
         * @param path defines the path to use
         * @returns the filename
         */
        static GetFilename(path: string): string;
        /**
         * Extracts the "folder" part of a path (everything before the filename).
         * @param uri The URI to extract the info from
         * @param returnUnchangedIfNoSlash Do not touch the URI if no slashes are present
         * @returns The "folder" part of the path
         */
        static GetFolderPath(uri: string, returnUnchangedIfNoSlash?: boolean): string;
        /**
         * Extracts text content from a DOM element hierarchy
         * Back Compat only, please use DomManagement.GetDOMTextContent instead.
         */
        static GetDOMTextContent: typeof DomManagement.GetDOMTextContent;
        /**
         * Convert an angle in radians to degrees
         * @param angle defines the angle to convert
         * @returns the angle in degrees
         */
        static ToDegrees(angle: number): number;
        /**
         * Convert an angle in degrees to radians
         * @param angle defines the angle to convert
         * @returns the angle in radians
         */
        static ToRadians(angle: number): number;
        /**
         * Returns an array if obj is not an array
         * @param obj defines the object to evaluate as an array
         * @param allowsNullUndefined defines a boolean indicating if obj is allowed to be null or undefined
         * @returns either obj directly if obj is an array or a new array containing obj
         */
        static MakeArray(obj: any, allowsNullUndefined?: boolean): Nullable<Array<any>>;
        /**
         * Gets the pointer prefix to use
         * @param engine defines the engine we are finding the prefix for
         * @returns "pointer" if touch is enabled. Else returns "mouse"
         */
        static GetPointerPrefix(engine: Engine): string;
        /**
         * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.
         * @param url define the url we are trying
         * @param element define the dom element where to configure the cors policy
         */
        static SetCorsBehavior(url: string | string[], element: {
            crossOrigin: string | null;
        }): void;
        /**
         * Removes unwanted characters from an url
         * @param url defines the url to clean
         * @returns the cleaned url
         */
        static CleanUrl(url: string): string;
        /**
         * Gets or sets a function used to pre-process url before using them to load assets
         */
        static get PreprocessUrl(): (url: string) => string;
        static set PreprocessUrl(processor: (url: string) => string);
        /**
        * Loads an image as an HTMLImageElement.
        * @param input url string, ArrayBuffer, or Blob to load
        * @param onLoad callback called when the image successfully loads
        * @param onError callback called when the image fails to load
        * @param offlineProvider offline provider for caching
        * @param mimeType optional mime type
        * @returns the HTMLImageElement of the loaded image
        */
        static LoadImage(input: string | ArrayBuffer | Blob, onLoad: (img: HTMLImageElement | ImageBitmap) => void, onError: (message?: string, exception?: any) => void, offlineProvider: Nullable<IOfflineProvider>, mimeType?: string): Nullable<HTMLImageElement>;
        /**
         * Loads a file from a url
         * @param url url string, ArrayBuffer, or Blob to load
         * @param onSuccess callback called when the file successfully loads
         * @param onProgress callback called while file is loading (if the server supports this mode)
         * @param offlineProvider defines the offline provider for caching
         * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer
         * @param onError callback called when the file fails to load
         * @returns a file request object
         */
        static LoadFile(url: string, onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void, onProgress?: (data: any) => void, offlineProvider?: IOfflineProvider, useArrayBuffer?: boolean, onError?: (request?: WebRequest, exception?: any) => void): IFileRequest;
        /**
         * Loads a file from a url
         * @param url the file url to load
         * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer
         * @returns a promise containing an ArrayBuffer corresponding to the loaded file
         */
        static LoadFileAsync(url: string, useArrayBuffer?: boolean): Promise<ArrayBuffer | string>;
        /**
         * Load a script (identified by an url). When the url returns, the
         * content of this file is added into a new script element, attached to the DOM (body element)
         * @param scriptUrl defines the url of the script to laod
         * @param onSuccess defines the callback called when the script is loaded
         * @param onError defines the callback to call if an error occurs
         * @param scriptId defines the id of the script element
         */
        static LoadScript(scriptUrl: string, onSuccess: () => void, onError?: (message?: string, exception?: any) => void, scriptId?: string): void;
        /**
         * Load an asynchronous script (identified by an url). When the url returns, the
         * content of this file is added into a new script element, attached to the DOM (body element)
         * @param scriptUrl defines the url of the script to laod
         * @param scriptId defines the id of the script element
         * @returns a promise request object
         */
        static LoadScriptAsync(scriptUrl: string, scriptId?: string): Promise<void>;
        /**
         * Loads a file from a blob
         * @param fileToLoad defines the blob to use
         * @param callback defines the callback to call when data is loaded
         * @param progressCallback defines the callback to call during loading process
         * @returns a file request object
         */
        static ReadFileAsDataURL(fileToLoad: Blob, callback: (data: any) => void, progressCallback: (ev: ProgressEvent) => any): IFileRequest;
        /**
         * Reads a file from a File object
         * @param file defines the file to load
         * @param onSuccess defines the callback to call when data is loaded
         * @param onProgress defines the callback to call during loading process
         * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer
         * @param onError defines the callback to call when an error occurs
         * @returns a file request object
         */
        static ReadFile(file: File, onSuccess: (data: any) => void, onProgress?: (ev: ProgressEvent) => any, useArrayBuffer?: boolean, onError?: (error: ReadFileError) => void): IFileRequest;
        /**
         * Creates a data url from a given string content
         * @param content defines the content to convert
         * @returns the new data url link
         */
        static FileAsURL(content: string): string;
        /**
         * Format the given number to a specific decimal format
         * @param value defines the number to format
         * @param decimals defines the number of decimals to use
         * @returns the formatted string
         */
        static Format(value: number, decimals?: number): string;
        /**
         * Tries to copy an object by duplicating every property
         * @param source defines the source object
         * @param destination defines the target object
         * @param doNotCopyList defines a list of properties to avoid
         * @param mustCopyList defines a list of properties to copy (even if they start with _)
         */
        static DeepCopy(source: any, destination: any, doNotCopyList?: string[], mustCopyList?: string[]): void;
        /**
         * Gets a boolean indicating if the given object has no own property
         * @param obj defines the object to test
         * @returns true if object has no own property
         */
        static IsEmpty(obj: any): boolean;
        /**
         * Function used to register events at window level
         * @param windowElement defines the Window object to use
         * @param events defines the events to register
         */
        static RegisterTopRootEvents(windowElement: Window, events: {
            name: string;
            handler: Nullable<(e: FocusEvent) => any>;
        }[]): void;
        /**
         * Function used to unregister events from window level
         * @param windowElement defines the Window object to use
         * @param events defines the events to unregister
         */
        static UnregisterTopRootEvents(windowElement: Window, events: {
            name: string;
            handler: Nullable<(e: FocusEvent) => any>;
        }[]): void;
        /**
         * @ignore
         */
        static _ScreenshotCanvas: HTMLCanvasElement;
        /**
         * Dumps the current bound framebuffer
         * @param width defines the rendering width
         * @param height defines the rendering height
         * @param engine defines the hosting engine
         * @param successCallback defines the callback triggered once the data are available
         * @param mimeType defines the mime type of the result
         * @param fileName defines the filename to download. If present, the result will automatically be downloaded
         */
        static DumpFramebuffer(width: number, height: number, engine: Engine, successCallback?: (data: string) => void, mimeType?: string, fileName?: string): void;
        /**
         * Converts the canvas data to blob.
         * This acts as a polyfill for browsers not supporting the to blob function.
         * @param canvas Defines the canvas to extract the data from
         * @param successCallback Defines the callback triggered once the data are available
         * @param mimeType Defines the mime type of the result
         */
        static ToBlob(canvas: HTMLCanvasElement, successCallback: (blob: Nullable<Blob>) => void, mimeType?: string): void;
        /**
         * Encodes the canvas data to base 64 or automatically download the result if filename is defined
         * @param successCallback defines the callback triggered once the data are available
         * @param mimeType defines the mime type of the result
         * @param fileName defines he filename to download. If present, the result will automatically be downloaded
         */
        static EncodeScreenshotCanvasData(successCallback?: (data: string) => void, mimeType?: string, fileName?: string): void;
        /**
         * Downloads a blob in the browser
         * @param blob defines the blob to download
         * @param fileName defines the name of the downloaded file
         */
        static Download(blob: Blob, fileName: string): void;
        /**
         * Captures a screenshot of the current rendering
         * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png
         * @param engine defines the rendering engine
         * @param camera defines the source camera
         * @param size This parameter can be set to a single number or to an object with the
         * following (optional) properties: precision, width, height. If a single number is passed,
         * it will be used for both width and height. If an object is passed, the screenshot size
         * will be derived from the parameters. The precision property is a multiplier allowing
         * rendering at a higher or lower resolution
         * @param successCallback defines the callback receives a single parameter which contains the
         * screenshot as a string of base64-encoded characters. This string can be assigned to the
         * src parameter of an <img> to display it
         * @param mimeType defines the MIME type of the screenshot image (default: image/png).
         * Check your browser for supported MIME types
         */
        static CreateScreenshot(engine: Engine, camera: Camera, size: IScreenshotSize | number, successCallback?: (data: string) => void, mimeType?: string): void;
        /**
         * Captures a screenshot of the current rendering
         * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png
         * @param engine defines the rendering engine
         * @param camera defines the source camera
         * @param size This parameter can be set to a single number or to an object with the
         * following (optional) properties: precision, width, height. If a single number is passed,
         * it will be used for both width and height. If an object is passed, the screenshot size
         * will be derived from the parameters. The precision property is a multiplier allowing
         * rendering at a higher or lower resolution
         * @param mimeType defines the MIME type of the screenshot image (default: image/png).
         * Check your browser for supported MIME types
         * @returns screenshot as a string of base64-encoded characters. This string can be assigned
         * to the src parameter of an <img> to display it
         */
        static CreateScreenshotAsync(engine: Engine, camera: Camera, size: IScreenshotSize | number, mimeType?: string): Promise<string>;
        /**
         * Generates an image screenshot from the specified camera.
         * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png
         * @param engine The engine to use for rendering
         * @param camera The camera to use for rendering
         * @param size This parameter can be set to a single number or to an object with the
         * following (optional) properties: precision, width, height. If a single number is passed,
         * it will be used for both width and height. If an object is passed, the screenshot size
         * will be derived from the parameters. The precision property is a multiplier allowing
         * rendering at a higher or lower resolution
         * @param successCallback The callback receives a single parameter which contains the
         * screenshot as a string of base64-encoded characters. This string can be assigned to the
         * src parameter of an <img> to display it
         * @param mimeType The MIME type of the screenshot image (default: image/png).
         * Check your browser for supported MIME types
         * @param samples Texture samples (default: 1)
         * @param antialiasing Whether antialiasing should be turned on or not (default: false)
         * @param fileName A name for for the downloaded file.
         */
        static CreateScreenshotUsingRenderTarget(engine: Engine, camera: Camera, size: IScreenshotSize | number, successCallback?: (data: string) => void, mimeType?: string, samples?: number, antialiasing?: boolean, fileName?: string): void;
        /**
         * Generates an image screenshot from the specified camera.
         * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png
         * @param engine The engine to use for rendering
         * @param camera The camera to use for rendering
         * @param size This parameter can be set to a single number or to an object with the
         * following (optional) properties: precision, width, height. If a single number is passed,
         * it will be used for both width and height. If an object is passed, the screenshot size
         * will be derived from the parameters. The precision property is a multiplier allowing
         * rendering at a higher or lower resolution
         * @param mimeType The MIME type of the screenshot image (default: image/png).
         * Check your browser for supported MIME types
         * @param samples Texture samples (default: 1)
         * @param antialiasing Whether antialiasing should be turned on or not (default: false)
         * @param fileName A name for for the downloaded file.
         * @returns screenshot as a string of base64-encoded characters. This string can be assigned
         * to the src parameter of an <img> to display it
         */
        static CreateScreenshotUsingRenderTargetAsync(engine: Engine, camera: Camera, size: IScreenshotSize | number, mimeType?: string, samples?: number, antialiasing?: boolean, fileName?: string): Promise<string>;
        /**
         * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
         * Be aware Math.random() could cause collisions, but:
         * "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
         * @returns a pseudo random id
         */
        static RandomId(): string;
        /**
        * Test if the given uri is a base64 string
        * @param uri The uri to test
        * @return True if the uri is a base64 string or false otherwise
        */
        static IsBase64(uri: string): boolean;
        /**
        * Decode the given base64 uri.
        * @param uri The uri to decode
        * @return The decoded base64 data.
        */
        static DecodeBase64(uri: string): ArrayBuffer;
        /**
         * Gets the absolute url.
         * @param url the input url
         * @return the absolute url
         */
        static GetAbsoluteUrl(url: string): string;
        /**
         * No log
         */
        static readonly NoneLogLevel: number;
        /**
         * Only message logs
         */
        static readonly MessageLogLevel: number;
        /**
         * Only warning logs
         */
        static readonly WarningLogLevel: number;
        /**
         * Only error logs
         */
        static readonly ErrorLogLevel: number;
        /**
         * All logs
         */
        static readonly AllLogLevel: number;
        /**
         * Gets a value indicating the number of loading errors
         * @ignorenaming
         */
        static get errorsCount(): number;
        /**
         * Callback called when a new log is added
         */
        static OnNewCacheEntry: (entry: string) => void;
        /**
         * Log a message to the console
         * @param message defines the message to log
         */
        static Log(message: string): void;
        /**
         * Write a warning message to the console
         * @param message defines the message to log
         */
        static Warn(message: string): void;
        /**
         * Write an error message to the console
         * @param message defines the message to log
         */
        static Error(message: string): void;
        /**
         * Gets current log cache (list of logs)
         */
        static get LogCache(): string;
        /**
         * Clears the log cache
         */
        static ClearLogCache(): void;
        /**
         * Sets the current log level (MessageLogLevel / WarningLogLevel / ErrorLogLevel)
         */
        static set LogLevels(level: number);
        /**
         * Checks if the window object exists
         * Back Compat only, please use DomManagement.IsWindowObjectExist instead.
         */
        static IsWindowObjectExist: typeof DomManagement.IsWindowObjectExist;
        /**
         * No performance log
         */
        static readonly PerformanceNoneLogLevel: number;
        /**
         * Use user marks to log performance
         */
        static readonly PerformanceUserMarkLogLevel: number;
        /**
         * Log performance to the console
         */
        static readonly PerformanceConsoleLogLevel: number;
        private static _performance;
        /**
         * Sets the current performance log level
         */
        static set PerformanceLogLevel(level: number);
        private static _StartPerformanceCounterDisabled;
        private static _EndPerformanceCounterDisabled;
        private static _StartUserMark;
        private static _EndUserMark;
        private static _StartPerformanceConsole;
        private static _EndPerformanceConsole;
        /**
         * Starts a performance counter
         */
        static StartPerformanceCounter: (counterName: string, condition?: boolean) => void;
        /**
         * Ends a specific performance coutner
         */
        static EndPerformanceCounter: (counterName: string, condition?: boolean) => void;
        /**
         * Gets either window.performance.now() if supported or Date.now() else
         */
        static get Now(): number;
        /**
         * This method will return the name of the class used to create the instance of the given object.
         * It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator.
         * @param object the object to get the class name from
         * @param isType defines if the object is actually a type
         * @returns the name of the class, will be "object" for a custom data type not using the @className decorator
         */
        static GetClassName(object: any, isType?: boolean): string;
        /**
         * Gets the first element of an array satisfying a given predicate
         * @param array defines the array to browse
         * @param predicate defines the predicate to use
         * @returns null if not found or the element
         */
        static First<T>(array: Array<T>, predicate: (item: T) => boolean): Nullable<T>;
        /**
         * This method will return the name of the full name of the class, including its owning module (if any).
         * It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator or implementing a method getClassName():string (in which case the module won't be specified).
         * @param object the object to get the class name from
         * @param isType defines if the object is actually a type
         * @return a string that can have two forms: "moduleName.className" if module was specified when the class' Name was registered or "className" if there was not module specified.
         * @ignorenaming
         */
        static getFullClassName(object: any, isType?: boolean): Nullable<string>;
        /**
         * Returns a promise that resolves after the given amount of time.
         * @param delay Number of milliseconds to delay
         * @returns Promise that resolves after the given amount of time
         */
        static DelayAsync(delay: number): Promise<void>;
        /**
         * Utility function to detect if the current user agent is Safari
         * @returns whether or not the current user agent is safari
         */
        static IsSafari(): boolean;
    }
    /**
     * Use this className as a decorator on a given class definition to add it a name and optionally its module.
     * You can then use the Tools.getClassName(obj) on an instance to retrieve its class name.
     * This method is the only way to get it done in all cases, even if the .js file declaring the class is minified
     * @param name The name of the class, case should be preserved
     * @param module The name of the Module hosting the class, optional, but strongly recommended to specify if possible. Case should be preserved.
     */
    export function className(name: string, module?: string): (target: Object) => void;
    /**
     * An implementation of a loop for asynchronous functions.
     */
    export class AsyncLoop {
        /**
         * Defines the number of iterations for the loop
         */
        iterations: number;
        /**
         * Defines the current index of the loop.
         */
        index: number;
        private _done;
        private _fn;
        private _successCallback;
        /**
         * Constructor.
         * @param iterations the number of iterations.
         * @param func the function to run each iteration
         * @param successCallback the callback that will be called upon succesful execution
         * @param offset starting offset.
         */
        constructor(
        /**
         * Defines the number of iterations for the loop
         */
        iterations: number, func: (asyncLoop: AsyncLoop) => void, successCallback: () => void, offset?: number);
        /**
         * Execute the next iteration. Must be called after the last iteration was finished.
         */
        executeNext(): void;
        /**
         * Break the loop and run the success callback.
         */
        breakLoop(): void;
        /**
         * Create and run an async loop.
         * @param iterations the number of iterations.
         * @param fn the function to run each iteration
         * @param successCallback the callback that will be called upon succesful execution
         * @param offset starting offset.
         * @returns the created async loop object
         */
        static Run(iterations: number, fn: (asyncLoop: AsyncLoop) => void, successCallback: () => void, offset?: number): AsyncLoop;
        /**
         * A for-loop that will run a given number of iterations synchronous and the rest async.
         * @param iterations total number of iterations
         * @param syncedIterations number of synchronous iterations in each async iteration.
         * @param fn the function to call each iteration.
         * @param callback a success call back that will be called when iterating stops.
         * @param breakFunction a break condition (optional)
         * @param timeout timeout settings for the setTimeout function. default - 0.
         * @returns the created async loop object
         */
        static SyncAsyncForLoop(iterations: number, syncedIterations: number, fn: (iteration: number) => void, callback: () => void, breakFunction?: () => boolean, timeout?: number): AsyncLoop;
    }
}
declare module BABYLON {
    /**
     * This class implement a typical dictionary using a string as key and the generic type T as value.
     * The underlying implementation relies on an associative array to ensure the best performances.
     * The value can be anything including 'null' but except 'undefined'
     */
    export class StringDictionary<T> {
        /**
         * This will clear this dictionary and copy the content from the 'source' one.
         * If the T value is a custom object, it won't be copied/cloned, the same object will be used
         * @param source the dictionary to take the content from and copy to this dictionary
         */
        copyFrom(source: StringDictionary<T>): void;
        /**
         * Get a value based from its key
         * @param key the given key to get the matching value from
         * @return the value if found, otherwise undefined is returned
         */
        get(key: string): T | undefined;
        /**
         * Get a value from its key or add it if it doesn't exist.
         * This method will ensure you that a given key/data will be present in the dictionary.
         * @param key the given key to get the matching value from
         * @param factory the factory that will create the value if the key is not present in the dictionary.
         * The factory will only be invoked if there's no data for the given key.
         * @return the value corresponding to the key.
         */
        getOrAddWithFactory(key: string, factory: (key: string) => T): T;
        /**
         * Get a value from its key if present in the dictionary otherwise add it
         * @param key the key to get the value from
         * @param val if there's no such key/value pair in the dictionary add it with this value
         * @return the value corresponding to the key
         */
        getOrAdd(key: string, val: T): T;
        /**
         * Check if there's a given key in the dictionary
         * @param key the key to check for
         * @return true if the key is present, false otherwise
         */
        contains(key: string): boolean;
        /**
         * Add a new key and its corresponding value
         * @param key the key to add
         * @param value the value corresponding to the key
         * @return true if the operation completed successfully, false if we couldn't insert the key/value because there was already this key in the dictionary
         */
        add(key: string, value: T): boolean;
        /**
         * Update a specific value associated to a key
         * @param key defines the key to use
         * @param value defines the value to store
         * @returns true if the value was updated (or false if the key was not found)
         */
        set(key: string, value: T): boolean;
        /**
         * Get the element of the given key and remove it from the dictionary
         * @param key defines the key to search
         * @returns the value associated with the key or null if not found
         */
        getAndRemove(key: string): Nullable<T>;
        /**
         * Remove a key/value from the dictionary.
         * @param key the key to remove
         * @return true if the item was successfully deleted, false if no item with such key exist in the dictionary
         */
        remove(key: string): boolean;
        /**
         * Clear the whole content of the dictionary
         */
        clear(): void;
        /**
         * Gets the current count
         */
        get count(): number;
        /**
         * Execute a callback on each key/val of the dictionary.
         * Note that you can remove any element in this dictionary in the callback implementation
         * @param callback the callback to execute on a given key/value pair
         */
        forEach(callback: (key: string, val: T) => void): void;
        /**
         * Execute a callback on every occurrence of the dictionary until it returns a valid TRes object.
         * If the callback returns null or undefined the method will iterate to the next key/value pair
         * Note that you can remove any element in this dictionary in the callback implementation
         * @param callback the callback to execute, if it return a valid T instanced object the enumeration will stop and the object will be returned
         * @returns the first item
         */
        first<TRes>(callback: (key: string, val: T) => TRes): TRes | null;
        private _count;
        private _data;
    }
}
declare module BABYLON {
    /** @hidden */
    export interface ICollisionCoordinator {
        createCollider(): Collider;
        getNewPosition(position: Vector3, displacement: Vector3, collider: Collider, maximumRetry: number, excludedMesh: Nullable<AbstractMesh>, onNewPosition: (collisionIndex: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh>) => void, collisionIndex: number): void;
        init(scene: Scene): void;
    }
    /** @hidden */
    export class DefaultCollisionCoordinator implements ICollisionCoordinator {
        private _scene;
        private _scaledPosition;
        private _scaledVelocity;
        private _finalPosition;
        getNewPosition(position: Vector3, displacement: Vector3, collider: Collider, maximumRetry: number, excludedMesh: AbstractMesh, onNewPosition: (collisionIndex: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh>) => void, collisionIndex: number): void;
        createCollider(): Collider;
        init(scene: Scene): void;
        private _collideWithWorld;
    }
}
declare module BABYLON {
    /**
     * Class used to manage all inputs for the scene.
     */
    export class InputManager {
        /** The distance in pixel that you have to move to prevent some events */
        static DragMovementThreshold: number;
        /** Time in milliseconds to wait to raise long press events if button is still pressed */
        static LongPressDelay: number;
        /** Time in milliseconds with two consecutive clicks will be considered as a double click */
        static DoubleClickDelay: number;
        /** If you need to check double click without raising a single click at first click, enable this flag */
        static ExclusiveDoubleClickMode: boolean;
        /** This is a defensive check to not allow control attachment prior to an already active one. If already attached, previous control is unattached before attaching the new one. */
        private _alreadyAttached;
        private _wheelEventName;
        private _onPointerMove;
        private _onPointerDown;
        private _onPointerUp;
        private _initClickEvent;
        private _initActionManager;
        private _delayedSimpleClick;
        private _delayedSimpleClickTimeout;
        private _previousDelayedSimpleClickTimeout;
        private _meshPickProceed;
        private _previousButtonPressed;
        private _currentPickResult;
        private _previousPickResult;
        private _totalPointersPressed;
        private _doubleClickOccured;
        private _pointerOverMesh;
        private _pickedDownMesh;
        private _pickedUpMesh;
        private _pointerX;
        private _pointerY;
        private _unTranslatedPointerX;
        private _unTranslatedPointerY;
        private _startingPointerPosition;
        private _previousStartingPointerPosition;
        private _startingPointerTime;
        private _previousStartingPointerTime;
        private _pointerCaptures;
        private _meshUnderPointerId;
        private _onKeyDown;
        private _onKeyUp;
        private _onCanvasFocusObserver;
        private _onCanvasBlurObserver;
        private _scene;
        /**
         * Creates a new InputManager
         * @param scene defines the hosting scene
         */
        constructor(scene: Scene);
        /**
         * Gets the mesh that is currently under the pointer
         */
        get meshUnderPointer(): Nullable<AbstractMesh>;
        /**
         * When using more than one pointer (for example in XR) you can get the mesh under the specific pointer
         * @param pointerId the pointer id to use
         * @returns The mesh under this pointer id or null if not found
         */
        getMeshUnderPointerByPointerId(pointerId: number): Nullable<AbstractMesh>;
        /**
         * Gets the pointer coordinates in 2D without any translation (ie. straight out of the pointer event)
         */
        get unTranslatedPointer(): Vector2;
        /**
         * Gets or sets the current on-screen X position of the pointer
         */
        get pointerX(): number;
        set pointerX(value: number);
        /**
         * Gets or sets the current on-screen Y position of the pointer
         */
        get pointerY(): number;
        set pointerY(value: number);
        private _updatePointerPosition;
        private _processPointerMove;
        private _setRayOnPointerInfo;
        private _checkPrePointerObservable;
        /**
         * Use this method to simulate a pointer move on a mesh
         * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
         * @param pickResult pickingInfo of the object wished to simulate pointer event on
         * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
         */
        simulatePointerMove(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): void;
        /**
         * Use this method to simulate a pointer down on a mesh
         * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
         * @param pickResult pickingInfo of the object wished to simulate pointer event on
         * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
         */
        simulatePointerDown(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): void;
        private _processPointerDown;
        /** @hidden */
        _isPointerSwiping(): boolean;
        /**
         * Use this method to simulate a pointer up on a mesh
         * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
         * @param pickResult pickingInfo of the object wished to simulate pointer event on
         * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
         * @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)
         */
        simulatePointerUp(pickResult: PickingInfo, pointerEventInit?: PointerEventInit, doubleTap?: boolean): void;
        private _processPointerUp;
        /**
         * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)
         * @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)
         * @returns true if the pointer was captured
         */
        isPointerCaptured(pointerId?: number): boolean;
        /**
         * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp
         * @param attachUp defines if you want to attach events to pointerup
         * @param attachDown defines if you want to attach events to pointerdown
         * @param attachMove defines if you want to attach events to pointermove
         * @param elementToAttachTo defines the target DOM element to attach to (will use the canvas by default)
         */
        attachControl(attachUp?: boolean, attachDown?: boolean, attachMove?: boolean, elementToAttachTo?: Nullable<HTMLElement>): void;
        /**
         * Detaches all event handlers
         */
        detachControl(): void;
        /**
         * Force the value of meshUnderPointer
         * @param mesh defines the mesh to use
         * @param pointerId optional pointer id when using more than one pointer. Defaults to 0
         */
        setPointerOverMesh(mesh: Nullable<AbstractMesh>, pointerId?: number): void;
        /**
         * Gets the mesh under the pointer
         * @returns a Mesh or null if no mesh is under the pointer
         */
        getPointerOverMesh(): Nullable<AbstractMesh>;
    }
}
declare module BABYLON {
    /**
     * This class defines the direct association between an animation and a target
     */
    export class TargetedAnimation {
        /**
         * Animation to perform
         */
        animation: Animation;
        /**
         * Target to animate
         */
        target: any;
        /**
         * Returns the string "TargetedAnimation"
         * @returns "TargetedAnimation"
         */
        getClassName(): string;
        /**
         * Serialize the object
         * @returns the JSON object representing the current entity
         */
        serialize(): any;
    }
    /**
     * Use this class to create coordinated animations on multiple targets
     */
    export class AnimationGroup implements IDisposable {
        /** The name of the animation group */
        name: string;
        private _scene;
        private _targetedAnimations;
        private _animatables;
        private _from;
        private _to;
        private _isStarted;
        private _isPaused;
        private _speedRatio;
        private _loopAnimation;
        private _isAdditive;
        /**
         * Gets or sets the unique id of the node
         */
        uniqueId: number;
        /**
         * This observable will notify when one animation have ended
         */
        onAnimationEndObservable: Observable<TargetedAnimation>;
        /**
         * Observer raised when one animation loops
         */
        onAnimationLoopObservable: Observable<TargetedAnimation>;
        /**
         * Observer raised when all animations have looped
         */
        onAnimationGroupLoopObservable: Observable<AnimationGroup>;
        /**
         * This observable will notify when all animations have ended.
         */
        onAnimationGroupEndObservable: Observable<AnimationGroup>;
        /**
         * This observable will notify when all animations have paused.
         */
        onAnimationGroupPauseObservable: Observable<AnimationGroup>;
        /**
         * This observable will notify when all animations are playing.
         */
        onAnimationGroupPlayObservable: Observable<AnimationGroup>;
        /**
         * Gets the first frame
         */
        get from(): number;
        /**
         * Gets the last frame
         */
        get to(): number;
        /**
         * Define if the animations are started
         */
        get isStarted(): boolean;
        /**
         * Gets a value indicating that the current group is playing
         */
        get isPlaying(): boolean;
        /**
         * Gets or sets the speed ratio to use for all animations
         */
        get speedRatio(): number;
        /**
         * Gets or sets the speed ratio to use for all animations
         */
        set speedRatio(value: number);
        /**
         * Gets or sets if all animations should loop or not
         */
        get loopAnimation(): boolean;
        set loopAnimation(value: boolean);
        /**
         * Gets or sets if all animations should be evaluated additively
         */
        get isAdditive(): boolean;
        set isAdditive(value: boolean);
        /**
         * Gets the targeted animations for this animation group
         */
        get targetedAnimations(): Array<TargetedAnimation>;
        /**
         * returning the list of animatables controlled by this animation group.
         */
        get animatables(): Array<Animatable>;
        /**
         * Gets the list of target animations
         */
        get children(): TargetedAnimation[];
        /**
         * Instantiates a new Animation Group.
         * This helps managing several animations at once.
         * @see https://doc.babylonjs.com/how_to/group
         * @param name Defines the name of the group
         * @param scene Defines the scene the group belongs to
         */
        constructor(
        /** The name of the animation group */
        name: string, scene?: Nullable<Scene>);
        /**
         * Add an animation (with its target) in the group
         * @param animation defines the animation we want to add
         * @param target defines the target of the animation
         * @returns the TargetedAnimation object
         */
        addTargetedAnimation(animation: Animation, target: any): TargetedAnimation;
        /**
         * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame
         * It can add constant keys at begin or end
         * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)
         * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)
         * @returns the animation group
         */
        normalize(beginFrame?: Nullable<number>, endFrame?: Nullable<number>): AnimationGroup;
        private _animationLoopCount;
        private _animationLoopFlags;
        private _processLoop;
        /**
         * Start all animations on given targets
         * @param loop defines if animations must loop
         * @param speedRatio defines the ratio to apply to animation speed (1 by default)
         * @param from defines the from key (optional)
         * @param to defines the to key (optional)
         * @param isAdditive defines the additive state for the resulting animatables (optional)
         * @returns the current animation group
         */
        start(loop?: boolean, speedRatio?: number, from?: number, to?: number, isAdditive?: boolean): AnimationGroup;
        /**
         * Pause all animations
         * @returns the animation group
         */
        pause(): AnimationGroup;
        /**
         * Play all animations to initial state
         * This function will start() the animations if they were not started or will restart() them if they were paused
         * @param loop defines if animations must loop
         * @returns the animation group
         */
        play(loop?: boolean): AnimationGroup;
        /**
         * Reset all animations to initial state
         * @returns the animation group
         */
        reset(): AnimationGroup;
        /**
         * Restart animations from key 0
         * @returns the animation group
         */
        restart(): AnimationGroup;
        /**
         * Stop all animations
         * @returns the animation group
         */
        stop(): AnimationGroup;
        /**
         * Set animation weight for all animatables
         * @param weight defines the weight to use
         * @return the animationGroup
         * @see https://doc.babylonjs.com/babylon101/animations#animation-weights
         */
        setWeightForAllAnimatables(weight: number): AnimationGroup;
        /**
         * Synchronize and normalize all animatables with a source animatable
         * @param root defines the root animatable to synchronize with
         * @return the animationGroup
         * @see https://doc.babylonjs.com/babylon101/animations#animation-weights
         */
        syncAllAnimationsWith(root: Animatable): AnimationGroup;
        /**
         * Goes to a specific frame in this animation group
         * @param frame the frame number to go to
         * @return the animationGroup
         */
        goToFrame(frame: number): AnimationGroup;
        /**
         * Dispose all associated resources
         */
        dispose(): void;
        private _checkAnimationGroupEnded;
        /**
         * Clone the current animation group and returns a copy
         * @param newName defines the name of the new group
         * @param targetConverter defines an optional function used to convert current animation targets to new ones
         * @returns the new aniamtion group
         */
        clone(newName: string, targetConverter?: (oldTarget: any) => any): AnimationGroup;
        /**
         * Serializes the animationGroup to an object
         * @returns Serialized object
         */
        serialize(): any;
        /**
         * Returns a new AnimationGroup object parsed from the source provided.
         * @param parsedAnimationGroup defines the source
         * @param scene defines the scene that will receive the animationGroup
         * @returns a new AnimationGroup
         */
        static Parse(parsedAnimationGroup: any, scene: Scene): AnimationGroup;
        /**
         * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.
         * @param sourceAnimationGroup defines the AnimationGroup containing animations to convert
         * @param referenceFrame defines the frame that keyframes in the range will be relative to
         * @param range defines the name of the AnimationRange belonging to the animations in the group to convert
         * @param cloneOriginal defines whether or not to clone the group and convert the clone or convert the original group (default is false)
         * @param clonedName defines the name of the resulting cloned AnimationGroup if cloneOriginal is true
         * @returns a new AnimationGroup if cloneOriginal is true or the original AnimationGroup if cloneOriginal is false
         */
        static MakeAnimationAdditive(sourceAnimationGroup: AnimationGroup, referenceFrame?: number, range?: string, cloneOriginal?: boolean, clonedName?: string): AnimationGroup;
        /**
         * Returns the string "AnimationGroup"
         * @returns "AnimationGroup"
         */
        getClassName(): string;
        /**
         * Creates a detailled string about the object
         * @param fullDetails defines if the output string will support multiple levels of logging within scene loading
         * @returns a string representing the object
         */
        toString(fullDetails?: boolean): string;
    }
}
declare module BABYLON {
    /**
     * Define an interface for all classes that will hold resources
     */
    export interface IDisposable {
        /**
         * Releases all held resources
         */
        dispose(): void;
    }
    /** Interface defining initialization parameters for Scene class */
    export interface SceneOptions {
        /**
         * Defines that scene should keep up-to-date a map of geometry to enable fast look-up by uniqueId
         * It will improve performance when the number of geometries becomes important.
         */
        useGeometryUniqueIdsMap?: boolean;
        /**
         * Defines that each material of the scene should keep up-to-date a map of referencing meshes for fast diposing
         * It will improve performance when the number of mesh becomes important, but might consume a bit more memory
         */
        useMaterialMeshMap?: boolean;
        /**
         * Defines that each mesh of the scene should keep up-to-date a map of referencing cloned meshes for fast diposing
         * It will improve performance when the number of mesh becomes important, but might consume a bit more memory
         */
        useClonedMeshMap?: boolean;
        /** Defines if the creation of the scene should impact the engine (Eg. UtilityLayer's scene) */
        virtual?: boolean;
    }
    /**
     * Represents a scene to be rendered by the engine.
     * @see https://doc.babylonjs.com/features/scene
     */
    export class Scene extends AbstractScene implements IAnimatable, IClipPlanesHolder {
        /** The fog is deactivated */
        static readonly FOGMODE_NONE: number;
        /** The fog density is following an exponential function */
        static readonly FOGMODE_EXP: number;
        /** The fog density is following an exponential function faster than FOGMODE_EXP */
        static readonly FOGMODE_EXP2: number;
        /** The fog density is following a linear function. */
        static readonly FOGMODE_LINEAR: number;
        /**
         * Gets or sets the minimum deltatime when deterministic lock step is enabled
         * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         */
        static MinDeltaTime: number;
        /**
         * Gets or sets the maximum deltatime when deterministic lock step is enabled
         * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         */
        static MaxDeltaTime: number;
        /**
         * Factory used to create the default material.
         * @param name The name of the material to create
         * @param scene The scene to create the material for
         * @returns The default material
         */
        static DefaultMaterialFactory(scene: Scene): Material;
        /**
         * Factory used to create the a collision coordinator.
         * @returns The collision coordinator
         */
        static CollisionCoordinatorFactory(): ICollisionCoordinator;
        /** @hidden */
        _inputManager: InputManager;
        /** Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position */
        cameraToUseForPointers: Nullable<Camera>;
        /** @hidden */
        readonly _isScene: boolean;
        /** @hidden */
        _blockEntityCollection: boolean;
        /**
         * Gets or sets a boolean that indicates if the scene must clear the render buffer before rendering a frame
         */
        autoClear: boolean;
        /**
         * Gets or sets a boolean that indicates if the scene must clear the depth and stencil buffers before rendering a frame
         */
        autoClearDepthAndStencil: boolean;
        /**
         * Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))
         */
        clearColor: Color4;
        /**
         * Defines the color used to simulate the ambient color (Default is (0, 0, 0))
         */
        ambientColor: Color3;
        /**
         * This is use to store the default BRDF lookup for PBR materials in your scene.
         * It should only be one of the following (if not the default embedded one):
         * * For uncorrelated BRDF (pbr.brdf.useEnergyConservation = false and pbr.brdf.useSmithVisibilityHeightCorrelated = false) : https://assets.babylonjs.com/environments/uncorrelatedBRDF.dds
         * * For correlated BRDF (pbr.brdf.useEnergyConservation = false and pbr.brdf.useSmithVisibilityHeightCorrelated = true) : https://assets.babylonjs.com/environments/correlatedBRDF.dds
         * * For correlated multi scattering BRDF (pbr.brdf.useEnergyConservation = true and pbr.brdf.useSmithVisibilityHeightCorrelated = true) : https://assets.babylonjs.com/environments/correlatedMSBRDF.dds
         * The material properties need to be setup according to the type of texture in use.
         */
        environmentBRDFTexture: BaseTexture;
        /**
         * Texture used in all pbr material as the reflection texture.
         * As in the majority of the scene they are the same (exception for multi room and so on),
         * this is easier to reference from here than from all the materials.
         */
        get environmentTexture(): Nullable<BaseTexture>;
        /**
         * Texture used in all pbr material as the reflection texture.
         * As in the majority of the scene they are the same (exception for multi room and so on),
         * this is easier to set here than in all the materials.
         */
        set environmentTexture(value: Nullable<BaseTexture>);
        /** @hidden */
        protected _environmentIntensity: number;
        /**
         * Intensity of the environment in all pbr material.
         * This dims or reinforces the IBL lighting overall (reflection and diffuse).
         * As in the majority of the scene they are the same (exception for multi room and so on),
         * this is easier to reference from here than from all the materials.
         */
        get environmentIntensity(): number;
        /**
         * Intensity of the environment in all pbr material.
         * This dims or reinforces the IBL lighting overall (reflection and diffuse).
         * As in the majority of the scene they are the same (exception for multi room and so on),
         * this is easier to set here than in all the materials.
         */
        set environmentIntensity(value: number);
        /** @hidden */
        protected _imageProcessingConfiguration: ImageProcessingConfiguration;
        /**
         * Default image processing configuration used either in the rendering
         * Forward main pass or through the imageProcessingPostProcess if present.
         * As in the majority of the scene they are the same (exception for multi camera),
         * this is easier to reference from here than from all the materials and post process.
         *
         * No setter as we it is a shared configuration, you can set the values instead.
         */
        get imageProcessingConfiguration(): ImageProcessingConfiguration;
        private _forceWireframe;
        /**
         * Gets or sets a boolean indicating if all rendering must be done in wireframe
         */
        set forceWireframe(value: boolean);
        get forceWireframe(): boolean;
        private _skipFrustumClipping;
        /**
         * Gets or sets a boolean indicating if we should skip the frustum clipping part of the active meshes selection
         */
        set skipFrustumClipping(value: boolean);
        get skipFrustumClipping(): boolean;
        private _forcePointsCloud;
        /**
         * Gets or sets a boolean indicating if all rendering must be done in point cloud
         */
        set forcePointsCloud(value: boolean);
        get forcePointsCloud(): boolean;
        /**
         * Gets or sets the active clipplane 1
         */
        clipPlane: Nullable<Plane>;
        /**
         * Gets or sets the active clipplane 2
         */
        clipPlane2: Nullable<Plane>;
        /**
         * Gets or sets the active clipplane 3
         */
        clipPlane3: Nullable<Plane>;
        /**
         * Gets or sets the active clipplane 4
         */
        clipPlane4: Nullable<Plane>;
        /**
         * Gets or sets the active clipplane 5
         */
        clipPlane5: Nullable<Plane>;
        /**
         * Gets or sets the active clipplane 6
         */
        clipPlane6: Nullable<Plane>;
        /**
         * Gets or sets a boolean indicating if animations are enabled
         */
        animationsEnabled: boolean;
        private _animationPropertiesOverride;
        /**
         * Gets or sets the animation properties override
         */
        get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride>;
        set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>);
        /**
         * Gets or sets a boolean indicating if a constant deltatime has to be used
         * This is mostly useful for testing purposes when you do not want the animations to scale with the framerate
         */
        useConstantAnimationDeltaTime: boolean;
        /**
         * Gets or sets a boolean indicating if the scene must keep the meshUnderPointer property updated
         * Please note that it requires to run a ray cast through the scene on every frame
         */
        constantlyUpdateMeshUnderPointer: boolean;
        /**
         * Defines the HTML cursor to use when hovering over interactive elements
         */
        hoverCursor: string;
        /**
         * Defines the HTML default cursor to use (empty by default)
         */
        defaultCursor: string;
        /**
         * Defines whether cursors are handled by the scene.
         */
        doNotHandleCursors: boolean;
        /**
         * This is used to call preventDefault() on pointer down
         * in order to block unwanted artifacts like system double clicks
         */
        preventDefaultOnPointerDown: boolean;
        /**
         * This is used to call preventDefault() on pointer up
         * in order to block unwanted artifacts like system double clicks
         */
        preventDefaultOnPointerUp: boolean;
        /**
         * Gets or sets user defined metadata
         */
        metadata: any;
        /**
         * For internal use only. Please do not use.
         */
        reservedDataStore: any;
        /**
         * Gets the name of the plugin used to load this scene (null by default)
         */
        loadingPluginName: string;
        /**
         * Use this array to add regular expressions used to disable offline support for specific urls
         */
        disableOfflineSupportExceptionRules: RegExp[];
        /**
        * An event triggered when the scene is disposed.
        */
        onDisposeObservable: Observable<Scene>;
        private _onDisposeObserver;
        /** Sets a function to be executed when this scene is disposed. */
        set onDispose(callback: () => void);
        /**
        * An event triggered before rendering the scene (right after animations and physics)
        */
        onBeforeRenderObservable: Observable<Scene>;
        private _onBeforeRenderObserver;
        /** Sets a function to be executed before rendering this scene */
        set beforeRender(callback: Nullable<() => void>);
        /**
        * An event triggered after rendering the scene
        */
        onAfterRenderObservable: Observable<Scene>;
        /**
        * An event triggered after rendering the scene for an active camera (When scene.render is called this will be called after each camera)
        */
        onAfterRenderCameraObservable: Observable<Camera>;
        private _onAfterRenderObserver;
        /** Sets a function to be executed after rendering this scene */
        set afterRender(callback: Nullable<() => void>);
        /**
        * An event triggered before animating the scene
        */
        onBeforeAnimationsObservable: Observable<Scene>;
        /**
        * An event triggered after animations processing
        */
        onAfterAnimationsObservable: Observable<Scene>;
        /**
        * An event triggered before draw calls are ready to be sent
        */
        onBeforeDrawPhaseObservable: Observable<Scene>;
        /**
        * An event triggered after draw calls have been sent
        */
        onAfterDrawPhaseObservable: Observable<Scene>;
        /**
        * An event triggered when the scene is ready
        */
        onReadyObservable: Observable<Scene>;
        /**
        * An event triggered before rendering a camera
        */
        onBeforeCameraRenderObservable: Observable<Camera>;
        private _onBeforeCameraRenderObserver;
        /** Sets a function to be executed before rendering a camera*/
        set beforeCameraRender(callback: () => void);
        /**
        * An event triggered after rendering a camera
        */
        onAfterCameraRenderObservable: Observable<Camera>;
        private _onAfterCameraRenderObserver;
        /** Sets a function to be executed after rendering a camera*/
        set afterCameraRender(callback: () => void);
        /**
        * An event triggered when active meshes evaluation is about to start
        */
        onBeforeActiveMeshesEvaluationObservable: Observable<Scene>;
        /**
        * An event triggered when active meshes evaluation is done
        */
        onAfterActiveMeshesEvaluationObservable: Observable<Scene>;
        /**
        * An event triggered when particles rendering is about to start
        * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)
        */
        onBeforeParticlesRenderingObservable: Observable<Scene>;
        /**
        * An event triggered when particles rendering is done
        * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)
        */
        onAfterParticlesRenderingObservable: Observable<Scene>;
        /**
        * An event triggered when SceneLoader.Append or SceneLoader.Load or SceneLoader.ImportMesh were successfully executed
        */
        onDataLoadedObservable: Observable<Scene>;
        /**
        * An event triggered when a camera is created
        */
        onNewCameraAddedObservable: Observable<Camera>;
        /**
        * An event triggered when a camera is removed
        */
        onCameraRemovedObservable: Observable<Camera>;
        /**
        * An event triggered when a light is created
        */
        onNewLightAddedObservable: Observable<Light>;
        /**
        * An event triggered when a light is removed
        */
        onLightRemovedObservable: Observable<Light>;
        /**
        * An event triggered when a geometry is created
        */
        onNewGeometryAddedObservable: Observable<Geometry>;
        /**
        * An event triggered when a geometry is removed
        */
        onGeometryRemovedObservable: Observable<Geometry>;
        /**
        * An event triggered when a transform node is created
        */
        onNewTransformNodeAddedObservable: Observable<TransformNode>;
        /**
        * An event triggered when a transform node is removed
        */
        onTransformNodeRemovedObservable: Observable<TransformNode>;
        /**
        * An event triggered when a mesh is created
        */
        onNewMeshAddedObservable: Observable<AbstractMesh>;
        /**
        * An event triggered when a mesh is removed
        */
        onMeshRemovedObservable: Observable<AbstractMesh>;
        /**
         * An event triggered when a skeleton is created
         */
        onNewSkeletonAddedObservable: Observable<Skeleton>;
        /**
        * An event triggered when a skeleton is removed
        */
        onSkeletonRemovedObservable: Observable<Skeleton>;
        /**
        * An event triggered when a material is created
        */
        onNewMaterialAddedObservable: Observable<Material>;
        /**
        * An event triggered when a material is removed
        */
        onMaterialRemovedObservable: Observable<Material>;
        /**
        * An event triggered when a texture is created
        */
        onNewTextureAddedObservable: Observable<BaseTexture>;
        /**
        * An event triggered when a texture is removed
        */
        onTextureRemovedObservable: Observable<BaseTexture>;
        /**
        * An event triggered when render targets are about to be rendered
        * Can happen multiple times per frame.
        */
        onBeforeRenderTargetsRenderObservable: Observable<Scene>;
        /**
        * An event triggered when render targets were rendered.
        * Can happen multiple times per frame.
        */
        onAfterRenderTargetsRenderObservable: Observable<Scene>;
        /**
        * An event triggered before calculating deterministic simulation step
        */
        onBeforeStepObservable: Observable<Scene>;
        /**
        * An event triggered after calculating deterministic simulation step
        */
        onAfterStepObservable: Observable<Scene>;
        /**
         * An event triggered when the activeCamera property is updated
         */
        onActiveCameraChanged: Observable<Scene>;
        /**
         * This Observable will be triggered before rendering each renderingGroup of each rendered camera.
         * The RenderinGroupInfo class contains all the information about the context in which the observable is called
         * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)
         */
        onBeforeRenderingGroupObservable: Observable<RenderingGroupInfo>;
        /**
         * This Observable will be triggered after rendering each renderingGroup of each rendered camera.
         * The RenderinGroupInfo class contains all the information about the context in which the observable is called
         * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)
         */
        onAfterRenderingGroupObservable: Observable<RenderingGroupInfo>;
        /**
         * This Observable will when a mesh has been imported into the scene.
         */
        onMeshImportedObservable: Observable<AbstractMesh>;
        /**
         * This Observable will when an animation file has been imported into the scene.
         */
        onAnimationFileImportedObservable: Observable<Scene>;
        /**
         * Gets or sets a user defined funtion to select LOD from a mesh and a camera.
         * By default this function is undefined and Babylon.js will select LOD based on distance to camera
         */
        customLODSelector: (mesh: AbstractMesh, camera: Camera) => Nullable<AbstractMesh>;
        /** @hidden */
        _registeredForLateAnimationBindings: SmartArrayNoDuplicate<any>;
        /**
         * Gets or sets a predicate used to select candidate meshes for a pointer down event
         */
        pointerDownPredicate: (Mesh: AbstractMesh) => boolean;
        /**
         * Gets or sets a predicate used to select candidate meshes for a pointer up event
         */
        pointerUpPredicate: (Mesh: AbstractMesh) => boolean;
        /**
         * Gets or sets a predicate used to select candidate meshes for a pointer move event
         */
        pointerMovePredicate: (Mesh: AbstractMesh) => boolean;
        /** Callback called when a pointer move is detected */
        onPointerMove: (evt: PointerEvent, pickInfo: PickingInfo, type: PointerEventTypes) => void;
        /** Callback called when a pointer down is detected  */
        onPointerDown: (evt: PointerEvent, pickInfo: PickingInfo, type: PointerEventTypes) => void;
        /** Callback called when a pointer up is detected  */
        onPointerUp: (evt: PointerEvent, pickInfo: Nullable<PickingInfo>, type: PointerEventTypes) => void;
        /** Callback called when a pointer pick is detected */
        onPointerPick: (evt: PointerEvent, pickInfo: PickingInfo) => void;
        /**
         * This observable event is triggered when any ponter event is triggered. It is registered during Scene.attachControl() and it is called BEFORE the 3D engine process anything (mesh/sprite picking for instance).
         * You have the possibility to skip the process and the call to onPointerObservable by setting PointerInfoPre.skipOnPointerObservable to true
         */
        onPrePointerObservable: Observable<PointerInfoPre>;
        /**
         * Observable event triggered each time an input event is received from the rendering canvas
         */
        onPointerObservable: Observable<PointerInfo>;
        /**
         * Gets the pointer coordinates without any translation (ie. straight out of the pointer event)
         */
        get unTranslatedPointer(): Vector2;
        /**
         * Gets or sets the distance in pixel that you have to move to prevent some events. Default is 10 pixels
         */
        static get DragMovementThreshold(): number;
        static set DragMovementThreshold(value: number);
        /**
         * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 500 ms
         */
        static get LongPressDelay(): number;
        static set LongPressDelay(value: number);
        /**
         * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 300 ms
         */
        static get DoubleClickDelay(): number;
        static set DoubleClickDelay(value: number);
        /** If you need to check double click without raising a single click at first click, enable this flag */
        static get ExclusiveDoubleClickMode(): boolean;
        static set ExclusiveDoubleClickMode(value: boolean);
        /** @hidden */
        _mirroredCameraPosition: Nullable<Vector3>;
        /**
         * This observable event is triggered when any keyboard event si raised and registered during Scene.attachControl()
         * You have the possibility to skip the process and the call to onKeyboardObservable by setting KeyboardInfoPre.skipOnPointerObservable to true
         */
        onPreKeyboardObservable: Observable<KeyboardInfoPre>;
        /**
         * Observable event triggered each time an keyboard event is received from the hosting window
         */
        onKeyboardObservable: Observable<KeyboardInfo>;
        private _useRightHandedSystem;
        /**
        * Gets or sets a boolean indicating if the scene must use right-handed coordinates system
        */
        set useRightHandedSystem(value: boolean);
        get useRightHandedSystem(): boolean;
        private _timeAccumulator;
        private _currentStepId;
        private _currentInternalStep;
        /**
         * Sets the step Id used by deterministic lock step
         * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         * @param newStepId defines the step Id
         */
        setStepId(newStepId: number): void;
        /**
         * Gets the step Id used by deterministic lock step
         * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         * @returns the step Id
         */
        getStepId(): number;
        /**
         * Gets the internal step used by deterministic lock step
         * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         * @returns the internal step
         */
        getInternalStep(): number;
        private _fogEnabled;
        /**
        * Gets or sets a boolean indicating if fog is enabled on this scene
        * @see https://doc.babylonjs.com/babylon101/environment#fog
        * (Default is true)
        */
        set fogEnabled(value: boolean);
        get fogEnabled(): boolean;
        private _fogMode;
        /**
        * Gets or sets the fog mode to use
        * @see https://doc.babylonjs.com/babylon101/environment#fog
        * | mode | value |
        * | --- | --- |
        * | FOGMODE_NONE | 0 |
        * | FOGMODE_EXP | 1 |
        * | FOGMODE_EXP2 | 2 |
        * | FOGMODE_LINEAR | 3 |
        */
        set fogMode(value: number);
        get fogMode(): number;
        /**
        * Gets or sets the fog color to use
        * @see https://doc.babylonjs.com/babylon101/environment#fog
        * (Default is Color3(0.2, 0.2, 0.3))
        */
        fogColor: Color3;
        /**
        * Gets or sets the fog density to use
        * @see https://doc.babylonjs.com/babylon101/environment#fog
        * (Default is 0.1)
        */
        fogDensity: number;
        /**
        * Gets or sets the fog start distance to use
        * @see https://doc.babylonjs.com/babylon101/environment#fog
        * (Default is 0)
        */
        fogStart: number;
        /**
        * Gets or sets the fog end distance to use
        * @see https://doc.babylonjs.com/babylon101/environment#fog
        * (Default is 1000)
        */
        fogEnd: number;
        /**
        * Flag indicating that the frame buffer binding is handled by another component
        */
        prePass: boolean;
        private _shadowsEnabled;
        /**
        * Gets or sets a boolean indicating if shadows are enabled on this scene
        */
        set shadowsEnabled(value: boolean);
        get shadowsEnabled(): boolean;
        private _lightsEnabled;
        /**
        * Gets or sets a boolean indicating if lights are enabled on this scene
        */
        set lightsEnabled(value: boolean);
        get lightsEnabled(): boolean;
        /** All of the active cameras added to this scene. */
        activeCameras: Camera[];
        /** @hidden */
        _activeCamera: Nullable<Camera>;
        /** Gets or sets the current active camera */
        get activeCamera(): Nullable<Camera>;
        set activeCamera(value: Nullable<Camera>);
        private _defaultMaterial;
        /** The default material used on meshes when no material is affected */
        get defaultMaterial(): Material;
        /** The default material used on meshes when no material is affected */
        set defaultMaterial(value: Material);
        private _texturesEnabled;
        /**
        * Gets or sets a boolean indicating if textures are enabled on this scene
        */
        set texturesEnabled(value: boolean);
        get texturesEnabled(): boolean;
        /**
         * Gets or sets a boolean indicating if physic engines are enabled on this scene
         */
        physicsEnabled: boolean;
        /**
        * Gets or sets a boolean indicating if particles are enabled on this scene
        */
        particlesEnabled: boolean;
        /**
        * Gets or sets a boolean indicating if sprites are enabled on this scene
        */
        spritesEnabled: boolean;
        private _skeletonsEnabled;
        /**
        * Gets or sets a boolean indicating if skeletons are enabled on this scene
        */
        set skeletonsEnabled(value: boolean);
        get skeletonsEnabled(): boolean;
        /**
        * Gets or sets a boolean indicating if lens flares are enabled on this scene
        */
        lensFlaresEnabled: boolean;
        /**
        * Gets or sets a boolean indicating if collisions are enabled on this scene
        * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
        */
        collisionsEnabled: boolean;
        private _collisionCoordinator;
        /** @hidden */
        get collisionCoordinator(): ICollisionCoordinator;
        /**
         * Defines the gravity applied to this scene (used only for collisions)
         * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
         */
        gravity: Vector3;
        /**
        * Gets or sets a boolean indicating if postprocesses are enabled on this scene
        */
        postProcessesEnabled: boolean;
        /**
         * Gets the current postprocess manager
         */
        postProcessManager: PostProcessManager;
        /**
        * Gets or sets a boolean indicating if render targets are enabled on this scene
        */
        renderTargetsEnabled: boolean;
        /**
        * Gets or sets a boolean indicating if next render targets must be dumped as image for debugging purposes
        * We recommend not using it and instead rely on Spector.js: http://spector.babylonjs.com
        */
        dumpNextRenderTargets: boolean;
        /**
         * The list of user defined render targets added to the scene
         */
        customRenderTargets: RenderTargetTexture[];
        /**
         * Defines if texture loading must be delayed
         * If true, textures will only be loaded when they need to be rendered
         */
        useDelayedTextureLoading: boolean;
        /**
         * Gets the list of meshes imported to the scene through SceneLoader
         */
        importedMeshesFiles: String[];
        /**
        * Gets or sets a boolean indicating if probes are enabled on this scene
        */
        probesEnabled: boolean;
        /**
         * Gets or sets the current offline provider to use to store scene data
         * @see https://doc.babylonjs.com/how_to/caching_resources_in_indexeddb
         */
        offlineProvider: IOfflineProvider;
        /**
         * Gets or sets the action manager associated with the scene
         * @see https://doc.babylonjs.com/how_to/how_to_use_actions
        */
        actionManager: AbstractActionManager;
        private _meshesForIntersections;
        /**
        * Gets or sets a boolean indicating if procedural textures are enabled on this scene
        */
        proceduralTexturesEnabled: boolean;
        private _engine;
        private _totalVertices;
        /** @hidden */
        _activeIndices: PerfCounter;
        /** @hidden */
        _activeParticles: PerfCounter;
        /** @hidden */
        _activeBones: PerfCounter;
        private _animationRatio;
        /** @hidden */
        _animationTimeLast: number;
        /** @hidden */
        _animationTime: number;
        /**
         * Gets or sets a general scale for animation speed
         * @see https://www.babylonjs-playground.com/#IBU2W7#3
         */
        animationTimeScale: number;
        /** @hidden */
        _cachedMaterial: Nullable<Material>;
        /** @hidden */
        _cachedEffect: Nullable<Effect>;
        /** @hidden */
        _cachedVisibility: Nullable<number>;
        private _renderId;
        private _frameId;
        private _executeWhenReadyTimeoutId;
        private _intermediateRendering;
        private _viewUpdateFlag;
        private _projectionUpdateFlag;
        /** @hidden */
        _toBeDisposed: Nullable<IDisposable>[];
        private _activeRequests;
        /** @hidden */
        _pendingData: any[];
        private _isDisposed;
        /**
         * Gets or sets a boolean indicating that all submeshes of active meshes must be rendered
         * Use this boolean to avoid computing frustum clipping on submeshes (This could help when you are CPU bound)
         */
        dispatchAllSubMeshesOfActiveMeshes: boolean;
        private _activeMeshes;
        private _processedMaterials;
        private _renderTargets;
        /** @hidden */
        _activeParticleSystems: SmartArray<IParticleSystem>;
        private _activeSkeletons;
        private _softwareSkinnedMeshes;
        private _renderingManager;
        /** @hidden */
        _activeAnimatables: Animatable[];
        private _transformMatrix;
        private _sceneUbo;
        /** @hidden */
        _viewMatrix: Matrix;
        private _projectionMatrix;
        /** @hidden */
        _forcedViewPosition: Nullable<Vector3>;
        /** @hidden */
        _frustumPlanes: Plane[];
        /**
         * Gets the list of frustum planes (built from the active camera)
         */
        get frustumPlanes(): Plane[];
        /**
         * Gets or sets a boolean indicating if lights must be sorted by priority (off by default)
         * This is useful if there are more lights that the maximum simulteanous authorized
         */
        requireLightSorting: boolean;
        /** @hidden */
        readonly useMaterialMeshMap: boolean;
        /** @hidden */
        readonly useClonedMeshMap: boolean;
        private _externalData;
        private _uid;
        /**
         * @hidden
         * Backing store of defined scene components.
         */
        _components: ISceneComponent[];
        /**
         * @hidden
         * Backing store of defined scene components.
         */
        _serializableComponents: ISceneSerializableComponent[];
        /**
         * List of components to register on the next registration step.
         */
        private _transientComponents;
        /**
         * Registers the transient components if needed.
         */
        private _registerTransientComponents;
        /**
         * @hidden
         * Add a component to the scene.
         * Note that the ccomponent could be registered on th next frame if this is called after
         * the register component stage.
         * @param component Defines the component to add to the scene
         */
        _addComponent(component: ISceneComponent): void;
        /**
         * @hidden
         * Gets a component from the scene.
         * @param name defines the name of the component to retrieve
         * @returns the component or null if not present
         */
        _getComponent(name: string): Nullable<ISceneComponent>;
        /**
         * @hidden
         * Defines the actions happening before camera updates.
         */
        _beforeCameraUpdateStage: Stage<SimpleStageAction>;
        /**
         * @hidden
         * Defines the actions happening before clear the canvas.
         */
        _beforeClearStage: Stage<SimpleStageAction>;
        /**
         * @hidden
         * Defines the actions when collecting render targets for the frame.
         */
        _gatherRenderTargetsStage: Stage<RenderTargetsStageAction>;
        /**
         * @hidden
         * Defines the actions happening for one camera in the frame.
         */
        _gatherActiveCameraRenderTargetsStage: Stage<RenderTargetsStageAction>;
        /**
         * @hidden
         * Defines the actions happening during the per mesh ready checks.
         */
        _isReadyForMeshStage: Stage<MeshStageAction>;
        /**
         * @hidden
         * Defines the actions happening before evaluate active mesh checks.
         */
        _beforeEvaluateActiveMeshStage: Stage<SimpleStageAction>;
        /**
         * @hidden
         * Defines the actions happening during the evaluate sub mesh checks.
         */
        _evaluateSubMeshStage: Stage<EvaluateSubMeshStageAction>;
        /**
         * @hidden
         * Defines the actions happening during the active mesh stage.
         */
        _activeMeshStage: Stage<ActiveMeshStageAction>;
        /**
         * @hidden
         * Defines the actions happening during the per camera render target step.
         */
        _cameraDrawRenderTargetStage: Stage<CameraStageFrameBufferAction>;
        /**
         * @hidden
         * Defines the actions happening just before the active camera is drawing.
         */
        _beforeCameraDrawStage: Stage<CameraStageAction>;
        /**
         * @hidden
         * Defines the actions happening just before a render target is drawing.
         */
        _beforeRenderTargetDrawStage: Stage<RenderTargetStageAction>;
        /**
         * @hidden
         * Defines the actions happening just before a rendering group is drawing.
         */
        _beforeRenderingGroupDrawStage: Stage<RenderingGroupStageAction>;
        /**
         * @hidden
         * Defines the actions happening just before a mesh is drawing.
         */
        _beforeRenderingMeshStage: Stage<RenderingMeshStageAction>;
        /**
         * @hidden
         * Defines the actions happening just after a mesh has been drawn.
         */
        _afterRenderingMeshStage: Stage<RenderingMeshStageAction>;
        /**
         * @hidden
         * Defines the actions happening just after a rendering group has been drawn.
         */
        _afterRenderingGroupDrawStage: Stage<RenderingGroupStageAction>;
        /**
         * @hidden
         * Defines the actions happening just after the active camera has been drawn.
         */
        _afterCameraDrawStage: Stage<CameraStageAction>;
        /**
         * @hidden
         * Defines the actions happening just after a render target has been drawn.
         */
        _afterRenderTargetDrawStage: Stage<RenderTargetStageAction>;
        /**
         * @hidden
         * Defines the actions happening just after rendering all cameras and computing intersections.
         */
        _afterRenderStage: Stage<SimpleStageAction>;
        /**
         * @hidden
         * Defines the actions happening when a pointer move event happens.
         */
        _pointerMoveStage: Stage<PointerMoveStageAction>;
        /**
         * @hidden
         * Defines the actions happening when a pointer down event happens.
         */
        _pointerDownStage: Stage<PointerUpDownStageAction>;
        /**
         * @hidden
         * Defines the actions happening when a pointer up event happens.
         */
        _pointerUpStage: Stage<PointerUpDownStageAction>;
        /**
         * an optional map from Geometry Id to Geometry index in the 'geometries' array
         */
        private geometriesByUniqueId;
        /**
         * Creates a new Scene
         * @param engine defines the engine to use to render this scene
         * @param options defines the scene options
         */
        constructor(engine: Engine, options?: SceneOptions);
        /**
         * Gets a string identifying the name of the class
         * @returns "Scene" string
         */
        getClassName(): string;
        private _defaultMeshCandidates;
        /**
         * @hidden
         */
        _getDefaultMeshCandidates(): ISmartArrayLike<AbstractMesh>;
        private _defaultSubMeshCandidates;
        /**
         * @hidden
         */
        _getDefaultSubMeshCandidates(mesh: AbstractMesh): ISmartArrayLike<SubMesh>;
        /**
         * Sets the default candidate providers for the scene.
         * This sets the getActiveMeshCandidates, getActiveSubMeshCandidates, getIntersectingSubMeshCandidates
         * and getCollidingSubMeshCandidates to their default function
         */
        setDefaultCandidateProviders(): void;
        /**
         * Gets the mesh that is currently under the pointer
         */
        get meshUnderPointer(): Nullable<AbstractMesh>;
        /**
         * Gets or sets the current on-screen X position of the pointer
         */
        get pointerX(): number;
        set pointerX(value: number);
        /**
         * Gets or sets the current on-screen Y position of the pointer
         */
        get pointerY(): number;
        set pointerY(value: number);
        /**
         * Gets the cached material (ie. the latest rendered one)
         * @returns the cached material
         */
        getCachedMaterial(): Nullable<Material>;
        /**
         * Gets the cached effect (ie. the latest rendered one)
         * @returns the cached effect
         */
        getCachedEffect(): Nullable<Effect>;
        /**
         * Gets the cached visibility state (ie. the latest rendered one)
         * @returns the cached visibility state
         */
        getCachedVisibility(): Nullable<number>;
        /**
         * Gets a boolean indicating if the current material / effect / visibility must be bind again
         * @param material defines the current material
         * @param effect defines the current effect
         * @param visibility defines the current visibility state
         * @returns true if one parameter is not cached
         */
        isCachedMaterialInvalid(material: Material, effect: Effect, visibility?: number): boolean;
        /**
         * Gets the engine associated with the scene
         * @returns an Engine
         */
        getEngine(): Engine;
        /**
         * Gets the total number of vertices rendered per frame
         * @returns the total number of vertices rendered per frame
         */
        getTotalVertices(): number;
        /**
         * Gets the performance counter for total vertices
         * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation
         */
        get totalVerticesPerfCounter(): PerfCounter;
        /**
         * Gets the total number of active indices rendered per frame (You can deduce the number of rendered triangles by dividing this number by 3)
         * @returns the total number of active indices rendered per frame
         */
        getActiveIndices(): number;
        /**
         * Gets the performance counter for active indices
         * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation
         */
        get totalActiveIndicesPerfCounter(): PerfCounter;
        /**
         * Gets the total number of active particles rendered per frame
         * @returns the total number of active particles rendered per frame
         */
        getActiveParticles(): number;
        /**
         * Gets the performance counter for active particles
         * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation
         */
        get activeParticlesPerfCounter(): PerfCounter;
        /**
         * Gets the total number of active bones rendered per frame
         * @returns the total number of active bones rendered per frame
         */
        getActiveBones(): number;
        /**
         * Gets the performance counter for active bones
         * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation
         */
        get activeBonesPerfCounter(): PerfCounter;
        /**
         * Gets the array of active meshes
         * @returns an array of AbstractMesh
         */
        getActiveMeshes(): SmartArray<AbstractMesh>;
        /**
         * Gets the animation ratio (which is 1.0 is the scene renders at 60fps and 2 if the scene renders at 30fps, etc.)
         * @returns a number
         */
        getAnimationRatio(): number;
        /**
         * Gets an unique Id for the current render phase
         * @returns a number
         */
        getRenderId(): number;
        /**
         * Gets an unique Id for the current frame
         * @returns a number
         */
        getFrameId(): number;
        /** Call this function if you want to manually increment the render Id*/
        incrementRenderId(): void;
        private _createUbo;
        /**
         * Use this method to simulate a pointer move on a mesh
         * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
         * @param pickResult pickingInfo of the object wished to simulate pointer event on
         * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
         * @returns the current scene
         */
        simulatePointerMove(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): Scene;
        /**
         * Use this method to simulate a pointer down on a mesh
         * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
         * @param pickResult pickingInfo of the object wished to simulate pointer event on
         * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
         * @returns the current scene
         */
        simulatePointerDown(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): Scene;
        /**
         * Use this method to simulate a pointer up on a mesh
         * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
         * @param pickResult pickingInfo of the object wished to simulate pointer event on
         * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
         * @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)
         * @returns the current scene
         */
        simulatePointerUp(pickResult: PickingInfo, pointerEventInit?: PointerEventInit, doubleTap?: boolean): Scene;
        /**
         * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)
         * @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)
         * @returns true if the pointer was captured
         */
        isPointerCaptured(pointerId?: number): boolean;
        /**
        * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp
        * @param attachUp defines if you want to attach events to pointerup
        * @param attachDown defines if you want to attach events to pointerdown
        * @param attachMove defines if you want to attach events to pointermove
        */
        attachControl(attachUp?: boolean, attachDown?: boolean, attachMove?: boolean): void;
        /** Detaches all event handlers*/
        detachControl(): void;
        /**
         * This function will check if the scene can be rendered (textures are loaded, shaders are compiled)
         * Delay loaded resources are not taking in account
         * @return true if all required resources are ready
         */
        isReady(): boolean;
        /** Resets all cached information relative to material (including effect and visibility) */
        resetCachedMaterial(): void;
        /**
         * Registers a function to be called before every frame render
         * @param func defines the function to register
         */
        registerBeforeRender(func: () => void): void;
        /**
         * Unregisters a function called before every frame render
         * @param func defines the function to unregister
         */
        unregisterBeforeRender(func: () => void): void;
        /**
         * Registers a function to be called after every frame render
         * @param func defines the function to register
         */
        registerAfterRender(func: () => void): void;
        /**
         * Unregisters a function called after every frame render
         * @param func defines the function to unregister
         */
        unregisterAfterRender(func: () => void): void;
        private _executeOnceBeforeRender;
        /**
         * The provided function will run before render once and will be disposed afterwards.
         * A timeout delay can be provided so that the function will be executed in N ms.
         * The timeout is using the browser's native setTimeout so time percision cannot be guaranteed.
         * @param func The function to be executed.
         * @param timeout optional delay in ms
         */
        executeOnceBeforeRender(func: () => void, timeout?: number): void;
        /** @hidden */
        _addPendingData(data: any): void;
        /** @hidden */
        _removePendingData(data: any): void;
        /**
         * Returns the number of items waiting to be loaded
         * @returns the number of items waiting to be loaded
         */
        getWaitingItemsCount(): number;
        /**
         * Returns a boolean indicating if the scene is still loading data
         */
        get isLoading(): boolean;
        /**
         * Registers a function to be executed when the scene is ready
         * @param {Function} func - the function to be executed
         */
        executeWhenReady(func: () => void): void;
        /**
         * Returns a promise that resolves when the scene is ready
         * @returns A promise that resolves when the scene is ready
         */
        whenReadyAsync(): Promise<void>;
        /** @hidden */
        _checkIsReady(): void;
        /**
         * Gets all animatable attached to the scene
         */
        get animatables(): Animatable[];
        /**
         * Resets the last animation time frame.
         * Useful to override when animations start running when loading a scene for the first time.
         */
        resetLastAnimationTimeFrame(): void;
        /**
         * Gets the current view matrix
         * @returns a Matrix
         */
        getViewMatrix(): Matrix;
        /**
         * Gets the current projection matrix
         * @returns a Matrix
         */
        getProjectionMatrix(): Matrix;
        /**
         * Gets the current transform matrix
         * @returns a Matrix made of View * Projection
         */
        getTransformMatrix(): Matrix;
        /**
         * Sets the current transform matrix
         * @param viewL defines the View matrix to use
         * @param projectionL defines the Projection matrix to use
         * @param viewR defines the right View matrix to use (if provided)
         * @param projectionR defines the right Projection matrix to use (if provided)
         */
        setTransformMatrix(viewL: Matrix, projectionL: Matrix, viewR?: Matrix, projectionR?: Matrix): void;
        /**
         * Gets the uniform buffer used to store scene data
         * @returns a UniformBuffer
         */
        getSceneUniformBuffer(): UniformBuffer;
        /**
         * Gets an unique (relatively to the current scene) Id
         * @returns an unique number for the scene
         */
        getUniqueId(): number;
        /**
         * Add a mesh to the list of scene's meshes
         * @param newMesh defines the mesh to add
         * @param recursive if all child meshes should also be added to the scene
         */
        addMesh(newMesh: AbstractMesh, recursive?: boolean): void;
        /**
         * Remove a mesh for the list of scene's meshes
         * @param toRemove defines the mesh to remove
         * @param recursive if all child meshes should also be removed from the scene
         * @returns the index where the mesh was in the mesh list
         */
        removeMesh(toRemove: AbstractMesh, recursive?: boolean): number;
        /**
         * Add a transform node to the list of scene's transform nodes
         * @param newTransformNode defines the transform node to add
         */
        addTransformNode(newTransformNode: TransformNode): void;
        /**
         * Remove a transform node for the list of scene's transform nodes
         * @param toRemove defines the transform node to remove
         * @returns the index where the transform node was in the transform node list
         */
        removeTransformNode(toRemove: TransformNode): number;
        /**
         * Remove a skeleton for the list of scene's skeletons
         * @param toRemove defines the skeleton to remove
         * @returns the index where the skeleton was in the skeleton list
         */
        removeSkeleton(toRemove: Skeleton): number;
        /**
         * Remove a morph target for the list of scene's morph targets
         * @param toRemove defines the morph target to remove
         * @returns the index where the morph target was in the morph target list
         */
        removeMorphTargetManager(toRemove: MorphTargetManager): number;
        /**
         * Remove a light for the list of scene's lights
         * @param toRemove defines the light to remove
         * @returns the index where the light was in the light list
         */
        removeLight(toRemove: Light): number;
        /**
         * Remove a camera for the list of scene's cameras
         * @param toRemove defines the camera to remove
         * @returns the index where the camera was in the camera list
         */
        removeCamera(toRemove: Camera): number;
        /**
         * Remove a particle system for the list of scene's particle systems
         * @param toRemove defines the particle system to remove
         * @returns the index where the particle system was in the particle system list
         */
        removeParticleSystem(toRemove: IParticleSystem): number;
        /**
         * Remove a animation for the list of scene's animations
         * @param toRemove defines the animation to remove
         * @returns the index where the animation was in the animation list
         */
        removeAnimation(toRemove: Animation): number;
        /**
         * Will stop the animation of the given target
         * @param target - the target
         * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)
         * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)
         */
        stopAnimation(target: any, animationName?: string, targetMask?: (target: any) => boolean): void;
        /**
         * Removes the given animation group from this scene.
         * @param toRemove The animation group to remove
         * @returns The index of the removed animation group
         */
        removeAnimationGroup(toRemove: AnimationGroup): number;
        /**
         * Removes the given multi-material from this scene.
         * @param toRemove The multi-material to remove
         * @returns The index of the removed multi-material
         */
        removeMultiMaterial(toRemove: MultiMaterial): number;
        /**
         * Removes the given material from this scene.
         * @param toRemove The material to remove
         * @returns The index of the removed material
         */
        removeMaterial(toRemove: Material): number;
        /**
         * Removes the given action manager from this scene.
         * @param toRemove The action manager to remove
         * @returns The index of the removed action manager
         */
        removeActionManager(toRemove: AbstractActionManager): number;
        /**
         * Removes the given texture from this scene.
         * @param toRemove The texture to remove
         * @returns The index of the removed texture
         */
        removeTexture(toRemove: BaseTexture): number;
        /**
         * Adds the given light to this scene
         * @param newLight The light to add
         */
        addLight(newLight: Light): void;
        /**
         * Sorts the list list based on light priorities
         */
        sortLightsByPriority(): void;
        /**
         * Adds the given camera to this scene
         * @param newCamera The camera to add
         */
        addCamera(newCamera: Camera): void;
        /**
         * Adds the given skeleton to this scene
         * @param newSkeleton The skeleton to add
         */
        addSkeleton(newSkeleton: Skeleton): void;
        /**
         * Adds the given particle system to this scene
         * @param newParticleSystem The particle system to add
         */
        addParticleSystem(newParticleSystem: IParticleSystem): void;
        /**
         * Adds the given animation to this scene
         * @param newAnimation The animation to add
         */
        addAnimation(newAnimation: Animation): void;
        /**
         * Adds the given animation group to this scene.
         * @param newAnimationGroup The animation group to add
         */
        addAnimationGroup(newAnimationGroup: AnimationGroup): void;
        /**
         * Adds the given multi-material to this scene
         * @param newMultiMaterial The multi-material to add
         */
        addMultiMaterial(newMultiMaterial: MultiMaterial): void;
        /**
         * Adds the given material to this scene
         * @param newMaterial The material to add
         */
        addMaterial(newMaterial: Material): void;
        /**
         * Adds the given morph target to this scene
         * @param newMorphTargetManager The morph target to add
         */
        addMorphTargetManager(newMorphTargetManager: MorphTargetManager): void;
        /**
         * Adds the given geometry to this scene
         * @param newGeometry The geometry to add
         */
        addGeometry(newGeometry: Geometry): void;
        /**
         * Adds the given action manager to this scene
         * @param newActionManager The action manager to add
         */
        addActionManager(newActionManager: AbstractActionManager): void;
        /**
         * Adds the given texture to this scene.
         * @param newTexture The texture to add
         */
        addTexture(newTexture: BaseTexture): void;
        /**
         * Switch active camera
         * @param newCamera defines the new active camera
         * @param attachControl defines if attachControl must be called for the new active camera (default: true)
         */
        switchActiveCamera(newCamera: Camera, attachControl?: boolean): void;
        /**
         * sets the active camera of the scene using its ID
         * @param id defines the camera's ID
         * @return the new active camera or null if none found.
         */
        setActiveCameraByID(id: string): Nullable<Camera>;
        /**
         * sets the active camera of the scene using its name
         * @param name defines the camera's name
         * @returns the new active camera or null if none found.
         */
        setActiveCameraByName(name: string): Nullable<Camera>;
        /**
         * get an animation group using its name
         * @param name defines the material's name
         * @return the animation group or null if none found.
         */
        getAnimationGroupByName(name: string): Nullable<AnimationGroup>;
        /**
         * Get a material using its unique id
         * @param uniqueId defines the material's unique id
         * @return the material or null if none found.
         */
        getMaterialByUniqueID(uniqueId: number): Nullable<Material>;
        /**
         * get a material using its id
         * @param id defines the material's ID
         * @return the material or null if none found.
         */
        getMaterialByID(id: string): Nullable<Material>;
        /**
         * Gets a the last added material using a given id
         * @param id defines the material's ID
         * @return the last material with the given id or null if none found.
         */
        getLastMaterialByID(id: string): Nullable<Material>;
        /**
         * Gets a material using its name
         * @param name defines the material's name
         * @return the material or null if none found.
         */
        getMaterialByName(name: string): Nullable<Material>;
        /**
         * Get a texture using its unique id
         * @param uniqueId defines the texture's unique id
         * @return the texture or null if none found.
         */
        getTextureByUniqueID(uniqueId: number): Nullable<BaseTexture>;
        /**
         * Gets a camera using its id
         * @param id defines the id to look for
         * @returns the camera or null if not found
         */
        getCameraByID(id: string): Nullable<Camera>;
        /**
         * Gets a camera using its unique id
         * @param uniqueId defines the unique id to look for
         * @returns the camera or null if not found
         */
        getCameraByUniqueID(uniqueId: number): Nullable<Camera>;
        /**
         * Gets a camera using its name
         * @param name defines the camera's name
         * @return the camera or null if none found.
         */
        getCameraByName(name: string): Nullable<Camera>;
        /**
         * Gets a bone using its id
         * @param id defines the bone's id
         * @return the bone or null if not found
         */
        getBoneByID(id: string): Nullable<Bone>;
        /**
        * Gets a bone using its id
        * @param name defines the bone's name
        * @return the bone or null if not found
        */
        getBoneByName(name: string): Nullable<Bone>;
        /**
         * Gets a light node using its name
         * @param name defines the the light's name
         * @return the light or null if none found.
         */
        getLightByName(name: string): Nullable<Light>;
        /**
         * Gets a light node using its id
         * @param id defines the light's id
         * @return the light or null if none found.
         */
        getLightByID(id: string): Nullable<Light>;
        /**
         * Gets a light node using its scene-generated unique ID
         * @param uniqueId defines the light's unique id
         * @return the light or null if none found.
         */
        getLightByUniqueID(uniqueId: number): Nullable<Light>;
        /**
         * Gets a particle system by id
         * @param id defines the particle system id
         * @return the corresponding system or null if none found
         */
        getParticleSystemByID(id: string): Nullable<IParticleSystem>;
        /**
         * Gets a geometry using its ID
         * @param id defines the geometry's id
         * @return the geometry or null if none found.
         */
        getGeometryByID(id: string): Nullable<Geometry>;
        private _getGeometryByUniqueID;
        /**
         * Add a new geometry to this scene
         * @param geometry defines the geometry to be added to the scene.
         * @param force defines if the geometry must be pushed even if a geometry with this id already exists
         * @return a boolean defining if the geometry was added or not
         */
        pushGeometry(geometry: Geometry, force?: boolean): boolean;
        /**
         * Removes an existing geometry
         * @param geometry defines the geometry to be removed from the scene
         * @return a boolean defining if the geometry was removed or not
         */
        removeGeometry(geometry: Geometry): boolean;
        /**
         * Gets the list of geometries attached to the scene
         * @returns an array of Geometry
         */
        getGeometries(): Geometry[];
        /**
         * Gets the first added mesh found of a given ID
         * @param id defines the id to search for
         * @return the mesh found or null if not found at all
         */
        getMeshByID(id: string): Nullable<AbstractMesh>;
        /**
         * Gets a list of meshes using their id
         * @param id defines the id to search for
         * @returns a list of meshes
         */
        getMeshesByID(id: string): Array<AbstractMesh>;
        /**
         * Gets the first added transform node found of a given ID
         * @param id defines the id to search for
         * @return the found transform node or null if not found at all.
         */
        getTransformNodeByID(id: string): Nullable<TransformNode>;
        /**
         * Gets a transform node with its auto-generated unique id
         * @param uniqueId efines the unique id to search for
         * @return the found transform node or null if not found at all.
         */
        getTransformNodeByUniqueID(uniqueId: number): Nullable<TransformNode>;
        /**
         * Gets a list of transform nodes using their id
         * @param id defines the id to search for
         * @returns a list of transform nodes
         */
        getTransformNodesByID(id: string): Array<TransformNode>;
        /**
         * Gets a mesh with its auto-generated unique id
         * @param uniqueId defines the unique id to search for
         * @return the found mesh or null if not found at all.
         */
        getMeshByUniqueID(uniqueId: number): Nullable<AbstractMesh>;
        /**
         * Gets a the last added mesh using a given id
         * @param id defines the id to search for
         * @return the found mesh or null if not found at all.
         */
        getLastMeshByID(id: string): Nullable<AbstractMesh>;
        /**
         * Gets a the last added node (Mesh, Camera, Light) using a given id
         * @param id defines the id to search for
         * @return the found node or null if not found at all
         */
        getLastEntryByID(id: string): Nullable<Node>;
        /**
         * Gets a node (Mesh, Camera, Light) using a given id
         * @param id defines the id to search for
         * @return the found node or null if not found at all
         */
        getNodeByID(id: string): Nullable<Node>;
        /**
         * Gets a node (Mesh, Camera, Light) using a given name
         * @param name defines the name to search for
         * @return the found node or null if not found at all.
         */
        getNodeByName(name: string): Nullable<Node>;
        /**
         * Gets a mesh using a given name
         * @param name defines the name to search for
         * @return the found mesh or null if not found at all.
         */
        getMeshByName(name: string): Nullable<AbstractMesh>;
        /**
         * Gets a transform node using a given name
         * @param name defines the name to search for
         * @return the found transform node or null if not found at all.
         */
        getTransformNodeByName(name: string): Nullable<TransformNode>;
        /**
         * Gets a skeleton using a given id (if many are found, this function will pick the last one)
         * @param id defines the id to search for
         * @return the found skeleton or null if not found at all.
         */
        getLastSkeletonByID(id: string): Nullable<Skeleton>;
        /**
         * Gets a skeleton using a given auto generated unique id
         * @param  uniqueId defines the unique id to search for
         * @return the found skeleton or null if not found at all.
         */
        getSkeletonByUniqueId(uniqueId: number): Nullable<Skeleton>;
        /**
         * Gets a skeleton using a given id (if many are found, this function will pick the first one)
         * @param id defines the id to search for
         * @return the found skeleton or null if not found at all.
         */
        getSkeletonById(id: string): Nullable<Skeleton>;
        /**
         * Gets a skeleton using a given name
         * @param name defines the name to search for
         * @return the found skeleton or null if not found at all.
         */
        getSkeletonByName(name: string): Nullable<Skeleton>;
        /**
         * Gets a morph target manager  using a given id (if many are found, this function will pick the last one)
         * @param id defines the id to search for
         * @return the found morph target manager or null if not found at all.
         */
        getMorphTargetManagerById(id: number): Nullable<MorphTargetManager>;
        /**
         * Gets a morph target using a given id (if many are found, this function will pick the first one)
         * @param id defines the id to search for
         * @return the found morph target or null if not found at all.
         */
        getMorphTargetById(id: string): Nullable<MorphTarget>;
        /**
         * Gets a morph target using a given name (if many are found, this function will pick the first one)
         * @param name defines the name to search for
         * @return the found morph target or null if not found at all.
         */
        getMorphTargetByName(name: string): Nullable<MorphTarget>;
        /**
         * Gets a post process using a given name (if many are found, this function will pick the first one)
         * @param name defines the name to search for
         * @return the found post process or null if not found at all.
         */
        getPostProcessByName(name: string): Nullable<PostProcess>;
        /**
         * Gets a boolean indicating if the given mesh is active
         * @param mesh defines the mesh to look for
         * @returns true if the mesh is in the active list
         */
        isActiveMesh(mesh: AbstractMesh): boolean;
        /**
         * Return a unique id as a string which can serve as an identifier for the scene
         */
        get uid(): string;
        /**
         * Add an externaly attached data from its key.
         * This method call will fail and return false, if such key already exists.
         * If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.
         * @param key the unique key that identifies the data
         * @param data the data object to associate to the key for this Engine instance
         * @return true if no such key were already present and the data was added successfully, false otherwise
         */
        addExternalData<T>(key: string, data: T): boolean;
        /**
         * Get an externaly attached data from its key
         * @param key the unique key that identifies the data
         * @return the associated data, if present (can be null), or undefined if not present
         */
        getExternalData<T>(key: string): Nullable<T>;
        /**
         * Get an externaly attached data from its key, create it using a factory if it's not already present
         * @param key the unique key that identifies the data
         * @param factory the factory that will be called to create the instance if and only if it doesn't exists
         * @return the associated data, can be null if the factory returned null.
         */
        getOrAddExternalDataWithFactory<T>(key: string, factory: (k: string) => T): T;
        /**
         * Remove an externaly attached data from the Engine instance
         * @param key the unique key that identifies the data
         * @return true if the data was successfully removed, false if it doesn't exist
         */
        removeExternalData(key: string): boolean;
        private _evaluateSubMesh;
        /**
         * Clear the processed materials smart array preventing retention point in material dispose.
         */
        freeProcessedMaterials(): void;
        private _preventFreeActiveMeshesAndRenderingGroups;
        /** Gets or sets a boolean blocking all the calls to freeActiveMeshes and freeRenderingGroups
         * It can be used in order to prevent going through methods freeRenderingGroups and freeActiveMeshes several times to improve performance
         * when disposing several meshes in a row or a hierarchy of meshes.
         * When used, it is the responsability of the user to blockfreeActiveMeshesAndRenderingGroups back to false.
         */
        get blockfreeActiveMeshesAndRenderingGroups(): boolean;
        set blockfreeActiveMeshesAndRenderingGroups(value: boolean);
        /**
         * Clear the active meshes smart array preventing retention point in mesh dispose.
         */
        freeActiveMeshes(): void;
        /**
         * Clear the info related to rendering groups preventing retention points during dispose.
         */
        freeRenderingGroups(): void;
        /** @hidden */
        _isInIntermediateRendering(): boolean;
        /**
         * Lambda returning the list of potentially active meshes.
         */
        getActiveMeshCandidates: () => ISmartArrayLike<AbstractMesh>;
        /**
         * Lambda returning the list of potentially active sub meshes.
         */
        getActiveSubMeshCandidates: (mesh: AbstractMesh) => ISmartArrayLike<SubMesh>;
        /**
         * Lambda returning the list of potentially intersecting sub meshes.
         */
        getIntersectingSubMeshCandidates: (mesh: AbstractMesh, localRay: Ray) => ISmartArrayLike<SubMesh>;
        /**
         * Lambda returning the list of potentially colliding sub meshes.
         */
        getCollidingSubMeshCandidates: (mesh: AbstractMesh, collider: Collider) => ISmartArrayLike<SubMesh>;
        private _activeMeshesFrozen;
        private _skipEvaluateActiveMeshesCompletely;
        /**
         * Use this function to stop evaluating active meshes. The current list will be keep alive between frames
         * @param skipEvaluateActiveMeshes defines an optional boolean indicating that the evaluate active meshes step must be completely skipped
         * @returns the current scene
         */
        freezeActiveMeshes(skipEvaluateActiveMeshes?: boolean): Scene;
        /**
         * Use this function to restart evaluating active meshes on every frame
         * @returns the current scene
         */
        unfreezeActiveMeshes(): Scene;
        private _evaluateActiveMeshes;
        private _activeMesh;
        /**
         * Update the transform matrix to update from the current active camera
         * @param force defines a boolean used to force the update even if cache is up to date
         */
        updateTransformMatrix(force?: boolean): void;
        private _bindFrameBuffer;
        /** @hidden */
        _allowPostProcessClearColor: boolean;
        /** @hidden */
        _renderForCamera(camera: Camera, rigParent?: Camera): void;
        private _processSubCameras;
        private _checkIntersections;
        /** @hidden */
        _advancePhysicsEngineStep(step: number): void;
        /**
         * User updatable function that will return a deterministic frame time when engine is in deterministic lock step mode
         */
        getDeterministicFrameTime: () => number;
        /** @hidden */
        _animate(): void;
        /** Execute all animations (for a frame) */
        animate(): void;
        /**
         * Render the scene
         * @param updateCameras defines a boolean indicating if cameras must update according to their inputs (true by default)
         * @param ignoreAnimations defines a boolean indicating if animations should not be executed (false by default)
         */
        render(updateCameras?: boolean, ignoreAnimations?: boolean): void;
        /**
         * Freeze all materials
         * A frozen material will not be updatable but should be faster to render
         */
        freezeMaterials(): void;
        /**
         * Unfreeze all materials
         * A frozen material will not be updatable but should be faster to render
         */
        unfreezeMaterials(): void;
        /**
         * Releases all held ressources
         */
        dispose(): void;
        /**
         * Gets if the scene is already disposed
         */
        get isDisposed(): boolean;
        /**
         * Call this function to reduce memory footprint of the scene.
         * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)
         */
        clearCachedVertexData(): void;
        /**
         * This function will remove the local cached buffer data from texture.
         * It will save memory but will prevent the texture from being rebuilt
         */
        cleanCachedTextureBuffer(): void;
        /**
         * Get the world extend vectors with an optional filter
         *
         * @param filterPredicate the predicate - which meshes should be included when calculating the world size
         * @returns {{ min: Vector3; max: Vector3 }} min and max vectors
         */
        getWorldExtends(filterPredicate?: (mesh: AbstractMesh) => boolean): {
            min: Vector3;
            max: Vector3;
        };
        /**
         * Creates a ray that can be used to pick in the scene
         * @param x defines the x coordinate of the origin (on-screen)
         * @param y defines the y coordinate of the origin (on-screen)
         * @param world defines the world matrix to use if you want to pick in object space (instead of world space)
         * @param camera defines the camera to use for the picking
         * @param cameraViewSpace defines if picking will be done in view space (false by default)
         * @returns a Ray
         */
        createPickingRay(x: number, y: number, world: Matrix, camera: Nullable<Camera>, cameraViewSpace?: boolean): Ray;
        /**
         * Creates a ray that can be used to pick in the scene
         * @param x defines the x coordinate of the origin (on-screen)
         * @param y defines the y coordinate of the origin (on-screen)
         * @param world defines the world matrix to use if you want to pick in object space (instead of world space)
         * @param result defines the ray where to store the picking ray
         * @param camera defines the camera to use for the picking
         * @param cameraViewSpace defines if picking will be done in view space (false by default)
         * @returns the current scene
         */
        createPickingRayToRef(x: number, y: number, world: Matrix, result: Ray, camera: Nullable<Camera>, cameraViewSpace?: boolean): Scene;
        /**
         * Creates a ray that can be used to pick in the scene
         * @param x defines the x coordinate of the origin (on-screen)
         * @param y defines the y coordinate of the origin (on-screen)
         * @param camera defines the camera to use for the picking
         * @returns a Ray
         */
        createPickingRayInCameraSpace(x: number, y: number, camera?: Camera): Ray;
        /**
         * Creates a ray that can be used to pick in the scene
         * @param x defines the x coordinate of the origin (on-screen)
         * @param y defines the y coordinate of the origin (on-screen)
         * @param result defines the ray where to store the picking ray
         * @param camera defines the camera to use for the picking
         * @returns the current scene
         */
        createPickingRayInCameraSpaceToRef(x: number, y: number, result: Ray, camera?: Camera): Scene;
        /** Launch a ray to try to pick a mesh in the scene
         * @param x position on screen
         * @param y position on screen
         * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true
         * @param fastCheck defines if the first intersection will be used (and not the closest)
         * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used
         * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
         * @returns a PickingInfo
         */
        pick(x: number, y: number, predicate?: (mesh: AbstractMesh) => boolean, fastCheck?: boolean, camera?: Nullable<Camera>, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo>;
        /** Launch a ray to try to pick a mesh in the scene using only bounding information of the main mesh (not using submeshes)
         * @param x position on screen
         * @param y position on screen
         * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true
         * @param fastCheck defines if the first intersection will be used (and not the closest)
         * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used
         * @returns a PickingInfo (Please note that some info will not be set like distance, bv, bu and everything that cannot be capture by only using bounding infos)
         */
        pickWithBoundingInfo(x: number, y: number, predicate?: (mesh: AbstractMesh) => boolean, fastCheck?: boolean, camera?: Nullable<Camera>): Nullable<PickingInfo>;
        /** Use the given ray to pick a mesh in the scene
         * @param ray The ray to use to pick meshes
         * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true
         * @param fastCheck defines if the first intersection will be used (and not the closest)
         * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
         * @returns a PickingInfo
         */
        pickWithRay(ray: Ray, predicate?: (mesh: AbstractMesh) => boolean, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo>;
        /**
         * Launch a ray to try to pick a mesh in the scene
         * @param x X position on screen
         * @param y Y position on screen
         * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true
         * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used
         * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
         * @returns an array of PickingInfo
         */
        multiPick(x: number, y: number, predicate?: (mesh: AbstractMesh) => boolean, camera?: Camera, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]>;
        /**
         * Launch a ray to try to pick a mesh in the scene
         * @param ray Ray to use
         * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true
         * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
         * @returns an array of PickingInfo
         */
        multiPickWithRay(ray: Ray, predicate: (mesh: AbstractMesh) => boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]>;
        /**
         * Force the value of meshUnderPointer
         * @param mesh defines the mesh to use
         * @param pointerId optional pointer id when using more than one pointer
         */
        setPointerOverMesh(mesh: Nullable<AbstractMesh>, pointerId?: number): void;
        /**
         * Gets the mesh under the pointer
         * @returns a Mesh or null if no mesh is under the pointer
         */
        getPointerOverMesh(): Nullable<AbstractMesh>;
        /** @hidden */
        _rebuildGeometries(): void;
        /** @hidden */
        _rebuildTextures(): void;
        private _getByTags;
        /**
         * Get a list of meshes by tags
         * @param tagsQuery defines the tags query to use
         * @param forEach defines a predicate used to filter results
         * @returns an array of Mesh
         */
        getMeshesByTags(tagsQuery: string, forEach?: (mesh: AbstractMesh) => void): Mesh[];
        /**
         * Get a list of cameras by tags
         * @param tagsQuery defines the tags query to use
         * @param forEach defines a predicate used to filter results
         * @returns an array of Camera
         */
        getCamerasByTags(tagsQuery: string, forEach?: (camera: Camera) => void): Camera[];
        /**
         * Get a list of lights by tags
         * @param tagsQuery defines the tags query to use
         * @param forEach defines a predicate used to filter results
         * @returns an array of Light
         */
        getLightsByTags(tagsQuery: string, forEach?: (light: Light) => void): Light[];
        /**
         * Get a list of materials by tags
         * @param tagsQuery defines the tags query to use
         * @param forEach defines a predicate used to filter results
         * @returns an array of Material
         */
        getMaterialByTags(tagsQuery: string, forEach?: (material: Material) => void): Material[];
        /**
         * Get a list of transform nodes by tags
         * @param tagsQuery defines the tags query to use
         * @param forEach defines a predicate used to filter results
         * @returns an array of TransformNode
         */
        getTransformNodesByTags(tagsQuery: string, forEach?: (transform: TransformNode) => void): TransformNode[];
        /**
         * Overrides the default sort function applied in the renderging group to prepare the meshes.
         * This allowed control for front to back rendering or reversly depending of the special needs.
         *
         * @param renderingGroupId The rendering group id corresponding to its index
         * @param opaqueSortCompareFn The opaque queue comparison function use to sort.
         * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.
         * @param transparentSortCompareFn The transparent queue comparison function use to sort.
         */
        setRenderingOrder(renderingGroupId: number, opaqueSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>, alphaTestSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>, transparentSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>): void;
        /**
         * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
         *
         * @param renderingGroupId The rendering group id corresponding to its index
         * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
         * @param depth Automatically clears depth between groups if true and autoClear is true.
         * @param stencil Automatically clears stencil between groups if true and autoClear is true.
         */
        setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean, depth?: boolean, stencil?: boolean): void;
        /**
         * Gets the current auto clear configuration for one rendering group of the rendering
         * manager.
         * @param index the rendering group index to get the information for
         * @returns The auto clear setup for the requested rendering group
         */
        getAutoClearDepthStencilSetup(index: number): IRenderingManagerAutoClearSetup;
        private _blockMaterialDirtyMechanism;
        /** Gets or sets a boolean blocking all the calls to markAllMaterialsAsDirty (ie. the materials won't be updated if they are out of sync) */
        get blockMaterialDirtyMechanism(): boolean;
        set blockMaterialDirtyMechanism(value: boolean);
        /**
         * Will flag all materials as dirty to trigger new shader compilation
         * @param flag defines the flag used to specify which material part must be marked as dirty
         * @param predicate If not null, it will be used to specifiy if a material has to be marked as dirty
         */
        markAllMaterialsAsDirty(flag: number, predicate?: (mat: Material) => boolean): void;
        /** @hidden */
        _loadFile(url: string, onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void, onProgress?: (ev: ProgressEvent) => void, useOfflineSupport?: boolean, useArrayBuffer?: boolean, onError?: (request?: WebRequest, exception?: LoadFileError) => void): IFileRequest;
        /** @hidden */
        _loadFileAsync(url: string, onProgress?: (data: any) => void, useOfflineSupport?: boolean, useArrayBuffer?: boolean): Promise<string | ArrayBuffer>;
        /** @hidden */
        _requestFile(url: string, onSuccess: (data: string | ArrayBuffer, request?: WebRequest) => void, onProgress?: (ev: ProgressEvent) => void, useOfflineSupport?: boolean, useArrayBuffer?: boolean, onError?: (error: RequestFileError) => void, onOpened?: (request: WebRequest) => void): IFileRequest;
        /** @hidden */
        _requestFileAsync(url: string, onProgress?: (ev: ProgressEvent) => void, useOfflineSupport?: boolean, useArrayBuffer?: boolean, onOpened?: (request: WebRequest) => void): Promise<string | ArrayBuffer>;
        /** @hidden */
        _readFile(file: File, onSuccess: (data: string | ArrayBuffer) => void, onProgress?: (ev: ProgressEvent) => any, useArrayBuffer?: boolean, onError?: (error: ReadFileError) => void): IFileRequest;
        /** @hidden */
        _readFileAsync(file: File, onProgress?: (ev: ProgressEvent) => any, useArrayBuffer?: boolean): Promise<string | ArrayBuffer>;
    }
}
declare module BABYLON {
    /**
     * Set of assets to keep when moving a scene into an asset container.
     */
    export class KeepAssets extends AbstractScene {
    }
    /**
     * Class used to store the output of the AssetContainer.instantiateAllMeshesToScene function
     */
    export class InstantiatedEntries {
        /**
         * List of new root nodes (eg. nodes with no parent)
         */
        rootNodes: TransformNode[];
        /**
         * List of new skeletons
         */
        skeletons: Skeleton[];
        /**
         * List of new animation groups
         */
        animationGroups: AnimationGroup[];
    }
    /**
     * Container with a set of assets that can be added or removed from a scene.
     */
    export class AssetContainer extends AbstractScene {
        private _wasAddedToScene;
        /**
         * The scene the AssetContainer belongs to.
         */
        scene: Scene;
        /**
         * Instantiates an AssetContainer.
         * @param scene The scene the AssetContainer belongs to.
         */
        constructor(scene: Scene);
        /**
         * Instantiate or clone all meshes and add the new ones to the scene.
         * Skeletons and animation groups will all be cloned
         * @param nameFunction defines an optional function used to get new names for clones
         * @param cloneMaterials defines an optional boolean that defines if materials must be cloned as well (false by default)
         * @returns a list of rootNodes, skeletons and aniamtion groups that were duplicated
         */
        instantiateModelsToScene(nameFunction?: (sourceName: string) => string, cloneMaterials?: boolean): InstantiatedEntries;
        /**
         * Adds all the assets from the container to the scene.
         */
        addAllToScene(): void;
        /**
         * Removes all the assets in the container from the scene
         */
        removeAllFromScene(): void;
        /**
         * Disposes all the assets in the container
         */
        dispose(): void;
        private _moveAssets;
        /**
         * Removes all the assets contained in the scene and adds them to the container.
         * @param keepAssets Set of assets to keep in the scene. (default: empty)
         */
        moveAllFromScene(keepAssets?: KeepAssets): void;
        /**
         * Adds all meshes in the asset container to a root mesh that can be used to position all the contained meshes. The root mesh is then added to the front of the meshes in the assetContainer.
         * @returns the root mesh
         */
        createRootMesh(): Mesh;
        /**
         * Merge animations (direct and animation groups) from this asset container into a scene
         * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
         * @param animatables set of animatables to retarget to a node from the scene
         * @param targetConverter defines a function used to convert animation targets from the asset container to the scene (default: search node by name)
         * @returns an array of the new AnimationGroup added to the scene (empty array if none)
         */
        mergeAnimationsTo(scene: Scene | null | undefined, animatables: Animatable[], targetConverter?: Nullable<(target: any) => Nullable<Node>>): AnimationGroup[];
    }
}
declare module BABYLON {
    /**
     * Defines how the parser contract is defined.
     * These parsers are used to parse a list of specific assets (like particle systems, etc..)
     */
    export type BabylonFileParser = (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => void;
    /**
     * Defines how the individual parser contract is defined.
     * These parser can parse an individual asset
     */
    export type IndividualBabylonFileParser = (parsedData: any, scene: Scene, rootUrl: string) => any;
    /**
     * Base class of the scene acting as a container for the different elements composing a scene.
     * This class is dynamically extended by the different components of the scene increasing
     * flexibility and reducing coupling
     */
    export abstract class AbstractScene {
        /**
         * Stores the list of available parsers in the application.
         */
        private static _BabylonFileParsers;
        /**
         * Stores the list of available individual parsers in the application.
         */
        private static _IndividualBabylonFileParsers;
        /**
         * Adds a parser in the list of available ones
         * @param name Defines the name of the parser
         * @param parser Defines the parser to add
         */
        static AddParser(name: string, parser: BabylonFileParser): void;
        /**
         * Gets a general parser from the list of avaialble ones
         * @param name Defines the name of the parser
         * @returns the requested parser or null
         */
        static GetParser(name: string): Nullable<BabylonFileParser>;
        /**
         * Adds n individual parser in the list of available ones
         * @param name Defines the name of the parser
         * @param parser Defines the parser to add
         */
        static AddIndividualParser(name: string, parser: IndividualBabylonFileParser): void;
        /**
         * Gets an individual parser from the list of avaialble ones
         * @param name Defines the name of the parser
         * @returns the requested parser or null
         */
        static GetIndividualParser(name: string): Nullable<IndividualBabylonFileParser>;
        /**
         * Parser json data and populate both a scene and its associated container object
         * @param jsonData Defines the data to parse
         * @param scene Defines the scene to parse the data for
         * @param container Defines the container attached to the parsing sequence
         * @param rootUrl Defines the root url of the data
         */
        static Parse(jsonData: any, scene: Scene, container: AssetContainer, rootUrl: string): void;
        /**
         * Gets the list of root nodes (ie. nodes with no parent)
         */
        rootNodes: Node[];
        /** All of the cameras added to this scene
         * @see https://doc.babylonjs.com/babylon101/cameras
         */
        cameras: Camera[];
        /**
        * All of the lights added to this scene
        * @see https://doc.babylonjs.com/babylon101/lights
        */
        lights: Light[];
        /**
        * All of the (abstract) meshes added to this scene
        */
        meshes: AbstractMesh[];
        /**
         * The list of skeletons added to the scene
         * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons
         */
        skeletons: Skeleton[];
        /**
        * All of the particle systems added to this scene
        * @see https://doc.babylonjs.com/babylon101/particles
        */
        particleSystems: IParticleSystem[];
        /**
         * Gets a list of Animations associated with the scene
         */
        animations: Animation[];
        /**
        * All of the animation groups added to this scene
        * @see https://doc.babylonjs.com/how_to/group
        */
        animationGroups: AnimationGroup[];
        /**
        * All of the multi-materials added to this scene
        * @see https://doc.babylonjs.com/how_to/multi_materials
        */
        multiMaterials: MultiMaterial[];
        /**
        * All of the materials added to this scene
        * In the context of a Scene, it is not supposed to be modified manually.
        * Any addition or removal should be done using the addMaterial and removeMaterial Scene methods.
        * Note also that the order of the Material within the array is not significant and might change.
        * @see https://doc.babylonjs.com/babylon101/materials
        */
        materials: Material[];
        /**
         * The list of morph target managers added to the scene
         * @see https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh
         */
        morphTargetManagers: MorphTargetManager[];
        /**
         * The list of geometries used in the scene.
         */
        geometries: Geometry[];
        /**
        * All of the tranform nodes added to this scene
        * In the context of a Scene, it is not supposed to be modified manually.
        * Any addition or removal should be done using the addTransformNode and removeTransformNode Scene methods.
        * Note also that the order of the TransformNode wihin the array is not significant and might change.
        * @see https://doc.babylonjs.com/how_to/transformnode
        */
        transformNodes: TransformNode[];
        /**
         * ActionManagers available on the scene.
         */
        actionManagers: AbstractActionManager[];
        /**
         * Textures to keep.
         */
        textures: BaseTexture[];
        /** @hidden */
        protected _environmentTexture: Nullable<BaseTexture>;
        /**
         * Texture used in all pbr material as the reflection texture.
         * As in the majority of the scene they are the same (exception for multi room and so on),
         * this is easier to reference from here than from all the materials.
         */
        get environmentTexture(): Nullable<BaseTexture>;
        set environmentTexture(value: Nullable<BaseTexture>);
        /**
         * The list of postprocesses added to the scene
         */
        postProcesses: PostProcess[];
        /**
         * @returns all meshes, lights, cameras, transformNodes and bones
         */
        getNodes(): Array<Node>;
    }
}
declare module BABYLON {
    /**
     * Interface used to define options for Sound class
     */
    export interface ISoundOptions {
        /**
         * Does the sound autoplay once loaded.
         */
        autoplay?: boolean;
        /**
         * Does the sound loop after it finishes playing once.
         */
        loop?: boolean;
        /**
         * Sound's volume
         */
        volume?: number;
        /**
         * Is it a spatial sound?
         */
        spatialSound?: boolean;
        /**
         * Maximum distance to hear that sound
         */
        maxDistance?: number;
        /**
         * Uses user defined attenuation function
         */
        useCustomAttenuation?: boolean;
        /**
         * Define the roll off factor of spatial sounds.
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
         */
        rolloffFactor?: number;
        /**
         * Define the reference distance the sound should be heard perfectly.
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
         */
        refDistance?: number;
        /**
         * Define the distance attenuation model the sound will follow.
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
         */
        distanceModel?: string;
        /**
         * Defines the playback speed (1 by default)
         */
        playbackRate?: number;
        /**
         * Defines if the sound is from a streaming source
         */
        streaming?: boolean;
        /**
         * Defines an optional length (in seconds) inside the sound file
         */
        length?: number;
        /**
         * Defines an optional offset (in seconds) inside the sound file
         */
        offset?: number;
        /**
         * If true, URLs will not be required to state the audio file codec to use.
         */
        skipCodecCheck?: boolean;
    }
    /**
     * Defines a sound that can be played in the application.
     * The sound can either be an ambient track or a simple sound played in reaction to a user action.
     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music
     */
    export class Sound {
        /**
         * The name of the sound in the scene.
         */
        name: string;
        /**
         * Does the sound autoplay once loaded.
         */
        autoplay: boolean;
        /**
         * Does the sound loop after it finishes playing once.
         */
        loop: boolean;
        /**
         * Does the sound use a custom attenuation curve to simulate the falloff
         * happening when the source gets further away from the camera.
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-your-own-custom-attenuation-function
         */
        useCustomAttenuation: boolean;
        /**
         * The sound track id this sound belongs to.
         */
        soundTrackId: number;
        /**
         * Is this sound currently played.
         */
        isPlaying: boolean;
        /**
         * Is this sound currently paused.
         */
        isPaused: boolean;
        /**
         * Does this sound enables spatial sound.
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
         */
        spatialSound: boolean;
        /**
         * Define the reference distance the sound should be heard perfectly.
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
         */
        refDistance: number;
        /**
         * Define the roll off factor of spatial sounds.
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
         */
        rolloffFactor: number;
        /**
         * Define the max distance the sound should be heard (intensity just became 0 at this point).
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
         */
        maxDistance: number;
        /**
         * Define the distance attenuation model the sound will follow.
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
         */
        distanceModel: string;
        /**
         * @hidden
         * Back Compat
         **/
        onended: () => any;
        /**
         * Gets or sets an object used to store user defined information for the sound.
         */
        metadata: any;
        /**
         * Observable event when the current playing sound finishes.
         */
        onEndedObservable: Observable<Sound>;
        private _panningModel;
        private _playbackRate;
        private _streaming;
        private _startTime;
        private _startOffset;
        private _position;
        /** @hidden */
        _positionInEmitterSpace: boolean;
        private _localDirection;
        private _volume;
        private _isReadyToPlay;
        private _isDirectional;
        private _readyToPlayCallback;
        private _audioBuffer;
        private _soundSource;
        private _streamingSource;
        private _soundPanner;
        private _soundGain;
        private _inputAudioNode;
        private _outputAudioNode;
        private _coneInnerAngle;
        private _coneOuterAngle;
        private _coneOuterGain;
        private _scene;
        private _connectedTransformNode;
        private _customAttenuationFunction;
        private _registerFunc;
        private _isOutputConnected;
        private _htmlAudioElement;
        private _urlType;
        private _length?;
        private _offset?;
        /** @hidden */
        static _SceneComponentInitialization: (scene: Scene) => void;
        /**
         * Create a sound and attach it to a scene
         * @param name Name of your sound
         * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams
         * @param scene defines the scene the sound belongs to
         * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played
         * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming
         */
        constructor(name: string, urlOrArrayBuffer: any, scene: Scene, readyToPlayCallback?: Nullable<() => void>, options?: ISoundOptions);
        /**
         * Release the sound and its associated resources
         */
        dispose(): void;
        /**
         * Gets if the sounds is ready to be played or not.
         * @returns true if ready, otherwise false
         */
        isReady(): boolean;
        private _soundLoaded;
        /**
         * Sets the data of the sound from an audiobuffer
         * @param audioBuffer The audioBuffer containing the data
         */
        setAudioBuffer(audioBuffer: AudioBuffer): void;
        /**
         * Updates the current sounds options such as maxdistance, loop...
         * @param options A JSON object containing values named as the object properties
         */
        updateOptions(options: ISoundOptions): void;
        private _createSpatialParameters;
        private _updateSpatialParameters;
        /**
         * Switch the panning model to HRTF:
         * Renders a stereo output of higher quality than equalpower  it uses a convolution with measured impulse responses from human subjects.
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
         */
        switchPanningModelToHRTF(): void;
        /**
         * Switch the panning model to Equal Power:
         * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
         */
        switchPanningModelToEqualPower(): void;
        private _switchPanningModel;
        /**
         * Connect this sound to a sound track audio node like gain...
         * @param soundTrackAudioNode the sound track audio node to connect to
         */
        connectToSoundTrackAudioNode(soundTrackAudioNode: AudioNode): void;
        /**
         * Transform this sound into a directional source
         * @param coneInnerAngle Size of the inner cone in degree
         * @param coneOuterAngle Size of the outer cone in degree
         * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)
         */
        setDirectionalCone(coneInnerAngle: number, coneOuterAngle: number, coneOuterGain: number): void;
        /**
         * Gets or sets the inner angle for the directional cone.
         */
        get directionalConeInnerAngle(): number;
        /**
         * Gets or sets the inner angle for the directional cone.
         */
        set directionalConeInnerAngle(value: number);
        /**
         * Gets or sets the outer angle for the directional cone.
         */
        get directionalConeOuterAngle(): number;
        /**
         * Gets or sets the outer angle for the directional cone.
         */
        set directionalConeOuterAngle(value: number);
        /**
         * Sets the position of the emitter if spatial sound is enabled
         * @param newPosition Defines the new posisiton
         */
        setPosition(newPosition: Vector3): void;
        /**
         * Sets the local direction of the emitter if spatial sound is enabled
         * @param newLocalDirection Defines the new local direction
         */
        setLocalDirectionToMesh(newLocalDirection: Vector3): void;
        private _updateDirection;
        /** @hidden */
        updateDistanceFromListener(): void;
        /**
         * Sets a new custom attenuation function for the sound.
         * @param callback Defines the function used for the attenuation
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-your-own-custom-attenuation-function
         */
        setAttenuationFunction(callback: (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => number): void;
        /**
         * Play the sound
         * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.
         * @param offset (optional) Start the sound at a specific time in seconds
         * @param length (optional) Sound duration (in seconds)
         */
        play(time?: number, offset?: number, length?: number): void;
        private _onended;
        /**
         * Stop the sound
         * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.
         */
        stop(time?: number): void;
        /**
         * Put the sound in pause
         */
        pause(): void;
        /**
         * Sets a dedicated volume for this sounds
         * @param newVolume Define the new volume of the sound
         * @param time Define time for gradual change to new volume
         */
        setVolume(newVolume: number, time?: number): void;
        /**
         * Set the sound play back rate
         * @param newPlaybackRate Define the playback rate the sound should be played at
         */
        setPlaybackRate(newPlaybackRate: number): void;
        /**
         * Gets the volume of the sound.
         * @returns the volume of the sound
         */
        getVolume(): number;
        /**
         * Attach the sound to a dedicated mesh
         * @param transformNode The transform node to connect the sound with
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#attaching-a-sound-to-a-mesh
         */
        attachToMesh(transformNode: TransformNode): void;
        /**
         * Detach the sound from the previously attached mesh
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#attaching-a-sound-to-a-mesh
         */
        detachFromMesh(): void;
        private _onRegisterAfterWorldMatrixUpdate;
        /**
         * Clone the current sound in the scene.
         * @returns the new sound clone
         */
        clone(): Nullable<Sound>;
        /**
         * Gets the current underlying audio buffer containing the data
         * @returns the audio buffer
         */
        getAudioBuffer(): Nullable<AudioBuffer>;
        /**
         * Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.
         * @returns the source node
         */
        getSoundSource(): Nullable<AudioBufferSourceNode>;
        /**
         * Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.
         * @returns the gain node
         */
        getSoundGain(): Nullable<GainNode>;
        /**
         * Serializes the Sound in a JSON representation
         * @returns the JSON representation of the sound
         */
        serialize(): any;
        /**
         * Parse a JSON representation of a sound to innstantiate in a given scene
         * @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)
         * @param scene Define the scene the new parsed sound should be created in
         * @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies
         * @param sourceSound Define a cound place holder if do not need to instantiate a new one
         * @returns the newly parsed sound
         */
        static Parse(parsedSound: any, scene: Scene, rootUrl: string, sourceSound?: Sound): Sound;
    }
}
declare module BABYLON {
    /**
     * This defines an action helpful to play a defined sound on a triggered action.
     */
    export class PlaySoundAction extends Action {
        private _sound;
        /**
         * Instantiate the action
         * @param triggerOptions defines the trigger options
         * @param sound defines the sound to play
         * @param condition defines the trigger related conditions
         */
        constructor(triggerOptions: any, sound: Sound, condition?: Condition);
        /** @hidden */
        _prepare(): void;
        /**
         * Execute the action and play the sound.
         */
        execute(): void;
        /**
         * Serializes the actions and its related information.
         * @param parent defines the object to serialize in
         * @returns the serialized object
         */
        serialize(parent: any): any;
    }
    /**
     * This defines an action helpful to stop a defined sound on a triggered action.
     */
    export class StopSoundAction extends Action {
        private _sound;
        /**
         * Instantiate the action
         * @param triggerOptions defines the trigger options
         * @param sound defines the sound to stop
         * @param condition defines the trigger related conditions
         */
        constructor(triggerOptions: any, sound: Sound, condition?: Condition);
        /** @hidden */
        _prepare(): void;
        /**
         * Execute the action and stop the sound.
         */
        execute(): void;
        /**
         * Serializes the actions and its related information.
         * @param parent defines the object to serialize in
         * @returns the serialized object
         */
        serialize(parent: any): any;
    }
}
declare module BABYLON {
    /**
     * This defines an action responsible to change the value of a property
     * by interpolating between its current value and the newly set one once triggered.
     * @see https://doc.babylonjs.com/how_to/how_to_use_actions
     */
    export class InterpolateValueAction extends Action {
        /**
         * Defines the path of the property where the value should be interpolated
         */
        propertyPath: string;
        /**
         * Defines the target value at the end of the interpolation.
         */
        value: any;
        /**
         * Defines the time it will take for the property to interpolate to the value.
         */
        duration: number;
        /**
         * Defines if the other scene animations should be stopped when the action has been triggered
         */
        stopOtherAnimations?: boolean;
        /**
         * Defines a callback raised once the interpolation animation has been done.
         */
        onInterpolationDone?: () => void;
        /**
         * Observable triggered once the interpolation animation has been done.
         */
        onInterpolationDoneObservable: Observable<InterpolateValueAction>;
        private _target;
        private _effectiveTarget;
        private _property;
        /**
         * Instantiate the action
         * @param triggerOptions defines the trigger options
         * @param target defines the object containing the value to interpolate
         * @param propertyPath defines the path to the property in the target object
         * @param value defines the target value at the end of the interpolation
         * @param duration deines the time it will take for the property to interpolate to the value.
         * @param condition defines the trigger related conditions
         * @param stopOtherAnimations defines if the other scene animations should be stopped when the action has been triggered
         * @param onInterpolationDone defines a callback raised once the interpolation animation has been done
         */
        constructor(triggerOptions: any, target: any, propertyPath: string, value: any, duration?: number, condition?: Condition, stopOtherAnimations?: boolean, onInterpolationDone?: () => void);
        /** @hidden */
        _prepare(): void;
        /**
         * Execute the action starts the value interpolation.
         */
        execute(): void;
        /**
         * Serializes the actions and its related information.
         * @param parent defines the object to serialize in
         * @returns the serialized object
         */
        serialize(parent: any): any;
    }
}
declare module BABYLON {
    /**
     * Options allowed during the creation of a sound track.
     */
    export interface ISoundTrackOptions {
        /**
         * The volume the sound track should take during creation
         */
        volume?: number;
        /**
         * Define if the sound track is the main sound track of the scene
         */
        mainTrack?: boolean;
    }
    /**
     * It could be useful to isolate your music & sounds on several tracks to better manage volume on a grouped instance of sounds.
     * It will be also used in a future release to apply effects on a specific track.
     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#using-sound-tracks
     */
    export class SoundTrack {
        /**
         * The unique identifier of the sound track in the scene.
         */
        id: number;
        /**
         * The list of sounds included in the sound track.
         */
        soundCollection: Array<Sound>;
        private _outputAudioNode;
        private _scene;
        private _connectedAnalyser;
        private _options;
        private _isInitialized;
        /**
         * Creates a new sound track.
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#using-sound-tracks
         * @param scene Define the scene the sound track belongs to
         * @param options
         */
        constructor(scene: Scene, options?: ISoundTrackOptions);
        private _initializeSoundTrackAudioGraph;
        /**
         * Release the sound track and its associated resources
         */
        dispose(): void;
        /**
         * Adds a sound to this sound track
         * @param sound define the cound to add
         * @ignoreNaming
         */
        AddSound(sound: Sound): void;
        /**
         * Removes a sound to this sound track
         * @param sound define the cound to remove
         * @ignoreNaming
         */
        RemoveSound(sound: Sound): void;
        /**
         * Set a global volume for the full sound track.
         * @param newVolume Define the new volume of the sound track
         */
        setVolume(newVolume: number): void;
        /**
         * Switch the panning model to HRTF:
         * Renders a stereo output of higher quality than equalpower  it uses a convolution with measured impulse responses from human subjects.
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
         */
        switchPanningModelToHRTF(): void;
        /**
         * Switch the panning model to Equal Power:
         * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound
         */
        switchPanningModelToEqualPower(): void;
        /**
         * Connect the sound track to an audio analyser allowing some amazing
         * synchornization between the sounds/music and your visualization (VuMeter for instance).
         * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#using-the-analyser
         * @param analyser The analyser to connect to the engine
         */
        connectToAnalyser(analyser: Analyser): void;
    }
}
declare module BABYLON {
        interface AbstractScene {
            /**
             * The list of sounds used in the scene.
             */
            sounds: Nullable<Array<Sound>>;
        }
        interface Scene {
            /**
             * @hidden
             * Backing field
             */
            _mainSoundTrack: SoundTrack;
            /**
             * The main sound track played by the scene.
             * It cotains your primary collection of sounds.
             */
            mainSoundTrack: SoundTrack;
            /**
             * The list of sound tracks added to the scene
             * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music
             */
            soundTracks: Nullable<Array<SoundTrack>>;
            /**
             * Gets a sound using a given name
             * @param name defines the name to search for
             * @return the found sound or null if not found at all.
             */
            getSoundByName(name: string): Nullable<Sound>;
            /**
             * Gets or sets if audio support is enabled
             * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music
             */
            audioEnabled: boolean;
            /**
             * Gets or sets if audio will be output to headphones
             * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music
             */
            headphone: boolean;
            /**
             * Gets or sets custom audio listener position provider
             * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music
             */
            audioListenerPositionProvider: Nullable<() => Vector3>;
            /**
             * Gets or sets a refresh rate when using 3D audio positioning
             */
            audioPositioningRefreshRate: number;
        }
    /**
     * Defines the sound scene component responsible to manage any sounds
     * in a given scene.
     */
    export class AudioSceneComponent implements ISceneSerializableComponent {
        private static _CameraDirectionLH;
        private static _CameraDirectionRH;
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        readonly name: string;
        /**
         * The scene the component belongs to.
         */
        scene: Scene;
        private _audioEnabled;
        /**
         * Gets whether audio is enabled or not.
         * Please use related enable/disable method to switch state.
         */
        get audioEnabled(): boolean;
        private _headphone;
        /**
         * Gets whether audio is outputing to headphone or not.
         * Please use the according Switch methods to change output.
         */
        get headphone(): boolean;
        /**
         * Gets or sets a refresh rate when using 3D audio positioning
         */
        audioPositioningRefreshRate: number;
        private _audioListenerPositionProvider;
        /**
         * Gets the current audio listener position provider
         */
        get audioListenerPositionProvider(): Nullable<() => Vector3>;
        /**
         * Sets a custom listener position for all sounds in the scene
         * By default, this is the position of the first active camera
         */
        set audioListenerPositionProvider(value: Nullable<() => Vector3>);
        /**
         * Creates a new instance of the component for the given scene
         * @param scene Defines the scene to register the component in
         */
        constructor(scene: Scene);
        /**
         * Registers the component in a given scene
         */
        register(): void;
        /**
         * Rebuilds the elements related to this component in case of
         * context lost for instance.
         */
        rebuild(): void;
        /**
         * Serializes the component data to the specified json object
         * @param serializationObject The object to serialize to
         */
        serialize(serializationObject: any): void;
        /**
         * Adds all the elements from the container to the scene
         * @param container the container holding the elements
         */
        addFromContainer(container: AbstractScene): void;
        /**
         * Removes all the elements in the container from the scene
         * @param container contains the elements to remove
         * @param dispose if the removed element should be disposed (default: false)
         */
        removeFromContainer(container: AbstractScene, dispose?: boolean): void;
        /**
         * Disposes the component and the associated ressources.
         */
        dispose(): void;
        /**
         * Disables audio in the associated scene.
         */
        disableAudio(): void;
        /**
         * Enables audio in the associated scene.
         */
        enableAudio(): void;
        /**
         * Switch audio to headphone output.
         */
        switchAudioModeForHeadphones(): void;
        /**
         * Switch audio to normal speakers.
         */
        switchAudioModeForNormalSpeakers(): void;
        private _cachedCameraDirection;
        private _cachedCameraPosition;
        private _lastCheck;
        private _afterRender;
    }
}
declare module BABYLON {
    /**
     * Wraps one or more Sound objects and selects one with random weight for playback.
     */
    export class WeightedSound {
        /** When true a Sound will be selected and played when the current playing Sound completes. */
        loop: boolean;
        private _coneInnerAngle;
        private _coneOuterAngle;
        private _volume;
        /** A Sound is currently playing. */
        isPlaying: boolean;
        /** A Sound is currently paused. */
        isPaused: boolean;
        private _sounds;
        private _weights;
        private _currentIndex?;
        /**
         * Creates a new WeightedSound from the list of sounds given.
         * @param loop When true a Sound will be selected and played when the current playing Sound completes.
         * @param sounds Array of Sounds that will be selected from.
         * @param weights Array of number values for selection weights; length must equal sounds, values will be normalized to 1
         */
        constructor(loop: boolean, sounds: Sound[], weights: number[]);
        /**
         * The size of cone in degrees for a directional sound in which there will be no attenuation.
         */
        get directionalConeInnerAngle(): number;
        /**
         * The size of cone in degress for a directional sound in which there will be no attenuation.
         */
        set directionalConeInnerAngle(value: number);
        /**
         * Size of cone in degrees for a directional sound outside of which there will be no sound.
         * Listener angles between innerAngle and outerAngle will falloff linearly.
         */
        get directionalConeOuterAngle(): number;
        /**
         * Size of cone in degrees for a directional sound outside of which there will be no sound.
         * Listener angles between innerAngle and outerAngle will falloff linearly.
         */
        set directionalConeOuterAngle(value: number);
        /**
         * Playback volume.
         */
        get volume(): number;
        /**
         * Playback volume.
         */
        set volume(value: number);
        private _onended;
        /**
         * Suspend playback
         */
        pause(): void;
        /**
         * Stop playback
         */
        stop(): void;
        /**
         * Start playback.
         * @param startOffset Position the clip head at a specific time in seconds.
         */
        play(startOffset?: number): void;
    }
}
declare module BABYLON {
    /**
     * Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius
     * @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior
     */
    export class BouncingBehavior implements Behavior<ArcRotateCamera> {
        /**
         * Gets the name of the behavior.
         */
        get name(): string;
        /**
         * The easing function used by animations
         */
        static EasingFunction: BackEase;
        /**
         * The easing mode used by animations
         */
        static EasingMode: number;
        /**
         * The duration of the animation, in milliseconds
         */
        transitionDuration: number;
        /**
         * Length of the distance animated by the transition when lower radius is reached
         */
        lowerRadiusTransitionRange: number;
        /**
         * Length of the distance animated by the transition when upper radius is reached
         */
        upperRadiusTransitionRange: number;
        private _autoTransitionRange;
        /**
         * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically
         */
        get autoTransitionRange(): boolean;
        /**
         * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically
         * Transition ranges will be set to 5% of the bounding box diagonal in world space
         */
        set autoTransitionRange(value: boolean);
        private _attachedCamera;
        private _onAfterCheckInputsObserver;
        private _onMeshTargetChangedObserver;
        /**
         * Initializes the behavior.
         */
        init(): void;
        /**
         * Attaches the behavior to its arc rotate camera.
         * @param camera Defines the camera to attach the behavior to
         */
        attach(camera: ArcRotateCamera): void;
        /**
         * Detaches the behavior from its current arc rotate camera.
         */
        detach(): void;
        private _radiusIsAnimating;
        private _radiusBounceTransition;
        private _animatables;
        private _cachedWheelPrecision;
        /**
         * Checks if the camera radius is at the specified limit. Takes into account animation locks.
         * @param radiusLimit The limit to check against.
         * @return Bool to indicate if at limit.
         */
        private _isRadiusAtLimit;
        /**
         * Applies an animation to the radius of the camera, extending by the radiusDelta.
         * @param radiusDelta The delta by which to animate to. Can be negative.
         */
        private _applyBoundRadiusAnimation;
        /**
         * Removes all animation locks. Allows new animations to be added to any of the camera properties.
         */
        protected _clearAnimationLocks(): void;
        /**
         * Stops and removes all animations that have been applied to the camera
         */
        stopAllAnimations(): void;
    }
}
declare module BABYLON {
    /**
     * The framing behavior (FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.
     * @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior
     */
    export class FramingBehavior implements Behavior<ArcRotateCamera> {
        /**
         * Gets the name of the behavior.
         */
        get name(): string;
        private _mode;
        private _radiusScale;
        private _positionScale;
        private _defaultElevation;
        private _elevationReturnTime;
        private _elevationReturnWaitTime;
        private _zoomStopsAnimation;
        private _framingTime;
        /**
         * The easing function used by animations
         */
        static EasingFunction: ExponentialEase;
        /**
         * The easing mode used by animations
         */
        static EasingMode: number;
        /**
         * Sets the current mode used by the behavior
         */
        set mode(mode: number);
        /**
         * Gets current mode used by the behavior.
         */
        get mode(): number;
        /**
         * Sets the scale applied to the radius (1 by default)
         */
        set radiusScale(radius: number);
        /**
         * Gets the scale applied to the radius
         */
        get radiusScale(): number;
        /**
         * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.
         */
        set positionScale(scale: number);
        /**
         * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.
         */
        get positionScale(): number;
        /**
        * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle
        * behaviour is triggered, in radians.
        */
        set defaultElevation(elevation: number);
        /**
        * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle
        * behaviour is triggered, in radians.
        */
        get defaultElevation(): number;
        /**
         * Sets the time (in milliseconds) taken to return to the default beta position.
         * Negative value indicates camera should not return to default.
         */
        set elevationReturnTime(speed: number);
        /**
         * Gets the time (in milliseconds) taken to return to the default beta position.
         * Negative value indicates camera should not return to default.
         */
        get elevationReturnTime(): number;
        /**
         * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.
         */
        set elevationReturnWaitTime(time: number);
        /**
         * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.
         */
        get elevationReturnWaitTime(): number;
        /**
        * Sets the flag that indicates if user zooming should stop animation.
        */
        set zoomStopsAnimation(flag: boolean);
        /**
        * Gets the flag that indicates if user zooming should stop animation.
        */
        get zoomStopsAnimation(): boolean;
        /**
         * Sets the transition time when framing the mesh, in milliseconds
        */
        set framingTime(time: number);
        /**
         * Gets the transition time when framing the mesh, in milliseconds
        */
        get framingTime(): number;
        /**
         * Define if the behavior should automatically change the configured
         * camera limits and sensibilities.
         */
        autoCorrectCameraLimitsAndSensibility: boolean;
        private _onPrePointerObservableObserver;
        private _onAfterCheckInputsObserver;
        private _onMeshTargetChangedObserver;
        private _attachedCamera;
        private _isPointerDown;
        private _lastInteractionTime;
        /**
         * Initializes the behavior.
         */
        init(): void;
        /**
         * Attaches the behavior to its arc rotate camera.
         * @param camera Defines the camera to attach the behavior to
         */
        attach(camera: ArcRotateCamera): void;
        /**
         * Detaches the behavior from its current arc rotate camera.
         */
        detach(): void;
        private _animatables;
        private _betaIsAnimating;
        private _betaTransition;
        private _radiusTransition;
        private _vectorTransition;
        /**
         * Targets the given mesh and updates zoom level accordingly.
         * @param mesh  The mesh to target.
         * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
         * @param onAnimationEnd Callback triggered at the end of the framing animation
         */
        zoomOnMesh(mesh: AbstractMesh, focusOnOriginXZ?: boolean, onAnimationEnd?: Nullable<() => void>): void;
        /**
         * Targets the given mesh with its children and updates zoom level accordingly.
         * @param mesh  The mesh to target.
         * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
         * @param onAnimationEnd Callback triggered at the end of the framing animation
         */
        zoomOnMeshHierarchy(mesh: AbstractMesh, focusOnOriginXZ?: boolean, onAnimationEnd?: Nullable<() => void>): void;
        /**
         * Targets the given meshes with their children and updates zoom level accordingly.
         * @param meshes  The mesh to target.
         * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
         * @param onAnimationEnd Callback triggered at the end of the framing animation
         */
        zoomOnMeshesHierarchy(meshes: AbstractMesh[], focusOnOriginXZ?: boolean, onAnimationEnd?: Nullable<() => void>): void;
        /**
         * Targets the bounding box info defined by its extends and updates zoom level accordingly.
         * @param minimumWorld Determines the smaller position of the bounding box extend
         * @param maximumWorld Determines the bigger position of the bounding box extend
         * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
         * @param onAnimationEnd Callback triggered at the end of the framing animation
         */
        zoomOnBoundingInfo(minimumWorld: Vector3, maximumWorld: Vector3, focusOnOriginXZ?: boolean, onAnimationEnd?: Nullable<() => void>): void;
        /**
         * Calculates the lowest radius for the camera based on the bounding box of the mesh.
         * @param mesh The mesh on which to base the calculation. mesh boundingInfo used to estimate necessary
         *			  frustum width.
         * @return The minimum distance from the primary mesh's center point at which the camera must be kept in order
         *		 to fully enclose the mesh in the viewing frustum.
         */
        protected _calculateLowerRadiusFromModelBoundingSphere(minimumWorld: Vector3, maximumWorld: Vector3): number;
        /**
         * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera
         * is automatically returned to its default position (expected to be above ground plane).
         */
        private _maintainCameraAboveGround;
        /**
         * Returns the frustum slope based on the canvas ratio and camera FOV
         * @returns The frustum slope represented as a Vector2 with X and Y slopes
         */
        private _getFrustumSlope;
        /**
         * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.
         */
        private _clearAnimationLocks;
        /**
         *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.
         */
        private _applyUserInteraction;
        /**
         * Stops and removes all animations that have been applied to the camera
         */
        stopAllAnimations(): void;
        /**
         * Gets a value indicating if the user is moving the camera
         */
        get isUserIsMoving(): boolean;
        /**
         * The camera can move all the way towards the mesh.
         */
        static IgnoreBoundsSizeMode: number;
        /**
         * The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides
         */
        static FitFrustumSidesMode: number;
    }
}
declare module BABYLON {
    /**
     * Base class for Camera Pointer Inputs.
     * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts
     * for example usage.
     */
    export abstract class BaseCameraPointersInput implements ICameraInput<Camera> {
        /**
         * Defines the camera the input is attached to.
         */
        abstract camera: Camera;
        /**
         * Whether keyboard modifier keys are pressed at time of last mouse event.
         */
        protected _altKey: boolean;
        protected _ctrlKey: boolean;
        protected _metaKey: boolean;
        protected _shiftKey: boolean;
        /**
         * Which mouse buttons were pressed at time of last mouse event.
         * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
         */
        protected _buttonsPressed: number;
        /**
         * Defines the buttons associated with the input to handle camera move.
         */
        buttons: number[];
        /**
         * Attach the input controls to a specific dom element to get the input from.
         * @param element Defines the element the controls should be listened from
         * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Detach the current controls from the specified dom element.
         * @param element Defines the element to stop listening the inputs from
         */
        detachControl(element: Nullable<HTMLElement>): void;
        /**
         * Gets the class name of the current input.
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Get the friendly name associated with the input class.
         * @returns the input friendly name
         */
        getSimpleName(): string;
        /**
         * Called on pointer POINTERDOUBLETAP event.
         * Override this method to provide functionality on POINTERDOUBLETAP event.
         */
        protected onDoubleTap(type: string): void;
        /**
         * Called on pointer POINTERMOVE event if only a single touch is active.
         * Override this method to provide functionality.
         */
        protected onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void;
        /**
         * Called on pointer POINTERMOVE event if multiple touches are active.
         * Override this method to provide functionality.
         */
        protected onMultiTouch(pointA: Nullable<PointerTouch>, pointB: Nullable<PointerTouch>, previousPinchSquaredDistance: number, pinchSquaredDistance: number, previousMultiTouchPanPosition: Nullable<PointerTouch>, multiTouchPanPosition: Nullable<PointerTouch>): void;
        /**
         * Called on JS contextmenu event.
         * Override this method to provide functionality.
         */
        protected onContextMenu(evt: PointerEvent): void;
        /**
         * Called each time a new POINTERDOWN event occurs. Ie, for each button
         * press.
         * Override this method to provide functionality.
         */
        protected onButtonDown(evt: PointerEvent): void;
        /**
         * Called each time a new POINTERUP event occurs. Ie, for each button
         * release.
         * Override this method to provide functionality.
         */
        protected onButtonUp(evt: PointerEvent): void;
        /**
         * Called when window becomes inactive.
         * Override this method to provide functionality.
         */
        protected onLostFocus(): void;
        private _pointerInput;
        private _observer;
        private _onLostFocus;
        private pointA;
        private pointB;
    }
}
declare module BABYLON {
    /**
     * Manage the pointers inputs to control an arc rotate camera.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class ArcRotateCameraPointersInput extends BaseCameraPointersInput {
        /**
         * Defines the camera the input is attached to.
         */
        camera: ArcRotateCamera;
        /**
         * Gets the class name of the current input.
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Defines the buttons associated with the input to handle camera move.
         */
        buttons: number[];
        /**
         * Defines the pointer angular sensibility  along the X axis or how fast is
         * the camera rotating.
         */
        angularSensibilityX: number;
        /**
         * Defines the pointer angular sensibility along the Y axis or how fast is
         * the camera rotating.
         */
        angularSensibilityY: number;
        /**
         * Defines the pointer pinch precision or how fast is the camera zooming.
         */
        pinchPrecision: number;
        /**
         * pinchDeltaPercentage will be used instead of pinchPrecision if different
         * from 0.
         * It defines the percentage of current camera.radius to use as delta when
         * pinch zoom is used.
         */
        pinchDeltaPercentage: number;
        /**
         * When useNaturalPinchZoom is true, multi touch zoom will zoom in such
         * that any object in the plane at the camera's target point will scale
         * perfectly with finger motion.
         * Overrides pinchDeltaPercentage and pinchPrecision.
         */
        useNaturalPinchZoom: boolean;
        /**
         * Defines the pointer panning sensibility or how fast is the camera moving.
         */
        panningSensibility: number;
        /**
         * Defines whether panning (2 fingers swipe) is enabled through multitouch.
         */
        multiTouchPanning: boolean;
        /**
         * Defines whether panning is enabled for both pan (2 fingers swipe) and
         * zoom (pinch) through multitouch.
         */
        multiTouchPanAndZoom: boolean;
        /**
         * Revers pinch action direction.
         */
        pinchInwards: boolean;
        private _isPanClick;
        private _twoFingerActivityCount;
        private _isPinching;
        /**
         * Called on pointer POINTERMOVE event if only a single touch is active.
         */
        protected onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void;
        /**
         * Called on pointer POINTERDOUBLETAP event.
         */
        protected onDoubleTap(type: string): void;
        /**
         * Called on pointer POINTERMOVE event if multiple touches are active.
         */
        protected onMultiTouch(pointA: Nullable<PointerTouch>, pointB: Nullable<PointerTouch>, previousPinchSquaredDistance: number, pinchSquaredDistance: number, previousMultiTouchPanPosition: Nullable<PointerTouch>, multiTouchPanPosition: Nullable<PointerTouch>): void;
        /**
         * Called each time a new POINTERDOWN event occurs. Ie, for each button
         * press.
         */
        protected onButtonDown(evt: PointerEvent): void;
        /**
         * Called each time a new POINTERUP event occurs. Ie, for each button
         * release.
         */
        protected onButtonUp(evt: PointerEvent): void;
        /**
         * Called when window becomes inactive.
         */
        protected onLostFocus(): void;
    }
}
declare module BABYLON {
    /**
     * Manage the keyboard inputs to control the movement of an arc rotate camera.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class ArcRotateCameraKeyboardMoveInput implements ICameraInput<ArcRotateCamera> {
        /**
         * Defines the camera the input is attached to.
         */
        camera: ArcRotateCamera;
        /**
         * Defines the list of key codes associated with the up action (increase alpha)
         */
        keysUp: number[];
        /**
         * Defines the list of key codes associated with the down action (decrease alpha)
         */
        keysDown: number[];
        /**
         * Defines the list of key codes associated with the left action (increase beta)
         */
        keysLeft: number[];
        /**
         * Defines the list of key codes associated with the right action (decrease beta)
         */
        keysRight: number[];
        /**
         * Defines the list of key codes associated with the reset action.
         * Those keys reset the camera to its last stored state (with the method camera.storeState())
         */
        keysReset: number[];
        /**
         * Defines the panning sensibility of the inputs.
         * (How fast is the camera panning)
         */
        panningSensibility: number;
        /**
         * Defines the zooming sensibility of the inputs.
         * (How fast is the camera zooming)
         */
        zoomingSensibility: number;
        /**
         * Defines whether maintaining the alt key down switch the movement mode from
         * orientation to zoom.
         */
        useAltToZoom: boolean;
        /**
         * Rotation speed of the camera
         */
        angularSpeed: number;
        private _keys;
        private _ctrlPressed;
        private _altPressed;
        private _onCanvasBlurObserver;
        private _onKeyboardObserver;
        private _engine;
        private _scene;
        /**
         * Attach the input controls to a specific dom element to get the input from.
         * @param element Defines the element the controls should be listened from
         * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Detach the current controls from the specified dom element.
         * @param element Defines the element to stop listening the inputs from
         */
        detachControl(element: Nullable<HTMLElement>): void;
        /**
         * Update the current camera state depending on the inputs that have been used this frame.
         * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
         */
        checkInputs(): void;
        /**
         * Gets the class name of the current intput.
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Get the friendly name associated with the input class.
         * @returns the input friendly name
         */
        getSimpleName(): string;
    }
}
declare module BABYLON {
    /**
     * Manage the mouse wheel inputs to control an arc rotate camera.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class ArcRotateCameraMouseWheelInput implements ICameraInput<ArcRotateCamera> {
        /**
         * Defines the camera the input is attached to.
         */
        camera: ArcRotateCamera;
        /**
         * Gets or Set the mouse wheel precision or how fast is the camera zooming.
         */
        wheelPrecision: number;
        /**
         * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.
         * It defines the percentage of current camera.radius to use as delta when wheel is used.
         */
        wheelDeltaPercentage: number;
        private _wheel;
        private _observer;
        private computeDeltaFromMouseWheelLegacyEvent;
        /**
         * Attach the input controls to a specific dom element to get the input from.
         * @param element Defines the element the controls should be listened from
         * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Detach the current controls from the specified dom element.
         * @param element Defines the element to stop listening the inputs from
         */
        detachControl(element: Nullable<HTMLElement>): void;
        /**
         * Gets the class name of the current intput.
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Get the friendly name associated with the input class.
         * @returns the input friendly name
         */
        getSimpleName(): string;
    }
}
declare module BABYLON {
    /**
     * Default Inputs manager for the ArcRotateCamera.
     * It groups all the default supported inputs for ease of use.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class ArcRotateCameraInputsManager extends CameraInputsManager<ArcRotateCamera> {
        /**
         * Instantiates a new ArcRotateCameraInputsManager.
         * @param camera Defines the camera the inputs belong to
         */
        constructor(camera: ArcRotateCamera);
        /**
         * Add mouse wheel input support to the input manager.
         * @returns the current input manager
         */
        addMouseWheel(): ArcRotateCameraInputsManager;
        /**
         * Add pointers input support to the input manager.
         * @returns the current input manager
         */
        addPointers(): ArcRotateCameraInputsManager;
        /**
         * Add keyboard input support to the input manager.
         * @returns the current input manager
         */
        addKeyboard(): ArcRotateCameraInputsManager;
    }
}
declare module BABYLON {
    /**
     * This represents an orbital type of camera.
     *
     * This camera always points towards a given target position and can be rotated around that target with the target as the centre of rotation. It can be controlled with cursors and mouse, or with touch events.
     * Think of this camera as one orbiting its target position, or more imaginatively as a spy satellite orbiting the earth. Its position relative to the target (earth) can be set by three parameters, alpha (radians) the longitudinal rotation, beta (radians) the latitudinal rotation and radius the distance from the target position.
     * @see https://doc.babylonjs.com/babylon101/cameras#arc-rotate-camera
     */
    export class ArcRotateCamera extends TargetCamera {
        /**
         * Defines the rotation angle of the camera along the longitudinal axis.
         */
        alpha: number;
        /**
         * Defines the rotation angle of the camera along the latitudinal axis.
         */
        beta: number;
        /**
         * Defines the radius of the camera from it s target point.
         */
        radius: number;
        protected _target: Vector3;
        protected _targetHost: Nullable<AbstractMesh>;
        /**
         * Defines the target point of the camera.
         * The camera looks towards it form the radius distance.
         * Please note that you can set the target to a mesh and thus the target will be copied from mesh.position
         */
        get target(): Vector3;
        set target(value: Vector3);
        /**
         * Define the current local position of the camera in the scene
         */
        get position(): Vector3;
        set position(newPosition: Vector3);
        protected _upToYMatrix: Matrix;
        protected _YToUpMatrix: Matrix;
        /**
         * The vector the camera should consider as up. (default is Vector3(0, 1, 0) as returned by Vector3.Up())
         * Setting this will copy the given vector to the camera's upVector, and set rotation matrices to and from Y up.
         * DO NOT set the up vector using copyFrom or copyFromFloats, as this bypasses setting the above matrices.
         */
        set upVector(vec: Vector3);
        get upVector(): Vector3;
        /**
         * Sets the Y-up to camera up-vector rotation matrix, and the up-vector to Y-up rotation matrix.
         */
        setMatUp(): void;
        /**
         * Current inertia value on the longitudinal axis.
         * The bigger this number the longer it will take for the camera to stop.
         */
        inertialAlphaOffset: number;
        /**
         * Current inertia value on the latitudinal axis.
         * The bigger this number the longer it will take for the camera to stop.
         */
        inertialBetaOffset: number;
        /**
         * Current inertia value on the radius axis.
         * The bigger this number the longer it will take for the camera to stop.
         */
        inertialRadiusOffset: number;
        /**
         * Minimum allowed angle on the longitudinal axis.
         * This can help limiting how the Camera is able to move in the scene.
         */
        lowerAlphaLimit: Nullable<number>;
        /**
         * Maximum allowed angle on the longitudinal axis.
         * This can help limiting how the Camera is able to move in the scene.
         */
        upperAlphaLimit: Nullable<number>;
        /**
         * Minimum allowed angle on the latitudinal axis.
         * This can help limiting how the Camera is able to move in the scene.
         */
        lowerBetaLimit: number;
        /**
         * Maximum allowed angle on the latitudinal axis.
         * This can help limiting how the Camera is able to move in the scene.
         */
        upperBetaLimit: number;
        /**
         * Minimum allowed distance of the camera to the target (The camera can not get closer).
         * This can help limiting how the Camera is able to move in the scene.
         */
        lowerRadiusLimit: Nullable<number>;
        /**
         * Maximum allowed distance of the camera to the target (The camera can not get further).
         * This can help limiting how the Camera is able to move in the scene.
         */
        upperRadiusLimit: Nullable<number>;
        /**
         * Defines the current inertia value used during panning of the camera along the X axis.
         */
        inertialPanningX: number;
        /**
         * Defines the current inertia value used during panning of the camera along the Y axis.
         */
        inertialPanningY: number;
        /**
         * Defines the distance used to consider the camera in pan mode vs pinch/zoom.
         * Basically if your fingers moves away from more than this distance you will be considered
         * in pinch mode.
         */
        pinchToPanMaxDistance: number;
        /**
         * Defines the maximum distance the camera can pan.
         * This could help keeping the cammera always in your scene.
         */
        panningDistanceLimit: Nullable<number>;
        /**
         * Defines the target of the camera before paning.
         */
        panningOriginTarget: Vector3;
        /**
         * Defines the value of the inertia used during panning.
         * 0 would mean stop inertia and one would mean no decelleration at all.
         */
        panningInertia: number;
        /**
         * Gets or Set the pointer angular sensibility  along the X axis or how fast is the camera rotating.
         */
        get angularSensibilityX(): number;
        set angularSensibilityX(value: number);
        /**
         * Gets or Set the pointer angular sensibility along the Y axis or how fast is the camera rotating.
         */
        get angularSensibilityY(): number;
        set angularSensibilityY(value: number);
        /**
         * Gets or Set the pointer pinch precision or how fast is the camera zooming.
         */
        get pinchPrecision(): number;
        set pinchPrecision(value: number);
        /**
         * Gets or Set the pointer pinch delta percentage or how fast is the camera zooming.
         * It will be used instead of pinchDeltaPrecision if different from 0.
         * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.
         */
        get pinchDeltaPercentage(): number;
        set pinchDeltaPercentage(value: number);
        /**
         * Gets or Set the pointer use natural pinch zoom to override the pinch precision
         * and pinch delta percentage.
         * When useNaturalPinchZoom is true, multi touch zoom will zoom in such
         * that any object in the plane at the camera's target point will scale
         * perfectly with finger motion.
         */
        get useNaturalPinchZoom(): boolean;
        set useNaturalPinchZoom(value: boolean);
        /**
         * Gets or Set the pointer panning sensibility or how fast is the camera moving.
         */
        get panningSensibility(): number;
        set panningSensibility(value: number);
        /**
         * Gets or Set the list of keyboard keys used to control beta angle in a positive direction.
         */
        get keysUp(): number[];
        set keysUp(value: number[]);
        /**
         * Gets or Set the list of keyboard keys used to control beta angle in a negative direction.
         */
        get keysDown(): number[];
        set keysDown(value: number[]);
        /**
         * Gets or Set the list of keyboard keys used to control alpha angle in a negative direction.
         */
        get keysLeft(): number[];
        set keysLeft(value: number[]);
        /**
         * Gets or Set the list of keyboard keys used to control alpha angle in a positive direction.
         */
        get keysRight(): number[];
        set keysRight(value: number[]);
        /**
         * Gets or Set the mouse wheel precision or how fast is the camera zooming.
         */
        get wheelPrecision(): number;
        set wheelPrecision(value: number);
        /**
         * Gets or Set the mouse wheel delta percentage or how fast is the camera zooming.
         * It will be used instead of pinchDeltaPrecision if different from 0.
         * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.
         */
        get wheelDeltaPercentage(): number;
        set wheelDeltaPercentage(value: number);
        /**
         * Defines how much the radius should be scaled while zomming on a particular mesh (through the zoomOn function)
         */
        zoomOnFactor: number;
        /**
         * Defines a screen offset for the camera position.
         */
        targetScreenOffset: Vector2;
        /**
         * Allows the camera to be completely reversed.
         * If false the camera can not arrive upside down.
         */
        allowUpsideDown: boolean;
        /**
         * Define if double tap/click is used to restore the previously saved state of the camera.
         */
        useInputToRestoreState: boolean;
        /** @hidden */
        _viewMatrix: Matrix;
        /** @hidden */
        _useCtrlForPanning: boolean;
        /** @hidden */
        _panningMouseButton: number;
        /**
         * Defines the input associated to the camera.
         */
        inputs: ArcRotateCameraInputsManager;
        /** @hidden */
        _reset: () => void;
        /**
         * Defines the allowed panning axis.
         */
        panningAxis: Vector3;
        protected _localDirection: Vector3;
        protected _transformedDirection: Vector3;
        private _bouncingBehavior;
        /**
         * Gets the bouncing behavior of the camera if it has been enabled.
         * @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior
         */
        get bouncingBehavior(): Nullable<BouncingBehavior>;
        /**
         * Defines if the bouncing behavior of the camera is enabled on the camera.
         * @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior
         */
        get useBouncingBehavior(): boolean;
        set useBouncingBehavior(value: boolean);
        private _framingBehavior;
        /**
         * Gets the framing behavior of the camera if it has been enabled.
         * @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior
         */
        get framingBehavior(): Nullable<FramingBehavior>;
        /**
         * Defines if the framing behavior of the camera is enabled on the camera.
         * @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior
         */
        get useFramingBehavior(): boolean;
        set useFramingBehavior(value: boolean);
        private _autoRotationBehavior;
        /**
         * Gets the auto rotation behavior of the camera if it has been enabled.
         * @see https://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior
         */
        get autoRotationBehavior(): Nullable<AutoRotationBehavior>;
        /**
         * Defines if the auto rotation behavior of the camera is enabled on the camera.
         * @see https://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior
         */
        get useAutoRotationBehavior(): boolean;
        set useAutoRotationBehavior(value: boolean);
        /**
         * Observable triggered when the mesh target has been changed on the camera.
         */
        onMeshTargetChangedObservable: Observable<Nullable<AbstractMesh>>;
        /**
         * Event raised when the camera is colliding with a mesh.
         */
        onCollide: (collidedMesh: AbstractMesh) => void;
        /**
         * Defines whether the camera should check collision with the objects oh the scene.
         * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#how-can-i-do-this
         */
        checkCollisions: boolean;
        /**
         * Defines the collision radius of the camera.
         * This simulates a sphere around the camera.
         * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#arcrotatecamera
         */
        collisionRadius: Vector3;
        protected _collider: Collider;
        protected _previousPosition: Vector3;
        protected _collisionVelocity: Vector3;
        protected _newPosition: Vector3;
        protected _previousAlpha: number;
        protected _previousBeta: number;
        protected _previousRadius: number;
        protected _collisionTriggered: boolean;
        protected _targetBoundingCenter: Nullable<Vector3>;
        private _computationVector;
        /**
         * Instantiates a new ArcRotateCamera in a given scene
         * @param name Defines the name of the camera
         * @param alpha Defines the camera rotation along the logitudinal axis
         * @param beta Defines the camera rotation along the latitudinal axis
         * @param radius Defines the camera distance from its target
         * @param target Defines the camera target
         * @param scene Defines the scene the camera belongs to
         * @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active if not other active cameras have been defined
         */
        constructor(name: string, alpha: number, beta: number, radius: number, target: Vector3, scene: Scene, setActiveOnSceneIfNoneActive?: boolean);
        /** @hidden */
        _initCache(): void;
        /** @hidden */
        _updateCache(ignoreParentClass?: boolean): void;
        protected _getTargetPosition(): Vector3;
        private _storedAlpha;
        private _storedBeta;
        private _storedRadius;
        private _storedTarget;
        private _storedTargetScreenOffset;
        /**
         * Stores the current state of the camera (alpha, beta, radius and target)
         * @returns the camera itself
         */
        storeState(): Camera;
        /**
         * @hidden
         * Restored camera state. You must call storeState() first
         */
        _restoreStateValues(): boolean;
        /** @hidden */
        _isSynchronizedViewMatrix(): boolean;
        /**
         * Attached controls to the current camera.
         * @param element Defines the element the controls should be listened from
         * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         * @param useCtrlForPanning  Defines whether ctrl is used for paning within the controls
         * @param panningMouseButton Defines whether panning is allowed through mouse click button
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean, useCtrlForPanning?: boolean, panningMouseButton?: number): void;
        /**
         * Detach the current controls from the camera.
         * The camera will stop reacting to inputs.
         * @param element Defines the element to stop listening the inputs from
         */
        detachControl(element: HTMLElement): void;
        /** @hidden */
        _checkInputs(): void;
        protected _checkLimits(): void;
        /**
         * Rebuilds angles (alpha, beta) and radius from the give position and target
         */
        rebuildAnglesAndRadius(): void;
        /**
         * Use a position to define the current camera related information like alpha, beta and radius
         * @param position Defines the position to set the camera at
         */
        setPosition(position: Vector3): void;
        /**
         * Defines the target the camera should look at.
         * This will automatically adapt alpha beta and radius to fit within the new target.
         * @param target Defines the new target as a Vector or a mesh
         * @param toBoundingCenter In case of a mesh target, defines whether to target the mesh position or its bounding information center
         * @param allowSamePosition If false, prevents reapplying the new computed position if it is identical to the current one (optim)
         */
        setTarget(target: AbstractMesh | Vector3, toBoundingCenter?: boolean, allowSamePosition?: boolean): void;
        /** @hidden */
        _getViewMatrix(): Matrix;
        protected _onCollisionPositionChange: (collisionId: number, newPosition: Vector3, collidedMesh?: Nullable<AbstractMesh>) => void;
        /**
         * Zooms on a mesh to be at the min distance where we could see it fully in the current viewport.
         * @param meshes Defines the mesh to zoom on
         * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)
         */
        zoomOn(meshes?: AbstractMesh[], doNotUpdateMaxZ?: boolean): void;
        /**
         * Focus on a mesh or a bounding box. This adapts the target and maxRadius if necessary but does not update the current radius.
         * The target will be changed but the radius
         * @param meshesOrMinMaxVectorAndDistance Defines the mesh or bounding info to focus on
         * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)
         */
        focusOn(meshesOrMinMaxVectorAndDistance: AbstractMesh[] | {
            min: Vector3;
            max: Vector3;
            distance: number;
        }, doNotUpdateMaxZ?: boolean): void;
        /**
         * @override
         * Override Camera.createRigCamera
         */
        createRigCamera(name: string, cameraIndex: number): Camera;
        /**
         * @hidden
         * @override
         * Override Camera._updateRigCameras
         */
        _updateRigCameras(): void;
        /**
         * Destroy the camera and release the current resources hold by it.
         */
        dispose(): void;
        /**
         * Gets the current object class name.
         * @return the class name
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /**
     * The autoRotation behavior (AutoRotationBehavior) is designed to create a smooth rotation of an ArcRotateCamera when there is no user interaction.
     * @see https://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior
     */
    export class AutoRotationBehavior implements Behavior<ArcRotateCamera> {
        /**
         * Gets the name of the behavior.
         */
        get name(): string;
        private _zoomStopsAnimation;
        private _idleRotationSpeed;
        private _idleRotationWaitTime;
        private _idleRotationSpinupTime;
        /**
        * Sets the flag that indicates if user zooming should stop animation.
        */
        set zoomStopsAnimation(flag: boolean);
        /**
        * Gets the flag that indicates if user zooming should stop animation.
        */
        get zoomStopsAnimation(): boolean;
        /**
        * Sets the default speed at which the camera rotates around the model.
        */
        set idleRotationSpeed(speed: number);
        /**
        * Gets the default speed at which the camera rotates around the model.
        */
        get idleRotationSpeed(): number;
        /**
        * Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.
        */
        set idleRotationWaitTime(time: number);
        /**
        * Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.
        */
        get idleRotationWaitTime(): number;
        /**
        * Sets the time (milliseconds) to take to spin up to the full idle rotation speed.
        */
        set idleRotationSpinupTime(time: number);
        /**
        * Gets the time (milliseconds) to take to spin up to the full idle rotation speed.
        */
        get idleRotationSpinupTime(): number;
        /**
         * Gets a value indicating if the camera is currently rotating because of this behavior
         */
        get rotationInProgress(): boolean;
        private _onPrePointerObservableObserver;
        private _onAfterCheckInputsObserver;
        private _attachedCamera;
        private _isPointerDown;
        private _lastFrameTime;
        private _lastInteractionTime;
        private _cameraRotationSpeed;
        /**
         * Initializes the behavior.
         */
        init(): void;
        /**
         * Attaches the behavior to its arc rotate camera.
         * @param camera Defines the camera to attach the behavior to
         */
        attach(camera: ArcRotateCamera): void;
        /**
         * Detaches the behavior from its current arc rotate camera.
         */
        detach(): void;
        /**
         * Returns true if user is scrolling.
         * @return true if user is scrolling.
         */
        private _userIsZooming;
        private _lastFrameRadius;
        private _shouldAnimationStopForInteraction;
        /**
         *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.
         */
        private _applyUserInteraction;
        private _userIsMoving;
    }
}
declare module BABYLON {
    /**
     * A behavior that when attached to a mesh will will place a specified node on the meshes face pointing towards the camera
     */
    export class AttachToBoxBehavior implements Behavior<Mesh> {
        private ui;
        /**
         *  The name of the behavior
         */
        name: string;
        /**
         * The distance away from the face of the mesh that the UI should be attached to (default: 0.15)
         */
        distanceAwayFromFace: number;
        /**
         * The distance from the bottom of the face that the UI should be attached to (default: 0.15)
         */
        distanceAwayFromBottomOfFace: number;
        private _faceVectors;
        private _target;
        private _scene;
        private _onRenderObserver;
        private _tmpMatrix;
        private _tmpVector;
        /**
         * Creates the AttachToBoxBehavior, used to attach UI to the closest face of the box to a camera
         * @param ui The transform node that should be attched to the mesh
         */
        constructor(ui: TransformNode);
        /**
         *  Initializes the behavior
         */
        init(): void;
        private _closestFace;
        private _zeroVector;
        private _lookAtTmpMatrix;
        private _lookAtToRef;
        /**
         * Attaches the AttachToBoxBehavior to the passed in mesh
         * @param target The mesh that the specified node will be attached to
         */
        attach(target: Mesh): void;
        /**
         *  Detaches the behavior from the mesh
         */
        detach(): void;
    }
}
declare module BABYLON {
    /**
     * A behavior that when attached to a mesh will allow the mesh to fade in and out
     */
    export class FadeInOutBehavior implements Behavior<Mesh> {
        /**
         * Time in milliseconds to delay before fading in (Default: 0)
         */
        delay: number;
        /**
         * Time in milliseconds for the mesh to fade in (Default: 300)
         */
        fadeInTime: number;
        private _millisecondsPerFrame;
        private _hovered;
        private _hoverValue;
        private _ownerNode;
        /**
         * Instatiates the FadeInOutBehavior
         */
        constructor();
        /**
         *  The name of the behavior
         */
        get name(): string;
        /**
         *  Initializes the behavior
         */
        init(): void;
        /**
         * Attaches the fade behavior on the passed in mesh
         * @param ownerNode The mesh that will be faded in/out once attached
         */
        attach(ownerNode: Mesh): void;
        /**
         *  Detaches the behavior from the mesh
         */
        detach(): void;
        /**
         * Triggers the mesh to begin fading in or out
         * @param value if the object should fade in or out (true to fade in)
         */
        fadeIn(value: boolean): void;
        private _update;
        private _setAllVisibility;
    }
}
declare module BABYLON {
    /**
     * Class containing a set of static utilities functions for managing Pivots
     * @hidden
     */
    export class PivotTools {
        private static _PivotCached;
        private static _OldPivotPoint;
        private static _PivotTranslation;
        private static _PivotTmpVector;
        private static _PivotPostMultiplyPivotMatrix;
        /** @hidden */
        static _RemoveAndStorePivotPoint(mesh: AbstractMesh): void;
        /** @hidden */
        static _RestorePivotPoint(mesh: AbstractMesh): void;
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class PlaneBuilder {
        /**
         * Creates a plane mesh
         * * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)
         * * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value of `size`)
         * * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the plane mesh
         * @see https://doc.babylonjs.com/how_to/set_shapes#plane
         */
        static CreatePlane(name: string, options: {
            size?: number;
            width?: number;
            height?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            updatable?: boolean;
            sourcePlane?: Plane;
        }, scene?: Nullable<Scene>): Mesh;
    }
}
declare module BABYLON {
    /**
     * A behavior that when attached to a mesh will allow the mesh to be dragged around the screen based on pointer events
     */
    export class PointerDragBehavior implements Behavior<AbstractMesh> {
        private static _AnyMouseID;
        /**
         * Abstract mesh the behavior is set on
         */
        attachedNode: AbstractMesh;
        private _dragPlane;
        private _scene;
        private _pointerObserver;
        private _beforeRenderObserver;
        private static _planeScene;
        private _useAlternatePickedPointAboveMaxDragAngleDragSpeed;
        /**
         * The maximum tolerated angle between the drag plane and dragging pointer rays to trigger pointer events. Set to 0 to allow any angle (default: 0)
         */
        maxDragAngle: number;
        /**
         * @hidden
         */
        _useAlternatePickedPointAboveMaxDragAngle: boolean;
        /**
         * The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)
         */
        currentDraggingPointerID: number;
        /**
         * The last position where the pointer hit the drag plane in world space
         */
        lastDragPosition: Vector3;
        /**
         * If the behavior is currently in a dragging state
         */
        dragging: boolean;
        /**
         * The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)
         */
        dragDeltaRatio: number;
        /**
         * If the drag plane orientation should be updated during the dragging (Default: true)
         */
        updateDragPlane: boolean;
        private _debugMode;
        private _moving;
        /**
         *  Fires each time the attached mesh is dragged with the pointer
         *  * delta between last drag position and current drag position in world space
         *  * dragDistance along the drag axis
         *  * dragPlaneNormal normal of the current drag plane used during the drag
         *  * dragPlanePoint in world space where the drag intersects the drag plane
         */
        onDragObservable: Observable<{
            delta: Vector3;
            dragPlanePoint: Vector3;
            dragPlaneNormal: Vector3;
            dragDistance: number;
            pointerId: number;
        }>;
        /**
         *  Fires each time a drag begins (eg. mouse down on mesh)
         */
        onDragStartObservable: Observable<{
            dragPlanePoint: Vector3;
            pointerId: number;
        }>;
        /**
         *  Fires each time a drag ends (eg. mouse release after drag)
         */
        onDragEndObservable: Observable<{
            dragPlanePoint: Vector3;
            pointerId: number;
        }>;
        /**
         *  If the attached mesh should be moved when dragged
         */
        moveAttached: boolean;
        /**
         *  If the drag behavior will react to drag events (Default: true)
         */
        enabled: boolean;
        /**
         * If pointer events should start and release the drag (Default: true)
         */
        startAndReleaseDragOnPointerEvents: boolean;
        /**
         * If camera controls should be detached during the drag
         */
        detachCameraControls: boolean;
        /**
         * If set, the drag plane/axis will be rotated based on the attached mesh's world rotation (Default: true)
         */
        useObjectOrientationForDragging: boolean;
        private _options;
        /**
         * Gets the options used by the behavior
         */
        get options(): {
            dragAxis?: Vector3;
            dragPlaneNormal?: Vector3;
        };
        /**
         * Sets the options used by the behavior
         */
        set options(options: {
            dragAxis?: Vector3;
            dragPlaneNormal?: Vector3;
        });
        /**
         * Creates a pointer drag behavior that can be attached to a mesh
         * @param options The drag axis or normal of the plane that will be dragged across. If no options are specified the drag plane will always face the ray's origin (eg. camera)
         */
        constructor(options?: {
            dragAxis?: Vector3;
            dragPlaneNormal?: Vector3;
        });
        /**
         * Predicate to determine if it is valid to move the object to a new position when it is moved
         */
        validateDrag: (targetPosition: Vector3) => boolean;
        /**
         *  The name of the behavior
         */
        get name(): string;
        /**
         *  Initializes the behavior
         */
        init(): void;
        private _tmpVector;
        private _alternatePickedPoint;
        private _worldDragAxis;
        private _targetPosition;
        private _attachedElement;
        /**
         * Attaches the drag behavior the passed in mesh
         * @param ownerNode The mesh that will be dragged around once attached
         * @param predicate Predicate to use for pick filtering
         */
        attach(ownerNode: AbstractMesh, predicate?: (m: AbstractMesh) => boolean): void;
        /**
         * Force relase the drag action by code.
         */
        releaseDrag(): void;
        private _startDragRay;
        private _lastPointerRay;
        /**
         * Simulates the start of a pointer drag event on the behavior
         * @param pointerId pointerID of the pointer that should be simulated (Default: Any mouse pointer ID)
         * @param fromRay initial ray of the pointer to be simulated (Default: Ray from camera to attached mesh)
         * @param startPickedPoint picked point of the pointer to be simulated (Default: attached mesh position)
         */
        startDrag(pointerId?: number, fromRay?: Ray, startPickedPoint?: Vector3): void;
        protected _startDrag(pointerId: number, fromRay?: Ray, startPickedPoint?: Vector3): void;
        private _dragDelta;
        protected _moveDrag(ray: Ray): void;
        private _pickWithRayOnDragPlane;
        private _pointA;
        private _pointC;
        private _localAxis;
        private _lookAt;
        private _updateDragPlanePosition;
        /**
         *  Detaches the behavior from the mesh
         */
        detach(): void;
    }
}
declare module BABYLON {
    /**
     * A behavior that when attached to a mesh will allow the mesh to be scaled
     */
    export class MultiPointerScaleBehavior implements Behavior<Mesh> {
        private _dragBehaviorA;
        private _dragBehaviorB;
        private _startDistance;
        private _initialScale;
        private _targetScale;
        private _ownerNode;
        private _sceneRenderObserver;
        /**
         * Instantiate a new behavior that when attached to a mesh will allow the mesh to be scaled
         */
        constructor();
        /**
         *  The name of the behavior
         */
        get name(): string;
        /**
         *  Initializes the behavior
         */
        init(): void;
        private _getCurrentDistance;
        /**
         * Attaches the scale behavior the passed in mesh
         * @param ownerNode The mesh that will be scaled around once attached
         */
        attach(ownerNode: Mesh): void;
        /**
         *  Detaches the behavior from the mesh
         */
        detach(): void;
    }
}
declare module BABYLON {
    /**
     * A behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray
     */
    export class SixDofDragBehavior implements Behavior<Mesh> {
        private static _virtualScene;
        private _ownerNode;
        private _sceneRenderObserver;
        private _scene;
        private _targetPosition;
        private _virtualOriginMesh;
        private _virtualDragMesh;
        private _pointerObserver;
        private _moving;
        private _startingOrientation;
        private _attachedElement;
        /**
         * How much faster the object should move when the controller is moving towards it. This is useful to bring objects that are far away from the user to them faster. Set this to 0 to avoid any speed increase. (Default: 3)
         */
        private zDragFactor;
        /**
         * If the object should rotate to face the drag origin
         */
        rotateDraggedObject: boolean;
        /**
         * If the behavior is currently in a dragging state
         */
        dragging: boolean;
        /**
         * The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)
         */
        dragDeltaRatio: number;
        /**
         * The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)
         */
        currentDraggingPointerID: number;
        /**
         * If camera controls should be detached during the drag
         */
        detachCameraControls: boolean;
        /**
         * Fires each time a drag starts
         */
        onDragStartObservable: Observable<{}>;
        /**
         *  Fires each time a drag ends (eg. mouse release after drag)
         */
        onDragEndObservable: Observable<{}>;
        /**
         * Instantiates a behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray
         */
        constructor();
        /**
         *  The name of the behavior
         */
        get name(): string;
        /**
         *  Initializes the behavior
         */
        init(): void;
        /**
         * In the case of multiplea active cameras, the cameraToUseForPointers should be used if set instead of active camera
         */
        private get _pointerCamera();
        /**
         * Attaches the scale behavior the passed in mesh
         * @param ownerNode The mesh that will be scaled around once attached
         */
        attach(ownerNode: Mesh): void;
        /**
         *  Detaches the behavior from the mesh
         */
        detach(): void;
    }
}
declare module BABYLON {
    /**
     * Class used to apply inverse kinematics to bones
     * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons#boneikcontroller
     */
    export class BoneIKController {
        private static _tmpVecs;
        private static _tmpQuat;
        private static _tmpMats;
        /**
         * Gets or sets the target mesh
         */
        targetMesh: AbstractMesh;
        /** Gets or sets the mesh used as pole */
        poleTargetMesh: AbstractMesh;
        /**
         * Gets or sets the bone used as pole
         */
        poleTargetBone: Nullable<Bone>;
        /**
         * Gets or sets the target position
         */
        targetPosition: Vector3;
        /**
         * Gets or sets the pole target position
         */
        poleTargetPosition: Vector3;
        /**
         * Gets or sets the pole target local offset
         */
        poleTargetLocalOffset: Vector3;
        /**
         * Gets or sets the pole angle
         */
        poleAngle: number;
        /**
         * Gets or sets the mesh associated with the controller
         */
        mesh: AbstractMesh;
        /**
         * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)
         */
        slerpAmount: number;
        private _bone1Quat;
        private _bone1Mat;
        private _bone2Ang;
        private _bone1;
        private _bone2;
        private _bone1Length;
        private _bone2Length;
        private _maxAngle;
        private _maxReach;
        private _rightHandedSystem;
        private _bendAxis;
        private _slerping;
        private _adjustRoll;
        /**
         * Gets or sets maximum allowed angle
         */
        get maxAngle(): number;
        set maxAngle(value: number);
        /**
         * Creates a new BoneIKController
         * @param mesh defines the mesh to control
         * @param bone defines the bone to control
         * @param options defines options to set up the controller
         */
        constructor(mesh: AbstractMesh, bone: Bone, options?: {
            targetMesh?: AbstractMesh;
            poleTargetMesh?: AbstractMesh;
            poleTargetBone?: Bone;
            poleTargetLocalOffset?: Vector3;
            poleAngle?: number;
            bendAxis?: Vector3;
            maxAngle?: number;
            slerpAmount?: number;
        });
        private _setMaxAngle;
        /**
         * Force the controller to update the bones
         */
        update(): void;
    }
}
declare module BABYLON {
    /**
     * Class used to make a bone look toward a point in space
     * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons#bonelookcontroller
     */
    export class BoneLookController {
        private static _tmpVecs;
        private static _tmpQuat;
        private static _tmpMats;
        /**
         * The target Vector3 that the bone will look at
         */
        target: Vector3;
        /**
         * The mesh that the bone is attached to
         */
        mesh: AbstractMesh;
        /**
         * The bone that will be looking to the target
         */
        bone: Bone;
        /**
         * The up axis of the coordinate system that is used when the bone is rotated
         */
        upAxis: Vector3;
        /**
         * The space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD
         */
        upAxisSpace: Space;
        /**
         * Used to make an adjustment to the yaw of the bone
         */
        adjustYaw: number;
        /**
         * Used to make an adjustment to the pitch of the bone
         */
        adjustPitch: number;
        /**
         * Used to make an adjustment to the roll of the bone
         */
        adjustRoll: number;
        /**
         * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)
         */
        slerpAmount: number;
        private _minYaw;
        private _maxYaw;
        private _minPitch;
        private _maxPitch;
        private _minYawSin;
        private _minYawCos;
        private _maxYawSin;
        private _maxYawCos;
        private _midYawConstraint;
        private _minPitchTan;
        private _maxPitchTan;
        private _boneQuat;
        private _slerping;
        private _transformYawPitch;
        private _transformYawPitchInv;
        private _firstFrameSkipped;
        private _yawRange;
        private _fowardAxis;
        /**
         * Gets or sets the minimum yaw angle that the bone can look to
         */
        get minYaw(): number;
        set minYaw(value: number);
        /**
         * Gets or sets the maximum yaw angle that the bone can look to
         */
        get maxYaw(): number;
        set maxYaw(value: number);
        /**
         * Gets or sets the minimum pitch angle that the bone can look to
         */
        get minPitch(): number;
        set minPitch(value: number);
        /**
         * Gets or sets the maximum pitch angle that the bone can look to
         */
        get maxPitch(): number;
        set maxPitch(value: number);
        /**
         * Create a BoneLookController
         * @param mesh the mesh that the bone belongs to
         * @param bone the bone that will be looking to the target
         * @param target the target Vector3 to look at
         * @param options optional settings:
         * * maxYaw: the maximum angle the bone will yaw to
         * * minYaw: the minimum angle the bone will yaw to
         * * maxPitch: the maximum angle the bone will pitch to
         * * minPitch: the minimum angle the bone will yaw to
         * * slerpAmount: set the between 0 and 1 to make the bone slerp to the target.
         * * upAxis: the up axis of the coordinate system
         * * upAxisSpace: the space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD.
         * * yawAxis: set yawAxis if the bone does not yaw on the y axis
         * * pitchAxis: set pitchAxis if the bone does not pitch on the x axis
         * * adjustYaw: used to make an adjustment to the yaw of the bone
         * * adjustPitch: used to make an adjustment to the pitch of the bone
         * * adjustRoll: used to make an adjustment to the roll of the bone
         **/
        constructor(mesh: AbstractMesh, bone: Bone, target: Vector3, options?: {
            maxYaw?: number;
            minYaw?: number;
            maxPitch?: number;
            minPitch?: number;
            slerpAmount?: number;
            upAxis?: Vector3;
            upAxisSpace?: Space;
            yawAxis?: Vector3;
            pitchAxis?: Vector3;
            adjustYaw?: number;
            adjustPitch?: number;
            adjustRoll?: number;
        });
        /**
         * Update the bone to look at the target.  This should be called before the scene is rendered (use scene.registerBeforeRender())
         */
        update(): void;
        private _getAngleDiff;
        private _getAngleBetween;
        private _isAngleBetween;
    }
}
declare module BABYLON {
    /**
     * Manage the gamepad inputs to control an arc rotate camera.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class ArcRotateCameraGamepadInput implements ICameraInput<ArcRotateCamera> {
        /**
         * Defines the camera the input is attached to.
         */
        camera: ArcRotateCamera;
        /**
         * Defines the gamepad the input is gathering event from.
         */
        gamepad: Nullable<Gamepad>;
        /**
         * Defines the gamepad rotation sensiblity.
         * This is the threshold from when rotation starts to be accounted for to prevent jittering.
         */
        gamepadRotationSensibility: number;
        /**
         * Defines the gamepad move sensiblity.
         * This is the threshold from when moving starts to be accounted for for to prevent jittering.
         */
        gamepadMoveSensibility: number;
        private _yAxisScale;
        /**
         * Gets or sets a boolean indicating that Yaxis (for right stick) should be inverted
         */
        get invertYAxis(): boolean;
        set invertYAxis(value: boolean);
        private _onGamepadConnectedObserver;
        private _onGamepadDisconnectedObserver;
        /**
         * Attach the input controls to a specific dom element to get the input from.
         * @param element Defines the element the controls should be listened from
         * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Detach the current controls from the specified dom element.
         * @param element Defines the element to stop listening the inputs from
         */
        detachControl(element: Nullable<HTMLElement>): void;
        /**
         * Update the current camera state depending on the inputs that have been used this frame.
         * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
         */
        checkInputs(): void;
        /**
         * Gets the class name of the current intput.
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Get the friendly name associated with the input class.
         * @returns the input friendly name
         */
        getSimpleName(): string;
    }
}
declare module BABYLON {
        interface ArcRotateCameraInputsManager {
            /**
             * Add orientation input support to the input manager.
             * @returns the current input manager
             */
            addVRDeviceOrientation(): ArcRotateCameraInputsManager;
        }
    /**
     * Manage the device orientation inputs (gyroscope) to control an arc rotate camera.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class ArcRotateCameraVRDeviceOrientationInput implements ICameraInput<ArcRotateCamera> {
        /**
         * Defines the camera the input is attached to.
         */
        camera: ArcRotateCamera;
        /**
         * Defines a correction factor applied on the alpha value retrieved from the orientation events.
         */
        alphaCorrection: number;
        /**
         * Defines a correction factor applied on the gamma value retrieved from the orientation events.
         */
        gammaCorrection: number;
        private _alpha;
        private _gamma;
        private _dirty;
        private _deviceOrientationHandler;
        /**
         * Instantiate a new ArcRotateCameraVRDeviceOrientationInput.
         */
        constructor();
        /**
         * Attach the input controls to a specific dom element to get the input from.
         * @param element Defines the element the controls should be listened from
         * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /** @hidden */
        _onOrientationEvent(evt: DeviceOrientationEvent): void;
        /**
         * Update the current camera state depending on the inputs that have been used this frame.
         * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
         */
        checkInputs(): void;
        /**
         * Detach the current controls from the specified dom element.
         * @param element Defines the element to stop listening the inputs from
         */
        detachControl(element: Nullable<HTMLElement>): void;
        /**
         * Gets the class name of the current intput.
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Get the friendly name associated with the input class.
         * @returns the input friendly name
         */
        getSimpleName(): string;
    }
}
declare module BABYLON {
    /**
     * Listen to mouse events to control the camera.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class FlyCameraMouseInput implements ICameraInput<FlyCamera> {
        /**
         * Defines the camera the input is attached to.
         */
        camera: FlyCamera;
        /**
         * Defines if touch is enabled. (Default is true.)
         */
        touchEnabled: boolean;
        /**
         * Defines the buttons associated with the input to handle camera rotation.
         */
        buttons: number[];
        /**
         * Assign buttons for Yaw control.
         */
        buttonsYaw: number[];
        /**
        * Assign buttons for Pitch control.
        */
        buttonsPitch: number[];
        /**
        * Assign buttons for Roll control.
        */
        buttonsRoll: number[];
        /**
         * Detect if any button is being pressed while mouse is moved.
         * -1 = Mouse locked.
         * 0 = Left button.
         * 1 = Middle Button.
         * 2 = Right Button.
         */
        activeButton: number;
        /**
         * Defines the pointer's angular sensibility, to control the camera rotation speed.
         * Higher values reduce its sensitivity.
         */
        angularSensibility: number;
        private _mousemoveCallback;
        private _observer;
        private _rollObserver;
        private previousPosition;
        private noPreventDefault;
        private element;
        /**
         * Listen to mouse events to control the camera.
         * @param touchEnabled Define if touch is enabled. (Default is true.)
         * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
         */
        constructor(touchEnabled?: boolean);
        /**
         * Attach the mouse control to the HTML DOM element.
         * @param element Defines the element that listens to the input events.
         * @param noPreventDefault Defines whether events caught by the controls should call preventdefault().
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Detach the current controls from the specified dom element.
         * @param element Defines the element to stop listening the inputs from
         */
        detachControl(element: Nullable<HTMLElement>): void;
        /**
         * Gets the class name of the current input.
         * @returns the class name.
         */
        getClassName(): string;
        /**
         * Get the friendly name associated with the input class.
         * @returns the input's friendly name.
         */
        getSimpleName(): string;
        private _pointerInput;
        private _onMouseMove;
        /**
         * Rotate camera by mouse offset.
         */
        private rotateCamera;
    }
}
declare module BABYLON {
    /**
     * Default Inputs manager for the FlyCamera.
     * It groups all the default supported inputs for ease of use.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class FlyCameraInputsManager extends CameraInputsManager<FlyCamera> {
        /**
         * Instantiates a new FlyCameraInputsManager.
         * @param camera Defines the camera the inputs belong to.
         */
        constructor(camera: FlyCamera);
        /**
         * Add keyboard input support to the input manager.
         * @returns the new FlyCameraKeyboardMoveInput().
         */
        addKeyboard(): FlyCameraInputsManager;
        /**
         * Add mouse input support to the input manager.
         * @param touchEnabled Enable touch screen support.
         * @returns the new FlyCameraMouseInput().
         */
        addMouse(touchEnabled?: boolean): FlyCameraInputsManager;
    }
}
declare module BABYLON {
    /**
     * This is a flying camera, designed for 3D movement and rotation in all directions,
     * such as in a 3D Space Shooter or a Flight Simulator.
     */
    export class FlyCamera extends TargetCamera {
        /**
         * Define the collision ellipsoid of the camera.
         * This is helpful for simulating a camera body, like a player's body.
         * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#arcrotatecamera
         */
        ellipsoid: Vector3;
        /**
         * Define an offset for the position of the ellipsoid around the camera.
         * This can be helpful if the camera is attached away from the player's body center,
         * such as at its head.
         */
        ellipsoidOffset: Vector3;
        /**
         * Enable or disable collisions of the camera with the rest of the scene objects.
         */
        checkCollisions: boolean;
        /**
         * Enable or disable gravity on the camera.
         */
        applyGravity: boolean;
        /**
         * Define the current direction the camera is moving to.
         */
        cameraDirection: Vector3;
        /**
         * Define the current local rotation of the camera as a quaternion to prevent Gimbal lock.
         * This overrides and empties cameraRotation.
         */
        rotationQuaternion: Quaternion;
        /**
         * Track Roll to maintain the wanted Rolling when looking around.
         */
        _trackRoll: number;
        /**
        * Slowly correct the Roll to its original value after a Pitch+Yaw rotation.
        */
        rollCorrect: number;
        /**
         * Mimic a banked turn, Rolling the camera when Yawing.
         * It's recommended to use rollCorrect = 10 for faster banking correction.
         */
        bankedTurn: boolean;
        /**
         * Limit in radians for how much Roll banking will add. (Default: 90)
         */
        bankedTurnLimit: number;
        /**
         * Value of 0 disables the banked Roll.
         * Value of 1 is equal to the Yaw angle in radians.
         */
        bankedTurnMultiplier: number;
        /**
         * The inputs manager loads all the input sources, such as keyboard and mouse.
         */
        inputs: FlyCameraInputsManager;
        /**
         * Gets the input sensibility for mouse input.
         * Higher values reduce sensitivity.
         */
        get angularSensibility(): number;
        /**
         * Sets the input sensibility for a mouse input.
         * Higher values reduce sensitivity.
         */
        set angularSensibility(value: number);
        /**
         * Get the keys for camera movement forward.
         */
        get keysForward(): number[];
        /**
        * Set the keys for camera movement forward.
        */
        set keysForward(value: number[]);
        /**
         * Get the keys for camera movement backward.
         */
        get keysBackward(): number[];
        set keysBackward(value: number[]);
        /**
         * Get the keys for camera movement up.
         */
        get keysUp(): number[];
        /**
        * Set the keys for camera movement up.
        */
        set keysUp(value: number[]);
        /**
         * Get the keys for camera movement down.
         */
        get keysDown(): number[];
        /**
        * Set the keys for camera movement down.
        */
        set keysDown(value: number[]);
        /**
         * Get the keys for camera movement left.
         */
        get keysLeft(): number[];
        /**
        * Set the keys for camera movement left.
        */
        set keysLeft(value: number[]);
        /**
         * Set the keys for camera movement right.
         */
        get keysRight(): number[];
        /**
        * Set the keys for camera movement right.
        */
        set keysRight(value: number[]);
        /**
         * Event raised when the camera collides with a mesh in the scene.
         */
        onCollide: (collidedMesh: AbstractMesh) => void;
        private _collider;
        private _needMoveForGravity;
        private _oldPosition;
        private _diffPosition;
        private _newPosition;
        /** @hidden */
        _localDirection: Vector3;
        /** @hidden */
        _transformedDirection: Vector3;
        /**
         * Instantiates a FlyCamera.
         * This is a flying camera, designed for 3D movement and rotation in all directions,
         * such as in a 3D Space Shooter or a Flight Simulator.
         * @param name Define the name of the camera in the scene.
         * @param position Define the starting position of the camera in the scene.
         * @param scene Define the scene the camera belongs to.
         * @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active, if no other camera has been defined as active.
        */
        constructor(name: string, position: Vector3, scene: Scene, setActiveOnSceneIfNoneActive?: boolean);
        /**
         * Attach a control to the HTML DOM element.
         * @param element Defines the element that listens to the input events.
         * @param noPreventDefault Defines whether events caught by the controls should call preventdefault(). https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Detach a control from the HTML DOM element.
         * The camera will stop reacting to that input.
         * @param element Defines the element that listens to the input events.
         */
        detachControl(element: HTMLElement): void;
        private _collisionMask;
        /**
         * Get the mask that the camera ignores in collision events.
         */
        get collisionMask(): number;
        /**
        * Set the mask that the camera ignores in collision events.
        */
        set collisionMask(mask: number);
        /** @hidden */
        _collideWithWorld(displacement: Vector3): void;
        /** @hidden */
        private _onCollisionPositionChange;
        /** @hidden */
        _checkInputs(): void;
        /** @hidden */
        _decideIfNeedsToMove(): boolean;
        /** @hidden */
        _updatePosition(): void;
        /**
         * Restore the Roll to its target value at the rate specified.
         * @param rate - Higher means slower restoring.
         * @hidden
         */
        restoreRoll(rate: number): void;
        /**
         * Destroy the camera and release the current resources held by it.
         */
        dispose(): void;
        /**
         * Get the current object class name.
         * @returns the class name.
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /**
     * Listen to keyboard events to control the camera.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class FlyCameraKeyboardInput implements ICameraInput<FlyCamera> {
        /**
         * Defines the camera the input is attached to.
         */
        camera: FlyCamera;
        /**
         * The list of keyboard keys used to control the forward move of the camera.
         */
        keysForward: number[];
        /**
         * The list of keyboard keys used to control the backward move of the camera.
         */
        keysBackward: number[];
        /**
         * The list of keyboard keys used to control the forward move of the camera.
         */
        keysUp: number[];
        /**
         * The list of keyboard keys used to control the backward move of the camera.
         */
        keysDown: number[];
        /**
         * The list of keyboard keys used to control the right strafe move of the camera.
         */
        keysRight: number[];
        /**
         * The list of keyboard keys used to control the left strafe move of the camera.
         */
        keysLeft: number[];
        private _keys;
        private _onCanvasBlurObserver;
        private _onKeyboardObserver;
        private _engine;
        private _scene;
        /**
         * Attach the input controls to a specific dom element to get the input from.
         * @param element Defines the element the controls should be listened from
         * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Detach the current controls from the specified dom element.
         * @param element Defines the element to stop listening the inputs from
         */
        detachControl(element: Nullable<HTMLElement>): void;
        /**
         * Gets the class name of the current intput.
         * @returns the class name
         */
        getClassName(): string;
        /** @hidden */
        _onLostFocus(e: FocusEvent): void;
        /**
         * Get the friendly name associated with the input class.
         * @returns the input friendly name
         */
        getSimpleName(): string;
        /**
         * Update the current camera state depending on the inputs that have been used this frame.
         * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
         */
        checkInputs(): void;
    }
}
declare module BABYLON {
    /**
     * Manage the mouse wheel inputs to control a follow camera.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class FollowCameraMouseWheelInput implements ICameraInput<FollowCamera> {
        /**
         * Defines the camera the input is attached to.
         */
        camera: FollowCamera;
        /**
         * Moue wheel controls zoom. (Mouse wheel modifies camera.radius value.)
         */
        axisControlRadius: boolean;
        /**
         * Moue wheel controls height. (Mouse wheel modifies camera.heightOffset value.)
         */
        axisControlHeight: boolean;
        /**
         * Moue wheel controls angle. (Mouse wheel modifies camera.rotationOffset value.)
         */
        axisControlRotation: boolean;
        /**
         * Gets or Set the mouse wheel precision or how fast is the camera moves in
         * relation to mouseWheel events.
         */
        wheelPrecision: number;
        /**
         * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.
         * It defines the percentage of current camera.radius to use as delta when wheel is used.
         */
        wheelDeltaPercentage: number;
        private _wheel;
        private _observer;
        /**
         * Attach the input controls to a specific dom element to get the input from.
         * @param element Defines the element the controls should be listened from
         * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Detach the current controls from the specified dom element.
         * @param element Defines the element to stop listening the inputs from
         */
        detachControl(element: Nullable<HTMLElement>): void;
        /**
         * Gets the class name of the current intput.
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Get the friendly name associated with the input class.
         * @returns the input friendly name
         */
        getSimpleName(): string;
    }
}
declare module BABYLON {
    /**
     * Manage the pointers inputs to control an follow camera.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class FollowCameraPointersInput extends BaseCameraPointersInput {
        /**
         * Defines the camera the input is attached to.
         */
        camera: FollowCamera;
        /**
         * Gets the class name of the current input.
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Defines the pointer angular sensibility along the X axis or how fast is
         * the camera rotating.
         * A negative number will reverse the axis direction.
         */
        angularSensibilityX: number;
        /**
         * Defines the pointer angular sensibility along the Y axis or how fast is
         * the camera rotating.
         * A negative number will reverse the axis direction.
         */
        angularSensibilityY: number;
        /**
         * Defines the pointer pinch precision or how fast is the camera zooming.
         * A negative number will reverse the axis direction.
         */
        pinchPrecision: number;
        /**
         * pinchDeltaPercentage will be used instead of pinchPrecision if different
         * from 0.
         * It defines the percentage of current camera.radius to use as delta when
         * pinch zoom is used.
         */
        pinchDeltaPercentage: number;
        /**
         * Pointer X axis controls zoom. (X axis modifies camera.radius value.)
         */
        axisXControlRadius: boolean;
        /**
         * Pointer X axis controls height. (X axis modifies camera.heightOffset value.)
         */
        axisXControlHeight: boolean;
        /**
         * Pointer X axis controls angle. (X axis modifies camera.rotationOffset value.)
         */
        axisXControlRotation: boolean;
        /**
         * Pointer Y axis controls zoom. (Y axis modifies camera.radius value.)
         */
        axisYControlRadius: boolean;
        /**
         * Pointer Y axis controls height. (Y axis modifies camera.heightOffset value.)
         */
        axisYControlHeight: boolean;
        /**
         * Pointer Y axis controls angle. (Y axis modifies camera.rotationOffset value.)
         */
        axisYControlRotation: boolean;
        /**
         * Pinch controls zoom. (Pinch modifies camera.radius value.)
         */
        axisPinchControlRadius: boolean;
        /**
         * Pinch controls height. (Pinch modifies camera.heightOffset value.)
         */
        axisPinchControlHeight: boolean;
        /**
         * Pinch controls angle. (Pinch modifies camera.rotationOffset value.)
         */
        axisPinchControlRotation: boolean;
        /**
         * Log error messages if basic misconfiguration has occurred.
         */
        warningEnable: boolean;
        protected onTouch(pointA: Nullable<PointerTouch>, offsetX: number, offsetY: number): void;
        protected onMultiTouch(pointA: Nullable<PointerTouch>, pointB: Nullable<PointerTouch>, previousPinchSquaredDistance: number, pinchSquaredDistance: number, previousMultiTouchPanPosition: Nullable<PointerTouch>, multiTouchPanPosition: Nullable<PointerTouch>): void;
        private _warningCounter;
        private _warning;
    }
}
declare module BABYLON {
    /**
     * Default Inputs manager for the FollowCamera.
     * It groups all the default supported inputs for ease of use.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class FollowCameraInputsManager extends CameraInputsManager<FollowCamera> {
        /**
         * Instantiates a new FollowCameraInputsManager.
         * @param camera Defines the camera the inputs belong to
         */
        constructor(camera: FollowCamera);
        /**
         * Add keyboard input support to the input manager.
         * @returns the current input manager
         */
        addKeyboard(): FollowCameraInputsManager;
        /**
         * Add mouse wheel input support to the input manager.
         * @returns the current input manager
         */
        addMouseWheel(): FollowCameraInputsManager;
        /**
         * Add pointers input support to the input manager.
         * @returns the current input manager
         */
        addPointers(): FollowCameraInputsManager;
        /**
         * Add orientation input support to the input manager.
         * @returns the current input manager
         */
        addVRDeviceOrientation(): FollowCameraInputsManager;
    }
}
declare module BABYLON {
    /**
     * A follow camera takes a mesh as a target and follows it as it moves. Both a free camera version followCamera and
     * an arc rotate version arcFollowCamera are available.
     * @see https://doc.babylonjs.com/features/cameras#follow-camera
     */
    export class FollowCamera extends TargetCamera {
        /**
         * Distance the follow camera should follow an object at
         */
        radius: number;
        /**
         * Minimum allowed distance of the camera to the axis of rotation
         * (The camera can not get closer).
         * This can help limiting how the Camera is able to move in the scene.
         */
        lowerRadiusLimit: Nullable<number>;
        /**
         * Maximum allowed distance of the camera to the axis of rotation
         * (The camera can not get further).
         * This can help limiting how the Camera is able to move in the scene.
         */
        upperRadiusLimit: Nullable<number>;
        /**
         * Define a rotation offset between the camera and the object it follows
         */
        rotationOffset: number;
        /**
         * Minimum allowed angle to camera position relative to target object.
         * This can help limiting how the Camera is able to move in the scene.
         */
        lowerRotationOffsetLimit: Nullable<number>;
        /**
         * Maximum allowed angle to camera position relative to target object.
         * This can help limiting how the Camera is able to move in the scene.
         */
        upperRotationOffsetLimit: Nullable<number>;
        /**
         * Define a height offset between the camera and the object it follows.
         * It can help following an object from the top (like a car chaing a plane)
         */
        heightOffset: number;
        /**
         * Minimum allowed height of camera position relative to target object.
         * This can help limiting how the Camera is able to move in the scene.
         */
        lowerHeightOffsetLimit: Nullable<number>;
        /**
         * Maximum allowed height of camera position relative to target object.
         * This can help limiting how the Camera is able to move in the scene.
         */
        upperHeightOffsetLimit: Nullable<number>;
        /**
         * Define how fast the camera can accelerate to follow it s target.
         */
        cameraAcceleration: number;
        /**
         * Define the speed limit of the camera following an object.
         */
        maxCameraSpeed: number;
        /**
         * Define the target of the camera.
         */
        lockedTarget: Nullable<AbstractMesh>;
        /**
         * Defines the input associated with the camera.
         */
        inputs: FollowCameraInputsManager;
        /**
         * Instantiates the follow camera.
         * @see https://doc.babylonjs.com/features/cameras#follow-camera
         * @param name Define the name of the camera in the scene
         * @param position Define the position of the camera
         * @param scene Define the scene the camera belong to
         * @param lockedTarget Define the target of the camera
         */
        constructor(name: string, position: Vector3, scene: Scene, lockedTarget?: Nullable<AbstractMesh>);
        private _follow;
        /**
         * Attached controls to the current camera.
         * @param element Defines the element the controls should be listened from
         * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Detach the current controls from the camera.
         * The camera will stop reacting to inputs.
         * @param element Defines the element to stop listening the inputs from
         */
        detachControl(element: HTMLElement): void;
        /** @hidden */
        _checkInputs(): void;
        private _checkLimits;
        /**
         * Gets the camera class name.
         * @returns the class name
         */
        getClassName(): string;
    }
    /**
     * Arc Rotate version of the follow camera.
     * It still follows a Defined mesh but in an Arc Rotate Camera fashion.
     * @see https://doc.babylonjs.com/features/cameras#follow-camera
     */
    export class ArcFollowCamera extends TargetCamera {
        /** The longitudinal angle of the camera */
        alpha: number;
        /** The latitudinal angle of the camera */
        beta: number;
        /** The radius of the camera from its target */
        radius: number;
        private _cartesianCoordinates;
        /** Define the camera target (the mesh it should follow) */
        private _meshTarget;
        /**
         * Instantiates a new ArcFollowCamera
         * @see https://doc.babylonjs.com/features/cameras#follow-camera
         * @param name Define the name of the camera
         * @param alpha Define the rotation angle of the camera around the logitudinal axis
         * @param beta Define the rotation angle of the camera around the elevation axis
         * @param radius Define the radius of the camera from its target point
         * @param target Define the target of the camera
         * @param scene Define the scene the camera belongs to
         */
        constructor(name: string, 
        /** The longitudinal angle of the camera */
        alpha: number, 
        /** The latitudinal angle of the camera */
        beta: number, 
        /** The radius of the camera from its target */
        radius: number, 
        /** Define the camera target (the mesh it should follow) */
        target: Nullable<AbstractMesh>, scene: Scene);
        private _follow;
        /** @hidden */
        _checkInputs(): void;
        /**
         * Returns the class name of the object.
         * It is mostly used internally for serialization purposes.
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /**
     * Manage the keyboard inputs to control the movement of a follow camera.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class FollowCameraKeyboardMoveInput implements ICameraInput<FollowCamera> {
        /**
         * Defines the camera the input is attached to.
         */
        camera: FollowCamera;
        /**
         * Defines the list of key codes associated with the up action (increase heightOffset)
         */
        keysHeightOffsetIncr: number[];
        /**
         * Defines the list of key codes associated with the down action (decrease heightOffset)
         */
        keysHeightOffsetDecr: number[];
        /**
         * Defines whether the Alt modifier key is required to move up/down (alter heightOffset)
         */
        keysHeightOffsetModifierAlt: boolean;
        /**
         * Defines whether the Ctrl modifier key is required to move up/down (alter heightOffset)
         */
        keysHeightOffsetModifierCtrl: boolean;
        /**
         * Defines whether the Shift modifier key is required to move up/down (alter heightOffset)
         */
        keysHeightOffsetModifierShift: boolean;
        /**
         * Defines the list of key codes associated with the left action (increase rotationOffset)
         */
        keysRotationOffsetIncr: number[];
        /**
         * Defines the list of key codes associated with the right action (decrease rotationOffset)
         */
        keysRotationOffsetDecr: number[];
        /**
         * Defines whether the Alt modifier key is required to move left/right (alter rotationOffset)
         */
        keysRotationOffsetModifierAlt: boolean;
        /**
         * Defines whether the Ctrl modifier key is required to move left/right (alter rotationOffset)
         */
        keysRotationOffsetModifierCtrl: boolean;
        /**
         * Defines whether the Shift modifier key is required to move left/right (alter rotationOffset)
         */
        keysRotationOffsetModifierShift: boolean;
        /**
         * Defines the list of key codes associated with the zoom-in action (decrease radius)
         */
        keysRadiusIncr: number[];
        /**
         * Defines the list of key codes associated with the zoom-out action (increase radius)
         */
        keysRadiusDecr: number[];
        /**
         * Defines whether the Alt modifier key is required to zoom in/out (alter radius value)
         */
        keysRadiusModifierAlt: boolean;
        /**
         * Defines whether the Ctrl modifier key is required to zoom in/out (alter radius value)
         */
        keysRadiusModifierCtrl: boolean;
        /**
         * Defines whether the Shift modifier key is required to zoom in/out (alter radius value)
         */
        keysRadiusModifierShift: boolean;
        /**
         * Defines the rate of change of heightOffset.
         */
        heightSensibility: number;
        /**
         * Defines the rate of change of rotationOffset.
         */
        rotationSensibility: number;
        /**
         * Defines the rate of change of radius.
         */
        radiusSensibility: number;
        private _keys;
        private _ctrlPressed;
        private _altPressed;
        private _shiftPressed;
        private _onCanvasBlurObserver;
        private _onKeyboardObserver;
        private _engine;
        private _scene;
        /**
         * Attach the input controls to a specific dom element to get the input from.
         * @param element Defines the element the controls should be listened from
         * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Detach the current controls from the specified dom element.
         * @param element Defines the element to stop listening the inputs from
         */
        detachControl(element: Nullable<HTMLElement>): void;
        /**
         * Update the current camera state depending on the inputs that have been used this frame.
         * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
         */
        checkInputs(): void;
        /**
         * Gets the class name of the current input.
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Get the friendly name associated with the input class.
         * @returns the input friendly name
         */
        getSimpleName(): string;
        /**
         * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to
         * allow modification of the heightOffset value.
         */
        private _modifierHeightOffset;
        /**
         * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to
         * allow modification of the rotationOffset value.
         */
        private _modifierRotationOffset;
        /**
         * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to
         * allow modification of the radius value.
         */
        private _modifierRadius;
    }
}
declare module BABYLON {
        interface FreeCameraInputsManager {
            /**
             * @hidden
             */
            _deviceOrientationInput: Nullable<FreeCameraDeviceOrientationInput>;
            /**
             * Add orientation input support to the input manager.
             * @returns the current input manager
             */
            addDeviceOrientation(): FreeCameraInputsManager;
        }
    /**
     * Takes information about the orientation of the device as reported by the deviceorientation event to orient the camera.
     * Screen rotation is taken into account.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class FreeCameraDeviceOrientationInput implements ICameraInput<FreeCamera> {
        private _camera;
        private _screenOrientationAngle;
        private _constantTranform;
        private _screenQuaternion;
        private _alpha;
        private _beta;
        private _gamma;
        /**
         * Can be used to detect if a device orientation sensor is available on a device
         * @param timeout amount of time in milliseconds to wait for a response from the sensor (default: infinite)
         * @returns a promise that will resolve on orientation change
         */
        static WaitForOrientationChangeAsync(timeout?: number): Promise<unknown>;
        /**
         * @hidden
         */
        _onDeviceOrientationChangedObservable: Observable<void>;
        /**
         * Instantiates a new input
         * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
         */
        constructor();
        /**
         * Define the camera controlled by the input.
         */
        get camera(): FreeCamera;
        set camera(camera: FreeCamera);
        /**
         * Attach the input controls to a specific dom element to get the input from.
         * @param element Defines the element the controls should be listened from
         * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        private _orientationChanged;
        private _deviceOrientation;
        /**
         * Detach the current controls from the specified dom element.
         * @param element Defines the element to stop listening the inputs from
         */
        detachControl(element: Nullable<HTMLElement>): void;
        /**
         * Update the current camera state depending on the inputs that have been used this frame.
         * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
         */
        checkInputs(): void;
        /**
         * Gets the class name of the current intput.
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Get the friendly name associated with the input class.
         * @returns the input friendly name
         */
        getSimpleName(): string;
    }
}
declare module BABYLON {
    /**
     * Manage the gamepad inputs to control a free camera.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class FreeCameraGamepadInput implements ICameraInput<FreeCamera> {
        /**
         * Define the camera the input is attached to.
         */
        camera: FreeCamera;
        /**
         * Define the Gamepad controlling the input
         */
        gamepad: Nullable<Gamepad>;
        /**
         * Defines the gamepad rotation sensiblity.
         * This is the threshold from when rotation starts to be accounted for to prevent jittering.
         */
        gamepadAngularSensibility: number;
        /**
         * Defines the gamepad move sensiblity.
         * This is the threshold from when moving starts to be accounted for for to prevent jittering.
         */
        gamepadMoveSensibility: number;
        private _yAxisScale;
        /**
         * Gets or sets a boolean indicating that Yaxis (for right stick) should be inverted
         */
        get invertYAxis(): boolean;
        set invertYAxis(value: boolean);
        private _onGamepadConnectedObserver;
        private _onGamepadDisconnectedObserver;
        private _cameraTransform;
        private _deltaTransform;
        private _vector3;
        private _vector2;
        /**
         * Attach the input controls to a specific dom element to get the input from.
         * @param element Defines the element the controls should be listened from
         * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Detach the current controls from the specified dom element.
         * @param element Defines the element to stop listening the inputs from
         */
        detachControl(element: Nullable<HTMLElement>): void;
        /**
         * Update the current camera state depending on the inputs that have been used this frame.
         * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
         */
        checkInputs(): void;
        /**
         * Gets the class name of the current intput.
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Get the friendly name associated with the input class.
         * @returns the input friendly name
         */
        getSimpleName(): string;
    }
}
declare module BABYLON {
    /**
     * Defines the potential axis of a Joystick
     */
    export enum JoystickAxis {
        /** X axis */
        X = 0,
        /** Y axis */
        Y = 1,
        /** Z axis */
        Z = 2
    }
    /**
     * Represents the different customization options available
     * for VirtualJoystick
     */
    interface VirtualJoystickCustomizations {
        /**
         * Size of the joystick's puck
         */
        puckSize: number;
        /**
         * Size of the joystick's container
         */
        containerSize: number;
        /**
         * Color of the joystick && puck
         */
        color: string;
        /**
         * Image URL for the joystick's puck
         */
        puckImage?: string;
        /**
         * Image URL for the joystick's container
         */
        containerImage?: string;
        /**
         * Defines the unmoving position of the joystick container
         */
        position?: {
            x: number;
            y: number;
        };
        /**
         * Defines whether or not the joystick container is always visible
         */
        alwaysVisible: boolean;
        /**
         * Defines whether or not to limit the movement of the puck to the joystick's container
         */
        limitToContainer: boolean;
    }
    /**
     * Class used to define virtual joystick (used in touch mode)
     */
    export class VirtualJoystick {
        /**
         * Gets or sets a boolean indicating that left and right values must be inverted
         */
        reverseLeftRight: boolean;
        /**
         * Gets or sets a boolean indicating that up and down values must be inverted
         */
        reverseUpDown: boolean;
        /**
         * Gets the offset value for the position (ie. the change of the position value)
         */
        deltaPosition: Vector3;
        /**
         * Gets a boolean indicating if the virtual joystick was pressed
         */
        pressed: boolean;
        /**
         * Canvas the virtual joystick will render onto, default z-index of this is 5
         */
        static Canvas: Nullable<HTMLCanvasElement>;
        /**
         * boolean indicating whether or not the joystick's puck's movement should be limited to the joystick's container area
         */
        limitToContainer: boolean;
        private static _globalJoystickIndex;
        private static _alwaysVisibleSticks;
        private static vjCanvasContext;
        private static vjCanvasWidth;
        private static vjCanvasHeight;
        private static halfWidth;
        private static _GetDefaultOptions;
        private _action;
        private _axisTargetedByLeftAndRight;
        private _axisTargetedByUpAndDown;
        private _joystickSensibility;
        private _inversedSensibility;
        private _joystickPointerID;
        private _joystickColor;
        private _joystickPointerPos;
        private _joystickPreviousPointerPos;
        private _joystickPointerStartPos;
        private _deltaJoystickVector;
        private _leftJoystick;
        private _touches;
        private _joystickPosition;
        private _alwaysVisible;
        private _puckImage;
        private _containerImage;
        private _joystickPuckSize;
        private _joystickContainerSize;
        private _clearPuckSize;
        private _clearContainerSize;
        private _clearPuckSizeOffset;
        private _clearContainerSizeOffset;
        private _onPointerDownHandlerRef;
        private _onPointerMoveHandlerRef;
        private _onPointerUpHandlerRef;
        private _onResize;
        /**
         * Creates a new virtual joystick
         * @param leftJoystick defines that the joystick is for left hand (false by default)
         * @param customizations Defines the options we want to customize the VirtualJoystick
         */
        constructor(leftJoystick?: boolean, customizations?: Partial<VirtualJoystickCustomizations>);
        /**
         * Defines joystick sensibility (ie. the ratio beteen a physical move and virtual joystick position change)
         * @param newJoystickSensibility defines the new sensibility
         */
        setJoystickSensibility(newJoystickSensibility: number): void;
        private _onPointerDown;
        private _onPointerMove;
        private _onPointerUp;
        /**
         * Change the color of the virtual joystick
         * @param newColor a string that must be a CSS color value (like "red") or the hexa value (like "#FF0000")
         */
        setJoystickColor(newColor: string): void;
        /**
         * Size of the joystick's container
         */
        set containerSize(newSize: number);
        get containerSize(): number;
        /**
         * Size of the joystick's puck
         */
        set puckSize(newSize: number);
        get puckSize(): number;
        /**
         * Clears the set position of the joystick
         */
        clearPosition(): void;
        /**
         * Defines whether or not the joystick container is always visible
         */
        set alwaysVisible(value: boolean);
        get alwaysVisible(): boolean;
        /**
        * Sets the constant position of the Joystick container
        * @param x X axis coordinate
        * @param y Y axis coordinate
        */
        setPosition(x: number, y: number): void;
        /**
         * Defines a callback to call when the joystick is touched
         * @param action defines the callback
         */
        setActionOnTouch(action: () => any): void;
        /**
         * Defines which axis you'd like to control for left & right
         * @param axis defines the axis to use
         */
        setAxisForLeftRight(axis: JoystickAxis): void;
        /**
         * Defines which axis you'd like to control for up & down
         * @param axis defines the axis to use
         */
        setAxisForUpDown(axis: JoystickAxis): void;
        /**
         * Clears the canvas from the previous puck / container draw
         */
        private _clearPreviousDraw;
        /**
         * Loads `urlPath` to be used for the container's image
         * @param urlPath defines the urlPath of an image to use
         */
        setContainerImage(urlPath: string): void;
        /**
         * Loads `urlPath` to be used for the puck's image
         * @param urlPath defines the urlPath of an image to use
         */
        setPuckImage(urlPath: string): void;
        /**
         * Draws the Virtual Joystick's container
         */
        private _drawContainer;
        /**
         * Draws the Virtual Joystick's puck
         */
        private _drawPuck;
        private _drawVirtualJoystick;
        /**
         * Release internal HTML canvas
         */
        releaseCanvas(): void;
    }
}
declare module BABYLON {
        interface FreeCameraInputsManager {
            /**
             * Add virtual joystick input support to the input manager.
             * @returns the current input manager
             */
            addVirtualJoystick(): FreeCameraInputsManager;
        }
    /**
     * Manage the Virtual Joystick inputs to control the movement of a free camera.
     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs
     */
    export class FreeCameraVirtualJoystickInput implements ICameraInput<FreeCamera> {
        /**
         * Defines the camera the input is attached to.
         */
        camera: FreeCamera;
        private _leftjoystick;
        private _rightjoystick;
        /**
         * Gets the left stick of the virtual joystick.
         * @returns The virtual Joystick
         */
        getLeftJoystick(): VirtualJoystick;
        /**
         * Gets the right stick of the virtual joystick.
         * @returns The virtual Joystick
         */
        getRightJoystick(): VirtualJoystick;
        /**
         * Update the current camera state depending on the inputs that have been used this frame.
         * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
         */
        checkInputs(): void;
        /**
         * Attach the input controls to a specific dom element to get the input from.
         * @param element Defines the element the controls should be listened from
         * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Detach the current controls from the specified dom element.
         * @param element Defines the element to stop listening the inputs from
         */
        detachControl(element: Nullable<HTMLElement>): void;
        /**
         * Gets the class name of the current intput.
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Get the friendly name associated with the input class.
         * @returns the input friendly name
         */
        getSimpleName(): string;
    }
}
declare module BABYLON {
    /**
     * This represents a FPS type of camera controlled by touch.
     * This is like a universal camera minus the Gamepad controls.
     * @see https://doc.babylonjs.com/features/cameras#universal-camera
     */
    export class TouchCamera extends FreeCamera {
        /**
         * Defines the touch sensibility for rotation.
         * The higher the faster.
         */
        get touchAngularSensibility(): number;
        set touchAngularSensibility(value: number);
        /**
         * Defines the touch sensibility for move.
         * The higher the faster.
         */
        get touchMoveSensibility(): number;
        set touchMoveSensibility(value: number);
        /**
         * Instantiates a new touch camera.
         * This represents a FPS type of camera controlled by touch.
         * This is like a universal camera minus the Gamepad controls.
         * @see https://doc.babylonjs.com/features/cameras#universal-camera
         * @param name Define the name of the camera in the scene
         * @param position Define the start position of the camera in the scene
         * @param scene Define the scene the camera belongs to
         */
        constructor(name: string, position: Vector3, scene: Scene);
        /**
         * Gets the current object class name.
         * @return the class name
         */
        getClassName(): string;
        /** @hidden */
        _setupInputs(): void;
    }
}
declare module BABYLON {
    /**
     * This is a camera specifically designed to react to device orientation events such as a modern mobile device
     * being tilted forward or back and left or right.
     */
    export class DeviceOrientationCamera extends FreeCamera {
        private _initialQuaternion;
        private _quaternionCache;
        private _tmpDragQuaternion;
        private _disablePointerInputWhenUsingDeviceOrientation;
        /**
         * Creates a new device orientation camera
         * @param name The name of the camera
         * @param position The start position camera
         * @param scene The scene the camera belongs to
         */
        constructor(name: string, position: Vector3, scene: Scene);
        /**
         * Gets or sets a boolean indicating that pointer input must be disabled on first orientation sensor update (Default: true)
         */
        get disablePointerInputWhenUsingDeviceOrientation(): boolean;
        set disablePointerInputWhenUsingDeviceOrientation(value: boolean);
        private _dragFactor;
        /**
         * Enabled turning on the y axis when the orientation sensor is active
         * @param dragFactor the factor that controls the turn speed (default: 1/300)
         */
        enableHorizontalDragging(dragFactor?: number): void;
        /**
         * Gets the current instance class name ("DeviceOrientationCamera").
         * This helps avoiding instanceof at run time.
         * @returns the class name
         */
        getClassName(): string;
        /**
         * @hidden
         * Checks and applies the current values of the inputs to the camera. (Internal use only)
         */
        _checkInputs(): void;
        /**
         * Reset the camera to its default orientation on the specified axis only.
         * @param axis The axis to reset
         */
        resetToCurrentRotation(axis?: Axis): void;
    }
}
declare module BABYLON {
    /**
     * Defines supported buttons for XBox360 compatible gamepads
     */
    export enum Xbox360Button {
        /** A */
        A = 0,
        /** B */
        B = 1,
        /** X */
        X = 2,
        /** Y */
        Y = 3,
        /** Left button */
        LB = 4,
        /** Right button */
        RB = 5,
        /** Back */
        Back = 8,
        /** Start */
        Start = 9,
        /** Left stick */
        LeftStick = 10,
        /** Right stick */
        RightStick = 11
    }
    /** Defines values for XBox360 DPad  */
    export enum Xbox360Dpad {
        /** Up */
        Up = 12,
        /** Down */
        Down = 13,
        /** Left */
        Left = 14,
        /** Right */
        Right = 15
    }
    /**
     * Defines a XBox360 gamepad
     */
    export class Xbox360Pad extends Gamepad {
        private _leftTrigger;
        private _rightTrigger;
        private _onlefttriggerchanged;
        private _onrighttriggerchanged;
        private _onbuttondown;
        private _onbuttonup;
        private _ondpaddown;
        private _ondpadup;
        /** Observable raised when a button is pressed */
        onButtonDownObservable: Observable<Xbox360Button>;
        /** Observable raised when a button is released */
        onButtonUpObservable: Observable<Xbox360Button>;
        /** Observable raised when a pad is pressed */
        onPadDownObservable: Observable<Xbox360Dpad>;
        /** Observable raised when a pad is released */
        onPadUpObservable: Observable<Xbox360Dpad>;
        private _buttonA;
        private _buttonB;
        private _buttonX;
        private _buttonY;
        private _buttonBack;
        private _buttonStart;
        private _buttonLB;
        private _buttonRB;
        private _buttonLeftStick;
        private _buttonRightStick;
        private _dPadUp;
        private _dPadDown;
        private _dPadLeft;
        private _dPadRight;
        private _isXboxOnePad;
        /**
         * Creates a new XBox360 gamepad object
         * @param id defines the id of this gamepad
         * @param index defines its index
         * @param gamepad defines the internal HTML gamepad object
         * @param xboxOne defines if it is a XBox One gamepad
         */
        constructor(id: string, index: number, gamepad: any, xboxOne?: boolean);
        /**
         * Defines the callback to call when left trigger is pressed
         * @param callback defines the callback to use
         */
        onlefttriggerchanged(callback: (value: number) => void): void;
        /**
         * Defines the callback to call when right trigger is pressed
         * @param callback defines the callback to use
         */
        onrighttriggerchanged(callback: (value: number) => void): void;
        /**
         * Gets the left trigger value
         */
        get leftTrigger(): number;
        /**
         * Sets the left trigger value
         */
        set leftTrigger(newValue: number);
        /**
         * Gets the right trigger value
         */
        get rightTrigger(): number;
        /**
         * Sets the right trigger value
         */
        set rightTrigger(newValue: number);
        /**
         * Defines the callback to call when a button is pressed
         * @param callback defines the callback to use
         */
        onbuttondown(callback: (buttonPressed: Xbox360Button) => void): void;
        /**
         * Defines the callback to call when a button is released
         * @param callback defines the callback to use
         */
        onbuttonup(callback: (buttonReleased: Xbox360Button) => void): void;
        /**
         * Defines the callback to call when a pad is pressed
         * @param callback defines the callback to use
         */
        ondpaddown(callback: (dPadPressed: Xbox360Dpad) => void): void;
        /**
         * Defines the callback to call when a pad is released
         * @param callback defines the callback to use
         */
        ondpadup(callback: (dPadReleased: Xbox360Dpad) => void): void;
        private _setButtonValue;
        private _setDPadValue;
        /**
         * Gets the value of the `A` button
         */
        get buttonA(): number;
        /**
         * Sets the value of the `A` button
         */
        set buttonA(value: number);
        /**
         * Gets the value of the `B` button
         */
        get buttonB(): number;
        /**
         * Sets the value of the `B` button
         */
        set buttonB(value: number);
        /**
         * Gets the value of the `X` button
         */
        get buttonX(): number;
        /**
         * Sets the value of the `X` button
         */
        set buttonX(value: number);
        /**
         * Gets the value of the `Y` button
         */
        get buttonY(): number;
        /**
         * Sets the value of the `Y` button
         */
        set buttonY(value: number);
        /**
         * Gets the value of the `Start` button
         */
        get buttonStart(): number;
        /**
         * Sets the value of the `Start` button
         */
        set buttonStart(value: number);
        /**
         * Gets the value of the `Back` button
         */
        get buttonBack(): number;
        /**
         * Sets the value of the `Back` button
         */
        set buttonBack(value: number);
        /**
         * Gets the value of the `Left` button
         */
        get buttonLB(): number;
        /**
         * Sets the value of the `Left` button
         */
        set buttonLB(value: number);
        /**
         * Gets the value of the `Right` button
         */
        get buttonRB(): number;
        /**
         * Sets the value of the `Right` button
         */
        set buttonRB(value: number);
        /**
         * Gets the value of the Left joystick
         */
        get buttonLeftStick(): number;
        /**
         * Sets the value of the Left joystick
         */
        set buttonLeftStick(value: number);
        /**
         * Gets the value of the Right joystick
         */
        get buttonRightStick(): number;
        /**
         * Sets the value of the Right joystick
         */
        set buttonRightStick(value: number);
        /**
         * Gets the value of D-pad up
         */
        get dPadUp(): number;
        /**
         * Sets the value of D-pad up
         */
        set dPadUp(value: number);
        /**
         * Gets the value of D-pad down
         */
        get dPadDown(): number;
        /**
         * Sets the value of D-pad down
         */
        set dPadDown(value: number);
        /**
         * Gets the value of D-pad left
         */
        get dPadLeft(): number;
        /**
         * Sets the value of D-pad left
         */
        set dPadLeft(value: number);
        /**
         * Gets the value of D-pad right
         */
        get dPadRight(): number;
        /**
         * Sets the value of D-pad right
         */
        set dPadRight(value: number);
        /**
         * Force the gamepad to synchronize with device values
         */
        update(): void;
        /**
         * Disposes the gamepad
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * Defines supported buttons for DualShock compatible gamepads
     */
    export enum DualShockButton {
        /** Cross */
        Cross = 0,
        /** Circle */
        Circle = 1,
        /** Square */
        Square = 2,
        /** Triangle */
        Triangle = 3,
        /** L1 */
        L1 = 4,
        /** R1 */
        R1 = 5,
        /** Share */
        Share = 8,
        /** Options */
        Options = 9,
        /** Left stick */
        LeftStick = 10,
        /** Right stick */
        RightStick = 11
    }
    /** Defines values for DualShock DPad  */
    export enum DualShockDpad {
        /** Up */
        Up = 12,
        /** Down */
        Down = 13,
        /** Left */
        Left = 14,
        /** Right */
        Right = 15
    }
    /**
     * Defines a DualShock gamepad
     */
    export class DualShockPad extends Gamepad {
        private _leftTrigger;
        private _rightTrigger;
        private _onlefttriggerchanged;
        private _onrighttriggerchanged;
        private _onbuttondown;
        private _onbuttonup;
        private _ondpaddown;
        private _ondpadup;
        /** Observable raised when a button is pressed */
        onButtonDownObservable: Observable<DualShockButton>;
        /** Observable raised when a button is released */
        onButtonUpObservable: Observable<DualShockButton>;
        /** Observable raised when a pad is pressed */
        onPadDownObservable: Observable<DualShockDpad>;
        /** Observable raised when a pad is released */
        onPadUpObservable: Observable<DualShockDpad>;
        private _buttonCross;
        private _buttonCircle;
        private _buttonSquare;
        private _buttonTriangle;
        private _buttonShare;
        private _buttonOptions;
        private _buttonL1;
        private _buttonR1;
        private _buttonLeftStick;
        private _buttonRightStick;
        private _dPadUp;
        private _dPadDown;
        private _dPadLeft;
        private _dPadRight;
        /**
         * Creates a new DualShock gamepad object
         * @param id defines the id of this gamepad
         * @param index defines its index
         * @param gamepad defines the internal HTML gamepad object
         */
        constructor(id: string, index: number, gamepad: any);
        /**
         * Defines the callback to call when left trigger is pressed
         * @param callback defines the callback to use
         */
        onlefttriggerchanged(callback: (value: number) => void): void;
        /**
         * Defines the callback to call when right trigger is pressed
         * @param callback defines the callback to use
         */
        onrighttriggerchanged(callback: (value: number) => void): void;
        /**
         * Gets the left trigger value
         */
        get leftTrigger(): number;
        /**
         * Sets the left trigger value
         */
        set leftTrigger(newValue: number);
        /**
         * Gets the right trigger value
         */
        get rightTrigger(): number;
        /**
         * Sets the right trigger value
         */
        set rightTrigger(newValue: number);
        /**
         * Defines the callback to call when a button is pressed
         * @param callback defines the callback to use
         */
        onbuttondown(callback: (buttonPressed: DualShockButton) => void): void;
        /**
         * Defines the callback to call when a button is released
         * @param callback defines the callback to use
         */
        onbuttonup(callback: (buttonReleased: DualShockButton) => void): void;
        /**
         * Defines the callback to call when a pad is pressed
         * @param callback defines the callback to use
         */
        ondpaddown(callback: (dPadPressed: DualShockDpad) => void): void;
        /**
         * Defines the callback to call when a pad is released
         * @param callback defines the callback to use
         */
        ondpadup(callback: (dPadReleased: DualShockDpad) => void): void;
        private _setButtonValue;
        private _setDPadValue;
        /**
         * Gets the value of the `Cross` button
         */
        get buttonCross(): number;
        /**
         * Sets the value of the `Cross` button
         */
        set buttonCross(value: number);
        /**
         * Gets the value of the `Circle` button
         */
        get buttonCircle(): number;
        /**
         * Sets the value of the `Circle` button
         */
        set buttonCircle(value: number);
        /**
         * Gets the value of the `Square` button
         */
        get buttonSquare(): number;
        /**
         * Sets the value of the `Square` button
         */
        set buttonSquare(value: number);
        /**
         * Gets the value of the `Triangle` button
         */
        get buttonTriangle(): number;
        /**
         * Sets the value of the `Triangle` button
         */
        set buttonTriangle(value: number);
        /**
         * Gets the value of the `Options` button
         */
        get buttonOptions(): number;
        /**
         * Sets the value of the `Options` button
         */
        set buttonOptions(value: number);
        /**
         * Gets the value of the `Share` button
         */
        get buttonShare(): number;
        /**
         * Sets the value of the `Share` button
         */
        set buttonShare(value: number);
        /**
         * Gets the value of the `L1` button
         */
        get buttonL1(): number;
        /**
         * Sets the value of the `L1` button
         */
        set buttonL1(value: number);
        /**
         * Gets the value of the `R1` button
         */
        get buttonR1(): number;
        /**
         * Sets the value of the `R1` button
         */
        set buttonR1(value: number);
        /**
         * Gets the value of the Left joystick
         */
        get buttonLeftStick(): number;
        /**
         * Sets the value of the Left joystick
         */
        set buttonLeftStick(value: number);
        /**
         * Gets the value of the Right joystick
         */
        get buttonRightStick(): number;
        /**
         * Sets the value of the Right joystick
         */
        set buttonRightStick(value: number);
        /**
         * Gets the value of D-pad up
         */
        get dPadUp(): number;
        /**
         * Sets the value of D-pad up
         */
        set dPadUp(value: number);
        /**
         * Gets the value of D-pad down
         */
        get dPadDown(): number;
        /**
         * Sets the value of D-pad down
         */
        set dPadDown(value: number);
        /**
         * Gets the value of D-pad left
         */
        get dPadLeft(): number;
        /**
         * Sets the value of D-pad left
         */
        set dPadLeft(value: number);
        /**
         * Gets the value of D-pad right
         */
        get dPadRight(): number;
        /**
         * Sets the value of D-pad right
         */
        set dPadRight(value: number);
        /**
         * Force the gamepad to synchronize with device values
         */
        update(): void;
        /**
         * Disposes the gamepad
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * Manager for handling gamepads
     */
    export class GamepadManager {
        private _scene?;
        private _babylonGamepads;
        private _oneGamepadConnected;
        /** @hidden */
        _isMonitoring: boolean;
        private _gamepadEventSupported;
        private _gamepadSupport?;
        /**
         * observable to be triggered when the gamepad controller has been connected
         */
        onGamepadConnectedObservable: Observable<Gamepad>;
        /**
         * observable to be triggered when the gamepad controller has been disconnected
         */
        onGamepadDisconnectedObservable: Observable<Gamepad>;
        private _onGamepadConnectedEvent;
        private _onGamepadDisconnectedEvent;
        /**
         * Initializes the gamepad manager
         * @param _scene BabylonJS scene
         */
        constructor(_scene?: Scene | undefined);
        /**
         * The gamepads in the game pad manager
         */
        get gamepads(): Gamepad[];
        /**
         * Get the gamepad controllers based on type
         * @param type The type of gamepad controller
         * @returns Nullable gamepad
         */
        getGamepadByType(type?: number): Nullable<Gamepad>;
        /**
         * Disposes the gamepad manager
         */
        dispose(): void;
        private _addNewGamepad;
        private _startMonitoringGamepads;
        private _stopMonitoringGamepads;
        /** @hidden */
        _checkGamepadsStatus(): void;
        private _updateGamepadObjects;
    }
}
declare module BABYLON {
        interface Scene {
            /** @hidden */
            _gamepadManager: Nullable<GamepadManager>;
            /**
             * Gets the gamepad manager associated with the scene
             * @see https://doc.babylonjs.com/how_to/how_to_use_gamepads
             */
            gamepadManager: GamepadManager;
        }
        /**
         * Interface representing a free camera inputs manager
         */
        interface FreeCameraInputsManager {
            /**
             * Adds gamepad input support to the FreeCameraInputsManager.
             * @returns the FreeCameraInputsManager
             */
            addGamepad(): FreeCameraInputsManager;
        }
        /**
         * Interface representing an arc rotate camera inputs manager
         */
        interface ArcRotateCameraInputsManager {
            /**
             * Adds gamepad input support to the ArcRotateCamera InputManager.
             * @returns the camera inputs manager
             */
            addGamepad(): ArcRotateCameraInputsManager;
        }
    /**
      * Defines the gamepad scene component responsible to manage gamepads in a given scene
      */
    export class GamepadSystemSceneComponent implements ISceneComponent {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        readonly name: string;
        /**
         * The scene the component belongs to.
         */
        scene: Scene;
        /**
         * Creates a new instance of the component for the given scene
         * @param scene Defines the scene to register the component in
         */
        constructor(scene: Scene);
        /**
         * Registers the component in a given scene
         */
        register(): void;
        /**
         * Rebuilds the elements related to this component in case of
         * context lost for instance.
         */
        rebuild(): void;
        /**
         * Disposes the component and the associated ressources
         */
        dispose(): void;
        private _beforeCameraUpdate;
    }
}
declare module BABYLON {
    /**
     * The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,
     * which still works and will still be found in many Playgrounds.
     * @see https://doc.babylonjs.com/features/cameras#universal-camera
     */
    export class UniversalCamera extends TouchCamera {
        /**
         * Defines the gamepad rotation sensiblity.
         * This is the threshold from when rotation starts to be accounted for to prevent jittering.
         */
        get gamepadAngularSensibility(): number;
        set gamepadAngularSensibility(value: number);
        /**
         * Defines the gamepad move sensiblity.
         * This is the threshold from when moving starts to be accounted for for to prevent jittering.
         */
        get gamepadMoveSensibility(): number;
        set gamepadMoveSensibility(value: number);
        /**
         * The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,
         * which still works and will still be found in many Playgrounds.
         * @see https://doc.babylonjs.com/features/cameras#universal-camera
         * @param name Define the name of the camera in the scene
         * @param position Define the start position of the camera in the scene
         * @param scene Define the scene the camera belongs to
         */
        constructor(name: string, position: Vector3, scene: Scene);
        /**
         * Gets the current object class name.
         * @return the class name
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /**
     * This represents a FPS type of camera. This is only here for back compat purpose.
     * Please use the UniversalCamera instead as both are identical.
     * @see https://doc.babylonjs.com/features/cameras#universal-camera
     */
    export class GamepadCamera extends UniversalCamera {
        /**
         * Instantiates a new Gamepad Camera
         * This represents a FPS type of camera. This is only here for back compat purpose.
         * Please use the UniversalCamera instead as both are identical.
         * @see https://doc.babylonjs.com/features/cameras#universal-camera
         * @param name Define the name of the camera in the scene
         * @param position Define the start position of the camera in the scene
         * @param scene Define the scene the camera belongs to
         */
        constructor(name: string, position: Vector3, scene: Scene);
        /**
         * Gets the current object class name.
         * @return the class name
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /** @hidden */
    export var passPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var passCubePixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * PassPostProcess which produces an output the same as it's input
     */
    export class PassPostProcess extends PostProcess {
        /**
         * Gets a string identifying the name of the class
         * @returns "PassPostProcess" string
         */
        getClassName(): string;
        /**
         * Creates the PassPostProcess
         * @param name The name of the effect.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType The type of texture to be used when performing the post processing.
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, options: number | PostProcessOptions, camera?: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
        /** @hidden */
        static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): PassPostProcess;
    }
    /**
     * PassCubePostProcess which produces an output the same as it's input (which must be a cube texture)
     */
    export class PassCubePostProcess extends PostProcess {
        private _face;
        /**
         * Gets or sets the cube face to display.
         *  * 0 is +X
         *  * 1 is -X
         *  * 2 is +Y
         *  * 3 is -Y
         *  * 4 is +Z
         *  * 5 is -Z
         */
        get face(): number;
        set face(value: number);
        /**
         * Gets a string identifying the name of the class
         * @returns "PassCubePostProcess" string
         */
        getClassName(): string;
        /**
         * Creates the PassCubePostProcess
         * @param name The name of the effect.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType The type of texture to be used when performing the post processing.
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, options: number | PostProcessOptions, camera?: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
        /** @hidden */
        static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): PassCubePostProcess;
    }
}
declare module BABYLON {
    /** @hidden */
    export var anaglyphPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Postprocess used to generate anaglyphic rendering
     */
    export class AnaglyphPostProcess extends PostProcess {
        private _passedProcess;
        /**
         * Gets a string identifying the name of the class
         * @returns "AnaglyphPostProcess" string
         */
        getClassName(): string;
        /**
         * Creates a new AnaglyphPostProcess
         * @param name defines postprocess name
         * @param options defines creation options or target ratio scale
         * @param rigCameras defines cameras using this postprocess
         * @param samplingMode defines required sampling mode (BABYLON.Texture.NEAREST_SAMPLINGMODE by default)
         * @param engine defines hosting engine
         * @param reusable defines if the postprocess will be reused multiple times per frame
         */
        constructor(name: string, options: number | PostProcessOptions, rigCameras: Camera[], samplingMode?: number, engine?: Engine, reusable?: boolean);
    }
}
declare module BABYLON {
    /**
     * Camera used to simulate anaglyphic rendering (based on ArcRotateCamera)
     * @see https://doc.babylonjs.com/features/cameras#anaglyph-cameras
     */
    export class AnaglyphArcRotateCamera extends ArcRotateCamera {
        /**
         * Creates a new AnaglyphArcRotateCamera
         * @param name defines camera name
         * @param alpha defines alpha angle (in radians)
         * @param beta defines beta angle (in radians)
         * @param radius defines radius
         * @param target defines camera target
         * @param interaxialDistance defines distance between each color axis
         * @param scene defines the hosting scene
         */
        constructor(name: string, alpha: number, beta: number, radius: number, target: Vector3, interaxialDistance: number, scene: Scene);
        /**
         * Gets camera class name
         * @returns AnaglyphArcRotateCamera
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /**
     * Camera used to simulate anaglyphic rendering (based on FreeCamera)
     * @see https://doc.babylonjs.com/features/cameras#anaglyph-cameras
     */
    export class AnaglyphFreeCamera extends FreeCamera {
        /**
         * Creates a new AnaglyphFreeCamera
         * @param name defines camera name
         * @param position defines initial position
         * @param interaxialDistance defines distance between each color axis
         * @param scene defines the hosting scene
         */
        constructor(name: string, position: Vector3, interaxialDistance: number, scene: Scene);
        /**
         * Gets camera class name
         * @returns AnaglyphFreeCamera
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /**
     * Camera used to simulate anaglyphic rendering (based on GamepadCamera)
     * @see https://doc.babylonjs.com/features/cameras#anaglyph-cameras
     */
    export class AnaglyphGamepadCamera extends GamepadCamera {
        /**
         * Creates a new AnaglyphGamepadCamera
         * @param name defines camera name
         * @param position defines initial position
         * @param interaxialDistance defines distance between each color axis
         * @param scene defines the hosting scene
         */
        constructor(name: string, position: Vector3, interaxialDistance: number, scene: Scene);
        /**
         * Gets camera class name
         * @returns AnaglyphGamepadCamera
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /**
     * Camera used to simulate anaglyphic rendering (based on UniversalCamera)
     * @see https://doc.babylonjs.com/features/cameras#anaglyph-cameras
     */
    export class AnaglyphUniversalCamera extends UniversalCamera {
        /**
         * Creates a new AnaglyphUniversalCamera
         * @param name defines camera name
         * @param position defines initial position
         * @param interaxialDistance defines distance between each color axis
         * @param scene defines the hosting scene
         */
        constructor(name: string, position: Vector3, interaxialDistance: number, scene: Scene);
        /**
         * Gets camera class name
         * @returns AnaglyphUniversalCamera
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /**
     * Camera used to simulate stereoscopic rendering (based on ArcRotateCamera)
     * @see https://doc.babylonjs.com/features/cameras
     */
    export class StereoscopicArcRotateCamera extends ArcRotateCamera {
        /**
         * Creates a new StereoscopicArcRotateCamera
         * @param name defines camera name
         * @param alpha defines alpha angle (in radians)
         * @param beta defines beta angle (in radians)
         * @param radius defines radius
         * @param target defines camera target
         * @param interaxialDistance defines distance between each color axis
         * @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under
         * @param scene defines the hosting scene
         */
        constructor(name: string, alpha: number, beta: number, radius: number, target: Vector3, interaxialDistance: number, isStereoscopicSideBySide: boolean, scene: Scene);
        /**
         * Gets camera class name
         * @returns StereoscopicArcRotateCamera
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /**
     * Camera used to simulate stereoscopic rendering (based on FreeCamera)
     * @see https://doc.babylonjs.com/features/cameras
     */
    export class StereoscopicFreeCamera extends FreeCamera {
        /**
         * Creates a new StereoscopicFreeCamera
         * @param name defines camera name
         * @param position defines initial position
         * @param interaxialDistance defines distance between each color axis
         * @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under
         * @param scene defines the hosting scene
         */
        constructor(name: string, position: Vector3, interaxialDistance: number, isStereoscopicSideBySide: boolean, scene: Scene);
        /**
         * Gets camera class name
         * @returns StereoscopicFreeCamera
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /**
     * Camera used to simulate stereoscopic rendering (based on GamepadCamera)
     * @see https://doc.babylonjs.com/features/cameras
     */
    export class StereoscopicGamepadCamera extends GamepadCamera {
        /**
         * Creates a new StereoscopicGamepadCamera
         * @param name defines camera name
         * @param position defines initial position
         * @param interaxialDistance defines distance between each color axis
         * @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under
         * @param scene defines the hosting scene
         */
        constructor(name: string, position: Vector3, interaxialDistance: number, isStereoscopicSideBySide: boolean, scene: Scene);
        /**
         * Gets camera class name
         * @returns StereoscopicGamepadCamera
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /**
     * Camera used to simulate stereoscopic rendering (based on UniversalCamera)
     * @see https://doc.babylonjs.com/features/cameras
     */
    export class StereoscopicUniversalCamera extends UniversalCamera {
        /**
         * Creates a new StereoscopicUniversalCamera
         * @param name defines camera name
         * @param position defines initial position
         * @param interaxialDistance defines distance between each color axis
         * @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under
         * @param scene defines the hosting scene
         */
        constructor(name: string, position: Vector3, interaxialDistance: number, isStereoscopicSideBySide: boolean, scene: Scene);
        /**
         * Gets camera class name
         * @returns StereoscopicUniversalCamera
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /**
     * This represents a free type of camera. It can be useful in First Person Shooter game for instance.
     * It is identical to the Free Camera and simply adds by default a virtual joystick.
     * Virtual Joysticks are on-screen 2D graphics that are used to control the camera or other scene items.
     * @see https://doc.babylonjs.com/features/cameras#virtual-joysticks-camera
     */
    export class VirtualJoysticksCamera extends FreeCamera {
        /**
         * Intantiates a VirtualJoysticksCamera. It can be useful in First Person Shooter game for instance.
         * It is identical to the Free Camera and simply adds by default a virtual joystick.
         * Virtual Joysticks are on-screen 2D graphics that are used to control the camera or other scene items.
         * @see https://doc.babylonjs.com/features/cameras#virtual-joysticks-camera
         * @param name Define the name of the camera in the scene
         * @param position Define the start position of the camera in the scene
         * @param scene Define the scene the camera belongs to
         */
        constructor(name: string, position: Vector3, scene: Scene);
        /**
         * Gets the current object class name.
         * @return the class name
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /**
     * This represents all the required metrics to create a VR camera.
     * @see https://doc.babylonjs.com/babylon101/cameras#device-orientation-camera
     */
    export class VRCameraMetrics {
        /**
         * Define the horizontal resolution off the screen.
         */
        hResolution: number;
        /**
         * Define the vertical resolution off the screen.
         */
        vResolution: number;
        /**
         * Define the horizontal screen size.
         */
        hScreenSize: number;
        /**
         * Define the vertical screen size.
         */
        vScreenSize: number;
        /**
         * Define the vertical screen center position.
         */
        vScreenCenter: number;
        /**
         * Define the distance of the eyes to the screen.
         */
        eyeToScreenDistance: number;
        /**
         * Define the distance between both lenses
         */
        lensSeparationDistance: number;
        /**
         * Define the distance between both viewer's eyes.
         */
        interpupillaryDistance: number;
        /**
         * Define the distortion factor of the VR postprocess.
         * Please, touch with care.
         */
        distortionK: number[];
        /**
         * Define the chromatic aberration correction factors for the VR post process.
         */
        chromaAbCorrection: number[];
        /**
         * Define the scale factor of the post process.
         * The smaller the better but the slower.
         */
        postProcessScaleFactor: number;
        /**
         * Define an offset for the lens center.
         */
        lensCenterOffset: number;
        /**
         * Define if the current vr camera should compensate the distortion of the lense or not.
         */
        compensateDistortion: boolean;
        /**
         * Defines if multiview should be enabled when rendering (Default: false)
         */
        multiviewEnabled: boolean;
        /**
         * Gets the rendering aspect ratio based on the provided resolutions.
         */
        get aspectRatio(): number;
        /**
         * Gets the aspect ratio based on the FOV, scale factors, and real screen sizes.
         */
        get aspectRatioFov(): number;
        /**
         * @hidden
         */
        get leftHMatrix(): Matrix;
        /**
         * @hidden
         */
        get rightHMatrix(): Matrix;
        /**
         * @hidden
         */
        get leftPreViewMatrix(): Matrix;
        /**
         * @hidden
         */
        get rightPreViewMatrix(): Matrix;
        /**
         * Get the default VRMetrics based on the most generic setup.
         * @returns the default vr metrics
         */
        static GetDefault(): VRCameraMetrics;
    }
}
declare module BABYLON {
    /** @hidden */
    export var vrDistortionCorrectionPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * VRDistortionCorrectionPostProcess used for mobile VR
     */
    export class VRDistortionCorrectionPostProcess extends PostProcess {
        private _isRightEye;
        private _distortionFactors;
        private _postProcessScaleFactor;
        private _lensCenterOffset;
        private _scaleIn;
        private _scaleFactor;
        private _lensCenter;
        /**
         * Gets a string identifying the name of the class
         * @returns "VRDistortionCorrectionPostProcess" string
         */
        getClassName(): string;
        /**
         * Initializes the VRDistortionCorrectionPostProcess
         * @param name The name of the effect.
         * @param camera The camera to apply the render pass to.
         * @param isRightEye If this is for the right eye distortion
         * @param vrMetrics All the required metrics for the VR camera
         */
        constructor(name: string, camera: Camera, isRightEye: boolean, vrMetrics: VRCameraMetrics);
    }
}
declare module BABYLON {
    /**
     * Camera used to simulate VR rendering (based on ArcRotateCamera)
     * @see https://doc.babylonjs.com/babylon101/cameras#vr-device-orientation-cameras
     */
    export class VRDeviceOrientationArcRotateCamera extends ArcRotateCamera {
        /**
         * Creates a new VRDeviceOrientationArcRotateCamera
         * @param name defines camera name
         * @param alpha defines the camera rotation along the logitudinal axis
         * @param beta defines the camera rotation along the latitudinal axis
         * @param radius defines the camera distance from its target
         * @param target defines the camera target
         * @param scene defines the scene the camera belongs to
         * @param compensateDistortion defines if the camera needs to compensate the lens distorsion
         * @param vrCameraMetrics defines the vr metrics associated to the camera
         */
        constructor(name: string, alpha: number, beta: number, radius: number, target: Vector3, scene: Scene, compensateDistortion?: boolean, vrCameraMetrics?: VRCameraMetrics);
        /**
         * Gets camera class name
         * @returns VRDeviceOrientationArcRotateCamera
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /**
     * Camera used to simulate VR rendering (based on FreeCamera)
     * @see https://doc.babylonjs.com/babylon101/cameras#vr-device-orientation-cameras
     */
    export class VRDeviceOrientationFreeCamera extends DeviceOrientationCamera {
        /**
         * Creates a new VRDeviceOrientationFreeCamera
         * @param name defines camera name
         * @param position defines the start position of the camera
         * @param scene defines the scene the camera belongs to
         * @param compensateDistortion defines if the camera needs to compensate the lens distorsion
         * @param vrCameraMetrics defines the vr metrics associated to the camera
         */
        constructor(name: string, position: Vector3, scene: Scene, compensateDistortion?: boolean, vrCameraMetrics?: VRCameraMetrics);
        /**
         * Gets camera class name
         * @returns VRDeviceOrientationFreeCamera
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /**
     * Camera used to simulate VR rendering (based on VRDeviceOrientationFreeCamera)
     * @see https://doc.babylonjs.com/babylon101/cameras#vr-device-orientation-cameras
     */
    export class VRDeviceOrientationGamepadCamera extends VRDeviceOrientationFreeCamera {
        /**
         * Creates a new VRDeviceOrientationGamepadCamera
         * @param name defines camera name
         * @param position defines the start position of the camera
         * @param scene defines the scene the camera belongs to
         * @param compensateDistortion defines if the camera needs to compensate the lens distorsion
         * @param vrCameraMetrics defines the vr metrics associated to the camera
         */
        constructor(name: string, position: Vector3, scene: Scene, compensateDistortion?: boolean, vrCameraMetrics?: VRCameraMetrics);
        /**
         * Gets camera class name
         * @returns VRDeviceOrientationGamepadCamera
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /**
     * A class extending Texture allowing drawing on a texture
     * @see https://doc.babylonjs.com/how_to/dynamictexture
     */
    export class DynamicTexture extends Texture {
        private _generateMipMaps;
        private _canvas;
        private _context;
        /**
         * Creates a DynamicTexture
         * @param name defines the name of the texture
         * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height
         * @param scene defines the scene where you want the texture
         * @param generateMipMaps defines the use of MinMaps or not (default is false)
         * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)
         * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)
         */
        constructor(name: string, options: any, scene: Scene | null | undefined, generateMipMaps: boolean, samplingMode?: number, format?: number);
        /**
         * Get the current class name of the texture useful for serialization or dynamic coding.
         * @returns "DynamicTexture"
         */
        getClassName(): string;
        /**
         * Gets the current state of canRescale
         */
        get canRescale(): boolean;
        private _recreate;
        /**
         * Scales the texture
         * @param ratio the scale factor to apply to both width and height
         */
        scale(ratio: number): void;
        /**
         * Resizes the texture
         * @param width the new width
         * @param height the new height
         */
        scaleTo(width: number, height: number): void;
        /**
         * Gets the context of the canvas used by the texture
         * @returns the canvas context of the dynamic texture
         */
        getContext(): CanvasRenderingContext2D;
        /**
         * Clears the texture
         */
        clear(): void;
        /**
         * Updates the texture
         * @param invertY defines the direction for the Y axis (default is true - y increases downwards)
         * @param premulAlpha defines if alpha is stored as premultiplied (default is false)
         */
        update(invertY?: boolean, premulAlpha?: boolean): void;
        /**
         * Draws text onto the texture
         * @param text defines the text to be drawn
         * @param x defines the placement of the text from the left
         * @param y defines the placement of the text from the top when invertY is true and from the bottom when false
         * @param font defines the font to be used with font-style, font-size, font-name
         * @param color defines the color used for the text
         * @param clearColor defines the color for the canvas, use null to not overwrite canvas
         * @param invertY defines the direction for the Y axis (default is true - y increases downwards)
         * @param update defines whether texture is immediately update (default is true)
         */
        drawText(text: string, x: number | null | undefined, y: number | null | undefined, font: string, color: string | null, clearColor: string, invertY?: boolean, update?: boolean): void;
        /**
         * Clones the texture
         * @returns the clone of the texture.
         */
        clone(): DynamicTexture;
        /**
         * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized
         * @returns a serialized dynamic texture object
         */
        serialize(): any;
        private _IsCanvasElement;
        /** @hidden */
        _rebuild(): void;
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class GroundBuilder {
        /**
         * Creates a ground mesh
         * * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground
         * * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the ground mesh
         * @see https://doc.babylonjs.com/how_to/set_shapes#ground
         */
        static CreateGround(name: string, options: {
            width?: number;
            height?: number;
            subdivisions?: number;
            subdivisionsX?: number;
            subdivisionsY?: number;
            updatable?: boolean;
        }, scene: any): Mesh;
        /**
         * Creates a tiled ground mesh
         * * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates
         * * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates
         * * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile
         * * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the tiled ground mesh
         * @see https://doc.babylonjs.com/how_to/set_shapes#tiled-ground
         */
        static CreateTiledGround(name: string, options: {
            xmin: number;
            zmin: number;
            xmax: number;
            zmax: number;
            subdivisions?: {
                w: number;
                h: number;
            };
            precision?: {
                w: number;
                h: number;
            };
            updatable?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates a ground mesh from a height map
         * * The parameter `url` sets the URL of the height map image resource.
         * * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.
         * * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.
         * * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.
         * * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.
         * * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.
         * * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).
         * * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         * @param name defines the name of the mesh
         * @param url defines the url to the height map
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the ground mesh
         * @see https://doc.babylonjs.com/babylon101/height_map
         * @see https://doc.babylonjs.com/how_to/set_shapes#ground-from-a-height-map
         */
        static CreateGroundFromHeightMap(name: string, url: string, options: {
            width?: number;
            height?: number;
            subdivisions?: number;
            minHeight?: number;
            maxHeight?: number;
            colorFilter?: Color3;
            alphaFilter?: number;
            updatable?: boolean;
            onReady?: (mesh: GroundMesh) => void;
        }, scene?: Nullable<Scene>): GroundMesh;
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class TorusBuilder {
        /**
         * Creates a torus mesh
         * * The parameter `diameter` sets the diameter size (float) of the torus (default 1)
         * * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)
         * * The parameter `tessellation` sets the number of torus sides (postive integer, default 16)
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the torus mesh
         * @see https://doc.babylonjs.com/how_to/set_shapes#torus
         */
        static CreateTorus(name: string, options: {
            diameter?: number;
            thickness?: number;
            tessellation?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }, scene: any): Mesh;
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class CylinderBuilder {
        /**
         * Creates a cylinder or a cone mesh
         * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).
         * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).
         * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter "diameterBottom" can't be zero.
         * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.
         * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).
         * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.
         * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.
         * * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).
         * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.
         * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).
         * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3
         * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7
         * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17
         * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.
         * * If `enclose` is false, a ring surface is one element.
         * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.
         * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the cylinder mesh
         * @see https://doc.babylonjs.com/how_to/set_shapes#cylinder-or-cone
         */
        static CreateCylinder(name: string, options: {
            height?: number;
            diameterTop?: number;
            diameterBottom?: number;
            diameter?: number;
            tessellation?: number;
            subdivisions?: number;
            arc?: number;
            faceColors?: Color4[];
            faceUV?: Vector4[];
            updatable?: boolean;
            hasRings?: boolean;
            enclose?: boolean;
            cap?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }, scene: any): Mesh;
    }
}
declare module BABYLON {
    /**
     * States of the webXR experience
     */
    export enum WebXRState {
        /**
         * Transitioning to being in XR mode
         */
        ENTERING_XR = 0,
        /**
         * Transitioning to non XR mode
         */
        EXITING_XR = 1,
        /**
         * In XR mode and presenting
         */
        IN_XR = 2,
        /**
         * Not entered XR mode
         */
        NOT_IN_XR = 3
    }
    /**
     * Abstraction of the XR render target
     */
    export interface WebXRRenderTarget extends IDisposable {
        /**
         * xrpresent context of the canvas which can be used to display/mirror xr content
         */
        canvasContext: WebGLRenderingContext;
        /**
         * xr layer for the canvas
         */
        xrLayer: Nullable<XRWebGLLayer>;
        /**
         * Initializes the xr layer for the session
         * @param xrSession xr session
         * @returns a promise that will resolve once the XR Layer has been created
         */
        initializeXRLayerAsync(xrSession: XRSession): Promise<XRWebGLLayer>;
    }
}
declare module BABYLON {
    /**
     * COnfiguration object for WebXR output canvas
     */
    export class WebXRManagedOutputCanvasOptions {
        /**
         * An optional canvas in case you wish to create it yourself and provide it here.
         * If not provided, a new canvas will be created
         */
        canvasElement?: HTMLCanvasElement;
        /**
         * Options for this XR Layer output
         */
        canvasOptions?: XRWebGLLayerOptions;
        /**
         * CSS styling for a newly created canvas (if not provided)
         */
        newCanvasCssStyle?: string;
        /**
         * Get the default values of the configuration object
         * @param engine defines the engine to use (can be null)
         * @returns default values of this configuration object
         */
        static GetDefaults(engine?: ThinEngine): WebXRManagedOutputCanvasOptions;
    }
    /**
     * Creates a canvas that is added/removed from the webpage when entering/exiting XR
     */
    export class WebXRManagedOutputCanvas implements WebXRRenderTarget {
        private _options;
        private _canvas;
        private _engine;
        private _originalCanvasSize;
        /**
         * Rendering context of the canvas which can be used to display/mirror xr content
         */
        canvasContext: WebGLRenderingContext;
        /**
         * xr layer for the canvas
         */
        xrLayer: Nullable<XRWebGLLayer>;
        /**
         * Obseervers registered here will be triggered when the xr layer was initialized
         */
        onXRLayerInitObservable: Observable<XRWebGLLayer>;
        /**
         * Initializes the canvas to be added/removed upon entering/exiting xr
         * @param _xrSessionManager The XR Session manager
         * @param _options optional configuration for this canvas output. defaults will be used if not provided
         */
        constructor(_xrSessionManager: WebXRSessionManager, _options?: WebXRManagedOutputCanvasOptions);
        /**
         * Disposes of the object
         */
        dispose(): void;
        /**
         * Initializes the xr layer for the session
         * @param xrSession xr session
         * @returns a promise that will resolve once the XR Layer has been created
         */
        initializeXRLayerAsync(xrSession: XRSession): Promise<XRWebGLLayer>;
        private _addCanvas;
        private _removeCanvas;
        private _setCanvasSize;
        private _setManagedOutputCanvas;
    }
}
declare module BABYLON {
    /**
     * Manages an XRSession to work with Babylon's engine
     * @see https://doc.babylonjs.com/how_to/webxr_session_manager
     */
    export class WebXRSessionManager implements IDisposable {
        /** The scene which the session should be created for */
        scene: Scene;
        private _referenceSpace;
        private _rttProvider;
        private _sessionEnded;
        private _xrNavigator;
        private baseLayer;
        /**
         * The base reference space from which the session started. good if you want to reset your
         * reference space
         */
        baseReferenceSpace: XRReferenceSpace;
        /**
         * Current XR frame
         */
        currentFrame: Nullable<XRFrame>;
        /** WebXR timestamp updated every frame */
        currentTimestamp: number;
        /**
         * Used just in case of a failure to initialize an immersive session.
         * The viewer reference space is compensated using this height, creating a kind of "viewer-floor" reference space
         */
        defaultHeightCompensation: number;
        /**
         * Fires every time a new xrFrame arrives which can be used to update the camera
         */
        onXRFrameObservable: Observable<XRFrame>;
        /**
         * Fires when the reference space changed
         */
        onXRReferenceSpaceChanged: Observable<XRReferenceSpace>;
        /**
         * Fires when the xr session is ended either by the device or manually done
         */
        onXRSessionEnded: Observable<any>;
        /**
         * Fires when the xr session is ended either by the device or manually done
         */
        onXRSessionInit: Observable<XRSession>;
        /**
         * Underlying xr session
         */
        session: XRSession;
        /**
         * The viewer (head position) reference space. This can be used to get the XR world coordinates
         * or get the offset the player is currently at.
         */
        viewerReferenceSpace: XRReferenceSpace;
        /**
         * Constructs a WebXRSessionManager, this must be initialized within a user action before usage
         * @param scene The scene which the session should be created for
         */
        constructor(
        /** The scene which the session should be created for */
        scene: Scene);
        /**
         * The current reference space used in this session. This reference space can constantly change!
         * It is mainly used to offset the camera's position.
         */
        get referenceSpace(): XRReferenceSpace;
        /**
         * Set a new reference space and triggers the observable
         */
        set referenceSpace(newReferenceSpace: XRReferenceSpace);
        /**
         * Disposes of the session manager
         */
        dispose(): void;
        /**
         * Stops the xrSession and restores the render loop
         * @returns Promise which resolves after it exits XR
         */
        exitXRAsync(): Promise<void>;
        /**
         * Gets the correct render target texture to be rendered this frame for this eye
         * @param eye the eye for which to get the render target
         * @returns the render target for the specified eye
         */
        getRenderTargetTextureForEye(eye: XREye): RenderTargetTexture;
        /**
         * Creates a WebXRRenderTarget object for the XR session
         * @param onStateChangedObservable optional, mechanism for enabling/disabling XR rendering canvas, used only on Web
         * @param options optional options to provide when creating a new render target
         * @returns a WebXR render target to which the session can render
         */
        getWebXRRenderTarget(options?: WebXRManagedOutputCanvasOptions): WebXRRenderTarget;
        /**
         * Initializes the manager
         * After initialization enterXR can be called to start an XR session
         * @returns Promise which resolves after it is initialized
         */
        initializeAsync(): Promise<void>;
        /**
         * Initializes an xr session
         * @param xrSessionMode mode to initialize
         * @param xrSessionInit defines optional and required values to pass to the session builder
         * @returns a promise which will resolve once the session has been initialized
         */
        initializeSessionAsync(xrSessionMode?: XRSessionMode, xrSessionInit?: XRSessionInit): Promise<XRSession>;
        /**
         * Checks if a session would be supported for the creation options specified
         * @param sessionMode session mode to check if supported eg. immersive-vr
         * @returns A Promise that resolves to true if supported and false if not
         */
        isSessionSupportedAsync(sessionMode: XRSessionMode): Promise<boolean>;
        /**
         * Resets the reference space to the one started the session
         */
        resetReferenceSpace(): void;
        /**
         * Starts rendering to the xr layer
         */
        runXRRenderLoop(): void;
        /**
         * Sets the reference space on the xr session
         * @param referenceSpaceType space to set
         * @returns a promise that will resolve once the reference space has been set
         */
        setReferenceSpaceTypeAsync(referenceSpaceType?: XRReferenceSpaceType): Promise<XRReferenceSpace>;
        /**
         * Updates the render state of the session
         * @param state state to set
         * @returns a promise that resolves once the render state has been updated
         */
        updateRenderStateAsync(state: XRRenderState): Promise<void>;
        /**
         * Returns a promise that resolves with a boolean indicating if the provided session mode is supported by this browser
         * @param sessionMode defines the session to test
         * @returns a promise with boolean as final value
         */
        static IsSessionSupportedAsync(sessionMode: XRSessionMode): Promise<boolean>;
        private _createRenderTargetTexture;
    }
}
declare module BABYLON {
    /**
     * WebXR Camera which holds the views for the xrSession
     * @see https://doc.babylonjs.com/how_to/webxr_camera
     */
    export class WebXRCamera extends FreeCamera {
        private _xrSessionManager;
        private _firstFrame;
        private _referenceQuaternion;
        private _referencedPosition;
        private _xrInvPositionCache;
        private _xrInvQuaternionCache;
        /**
         * Observable raised before camera teleportation
         */
        onBeforeCameraTeleport: Observable<Vector3>;
        /**
         *  Observable raised after camera teleportation
         */
        onAfterCameraTeleport: Observable<Vector3>;
        /**
         * Should position compensation execute on first frame.
         * This is used when copying the position from a native (non XR) camera
         */
        compensateOnFirstFrame: boolean;
        /**
         * Creates a new webXRCamera, this should only be set at the camera after it has been updated by the xrSessionManager
         * @param name the name of the camera
         * @param scene the scene to add the camera to
         * @param _xrSessionManager a constructed xr session manager
         */
        constructor(name: string, scene: Scene, _xrSessionManager: WebXRSessionManager);
        /**
         * Return the user's height, unrelated to the current ground.
         * This will be the y position of this camera, when ground level is 0.
         */
        get realWorldHeight(): number;
        /** @hidden */
        _updateForDualEyeDebugging(): void;
        /**
         * Sets this camera's transformation based on a non-vr camera
         * @param otherCamera the non-vr camera to copy the transformation from
         * @param resetToBaseReferenceSpace should XR reset to the base reference space
         */
        setTransformationFromNonVRCamera(otherCamera?: Camera, resetToBaseReferenceSpace?: boolean): void;
        /**
         * Gets the current instance class name ("WebXRCamera").
         * @returns the class name
         */
        getClassName(): string;
        private _rotate180;
        private _updateFromXRSession;
        private _updateNumberOfRigCameras;
        private _updateReferenceSpace;
        private _updateReferenceSpaceOffset;
    }
}
declare module BABYLON {
    /**
     * Defining the interface required for a (webxr) feature
     */
    export interface IWebXRFeature extends IDisposable {
        /**
         * Is this feature attached
         */
        attached: boolean;
        /**
         * Should auto-attach be disabled?
         */
        disableAutoAttach: boolean;
        /**
         * Attach the feature to the session
         * Will usually be called by the features manager
         *
         * @param force should attachment be forced (even when already attached)
         * @returns true if successful.
         */
        attach(force?: boolean): boolean;
        /**
         * Detach the feature from the session
         * Will usually be called by the features manager
         *
         * @returns true if successful.
         */
        detach(): boolean;
        /**
         * This function will be executed during before enabling the feature and can be used to not-allow enabling it.
         * Note that at this point the session has NOT started, so this is purely checking if the browser supports it
         *
         * @returns whether or not the feature is compatible in this environment
         */
        isCompatible(): boolean;
        /**
         * Was this feature disposed;
         */
        isDisposed: boolean;
        /**
         * The name of the native xr feature name, if applicable (like anchor, hit-test, or hand-tracking)
         */
        xrNativeFeatureName?: string;
        /**
         * A list of (Babylon WebXR) features this feature depends on
         */
        dependsOn?: string[];
    }
    /**
     * A list of the currently available features without referencing them
     */
    export class WebXRFeatureName {
        /**
         * The name of the anchor system feature
         */
        static readonly ANCHOR_SYSTEM: string;
        /**
         * The name of the background remover feature
         */
        static readonly BACKGROUND_REMOVER: string;
        /**
         * The name of the hit test feature
         */
        static readonly HIT_TEST: string;
        /**
         * physics impostors for xr controllers feature
         */
        static readonly PHYSICS_CONTROLLERS: string;
        /**
         * The name of the plane detection feature
         */
        static readonly PLANE_DETECTION: string;
        /**
         * The name of the pointer selection feature
         */
        static readonly POINTER_SELECTION: string;
        /**
         * The name of the teleportation feature
         */
        static readonly TELEPORTATION: string;
        /**
         * The name of the feature points feature.
         */
        static readonly FEATURE_POINTS: string;
        /**
         * The name of the hand tracking feature.
         */
        static readonly HAND_TRACKING: string;
    }
    /**
     * Defining the constructor of a feature. Used to register the modules.
     */
    export type WebXRFeatureConstructor = (xrSessionManager: WebXRSessionManager, options?: any) => () => IWebXRFeature;
    /**
     * The WebXR features manager is responsible of enabling or disabling features required for the current XR session.
     * It is mainly used in AR sessions.
     *
     * A feature can have a version that is defined by Babylon (and does not correspond with the webxr version).
     */
    export class WebXRFeaturesManager implements IDisposable {
        private _xrSessionManager;
        private static readonly _AvailableFeatures;
        private _features;
        /**
         * constructs a new features manages.
         *
         * @param _xrSessionManager an instance of WebXRSessionManager
         */
        constructor(_xrSessionManager: WebXRSessionManager);
        /**
         * Used to register a module. After calling this function a developer can use this feature in the scene.
         * Mainly used internally.
         *
         * @param featureName the name of the feature to register
         * @param constructorFunction the function used to construct the module
         * @param version the (babylon) version of the module
         * @param stable is that a stable version of this module
         */
        static AddWebXRFeature(featureName: string, constructorFunction: WebXRFeatureConstructor, version?: number, stable?: boolean): void;
        /**
         * Returns a constructor of a specific feature.
         *
         * @param featureName the name of the feature to construct
         * @param version the version of the feature to load
         * @param xrSessionManager the xrSessionManager. Used to construct the module
         * @param options optional options provided to the module.
         * @returns a function that, when called, will return a new instance of this feature
         */
        static ConstructFeature(featureName: string, version: number | undefined, xrSessionManager: WebXRSessionManager, options?: any): () => IWebXRFeature;
        /**
         * Can be used to return the list of features currently registered
         *
         * @returns an Array of available features
         */
        static GetAvailableFeatures(): string[];
        /**
         * Gets the versions available for a specific feature
         * @param featureName the name of the feature
         * @returns an array with the available versions
         */
        static GetAvailableVersions(featureName: string): string[];
        /**
         * Return the latest unstable version of this feature
         * @param featureName the name of the feature to search
         * @returns the version number. if not found will return -1
         */
        static GetLatestVersionOfFeature(featureName: string): number;
        /**
         * Return the latest stable version of this feature
         * @param featureName the name of the feature to search
         * @returns the version number. if not found will return -1
         */
        static GetStableVersionOfFeature(featureName: string): number;
        /**
         * Attach a feature to the current session. Mainly used when session started to start the feature effect.
         * Can be used during a session to start a feature
         * @param featureName the name of feature to attach
         */
        attachFeature(featureName: string): void;
        /**
         * Can be used inside a session or when the session ends to detach a specific feature
         * @param featureName the name of the feature to detach
         */
        detachFeature(featureName: string): void;
        /**
         * Used to disable an already-enabled feature
         * The feature will be disposed and will be recreated once enabled.
         * @param featureName the feature to disable
         * @returns true if disable was successful
         */
        disableFeature(featureName: string | {
            Name: string;
        }): boolean;
        /**
         * dispose this features manager
         */
        dispose(): void;
        /**
         * Enable a feature using its name and a version. This will enable it in the scene, and will be responsible to attach it when the session starts.
         * If used twice, the old version will be disposed and a new one will be constructed. This way you can re-enable with different configuration.
         *
         * @param featureName the name of the feature to load or the class of the feature
         * @param version optional version to load. if not provided the latest version will be enabled
         * @param moduleOptions options provided to the module. Ses the module documentation / constructor
         * @param attachIfPossible if set to true (default) the feature will be automatically attached, if it is currently possible
         * @param required is this feature required to the app. If set to true the session init will fail if the feature is not available.
         * @returns a new constructed feature or throws an error if feature not found.
         */
        enableFeature(featureName: string | {
            Name: string;
        }, version?: number | string, moduleOptions?: any, attachIfPossible?: boolean, required?: boolean): IWebXRFeature;
        /**
         * get the implementation of an enabled feature.
         * @param featureName the name of the feature to load
         * @returns the feature class, if found
         */
        getEnabledFeature(featureName: string): IWebXRFeature;
        /**
         * Get the list of enabled features
         * @returns an array of enabled features
         */
        getEnabledFeatures(): string[];
        /**
         * This function will exten the session creation configuration object with enabled features.
         * If, for example, the anchors feature is enabled, it will be automatically added to the optional or required features list,
         * according to the defined "required" variable, provided during enableFeature call
         * @param xrSessionInit the xr Session init object to extend
         *
         * @returns an extended XRSessionInit object
         */
        extendXRSessionInitObject(xrSessionInit: XRSessionInit): XRSessionInit;
    }
}
declare module BABYLON {
    /**
     * Base set of functionality needed to create an XR experience (WebXRSessionManager, Camera, StateManagement, etc.)
     * @see https://doc.babylonjs.com/how_to/webxr_experience_helpers
     */
    export class WebXRExperienceHelper implements IDisposable {
        private scene;
        private _nonVRCamera;
        private _originalSceneAutoClear;
        private _supported;
        /**
         * Camera used to render xr content
         */
        camera: WebXRCamera;
        /** A features manager for this xr session */
        featuresManager: WebXRFeaturesManager;
        /**
         * Observers registered here will be triggered after the camera's initial transformation is set
         * This can be used to set a different ground level or an extra rotation.
         *
         * Note that ground level is considered to be at 0. The height defined by the XR camera will be added
         * to the position set after this observable is done executing.
         */
        onInitialXRPoseSetObservable: Observable<WebXRCamera>;
        /**
         * Fires when the state of the experience helper has changed
         */
        onStateChangedObservable: Observable<WebXRState>;
        /** Session manager used to keep track of xr session */
        sessionManager: WebXRSessionManager;
        /**
         * The current state of the XR experience (eg. transitioning, in XR or not in XR)
         */
        state: WebXRState;
        /**
         * Creates a WebXRExperienceHelper
         * @param scene The scene the helper should be created in
         */
        private constructor();
        /**
         * Creates the experience helper
         * @param scene the scene to attach the experience helper to
         * @returns a promise for the experience helper
         */
        static CreateAsync(scene: Scene): Promise<WebXRExperienceHelper>;
        /**
         * Disposes of the experience helper
         */
        dispose(): void;
        /**
         * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)
         * @param sessionMode options for the XR session
         * @param referenceSpaceType frame of reference of the XR session
         * @param renderTarget the output canvas that will be used to enter XR mode
         * @param sessionCreationOptions optional XRSessionInit object to init the session with
         * @returns promise that resolves after xr mode has entered
         */
        enterXRAsync(sessionMode: XRSessionMode, referenceSpaceType: XRReferenceSpaceType, renderTarget?: WebXRRenderTarget, sessionCreationOptions?: XRSessionInit): Promise<WebXRSessionManager>;
        /**
         * Exits XR mode and returns the scene to its original state
         * @returns promise that resolves after xr mode has exited
         */
        exitXRAsync(): Promise<void>;
        private _nonXRToXRCamera;
        private _setState;
    }
}
declare module BABYLON {
    /**
     * X-Y values for axes in WebXR
     */
    export interface IWebXRMotionControllerAxesValue {
        /**
         * The value of the x axis
         */
        x: number;
        /**
         * The value of the y-axis
         */
        y: number;
    }
    /**
     * changed / previous values for the values of this component
     */
    export interface IWebXRMotionControllerComponentChangesValues<T> {
        /**
         * current (this frame) value
         */
        current: T;
        /**
         * previous (last change) value
         */
        previous: T;
    }
    /**
     * Represents changes in the component between current frame and last values recorded
     */
    export interface IWebXRMotionControllerComponentChanges {
        /**
         * will be populated with previous and current values if axes changed
         */
        axes?: IWebXRMotionControllerComponentChangesValues<IWebXRMotionControllerAxesValue>;
        /**
         * will be populated with previous and current values if pressed changed
         */
        pressed?: IWebXRMotionControllerComponentChangesValues<boolean>;
        /**
         * will be populated with previous and current values if touched changed
         */
        touched?: IWebXRMotionControllerComponentChangesValues<boolean>;
        /**
         * will be populated with previous and current values if value changed
         */
        value?: IWebXRMotionControllerComponentChangesValues<number>;
    }
    /**
     * This class represents a single component (for example button or thumbstick) of a motion controller
     */
    export class WebXRControllerComponent implements IDisposable {
        /**
         * the id of this component
         */
        id: string;
        /**
         * the type of the component
         */
        type: MotionControllerComponentType;
        private _buttonIndex;
        private _axesIndices;
        private _axes;
        private _changes;
        private _currentValue;
        private _hasChanges;
        private _pressed;
        private _touched;
        /**
         * button component type
         */
        static BUTTON_TYPE: MotionControllerComponentType;
        /**
         * squeeze component type
         */
        static SQUEEZE_TYPE: MotionControllerComponentType;
        /**
         * Thumbstick component type
         */
        static THUMBSTICK_TYPE: MotionControllerComponentType;
        /**
         * Touchpad component type
         */
        static TOUCHPAD_TYPE: MotionControllerComponentType;
        /**
         * trigger component type
         */
        static TRIGGER_TYPE: MotionControllerComponentType;
        /**
         * If axes are available for this component (like a touchpad or thumbstick) the observers will be notified when
         * the axes data changes
         */
        onAxisValueChangedObservable: Observable<{
            x: number;
            y: number;
        }>;
        /**
         * Observers registered here will be triggered when the state of a button changes
         * State change is either pressed / touched / value
         */
        onButtonStateChangedObservable: Observable<WebXRControllerComponent>;
        /**
         * Creates a new component for a motion controller.
         * It is created by the motion controller itself
         *
         * @param id the id of this component
         * @param type the type of the component
         * @param _buttonIndex index in the buttons array of the gamepad
         * @param _axesIndices indices of the values in the axes array of the gamepad
         */
        constructor(
        /**
         * the id of this component
         */
        id: string, 
        /**
         * the type of the component
         */
        type: MotionControllerComponentType, _buttonIndex?: number, _axesIndices?: number[]);
        /**
         * The current axes data. If this component has no axes it will still return an object { x: 0, y: 0 }
         */
        get axes(): IWebXRMotionControllerAxesValue;
        /**
         * Get the changes. Elements will be populated only if they changed with their previous and current value
         */
        get changes(): IWebXRMotionControllerComponentChanges;
        /**
         * Return whether or not the component changed the last frame
         */
        get hasChanges(): boolean;
        /**
         * is the button currently pressed
         */
        get pressed(): boolean;
        /**
         * is the button currently touched
         */
        get touched(): boolean;
        /**
         * Get the current value of this component
         */
        get value(): number;
        /**
         * Dispose this component
         */
        dispose(): void;
        /**
         * Are there axes correlating to this component
         * @return true is axes data is available
         */
        isAxes(): boolean;
        /**
         * Is this component a button (hence - pressable)
         * @returns true if can be pressed
         */
        isButton(): boolean;
        /**
         * update this component using the gamepad object it is in. Called on every frame
         * @param nativeController the native gamepad controller object
         */
        update(nativeController: IMinimalMotionControllerObject): void;
    }
}
declare module BABYLON {
    /**
     * Interface used to represent data loading progression
     */
    export interface ISceneLoaderProgressEvent {
        /**
         * Defines if data length to load can be evaluated
         */
        readonly lengthComputable: boolean;
        /**
         * Defines the loaded data length
         */
        readonly loaded: number;
        /**
         * Defines the data length to load
         */
        readonly total: number;
    }
    /**
     * Interface used by SceneLoader plugins to define supported file extensions
     */
    export interface ISceneLoaderPluginExtensions {
        /**
         * Defines the list of supported extensions
         */
        [extension: string]: {
            isBinary: boolean;
        };
    }
    /**
     * Interface used by SceneLoader plugin factory
     */
    export interface ISceneLoaderPluginFactory {
        /**
         * Defines the name of the factory
         */
        name: string;
        /**
         * Function called to create a new plugin
         * @return the new plugin
         */
        createPlugin(): ISceneLoaderPlugin | ISceneLoaderPluginAsync;
        /**
         * The callback that returns true if the data can be directly loaded.
         * @param data string containing the file data
         * @returns if the data can be loaded directly
         */
        canDirectLoad?(data: string): boolean;
    }
    /**
     * Interface used to define the base of ISceneLoaderPlugin and ISceneLoaderPluginAsync
     */
    export interface ISceneLoaderPluginBase {
        /**
         * The friendly name of this plugin.
         */
        name: string;
        /**
         * The file extensions supported by this plugin.
         */
        extensions: string | ISceneLoaderPluginExtensions;
        /**
         * The callback called when loading from a url.
         * @param scene scene loading this url
         * @param url url to load
         * @param onSuccess callback called when the file successfully loads
         * @param onProgress callback called while file is loading (if the server supports this mode)
         * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer
         * @param onError callback called when the file fails to load
         * @returns a file request object
         */
        requestFile?(scene: Scene, url: string, onSuccess: (data: any, request?: WebRequest) => void, onProgress?: (ev: ISceneLoaderProgressEvent) => void, useArrayBuffer?: boolean, onError?: (error: any) => void): IFileRequest;
        /**
         * The callback called when loading from a file object.
         * @param scene scene loading this file
         * @param file defines the file to load
         * @param onSuccess defines the callback to call when data is loaded
         * @param onProgress defines the callback to call during loading process
         * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer
         * @param onError defines the callback to call when an error occurs
         * @returns a file request object
         */
        readFile?(scene: Scene, file: File, onSuccess: (data: any) => void, onProgress?: (ev: ISceneLoaderProgressEvent) => any, useArrayBuffer?: boolean, onError?: (error: any) => void): IFileRequest;
        /**
         * The callback that returns true if the data can be directly loaded.
         * @param data string containing the file data
         * @returns if the data can be loaded directly
         */
        canDirectLoad?(data: string): boolean;
        /**
         * The callback that returns the data to pass to the plugin if the data can be directly loaded.
         * @param scene scene loading this data
         * @param data string containing the data
         * @returns data to pass to the plugin
         */
        directLoad?(scene: Scene, data: string): any;
        /**
         * The callback that allows custom handling of the root url based on the response url.
         * @param rootUrl the original root url
         * @param responseURL the response url if available
         * @returns the new root url
         */
        rewriteRootURL?(rootUrl: string, responseURL?: string): string;
    }
    /**
     * Interface used to define a SceneLoader plugin
     */
    export interface ISceneLoaderPlugin extends ISceneLoaderPluginBase {
        /**
         * Import meshes into a scene.
         * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
         * @param scene The scene to import into
         * @param data The data to import
         * @param rootUrl The root url for scene and resources
         * @param meshes The meshes array to import into
         * @param particleSystems The particle systems array to import into
         * @param skeletons The skeletons array to import into
         * @param onError The callback when import fails
         * @returns True if successful or false otherwise
         */
        importMesh(meshesNames: any, scene: Scene, data: any, rootUrl: string, meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], onError?: (message: string, exception?: any) => void): boolean;
        /**
         * Load into a scene.
         * @param scene The scene to load into
         * @param data The data to import
         * @param rootUrl The root url for scene and resources
         * @param onError The callback when import fails
         * @returns True if successful or false otherwise
         */
        load(scene: Scene, data: any, rootUrl: string, onError?: (message: string, exception?: any) => void): boolean;
        /**
         * Load into an asset container.
         * @param scene The scene to load into
         * @param data The data to import
         * @param rootUrl The root url for scene and resources
         * @param onError The callback when import fails
         * @returns The loaded asset container
         */
        loadAssetContainer(scene: Scene, data: any, rootUrl: string, onError?: (message: string, exception?: any) => void): AssetContainer;
    }
    /**
     * Interface used to define an async SceneLoader plugin
     */
    export interface ISceneLoaderPluginAsync extends ISceneLoaderPluginBase {
        /**
         * Import meshes into a scene.
         * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
         * @param scene The scene to import into
         * @param data The data to import
         * @param rootUrl The root url for scene and resources
         * @param onProgress The callback when the load progresses
         * @param fileName Defines the name of the file to load
         * @returns The loaded meshes, particle systems, skeletons, and animation groups
         */
        importMeshAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<{
            meshes: AbstractMesh[];
            particleSystems: IParticleSystem[];
            skeletons: Skeleton[];
            animationGroups: AnimationGroup[];
        }>;
        /**
         * Load into a scene.
         * @param scene The scene to load into
         * @param data The data to import
         * @param rootUrl The root url for scene and resources
         * @param onProgress The callback when the load progresses
         * @param fileName Defines the name of the file to load
         * @returns Nothing
         */
        loadAsync(scene: Scene, data: any, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<void>;
        /**
         * Load into an asset container.
         * @param scene The scene to load into
         * @param data The data to import
         * @param rootUrl The root url for scene and resources
         * @param onProgress The callback when the load progresses
         * @param fileName Defines the name of the file to load
         * @returns The loaded asset container
         */
        loadAssetContainerAsync(scene: Scene, data: any, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<AssetContainer>;
    }
    /**
     * Mode that determines how to handle old animation groups before loading new ones.
     */
    export enum SceneLoaderAnimationGroupLoadingMode {
        /**
         * Reset all old animations to initial state then dispose them.
         */
        Clean = 0,
        /**
         * Stop all old animations.
         */
        Stop = 1,
        /**
         * Restart old animations from first frame.
         */
        Sync = 2,
        /**
         * Old animations remains untouched.
         */
        NoSync = 3
    }
    /**
     * Defines a plugin registered by the SceneLoader
     */
    interface IRegisteredPlugin {
        /**
         * Defines the plugin to use
         */
        plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory;
        /**
         * Defines if the plugin supports binary data
         */
        isBinary: boolean;
    }
    /**
     * Class used to load scene from various file formats using registered plugins
     * @see https://doc.babylonjs.com/how_to/load_from_any_file_type
     */
    export class SceneLoader {
        /**
         * No logging while loading
         */
        static readonly NO_LOGGING: number;
        /**
         * Minimal logging while loading
         */
        static readonly MINIMAL_LOGGING: number;
        /**
         * Summary logging while loading
         */
        static readonly SUMMARY_LOGGING: number;
        /**
         * Detailled logging while loading
         */
        static readonly DETAILED_LOGGING: number;
        /**
         * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data
         */
        static get ForceFullSceneLoadingForIncremental(): boolean;
        static set ForceFullSceneLoadingForIncremental(value: boolean);
        /**
         * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene
         */
        static get ShowLoadingScreen(): boolean;
        static set ShowLoadingScreen(value: boolean);
        /**
         * Defines the current logging level (while loading the scene)
         * @ignorenaming
         */
        static get loggingLevel(): number;
        static set loggingLevel(value: number);
        /**
         * Gets or set a boolean indicating if matrix weights must be cleaned upon loading
         */
        static get CleanBoneMatrixWeights(): boolean;
        static set CleanBoneMatrixWeights(value: boolean);
        /**
         * Event raised when a plugin is used to load a scene
         */
        static OnPluginActivatedObservable: Observable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>;
        private static _registeredPlugins;
        private static _showingLoadingScreen;
        /**
         * Gets the default plugin (used to load Babylon files)
         * @returns the .babylon plugin
         */
        static GetDefaultPlugin(): IRegisteredPlugin;
        private static _GetPluginForExtension;
        private static _GetPluginForDirectLoad;
        private static _GetPluginForFilename;
        private static _GetDirectLoad;
        private static _LoadData;
        private static _GetFileInfo;
        /**
         * Gets a plugin that can load the given extension
         * @param extension defines the extension to load
         * @returns a plugin or null if none works
         */
        static GetPluginForExtension(extension: string): ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory;
        /**
         * Gets a boolean indicating that the given extension can be loaded
         * @param extension defines the extension to load
         * @returns true if the extension is supported
         */
        static IsPluginForExtensionAvailable(extension: string): boolean;
        /**
         * Adds a new plugin to the list of registered plugins
         * @param plugin defines the plugin to add
         */
        static RegisterPlugin(plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync): void;
        /**
         * Import meshes into a scene
         * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
         * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
         * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
         * @param scene the instance of BABYLON.Scene to append to
         * @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds
         * @param onProgress a callback with a progress event for each file being loaded
         * @param onError a callback with the scene, a message, and possibly an exception when import fails
         * @param pluginExtension the extension used to determine the plugin
         * @returns The loaded plugin
         */
        static ImportMesh(meshNames: any, rootUrl: string, sceneFilename?: string | File, scene?: Nullable<Scene>, onSuccess?: Nullable<(meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], animationGroups: AnimationGroup[]) => void>, onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>, onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>, pluginExtension?: Nullable<string>): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>;
        /**
         * Import meshes into a scene
         * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
         * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
         * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
         * @param scene the instance of BABYLON.Scene to append to
         * @param onProgress a callback with a progress event for each file being loaded
         * @param pluginExtension the extension used to determine the plugin
         * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups
         */
        static ImportMeshAsync(meshNames: any, rootUrl: string, sceneFilename?: string | File, scene?: Nullable<Scene>, onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>, pluginExtension?: Nullable<string>): Promise<{
            meshes: AbstractMesh[];
            particleSystems: IParticleSystem[];
            skeletons: Skeleton[];
            animationGroups: AnimationGroup[];
        }>;
        /**
         * Load a scene
         * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
         * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
         * @param engine is the instance of BABYLON.Engine to use to create the scene
         * @param onSuccess a callback with the scene when import succeeds
         * @param onProgress a callback with a progress event for each file being loaded
         * @param onError a callback with the scene, a message, and possibly an exception when import fails
         * @param pluginExtension the extension used to determine the plugin
         * @returns The loaded plugin
         */
        static Load(rootUrl: string, sceneFilename?: string | File, engine?: Nullable<Engine>, onSuccess?: Nullable<(scene: Scene) => void>, onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>, onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>, pluginExtension?: Nullable<string>): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>;
        /**
         * Load a scene
         * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
         * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
         * @param engine is the instance of BABYLON.Engine to use to create the scene
         * @param onProgress a callback with a progress event for each file being loaded
         * @param pluginExtension the extension used to determine the plugin
         * @returns The loaded scene
         */
        static LoadAsync(rootUrl: string, sceneFilename?: string | File, engine?: Nullable<Engine>, onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>, pluginExtension?: Nullable<string>): Promise<Scene>;
        /**
         * Append a scene
         * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
         * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
         * @param scene is the instance of BABYLON.Scene to append to
         * @param onSuccess a callback with the scene when import succeeds
         * @param onProgress a callback with a progress event for each file being loaded
         * @param onError a callback with the scene, a message, and possibly an exception when import fails
         * @param pluginExtension the extension used to determine the plugin
         * @returns The loaded plugin
         */
        static Append(rootUrl: string, sceneFilename?: string | File, scene?: Nullable<Scene>, onSuccess?: Nullable<(scene: Scene) => void>, onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>, onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>, pluginExtension?: Nullable<string>): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>;
        /**
         * Append a scene
         * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
         * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
         * @param scene is the instance of BABYLON.Scene to append to
         * @param onProgress a callback with a progress event for each file being loaded
         * @param pluginExtension the extension used to determine the plugin
         * @returns The given scene
         */
        static AppendAsync(rootUrl: string, sceneFilename?: string | File, scene?: Nullable<Scene>, onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>, pluginExtension?: Nullable<string>): Promise<Scene>;
        /**
         * Load a scene into an asset container
         * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
         * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
         * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
         * @param onSuccess a callback with the scene when import succeeds
         * @param onProgress a callback with a progress event for each file being loaded
         * @param onError a callback with the scene, a message, and possibly an exception when import fails
         * @param pluginExtension the extension used to determine the plugin
         * @returns The loaded plugin
         */
        static LoadAssetContainer(rootUrl: string, sceneFilename?: string | File, scene?: Nullable<Scene>, onSuccess?: Nullable<(assets: AssetContainer) => void>, onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>, onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>, pluginExtension?: Nullable<string>): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>;
        /**
         * Load a scene into an asset container
         * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
         * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene (default: empty string)
         * @param scene is the instance of Scene to append to
         * @param onProgress a callback with a progress event for each file being loaded
         * @param pluginExtension the extension used to determine the plugin
         * @returns The loaded asset container
         */
        static LoadAssetContainerAsync(rootUrl: string, sceneFilename?: string, scene?: Nullable<Scene>, onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>, pluginExtension?: Nullable<string>): Promise<AssetContainer>;
        /**
         * Import animations from a file into a scene
         * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
         * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
         * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
         * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise
         * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones
         * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)
         * @param onSuccess a callback with the scene when import succeeds
         * @param onProgress a callback with a progress event for each file being loaded
         * @param onError a callback with the scene, a message, and possibly an exception when import fails
         * @param pluginExtension the extension used to determine the plugin
         */
        static ImportAnimations(rootUrl: string, sceneFilename?: string | File, scene?: Nullable<Scene>, overwriteAnimations?: boolean, animationGroupLoadingMode?: SceneLoaderAnimationGroupLoadingMode, targetConverter?: Nullable<(target: any) => any>, onSuccess?: Nullable<(scene: Scene) => void>, onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>, onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>, pluginExtension?: Nullable<string>): void;
        /**
         * Import animations from a file into a scene
         * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
         * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
         * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
         * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise
         * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones
         * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)
         * @param onSuccess a callback with the scene when import succeeds
         * @param onProgress a callback with a progress event for each file being loaded
         * @param onError a callback with the scene, a message, and possibly an exception when import fails
         * @param pluginExtension the extension used to determine the plugin
         * @returns the updated scene with imported animations
         */
        static ImportAnimationsAsync(rootUrl: string, sceneFilename?: string | File, scene?: Nullable<Scene>, overwriteAnimations?: boolean, animationGroupLoadingMode?: SceneLoaderAnimationGroupLoadingMode, targetConverter?: Nullable<(target: any) => any>, onSuccess?: Nullable<(scene: Scene) => void>, onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>, onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>, pluginExtension?: Nullable<string>): Promise<Scene>;
    }
}
declare module BABYLON {
    /**
     * Handedness type in xrInput profiles. These can be used to define layouts in the Layout Map.
     */
    export type MotionControllerHandedness = "none" | "left" | "right";
    /**
     * The type of components available in motion controllers.
     * This is not the name of the component.
     */
    export type MotionControllerComponentType = "trigger" | "squeeze" | "touchpad" | "thumbstick" | "button";
    /**
     * The state of a controller component
     */
    export type MotionControllerComponentStateType = "default" | "touched" | "pressed";
    /**
     * The schema of motion controller layout.
     * No object will be initialized using this interface
     * This is used just to define the profile.
     */
    export interface IMotionControllerLayout {
        /**
         * Path to load the assets. Usually relative to the base path
         */
        assetPath: string;
        /**
         * Available components (unsorted)
         */
        components: {
            /**
             * A map of component Ids
             */
            [componentId: string]: {
                /**
                 * The type of input the component outputs
                 */
                type: MotionControllerComponentType;
                /**
                 * The indices of this component in the gamepad object
                 */
                gamepadIndices: {
                    /**
                     * Index of button
                     */
                    button?: number;
                    /**
                     * If available, index of x-axis
                     */
                    xAxis?: number;
                    /**
                     * If available, index of y-axis
                     */
                    yAxis?: number;
                };
                /**
                 * The mesh's root node name
                 */
                rootNodeName: string;
                /**
                 * Animation definitions for this model
                 */
                visualResponses: {
                    [stateKey: string]: {
                        /**
                         * What property will be animated
                         */
                        componentProperty: "xAxis" | "yAxis" | "button" | "state";
                        /**
                         * What states influence this visual response
                         */
                        states: MotionControllerComponentStateType[];
                        /**
                         * Type of animation - movement or visibility
                         */
                        valueNodeProperty: "transform" | "visibility";
                        /**
                         * Base node name to move. Its position will be calculated according to the min and max nodes
                         */
                        valueNodeName?: string;
                        /**
                         * Minimum movement node
                         */
                        minNodeName?: string;
                        /**
                         * Max movement node
                         */
                        maxNodeName?: string;
                    };
                };
                /**
                 * If touch enabled, what is the name of node to display user feedback
                 */
                touchPointNodeName?: string;
            };
        };
        /**
         * Is it xr standard mapping or not
         */
        gamepadMapping: "" | "xr-standard";
        /**
         * Base root node of this entire model
         */
        rootNodeName: string;
        /**
         * Defines the main button component id
         */
        selectComponentId: string;
    }
    /**
     * A definition for the layout map in the input profile
     */
    export interface IMotionControllerLayoutMap {
        /**
         * Layouts with handedness type as a key
         */
        [handedness: string]: IMotionControllerLayout;
    }
    /**
     * The XR Input profile schema
     * Profiles can be found here:
     * https://github.com/immersive-web/webxr-input-profiles/tree/master/packages/registry/profiles
     */
    export interface IMotionControllerProfile {
        /**
         * fallback profiles for this profileId
         */
        fallbackProfileIds: string[];
        /**
         * The layout map, with handedness as key
         */
        layouts: IMotionControllerLayoutMap;
        /**
         * The id of this profile
         * correlates to the profile(s) in the xrInput.profiles array
         */
        profileId: string;
    }
    /**
     * A helper-interface for the 3 meshes needed for controller button animation
     * The meshes are provided to the _lerpButtonTransform function to calculate the current position of the value mesh
     */
    export interface IMotionControllerButtonMeshMap {
        /**
         * the mesh that defines the pressed value mesh position.
         * This is used to find the max-position of this button
         */
        pressedMesh: AbstractMesh;
        /**
         * the mesh that defines the unpressed value mesh position.
         * This is used to find the min (or initial) position of this button
         */
        unpressedMesh: AbstractMesh;
        /**
         * The mesh that will be changed when value changes
         */
        valueMesh: AbstractMesh;
    }
    /**
     * A helper-interface for the 3 meshes needed for controller axis animation.
     * This will be expanded when touchpad animations are fully supported
     * The meshes are provided to the _lerpAxisTransform function to calculate the current position of the value mesh
     */
    export interface IMotionControllerMeshMap {
        /**
         * the mesh that defines the maximum value mesh position.
         */
        maxMesh?: AbstractMesh;
        /**
         * the mesh that defines the minimum value mesh position.
         */
        minMesh?: AbstractMesh;
        /**
         * The mesh that will be changed when axis value changes
         */
        valueMesh?: AbstractMesh;
    }
    /**
     * The elements needed for change-detection of the gamepad objects in motion controllers
     */
    export interface IMinimalMotionControllerObject {
        /**
         * Available axes of this controller
         */
        axes: number[];
        /**
         * An array of available buttons
         */
        buttons: Array<{
            /**
             * Value of the button/trigger
             */
            value: number;
            /**
             * If the button/trigger is currently touched
             */
            touched: boolean;
            /**
             * If the button/trigger is currently pressed
             */
            pressed: boolean;
        }>;
        /**
         * EXPERIMENTAL haptic support.
         */
        hapticActuators?: Array<{
            pulse: (value: number, duration: number) => Promise<boolean>;
        }>;
    }
    /**
     * An Abstract Motion controller
     * This class receives an xrInput and a profile layout and uses those to initialize the components
     * Each component has an observable to check for changes in value and state
     */
    export abstract class WebXRAbstractMotionController implements IDisposable {
        protected scene: Scene;
        protected layout: IMotionControllerLayout;
        /**
         * The gamepad object correlating to this controller
         */
        gamepadObject: IMinimalMotionControllerObject;
        /**
         * handedness (left/right/none) of this controller
         */
        handedness: MotionControllerHandedness;
        private _initComponent;
        private _modelReady;
        /**
         * A map of components (WebXRControllerComponent) in this motion controller
         * Components have a ComponentType and can also have both button and axis definitions
         */
        readonly components: {
            [id: string]: WebXRControllerComponent;
        };
        /**
         * Disable the model's animation. Can be set at any time.
         */
        disableAnimation: boolean;
        /**
         * Observers registered here will be triggered when the model of this controller is done loading
         */
        onModelLoadedObservable: Observable<WebXRAbstractMotionController>;
        /**
         * The profile id of this motion controller
         */
        abstract profileId: string;
        /**
         * The root mesh of the model. It is null if the model was not yet initialized
         */
        rootMesh: Nullable<AbstractMesh>;
        /**
         * constructs a new abstract motion controller
         * @param scene the scene to which the model of the controller will be added
         * @param layout The profile layout to load
         * @param gamepadObject The gamepad object correlating to this controller
         * @param handedness handedness (left/right/none) of this controller
         * @param _doNotLoadControllerMesh set this flag to ignore the mesh loading
         */
        constructor(scene: Scene, layout: IMotionControllerLayout, 
        /**
         * The gamepad object correlating to this controller
         */
        gamepadObject: IMinimalMotionControllerObject, 
        /**
         * handedness (left/right/none) of this controller
         */
        handedness: MotionControllerHandedness, _doNotLoadControllerMesh?: boolean);
        /**
         * Dispose this controller, the model mesh and all its components
         */
        dispose(): void;
        /**
         * Returns all components of specific type
         * @param type the type to search for
         * @return an array of components with this type
         */
        getAllComponentsOfType(type: MotionControllerComponentType): WebXRControllerComponent[];
        /**
         * get a component based an its component id as defined in layout.components
         * @param id the id of the component
         * @returns the component correlates to the id or undefined if not found
         */
        getComponent(id: string): WebXRControllerComponent;
        /**
         * Get the list of components available in this motion controller
         * @returns an array of strings correlating to available components
         */
        getComponentIds(): string[];
        /**
         * Get the first component of specific type
         * @param type type of component to find
         * @return a controller component or null if not found
         */
        getComponentOfType(type: MotionControllerComponentType): Nullable<WebXRControllerComponent>;
        /**
         * Get the main (Select) component of this controller as defined in the layout
         * @returns the main component of this controller
         */
        getMainComponent(): WebXRControllerComponent;
        /**
         * Loads the model correlating to this controller
         * When the mesh is loaded, the onModelLoadedObservable will be triggered
         * @returns A promise fulfilled with the result of the model loading
         */
        loadModel(): Promise<boolean>;
        /**
         * Update this model using the current XRFrame
         * @param xrFrame the current xr frame to use and update the model
         */
        updateFromXRFrame(xrFrame: XRFrame): void;
        /**
         * Backwards compatibility due to a deeply-integrated typo
         */
        get handness(): XREye;
        /**
         * Pulse (vibrate) this controller
         * If the controller does not support pulses, this function will fail silently and return Promise<false> directly after called
         * Consecutive calls to this function will cancel the last pulse call
         *
         * @param value the strength of the pulse in 0.0...1.0 range
         * @param duration Duration of the pulse in milliseconds
         * @param hapticActuatorIndex optional index of actuator (will usually be 0)
         * @returns a promise that will send true when the pulse has ended and false if the device doesn't support pulse or an error accrued
         */
        pulse(value: number, duration: number, hapticActuatorIndex?: number): Promise<boolean>;
        protected _getChildByName(node: AbstractMesh, name: string): AbstractMesh | undefined;
        protected _getImmediateChildByName(node: AbstractMesh, name: string): AbstractMesh | undefined;
        /**
         * Moves the axis on the controller mesh based on its current state
         * @param axis the index of the axis
         * @param axisValue the value of the axis which determines the meshes new position
         * @hidden
         */
        protected _lerpTransform(axisMap: IMotionControllerMeshMap, axisValue: number, fixValueCoordinates?: boolean): void;
        /**
         * Update the model itself with the current frame data
         * @param xrFrame the frame to use for updating the model mesh
         */
        protected updateModel(xrFrame: XRFrame): void;
        /**
         * Get the filename and path for this controller's model
         * @returns a map of filename and path
         */
        protected abstract _getFilenameAndPath(): {
            filename: string;
            path: string;
        };
        /**
         * This function is called before the mesh is loaded. It checks for loading constraints.
         * For example, this function can check if the GLB loader is available
         * If this function returns false, the generic controller will be loaded instead
         * @returns Is the client ready to load the mesh
         */
        protected abstract _getModelLoadingConstraints(): boolean;
        /**
         * This function will be called after the model was successfully loaded and can be used
         * for mesh transformations before it is available for the user
         * @param meshes the loaded meshes
         */
        protected abstract _processLoadedModel(meshes: AbstractMesh[]): void;
        /**
         * Set the root mesh for this controller. Important for the WebXR controller class
         * @param meshes the loaded meshes
         */
        protected abstract _setRootMesh(meshes: AbstractMesh[]): void;
        /**
         * A function executed each frame that updates the mesh (if needed)
         * @param xrFrame the current xrFrame
         */
        protected abstract _updateModel(xrFrame: XRFrame): void;
        private _getGenericFilenameAndPath;
        private _getGenericParentMesh;
    }
}
declare module BABYLON {
    /**
     * A generic trigger-only motion controller for WebXR
     */
    export class WebXRGenericTriggerMotionController extends WebXRAbstractMotionController {
        /**
         * Static version of the profile id of this controller
         */
        static ProfileId: string;
        profileId: string;
        constructor(scene: Scene, gamepadObject: IMinimalMotionControllerObject, handedness: MotionControllerHandedness);
        protected _getFilenameAndPath(): {
            filename: string;
            path: string;
        };
        protected _getModelLoadingConstraints(): boolean;
        protected _processLoadedModel(meshes: AbstractMesh[]): void;
        protected _setRootMesh(meshes: AbstractMesh[]): void;
        protected _updateModel(): void;
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class SphereBuilder {
        /**
         * Creates a sphere mesh
         * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)
         * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)
         * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)
         * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio
         * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the sphere mesh
         * @see https://doc.babylonjs.com/how_to/set_shapes#sphere
         */
        static CreateSphere(name: string, options: {
            segments?: number;
            diameter?: number;
            diameterX?: number;
            diameterY?: number;
            diameterZ?: number;
            arc?: number;
            slice?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            updatable?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
    }
}
declare module BABYLON {
    /**
     * A profiled motion controller has its profile loaded from an online repository.
     * The class is responsible of loading the model, mapping the keys and enabling model-animations
     */
    export class WebXRProfiledMotionController extends WebXRAbstractMotionController {
        private _repositoryUrl;
        private _buttonMeshMapping;
        private _touchDots;
        /**
         * The profile ID of this controller. Will be populated when the controller initializes.
         */
        profileId: string;
        constructor(scene: Scene, xrInput: XRInputSource, _profile: IMotionControllerProfile, _repositoryUrl: string);
        dispose(): void;
        protected _getFilenameAndPath(): {
            filename: string;
            path: string;
        };
        protected _getModelLoadingConstraints(): boolean;
        protected _processLoadedModel(_meshes: AbstractMesh[]): void;
        protected _setRootMesh(meshes: AbstractMesh[]): void;
        protected _updateModel(_xrFrame: XRFrame): void;
    }
}
declare module BABYLON {
    /**
     * A construction function type to create a new controller based on an xrInput object
     */
    export type MotionControllerConstructor = (xrInput: XRInputSource, scene: Scene) => WebXRAbstractMotionController;
    /**
     * The MotionController Manager manages all registered motion controllers and loads the right one when needed.
     *
     * When this repository is complete: https://github.com/immersive-web/webxr-input-profiles/tree/master/packages/assets
     * it should be replaced with auto-loaded controllers.
     *
     * When using a model try to stay as generic as possible. Eventually there will be no need in any of the controller classes
     */
    export class WebXRMotionControllerManager {
        private static _AvailableControllers;
        private static _Fallbacks;
        private static _ProfileLoadingPromises;
        private static _ProfilesList;
        /**
         * The base URL of the online controller repository. Can be changed at any time.
         */
        static BaseRepositoryUrl: string;
        /**
         * Which repository gets priority - local or online
         */
        static PrioritizeOnlineRepository: boolean;
        /**
         * Use the online repository, or use only locally-defined controllers
         */
        static UseOnlineRepository: boolean;
        /**
         * Clear the cache used for profile loading and reload when requested again
         */
        static ClearProfilesCache(): void;
        /**
         * Register the default fallbacks.
         * This function is called automatically when this file is imported.
         */
        static DefaultFallbacks(): void;
        /**
         * Find a fallback profile if the profile was not found. There are a few predefined generic profiles.
         * @param profileId the profile to which a fallback needs to be found
         * @return an array with corresponding fallback profiles
         */
        static FindFallbackWithProfileId(profileId: string): string[];
        /**
         * When acquiring a new xrInput object (usually by the WebXRInput class), match it with the correct profile.
         * The order of search:
         *
         * 1) Iterate the profiles array of the xr input and try finding a corresponding motion controller
         * 2) (If not found) search in the gamepad id and try using it (legacy versions only)
         * 3) search for registered fallbacks (should be redundant, nonetheless it makes sense to check)
         * 4) return the generic trigger controller if none were found
         *
         * @param xrInput the xrInput to which a new controller is initialized
         * @param scene the scene to which the model will be added
         * @param forceProfile force a certain profile for this controller
         * @return A promise that fulfils with the motion controller class for this profile id or the generic standard class if none was found
         */
        static GetMotionControllerWithXRInput(xrInput: XRInputSource, scene: Scene, forceProfile?: string): Promise<WebXRAbstractMotionController>;
        /**
         * Register a new controller based on its profile. This function will be called by the controller classes themselves.
         *
         * If you are missing a profile, make sure it is imported in your source, otherwise it will not register.
         *
         * @param type the profile type to register
         * @param constructFunction the function to be called when loading this profile
         */
        static RegisterController(type: string, constructFunction: MotionControllerConstructor): void;
        /**
         * Register a fallback to a specific profile.
         * @param profileId the profileId that will receive the fallbacks
         * @param fallbacks A list of fallback profiles
         */
        static RegisterFallbacksForProfileId(profileId: string, fallbacks: string[]): void;
        /**
         * Will update the list of profiles available in the repository
         * @return a promise that resolves to a map of profiles available online
         */
        static UpdateProfilesList(): Promise<{
            [profile: string]: string;
        }>;
        private static _LoadProfileFromRepository;
        private static _LoadProfilesFromAvailableControllers;
    }
}
declare module BABYLON {
    /**
     * Configuration options for the WebXR controller creation
     */
    export interface IWebXRControllerOptions {
        /**
         * Should the controller mesh be animated when a user interacts with it
         * The pressed buttons / thumbstick and touchpad animations will be disabled
         */
        disableMotionControllerAnimation?: boolean;
        /**
         * Do not load the controller mesh, in case a different mesh needs to be loaded.
         */
        doNotLoadControllerMesh?: boolean;
        /**
         * Force a specific controller type for this controller.
         * This can be used when creating your own profile or when testing different controllers
         */
        forceControllerProfile?: string;
        /**
         * Defines a rendering group ID for meshes that will be loaded.
         * This is for the default controllers only.
         */
        renderingGroupId?: number;
    }
    /**
     * Represents an XR controller
     */
    export class WebXRInputSource {
        private _scene;
        /** The underlying input source for the controller  */
        inputSource: XRInputSource;
        private _options;
        private _tmpVector;
        private _uniqueId;
        private _disposed;
        /**
         * Represents the part of the controller that is held. This may not exist if the controller is the head mounted display itself, if thats the case only the pointer from the head will be availible
         */
        grip?: AbstractMesh;
        /**
         * If available, this is the gamepad object related to this controller.
         * Using this object it is possible to get click events and trackpad changes of the
         * webxr controller that is currently being used.
         */
        motionController?: WebXRAbstractMotionController;
        /**
         * Event that fires when the controller is removed/disposed.
         * The object provided as event data is this controller, after associated assets were disposed.
         * uniqueId is still available.
         */
        onDisposeObservable: Observable<WebXRInputSource>;
        /**
         * Will be triggered when the mesh associated with the motion controller is done loading.
         * It is also possible that this will never trigger (!) if no mesh was loaded, or if the developer decides to load a different mesh
         * A shortened version of controller -> motion controller -> on mesh loaded.
         */
        onMeshLoadedObservable: Observable<AbstractMesh>;
        /**
         * Observers registered here will trigger when a motion controller profile was assigned to this xr controller
         */
        onMotionControllerInitObservable: Observable<WebXRAbstractMotionController>;
        /**
         * Pointer which can be used to select objects or attach a visible laser to
         */
        pointer: AbstractMesh;
        /**
         * Creates the input source object
         * @see https://doc.babylonjs.com/how_to/webxr_controllers_support
         * @param _scene the scene which the controller should be associated to
         * @param inputSource the underlying input source for the controller
         * @param _options options for this controller creation
         */
        constructor(_scene: Scene, 
        /** The underlying input source for the controller  */
        inputSource: XRInputSource, _options?: IWebXRControllerOptions);
        /**
         * Get this controllers unique id
         */
        get uniqueId(): string;
        /**
         * Disposes of the object
         */
        dispose(): void;
        /**
         * Gets a world space ray coming from the pointer or grip
         * @param result the resulting ray
         * @param gripIfAvailable use the grip mesh instead of the pointer, if available
         */
        getWorldPointerRayToRef(result: Ray, gripIfAvailable?: boolean): void;
        /**
         * Updates the controller pose based on the given XRFrame
         * @param xrFrame xr frame to update the pose with
         * @param referenceSpace reference space to use
         */
        updateFromXRFrame(xrFrame: XRFrame, referenceSpace: XRReferenceSpace): void;
    }
}
declare module BABYLON {
    /**
     * The schema for initialization options of the XR Input class
     */
    export interface IWebXRInputOptions {
        /**
         * If set to true no model will be automatically loaded
         */
        doNotLoadControllerMeshes?: boolean;
        /**
         * If set, this profile will be used for all controllers loaded (for example "microsoft-mixed-reality")
         * If not found, the xr input profile data will be used.
         * Profiles are defined here - https://github.com/immersive-web/webxr-input-profiles/
         */
        forceInputProfile?: string;
        /**
         * Do not send a request to the controller repository to load the profile.
         *
         * Instead, use the controllers available in babylon itself.
         */
        disableOnlineControllerRepository?: boolean;
        /**
         * A custom URL for the controllers repository
         */
        customControllersRepositoryURL?: string;
        /**
         * Should the controller model's components not move according to the user input
         */
        disableControllerAnimation?: boolean;
        /**
         * Optional options to pass to the controller. Will be overridden by the Input options where applicable
         */
        controllerOptions?: IWebXRControllerOptions;
    }
    /**
     * XR input used to track XR inputs such as controllers/rays
     */
    export class WebXRInput implements IDisposable {
        /**
         * the xr session manager for this session
         */
        xrSessionManager: WebXRSessionManager;
        /**
         * the WebXR camera for this session. Mainly used for teleportation
         */
        xrCamera: WebXRCamera;
        private readonly options;
        /**
         * XR controllers being tracked
         */
        controllers: Array<WebXRInputSource>;
        private _frameObserver;
        private _sessionEndedObserver;
        private _sessionInitObserver;
        /**
         * Event when a controller has been connected/added
         */
        onControllerAddedObservable: Observable<WebXRInputSource>;
        /**
         * Event when a controller has been removed/disconnected
         */
        onControllerRemovedObservable: Observable<WebXRInputSource>;
        /**
         * Initializes the WebXRInput
         * @param xrSessionManager the xr session manager for this session
         * @param xrCamera the WebXR camera for this session. Mainly used for teleportation
         * @param options = initialization options for this xr input
         */
        constructor(
        /**
         * the xr session manager for this session
         */
        xrSessionManager: WebXRSessionManager, 
        /**
         * the WebXR camera for this session. Mainly used for teleportation
         */
        xrCamera: WebXRCamera, options?: IWebXRInputOptions);
        private _onInputSourcesChange;
        private _addAndRemoveControllers;
        /**
         * Disposes of the object
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * This is the base class for all WebXR features.
     * Since most features require almost the same resources and callbacks, this class can be used to simplify the development
     * Note that since the features manager is using the `IWebXRFeature` you are in no way obligated to use this class
     */
    export abstract class WebXRAbstractFeature implements IWebXRFeature {
        protected _xrSessionManager: WebXRSessionManager;
        private _attached;
        private _removeOnDetach;
        /**
         * Is this feature disposed?
         */
        isDisposed: boolean;
        /**
         * Should auto-attach be disabled?
         */
        disableAutoAttach: boolean;
        /**
         * The name of the native xr feature name (like anchor, hit-test, or hand-tracking)
         */
        xrNativeFeatureName: string;
        /**
         * Construct a new (abstract) WebXR feature
         * @param _xrSessionManager the xr session manager for this feature
         */
        constructor(_xrSessionManager: WebXRSessionManager);
        /**
         * Is this feature attached
         */
        get attached(): boolean;
        /**
         * attach this feature
         *
         * @param force should attachment be forced (even when already attached)
         * @returns true if successful, false is failed or already attached
         */
        attach(force?: boolean): boolean;
        /**
         * detach this feature.
         *
         * @returns true if successful, false if failed or already detached
         */
        detach(): boolean;
        /**
         * Dispose this feature and all of the resources attached
         */
        dispose(): void;
        /**
         * This function will be executed during before enabling the feature and can be used to not-allow enabling it.
         * Note that at this point the session has NOT started, so this is purely checking if the browser supports it
         *
         * @returns whether or not the feature is compatible in this environment
         */
        isCompatible(): boolean;
        /**
         * This is used to register callbacks that will automatically be removed when detach is called.
         * @param observable the observable to which the observer will be attached
         * @param callback the callback to register
         */
        protected _addNewAttachObserver<T>(observable: Observable<T>, callback: (eventData: T, eventState: EventState) => void): void;
        /**
         * Code in this function will be executed on each xrFrame received from the browser.
         * This function will not execute after the feature is detached.
         * @param _xrFrame the current frame
         */
        protected abstract _onXRFrame(_xrFrame: XRFrame): void;
    }
}
declare module BABYLON {
    /**
     * Renders a layer on top of an existing scene
     */
    export class UtilityLayerRenderer implements IDisposable {
        /** the original scene that will be rendered on top of */
        originalScene: Scene;
        private _pointerCaptures;
        private _lastPointerEvents;
        private static _DefaultUtilityLayer;
        private static _DefaultKeepDepthUtilityLayer;
        private _sharedGizmoLight;
        private _renderCamera;
        /**
         * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)
         * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned
         * @returns the camera that is used when rendering the utility layer
         */
        getRenderCamera(getRigParentIfPossible?: boolean): Camera;
        /**
         * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)
         * @param cam the camera that should be used when rendering the utility layer
         */
        setRenderCamera(cam: Nullable<Camera>): void;
        /**
         * @hidden
         * Light which used by gizmos to get light shading
         */
        _getSharedGizmoLight(): HemisphericLight;
        /**
         * If the picking should be done on the utility layer prior to the actual scene (Default: true)
         */
        pickUtilitySceneFirst: boolean;
        /**
         * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)
         */
        static get DefaultUtilityLayer(): UtilityLayerRenderer;
        /**
         * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)
         */
        static get DefaultKeepDepthUtilityLayer(): UtilityLayerRenderer;
        /**
         * The scene that is rendered on top of the original scene
         */
        utilityLayerScene: Scene;
        /**
         *  If the utility layer should automatically be rendered on top of existing scene
        */
        shouldRender: boolean;
        /**
         * If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene
         */
        onlyCheckPointerDownEvents: boolean;
        /**
         * If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)
         */
        processAllEvents: boolean;
        /**
         * Observable raised when the pointer move from the utility layer scene to the main scene
         */
        onPointerOutObservable: Observable<number>;
        /** Gets or sets a predicate that will be used to indicate utility meshes present in the main scene */
        mainSceneTrackerPredicate: (mesh: Nullable<AbstractMesh>) => boolean;
        private _afterRenderObserver;
        private _sceneDisposeObserver;
        private _originalPointerObserver;
        /**
         * Instantiates a UtilityLayerRenderer
         * @param originalScene the original scene that will be rendered on top of
         * @param handleEvents boolean indicating if the utility layer should handle events
         */
        constructor(
        /** the original scene that will be rendered on top of */
        originalScene: Scene, handleEvents?: boolean);
        private _notifyObservers;
        /**
         * Renders the utility layers scene on top of the original scene
         */
        render(): void;
        /**
         * Disposes of the renderer
         */
        dispose(): void;
        private _updateCamera;
    }
}
declare module BABYLON {
    /**
     * Options interface for the pointer selection module
     */
    export interface IWebXRControllerPointerSelectionOptions {
        /**
         * if provided, this scene will be used to render meshes.
         */
        customUtilityLayerScene?: Scene;
        /**
         * Disable the pointer up event when the xr controller in screen and gaze mode is disposed (meaning - when the user removed the finger from the screen)
         * If not disabled, the last picked point will be used to execute a pointer up event
         * If disabled, pointer up event will be triggered right after the pointer down event.
         * Used in screen and gaze target ray mode only
         */
        disablePointerUpOnTouchOut: boolean;
        /**
         * For gaze mode for tracked-pointer / controllers (time to select instead of button press)
         */
        forceGazeMode: boolean;
        /**
         * Factor to be applied to the pointer-moved function in the gaze mode. How sensitive should the gaze mode be when checking if the pointer moved
         * to start a new countdown to the pointer down event.
         * Defaults to 1.
         */
        gazeModePointerMovedFactor?: number;
        /**
         * Different button type to use instead of the main component
         */
        overrideButtonId?: string;
        /**
         *  use this rendering group id for the meshes (optional)
         */
        renderingGroupId?: number;
        /**
         * The amount of time in milliseconds it takes between pick found something to a pointer down event.
         * Used in gaze modes. Tracked pointer uses the trigger, screen uses touch events
         * 3000 means 3 seconds between pointing at something and selecting it
         */
        timeToSelect?: number;
        /**
         * Should meshes created here be added to a utility layer or the main scene
         */
        useUtilityLayer?: boolean;
        /**
         * Optional WebXR camera to be used for gaze selection
         */
        gazeCamera?: WebXRCamera;
        /**
         * the xr input to use with this pointer selection
         */
        xrInput: WebXRInput;
    }
    /**
     * A module that will enable pointer selection for motion controllers of XR Input Sources
     */
    export class WebXRControllerPointerSelection extends WebXRAbstractFeature {
        private readonly _options;
        private static _idCounter;
        private _attachController;
        private _controllers;
        private _scene;
        private _tmpVectorForPickCompare;
        /**
         * The module's name
         */
        static readonly Name: string;
        /**
         * The (Babylon) version of this module.
         * This is an integer representing the implementation version.
         * This number does not correspond to the WebXR specs version
         */
        static readonly Version: number;
        /**
         * Disable lighting on the laser pointer (so it will always be visible)
         */
        disablePointerLighting: boolean;
        /**
         * Disable lighting on the selection mesh (so it will always be visible)
         */
        disableSelectionMeshLighting: boolean;
        /**
         * Should the laser pointer be displayed
         */
        displayLaserPointer: boolean;
        /**
         * Should the selection mesh be displayed (The ring at the end of the laser pointer)
         */
        displaySelectionMesh: boolean;
        /**
         * This color will be set to the laser pointer when selection is triggered
         */
        laserPointerPickedColor: Color3;
        /**
         * Default color of the laser pointer
         */
        laserPointerDefaultColor: Color3;
        /**
         * default color of the selection ring
         */
        selectionMeshDefaultColor: Color3;
        /**
         * This color will be applied to the selection ring when selection is triggered
         */
        selectionMeshPickedColor: Color3;
        /**
         * Optional filter to be used for ray selection.  This predicate shares behavior with
         * scene.pointerMovePredicate which takes priority if it is also assigned.
         */
        raySelectionPredicate: (mesh: AbstractMesh) => boolean;
        /**
         * constructs a new background remover module
         * @param _xrSessionManager the session manager for this module
         * @param _options read-only options to be used in this module
         */
        constructor(_xrSessionManager: WebXRSessionManager, _options: IWebXRControllerPointerSelectionOptions);
        /**
         * attach this feature
         * Will usually be called by the features manager
         *
         * @returns true if successful.
         */
        attach(): boolean;
        /**
         * detach this feature.
         * Will usually be called by the features manager
         *
         * @returns true if successful.
         */
        detach(): boolean;
        /**
         * Will get the mesh under a specific pointer.
         * `scene.meshUnderPointer` will only return one mesh - either left or right.
         * @param controllerId the controllerId to check
         * @returns The mesh under pointer or null if no mesh is under the pointer
         */
        getMeshUnderPointer(controllerId: string): Nullable<AbstractMesh>;
        /**
         * Get the xr controller that correlates to the pointer id in the pointer event
         *
         * @param id the pointer id to search for
         * @returns the controller that correlates to this id or null if not found
         */
        getXRControllerByPointerId(id: number): Nullable<WebXRInputSource>;
        protected _onXRFrame(_xrFrame: XRFrame): void;
        private _attachGazeMode;
        private _attachScreenRayMode;
        private _attachTrackedPointerRayMode;
        private _convertNormalToDirectionOfRay;
        private _detachController;
        private _generateNewMeshPair;
        private _pickingMoved;
        private _updatePointerDistance;
        /** @hidden */
        get lasterPointerDefaultColor(): Color3;
    }
}
declare module BABYLON {
    /**
     * Button which can be used to enter a different mode of XR
     */
    export class WebXREnterExitUIButton {
        /** button element */
        element: HTMLElement;
        /** XR initialization options for the button */
        sessionMode: XRSessionMode;
        /** Reference space type */
        referenceSpaceType: XRReferenceSpaceType;
        /**
         * Creates a WebXREnterExitUIButton
         * @param element button element
         * @param sessionMode XR initialization session mode
         * @param referenceSpaceType the type of reference space to be used
         */
        constructor(
        /** button element */
        element: HTMLElement, 
        /** XR initialization options for the button */
        sessionMode: XRSessionMode, 
        /** Reference space type */
        referenceSpaceType: XRReferenceSpaceType);
        /**
         * Extendable function which can be used to update the button's visuals when the state changes
         * @param activeButton the current active button in the UI
         */
        update(activeButton: Nullable<WebXREnterExitUIButton>): void;
    }
    /**
     * Options to create the webXR UI
     */
    export class WebXREnterExitUIOptions {
        /**
         * User provided buttons to enable/disable WebXR. The system will provide default if not set
         */
        customButtons?: Array<WebXREnterExitUIButton>;
        /**
         * A reference space type to use when creating the default button.
         * Default is local-floor
         */
        referenceSpaceType?: XRReferenceSpaceType;
        /**
         * Context to enter xr with
         */
        renderTarget?: Nullable<WebXRRenderTarget>;
        /**
         * A session mode to use when creating the default button.
         * Default is immersive-vr
         */
        sessionMode?: XRSessionMode;
        /**
         * A list of optional features to init the session with
         */
        optionalFeatures?: string[];
        /**
         * A list of optional features to init the session with
         */
        requiredFeatures?: string[];
    }
    /**
     * UI to allow the user to enter/exit XR mode
     */
    export class WebXREnterExitUI implements IDisposable {
        private scene;
        /** version of the options passed to this UI */
        options: WebXREnterExitUIOptions;
        private _activeButton;
        private _buttons;
        /**
         * The HTML Div Element to which buttons are added.
         */
        readonly overlay: HTMLDivElement;
        /**
         * Fired every time the active button is changed.
         *
         * When xr is entered via a button that launches xr that button will be the callback parameter
         *
         * When exiting xr the callback parameter will be null)
         */
        activeButtonChangedObservable: Observable<Nullable<WebXREnterExitUIButton>>;
        /**
         *
         * @param scene babylon scene object to use
         * @param options (read-only) version of the options passed to this UI
         */
        private constructor();
        /**
         * Creates UI to allow the user to enter/exit XR mode
         * @param scene the scene to add the ui to
         * @param helper the xr experience helper to enter/exit xr with
         * @param options options to configure the UI
         * @returns the created ui
         */
        static CreateAsync(scene: Scene, helper: WebXRExperienceHelper, options: WebXREnterExitUIOptions): Promise<WebXREnterExitUI>;
        /**
         * Disposes of the XR UI component
         */
        dispose(): void;
        private _updateButtons;
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class LinesBuilder {
        /**
         * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh
         * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter
         * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function
         * * The parameter `lines` is an array of lines, each line being an array of successive Vector3
         * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter
         * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point
         * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)
         * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
         * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @see https://doc.babylonjs.com/how_to/parametric_shapes#line-system
         * @param name defines the name of the new line system
         * @param options defines the options used to create the line system
         * @param scene defines the hosting scene
         * @returns a new line system mesh
         */
        static CreateLineSystem(name: string, options: {
            lines: Vector3[][];
            updatable?: boolean;
            instance?: Nullable<LinesMesh>;
            colors?: Nullable<Color4[][]>;
            useVertexAlpha?: boolean;
        }, scene: Nullable<Scene>): LinesMesh;
        /**
         * Creates a line mesh
         * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
         * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
         * * The parameter `points` is an array successive Vector3
         * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
         * * The optional parameter `colors` is an array of successive Color4, one per line point
         * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)
         * * When updating an instance, remember that only point positions can change, not the number of points
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @see https://doc.babylonjs.com/how_to/parametric_shapes#lines
         * @param name defines the name of the new line system
         * @param options defines the options used to create the line system
         * @param scene defines the hosting scene
         * @returns a new line mesh
         */
        static CreateLines(name: string, options: {
            points: Vector3[];
            updatable?: boolean;
            instance?: Nullable<LinesMesh>;
            colors?: Color4[];
            useVertexAlpha?: boolean;
        }, scene?: Nullable<Scene>): LinesMesh;
        /**
         * Creates a dashed line mesh
         * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
         * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
         * * The parameter `points` is an array successive Vector3
         * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)
         * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)
         * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)
         * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
         * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)
         * * When updating an instance, remember that only point positions can change, not the number of points
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the dashed line mesh
         * @see https://doc.babylonjs.com/how_to/parametric_shapes#dashed-lines
         */
        static CreateDashedLines(name: string, options: {
            points: Vector3[];
            dashSize?: number;
            gapSize?: number;
            dashNb?: number;
            updatable?: boolean;
            instance?: LinesMesh;
            useVertexAlpha?: boolean;
        }, scene?: Nullable<Scene>): LinesMesh;
    }
}
declare module BABYLON {
    /**
     * Construction options for a timer
     */
    export interface ITimerOptions<T> {
        /**
         * Time-to-end
         */
        timeout: number;
        /**
         * The context observable is used to calculate time deltas and provides the context of the timer's callbacks. Will usually be OnBeforeRenderObservable.
         * Countdown calculation is done ONLY when the observable is notifying its observers, meaning that if
         * you choose an observable that doesn't trigger too often, the wait time might extend further than the requested max time
         */
        contextObservable: Observable<T>;
        /**
         * Optional parameters when adding an observer to the observable
         */
        observableParameters?: {
            mask?: number;
            insertFirst?: boolean;
            scope?: any;
        };
        /**
         * An optional break condition that will stop the times prematurely. In this case onEnded will not be triggered!
         */
        breakCondition?: (data?: ITimerData<T>) => boolean;
        /**
         * Will be triggered when the time condition has met
         */
        onEnded?: (data: ITimerData<any>) => void;
        /**
         * Will be triggered when the break condition has met (prematurely ended)
         */
        onAborted?: (data: ITimerData<any>) => void;
        /**
         * Optional function to execute on each tick (or count)
         */
        onTick?: (data: ITimerData<any>) => void;
    }
    /**
     * An interface defining the data sent by the timer
     */
    export interface ITimerData<T> {
        /**
         * When did it start
         */
        startTime: number;
        /**
         * Time now
         */
        currentTime: number;
        /**
         * Time passed since started
         */
        deltaTime: number;
        /**
         * How much is completed, in [0.0...1.0].
         * Note that this CAN be higher than 1 due to the fact that we don't actually measure time but delta between observable calls
         */
        completeRate: number;
        /**
         * What the registered observable sent in the last count
         */
        payload: T;
    }
    /**
     * The current state of the timer
     */
    export enum TimerState {
        /**
         * Timer initialized, not yet started
         */
        INIT = 0,
        /**
         * Timer started and counting
         */
        STARTED = 1,
        /**
         * Timer ended (whether aborted or time reached)
         */
        ENDED = 2
    }
    /**
     * A simple version of the timer. Will take options and start the timer immediately after calling it
     *
     * @param options options with which to initialize this timer
     */
    export function setAndStartTimer(options: ITimerOptions<any>): Nullable<Observer<any>>;
    /**
     * An advanced implementation of a timer class
     */
    export class AdvancedTimer<T = any> implements IDisposable {
        /**
         * Will notify each time the timer calculates the remaining time
         */
        onEachCountObservable: Observable<ITimerData<T>>;
        /**
         * Will trigger when the timer was aborted due to the break condition
         */
        onTimerAbortedObservable: Observable<ITimerData<T>>;
        /**
         * Will trigger when the timer ended successfully
         */
        onTimerEndedObservable: Observable<ITimerData<T>>;
        /**
         * Will trigger when the timer state has changed
         */
        onStateChangedObservable: Observable<TimerState>;
        private _observer;
        private _contextObservable;
        private _observableParameters;
        private _startTime;
        private _timer;
        private _state;
        private _breakCondition;
        private _timeToEnd;
        private _breakOnNextTick;
        /**
         * Will construct a new advanced timer based on the options provided. Timer will not start until start() is called.
         * @param options construction options for this advanced timer
         */
        constructor(options: ITimerOptions<T>);
        /**
         * set a breaking condition for this timer. Default is to never break during count
         * @param predicate the new break condition. Returns true to break, false otherwise
         */
        set breakCondition(predicate: (data: ITimerData<T>) => boolean);
        /**
         * Reset ALL associated observables in this advanced timer
         */
        clearObservables(): void;
        /**
         * Will start a new iteration of this timer. Only one instance of this timer can run at a time.
         *
         * @param timeToEnd how much time to measure until timer ended
         */
        start(timeToEnd?: number): void;
        /**
         * Will force a stop on the next tick.
         */
        stop(): void;
        /**
         * Dispose this timer, clearing all resources
         */
        dispose(): void;
        private _setState;
        private _tick;
        private _stop;
    }
}
declare module BABYLON {
    /**
     * The options container for the teleportation module
     */
    export interface IWebXRTeleportationOptions {
        /**
         * if provided, this scene will be used to render meshes.
         */
        customUtilityLayerScene?: Scene;
        /**
         * Values to configure the default target mesh
         */
        defaultTargetMeshOptions?: {
            /**
             * Fill color of the teleportation area
             */
            teleportationFillColor?: string;
            /**
             * Border color for the teleportation area
             */
            teleportationBorderColor?: string;
            /**
             * Disable the mesh's animation sequence
             */
            disableAnimation?: boolean;
            /**
             * Disable lighting on the material or the ring and arrow
             */
            disableLighting?: boolean;
            /**
             * Override the default material of the torus and arrow
             */
            torusArrowMaterial?: Material;
        };
        /**
         * A list of meshes to use as floor meshes.
         * Meshes can be added and removed after initializing the feature using the
         * addFloorMesh and removeFloorMesh functions
         * If empty, rotation will still work
         */
        floorMeshes?: AbstractMesh[];
        /**
         *  use this rendering group id for the meshes (optional)
         */
        renderingGroupId?: number;
        /**
         * Should teleportation move only to snap points
         */
        snapPointsOnly?: boolean;
        /**
         * An array of points to which the teleportation will snap to.
         * If the teleportation ray is in the proximity of one of those points, it will be corrected to this point.
         */
        snapPositions?: Vector3[];
        /**
         * How close should the teleportation ray be in order to snap to position.
         * Default to 0.8 units (meters)
         */
        snapToPositionRadius?: number;
        /**
         * Provide your own teleportation mesh instead of babylon's wonderful doughnut.
         * If you want to support rotation, make sure your mesh has a direction indicator.
         *
         * When left untouched, the default mesh will be initialized.
         */
        teleportationTargetMesh?: AbstractMesh;
        /**
         * If main component is used (no thumbstick), how long should the "long press" take before teleport
         */
        timeToTeleport?: number;
        /**
         * Disable using the thumbstick and use the main component (usually trigger) on long press.
         * This will be automatically true if the controller doesn't have a thumbstick or touchpad.
         */
        useMainComponentOnly?: boolean;
        /**
         * Should meshes created here be added to a utility layer or the main scene
         */
        useUtilityLayer?: boolean;
        /**
         * Babylon XR Input class for controller
         */
        xrInput: WebXRInput;
        /**
         * Meshes that the teleportation ray cannot go through
         */
        pickBlockerMeshes?: AbstractMesh[];
    }
    /**
     * This is a teleportation feature to be used with WebXR-enabled motion controllers.
     * When enabled and attached, the feature will allow a user to move around and rotate in the scene using
     * the input of the attached controllers.
     */
    export class WebXRMotionControllerTeleportation extends WebXRAbstractFeature {
        private _options;
        private _controllers;
        private _currentTeleportationControllerId;
        private _floorMeshes;
        private _quadraticBezierCurve;
        private _selectionFeature;
        private _snapToPositions;
        private _snappedToPoint;
        private _teleportationRingMaterial?;
        private _tmpRay;
        private _tmpVector;
        private _tmpQuaternion;
        /**
         * The module's name
         */
        static readonly Name: string;
        /**
         * The (Babylon) version of this module.
         * This is an integer representing the implementation version.
         * This number does not correspond to the webxr specs version
         */
        static readonly Version: number;
        /**
         * Is movement backwards enabled
         */
        backwardsMovementEnabled: boolean;
        /**
         * Distance to travel when moving backwards
         */
        backwardsTeleportationDistance: number;
        /**
         * The distance from the user to the inspection point in the direction of the controller
         * A higher number will allow the user to move further
         * defaults to 5 (meters, in xr units)
         */
        parabolicCheckRadius: number;
        /**
         * Should the module support parabolic ray on top of direct ray
         * If enabled, the user will be able to point "at the sky" and move according to predefined radius distance
         * Very helpful when moving between floors / different heights
         */
        parabolicRayEnabled: boolean;
        /**
         * How much rotation should be applied when rotating right and left
         */
        rotationAngle: number;
        /**
         * Is rotation enabled when moving forward?
         * Disabling this feature will prevent the user from deciding the direction when teleporting
         */
        rotationEnabled: boolean;
        /**
         * constructs a new anchor system
         * @param _xrSessionManager an instance of WebXRSessionManager
         * @param _options configuration object for this feature
         */
        constructor(_xrSessionManager: WebXRSessionManager, _options: IWebXRTeleportationOptions);
        /**
         * Get the snapPointsOnly flag
         */
        get snapPointsOnly(): boolean;
        /**
         * Sets the snapPointsOnly flag
         * @param snapToPoints should teleportation be exclusively to snap points
         */
        set snapPointsOnly(snapToPoints: boolean);
        /**
         * Add a new mesh to the floor meshes array
         * @param mesh the mesh to use as floor mesh
         */
        addFloorMesh(mesh: AbstractMesh): void;
        /**
         * Add a new snap-to point to fix teleportation to this position
         * @param newSnapPoint The new Snap-To point
         */
        addSnapPoint(newSnapPoint: Vector3): void;
        attach(): boolean;
        detach(): boolean;
        dispose(): void;
        /**
         * Remove a mesh from the floor meshes array
         * @param mesh the mesh to remove
         */
        removeFloorMesh(mesh: AbstractMesh): void;
        /**
         * Remove a mesh from the floor meshes array using its name
         * @param name the mesh name to remove
         */
        removeFloorMeshByName(name: string): void;
        /**
         * This function will iterate through the array, searching for this point or equal to it. It will then remove it from the snap-to array
         * @param snapPointToRemove the point (or a clone of it) to be removed from the array
         * @returns was the point found and removed or not
         */
        removeSnapPoint(snapPointToRemove: Vector3): boolean;
        /**
         * This function sets a selection feature that will be disabled when
         * the forward ray is shown and will be reattached when hidden.
         * This is used to remove the selection rays when moving.
         * @param selectionFeature the feature to disable when forward movement is enabled
         */
        setSelectionFeature(selectionFeature: Nullable<IWebXRFeature>): void;
        protected _onXRFrame(_xrFrame: XRFrame): void;
        private _attachController;
        private _createDefaultTargetMesh;
        private _detachController;
        private _findClosestSnapPointWithRadius;
        private _setTargetMeshPosition;
        private _setTargetMeshVisibility;
        private _showParabolicPath;
        private _teleportForward;
    }
}
declare module BABYLON {
    /**
     * Options for the default xr helper
     */
    export class WebXRDefaultExperienceOptions {
        /**
         * Enable or disable default UI to enter XR
         */
        disableDefaultUI?: boolean;
        /**
         * Should teleportation not initialize. defaults to false.
         */
        disableTeleportation?: boolean;
        /**
         * Floor meshes that will be used for teleport
         */
        floorMeshes?: Array<AbstractMesh>;
        /**
         * If set to true, the first frame will not be used to reset position
         * The first frame is mainly used when copying transformation from the old camera
         * Mainly used in AR
         */
        ignoreNativeCameraTransformation?: boolean;
        /**
         * Disable the controller mesh-loading. Can be used if you want to load your own meshes
         */
        inputOptions?: IWebXRInputOptions;
        /**
         * optional configuration for the output canvas
         */
        outputCanvasOptions?: WebXRManagedOutputCanvasOptions;
        /**
         * optional UI options. This can be used among other to change session mode and reference space type
         */
        uiOptions?: WebXREnterExitUIOptions;
        /**
         * When loading teleportation and pointer select, use stable versions instead of latest.
         */
        useStablePlugins?: boolean;
        /**
         * An optional rendering group id that will be set globally for teleportation, pointer selection and default controller meshes
         */
        renderingGroupId?: number;
        /**
         * A list of optional features to init the session with
         * If set to true, all features we support will be added
         */
        optionalFeatures?: boolean | string[];
    }
    /**
     * Default experience which provides a similar setup to the previous webVRExperience
     */
    export class WebXRDefaultExperience {
        /**
         * Base experience
         */
        baseExperience: WebXRExperienceHelper;
        /**
         * Enables ui for entering/exiting xr
         */
        enterExitUI: WebXREnterExitUI;
        /**
         * Input experience extension
         */
        input: WebXRInput;
        /**
         * Enables laser pointer and selection
         */
        pointerSelection: WebXRControllerPointerSelection;
        /**
         * Default target xr should render to
         */
        renderTarget: WebXRRenderTarget;
        /**
         * Enables teleportation
         */
        teleportation: WebXRMotionControllerTeleportation;
        private constructor();
        /**
         * Creates the default xr experience
         * @param scene scene
         * @param options options for basic configuration
         * @returns resulting WebXRDefaultExperience
         */
        static CreateAsync(scene: Scene, options?: WebXRDefaultExperienceOptions): Promise<WebXRDefaultExperience>;
        /**
         * DIsposes of the experience helper
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * Options to modify the vr teleportation behavior.
     */
    export interface VRTeleportationOptions {
        /**
         * The name of the mesh which should be used as the teleportation floor. (default: null)
         */
        floorMeshName?: string;
        /**
         * A list of meshes to be used as the teleportation floor. (default: empty)
         */
        floorMeshes?: Mesh[];
        /**
         * The teleportation mode. (default: TELEPORTATIONMODE_CONSTANTTIME)
         */
        teleportationMode?: number;
        /**
         * The duration of the animation in ms, apply when animationMode is TELEPORTATIONMODE_CONSTANTTIME. (default 122ms)
         */
        teleportationTime?: number;
        /**
         * The speed of the animation in distance/sec, apply when animationMode is TELEPORTATIONMODE_CONSTANTSPEED. (default 20 units / sec)
         */
        teleportationSpeed?: number;
        /**
         * The easing function used in the animation or null for Linear. (default CircleEase)
         */
        easingFunction?: EasingFunction;
    }
    /**
     * Options to modify the vr experience helper's behavior.
     */
    export interface VRExperienceHelperOptions extends WebVROptions {
        /**
         * Create a DeviceOrientationCamera to be used as your out of vr camera. (default: true)
         */
        createDeviceOrientationCamera?: boolean;
        /**
         * Create a VRDeviceOrientationFreeCamera to be used for VR when no external HMD is found. (default: true)
         */
        createFallbackVRDeviceOrientationFreeCamera?: boolean;
        /**
         * Uses the main button on the controller to toggle the laser casted. (default: true)
         */
        laserToggle?: boolean;
        /**
         * A list of meshes to be used as the teleportation floor. If specified, teleportation will be enabled (default: undefined)
         */
        floorMeshes?: Mesh[];
        /**
         * Distortion metrics for the fallback vrDeviceOrientationCamera (default: VRCameraMetrics.Default)
         */
        vrDeviceOrientationCameraMetrics?: VRCameraMetrics;
        /**
         * Defines if WebXR should be used instead of WebVR (if available)
         */
        useXR?: boolean;
    }
    /**
     * Event containing information after VR has been entered
     */
    export class OnAfterEnteringVRObservableEvent {
        /**
         * If entering vr was successful
         */
        success: boolean;
    }
    /**
     * Helps to quickly add VR support to an existing scene.
     * See https://doc.babylonjs.com/how_to/webvr_helper
     */
    export class VRExperienceHelper {
        /** Options to modify the vr experience helper's behavior. */
        webVROptions: VRExperienceHelperOptions;
        private _scene;
        private _position;
        private _btnVR;
        private _btnVRDisplayed;
        private _webVRsupported;
        private _webVRready;
        private _webVRrequesting;
        private _webVRpresenting;
        private _hasEnteredVR;
        private _fullscreenVRpresenting;
        private _inputElement;
        private _webVRCamera;
        private _vrDeviceOrientationCamera;
        private _deviceOrientationCamera;
        private _existingCamera;
        private _onKeyDown;
        private _onVrDisplayPresentChange;
        private _onVRDisplayChanged;
        private _onVRRequestPresentStart;
        private _onVRRequestPresentComplete;
        /**
         * Gets or sets a boolean indicating that gaze can be enabled even if pointer lock is not engage (useful on iOS where fullscreen mode and pointer lock are not supported)
         */
        enableGazeEvenWhenNoPointerLock: boolean;
        /**
         * Gets or sets a boolean indicating that the VREXperienceHelper will exit VR if double tap is detected
         */
        exitVROnDoubleTap: boolean;
        /**
         * Observable raised right before entering VR.
         */
        onEnteringVRObservable: Observable<VRExperienceHelper>;
        /**
         * Observable raised when entering VR has completed.
         */
        onAfterEnteringVRObservable: Observable<OnAfterEnteringVRObservableEvent>;
        /**
         * Observable raised when exiting VR.
         */
        onExitingVRObservable: Observable<VRExperienceHelper>;
        /**
         * Observable raised when controller mesh is loaded.
         */
        onControllerMeshLoadedObservable: Observable<WebVRController>;
        /** Return this.onEnteringVRObservable
         * Note: This one is for backward compatibility. Please use onEnteringVRObservable directly
         */
        get onEnteringVR(): Observable<VRExperienceHelper>;
        /** Return this.onExitingVRObservable
         * Note: This one is for backward compatibility. Please use onExitingVRObservable directly
         */
        get onExitingVR(): Observable<VRExperienceHelper>;
        /** Return this.onControllerMeshLoadedObservable
         * Note: This one is for backward compatibility. Please use onControllerMeshLoadedObservable directly
         */
        get onControllerMeshLoaded(): Observable<WebVRController>;
        private _rayLength;
        private _useCustomVRButton;
        private _teleportationRequested;
        private _teleportActive;
        private _floorMeshName;
        private _floorMeshesCollection;
        private _teleportationMode;
        private _teleportationTime;
        private _teleportationSpeed;
        private _teleportationEasing;
        private _rotationAllowed;
        private _teleportBackwardsVector;
        private _teleportationTarget;
        private _isDefaultTeleportationTarget;
        private _postProcessMove;
        private _teleportationFillColor;
        private _teleportationBorderColor;
        private _rotationAngle;
        private _haloCenter;
        private _cameraGazer;
        private _padSensibilityUp;
        private _padSensibilityDown;
        private _leftController;
        private _rightController;
        private _gazeColor;
        private _laserColor;
        private _pickedLaserColor;
        private _pickedGazeColor;
        /**
         * Observable raised when a new mesh is selected based on meshSelectionPredicate
         */
        onNewMeshSelected: Observable<AbstractMesh>;
        /**
         * Observable raised when a new mesh is selected based on meshSelectionPredicate.
         * This observable will provide the mesh and the controller used to select the mesh
         */
        onMeshSelectedWithController: Observable<{
            mesh: AbstractMesh;
            controller: WebVRController;
        }>;
        /**
         * Observable raised when a new mesh is picked based on meshSelectionPredicate
         */
        onNewMeshPicked: Observable<PickingInfo>;
        private _circleEase;
        /**
         * Observable raised before camera teleportation
        */
        onBeforeCameraTeleport: Observable<Vector3>;
        /**
         *  Observable raised after camera teleportation
        */
        onAfterCameraTeleport: Observable<Vector3>;
        /**
        * Observable raised when current selected mesh gets unselected
        */
        onSelectedMeshUnselected: Observable<AbstractMesh>;
        private _raySelectionPredicate;
        /**
         * To be optionaly changed by user to define custom ray selection
         */
        raySelectionPredicate: (mesh: AbstractMesh) => boolean;
        /**
         * To be optionaly changed by user to define custom selection logic (after ray selection)
         */
        meshSelectionPredicate: (mesh: AbstractMesh) => boolean;
        /**
         * Set teleportation enabled. If set to false camera teleportation will be disabled but camera rotation will be kept.
         */
        teleportationEnabled: boolean;
        private _defaultHeight;
        private _teleportationInitialized;
        private _interactionsEnabled;
        private _interactionsRequested;
        private _displayGaze;
        private _displayLaserPointer;
        /**
         * The mesh used to display where the user is going to teleport.
         */
        get teleportationTarget(): Mesh;
        /**
         * Sets the mesh to be used to display where the user is going to teleport.
         */
        set teleportationTarget(value: Mesh);
        /**
         * The mesh used to display where the user is selecting, this mesh will be cloned and set as the gazeTracker for the left and right controller
         * when set bakeCurrentTransformIntoVertices will be called on the mesh.
         * See https://doc.babylonjs.com/resources/baking_transformations
         */
        get gazeTrackerMesh(): Mesh;
        set gazeTrackerMesh(value: Mesh);
        /**
         * If the gaze trackers scale should be updated to be constant size when pointing at near/far meshes
         */
        updateGazeTrackerScale: boolean;
        /**
         * If the gaze trackers color should be updated when selecting meshes
         */
        updateGazeTrackerColor: boolean;
        /**
         * If the controller laser color should be updated when selecting meshes
         */
        updateControllerLaserColor: boolean;
        /**
         * The gaze tracking mesh corresponding to the left controller
         */
        get leftControllerGazeTrackerMesh(): Nullable<Mesh>;
        /**
         * The gaze tracking mesh corresponding to the right controller
         */
        get rightControllerGazeTrackerMesh(): Nullable<Mesh>;
        /**
         * If the ray of the gaze should be displayed.
         */
        get displayGaze(): boolean;
        /**
         * Sets if the ray of the gaze should be displayed.
         */
        set displayGaze(value: boolean);
        /**
         * If the ray of the LaserPointer should be displayed.
         */
        get displayLaserPointer(): boolean;
        /**
         * Sets if the ray of the LaserPointer should be displayed.
         */
        set displayLaserPointer(value: boolean);
        /**
         * The deviceOrientationCamera used as the camera when not in VR.
         */
        get deviceOrientationCamera(): Nullable<DeviceOrientationCamera>;
        /**
         * Based on the current WebVR support, returns the current VR camera used.
         */
        get currentVRCamera(): Nullable<Camera>;
        /**
         * The webVRCamera which is used when in VR.
         */
        get webVRCamera(): WebVRFreeCamera;
        /**
         * The deviceOrientationCamera that is used as a fallback when vr device is not connected.
         */
        get vrDeviceOrientationCamera(): Nullable<VRDeviceOrientationFreeCamera>;
        /**
         * The html button that is used to trigger entering into VR.
         */
        get vrButton(): Nullable<HTMLButtonElement>;
        private get _teleportationRequestInitiated();
        /**
         * Defines whether or not Pointer lock should be requested when switching to
         * full screen.
         */
        requestPointerLockOnFullScreen: boolean;
        /**
         * If asking to force XR, this will be populated with the default xr experience
         */
        xr: WebXRDefaultExperience;
        /**
         * Was the XR test done already. If this is true AND this.xr exists, xr is initialized.
         * If this is true and no this.xr, xr exists but is not supported, using WebVR.
         */
        xrTestDone: boolean;
        /**
         * Instantiates a VRExperienceHelper.
         * Helps to quickly add VR support to an existing scene.
         * @param scene The scene the VRExperienceHelper belongs to.
         * @param webVROptions Options to modify the vr experience helper's behavior.
         */
        constructor(scene: Scene, 
        /** Options to modify the vr experience helper's behavior. */
        webVROptions?: VRExperienceHelperOptions);
        private completeVRInit;
        private _onDefaultMeshLoaded;
        private _onResize;
        private _onFullscreenChange;
        /**
         * Gets a value indicating if we are currently in VR mode.
         */
        get isInVRMode(): boolean;
        private onVrDisplayPresentChange;
        private onVRDisplayChanged;
        private moveButtonToBottomRight;
        private displayVRButton;
        private updateButtonVisibility;
        private _cachedAngularSensibility;
        /**
         * Attempt to enter VR. If a headset is connected and ready, will request present on that.
         * Otherwise, will use the fullscreen API.
         */
        enterVR(): void;
        /**
         * Attempt to exit VR, or fullscreen.
         */
        exitVR(): void;
        /**
         * The position of the vr experience helper.
         */
        get position(): Vector3;
        /**
         * Sets the position of the vr experience helper.
         */
        set position(value: Vector3);
        /**
         * Enables controllers and user interactions such as selecting and object or clicking on an object.
         */
        enableInteractions(): void;
        private get _noControllerIsActive();
        private beforeRender;
        private _isTeleportationFloor;
        /**
         * Adds a floor mesh to be used for teleportation.
         * @param floorMesh the mesh to be used for teleportation.
         */
        addFloorMesh(floorMesh: Mesh): void;
        /**
         * Removes a floor mesh from being used for teleportation.
         * @param floorMesh the mesh to be removed.
         */
        removeFloorMesh(floorMesh: Mesh): void;
        /**
         * Enables interactions and teleportation using the VR controllers and gaze.
         * @param vrTeleportationOptions options to modify teleportation behavior.
         */
        enableTeleportation(vrTeleportationOptions?: VRTeleportationOptions): void;
        private _onNewGamepadConnected;
        private _tryEnableInteractionOnController;
        private _onNewGamepadDisconnected;
        private _enableInteractionOnController;
        private _checkTeleportWithRay;
        private _checkRotate;
        private _checkTeleportBackwards;
        private _enableTeleportationOnController;
        private _createTeleportationCircles;
        private _displayTeleportationTarget;
        private _hideTeleportationTarget;
        private _rotateCamera;
        private _moveTeleportationSelectorTo;
        private _workingVector;
        private _workingQuaternion;
        private _workingMatrix;
        /**
         * Time Constant Teleportation Mode
         */
        static readonly TELEPORTATIONMODE_CONSTANTTIME: number;
        /**
         * Speed Constant Teleportation Mode
         */
        static readonly TELEPORTATIONMODE_CONSTANTSPEED: number;
        /**
         * Teleports the users feet to the desired location
         * @param location The location where the user's feet should be placed
         */
        teleportCamera(location: Vector3): void;
        private _convertNormalToDirectionOfRay;
        private _castRayAndSelectObject;
        private _notifySelectedMeshUnselected;
        /**
         * Permanently set new colors for the laser pointer
         * @param color the new laser color
         * @param pickedColor the new laser color when picked mesh detected
         */
        setLaserColor(color: Color3, pickedColor?: Color3): void;
        /**
         * Set lighting enabled / disabled on the laser pointer of both controllers
         * @param enabled should the lighting be enabled on the laser pointer
         */
        setLaserLightingState(enabled?: boolean): void;
        /**
         * Permanently set new colors for the gaze pointer
         * @param color the new gaze color
         * @param pickedColor the new gaze color when picked mesh detected
         */
        setGazeColor(color: Color3, pickedColor?: Color3): void;
        /**
         * Sets the color of the laser ray from the vr controllers.
         * @param color new color for the ray.
         */
        changeLaserColor(color: Color3): void;
        /**
         * Sets the color of the ray from the vr headsets gaze.
         * @param color new color for the ray.
         */
        changeGazeColor(color: Color3): void;
        /**
         * Exits VR and disposes of the vr experience helper
         */
        dispose(): void;
        /**
         * Gets the name of the VRExperienceHelper class
         * @returns "VRExperienceHelper"
         */
        getClassName(): string;
    }
}
declare module BABYLON {
    /**
     * Contains an array of blocks representing the octree
     */
    export interface IOctreeContainer<T> {
        /**
         * Blocks within the octree
         */
        blocks: Array<OctreeBlock<T>>;
    }
    /**
     * Class used to store a cell in an octree
     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
     */
    export class OctreeBlock<T> {
        /**
         * Gets the content of the current block
         */
        entries: T[];
        /**
         * Gets the list of block children
         */
        blocks: Array<OctreeBlock<T>>;
        private _depth;
        private _maxDepth;
        private _capacity;
        private _minPoint;
        private _maxPoint;
        private _boundingVectors;
        private _creationFunc;
        /**
         * Creates a new block
         * @param minPoint defines the minimum vector (in world space) of the block's bounding box
         * @param maxPoint defines the maximum vector (in world space) of the block's bounding box
         * @param capacity defines the maximum capacity of this block (if capacity is reached the block will be split into sub blocks)
         * @param depth defines the current depth of this block in the octree
         * @param maxDepth defines the maximal depth allowed (beyond this value, the capacity is ignored)
         * @param creationFunc defines a callback to call when an element is added to the block
         */
        constructor(minPoint: Vector3, maxPoint: Vector3, capacity: number, depth: number, maxDepth: number, creationFunc: (entry: T, block: OctreeBlock<T>) => void);
        /**
         * Gets the maximum capacity of this block (if capacity is reached the block will be split into sub blocks)
         */
        get capacity(): number;
        /**
         * Gets the minimum vector (in world space) of the block's bounding box
         */
        get minPoint(): Vector3;
        /**
         * Gets the maximum vector (in world space) of the block's bounding box
         */
        get maxPoint(): Vector3;
        /**
         * Add a new element to this block
         * @param entry defines the element to add
         */
        addEntry(entry: T): void;
        /**
         * Remove an element from this block
         * @param entry defines the element to remove
         */
        removeEntry(entry: T): void;
        /**
         * Add an array of elements to this block
         * @param entries defines the array of elements to add
         */
        addEntries(entries: T[]): void;
        /**
         * Test if the current block intersects the furstum planes and if yes, then add its content to the selection array
         * @param frustumPlanes defines the frustum planes to test
         * @param selection defines the array to store current content if selection is positive
         * @param allowDuplicate defines if the selection array can contains duplicated entries
         */
        select(frustumPlanes: Plane[], selection: SmartArrayNoDuplicate<T>, allowDuplicate?: boolean): void;
        /**
         * Test if the current block intersect with the given bounding sphere and if yes, then add its content to the selection array
         * @param sphereCenter defines the bounding sphere center
         * @param sphereRadius defines the bounding sphere radius
         * @param selection defines the array to store current content if selection is positive
         * @param allowDuplicate defines if the selection array can contains duplicated entries
         */
        intersects(sphereCenter: Vector3, sphereRadius: number, selection: SmartArrayNoDuplicate<T>, allowDuplicate?: boolean): void;
        /**
         * Test if the current block intersect with the given ray and if yes, then add its content to the selection array
         * @param ray defines the ray to test with
         * @param selection defines the array to store current content if selection is positive
         */
        intersectsRay(ray: Ray, selection: SmartArrayNoDuplicate<T>): void;
        /**
         * Subdivide the content into child blocks (this block will then be empty)
         */
        createInnerBlocks(): void;
        /**
         * @hidden
         */
        static _CreateBlocks<T>(worldMin: Vector3, worldMax: Vector3, entries: T[], maxBlockCapacity: number, currentDepth: number, maxDepth: number, target: IOctreeContainer<T>, creationFunc: (entry: T, block: OctreeBlock<T>) => void): void;
    }
}
declare module BABYLON {
    /**
     * Octrees are a really powerful data structure that can quickly select entities based on space coordinates.
     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
     */
    export class Octree<T> {
        /** Defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.) */
        maxDepth: number;
        /**
         * Blocks within the octree containing objects
         */
        blocks: Array<OctreeBlock<T>>;
        /**
         * Content stored in the octree
         */
        dynamicContent: T[];
        private _maxBlockCapacity;
        private _selectionContent;
        private _creationFunc;
        /**
         * Creates a octree
         * @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
         * @param creationFunc function to be used to instatiate the octree
         * @param maxBlockCapacity defines the maximum number of meshes you want on your octree's leaves (default: 64)
         * @param maxDepth defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.)
         */
        constructor(creationFunc: (entry: T, block: OctreeBlock<T>) => void, maxBlockCapacity?: number, 
        /** Defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.) */
        maxDepth?: number);
        /**
         * Updates the octree by adding blocks for the passed in meshes within the min and max world parameters
         * @param worldMin worldMin for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);
         * @param worldMax worldMax for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);
         * @param entries meshes to be added to the octree blocks
         */
        update(worldMin: Vector3, worldMax: Vector3, entries: T[]): void;
        /**
         * Adds a mesh to the octree
         * @param entry Mesh to add to the octree
         */
        addMesh(entry: T): void;
        /**
         * Remove an element from the octree
         * @param entry defines the element to remove
         */
        removeMesh(entry: T): void;
        /**
         * Selects an array of meshes within the frustum
         * @param frustumPlanes The frustum planes to use which will select all meshes within it
         * @param allowDuplicate If duplicate objects are allowed in the resulting object array
         * @returns array of meshes within the frustum
         */
        select(frustumPlanes: Plane[], allowDuplicate?: boolean): SmartArray<T>;
        /**
         * Test if the octree intersect with the given bounding sphere and if yes, then add its content to the selection array
         * @param sphereCenter defines the bounding sphere center
         * @param sphereRadius defines the bounding sphere radius
         * @param allowDuplicate defines if the selection array can contains duplicated entries
         * @returns an array of objects that intersect the sphere
         */
        intersects(sphereCenter: Vector3, sphereRadius: number, allowDuplicate?: boolean): SmartArray<T>;
        /**
        * Test if the octree intersect with the given ray and if yes, then add its content to resulting array
         * @param ray defines the ray to test with
         * @returns array of intersected objects
         */
        intersectsRay(ray: Ray): SmartArray<T>;
        /**
         * Adds a mesh into the octree block if it intersects the block
         */
        static CreationFuncForMeshes: (entry: AbstractMesh, block: OctreeBlock<AbstractMesh>) => void;
        /**
         * Adds a submesh into the octree block if it intersects the block
         */
        static CreationFuncForSubMeshes: (entry: SubMesh, block: OctreeBlock<SubMesh>) => void;
    }
}
declare module BABYLON {
        interface Scene {
            /**
             * @hidden
             * Backing Filed
             */
            _selectionOctree: Octree<AbstractMesh>;
            /**
             * Gets the octree used to boost mesh selection (picking)
             * @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
             */
            selectionOctree: Octree<AbstractMesh>;
            /**
             * Creates or updates the octree used to boost selection (picking)
             * @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
             * @param maxCapacity defines the maximum capacity per leaf
             * @param maxDepth defines the maximum depth of the octree
             * @returns an octree of AbstractMesh
             */
            createOrUpdateSelectionOctree(maxCapacity?: number, maxDepth?: number): Octree<AbstractMesh>;
        }
        interface AbstractMesh {
            /**
             * @hidden
             * Backing Field
             */
            _submeshesOctree: Octree<SubMesh>;
            /**
             * This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.
             * Please note that you must have a decent number of submeshes to get performance improvements when using an octree
             * @param maxCapacity defines the maximum size of each block (64 by default)
             * @param maxDepth defines the maximum depth to use (no more than 2 levels by default)
             * @returns the new octree
             * @see https://www.babylonjs-playground.com/#NA4OQ#12
             * @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
             */
            createOrUpdateSubmeshesOctree(maxCapacity?: number, maxDepth?: number): Octree<SubMesh>;
        }
    /**
     * Defines the octree scene component responsible to manage any octrees
     * in a given scene.
     */
    export class OctreeSceneComponent {
        /**
         * The component name help to identify the component in the list of scene components.
         */
        readonly name: string;
        /**
         * The scene the component belongs to.
         */
        scene: Scene;
        /**
         * Indicates if the meshes have been checked to make sure they are isEnabled()
         */
        readonly checksIsEnabled: boolean;
        /**
         * Creates a new instance of the component for the given scene
         * @param scene Defines the scene to register the component in
         */
        constructor(scene: Scene);
        /**
         * Registers the component in a given scene
         */
        register(): void;
        /**
         * Return the list of active meshes
         * @returns the list of active meshes
         */
        getActiveMeshCandidates(): ISmartArrayLike<AbstractMesh>;
        /**
         * Return the list of active sub meshes
         * @param mesh The mesh to get the candidates sub meshes from
         * @returns the list of active sub meshes
         */
        getActiveSubMeshCandidates(mesh: AbstractMesh): ISmartArrayLike<SubMesh>;
        private _tempRay;
        /**
         * Return the list of sub meshes intersecting with a given local ray
         * @param mesh defines the mesh to find the submesh for
         * @param localRay defines the ray in local space
         * @returns the list of intersecting sub meshes
         */
        getIntersectingSubMeshCandidates(mesh: AbstractMesh, localRay: Ray): ISmartArrayLike<SubMesh>;
        /**
         * Return the list of sub meshes colliding with a collider
         * @param mesh defines the mesh to find the submesh for
         * @param collider defines the collider to evaluate the collision against
         * @returns the list of colliding sub meshes
         */
        getCollidingSubMeshCandidates(mesh: AbstractMesh, collider: Collider): ISmartArrayLike<SubMesh>;
        /**
         * Rebuilds the elements related to this component in case of
         * context lost for instance.
         */
        rebuild(): void;
        /**
         * Disposes the component and the associated ressources.
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.
     */
    export class Gizmo implements IDisposable {
        /** The utility layer the gizmo will be added to */
        gizmoLayer: UtilityLayerRenderer;
        /**
         * The root mesh of the gizmo
         */
        _rootMesh: Mesh;
        private _attachedMesh;
        private _attachedNode;
        /**
         * Ratio for the scale of the gizmo (Default: 1)
         */
        protected _scaleRatio: number;
        /**
         * Ratio for the scale of the gizmo (Default: 1)
         */
        set scaleRatio(value: number);
        get scaleRatio(): number;
        /**
         * If a custom mesh has been set (Default: false)
         */
        protected _customMeshSet: boolean;
        /**
         * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)
         * * When set, interactions will be enabled
         */
        get attachedMesh(): Nullable<AbstractMesh>;
        set attachedMesh(value: Nullable<AbstractMesh>);
        /**
         * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)
         * * When set, interactions will be enabled
         */
        get attachedNode(): Nullable<Node>;
        set attachedNode(value: Nullable<Node>);
        /**
         * Disposes and replaces the current meshes in the gizmo with the specified mesh
         * @param mesh The mesh to replace the default mesh of the gizmo
         */
        setCustomMesh(mesh: Mesh): void;
        protected _updateGizmoRotationToMatchAttachedMesh: boolean;
        /**
         * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)
         */
        set updateGizmoRotationToMatchAttachedMesh(value: boolean);
        get updateGizmoRotationToMatchAttachedMesh(): boolean;
        /**
         * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)
         */
        updateGizmoPositionToMatchAttachedMesh: boolean;
        /**
         * When set, the gizmo will always appear the same size no matter where the camera is (default: true)
         */
        updateScale: boolean;
        protected _interactionsEnabled: boolean;
        protected _attachedNodeChanged(value: Nullable<Node>): void;
        private _beforeRenderObserver;
        private _tempQuaternion;
        private _tempVector;
        private _tempVector2;
        private _tempMatrix1;
        private _tempMatrix2;
        private _rightHandtoLeftHandMatrix;
        /**
         * Creates a gizmo
         * @param gizmoLayer The utility layer the gizmo will be added to
         */
        constructor(
        /** The utility layer the gizmo will be added to */
        gizmoLayer?: UtilityLayerRenderer);
        /**
         * Updates the gizmo to match the attached mesh's position/rotation
         */
        protected _update(): void;
        /**
         * computes the rotation/scaling/position of the transform once the Node world matrix has changed.
         * @param value Node, TransformNode or mesh
         */
        protected _matrixChanged(): void;
        /**
         * Disposes of the gizmo
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * Single plane drag gizmo
     */
    export class PlaneDragGizmo extends Gizmo {
        /**
         * Drag behavior responsible for the gizmos dragging interactions
         */
        dragBehavior: PointerDragBehavior;
        private _pointerObserver;
        /**
         * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
         */
        snapDistance: number;
        /**
         * Event that fires each time the gizmo snaps to a new location.
         * * snapDistance is the the change in distance
         */
        onSnapObservable: Observable<{
            snapDistance: number;
        }>;
        private _plane;
        private _coloredMaterial;
        private _hoverMaterial;
        private _isEnabled;
        private _parent;
        /** @hidden */
        static _CreatePlane(scene: Scene, material: StandardMaterial): TransformNode;
        /** @hidden */
        static _CreateArrowInstance(scene: Scene, arrow: TransformNode): TransformNode;
        /**
         * Creates a PlaneDragGizmo
         * @param gizmoLayer The utility layer the gizmo will be added to
         * @param dragPlaneNormal The axis normal to which the gizmo will be able to drag on
         * @param color The color of the gizmo
         */
        constructor(dragPlaneNormal: Vector3, color?: Color3, gizmoLayer?: UtilityLayerRenderer, parent?: Nullable<PositionGizmo>);
        protected _attachedNodeChanged(value: Nullable<Node>): void;
        /**
         * If the gizmo is enabled
         */
        set isEnabled(value: boolean);
        get isEnabled(): boolean;
        /**
         * Disposes of the gizmo
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * Gizmo that enables dragging a mesh along 3 axis
     */
    export class PositionGizmo extends Gizmo {
        /**
         * Internal gizmo used for interactions on the x axis
         */
        xGizmo: AxisDragGizmo;
        /**
         * Internal gizmo used for interactions on the y axis
         */
        yGizmo: AxisDragGizmo;
        /**
         * Internal gizmo used for interactions on the z axis
         */
        zGizmo: AxisDragGizmo;
        /**
         * Internal gizmo used for interactions on the yz plane
         */
        xPlaneGizmo: PlaneDragGizmo;
        /**
         * Internal gizmo used for interactions on the xz plane
         */
        yPlaneGizmo: PlaneDragGizmo;
        /**
         * Internal gizmo used for interactions on the xy plane
         */
        zPlaneGizmo: PlaneDragGizmo;
        /**
         * private variables
         */
        private _meshAttached;
        private _nodeAttached;
        private _snapDistance;
        /** Fires an event when any of it's sub gizmos are dragged */
        onDragStartObservable: Observable<unknown>;
        /** Fires an event when any of it's sub gizmos are released from dragging */
        onDragEndObservable: Observable<unknown>;
        /**
         * If set to true, planar drag is enabled
         */
        private _planarGizmoEnabled;
        get attachedMesh(): Nullable<AbstractMesh>;
        set attachedMesh(mesh: Nullable<AbstractMesh>);
        get attachedNode(): Nullable<Node>;
        set attachedNode(node: Nullable<Node>);
        /**
         * Creates a PositionGizmo
         * @param gizmoLayer The utility layer the gizmo will be added to
          @param thickness display gizmo axis thickness
         */
        constructor(gizmoLayer?: UtilityLayerRenderer, thickness?: number);
        /**
         * If the planar drag gizmo is enabled
         * setting this will enable/disable XY, XZ and YZ planes regardless of individual gizmo settings.
         */
        set planarGizmoEnabled(value: boolean);
        get planarGizmoEnabled(): boolean;
        set updateGizmoRotationToMatchAttachedMesh(value: boolean);
        get updateGizmoRotationToMatchAttachedMesh(): boolean;
        /**
         * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
         */
        set snapDistance(value: number);
        get snapDistance(): number;
        /**
         * Ratio for the scale of the gizmo (Default: 1)
         */
        set scaleRatio(value: number);
        get scaleRatio(): number;
        /**
         * Disposes of the gizmo
         */
        dispose(): void;
        /**
         * CustomMeshes are not supported by this gizmo
         * @param mesh The mesh to replace the default mesh of the gizmo
         */
        setCustomMesh(mesh: Mesh): void;
    }
}
declare module BABYLON {
    /**
     * Single axis drag gizmo
     */
    export class AxisDragGizmo extends Gizmo {
        /**
         * Drag behavior responsible for the gizmos dragging interactions
         */
        dragBehavior: PointerDragBehavior;
        private _pointerObserver;
        /**
         * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
         */
        snapDistance: number;
        /**
         * Event that fires each time the gizmo snaps to a new location.
         * * snapDistance is the the change in distance
         */
        onSnapObservable: Observable<{
            snapDistance: number;
        }>;
        private _isEnabled;
        private _parent;
        private _arrow;
        private _coloredMaterial;
        private _hoverMaterial;
        /** @hidden */
        static _CreateArrow(scene: Scene, material: StandardMaterial, thickness?: number): TransformNode;
        /** @hidden */
        static _CreateArrowInstance(scene: Scene, arrow: TransformNode): TransformNode;
        /**
         * Creates an AxisDragGizmo
         * @param gizmoLayer The utility layer the gizmo will be added to
         * @param dragAxis The axis which the gizmo will be able to drag on
         * @param color The color of the gizmo
         * @param thickness display gizmo axis thickness
         */
        constructor(dragAxis: Vector3, color?: Color3, gizmoLayer?: UtilityLayerRenderer, parent?: Nullable<PositionGizmo>, thickness?: number);
        protected _attachedNodeChanged(value: Nullable<Node>): void;
        /**
         * If the gizmo is enabled
         */
        set isEnabled(value: boolean);
        get isEnabled(): boolean;
        /**
         * Disposes of the gizmo
         */
        dispose(): void;
    }
}
declare module BABYLON.Debug {
    /**
         * The Axes viewer will show 3 axes in a specific point in space
         */
    export class AxesViewer {
        private _xAxis;
        private _yAxis;
        private _zAxis;
        private _scaleLinesFactor;
        private _instanced;
        /**
         * Gets the hosting scene
         */
        scene: Nullable<Scene>;
        /**
         * Gets or sets a number used to scale line length
         */
        scaleLines: number;
        /** Gets the node hierarchy used to render x-axis */
        get xAxis(): TransformNode;
        /** Gets the node hierarchy used to render y-axis */
        get yAxis(): TransformNode;
        /** Gets the node hierarchy used to render z-axis */
        get zAxis(): TransformNode;
        /**
         * Creates a new AxesViewer
         * @param scene defines the hosting scene
         * @param scaleLines defines a number used to scale line length (1 by default)
         * @param renderingGroupId defines a number used to set the renderingGroupId of the meshes (2 by default)
         * @param xAxis defines the node hierarchy used to render the x-axis
         * @param yAxis defines the node hierarchy used to render the y-axis
         * @param zAxis defines the node hierarchy used to render the z-axis
         */
        constructor(scene: Scene, scaleLines?: number, renderingGroupId?: Nullable<number>, xAxis?: TransformNode, yAxis?: TransformNode, zAxis?: TransformNode);
        /**
         * Force the viewer to update
         * @param position defines the position of the viewer
         * @param xaxis defines the x axis of the viewer
         * @param yaxis defines the y axis of the viewer
         * @param zaxis defines the z axis of the viewer
         */
        update(position: Vector3, xaxis: Vector3, yaxis: Vector3, zaxis: Vector3): void;
        /**
         * Creates an instance of this axes viewer.
         * @returns a new axes viewer with instanced meshes
         */
        createInstance(): AxesViewer;
        /** Releases resources */
        dispose(): void;
        private static _SetRenderingGroupId;
    }
}
declare module BABYLON.Debug {
    /**
         * The BoneAxesViewer will attach 3 axes to a specific bone of a specific mesh
         * @see demo here: https://www.babylonjs-playground.com/#0DE8F4#8
         */
    export class BoneAxesViewer extends AxesViewer {
        /**
         * Gets or sets the target mesh where to display the axes viewer
         */
        mesh: Nullable<Mesh>;
        /**
         * Gets or sets the target bone where to display the axes viewer
         */
        bone: Nullable<Bone>;
        /** Gets current position */
        pos: Vector3;
        /** Gets direction of X axis */
        xaxis: Vector3;
        /** Gets direction of Y axis */
        yaxis: Vector3;
        /** Gets direction of Z axis */
        zaxis: Vector3;
        /**
         * Creates a new BoneAxesViewer
         * @param scene defines the hosting scene
         * @param bone defines the target bone
         * @param mesh defines the target mesh
         * @param scaleLines defines a scaling factor for line length (1 by default)
         */
        constructor(scene: Scene, bone: Bone, mesh: Mesh, scaleLines?: number);
        /**
         * Force the viewer to update
         */
        update(): void;
        /** Releases resources */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * Interface used to define scene explorer extensibility option
     */
    export interface IExplorerExtensibilityOption {
        /**
         * Define the option label
         */
        label: string;
        /**
         * Defines the action to execute on click
         */
        action: (entity: any) => void;
    }
    /**
     * Defines a group of actions associated with a predicate to use when extending the Inspector scene explorer
     */
    export interface IExplorerExtensibilityGroup {
        /**
         * Defines a predicate to test if a given type mut be extended
         */
        predicate: (entity: any) => boolean;
        /**
         * Gets the list of options added to a type
         */
        entries: IExplorerExtensibilityOption[];
    }
    /**
     * Interface used to define the options to use to create the Inspector
     */
    export interface IInspectorOptions {
        /**
         * Display in overlay mode (default: false)
         */
        overlay?: boolean;
        /**
         * HTML element to use as root (the parent of the rendering canvas will be used as default value)
         */
        globalRoot?: HTMLElement;
        /**
         * Display the Scene explorer
         */
        showExplorer?: boolean;
        /**
         * Display the property inspector
         */
        showInspector?: boolean;
        /**
         * Display in embed mode (both panes on the right)
         */
        embedMode?: boolean;
        /**
         * let the Inspector handles resize of the canvas when panes are resized (default to true)
         */
        handleResize?: boolean;
        /**
         * Allow the panes to popup (default: true)
         */
        enablePopup?: boolean;
        /**
         * Allow the panes to be closed by users (default: true)
         */
        enableClose?: boolean;
        /**
         * Optional list of extensibility entries
         */
        explorerExtensibility?: IExplorerExtensibilityGroup[];
        /**
         * Optional URL to get the inspector script from (by default it uses the babylonjs CDN).
         */
        inspectorURL?: string;
        /**
         * Optional initial tab (default to DebugLayerTab.Properties)
         */
        initialTab?: DebugLayerTab;
    }
        interface Scene {
            /**
             * @hidden
             * Backing field
             */
            _debugLayer: DebugLayer;
            /**
             * Gets the debug layer (aka Inspector) associated with the scene
             * @see https://doc.babylonjs.com/features/playground_debuglayer
             */
            debugLayer: DebugLayer;
        }
    /**
     * Enum of inspector action tab
     */
    export enum DebugLayerTab {
        /**
         * Properties tag (default)
         */
        Properties = 0,
        /**
         * Debug tab
         */
        Debug = 1,
        /**
         * Statistics tab
         */
        Statistics = 2,
        /**
         * Tools tab
         */
        Tools = 3,
        /**
         * Settings tab
         */
        Settings = 4
    }
    /**
     * The debug layer (aka Inspector) is the go to tool in order to better understand
     * what is happening in your scene
     * @see https://doc.babylonjs.com/features/playground_debuglayer
     */
    export class DebugLayer {
        /**
         * Define the url to get the inspector script from.
         * By default it uses the babylonjs CDN.
         * @ignoreNaming
         */
        static InspectorURL: string;
        private _scene;
        private BJSINSPECTOR;
        private _onPropertyChangedObservable?;
        /**
         * Observable triggered when a property is changed through the inspector.
         */
        get onPropertyChangedObservable(): any;
        /**
         * Instantiates a new debug layer.
         * The debug layer (aka Inspector) is the go to tool in order to better understand
         * what is happening in your scene
         * @see https://doc.babylonjs.com/features/playground_debuglayer
         * @param scene Defines the scene to inspect
         */
        constructor(scene: Scene);
        /** Creates the inspector window. */
        private _createInspector;
        /**
         * Select a specific entity in the scene explorer and highlight a specific block in that entity property grid
         * @param entity defines the entity to select
         * @param lineContainerTitles defines the specific blocks to highlight (could be a string or an array of strings)
         */
        select(entity: any, lineContainerTitles?: string | string[]): void;
        /** Get the inspector from bundle or global */
        private _getGlobalInspector;
        /**
         * Get if the inspector is visible or not.
         * @returns true if visible otherwise, false
         */
        isVisible(): boolean;
        /**
         * Hide the inspector and close its window.
         */
        hide(): void;
        /**
         * Update the scene in the inspector
         */
        setAsActiveScene(): void;
        /**
          * Launch the debugLayer.
          * @param config Define the configuration of the inspector
          * @return a promise fulfilled when the debug layer is visible
          */
        show(config?: IInspectorOptions): Promise<DebugLayer>;
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class BoxBuilder {
        /**
         * Creates a box mesh
         * * The parameter `size` sets the size (float) of each box side (default 1)
         * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)
         * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)
         * * Please read this tutorial : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @see https://doc.babylonjs.com/how_to/set_shapes#box
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the box mesh
         */
        static CreateBox(name: string, options: {
            size?: number;
            width?: number;
            height?: number;
            depth?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            wrap?: boolean;
            topBaseAt?: number;
            bottomBaseAt?: number;
            updatable?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
    }
}
declare module BABYLON.Debug {
    /**
         * Used to show the physics impostor around the specific mesh
         */
    export class PhysicsViewer {
        /** @hidden */
        protected _impostors: Array<Nullable<PhysicsImpostor>>;
        /** @hidden */
        protected _meshes: Array<Nullable<AbstractMesh>>;
        /** @hidden */
        protected _scene: Nullable<Scene>;
        /** @hidden */
        protected _numMeshes: number;
        /** @hidden */
        protected _physicsEnginePlugin: Nullable<IPhysicsEnginePlugin>;
        private _renderFunction;
        private _utilityLayer;
        private _debugBoxMesh;
        private _debugSphereMesh;
        private _debugCylinderMesh;
        private _debugMaterial;
        private _debugMeshMeshes;
        /**
         * Creates a new PhysicsViewer
         * @param scene defines the hosting scene
         */
        constructor(scene: Scene);
        /** @hidden */
        protected _updateDebugMeshes(): void;
        /**
         * Renders a specified physic impostor
         * @param impostor defines the impostor to render
         * @param targetMesh defines the mesh represented by the impostor
         * @returns the new debug mesh used to render the impostor
         */
        showImpostor(impostor: PhysicsImpostor, targetMesh?: Mesh): Nullable<AbstractMesh>;
        /**
         * Hides a specified physic impostor
         * @param impostor defines the impostor to hide
         */
        hideImpostor(impostor: Nullable<PhysicsImpostor>): void;
        private _getDebugMaterial;
        private _getDebugBoxMesh;
        private _getDebugSphereMesh;
        private _getDebugCylinderMesh;
        private _getDebugMeshMesh;
        private _getDebugMesh;
        /** Releases all resources */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * As raycast might be hard to debug, the RayHelper can help rendering the different rays
     * in order to better appreciate the issue one might have.
     * @see https://doc.babylonjs.com/babylon101/raycasts#debugging
     */
    export class RayHelper {
        /**
         * Defines the ray we are currently tryin to visualize.
         */
        ray: Nullable<Ray>;
        private _renderPoints;
        private _renderLine;
        private _renderFunction;
        private _scene;
        private _onAfterRenderObserver;
        private _onAfterStepObserver;
        private _attachedToMesh;
        private _meshSpaceDirection;
        private _meshSpaceOrigin;
        /**
         * Helper function to create a colored helper in a scene in one line.
         * @param ray Defines the ray we are currently tryin to visualize
         * @param scene Defines the scene the ray is used in
         * @param color Defines the color we want to see the ray in
         * @returns The newly created ray helper.
         */
        static CreateAndShow(ray: Ray, scene: Scene, color: Color3): RayHelper;
        /**
         * Instantiate a new ray helper.
         * As raycast might be hard to debug, the RayHelper can help rendering the different rays
         * in order to better appreciate the issue one might have.
         * @see https://doc.babylonjs.com/babylon101/raycasts#debugging
         * @param ray Defines the ray we are currently tryin to visualize
         */
        constructor(ray: Ray);
        /**
         * Shows the ray we are willing to debug.
         * @param scene Defines the scene the ray needs to be rendered in
         * @param color Defines the color the ray needs to be rendered in
         */
        show(scene: Scene, color?: Color3): void;
        /**
         * Hides the ray we are debugging.
         */
        hide(): void;
        private _render;
        /**
         * Attach a ray helper to a mesh so that we can easily see its orientation for instance or information like its normals.
         * @param mesh Defines the mesh we want the helper attached to
         * @param meshSpaceDirection Defines the direction of the Ray in mesh space (local space of the mesh node)
         * @param meshSpaceOrigin Defines the origin of the Ray in mesh space (local space of the mesh node)
         * @param length Defines the length of the ray
         */
        attachToMesh(mesh: AbstractMesh, meshSpaceDirection?: Vector3, meshSpaceOrigin?: Vector3, length?: number): void;
        /**
         * Detach the ray helper from the mesh it has previously been attached to.
         */
        detachFromMesh(): void;
        private _updateToMesh;
        /**
         * Dispose the helper and release its associated resources.
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * Defines the options associated with the creation of a SkeletonViewer.
     */
    export interface ISkeletonViewerOptions {
        /** Should the system pause animations before building the Viewer? */
        pauseAnimations: boolean;
        /** Should the system return the skeleton to rest before building? */
        returnToRest: boolean;
        /** public Display Mode of the Viewer */
        displayMode: number;
        /** Flag to toggle if the Viewer should use the CPU for animations or not? */
        displayOptions: ISkeletonViewerDisplayOptions;
        /** Flag to toggle if the Viewer should use the CPU for animations or not? */
        computeBonesUsingShaders: boolean;
        /** Flag ignore non weighted bones */
        useAllBones: boolean;
    }
    /**
     * Defines how to display the various bone meshes for the viewer.
     */
    export interface ISkeletonViewerDisplayOptions {
        /** How far down to start tapering the bone spurs */
        midStep?: number;
        /** How big is the midStep? */
        midStepFactor?: number;
        /** Base for the Sphere Size */
        sphereBaseSize?: number;
        /** The ratio of the sphere to the longest bone in units */
        sphereScaleUnit?: number;
        /** Ratio for the Sphere Size */
        sphereFactor?: number;
    }
    /**
     * Defines the constructor options for the BoneWeight Shader.
     */
    export interface IBoneWeightShaderOptions {
        /** Skeleton to Map */
        skeleton: Skeleton;
        /** Colors for Uninfluenced bones */
        colorBase?: Color3;
        /** Colors for 0.0-0.25 Weight bones */
        colorZero?: Color3;
        /** Color for 0.25-0.5 Weight Influence */
        colorQuarter?: Color3;
        /** Color for 0.5-0.75 Weight Influence */
        colorHalf?: Color3;
        /** Color for 0.75-1 Weight Influence */
        colorFull?: Color3;
        /** Color for Zero Weight Influence */
        targetBoneIndex?: number;
    }
    /**
     * Simple structure of the gradient steps for the Color Map.
     */
    export interface ISkeletonMapShaderColorMapKnot {
        /** Color of the Knot */
        color: Color3;
        /** Location of the Knot */
        location: number;
    }
    /**
     * Defines the constructor options for the SkeletonMap Shader.
     */
    export interface ISkeletonMapShaderOptions {
        /** Skeleton to Map */
        skeleton: Skeleton;
        /** Array of ColorMapKnots that make the gradient must be ordered with knot[i].location < knot[i+1].location*/
        colorMap?: ISkeletonMapShaderColorMapKnot[];
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class RibbonBuilder {
        /**
         * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters
         * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry
         * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array
         * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array
         * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path
         * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11
         * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#ribbon
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
         * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones
         * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values
         * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry
         * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the ribbon mesh
         * @see https://doc.babylonjs.com/how_to/ribbon_tutorial
         * @see https://doc.babylonjs.com/how_to/parametric_shapes
         */
        static CreateRibbon(name: string, options: {
            pathArray: Vector3[][];
            closeArray?: boolean;
            closePath?: boolean;
            offset?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            instance?: Mesh;
            invertUV?: boolean;
            uvs?: Vector2[];
            colors?: Color4[];
        }, scene?: Nullable<Scene>): Mesh;
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class ShapeBuilder {
        /**
         * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
         * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
         * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
         * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.
         * * The parameter `scale` (float, default 1) is the value to scale the shape.
         * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
         * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape
         * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the extruded shape mesh
         * @see https://doc.babylonjs.com/how_to/parametric_shapes
         * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
         */
        static ExtrudeShape(name: string, options: {
            shape: Vector3[];
            path: Vector3[];
            scale?: number;
            rotation?: number;
            cap?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            instance?: Mesh;
            invertUV?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates an custom extruded shape mesh.
         * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
         * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
         * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
         * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path
         * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.
         * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path
         * * It must returns a float value that will be the scale value applied to the shape on each path point
         * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`
         * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`
         * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
         * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape
         * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the custom extruded shape mesh
         * @see https://doc.babylonjs.com/how_to/parametric_shapes#custom-extruded-shapes
         * @see https://doc.babylonjs.com/how_to/parametric_shapes
         * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
         */
        static ExtrudeShapeCustom(name: string, options: {
            shape: Vector3[];
            path: Vector3[];
            scaleFunction?: any;
            rotationFunction?: any;
            ribbonCloseArray?: boolean;
            ribbonClosePath?: boolean;
            cap?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            instance?: Mesh;
            invertUV?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
        private static _ExtrudeShapeGeneric;
    }
}
declare module BABYLON.Debug {
    /**
     * Class used to render a debug view of a given skeleton
     * @see http://www.babylonjs-playground.com/#1BZJVJ#8
     */
    export class SkeletonViewer {
        /** defines the skeleton to render */
        skeleton: Skeleton;
        /** defines the mesh attached to the skeleton */
        mesh: AbstractMesh;
        /** defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)  */
        autoUpdateBonesMatrices: boolean;
        /** defines the rendering group id to use with the viewer */
        renderingGroupId: number;
        /** is the options for the viewer */
        options: Partial<ISkeletonViewerOptions>;
        /** public Display constants BABYLON.SkeletonViewer.DISPLAY_LINES */
        static readonly DISPLAY_LINES: number;
        /** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERES */
        static readonly DISPLAY_SPHERES: number;
        /** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERE_AND_SPURS */
        static readonly DISPLAY_SPHERE_AND_SPURS: number;
        /** public static method to create a BoneWeight Shader
         * @param options The constructor options
         * @param scene The scene that the shader is scoped to
         * @returns The created ShaderMaterial
         * @see http://www.babylonjs-playground.com/#1BZJVJ#395
         */
        static CreateBoneWeightShader(options: IBoneWeightShaderOptions, scene: Scene): ShaderMaterial;
        /** public static method to create a BoneWeight Shader
         * @param options The constructor options
         * @param scene The scene that the shader is scoped to
         * @returns The created ShaderMaterial
         */
        static CreateSkeletonMapShader(options: ISkeletonMapShaderOptions, scene: Scene): ShaderMaterial;
        /** private static method to create a BoneWeight Shader
         * @param size The size of the buffer to create (usually the bone count)
         * @param colorMap The gradient data to generate
         * @param scene The scene that the shader is scoped to
         * @returns an Array of floats from the color gradient values
         */
        private static _CreateBoneMapColorBuffer;
        /** If SkeletonViewer scene scope. */
        private _scene;
        /** Gets or sets the color used to render the skeleton */
        color: Color3;
        /** Array of the points of the skeleton fo the line view. */
        private _debugLines;
        /** The SkeletonViewers Mesh. */
        private _debugMesh;
        /** If SkeletonViewer is enabled. */
        private _isEnabled;
        /** If SkeletonViewer is ready. */
        private _ready;
        /** SkeletonViewer render observable. */
        private _obs;
        /** The Utility Layer to render the gizmos in. */
        private _utilityLayer;
        private _boneIndices;
        /** Gets the Scene. */
        get scene(): Scene;
        /** Gets the utilityLayer. */
        get utilityLayer(): Nullable<UtilityLayerRenderer>;
        /** Checks Ready Status. */
        get isReady(): Boolean;
        /** Sets Ready Status. */
        set ready(value: boolean);
        /** Gets the debugMesh */
        get debugMesh(): Nullable<AbstractMesh> | Nullable<LinesMesh>;
        /** Sets the debugMesh */
        set debugMesh(value: Nullable<AbstractMesh> | Nullable<LinesMesh>);
        /** Gets the displayMode */
        get displayMode(): number;
        /** Sets the displayMode */
        set displayMode(value: number);
        /**
         * Creates a new SkeletonViewer
         * @param skeleton defines the skeleton to render
         * @param mesh defines the mesh attached to the skeleton
         * @param scene defines the hosting scene
         * @param autoUpdateBonesMatrices defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)
         * @param renderingGroupId defines the rendering group id to use with the viewer
         * @param options All of the extra constructor options for the SkeletonViewer
         */
        constructor(
        /** defines the skeleton to render */
        skeleton: Skeleton, 
        /** defines the mesh attached to the skeleton */
        mesh: AbstractMesh, 
        /** The Scene scope*/
        scene: Scene, 
        /** defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)  */
        autoUpdateBonesMatrices?: boolean, 
        /** defines the rendering group id to use with the viewer */
        renderingGroupId?: number, 
        /** is the options for the viewer */
        options?: Partial<ISkeletonViewerOptions>);
        /** The Dynamic bindings for the update functions */
        private _bindObs;
        /** Update the viewer to sync with current skeleton state, only used to manually update. */
        update(): void;
        /** Gets or sets a boolean indicating if the viewer is enabled */
        set isEnabled(value: boolean);
        get isEnabled(): boolean;
        private _getBonePosition;
        private _getLinesForBonesWithLength;
        private _getLinesForBonesNoLength;
        /** function to revert the mesh and scene back to the initial state. */
        private _revert;
        /** function to build and bind sphere joint points and spur bone representations. */
        private _buildSpheresAndSpurs;
        /** Update the viewer to sync with current skeleton state, only used for the line display. */
        private _displayLinesUpdate;
        /** Changes the displayMode of the skeleton viewer
         * @param mode The displayMode numerical value
         */
        changeDisplayMode(mode: number): void;
        /** Changes the displayMode of the skeleton viewer
         * @param option String of the option name
         * @param value The numerical option value
         */
        changeDisplayOptions(option: string, value: number): void;
        /** Release associated resources */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * Enum for Device Types
     */
    export enum DeviceType {
        /** Generic */
        Generic = 0,
        /** Keyboard */
        Keyboard = 1,
        /** Mouse */
        Mouse = 2,
        /** Touch Pointers */
        Touch = 3,
        /** PS4 Dual Shock */
        DualShock = 4,
        /** Xbox */
        Xbox = 5,
        /** Switch Controller */
        Switch = 6
    }
    /**
     * Enum for All Pointers (Touch/Mouse)
     */
    export enum PointerInput {
        /** Horizontal Axis */
        Horizontal = 0,
        /** Vertical Axis */
        Vertical = 1,
        /** Left Click or Touch */
        LeftClick = 2,
        /** Middle Click */
        MiddleClick = 3,
        /** Right Click */
        RightClick = 4,
        /** Browser Back */
        BrowserBack = 5,
        /** Browser Forward */
        BrowserForward = 6
    }
    /**
     * Enum for Dual Shock Gamepad
     */
    export enum DualShockInput {
        /** Cross */
        Cross = 0,
        /** Circle */
        Circle = 1,
        /** Square */
        Square = 2,
        /** Triangle */
        Triangle = 3,
        /** L1 */
        L1 = 4,
        /** R1 */
        R1 = 5,
        /** L2 */
        L2 = 6,
        /** R2 */
        R2 = 7,
        /** Share */
        Share = 8,
        /** Options */
        Options = 9,
        /** L3 */
        L3 = 10,
        /** R3 */
        R3 = 11,
        /** DPadUp */
        DPadUp = 12,
        /** DPadDown */
        DPadDown = 13,
        /** DPadLeft */
        DPadLeft = 14,
        /** DRight */
        DPadRight = 15,
        /** Home */
        Home = 16,
        /** TouchPad */
        TouchPad = 17,
        /** LStickXAxis */
        LStickXAxis = 18,
        /** LStickYAxis */
        LStickYAxis = 19,
        /** RStickXAxis */
        RStickXAxis = 20,
        /** RStickYAxis */
        RStickYAxis = 21
    }
    /**
     * Enum for Xbox Gamepad
     */
    export enum XboxInput {
        /** A */
        A = 0,
        /** B */
        B = 1,
        /** X */
        X = 2,
        /** Y */
        Y = 3,
        /** LB */
        LB = 4,
        /** RB */
        RB = 5,
        /** LT */
        LT = 6,
        /** RT */
        RT = 7,
        /** Back */
        Back = 8,
        /** Start */
        Start = 9,
        /** LS */
        LS = 10,
        /** RS */
        RS = 11,
        /** DPadUp */
        DPadUp = 12,
        /** DPadDown */
        DPadDown = 13,
        /** DPadLeft */
        DPadLeft = 14,
        /** DRight */
        DPadRight = 15,
        /** Home */
        Home = 16,
        /** LStickXAxis */
        LStickXAxis = 17,
        /** LStickYAxis */
        LStickYAxis = 18,
        /** RStickXAxis */
        RStickXAxis = 19,
        /** RStickYAxis */
        RStickYAxis = 20
    }
    /**
     * Enum for Switch (Pro/JoyCon L+R) Gamepad
     */
    export enum SwitchInput {
        /** B */
        B = 0,
        /** A */
        A = 1,
        /** Y */
        Y = 2,
        /** X */
        X = 3,
        /** L */
        L = 4,
        /** R */
        R = 5,
        /** ZL */
        ZL = 6,
        /** ZR */
        ZR = 7,
        /** Minus */
        Minus = 8,
        /** Plus */
        Plus = 9,
        /** LS */
        LS = 10,
        /** RS */
        RS = 11,
        /** DPadUp */
        DPadUp = 12,
        /** DPadDown */
        DPadDown = 13,
        /** DPadLeft */
        DPadLeft = 14,
        /** DRight */
        DPadRight = 15,
        /** Home */
        Home = 16,
        /** Capture */
        Capture = 17,
        /** LStickXAxis */
        LStickXAxis = 18,
        /** LStickYAxis */
        LStickYAxis = 19,
        /** RStickXAxis */
        RStickXAxis = 20,
        /** RStickYAxis */
        RStickYAxis = 21
    }
}
declare module BABYLON {
    /**
     * This class will take all inputs from Keyboard, Pointer, and
     * any Gamepads and provide a polling system that all devices
     * will use.  This class assumes that there will only be one
     * pointer device and one keyboard.
     */
    export class DeviceInputSystem implements IDisposable {
        /**
         * Callback to be triggered when a device is connected
         */
        onDeviceConnected: (deviceType: DeviceType, deviceSlot: number) => void;
        /**
         * Callback to be triggered when a device is disconnected
         */
        onDeviceDisconnected: (deviceType: DeviceType, deviceSlot: number) => void;
        /**
         * Callback to be triggered when event driven input is updated
         */
        onInputChanged: (deviceType: DeviceType, deviceSlot: number, inputIndex: number, previousState: Nullable<number>, currentState: Nullable<number>) => void;
        private _inputs;
        private _gamepads;
        private _keyboardActive;
        private _pointerActive;
        private _elementToAttachTo;
        private _keyboardDownEvent;
        private _keyboardUpEvent;
        private _pointerMoveEvent;
        private _pointerDownEvent;
        private _pointerUpEvent;
        private _gamepadConnectedEvent;
        private _gamepadDisconnectedEvent;
        private static _MAX_KEYCODES;
        private static _MAX_POINTER_INPUTS;
        private constructor();
        /**
         * Creates a new DeviceInputSystem instance
         * @param engine Engine to pull input element from
         * @returns The new instance
         */
        static Create(engine: Engine): DeviceInputSystem;
        /**
         * Checks for current device input value, given an id and input index
         * @param deviceName Id of connected device
         * @param inputIndex Index of device input
         * @returns Current value of input
         */
        /**
         * Checks for current device input value, given an id and input index. Throws exception if requested device not initialized.
         * @param deviceType Enum specifiying device type
         * @param deviceSlot "Slot" or index that device is referenced in
         * @param inputIndex Id of input to be checked
         * @returns Current value of input
         */
        pollInput(deviceType: DeviceType, deviceSlot: number, inputIndex: number): number;
        /**
         * Dispose of all the eventlisteners
         */
        dispose(): void;
        /**
         * Add device and inputs to device array
         * @param deviceType Enum specifiying device type
         * @param deviceSlot "Slot" or index that device is referenced in
         * @param numberOfInputs Number of input entries to create for given device
         */
        private _registerDevice;
        /**
         * Given a specific device name, remove that device from the device map
         * @param deviceType Enum specifiying device type
         * @param deviceSlot "Slot" or index that device is referenced in
         */
        private _unregisterDevice;
        /**
         * Handle all actions that come from keyboard interaction
         */
        private _handleKeyActions;
        /**
         * Handle all actions that come from pointer interaction
         */
        private _handlePointerActions;
        /**
         * Handle all actions that come from gamepad interaction
         */
        private _handleGamepadActions;
        /**
         * Update all non-event based devices with each frame
         * @param deviceType Enum specifiying device type
         * @param deviceSlot "Slot" or index that device is referenced in
         * @param inputIndex Id of input to be checked
         */
        private _updateDevice;
        /**
         * Gets DeviceType from the device name
         * @param deviceName Name of Device from DeviceInputSystem
         * @returns DeviceType enum value
         */
        private _getGamepadDeviceType;
    }
}
declare module BABYLON {
    /**
     * Type to handle enforcement of inputs
     */
    export type DeviceInput<T extends DeviceType> = T extends DeviceType.Keyboard | DeviceType.Generic ? number : T extends DeviceType.Mouse | DeviceType.Touch ? PointerInput : T extends DeviceType.DualShock ? DualShockInput : T extends DeviceType.Xbox ? XboxInput : T extends DeviceType.Switch ? SwitchInput : never;
}
declare module BABYLON {
    /**
     * Class that handles all input for a specific device
     */
    export class DeviceSource<T extends DeviceType> {
        /** Type of device */
        readonly deviceType: DeviceType;
        /** "Slot" or index that device is referenced in */
        readonly deviceSlot: number;
        /**
         * Observable to handle device input changes per device
         */
        readonly onInputChangedObservable: Observable<{
            inputIndex: DeviceInput<T>;
            previousState: Nullable<number>;
            currentState: Nullable<number>;
        }>;
        private readonly _deviceInputSystem;
        /**
         * Default Constructor
         * @param deviceInputSystem Reference to DeviceInputSystem
         * @param deviceType Type of device
         * @param deviceSlot "Slot" or index that device is referenced in
         */
        constructor(deviceInputSystem: DeviceInputSystem, 
        /** Type of device */
        deviceType: DeviceType, 
        /** "Slot" or index that device is referenced in */
        deviceSlot?: number);
        /**
         * Get input for specific input
         * @param inputIndex index of specific input on device
         * @returns Input value from DeviceInputSystem
         */
        getInput(inputIndex: DeviceInput<T>): number;
    }
    /**
     * Class to keep track of devices
     */
    export class DeviceSourceManager implements IDisposable {
        /**
         * Observable to be triggered when before a device is connected
         */
        readonly onBeforeDeviceConnectedObservable: Observable<{
            deviceType: DeviceType;
            deviceSlot: number;
        }>;
        /**
         * Observable to be triggered when before a device is disconnected
         */
        readonly onBeforeDeviceDisconnectedObservable: Observable<{
            deviceType: DeviceType;
            deviceSlot: number;
        }>;
        /**
         * Observable to be triggered when after a device is connected
         */
        readonly onAfterDeviceConnectedObservable: Observable<{
            deviceType: DeviceType;
            deviceSlot: number;
        }>;
        /**
         * Observable to be triggered when after a device is disconnected
         */
        readonly onAfterDeviceDisconnectedObservable: Observable<{
            deviceType: DeviceType;
            deviceSlot: number;
        }>;
        private readonly _devices;
        private readonly _firstDevice;
        private readonly _deviceInputSystem;
        /**
         * Default Constructor
         * @param engine engine to pull input element from
         */
        constructor(engine: Engine);
        /**
         * Gets a DeviceSource, given a type and slot
         * @param deviceType Enum specifying device type
         * @param deviceSlot "Slot" or index that device is referenced in
         * @returns DeviceSource object
         */
        getDeviceSource<T extends DeviceType>(deviceType: T, deviceSlot?: number): Nullable<DeviceSource<T>>;
        /**
         * Gets an array of DeviceSource objects for a given device type
         * @param deviceType Enum specifying device type
         * @returns Array of DeviceSource objects
         */
        getDeviceSources<T extends DeviceType>(deviceType: T): ReadonlyArray<DeviceSource<T>>;
        /**
         * Dispose of DeviceInputSystem and other parts
         */
        dispose(): void;
        /**
         * Function to add device name to device list
         * @param deviceType Enum specifying device type
         * @param deviceSlot "Slot" or index that device is referenced in
         */
        private _addDevice;
        /**
         * Function to remove device name to device list
         * @param deviceType Enum specifying device type
         * @param deviceSlot "Slot" or index that device is referenced in
         */
        private _removeDevice;
        /**
         * Updates array storing first connected device of each type
         * @param type Type of Device
         */
        private _updateFirstDevices;
    }
}
declare module BABYLON {
    /**
     * Options to create the null engine
     */
    export class NullEngineOptions {
        /**
         * Render width (Default: 512)
         */
        renderWidth: number;
        /**
         * Render height (Default: 256)
         */
        renderHeight: number;
        /**
         * Texture size (Default: 512)
         */
        textureSize: number;
        /**
         * If delta time between frames should be constant
         * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         */
        deterministicLockstep: boolean;
        /**
         * Maximum about of steps between frames (Default: 4)
         * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         */
        lockstepMaxSteps: number;
        /**
         * Make the matrix computations to be performed in 64 bits instead of 32 bits. False by default
         */
        useHighPrecisionMatrix?: boolean;
    }
    /**
     * The null engine class provides support for headless version of babylon.js.
     * This can be used in server side scenario or for testing purposes
     */
    export class NullEngine extends Engine {
        private _options;
        /**
         * Gets a boolean indicating that the engine is running in deterministic lock step mode
         * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         * @returns true if engine is in deterministic lock step mode
         */
        isDeterministicLockStep(): boolean;
        /**
         * Gets the max steps when engine is running in deterministic lock step
         * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         * @returns the max steps
         */
        getLockstepMaxSteps(): number;
        /**
         * Gets the current hardware scaling level.
         * By default the hardware scaling level is computed from the window device ratio.
         * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.
         * @returns a number indicating the current hardware scaling level
         */
        getHardwareScalingLevel(): number;
        constructor(options?: NullEngineOptions);
        /**
         * Creates a vertex buffer
         * @param vertices the data for the vertex buffer
         * @returns the new WebGL static buffer
         */
        createVertexBuffer(vertices: FloatArray): DataBuffer;
        /**
         * Creates a new index buffer
         * @param indices defines the content of the index buffer
         * @param updatable defines if the index buffer must be updatable
         * @returns a new webGL buffer
         */
        createIndexBuffer(indices: IndicesArray): DataBuffer;
        /**
         * Clear the current render buffer or the current render target (if any is set up)
         * @param color defines the color to use
         * @param backBuffer defines if the back buffer must be cleared
         * @param depth defines if the depth buffer must be cleared
         * @param stencil defines if the stencil buffer must be cleared
         */
        clear(color: IColor4Like, backBuffer: boolean, depth: boolean, stencil?: boolean): void;
        /**
         * Gets the current render width
         * @param useScreen defines if screen size must be used (or the current render target if any)
         * @returns a number defining the current render width
         */
        getRenderWidth(useScreen?: boolean): number;
        /**
         * Gets the current render height
         * @param useScreen defines if screen size must be used (or the current render target if any)
         * @returns a number defining the current render height
         */
        getRenderHeight(useScreen?: boolean): number;
        /**
         * Set the WebGL's viewport
         * @param viewport defines the viewport element to be used
         * @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used
         * @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used
         */
        setViewport(viewport: IViewportLike, requiredWidth?: number, requiredHeight?: number): void;
        createShaderProgram(pipelineContext: IPipelineContext, vertexCode: string, fragmentCode: string, defines: string, context?: WebGLRenderingContext): WebGLProgram;
        /**
         * Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names
         * @param pipelineContext defines the pipeline context to use
         * @param uniformsNames defines the list of uniform names
         * @returns an array of webGL uniform locations
         */
        getUniforms(pipelineContext: IPipelineContext, uniformsNames: string[]): Nullable<WebGLUniformLocation>[];
        /**
         * Gets the lsit of active attributes for a given webGL program
         * @param pipelineContext defines the pipeline context to use
         * @param attributesNames defines the list of attribute names to get
         * @returns an array of indices indicating the offset of each attribute
         */
        getAttributes(pipelineContext: IPipelineContext, attributesNames: string[]): number[];
        /**
         * Binds an effect to the webGL context
         * @param effect defines the effect to bind
         */
        bindSamplers(effect: Effect): void;
        /**
         * Activates an effect, mkaing it the current one (ie. the one used for rendering)
         * @param effect defines the effect to activate
         */
        enableEffect(effect: Effect): void;
        /**
         * Set various states to the webGL context
         * @param culling defines backface culling state
         * @param zOffset defines the value to apply to zOffset (0 by default)
         * @param force defines if states must be applied even if cache is up to date
         * @param reverseSide defines if culling must be reversed (CCW instead of CW and CW instead of CCW)
         */
        setState(culling: boolean, zOffset?: number, force?: boolean, reverseSide?: boolean): void;
        /**
         * Set the value of an uniform to an array of int32
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of int32 to store
         */
        setIntArray(uniform: WebGLUniformLocation, array: Int32Array): void;
        /**
         * Set the value of an uniform to an array of int32 (stored as vec2)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of int32 to store
         */
        setIntArray2(uniform: WebGLUniformLocation, array: Int32Array): void;
        /**
         * Set the value of an uniform to an array of int32 (stored as vec3)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of int32 to store
         */
        setIntArray3(uniform: WebGLUniformLocation, array: Int32Array): void;
        /**
         * Set the value of an uniform to an array of int32 (stored as vec4)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of int32 to store
         */
        setIntArray4(uniform: WebGLUniformLocation, array: Int32Array): void;
        /**
         * Set the value of an uniform to an array of float32
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of float32 to store
         */
        setFloatArray(uniform: WebGLUniformLocation, array: Float32Array): void;
        /**
         * Set the value of an uniform to an array of float32 (stored as vec2)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of float32 to store
         */
        setFloatArray2(uniform: WebGLUniformLocation, array: Float32Array): void;
        /**
         * Set the value of an uniform to an array of float32 (stored as vec3)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of float32 to store
         */
        setFloatArray3(uniform: WebGLUniformLocation, array: Float32Array): void;
        /**
         * Set the value of an uniform to an array of float32 (stored as vec4)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of float32 to store
         */
        setFloatArray4(uniform: WebGLUniformLocation, array: Float32Array): void;
        /**
         * Set the value of an uniform to an array of number
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of number to store
         */
        setArray(uniform: WebGLUniformLocation, array: number[]): void;
        /**
         * Set the value of an uniform to an array of number (stored as vec2)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of number to store
         */
        setArray2(uniform: WebGLUniformLocation, array: number[]): void;
        /**
         * Set the value of an uniform to an array of number (stored as vec3)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of number to store
         */
        setArray3(uniform: WebGLUniformLocation, array: number[]): void;
        /**
         * Set the value of an uniform to an array of number (stored as vec4)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of number to store
         */
        setArray4(uniform: WebGLUniformLocation, array: number[]): void;
        /**
         * Set the value of an uniform to an array of float32 (stored as matrices)
         * @param uniform defines the webGL uniform location where to store the value
         * @param matrices defines the array of float32 to store
         */
        setMatrices(uniform: WebGLUniformLocation, matrices: Float32Array): void;
        /**
         * Set the value of an uniform to a matrix (3x3)
         * @param uniform defines the webGL uniform location where to store the value
         * @param matrix defines the Float32Array representing the 3x3 matrix to store
         */
        setMatrix3x3(uniform: WebGLUniformLocation, matrix: Float32Array): void;
        /**
         * Set the value of an uniform to a matrix (2x2)
         * @param uniform defines the webGL uniform location where to store the value
         * @param matrix defines the Float32Array representing the 2x2 matrix to store
         */
        setMatrix2x2(uniform: WebGLUniformLocation, matrix: Float32Array): void;
        /**
         * Set the value of an uniform to a number (float)
         * @param uniform defines the webGL uniform location where to store the value
         * @param value defines the float number to store
         */
        setFloat(uniform: WebGLUniformLocation, value: number): void;
        /**
         * Set the value of an uniform to a vec2
         * @param uniform defines the webGL uniform location where to store the value
         * @param x defines the 1st component of the value
         * @param y defines the 2nd component of the value
         */
        setFloat2(uniform: WebGLUniformLocation, x: number, y: number): void;
        /**
         * Set the value of an uniform to a vec3
         * @param uniform defines the webGL uniform location where to store the value
         * @param x defines the 1st component of the value
         * @param y defines the 2nd component of the value
         * @param z defines the 3rd component of the value
         */
        setFloat3(uniform: WebGLUniformLocation, x: number, y: number, z: number): void;
        /**
         * Set the value of an uniform to a boolean
         * @param uniform defines the webGL uniform location where to store the value
         * @param bool defines the boolean to store
         */
        setBool(uniform: WebGLUniformLocation, bool: number): void;
        /**
         * Set the value of an uniform to a vec4
         * @param uniform defines the webGL uniform location where to store the value
         * @param x defines the 1st component of the value
         * @param y defines the 2nd component of the value
         * @param z defines the 3rd component of the value
         * @param w defines the 4th component of the value
         */
        setFloat4(uniform: WebGLUniformLocation, x: number, y: number, z: number, w: number): void;
        /**
         * Sets the current alpha mode
         * @param mode defines the mode to use (one of the Engine.ALPHA_XXX)
         * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)
         * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered
         */
        setAlphaMode(mode: number, noDepthWriteChange?: boolean): void;
        /**
         * Bind webGl buffers directly to the webGL context
         * @param vertexBuffers defines the vertex buffer to bind
         * @param indexBuffer defines the index buffer to bind
         * @param vertexDeclaration defines the vertex declaration to use with the vertex buffer
         * @param vertexStrideSize defines the vertex stride of the vertex buffer
         * @param effect defines the effect associated with the vertex buffer
         */
        bindBuffers(vertexBuffers: {
            [key: string]: VertexBuffer;
        }, indexBuffer: DataBuffer, effect: Effect): void;
        /**
         * Force the entire cache to be cleared
         * You should not have to use this function unless your engine needs to share the webGL context with another engine
         * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)
         */
        wipeCaches(bruteForce?: boolean): void;
        /**
         * Send a draw order
         * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)
         * @param indexStart defines the starting index
         * @param indexCount defines the number of index to draw
         * @param instancesCount defines the number of instances to draw (if instanciation is enabled)
         */
        draw(useTriangles: boolean, indexStart: number, indexCount: number, instancesCount?: number): void;
        /**
         * Draw a list of indexed primitives
         * @param fillMode defines the primitive to use
         * @param indexStart defines the starting index
         * @param indexCount defines the number of index to draw
         * @param instancesCount defines the number of instances to draw (if instanciation is enabled)
         */
        drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount?: number): void;
        /**
         * Draw a list of unindexed primitives
         * @param fillMode defines the primitive to use
         * @param verticesStart defines the index of first vertex to draw
         * @param verticesCount defines the count of vertices to draw
         * @param instancesCount defines the number of instances to draw (if instanciation is enabled)
         */
        drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount?: number): void;
        /** @hidden */
        _createTexture(): WebGLTexture;
        /** @hidden */
        _releaseTexture(texture: InternalTexture): void;
        /**
         * Usually called from Texture.ts.
         * Passed information to create a WebGLTexture
         * @param urlArg defines a value which contains one of the following:
         * * A conventional http URL, e.g. 'http://...' or 'file://...'
         * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'
         * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'
         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file
         * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)
         * @param scene needed for loading to the correct scene
         * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)
         * @param onLoad optional callback to be called upon successful completion
         * @param onError optional callback to be called upon failure
         * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob
         * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities
         * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures
         * @param forcedExtension defines the extension to use to pick the right loader
         * @param mimeType defines an optional mime type
         * @returns a InternalTexture for assignment back into BABYLON.Texture
         */
        createTexture(urlArg: Nullable<string>, noMipmap: boolean, invertY: boolean, scene: Nullable<ISceneLike>, samplingMode?: number, onLoad?: Nullable<() => void>, onError?: Nullable<(message: string, exception: any) => void>, buffer?: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap>, fallback?: Nullable<InternalTexture>, format?: Nullable<number>, forcedExtension?: Nullable<string>, mimeType?: string): InternalTexture;
        /**
         * Creates a new render target texture
         * @param size defines the size of the texture
         * @param options defines the options used to create the texture
         * @returns a new render target texture stored in an InternalTexture
         */
        createRenderTargetTexture(size: any, options: boolean | RenderTargetCreationOptions): InternalTexture;
        /**
         * Update the sampling mode of a given texture
         * @param samplingMode defines the required sampling mode
         * @param texture defines the texture to update
         */
        updateTextureSamplingMode(samplingMode: number, texture: InternalTexture): void;
        /**
         * Binds the frame buffer to the specified texture.
         * @param texture The texture to render to or null for the default canvas
         * @param faceIndex The face of the texture to render to in case of cube texture
         * @param requiredWidth The width of the target to render to
         * @param requiredHeight The height of the target to render to
         * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true
         * @param lodLevel defines le lod level to bind to the frame buffer
         */
        bindFramebuffer(texture: InternalTexture, faceIndex?: number, requiredWidth?: number, requiredHeight?: number, forceFullscreenViewport?: boolean): void;
        /**
         * Unbind the current render target texture from the webGL context
         * @param texture defines the render target texture to unbind
         * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated
         * @param onBeforeUnbind defines a function which will be called before the effective unbind
         */
        unBindFramebuffer(texture: InternalTexture, disableGenerateMipMaps?: boolean, onBeforeUnbind?: () => void): void;
        /**
         * Creates a dynamic vertex buffer
         * @param vertices the data for the dynamic vertex buffer
         * @returns the new WebGL dynamic buffer
         */
        createDynamicVertexBuffer(vertices: FloatArray): DataBuffer;
        /**
         * Update the content of a dynamic texture
         * @param texture defines the texture to update
         * @param canvas defines the canvas containing the source
         * @param invertY defines if data must be stored with Y axis inverted
         * @param premulAlpha defines if alpha is stored as premultiplied
         * @param format defines the format of the data
         * @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)
         */
        updateDynamicTexture(texture: Nullable<InternalTexture>, canvas: HTMLCanvasElement, invertY: boolean, premulAlpha?: boolean, format?: number): void;
        /**
         * Gets a boolean indicating if all created effects are ready
         * @returns true if all effects are ready
         */
        areAllEffectsReady(): boolean;
        /**
         * @hidden
         * Get the current error code of the webGL context
         * @returns the error code
         * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError
         */
        getError(): number;
        /** @hidden */
        _getUnpackAlignement(): number;
        /** @hidden */
        _unpackFlipY(value: boolean): void;
        /**
         * Update a dynamic index buffer
         * @param indexBuffer defines the target index buffer
         * @param indices defines the data to update
         * @param offset defines the offset in the target index buffer where update should start
         */
        updateDynamicIndexBuffer(indexBuffer: WebGLBuffer, indices: IndicesArray, offset?: number): void;
        /**
         * Updates a dynamic vertex buffer.
         * @param vertexBuffer the vertex buffer to update
         * @param vertices the data used to update the vertex buffer
         * @param byteOffset the byte offset of the data (optional)
         * @param byteLength the byte length of the data (optional)
         */
        updateDynamicVertexBuffer(vertexBuffer: WebGLBuffer, vertices: FloatArray, byteOffset?: number, byteLength?: number): void;
        /** @hidden */
        _bindTextureDirectly(target: number, texture: InternalTexture): boolean;
        /** @hidden */
        _bindTexture(channel: number, texture: InternalTexture): void;
        protected _deleteBuffer(buffer: WebGLBuffer): void;
        /**
         * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled
         */
        releaseEffects(): void;
        displayLoadingUI(): void;
        hideLoadingUI(): void;
        /** @hidden */
        _uploadCompressedDataToTextureDirectly(texture: InternalTexture, internalFormat: number, width: number, height: number, data: ArrayBufferView, faceIndex?: number, lod?: number): void;
        /** @hidden */
        _uploadDataToTextureDirectly(texture: InternalTexture, imageData: ArrayBufferView, faceIndex?: number, lod?: number): void;
        /** @hidden */
        _uploadArrayBufferViewToTexture(texture: InternalTexture, imageData: ArrayBufferView, faceIndex?: number, lod?: number): void;
        /** @hidden */
        _uploadImageToTexture(texture: InternalTexture, image: HTMLImageElement, faceIndex?: number, lod?: number): void;
    }
}
declare module BABYLON {
    /**
     * @hidden
     **/
    export class _TimeToken {
        _startTimeQuery: Nullable<WebGLQuery>;
        _endTimeQuery: Nullable<WebGLQuery>;
        _timeElapsedQuery: Nullable<WebGLQuery>;
        _timeElapsedQueryEnded: boolean;
    }
}
declare module BABYLON {
    /** @hidden */
    export class _OcclusionDataStorage {
        /** @hidden */
        occlusionInternalRetryCounter: number;
        /** @hidden */
        isOcclusionQueryInProgress: boolean;
        /** @hidden */
        isOccluded: boolean;
        /** @hidden */
        occlusionRetryCount: number;
        /** @hidden */
        occlusionType: number;
        /** @hidden */
        occlusionQueryAlgorithmType: number;
    }
        interface Engine {
            /**
             * Create a new webGL query (you must be sure that queries are supported by checking getCaps() function)
             * @return the new query
             */
            createQuery(): WebGLQuery;
            /**
             * Delete and release a webGL query
             * @param query defines the query to delete
             * @return the current engine
             */
            deleteQuery(query: WebGLQuery): Engine;
            /**
             * Check if a given query has resolved and got its value
             * @param query defines the query to check
             * @returns true if the query got its value
             */
            isQueryResultAvailable(query: WebGLQuery): boolean;
            /**
             * Gets the value of a given query
             * @param query defines the query to check
             * @returns the value of the query
             */
            getQueryResult(query: WebGLQuery): number;
            /**
             * Initiates an occlusion query
             * @param algorithmType defines the algorithm to use
             * @param query defines the query to use
             * @returns the current engine
             * @see https://doc.babylonjs.com/features/occlusionquery
             */
            beginOcclusionQuery(algorithmType: number, query: WebGLQuery): Engine;
            /**
             * Ends an occlusion query
             * @see https://doc.babylonjs.com/features/occlusionquery
             * @param algorithmType defines the algorithm to use
             * @returns the current engine
             */
            endOcclusionQuery(algorithmType: number): Engine;
            /**
             * Starts a time query (used to measure time spent by the GPU on a specific frame)
             * Please note that only one query can be issued at a time
             * @returns a time token used to track the time span
             */
            startTimeQuery(): Nullable<_TimeToken>;
            /**
             * Ends a time query
             * @param token defines the token used to measure the time span
             * @returns the time spent (in ns)
             */
            endTimeQuery(token: _TimeToken): int;
            /** @hidden */
            _currentNonTimestampToken: Nullable<_TimeToken>;
            /** @hidden */
            _createTimeQuery(): WebGLQuery;
            /** @hidden */
            _deleteTimeQuery(query: WebGLQuery): void;
            /** @hidden */
            _getGlAlgorithmType(algorithmType: number): number;
            /** @hidden */
            _getTimeQueryResult(query: WebGLQuery): any;
            /** @hidden */
            _getTimeQueryAvailability(query: WebGLQuery): any;
        }
        interface AbstractMesh {
            /**
             * Backing filed
             * @hidden
             */
            __occlusionDataStorage: _OcclusionDataStorage;
            /**
             * Access property
             * @hidden
             */
            _occlusionDataStorage: _OcclusionDataStorage;
            /**
            * This number indicates the number of allowed retries before stop the occlusion query, this is useful if the occlusion query is taking long time before to the query result is retireved, the query result indicates if the object is visible within the scene or not and based on that Babylon.Js engine decideds to show or hide the object.
            * The default value is -1 which means don't break the query and wait till the result
            * @see https://doc.babylonjs.com/features/occlusionquery
            */
            occlusionRetryCount: number;
            /**
             * This property is responsible for starting the occlusion query within the Mesh or not, this property is also used to determine what should happen when the occlusionRetryCount is reached. It has supports 3 values:
             * * OCCLUSION_TYPE_NONE (Default Value): this option means no occlusion query whith the Mesh.
             * * OCCLUSION_TYPE_OPTIMISTIC: this option is means use occlusion query and if occlusionRetryCount is reached and the query is broken show the mesh.
             * * OCCLUSION_TYPE_STRICT: this option is means use occlusion query and if occlusionRetryCount is reached and the query is broken restore the last state of the mesh occlusion if the mesh was visible then show the mesh if was hidden then hide don't show.
             * @see https://doc.babylonjs.com/features/occlusionquery
             */
            occlusionType: number;
            /**
            * This property determines the type of occlusion query algorithm to run in WebGl, you can use:
            * * AbstractMesh.OCCLUSION_ALGORITHM_TYPE_ACCURATE which is mapped to GL_ANY_SAMPLES_PASSED.
            * * AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE (Default Value) which is mapped to GL_ANY_SAMPLES_PASSED_CONSERVATIVE which is a false positive algorithm that is faster than GL_ANY_SAMPLES_PASSED but less accurate.
            * @see https://doc.babylonjs.com/features/occlusionquery
            */
            occlusionQueryAlgorithmType: number;
            /**
            * Gets or sets whether the mesh is occluded or not, it is used also to set the intial state of the mesh to be occluded or not
            * @see https://doc.babylonjs.com/features/occlusionquery
            */
            isOccluded: boolean;
            /**
             * Flag to check the progress status of the query
             * @see https://doc.babylonjs.com/features/occlusionquery
             */
            isOcclusionQueryInProgress: boolean;
        }
}
declare module BABYLON {
    /** @hidden */
    export var _forceTransformFeedbackToBundle: boolean;
        interface Engine {
            /**
             * Creates a webGL transform feedback object
             * Please makes sure to check webGLVersion property to check if you are running webGL 2+
             * @returns the webGL transform feedback object
             */
            createTransformFeedback(): WebGLTransformFeedback;
            /**
             * Delete a webGL transform feedback object
             * @param value defines the webGL transform feedback object to delete
             */
            deleteTransformFeedback(value: WebGLTransformFeedback): void;
            /**
             * Bind a webGL transform feedback object to the webgl context
             * @param value defines the webGL transform feedback object to bind
             */
            bindTransformFeedback(value: Nullable<WebGLTransformFeedback>): void;
            /**
             * Begins a transform feedback operation
             * @param usePoints defines if points or triangles must be used
             */
            beginTransformFeedback(usePoints: boolean): void;
            /**
             * Ends a transform feedback operation
             */
            endTransformFeedback(): void;
            /**
             * Specify the varyings to use with transform feedback
             * @param program defines the associated webGL program
             * @param value defines the list of strings representing the varying names
             */
            setTranformFeedbackVaryings(program: WebGLProgram, value: string[]): void;
            /**
             * Bind a webGL buffer for a transform feedback operation
             * @param value defines the webGL buffer to bind
             */
            bindTransformFeedbackBuffer(value: Nullable<DataBuffer>): void;
        }
}
declare module BABYLON {
    /**
     * Class used to define an additional view for the engine
     * @see https://doc.babylonjs.com/how_to/multi_canvases
     */
    export class EngineView {
        /** Defines the canvas where to render the view */
        target: HTMLCanvasElement;
        /** Defines an optional camera used to render the view (will use active camera else) */
        camera?: Camera;
    }
        interface Engine {
            /**
             * Gets or sets the  HTML element to use for attaching events
             */
            inputElement: Nullable<HTMLElement>;
            /**
             * Gets the current engine view
             * @see https://doc.babylonjs.com/how_to/multi_canvases
             */
            activeView: Nullable<EngineView>;
            /** Gets or sets the list of views */
            views: EngineView[];
            /**
             * Register a new child canvas
             * @param canvas defines the canvas to register
             * @param camera defines an optional camera to use with this canvas (it will overwrite the scene.camera for this view)
             * @returns the associated view
             */
            registerView(canvas: HTMLCanvasElement, camera?: Camera): EngineView;
            /**
             * Remove a registered child canvas
             * @param canvas defines the canvas to remove
             * @returns the current engine
             */
            unRegisterView(canvas: HTMLCanvasElement): Engine;
        }
}
declare module BABYLON {
        interface Engine {
            /** @hidden */
            _excludedCompressedTextures: string[];
            /** @hidden */
            _textureFormatInUse: string;
            /**
             * Gets the list of texture formats supported
             */
            readonly texturesSupported: Array<string>;
            /**
             * Gets the texture format in use
             */
            readonly textureFormatInUse: Nullable<string>;
            /**
             * Set the compressed texture extensions or file names to skip.
             *
             * @param skippedFiles defines the list of those texture files you want to skip
             * Example: [".dds", ".env", "myfile.png"]
             */
            setCompressedTextureExclusions(skippedFiles: Array<string>): void;
            /**
             * Set the compressed texture format to use, based on the formats you have, and the formats
             * supported by the hardware / browser.
             *
             * Khronos Texture Container (.ktx) files are used to support this.  This format has the
             * advantage of being specifically designed for OpenGL.  Header elements directly correspond
             * to API arguments needed to compressed textures.  This puts the burden on the container
             * generator to house the arcane code for determining these for current & future formats.
             *
             * for description see https://www.khronos.org/opengles/sdk/tools/KTX/
             * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
             *
             * Note: The result of this call is not taken into account when a texture is base64.
             *
             * @param formatsAvailable defines the list of those format families you have created
             * on your server.  Syntax: '-' + format family + '.ktx'.  (Case and order do not matter.)
             *
             * Current families are astc, dxt, pvrtc, etc2, & etc1.
             * @returns The extension selected.
             */
            setTextureFormatToUse(formatsAvailable: Array<string>): Nullable<string>;
        }
}
declare module BABYLON {
    /**
     * CubeMap information grouping all the data for each faces as well as the cubemap size.
     */
    export interface CubeMapInfo {
        /**
         * The pixel array for the front face.
         * This is stored in format, left to right, up to down format.
         */
        front: Nullable<ArrayBufferView>;
        /**
         * The pixel array for the back face.
         * This is stored in format, left to right, up to down format.
         */
        back: Nullable<ArrayBufferView>;
        /**
         * The pixel array for the left face.
         * This is stored in format, left to right, up to down format.
         */
        left: Nullable<ArrayBufferView>;
        /**
         * The pixel array for the right face.
         * This is stored in format, left to right, up to down format.
         */
        right: Nullable<ArrayBufferView>;
        /**
         * The pixel array for the up face.
         * This is stored in format, left to right, up to down format.
         */
        up: Nullable<ArrayBufferView>;
        /**
         * The pixel array for the down face.
         * This is stored in format, left to right, up to down format.
         */
        down: Nullable<ArrayBufferView>;
        /**
         * The size of the cubemap stored.
         *
         * Each faces will be size * size pixels.
         */
        size: number;
        /**
         * The format of the texture.
         *
         * RGBA, RGB.
         */
        format: number;
        /**
         * The type of the texture data.
         *
         * UNSIGNED_INT, FLOAT.
         */
        type: number;
        /**
         * Specifies whether the texture is in gamma space.
         */
        gammaSpace: boolean;
    }
    /**
     * Helper class useful to convert panorama picture to their cubemap representation in 6 faces.
     */
    export class PanoramaToCubeMapTools {
        private static FACE_LEFT;
        private static FACE_RIGHT;
        private static FACE_FRONT;
        private static FACE_BACK;
        private static FACE_DOWN;
        private static FACE_UP;
        /**
         * Converts a panorma stored in RGB right to left up to down format into a cubemap (6 faces).
         *
         * @param float32Array The source data.
         * @param inputWidth The width of the input panorama.
         * @param inputHeight The height of the input panorama.
         * @param size The willing size of the generated cubemap (each faces will be size * size pixels)
         * @return The cubemap data
         */
        static ConvertPanoramaToCubemap(float32Array: Float32Array, inputWidth: number, inputHeight: number, size: number): CubeMapInfo;
        private static CreateCubemapTexture;
        private static CalcProjectionSpherical;
    }
}
declare module BABYLON {
    /**
     * Helper class dealing with the extraction of spherical polynomial dataArray
     * from a cube map.
     */
    export class CubeMapToSphericalPolynomialTools {
        private static FileFaces;
        /**
         * Converts a texture to the according Spherical Polynomial data.
         * This extracts the first 3 orders only as they are the only one used in the lighting.
         *
         * @param texture The texture to extract the information from.
         * @return The Spherical Polynomial data.
         */
        static ConvertCubeMapTextureToSphericalPolynomial(texture: BaseTexture): Nullable<SphericalPolynomial>;
        /**
         * Converts a cubemap to the according Spherical Polynomial data.
         * This extracts the first 3 orders only as they are the only one used in the lighting.
         *
         * @param cubeInfo The Cube map to extract the information from.
         * @return The Spherical Polynomial data.
         */
        static ConvertCubeMapToSphericalPolynomial(cubeInfo: CubeMapInfo): SphericalPolynomial;
    }
}
declare module BABYLON {
        interface BaseTexture {
            /**
             * Get the polynomial representation of the texture data.
             * This is mainly use as a fast way to recover IBL Diffuse irradiance data.
             * @see https://learnopengl.com/PBR/IBL/Diffuse-irradiance
             */
            sphericalPolynomial: Nullable<SphericalPolynomial>;
        }
}
declare module BABYLON {
    /** @hidden */
    export var rgbdEncodePixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var rgbdDecodePixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Raw texture data and descriptor sufficient for WebGL texture upload
     */
    export interface EnvironmentTextureInfo {
        /**
         * Version of the environment map
         */
        version: number;
        /**
         * Width of image
         */
        width: number;
        /**
         * Irradiance information stored in the file.
         */
        irradiance: any;
        /**
         * Specular information stored in the file.
         */
        specular: any;
    }
    /**
     * Defines One Image in the file. It requires only the position in the file
     * as well as the length.
     */
    interface BufferImageData {
        /**
         * Length of the image data.
         */
        length: number;
        /**
         * Position of the data from the null terminator delimiting the end of the JSON.
         */
        position: number;
    }
    /**
     * Defines the specular data enclosed in the file.
     * This corresponds to the version 1 of the data.
     */
    export interface EnvironmentTextureSpecularInfoV1 {
        /**
         * Defines where the specular Payload is located. It is a runtime value only not stored in the file.
         */
        specularDataPosition?: number;
        /**
         * This contains all the images data needed to reconstruct the cubemap.
         */
        mipmaps: Array<BufferImageData>;
        /**
         * Defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness.
         */
        lodGenerationScale: number;
    }
    /**
     * Sets of helpers addressing the serialization and deserialization of environment texture
     * stored in a BabylonJS env file.
     * Those files are usually stored as .env files.
     */
    export class EnvironmentTextureTools {
        /**
         * Magic number identifying the env file.
         */
        private static _MagicBytes;
        /**
         * Gets the environment info from an env file.
         * @param data The array buffer containing the .env bytes.
         * @returns the environment file info (the json header) if successfully parsed.
         */
        static GetEnvInfo(data: ArrayBufferView): Nullable<EnvironmentTextureInfo>;
        /**
         * Creates an environment texture from a loaded cube texture.
         * @param texture defines the cube texture to convert in env file
         * @return a promise containing the environment data if succesfull.
         */
        static CreateEnvTextureAsync(texture: BaseTexture): Promise<ArrayBuffer>;
        /**
         * Creates a JSON representation of the spherical data.
         * @param texture defines the texture containing the polynomials
         * @return the JSON representation of the spherical info
         */
        private static _CreateEnvTextureIrradiance;
        /**
         * Creates the ArrayBufferViews used for initializing environment texture image data.
         * @param data the image data
         * @param info parameters that determine what views will be created for accessing the underlying buffer
         * @return the views described by info providing access to the underlying buffer
         */
        static CreateImageDataArrayBufferViews(data: ArrayBufferView, info: EnvironmentTextureInfo): Array<Array<ArrayBufferView>>;
        /**
         * Uploads the texture info contained in the env file to the GPU.
         * @param texture defines the internal texture to upload to
         * @param data defines the data to load
         * @param info defines the texture info retrieved through the GetEnvInfo method
         * @returns a promise
         */
        static UploadEnvLevelsAsync(texture: InternalTexture, data: ArrayBufferView, info: EnvironmentTextureInfo): Promise<void>;
        private static _OnImageReadyAsync;
        /**
         * Uploads the levels of image data to the GPU.
         * @param texture defines the internal texture to upload to
         * @param imageData defines the array buffer views of image data [mipmap][face]
         * @returns a promise
         */
        static UploadLevelsAsync(texture: InternalTexture, imageData: ArrayBufferView[][]): Promise<void>;
        /**
         * Uploads spherical polynomials information to the texture.
         * @param texture defines the texture we are trying to upload the information to
         * @param info defines the environment texture info retrieved through the GetEnvInfo method
         */
        static UploadEnvSpherical(texture: InternalTexture, info: EnvironmentTextureInfo): void;
        /** @hidden */
        static _UpdateRGBDAsync(internalTexture: InternalTexture, data: ArrayBufferView[][], sphericalPolynomial: Nullable<SphericalPolynomial>, lodScale: number, lodOffset: number): Promise<void>;
    }
}
declare module BABYLON {
    /**
     * Class used to inline functions in shader code
    */
    export class ShaderCodeInliner {
        private static readonly _RegexpFindFunctionNameAndType;
        private _sourceCode;
        private _functionDescr;
        private _numMaxIterations;
        /** Gets or sets the token used to mark the functions to inline */
        inlineToken: string;
        /** Gets or sets the debug mode */
        debug: boolean;
        /** Gets the code after the inlining process */
        get code(): string;
        /**
         * Initializes the inliner
         * @param sourceCode shader code source to inline
         * @param numMaxIterations maximum number of iterations (used to detect recursive calls)
         */
        constructor(sourceCode: string, numMaxIterations?: number);
        /**
         * Start the processing of the shader code
         */
        processCode(): void;
        private _collectFunctions;
        private _processInlining;
        private _extractBetweenMarkers;
        private _skipWhitespaces;
        private _removeComments;
        private _replaceFunctionCallsByCode;
        private _findBackward;
        private _escapeRegExp;
        private _replaceNames;
    }
}
declare module BABYLON {
    /**
     * Container for accessors for natively-stored mesh data buffers.
     */
    class NativeDataBuffer extends DataBuffer {
        /**
         * Accessor value used to identify/retrieve a natively-stored index buffer.
         */
        nativeIndexBuffer?: any;
        /**
         * Accessor value used to identify/retrieve a natively-stored vertex buffer.
         */
        nativeVertexBuffer?: any;
    }
    /** @hidden */
    class NativeTexture extends InternalTexture {
        getInternalTexture(): InternalTexture;
        getViewCount(): number;
    }
    /** @hidden */
    export class NativeEngine extends Engine {
        private readonly _native;
        /** Defines the invalid handle returned by bgfx when resource creation goes wrong */
        private readonly INVALID_HANDLE;
        private _boundBuffersVertexArray;
        getHardwareScalingLevel(): number;
        constructor();
        dispose(): void;
        /**
         * Can be used to override the current requestAnimationFrame requester.
         * @hidden
         */
        protected _queueNewFrame(bindedRenderFunction: any, requester?: any): number;
        /**
         * Override default engine behavior.
         * @param color
         * @param backBuffer
         * @param depth
         * @param stencil
         */
        _bindUnboundFramebuffer(framebuffer: Nullable<WebGLFramebuffer>): void;
        /**
         * Gets host document
         * @returns the host document object
         */
        getHostDocument(): Nullable<Document>;
        clear(color: Nullable<IColor4Like>, backBuffer: boolean, depth: boolean, stencil?: boolean): void;
        createIndexBuffer(indices: IndicesArray, updateable?: boolean): NativeDataBuffer;
        createVertexBuffer(data: DataArray, updateable?: boolean): NativeDataBuffer;
        protected _recordVertexArrayObject(vertexArray: any, vertexBuffers: {
            [key: string]: VertexBuffer;
        }, indexBuffer: Nullable<NativeDataBuffer>, effect: Effect): void;
        bindBuffers(vertexBuffers: {
            [key: string]: VertexBuffer;
        }, indexBuffer: Nullable<NativeDataBuffer>, effect: Effect): void;
        recordVertexArrayObject(vertexBuffers: {
            [key: string]: VertexBuffer;
        }, indexBuffer: Nullable<NativeDataBuffer>, effect: Effect): WebGLVertexArrayObject;
        bindVertexArrayObject(vertexArray: WebGLVertexArrayObject): void;
        releaseVertexArrayObject(vertexArray: WebGLVertexArrayObject): void;
        getAttributes(pipelineContext: IPipelineContext, attributesNames: string[]): number[];
        /**
         * Draw a list of indexed primitives
         * @param fillMode defines the primitive to use
         * @param indexStart defines the starting index
         * @param indexCount defines the number of index to draw
         * @param instancesCount defines the number of instances to draw (if instanciation is enabled)
         */
        drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount?: number): void;
        /**
         * Draw a list of unindexed primitives
         * @param fillMode defines the primitive to use
         * @param verticesStart defines the index of first vertex to draw
         * @param verticesCount defines the count of vertices to draw
         * @param instancesCount defines the number of instances to draw (if instanciation is enabled)
         */
        drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount?: number): void;
        createPipelineContext(): IPipelineContext;
        _preparePipelineContext(pipelineContext: IPipelineContext, vertexSourceCode: string, fragmentSourceCode: string, createAsRaw: boolean, rebuildRebind: any, defines: Nullable<string>, transformFeedbackVaryings: Nullable<string[]>): void;
        /** @hidden */
        _isRenderingStateCompiled(pipelineContext: IPipelineContext): boolean;
        /** @hidden */
        _executeWhenRenderingStateIsCompiled(pipelineContext: IPipelineContext, action: () => void): void;
        createRawShaderProgram(pipelineContext: IPipelineContext, vertexCode: string, fragmentCode: string, context?: WebGLRenderingContext, transformFeedbackVaryings?: Nullable<string[]>): any;
        createShaderProgram(pipelineContext: IPipelineContext, vertexCode: string, fragmentCode: string, defines: Nullable<string>, context?: WebGLRenderingContext, transformFeedbackVaryings?: Nullable<string[]>): any;
        protected _setProgram(program: WebGLProgram): void;
        _releaseEffect(effect: Effect): void;
        _deletePipelineContext(pipelineContext: IPipelineContext): void;
        getUniforms(pipelineContext: IPipelineContext, uniformsNames: string[]): WebGLUniformLocation[];
        bindUniformBlock(pipelineContext: IPipelineContext, blockName: string, index: number): void;
        bindSamplers(effect: Effect): void;
        setMatrix(uniform: WebGLUniformLocation, matrix: Matrix): void;
        getRenderWidth(useScreen?: boolean): number;
        getRenderHeight(useScreen?: boolean): number;
        setViewport(viewport: Viewport, requiredWidth?: number, requiredHeight?: number): void;
        setState(culling: boolean, zOffset?: number, force?: boolean, reverseSide?: boolean): void;
        /**
         * Set the z offset to apply to current rendering
         * @param value defines the offset to apply
         */
        setZOffset(value: number): void;
        /**
         * Gets the current value of the zOffset
         * @returns the current zOffset state
         */
        getZOffset(): number;
        /**
         * Enable or disable depth buffering
         * @param enable defines the state to set
         */
        setDepthBuffer(enable: boolean): void;
        /**
         * Gets a boolean indicating if depth writing is enabled
         * @returns the current depth writing state
         */
        getDepthWrite(): boolean;
        /**
         * Enable or disable depth writing
         * @param enable defines the state to set
         */
        setDepthWrite(enable: boolean): void;
        /**
         * Enable or disable color writing
         * @param enable defines the state to set
         */
        setColorWrite(enable: boolean): void;
        /**
         * Gets a boolean indicating if color writing is enabled
         * @returns the current color writing state
         */
        getColorWrite(): boolean;
        /**
         * Sets alpha constants used by some alpha blending modes
         * @param r defines the red component
         * @param g defines the green component
         * @param b defines the blue component
         * @param a defines the alpha component
         */
        setAlphaConstants(r: number, g: number, b: number, a: number): void;
        /**
         * Sets the current alpha mode
         * @param mode defines the mode to use (one of the BABYLON.Constants.ALPHA_XXX)
         * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)
         * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered
         */
        setAlphaMode(mode: number, noDepthWriteChange?: boolean): void;
        /**
         * Gets the current alpha mode
         * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered
         * @returns the current alpha mode
         */
        getAlphaMode(): number;
        setInt(uniform: WebGLUniformLocation, int: number): void;
        setIntArray(uniform: WebGLUniformLocation, array: Int32Array): void;
        setIntArray2(uniform: WebGLUniformLocation, array: Int32Array): void;
        setIntArray3(uniform: WebGLUniformLocation, array: Int32Array): void;
        setIntArray4(uniform: WebGLUniformLocation, array: Int32Array): void;
        setFloatArray(uniform: WebGLUniformLocation, array: Float32Array): void;
        setFloatArray2(uniform: WebGLUniformLocation, array: Float32Array): void;
        setFloatArray3(uniform: WebGLUniformLocation, array: Float32Array): void;
        setFloatArray4(uniform: WebGLUniformLocation, array: Float32Array): void;
        setArray(uniform: WebGLUniformLocation, array: number[]): void;
        setArray2(uniform: WebGLUniformLocation, array: number[]): void;
        setArray3(uniform: WebGLUniformLocation, array: number[]): void;
        setArray4(uniform: WebGLUniformLocation, array: number[]): void;
        setMatrices(uniform: WebGLUniformLocation, matrices: Float32Array): void;
        setMatrix3x3(uniform: WebGLUniformLocation, matrix: Float32Array): void;
        setMatrix2x2(uniform: WebGLUniformLocation, matrix: Float32Array): void;
        setFloat(uniform: WebGLUniformLocation, value: number): void;
        setFloat2(uniform: WebGLUniformLocation, x: number, y: number): void;
        setFloat3(uniform: WebGLUniformLocation, x: number, y: number, z: number): void;
        setFloat4(uniform: WebGLUniformLocation, x: number, y: number, z: number, w: number): void;
        setColor3(uniform: WebGLUniformLocation, color3: Color3): void;
        setColor4(uniform: WebGLUniformLocation, color3: Color3, alpha: number): void;
        wipeCaches(bruteForce?: boolean): void;
        _createTexture(): WebGLTexture;
        protected _deleteTexture(texture: Nullable<WebGLTexture>): void;
        /**
         * Usually called from Texture.ts.
         * Passed information to create a WebGLTexture
         * @param url defines a value which contains one of the following:
         * * A conventional http URL, e.g. 'http://...' or 'file://...'
         * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'
         * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'
         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file
         * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)
         * @param scene needed for loading to the correct scene
         * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)
         * @param onLoad optional callback to be called upon successful completion
         * @param onError optional callback to be called upon failure
         * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob
         * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities
         * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures
         * @param forcedExtension defines the extension to use to pick the right loader
         * @param mimeType defines an optional mime type
         * @returns a InternalTexture for assignment back into BABYLON.Texture
         */
        createTexture(url: Nullable<string>, noMipmap: boolean, invertY: boolean, scene: Nullable<ISceneLike>, samplingMode?: number, onLoad?: Nullable<() => void>, onError?: Nullable<(message: string, exception: any) => void>, buffer?: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap>, fallback?: Nullable<InternalTexture>, format?: Nullable<number>, forcedExtension?: Nullable<string>, mimeType?: string): InternalTexture;
        /**
         * Creates a cube texture
         * @param rootUrl defines the url where the files to load is located
         * @param scene defines the current scene
         * @param files defines the list of files to load (1 per face)
         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)
         * @param onLoad defines an optional callback raised when the texture is loaded
         * @param onError defines an optional callback raised if there is an issue to load the texture
         * @param format defines the format of the data
         * @param forcedExtension defines the extension to use to pick the right loader
         * @param createPolynomials if a polynomial sphere should be created for the cube texture
         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness
         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness
         * @param fallback defines texture to use while falling back when (compressed) texture file not found.
         * @returns the cube texture as an InternalTexture
         */
        createCubeTexture(rootUrl: string, scene: Nullable<Scene>, files: Nullable<string[]>, noMipmap?: boolean, onLoad?: Nullable<(data?: any) => void>, onError?: Nullable<(message?: string, exception?: any) => void>, format?: number, forcedExtension?: any, createPolynomials?: boolean, lodScale?: number, lodOffset?: number, fallback?: Nullable<InternalTexture>): InternalTexture;
        private _getSamplingFilter;
        private static _GetNativeTextureFormat;
        createRenderTargetTexture(size: number | {
            width: number;
            height: number;
        }, options: boolean | RenderTargetCreationOptions): NativeTexture;
        updateTextureSamplingMode(samplingMode: number, texture: InternalTexture): void;
        bindFramebuffer(texture: InternalTexture, faceIndex?: number, requiredWidth?: number, requiredHeight?: number, forceFullscreenViewport?: boolean): void;
        unBindFramebuffer(texture: InternalTexture, disableGenerateMipMaps?: boolean, onBeforeUnbind?: () => void): void;
        createDynamicVertexBuffer(data: DataArray): DataBuffer;
        updateDynamicIndexBuffer(indexBuffer: DataBuffer, indices: IndicesArray, offset?: number): void;
        /**
         * Updates a dynamic vertex buffer.
         * @param vertexBuffer the vertex buffer to update
         * @param data the data used to update the vertex buffer
         * @param byteOffset the byte offset of the data (optional)
         * @param byteLength the byte length of the data (optional)
         */
        updateDynamicVertexBuffer(vertexBuffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void;
        protected _setTexture(channel: number, texture: Nullable<BaseTexture>, isPartOfTextureArray?: boolean, depthStencilTexture?: boolean): boolean;
        private _updateAnisotropicLevel;
        private _getAddressMode;
        /** @hidden */
        _bindTexture(channel: number, texture: InternalTexture): void;
        protected _deleteBuffer(buffer: NativeDataBuffer): void;
        releaseEffects(): void;
        /** @hidden */
        _uploadCompressedDataToTextureDirectly(texture: InternalTexture, internalFormat: number, width: number, height: number, data: ArrayBufferView, faceIndex?: number, lod?: number): void;
        /** @hidden */
        _uploadDataToTextureDirectly(texture: InternalTexture, imageData: ArrayBufferView, faceIndex?: number, lod?: number): void;
        /** @hidden */
        _uploadArrayBufferViewToTexture(texture: InternalTexture, imageData: ArrayBufferView, faceIndex?: number, lod?: number): void;
        /** @hidden */
        _uploadImageToTexture(texture: InternalTexture, image: HTMLImageElement, faceIndex?: number, lod?: number): void;
    }
}
declare module BABYLON {
    /**
     * Gather the list of clipboard event types as constants.
     */
    export class ClipboardEventTypes {
        /**
         * The clipboard event is fired when a copy command is active (pressed).
         */
        static readonly COPY: number;
        /**
         *  The clipboard event is fired when a cut command is active (pressed).
         */
        static readonly CUT: number;
        /**
         * The clipboard event is fired when a paste command is active (pressed).
         */
        static readonly PASTE: number;
    }
    /**
     * This class is used to store clipboard related info for the onClipboardObservable event.
     */
    export class ClipboardInfo {
        /**
         * Defines the type of event (BABYLON.ClipboardEventTypes)
         */
        type: number;
        /**
         * Defines the related dom event
         */
        event: ClipboardEvent;
        /**
         *Creates an instance of ClipboardInfo.
         * @param type Defines the type of event (BABYLON.ClipboardEventTypes)
         * @param event Defines the related dom event
         */
        constructor(
        /**
         * Defines the type of event (BABYLON.ClipboardEventTypes)
         */
        type: number, 
        /**
         * Defines the related dom event
         */
        event: ClipboardEvent);
        /**
         *  Get the clipboard event's type from the keycode.
         * @param keyCode Defines the keyCode for the current keyboard event.
         * @return {number}
         */
        static GetTypeFromCharacter(keyCode: number): number;
    }
}
declare module BABYLON {
    /**
     * Google Daydream controller
     */
    export class DaydreamController extends WebVRController {
        /**
         * Base Url for the controller model.
         */
        static MODEL_BASE_URL: string;
        /**
         * File name for the controller model.
         */
        static MODEL_FILENAME: string;
        /**
         * Gamepad Id prefix used to identify Daydream Controller.
         */
        static readonly GAMEPAD_ID_PREFIX: string;
        /**
         * Creates a new DaydreamController from a gamepad
         * @param vrGamepad the gamepad that the controller should be created from
         */
        constructor(vrGamepad: any);
        /**
         * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
         * @param scene scene in which to add meshes
         * @param meshLoaded optional callback function that will be called if the mesh loads successfully.
         */
        initControllerMesh(scene: Scene, meshLoaded?: (mesh: AbstractMesh) => void): void;
        /**
         * Called once for each button that changed state since the last frame
         * @param buttonIdx Which button index changed
         * @param state New state of the button
         * @param changes Which properties on the state changed since last frame
         */
        protected _handleButtonChange(buttonIdx: number, state: ExtendedGamepadButton, changes: GamepadButtonChanges): void;
    }
}
declare module BABYLON {
    /**
         * Gear VR Controller
         */
    export class GearVRController extends WebVRController {
        /**
         * Base Url for the controller model.
         */
        static MODEL_BASE_URL: string;
        /**
         * File name for the controller model.
         */
        static MODEL_FILENAME: string;
        /**
         * Gamepad Id prefix used to identify this controller.
         */
        static readonly GAMEPAD_ID_PREFIX: string;
        private readonly _buttonIndexToObservableNameMap;
        /**
         * Creates a new GearVRController from a gamepad
         * @param vrGamepad the gamepad that the controller should be created from
         */
        constructor(vrGamepad: any);
        /**
         * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
         * @param scene scene in which to add meshes
         * @param meshLoaded optional callback function that will be called if the mesh loads successfully.
         */
        initControllerMesh(scene: Scene, meshLoaded?: (mesh: AbstractMesh) => void): void;
        /**
         * Called once for each button that changed state since the last frame
         * @param buttonIdx Which button index changed
         * @param state New state of the button
         * @param changes Which properties on the state changed since last frame
         */
        protected _handleButtonChange(buttonIdx: number, state: ExtendedGamepadButton, changes: GamepadButtonChanges): void;
    }
}
declare module BABYLON {
    /**
     * Generic Controller
     */
    export class GenericController extends WebVRController {
        /**
         * Base Url for the controller model.
         */
        static readonly MODEL_BASE_URL: string;
        /**
         * File name for the controller model.
         */
        static readonly MODEL_FILENAME: string;
        /**
         * Creates a new GenericController from a gamepad
         * @param vrGamepad the gamepad that the controller should be created from
         */
        constructor(vrGamepad: any);
        /**
         * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
         * @param scene scene in which to add meshes
         * @param meshLoaded optional callback function that will be called if the mesh loads successfully.
         */
        initControllerMesh(scene: Scene, meshLoaded?: (mesh: AbstractMesh) => void): void;
        /**
         * Called once for each button that changed state since the last frame
         * @param buttonIdx Which button index changed
         * @param state New state of the button
         * @param changes Which properties on the state changed since last frame
         */
        protected _handleButtonChange(buttonIdx: number, state: ExtendedGamepadButton, changes: GamepadButtonChanges): void;
    }
}
declare module BABYLON {
    /**
     * Oculus Touch Controller
     */
    export class OculusTouchController extends WebVRController {
        /**
         * Base Url for the controller model.
         */
        static MODEL_BASE_URL: string;
        /**
         * File name for the left controller model.
         */
        static MODEL_LEFT_FILENAME: string;
        /**
         * File name for the right controller model.
         */
        static MODEL_RIGHT_FILENAME: string;
        /**
         * Base Url for the Quest controller model.
         */
        static QUEST_MODEL_BASE_URL: string;
        /**
         * @hidden
         * If the controllers are running on a device that needs the updated Quest controller models
         */
        static _IsQuest: boolean;
        /**
         * Fired when the secondary trigger on this controller is modified
         */
        onSecondaryTriggerStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the thumb rest on this controller is modified
         */
        onThumbRestChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Creates a new OculusTouchController from a gamepad
         * @param vrGamepad the gamepad that the controller should be created from
         */
        constructor(vrGamepad: any);
        /**
         * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
         * @param scene scene in which to add meshes
         * @param meshLoaded optional callback function that will be called if the mesh loads successfully.
         */
        initControllerMesh(scene: Scene, meshLoaded?: (mesh: AbstractMesh) => void): void;
        /**
         * Fired when the A button on this controller is modified
         */
        get onAButtonStateChangedObservable(): Observable<ExtendedGamepadButton>;
        /**
         * Fired when the B button on this controller is modified
         */
        get onBButtonStateChangedObservable(): Observable<ExtendedGamepadButton>;
        /**
         * Fired when the X button on this controller is modified
         */
        get onXButtonStateChangedObservable(): Observable<ExtendedGamepadButton>;
        /**
         * Fired when the Y button on this controller is modified
         */
        get onYButtonStateChangedObservable(): Observable<ExtendedGamepadButton>;
        /**
          * Called once for each button that changed state since the last frame
          * 0) thumb stick (touch, press, value = pressed (0,1)). value is in this.leftStick
          * 1) index trigger (touch (?), press (only when value > 0.1), value 0 to 1)
          * 2) secondary trigger (same)
          * 3) A (right) X (left), touch, pressed = value
          * 4) B / Y
          * 5) thumb rest
          * @param buttonIdx Which button index changed
          * @param state New state of the button
          * @param changes Which properties on the state changed since last frame
          */
        protected _handleButtonChange(buttonIdx: number, state: ExtendedGamepadButton, changes: GamepadButtonChanges): void;
    }
}
declare module BABYLON {
    /**
     * Vive Controller
     */
    export class ViveController extends WebVRController {
        /**
         * Base Url for the controller model.
         */
        static MODEL_BASE_URL: string;
        /**
         * File name for the controller model.
         */
        static MODEL_FILENAME: string;
        /**
         * Creates a new ViveController from a gamepad
         * @param vrGamepad the gamepad that the controller should be created from
         */
        constructor(vrGamepad: any);
        /**
         * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
         * @param scene scene in which to add meshes
         * @param meshLoaded optional callback function that will be called if the mesh loads successfully.
         */
        initControllerMesh(scene: Scene, meshLoaded?: (mesh: AbstractMesh) => void): void;
        /**
         * Fired when the left button on this controller is modified
         */
        get onLeftButtonStateChangedObservable(): Observable<ExtendedGamepadButton>;
        /**
         * Fired when the right button on this controller is modified
         */
        get onRightButtonStateChangedObservable(): Observable<ExtendedGamepadButton>;
        /**
         * Fired when the menu button on this controller is modified
         */
        get onMenuButtonStateChangedObservable(): Observable<ExtendedGamepadButton>;
        /**
         * Called once for each button that changed state since the last frame
         * Vive mapping:
         * 0: touchpad
         * 1: trigger
         * 2: left AND right buttons
         * 3: menu button
         * @param buttonIdx Which button index changed
         * @param state New state of the button
         * @param changes Which properties on the state changed since last frame
         */
        protected _handleButtonChange(buttonIdx: number, state: ExtendedGamepadButton, changes: GamepadButtonChanges): void;
    }
}
declare module BABYLON {
    /**
     * Defines the WindowsMotionController object that the state of the windows motion controller
     */
    export class WindowsMotionController extends WebVRController {
        /**
         * The base url used to load the left and right controller models
         */
        static MODEL_BASE_URL: string;
        /**
         * The name of the left controller model file
         */
        static MODEL_LEFT_FILENAME: string;
        /**
         * The name of the right controller model file
         */
        static MODEL_RIGHT_FILENAME: string;
        /**
         * The controller name prefix for this controller type
         */
        static readonly GAMEPAD_ID_PREFIX: string;
        /**
         * The controller id pattern for this controller type
         */
        private static readonly GAMEPAD_ID_PATTERN;
        private _loadedMeshInfo;
        protected readonly _mapping: {
            buttons: string[];
            buttonMeshNames: {
                trigger: string;
                menu: string;
                grip: string;
                thumbstick: string;
                trackpad: string;
            };
            buttonObservableNames: {
                trigger: string;
                menu: string;
                grip: string;
                thumbstick: string;
                trackpad: string;
            };
            axisMeshNames: string[];
            pointingPoseMeshName: string;
        };
        /**
         * Fired when the trackpad on this controller is clicked
         */
        onTrackpadChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the trackpad on this controller is modified
         */
        onTrackpadValuesChangedObservable: Observable<StickValues>;
        /**
         * The current x and y values of this controller's trackpad
         */
        trackpad: StickValues;
        /**
         * Creates a new WindowsMotionController from a gamepad
         * @param vrGamepad the gamepad that the controller should be created from
         */
        constructor(vrGamepad: any);
        /**
         * Fired when the trigger on this controller is modified
         */
        get onTriggerButtonStateChangedObservable(): Observable<ExtendedGamepadButton>;
        /**
         * Fired when the menu button on this controller is modified
         */
        get onMenuButtonStateChangedObservable(): Observable<ExtendedGamepadButton>;
        /**
         * Fired when the grip button on this controller is modified
         */
        get onGripButtonStateChangedObservable(): Observable<ExtendedGamepadButton>;
        /**
         * Fired when the thumbstick button on this controller is modified
         */
        get onThumbstickButtonStateChangedObservable(): Observable<ExtendedGamepadButton>;
        /**
         * Fired when the touchpad button on this controller is modified
         */
        get onTouchpadButtonStateChangedObservable(): Observable<ExtendedGamepadButton>;
        /**
         * Fired when the touchpad values on this controller are modified
         */
        get onTouchpadValuesChangedObservable(): Observable<StickValues>;
        protected _updateTrackpad(): void;
        /**
         * Called once per frame by the engine.
         */
        update(): void;
        /**
         * Called once for each button that changed state since the last frame
         * @param buttonIdx Which button index changed
         * @param state New state of the button
         * @param changes Which properties on the state changed since last frame
         */
        protected _handleButtonChange(buttonIdx: number, state: ExtendedGamepadButton, changes: GamepadButtonChanges): void;
        /**
         * Moves the buttons on the controller mesh based on their current state
         * @param buttonName the name of the button to move
         * @param buttonValue the value of the button which determines the buttons new position
         */
        protected _lerpButtonTransform(buttonName: string, buttonValue: number): void;
        /**
         * Moves the axis on the controller mesh based on its current state
         * @param axis the index of the axis
         * @param axisValue the value of the axis which determines the meshes new position
         * @hidden
         */
        protected _lerpAxisTransform(axis: number, axisValue: number): void;
        /**
         * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
         * @param scene scene in which to add meshes
         * @param meshLoaded optional callback function that will be called if the mesh loads successfully.
         */
        initControllerMesh(scene: Scene, meshLoaded?: (mesh: AbstractMesh) => void, forceDefault?: boolean): void;
        /**
         * Takes a list of meshes (as loaded from the glTF file) and finds the root node, as well as nodes that
         * can be transformed by button presses and axes values, based on this._mapping.
         *
         * @param scene scene in which the meshes exist
         * @param meshes list of meshes that make up the controller model to process
         * @return structured view of the given meshes, with mapping of buttons and axes to meshes that can be transformed.
         */
        private processModel;
        private createMeshInfo;
        /**
         * Gets the ray of the controller in the direction the controller is pointing
         * @param length the length the resulting ray should be
         * @returns a ray in the direction the controller is pointing
         */
        getForwardRay(length?: number): Ray;
        /**
        * Disposes of the controller
        */
        dispose(): void;
    }
    /**
     * This class represents a new windows motion controller in XR.
     */
    export class XRWindowsMotionController extends WindowsMotionController {
        /**
         * Changing the original WIndowsMotionController mapping to fir the new mapping
         */
        protected readonly _mapping: {
            buttons: string[];
            buttonMeshNames: {
                trigger: string;
                menu: string;
                grip: string;
                thumbstick: string;
                trackpad: string;
            };
            buttonObservableNames: {
                trigger: string;
                menu: string;
                grip: string;
                thumbstick: string;
                trackpad: string;
            };
            axisMeshNames: string[];
            pointingPoseMeshName: string;
        };
        /**
         * Construct a new XR-Based windows motion controller
         *
         * @param gamepadInfo the gamepad object from the browser
         */
        constructor(gamepadInfo: any);
        /**
         * holds the thumbstick values (X,Y)
         */
        thumbstickValues: StickValues;
        /**
         * Fired when the thumbstick on this controller is clicked
         */
        onThumbstickStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the thumbstick on this controller is modified
         */
        onThumbstickValuesChangedObservable: Observable<StickValues>;
        /**
         * Fired when the touchpad button on this controller is modified
         */
        onTrackpadChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the touchpad values on this controller are modified
         */
        onTrackpadValuesChangedObservable: Observable<StickValues>;
        /**
         * Fired when the thumbstick button on this controller is modified
         * here to prevent breaking changes
         */
        get onThumbstickButtonStateChangedObservable(): Observable<ExtendedGamepadButton>;
        /**
         * updating the thumbstick(!) and not the trackpad.
         * This is named this way due to the difference between WebVR and XR and to avoid
         * changing the parent class.
         */
        protected _updateTrackpad(): void;
        /**
         * Disposes the class with joy
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class PolyhedronBuilder {
        /**
         * Creates a polyhedron mesh
         * * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type
         * * The parameter `size` (positive float, default 1) sets the polygon size
         * * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)
         * * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`
         * * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron
         * * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)
         * * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
         * * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the polyhedron mesh
         * @see https://doc.babylonjs.com/how_to/polyhedra_shapes
         */
        static CreatePolyhedron(name: string, options: {
            type?: number;
            size?: number;
            sizeX?: number;
            sizeY?: number;
            sizeZ?: number;
            custom?: any;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            flat?: boolean;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }, scene?: Nullable<Scene>): Mesh;
    }
}
declare module BABYLON {
    /**
     * Gizmo that enables scaling a mesh along 3 axis
     */
    export class ScaleGizmo extends Gizmo {
        /**
         * Internal gizmo used for interactions on the x axis
         */
        xGizmo: AxisScaleGizmo;
        /**
         * Internal gizmo used for interactions on the y axis
         */
        yGizmo: AxisScaleGizmo;
        /**
         * Internal gizmo used for interactions on the z axis
         */
        zGizmo: AxisScaleGizmo;
        /**
         * Internal gizmo used to scale all axis equally
         */
        uniformScaleGizmo: AxisScaleGizmo;
        private _meshAttached;
        private _nodeAttached;
        private _snapDistance;
        private _uniformScalingMesh;
        private _octahedron;
        private _sensitivity;
        /** Fires an event when any of it's sub gizmos are dragged */
        onDragStartObservable: Observable<unknown>;
        /** Fires an event when any of it's sub gizmos are released from dragging */
        onDragEndObservable: Observable<unknown>;
        get attachedMesh(): Nullable<AbstractMesh>;
        set attachedMesh(mesh: Nullable<AbstractMesh>);
        get attachedNode(): Nullable<Node>;
        set attachedNode(node: Nullable<Node>);
        /**
         * Creates a ScaleGizmo
         * @param gizmoLayer The utility layer the gizmo will be added to
         * @param thickness display gizmo axis thickness
         */
        constructor(gizmoLayer?: UtilityLayerRenderer, thickness?: number);
        set updateGizmoRotationToMatchAttachedMesh(value: boolean);
        get updateGizmoRotationToMatchAttachedMesh(): boolean;
        /**
         * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
         */
        set snapDistance(value: number);
        get snapDistance(): number;
        /**
         * Ratio for the scale of the gizmo (Default: 1)
         */
        set scaleRatio(value: number);
        get scaleRatio(): number;
        /**
         * Sensitivity factor for dragging (Default: 1)
         */
        set sensitivity(value: number);
        get sensitivity(): number;
        /**
         * Disposes of the gizmo
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * Single axis scale gizmo
     */
    export class AxisScaleGizmo extends Gizmo {
        /**
         * Drag behavior responsible for the gizmos dragging interactions
         */
        dragBehavior: PointerDragBehavior;
        private _pointerObserver;
        /**
         * Scale distance in babylon units that the gizmo will snap to when dragged (Default: 0)
         */
        snapDistance: number;
        /**
         * Event that fires each time the gizmo snaps to a new location.
         * * snapDistance is the the change in distance
         */
        onSnapObservable: Observable<{
            snapDistance: number;
        }>;
        /**
         * If the scaling operation should be done on all axis (default: false)
         */
        uniformScaling: boolean;
        /**
         * Custom sensitivity value for the drag strength
         */
        sensitivity: number;
        private _isEnabled;
        private _parent;
        private _arrow;
        private _coloredMaterial;
        private _hoverMaterial;
        /**
         * Creates an AxisScaleGizmo
         * @param gizmoLayer The utility layer the gizmo will be added to
         * @param dragAxis The axis which the gizmo will be able to scale on
         * @param color The color of the gizmo
         * @param thickness display gizmo axis thickness
         */
        constructor(dragAxis: Vector3, color?: Color3, gizmoLayer?: UtilityLayerRenderer, parent?: Nullable<ScaleGizmo>, thickness?: number);
        protected _attachedNodeChanged(value: Nullable<Node>): void;
        /**
     * If the gizmo is enabled
     */
        set isEnabled(value: boolean);
        get isEnabled(): boolean;
        /**
         * Disposes of the gizmo
         */
        dispose(): void;
        /**
         * Disposes and replaces the current meshes in the gizmo with the specified mesh
         * @param mesh The mesh to replace the default mesh of the gizmo
         * @param useGizmoMaterial If the gizmo's default material should be used (default: false)
         */
        setCustomMesh(mesh: Mesh, useGizmoMaterial?: boolean): void;
    }
}
declare module BABYLON {
    /**
     * Bounding box gizmo
     */
    export class BoundingBoxGizmo extends Gizmo {
        private _lineBoundingBox;
        private _rotateSpheresParent;
        private _scaleBoxesParent;
        private _boundingDimensions;
        private _renderObserver;
        private _pointerObserver;
        private _scaleDragSpeed;
        private _tmpQuaternion;
        private _tmpVector;
        private _tmpRotationMatrix;
        /**
         * If child meshes should be ignored when calculating the boudning box. This should be set to true to avoid perf hits with heavily nested meshes (Default: false)
         */
        ignoreChildren: boolean;
        /**
         * Returns true if a descendant should be included when computing the bounding box. When null, all descendants are included. If ignoreChildren is set this will be ignored. (Default: null)
         */
        includeChildPredicate: Nullable<(abstractMesh: AbstractMesh) => boolean>;
        /**
         * The size of the rotation spheres attached to the bounding box (Default: 0.1)
         */
        rotationSphereSize: number;
        /**
         * The size of the scale boxes attached to the bounding box (Default: 0.1)
         */
        scaleBoxSize: number;
        /**
         * If set, the rotation spheres and scale boxes will increase in size based on the distance away from the camera to have a consistent screen size (Default: false)
         */
        fixedDragMeshScreenSize: boolean;
        /**
         * The distance away from the object which the draggable meshes should appear world sized when fixedDragMeshScreenSize is set to true (default: 10)
         */
        fixedDragMeshScreenSizeDistanceFactor: number;
        /**
         * Fired when a rotation sphere or scale box is dragged
         */
        onDragStartObservable: Observable<{}>;
        /**
         * Fired when a scale box is dragged
         */
        onScaleBoxDragObservable: Observable<{}>;
        /**
          * Fired when a scale box drag is ended
         */
        onScaleBoxDragEndObservable: Observable<{}>;
        /**
         * Fired when a rotation sphere is dragged
         */
        onRotationSphereDragObservable: Observable<{}>;
        /**
         * Fired when a rotation sphere drag is ended
         */
        onRotationSphereDragEndObservable: Observable<{}>;
        /**
         * Relative bounding box pivot used when scaling the attached node. When null object with scale from the opposite corner. 0.5,0.5,0.5 for center and 0.5,0,0.5 for bottom (Default: null)
         */
        scalePivot: Nullable<Vector3>;
        /**
         * Mesh used as a pivot to rotate the attached node
         */
        private _anchorMesh;
        private _existingMeshScale;
        private _dragMesh;
        private pointerDragBehavior;
        private coloredMaterial;
        private hoverColoredMaterial;
        /**
         * Sets the color of the bounding box gizmo
         * @param color the color to set
         */
        setColor(color: Color3): void;
        /**
         * Creates an BoundingBoxGizmo
         * @param gizmoLayer The utility layer the gizmo will be added to
         * @param color The color of the gizmo
         */
        constructor(color?: Color3, gizmoLayer?: UtilityLayerRenderer);
        protected _attachedNodeChanged(value: Nullable<AbstractMesh>): void;
        private _selectNode;
        /**
         * Updates the bounding box information for the Gizmo
         */
        updateBoundingBox(): void;
        private _updateRotationSpheres;
        private _updateScaleBoxes;
        /**
         * Enables rotation on the specified axis and disables rotation on the others
         * @param axis The list of axis that should be enabled (eg. "xy" or "xyz")
         */
        setEnabledRotationAxis(axis: string): void;
        /**
         * Enables/disables scaling
         * @param enable if scaling should be enabled
         * @param homogeneousScaling defines if scaling should only be homogeneous
         */
        setEnabledScaling(enable: boolean, homogeneousScaling?: boolean): void;
        private _updateDummy;
        /**
         * Enables a pointer drag behavior on the bounding box of the gizmo
         */
        enableDragBehavior(): void;
        /**
         * Disposes of the gizmo
         */
        dispose(): void;
        /**
         * Makes a mesh not pickable and wraps the mesh inside of a bounding box mesh that is pickable. (This is useful to avoid picking within complex geometry)
         * @param mesh the mesh to wrap in the bounding box mesh and make not pickable
         * @returns the bounding box mesh with the passed in mesh as a child
         */
        static MakeNotPickableAndWrapInBoundingBox(mesh: Mesh): Mesh;
        /**
         * CustomMeshes are not supported by this gizmo
         * @param mesh The mesh to replace the default mesh of the gizmo
         */
        setCustomMesh(mesh: Mesh): void;
    }
}
declare module BABYLON {
    /**
     * Single plane rotation gizmo
     */
    export class PlaneRotationGizmo extends Gizmo {
        /**
         * Drag behavior responsible for the gizmos dragging interactions
         */
        dragBehavior: PointerDragBehavior;
        private _pointerObserver;
        /**
         * Rotation distance in radians that the gizmo will snap to (Default: 0)
         */
        snapDistance: number;
        /**
         * Event that fires each time the gizmo snaps to a new location.
         * * snapDistance is the the change in distance
         */
        onSnapObservable: Observable<{
            snapDistance: number;
        }>;
        private _isEnabled;
        private _parent;
        /**
         * Creates a PlaneRotationGizmo
         * @param gizmoLayer The utility layer the gizmo will be added to
         * @param planeNormal The normal of the plane which the gizmo will be able to rotate on
         * @param color The color of the gizmo
         * @param tessellation Amount of tessellation to be used when creating rotation circles
         * @param useEulerRotation Use and update Euler angle instead of quaternion
         * @param thickness display gizmo axis thickness
         */
        constructor(planeNormal: Vector3, color?: Color3, gizmoLayer?: UtilityLayerRenderer, tessellation?: number, parent?: Nullable<RotationGizmo>, useEulerRotation?: boolean, thickness?: number);
        protected _attachedNodeChanged(value: Nullable<Node>): void;
        /**
             * If the gizmo is enabled
             */
        set isEnabled(value: boolean);
        get isEnabled(): boolean;
        /**
         * Disposes of the gizmo
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * Gizmo that enables rotating a mesh along 3 axis
     */
    export class RotationGizmo extends Gizmo {
        /**
         * Internal gizmo used for interactions on the x axis
         */
        xGizmo: PlaneRotationGizmo;
        /**
         * Internal gizmo used for interactions on the y axis
         */
        yGizmo: PlaneRotationGizmo;
        /**
         * Internal gizmo used for interactions on the z axis
         */
        zGizmo: PlaneRotationGizmo;
        /** Fires an event when any of it's sub gizmos are dragged */
        onDragStartObservable: Observable<unknown>;
        /** Fires an event when any of it's sub gizmos are released from dragging */
        onDragEndObservable: Observable<unknown>;
        private _meshAttached;
        private _nodeAttached;
        get attachedMesh(): Nullable<AbstractMesh>;
        set attachedMesh(mesh: Nullable<AbstractMesh>);
        get attachedNode(): Nullable<Node>;
        set attachedNode(node: Nullable<Node>);
        /**
         * Creates a RotationGizmo
         * @param gizmoLayer The utility layer the gizmo will be added to
         * @param tessellation Amount of tessellation to be used when creating rotation circles
         * @param useEulerRotation Use and update Euler angle instead of quaternion
         * @param thickness display gizmo axis thickness
         */
        constructor(gizmoLayer?: UtilityLayerRenderer, tessellation?: number, useEulerRotation?: boolean, thickness?: number);
        set updateGizmoRotationToMatchAttachedMesh(value: boolean);
        get updateGizmoRotationToMatchAttachedMesh(): boolean;
        /**
         * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
         */
        set snapDistance(value: number);
        get snapDistance(): number;
        /**
         * Ratio for the scale of the gizmo (Default: 1)
         */
        set scaleRatio(value: number);
        get scaleRatio(): number;
        /**
         * Disposes of the gizmo
         */
        dispose(): void;
        /**
         * CustomMeshes are not supported by this gizmo
         * @param mesh The mesh to replace the default mesh of the gizmo
         */
        setCustomMesh(mesh: Mesh): void;
    }
}
declare module BABYLON {
    /**
     * Helps setup gizmo's in the scene to rotate/scale/position nodes
     */
    export class GizmoManager implements IDisposable {
        private scene;
        /**
         * Gizmo's created by the gizmo manager, gizmo will be null until gizmo has been enabled for the first time
         */
        gizmos: {
            positionGizmo: Nullable<PositionGizmo>;
            rotationGizmo: Nullable<RotationGizmo>;
            scaleGizmo: Nullable<ScaleGizmo>;
            boundingBoxGizmo: Nullable<BoundingBoxGizmo>;
        };
        /** When true, the gizmo will be detached from the current object when a pointer down occurs with an empty picked mesh */
        clearGizmoOnEmptyPointerEvent: boolean;
        /** Fires an event when the manager is attached to a mesh */
        onAttachedToMeshObservable: Observable<Nullable<AbstractMesh>>;
        /** Fires an event when the manager is attached to a node */
        onAttachedToNodeObservable: Observable<Nullable<Node>>;
        private _gizmosEnabled;
        private _pointerObserver;
        private _attachedMesh;
        private _attachedNode;
        private _boundingBoxColor;
        private _defaultUtilityLayer;
        private _defaultKeepDepthUtilityLayer;
        private _thickness;
        /**
         * When bounding box gizmo is enabled, this can be used to track drag/end events
         */
        boundingBoxDragBehavior: SixDofDragBehavior;
        /**
         * Array of meshes which will have the gizmo attached when a pointer selected them. If null, all meshes are attachable. (Default: null)
         */
        attachableMeshes: Nullable<Array<AbstractMesh>>;
        /**
         * Array of nodes which will have the gizmo attached when a pointer selected them. If null, all nodes are attachable. (Default: null)
         */
        attachableNodes: Nullable<Array<Node>>;
        /**
         * If pointer events should perform attaching/detaching a gizmo, if false this can be done manually via attachToMesh/attachToNode. (Default: true)
         */
        usePointerToAttachGizmos: boolean;
        /**
         * Utility layer that the bounding box gizmo belongs to
         */
        get keepDepthUtilityLayer(): UtilityLayerRenderer;
        /**
         * Utility layer that all gizmos besides bounding box belong to
         */
        get utilityLayer(): UtilityLayerRenderer;
        /**
         * Instatiates a gizmo manager
         * @param scene the scene to overlay the gizmos on top of
         * @param thickness display gizmo axis thickness
         */
        constructor(scene: Scene, thickness?: number);
        /**
         * Attaches a set of gizmos to the specified mesh
         * @param mesh The mesh the gizmo's should be attached to
         */
        attachToMesh(mesh: Nullable<AbstractMesh>): void;
        /**
         * Attaches a set of gizmos to the specified node
         * @param node The node the gizmo's should be attached to
         */
        attachToNode(node: Nullable<Node>): void;
        /**
         * If the position gizmo is enabled
         */
        set positionGizmoEnabled(value: boolean);
        get positionGizmoEnabled(): boolean;
        /**
         * If the rotation gizmo is enabled
         */
        set rotationGizmoEnabled(value: boolean);
        get rotationGizmoEnabled(): boolean;
        /**
         * If the scale gizmo is enabled
         */
        set scaleGizmoEnabled(value: boolean);
        get scaleGizmoEnabled(): boolean;
        /**
         * If the boundingBox gizmo is enabled
         */
        set boundingBoxGizmoEnabled(value: boolean);
        get boundingBoxGizmoEnabled(): boolean;
        /**
         * Disposes of the gizmo manager
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * A directional light is defined by a direction (what a surprise!).
     * The light is emitted from everywhere in the specified direction, and has an infinite range.
     * An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.
     * Documentation: https://doc.babylonjs.com/babylon101/lights
     */
    export class DirectionalLight extends ShadowLight {
        private _shadowFrustumSize;
        /**
         * Fix frustum size for the shadow generation. This is disabled if the value is 0.
         */
        get shadowFrustumSize(): number;
        /**
         * Specifies a fix frustum size for the shadow generation.
         */
        set shadowFrustumSize(value: number);
        private _shadowOrthoScale;
        /**
         * Gets the shadow projection scale against the optimal computed one.
         * 0.1 by default which means that the projection window is increase by 10% from the optimal size.
         * This does not impact in fixed frustum size (shadowFrustumSize being set)
         */
        get shadowOrthoScale(): number;
        /**
         * Sets the shadow projection scale against the optimal computed one.
         * 0.1 by default which means that the projection window is increase by 10% from the optimal size.
         * This does not impact in fixed frustum size (shadowFrustumSize being set)
         */
        set shadowOrthoScale(value: number);
        /**
         * Automatically compute the projection matrix to best fit (including all the casters)
         * on each frame.
         */
        autoUpdateExtends: boolean;
        /**
         * Automatically compute the shadowMinZ and shadowMaxZ for the projection matrix to best fit (including all the casters)
         * on each frame. autoUpdateExtends must be set to true for this to work
         */
        autoCalcShadowZBounds: boolean;
        private _orthoLeft;
        private _orthoRight;
        private _orthoTop;
        private _orthoBottom;
        /**
         * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).
         * The directional light is emitted from everywhere in the given direction.
         * It can cast shadows.
         * Documentation : https://doc.babylonjs.com/babylon101/lights
         * @param name The friendly name of the light
         * @param direction The direction of the light
         * @param scene The scene the light belongs to
         */
        constructor(name: string, direction: Vector3, scene: Scene);
        /**
         * Returns the string "DirectionalLight".
         * @return The class name
         */
        getClassName(): string;
        /**
         * Returns the integer 1.
         * @return The light Type id as a constant defines in Light.LIGHTTYPEID_x
         */
        getTypeID(): number;
        /**
         * Sets the passed matrix "matrix" as projection matrix for the shadows cast by the light according to the passed view matrix.
         * Returns the DirectionalLight Shadow projection matrix.
         */
        protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void;
        /**
         * Sets the passed matrix "matrix" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.
         * Returns the DirectionalLight Shadow projection matrix.
         */
        protected _setDefaultFixedFrustumShadowProjectionMatrix(matrix: Matrix): void;
        /**
         * Sets the passed matrix "matrix" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.
         * Returns the DirectionalLight Shadow projection matrix.
         */
        protected _setDefaultAutoExtendShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void;
        protected _buildUniformLayout(): void;
        /**
         * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.
         * @param effect The effect to update
         * @param lightIndex The index of the light in the effect to update
         * @returns The directional light
         */
        transferToEffect(effect: Effect, lightIndex: string): DirectionalLight;
        transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light;
        /**
         * Gets the minZ used for shadow according to both the scene and the light.
         *
         * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
         * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.
         * @param activeCamera The camera we are returning the min for
         * @returns the depth min z
         */
        getDepthMinZ(activeCamera: Camera): number;
        /**
         * Gets the maxZ used for shadow according to both the scene and the light.
         *
         * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
         * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.
         * @param activeCamera The camera we are returning the max for
         * @returns the depth max z
         */
        getDepthMaxZ(activeCamera: Camera): number;
        /**
         * Prepares the list of defines specific to the light type.
         * @param defines the list of defines
         * @param lightIndex defines the index of the light for the effect
         */
        prepareLightSpecificDefines(defines: any, lightIndex: number): void;
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class HemisphereBuilder {
        /**
         * Creates a hemisphere mesh
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the hemisphere mesh
         */
        static CreateHemisphere(name: string, options: {
            segments?: number;
            diameter?: number;
            sideOrientation?: number;
        }, scene: any): Mesh;
    }
}
declare module BABYLON {
    /**
     * A spot light is defined by a position, a direction, an angle, and an exponent.
     * These values define a cone of light starting from the position, emitting toward the direction.
     * The angle, in radians, defines the size (field of illumination) of the spotlight's conical beam,
     * and the exponent defines the speed of the decay of the light with distance (reach).
     * Documentation: https://doc.babylonjs.com/babylon101/lights
     */
    export class SpotLight extends ShadowLight {
        private _angle;
        private _innerAngle;
        private _cosHalfAngle;
        private _lightAngleScale;
        private _lightAngleOffset;
        /**
         * Gets the cone angle of the spot light in Radians.
         */
        get angle(): number;
        /**
         * Sets the cone angle of the spot light in Radians.
         */
        set angle(value: number);
        /**
         * Only used in gltf falloff mode, this defines the angle where
         * the directional falloff will start before cutting at angle which could be seen
         * as outer angle.
         */
        get innerAngle(): number;
        /**
         * Only used in gltf falloff mode, this defines the angle where
         * the directional falloff will start before cutting at angle which could be seen
         * as outer angle.
         */
        set innerAngle(value: number);
        private _shadowAngleScale;
        /**
         * Allows scaling the angle of the light for shadow generation only.
         */
        get shadowAngleScale(): number;
        /**
         * Allows scaling the angle of the light for shadow generation only.
         */
        set shadowAngleScale(value: number);
        /**
         * The light decay speed with the distance from the emission spot.
         */
        exponent: number;
        private _projectionTextureMatrix;
        /**
        * Allows reading the projecton texture
        */
        get projectionTextureMatrix(): Matrix;
        protected _projectionTextureLightNear: number;
        /**
         * Gets the near clip of the Spotlight for texture projection.
         */
        get projectionTextureLightNear(): number;
        /**
         * Sets the near clip of the Spotlight for texture projection.
         */
        set projectionTextureLightNear(value: number);
        protected _projectionTextureLightFar: number;
        /**
         * Gets the far clip of the Spotlight for texture projection.
         */
        get projectionTextureLightFar(): number;
        /**
         * Sets the far clip of the Spotlight for texture projection.
         */
        set projectionTextureLightFar(value: number);
        protected _projectionTextureUpDirection: Vector3;
        /**
         * Gets the Up vector of the Spotlight for texture projection.
         */
        get projectionTextureUpDirection(): Vector3;
        /**
         * Sets the Up vector of the Spotlight for texture projection.
         */
        set projectionTextureUpDirection(value: Vector3);
        private _projectionTexture;
        /**
         * Gets the projection texture of the light.
        */
        get projectionTexture(): Nullable<BaseTexture>;
        /**
        * Sets the projection texture of the light.
        */
        set projectionTexture(value: Nullable<BaseTexture>);
        private _projectionTextureViewLightDirty;
        private _projectionTextureProjectionLightDirty;
        private _projectionTextureDirty;
        private _projectionTextureViewTargetVector;
        private _projectionTextureViewLightMatrix;
        private _projectionTextureProjectionLightMatrix;
        private _projectionTextureScalingMatrix;
        /**
         * Creates a SpotLight object in the scene. A spot light is a simply light oriented cone.
         * It can cast shadows.
         * Documentation : https://doc.babylonjs.com/babylon101/lights
         * @param name The light friendly name
         * @param position The position of the spot light in the scene
         * @param direction The direction of the light in the scene
         * @param angle The cone angle of the light in Radians
         * @param exponent The light decay speed with the distance from the emission spot
         * @param scene The scene the lights belongs to
         */
        constructor(name: string, position: Vector3, direction: Vector3, angle: number, exponent: number, scene: Scene);
        /**
         * Returns the string "SpotLight".
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Returns the integer 2.
         * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
         */
        getTypeID(): number;
        /**
         * Overrides the direction setter to recompute the projection texture view light Matrix.
         */
        protected _setDirection(value: Vector3): void;
        /**
         * Overrides the position setter to recompute the projection texture view light Matrix.
         */
        protected _setPosition(value: Vector3): void;
        /**
         * Sets the passed matrix "matrix" as perspective projection matrix for the shadows and the passed view matrix with the fov equal to the SpotLight angle and and aspect ratio of 1.0.
         * Returns the SpotLight.
         */
        protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void;
        protected _computeProjectionTextureViewLightMatrix(): void;
        protected _computeProjectionTextureProjectionLightMatrix(): void;
        /**
         * Main function for light texture projection matrix computing.
         */
        protected _computeProjectionTextureMatrix(): void;
        protected _buildUniformLayout(): void;
        private _computeAngleValues;
        /**
         * Sets the passed Effect "effect" with the Light textures.
         * @param effect The effect to update
         * @param lightIndex The index of the light in the effect to update
         * @returns The light
         */
        transferTexturesToEffect(effect: Effect, lightIndex: string): Light;
        /**
         * Sets the passed Effect object with the SpotLight transfomed position (or position if not parented) and normalized direction.
         * @param effect The effect to update
         * @param lightIndex The index of the light in the effect to update
         * @returns The spot light
         */
        transferToEffect(effect: Effect, lightIndex: string): SpotLight;
        transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): this;
        /**
         * Disposes the light and the associated resources.
         */
        dispose(): void;
        /**
         * Prepares the list of defines specific to the light type.
         * @param defines the list of defines
         * @param lightIndex defines the index of the light for the effect
         */
        prepareLightSpecificDefines(defines: any, lightIndex: number): void;
    }
}
declare module BABYLON {
    /**
     * Gizmo that enables viewing a light
     */
    export class LightGizmo extends Gizmo {
        private _lightMesh;
        private _material;
        private _cachedPosition;
        private _cachedForward;
        private _attachedMeshParent;
        private _pointerObserver;
        /**
         * Event that fires each time the gizmo is clicked
         */
        onClickedObservable: Observable<Light>;
        /**
         * Creates a LightGizmo
         * @param gizmoLayer The utility layer the gizmo will be added to
         */
        constructor(gizmoLayer?: UtilityLayerRenderer);
        private _light;
        /**
         * The light that the gizmo is attached to
         */
        set light(light: Nullable<Light>);
        get light(): Nullable<Light>;
        /**
         * Gets the material used to render the light gizmo
         */
        get material(): StandardMaterial;
        /**
         * @hidden
         * Updates the gizmo to match the attached mesh's position/rotation
         */
        protected _update(): void;
        private static _Scale;
        /**
         * Creates the lines for a light mesh
         */
        private static _CreateLightLines;
        /**
         * Disposes of the light gizmo
         */
        dispose(): void;
        private static _CreateHemisphericLightMesh;
        private static _CreatePointLightMesh;
        private static _CreateSpotLightMesh;
        private static _CreateDirectionalLightMesh;
    }
}
declare module BABYLON {
    /**
     * Gizmo that enables viewing a camera
     */
    export class CameraGizmo extends Gizmo {
        private _cameraMesh;
        private _cameraLinesMesh;
        private _material;
        private _pointerObserver;
        /**
         * Event that fires each time the gizmo is clicked
         */
        onClickedObservable: Observable<Camera>;
        /**
         * Creates a CameraGizmo
         * @param gizmoLayer The utility layer the gizmo will be added to
         */
        constructor(gizmoLayer?: UtilityLayerRenderer);
        private _camera;
        /** Gets or sets a boolean indicating if frustum lines must be rendered (true by default)) */
        get displayFrustum(): boolean;
        set displayFrustum(value: boolean);
        /**
         * The camera that the gizmo is attached to
         */
        set camera(camera: Nullable<Camera>);
        get camera(): Nullable<Camera>;
        /**
         * Gets the material used to render the camera gizmo
         */
        get material(): StandardMaterial;
        /**
         * @hidden
         * Updates the gizmo to match the attached mesh's position/rotation
         */
        protected _update(): void;
        private static _Scale;
        private _invProjection;
        /**
         * Disposes of the camera gizmo
         */
        dispose(): void;
        private static _CreateCameraMesh;
        private static _CreateCameraFrustum;
    }
}
declare module BABYLON {
    /** @hidden */
    export var backgroundFragmentDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var backgroundUboDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var backgroundPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var backgroundVertexDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var backgroundVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Background material used to create an efficient environement around your scene.
     */
    export class BackgroundMaterial extends PushMaterial {
        /**
         * Standard reflectance value at parallel view angle.
         */
        static StandardReflectance0: number;
        /**
         * Standard reflectance value at grazing angle.
         */
        static StandardReflectance90: number;
        protected _primaryColor: Color3;
        /**
         * Key light Color (multiply against the environement texture)
         */
        primaryColor: Color3;
        protected __perceptualColor: Nullable<Color3>;
        /**
         * Experimental Internal Use Only.
         *
         * Key light Color in "perceptual value" meaning the color you would like to see on screen.
         * This acts as a helper to set the primary color to a more "human friendly" value.
         * Conversion to linear space as well as exposure and tone mapping correction will be applied to keep the
         * output color as close as possible from the chosen value.
         * (This does not account for contrast color grading and color curves as they are considered post effect and not directly
         * part of lighting setup.)
         */
        get _perceptualColor(): Nullable<Color3>;
        set _perceptualColor(value: Nullable<Color3>);
        protected _primaryColorShadowLevel: float;
        /**
         * Defines the level of the shadows (dark area of the reflection map) in order to help scaling the colors.
         * The color opposite to the primary color is used at the level chosen to define what the black area would look.
         */
        get primaryColorShadowLevel(): float;
        set primaryColorShadowLevel(value: float);
        protected _primaryColorHighlightLevel: float;
        /**
         * Defines the level of the highliights (highlight area of the reflection map) in order to help scaling the colors.
         * The primary color is used at the level chosen to define what the white area would look.
         */
        get primaryColorHighlightLevel(): float;
        set primaryColorHighlightLevel(value: float);
        protected _reflectionTexture: Nullable<BaseTexture>;
        /**
         * Reflection Texture used in the material.
         * Should be author in a specific way for the best result (refer to the documentation).
         */
        reflectionTexture: Nullable<BaseTexture>;
        protected _reflectionBlur: float;
        /**
         * Reflection Texture level of blur.
         *
         * Can be use to reuse an existing HDR Texture and target a specific LOD to prevent authoring the
         * texture twice.
         */
        reflectionBlur: float;
        protected _diffuseTexture: Nullable<BaseTexture>;
        /**
         * Diffuse Texture used in the material.
         * Should be author in a specific way for the best result (refer to the documentation).
         */
        diffuseTexture: Nullable<BaseTexture>;
        protected _shadowLights: Nullable<IShadowLight[]>;
        /**
         * Specify the list of lights casting shadow on the material.
         * All scene shadow lights will be included if null.
         */
        shadowLights: Nullable<IShadowLight[]>;
        protected _shadowLevel: float;
        /**
         * Helps adjusting the shadow to a softer level if required.
         * 0 means black shadows and 1 means no shadows.
         */
        shadowLevel: float;
        protected _sceneCenter: Vector3;
        /**
         * In case of opacity Fresnel or reflection falloff, this is use as a scene center.
         * It is usually zero but might be interesting to modify according to your setup.
         */
        sceneCenter: Vector3;
        protected _opacityFresnel: boolean;
        /**
         * This helps specifying that the material is falling off to the sky box at grazing angle.
         * This helps ensuring a nice transition when the camera goes under the ground.
         */
        opacityFresnel: boolean;
        protected _reflectionFresnel: boolean;
        /**
         * This helps specifying that the material is falling off from diffuse to the reflection texture at grazing angle.
         * This helps adding a mirror texture on the ground.
         */
        reflectionFresnel: boolean;
        protected _reflectionFalloffDistance: number;
        /**
         * This helps specifying the falloff radius off the reflection texture from the sceneCenter.
         * This helps adding a nice falloff effect to the reflection if used as a mirror for instance.
         */
        reflectionFalloffDistance: number;
        protected _reflectionAmount: number;
        /**
         * This specifies the weight of the reflection against the background in case of reflection Fresnel.
         */
        reflectionAmount: number;
        protected _reflectionReflectance0: number;
        /**
         * This specifies the weight of the reflection at grazing angle.
         */
        reflectionReflectance0: number;
        protected _reflectionReflectance90: number;
        /**
         * This specifies the weight of the reflection at a perpendicular point of view.
         */
        reflectionReflectance90: number;
        /**
         * Sets the reflection reflectance fresnel values according to the default standard
         * empirically know to work well :-)
         */
        set reflectionStandardFresnelWeight(value: number);
        protected _useRGBColor: boolean;
        /**
         * Helps to directly use the maps channels instead of their level.
         */
        useRGBColor: boolean;
        protected _enableNoise: boolean;
        /**
         * This helps reducing the banding effect that could occur on the background.
         */
        enableNoise: boolean;
        /**
         * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values "zoom in" and higher values "zoom out".
         * Best used when trying to implement visual zoom effects like fish-eye or binoculars while not adjusting camera fov.
         * Recommended to be keep at 1.0 except for special cases.
         */
        get fovMultiplier(): number;
        set fovMultiplier(value: number);
        private _fovMultiplier;
        /**
         * Enable the FOV adjustment feature controlled by fovMultiplier.
         */
        useEquirectangularFOV: boolean;
        private _maxSimultaneousLights;
        /**
         * Number of Simultaneous lights allowed on the material.
         */
        maxSimultaneousLights: int;
        private _shadowOnly;
        /**
         * Make the material only render shadows
         */
        shadowOnly: boolean;
        /**
         * Default configuration related to image processing available in the Background Material.
         */
        protected _imageProcessingConfiguration: ImageProcessingConfiguration;
        /**
         * Keep track of the image processing observer to allow dispose and replace.
         */
        private _imageProcessingObserver;
        /**
         * Attaches a new image processing configuration to the PBR Material.
         * @param configuration (if null the scene configuration will be use)
         */
        protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void;
        /**
         * Gets the image processing configuration used either in this material.
         */
        get imageProcessingConfiguration(): Nullable<ImageProcessingConfiguration>;
        /**
         * Sets the Default image processing configuration used either in the this material.
         *
         * If sets to null, the scene one is in use.
         */
        set imageProcessingConfiguration(value: Nullable<ImageProcessingConfiguration>);
        /**
         * Gets wether the color curves effect is enabled.
         */
        get cameraColorCurvesEnabled(): boolean;
        /**
         * Sets wether the color curves effect is enabled.
         */
        set cameraColorCurvesEnabled(value: boolean);
        /**
         * Gets wether the color grading effect is enabled.
         */
        get cameraColorGradingEnabled(): boolean;
        /**
         * Gets wether the color grading effect is enabled.
         */
        set cameraColorGradingEnabled(value: boolean);
        /**
         * Gets wether tonemapping is enabled or not.
         */
        get cameraToneMappingEnabled(): boolean;
        /**
         * Sets wether tonemapping is enabled or not
         */
        set cameraToneMappingEnabled(value: boolean);
        /**
         * The camera exposure used on this material.
         * This property is here and not in the camera to allow controlling exposure without full screen post process.
         * This corresponds to a photographic exposure.
         */
        get cameraExposure(): float;
        /**
         * The camera exposure used on this material.
         * This property is here and not in the camera to allow controlling exposure without full screen post process.
         * This corresponds to a photographic exposure.
         */
        set cameraExposure(value: float);
        /**
         * Gets The camera contrast used on this material.
         */
        get cameraContrast(): float;
        /**
         * Sets The camera contrast used on this material.
         */
        set cameraContrast(value: float);
        /**
         * Gets the Color Grading 2D Lookup Texture.
         */
        get cameraColorGradingTexture(): Nullable<BaseTexture>;
        /**
         * Sets the Color Grading 2D Lookup Texture.
         */
        set cameraColorGradingTexture(value: Nullable<BaseTexture>);
        /**
         * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
         * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
         * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
         * corresponding to low luminance, medium luminance, and high luminance areas respectively.
         */
        get cameraColorCurves(): Nullable<ColorCurves>;
        /**
         * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
         * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
         * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
         * corresponding to low luminance, medium luminance, and high luminance areas respectively.
         */
        set cameraColorCurves(value: Nullable<ColorCurves>);
        /**
         * Due to a bug in iOS10, video tags (which are using the background material) are in BGR and not RGB.
         * Setting this flag to true (not done automatically!) will convert it back to RGB.
         */
        switchToBGR: boolean;
        private _renderTargets;
        private _reflectionControls;
        private _white;
        private _primaryShadowColor;
        private _primaryHighlightColor;
        /**
         * Instantiates a Background Material in the given scene
         * @param name The friendly name of the material
         * @param scene The scene to add the material to
         */
        constructor(name: string, scene: Scene);
        /**
         * Gets a boolean indicating that current material needs to register RTT
         */
        get hasRenderTargetTextures(): boolean;
        /**
         * The entire material has been created in order to prevent overdraw.
         * @returns false
         */
        needAlphaTesting(): boolean;
        /**
         * The entire material has been created in order to prevent overdraw.
         * @returns true if blending is enable
         */
        needAlphaBlending(): boolean;
        /**
         * Checks wether the material is ready to be rendered for a given mesh.
         * @param mesh The mesh to render
         * @param subMesh The submesh to check against
         * @param useInstances Specify wether or not the material is used with instances
         * @returns true if all the dependencies are ready (Textures, Effects...)
         */
        isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean;
        /**
         * Compute the primary color according to the chosen perceptual color.
         */
        private _computePrimaryColorFromPerceptualColor;
        /**
         * Compute the highlights and shadow colors according to their chosen levels.
         */
        private _computePrimaryColors;
        /**
         * Build the uniform buffer used in the material.
         */
        buildUniformLayout(): void;
        /**
         * Unbind the material.
         */
        unbind(): void;
        /**
         * Bind only the world matrix to the material.
         * @param world The world matrix to bind.
         */
        bindOnlyWorldMatrix(world: Matrix): void;
        /**
         * Bind the material for a dedicated submeh (every used meshes will be considered opaque).
         * @param world The world matrix to bind.
         * @param subMesh The submesh to bind for.
         */
        bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void;
        /**
         * Checks to see if a texture is used in the material.
         * @param texture - Base texture to use.
         * @returns - Boolean specifying if a texture is used in the material.
         */
        hasTexture(texture: BaseTexture): boolean;
        /**
         * Dispose the material.
         * @param forceDisposeEffect Force disposal of the associated effect.
         * @param forceDisposeTextures Force disposal of the associated textures.
         */
        dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean): void;
        /**
         * Clones the material.
         * @param name The cloned name.
         * @returns The cloned material.
         */
        clone(name: string): BackgroundMaterial;
        /**
         * Serializes the current material to its JSON representation.
         * @returns The JSON representation.
         */
        serialize(): any;
        /**
         * Gets the class name of the material
         * @returns "BackgroundMaterial"
         */
        getClassName(): string;
        /**
         * Parse a JSON input to create back a background material.
         * @param source The JSON data to parse
         * @param scene The scene to create the parsed material in
         * @param rootUrl The root url of the assets the material depends upon
         * @returns the instantiated BackgroundMaterial.
         */
        static Parse(source: any, scene: Scene, rootUrl: string): BackgroundMaterial;
    }
}
declare module BABYLON {
    /**
     * Represents the different options available during the creation of
     * a Environment helper.
     *
     * This can control the default ground, skybox and image processing setup of your scene.
     */
    export interface IEnvironmentHelperOptions {
        /**
         * Specifies whether or not to create a ground.
         * True by default.
         */
        createGround: boolean;
        /**
         * Specifies the ground size.
         * 15 by default.
         */
        groundSize: number;
        /**
         * The texture used on the ground for the main color.
         * Comes from the BabylonJS CDN by default.
         *
         * Remarks: Can be either a texture or a url.
         */
        groundTexture: string | BaseTexture;
        /**
         * The color mixed in the ground texture by default.
         * BabylonJS clearColor by default.
         */
        groundColor: Color3;
        /**
         * Specifies the ground opacity.
         * 1 by default.
         */
        groundOpacity: number;
        /**
         * Enables the ground to receive shadows.
         * True by default.
         */
        enableGroundShadow: boolean;
        /**
         * Helps preventing the shadow to be fully black on the ground.
         * 0.5 by default.
         */
        groundShadowLevel: number;
        /**
         * Creates a mirror texture attach to the ground.
         * false by default.
         */
        enableGroundMirror: boolean;
        /**
         * Specifies the ground mirror size ratio.
         * 0.3 by default as the default kernel is 64.
         */
        groundMirrorSizeRatio: number;
        /**
         * Specifies the ground mirror blur kernel size.
         * 64 by default.
         */
        groundMirrorBlurKernel: number;
        /**
         * Specifies the ground mirror visibility amount.
         * 1 by default
         */
        groundMirrorAmount: number;
        /**
         * Specifies the ground mirror reflectance weight.
         * This uses the standard weight of the background material to setup the fresnel effect
         * of the mirror.
         * 1 by default.
         */
        groundMirrorFresnelWeight: number;
        /**
         * Specifies the ground mirror Falloff distance.
         * This can helps reducing the size of the reflection.
         * 0 by Default.
         */
        groundMirrorFallOffDistance: number;
        /**
         * Specifies the ground mirror texture type.
         * Unsigned Int by Default.
         */
        groundMirrorTextureType: number;
        /**
         * Specifies a bias applied to the ground vertical position to prevent z-fighting with
         * the shown objects.
         */
        groundYBias: number;
        /**
         * Specifies whether or not to create a skybox.
         * True by default.
         */
        createSkybox: boolean;
        /**
         * Specifies the skybox size.
         * 20 by default.
         */
        skyboxSize: number;
        /**
         * The texture used on the skybox for the main color.
         * Comes from the BabylonJS CDN by default.
         *
         * Remarks: Can be either a texture or a url.
         */
        skyboxTexture: string | BaseTexture;
        /**
         * The color mixed in the skybox texture by default.
         * BabylonJS clearColor by default.
         */
        skyboxColor: Color3;
        /**
         * The background rotation around the Y axis of the scene.
         * This helps aligning the key lights of your scene with the background.
         * 0 by default.
         */
        backgroundYRotation: number;
        /**
         * Compute automatically the size of the elements to best fit with the scene.
         */
        sizeAuto: boolean;
        /**
         * Default position of the rootMesh if autoSize is not true.
         */
        rootPosition: Vector3;
        /**
         * Sets up the image processing in the scene.
         * true by default.
         */
        setupImageProcessing: boolean;
        /**
         * The texture used as your environment texture in the scene.
         * Comes from the BabylonJS CDN by default and in use if setupImageProcessing is true.
         *
         * Remarks: Can be either a texture or a url.
         */
        environmentTexture: string | BaseTexture;
        /**
         * The value of the exposure to apply to the scene.
         * 0.6 by default if setupImageProcessing is true.
         */
        cameraExposure: number;
        /**
         * The value of the contrast to apply to the scene.
         * 1.6 by default if setupImageProcessing is true.
         */
        cameraContrast: number;
        /**
         * Specifies whether or not tonemapping should be enabled in the scene.
         * true by default if setupImageProcessing is true.
         */
        toneMappingEnabled: boolean;
    }
    /**
     * The Environment helper class can be used to add a fully featuread none expensive background to your scene.
     * It includes by default a skybox and a ground relying on the BackgroundMaterial.
     * It also helps with the default setup of your imageProcessing configuration.
     */
    export class EnvironmentHelper {
        /**
         * Default ground texture URL.
         */
        private static _groundTextureCDNUrl;
        /**
         * Default skybox texture URL.
         */
        private static _skyboxTextureCDNUrl;
        /**
         * Default environment texture URL.
         */
        private static _environmentTextureCDNUrl;
        /**
         * Creates the default options for the helper.
         */
        private static _getDefaultOptions;
        private _rootMesh;
        /**
         * Gets the root mesh created by the helper.
         */
        get rootMesh(): Mesh;
        private _skybox;
        /**
         * Gets the skybox created by the helper.
         */
        get skybox(): Nullable<Mesh>;
        private _skyboxTexture;
        /**
         * Gets the skybox texture created by the helper.
         */
        get skyboxTexture(): Nullable<BaseTexture>;
        private _skyboxMaterial;
        /**
         * Gets the skybox material created by the helper.
         */
        get skyboxMaterial(): Nullable<BackgroundMaterial>;
        private _ground;
        /**
         * Gets the ground mesh created by the helper.
         */
        get ground(): Nullable<Mesh>;
        private _groundTexture;
        /**
         * Gets the ground texture created by the helper.
         */
        get groundTexture(): Nullable<BaseTexture>;
        private _groundMirror;
        /**
         * Gets the ground mirror created by the helper.
         */
        get groundMirror(): Nullable<MirrorTexture>;
        /**
         * Gets the ground mirror render list to helps pushing the meshes
         * you wish in the ground reflection.
         */
        get groundMirrorRenderList(): Nullable<AbstractMesh[]>;
        private _groundMaterial;
        /**
         * Gets the ground material created by the helper.
         */
        get groundMaterial(): Nullable<BackgroundMaterial>;
        /**
         * Stores the creation options.
         */
        private readonly _scene;
        private _options;
        /**
         * This observable will be notified with any error during the creation of the environment,
         * mainly texture creation errors.
         */
        onErrorObservable: Observable<{
            message?: string;
            exception?: any;
        }>;
        /**
         * constructor
         * @param options Defines the options we want to customize the helper
         * @param scene The scene to add the material to
         */
        constructor(options: Partial<IEnvironmentHelperOptions>, scene: Scene);
        /**
         * Updates the background according to the new options
         * @param options
         */
        updateOptions(options: Partial<IEnvironmentHelperOptions>): void;
        /**
         * Sets the primary color of all the available elements.
         * @param color the main color to affect to the ground and the background
         */
        setMainColor(color: Color3): void;
        /**
         * Setup the image processing according to the specified options.
         */
        private _setupImageProcessing;
        /**
         * Setup the environment texture according to the specified options.
         */
        private _setupEnvironmentTexture;
        /**
         * Setup the background according to the specified options.
         */
        private _setupBackground;
        /**
         * Get the scene sizes according to the setup.
         */
        private _getSceneSize;
        /**
         * Setup the ground according to the specified options.
         */
        private _setupGround;
        /**
         * Setup the ground material according to the specified options.
         */
        private _setupGroundMaterial;
        /**
         * Setup the ground diffuse texture according to the specified options.
         */
        private _setupGroundDiffuseTexture;
        /**
         * Setup the ground mirror texture according to the specified options.
         */
        private _setupGroundMirrorTexture;
        /**
         * Setup the ground to receive the mirror texture.
         */
        private _setupMirrorInGroundMaterial;
        /**
         * Setup the skybox according to the specified options.
         */
        private _setupSkybox;
        /**
         * Setup the skybox material according to the specified options.
         */
        private _setupSkyboxMaterial;
        /**
         * Setup the skybox reflection texture according to the specified options.
         */
        private _setupSkyboxReflectionTexture;
        private _errorHandler;
        /**
         * Dispose all the elements created by the Helper.
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * Display a 360/180 degree texture on an approximately spherical surface, useful for VR applications or skyboxes.
     * As a subclass of TransformNode, this allow parenting to the camera or multiple textures with different locations in the scene.
     * This class achieves its effect with a Texture and a correctly configured BackgroundMaterial on an inverted sphere.
     * Potential additions to this helper include zoom and and non-infinite distance rendering effects.
     */
    export abstract class TextureDome<T extends Texture> extends TransformNode {
        protected onError: Nullable<(message?: string, exception?: any) => void>;
        /**
         * Define the source as a Monoscopic panoramic 360/180.
         */
        static readonly MODE_MONOSCOPIC: number;
        /**
         * Define the source as a Stereoscopic TopBottom/OverUnder panoramic 360/180.
         */
        static readonly MODE_TOPBOTTOM: number;
        /**
         * Define the source as a Stereoscopic Side by Side panoramic 360/180.
         */
        static readonly MODE_SIDEBYSIDE: number;
        private _halfDome;
        protected _useDirectMapping: boolean;
        /**
         * The texture being displayed on the sphere
         */
        protected _texture: T;
        /**
         * Gets the texture being displayed on the sphere
         */
        get texture(): T;
        /**
         * Sets the texture being displayed on the sphere
         */
        set texture(newTexture: T);
        /**
         * The skybox material
         */
        protected _material: BackgroundMaterial;
        /**
         * The surface used for the dome
         */
        protected _mesh: Mesh;
        /**
         * Gets the mesh used for the dome.
         */
        get mesh(): Mesh;
        /**
         * A mesh that will be used to mask the back of the dome in case it is a 180 degree movie.
         */
        private _halfDomeMask;
        /**
         * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values "zoom in" and higher values "zoom out".
         * Also see the options.resolution property.
         */
        get fovMultiplier(): number;
        set fovMultiplier(value: number);
        protected _textureMode: number;
        /**
         * Gets or set the current texture mode for the texture. It can be:
         * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.
         * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.
         * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.
         */
        get textureMode(): number;
        /**
         * Sets the current texture mode for the texture. It can be:
          * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.
         * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.
         * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.
         */
        set textureMode(value: number);
        /**
         * Is it a 180 degrees dome (half dome) or 360 texture (full dome)
         */
        get halfDome(): boolean;
        /**
         * Set the halfDome mode. If set, only the front (180 degrees) will be displayed and the back will be blacked out.
         */
        set halfDome(enabled: boolean);
        /**
         * Oberserver used in Stereoscopic VR Mode.
         */
        private _onBeforeCameraRenderObserver;
        /**
         * Observable raised when an error occured while loading the 360 image
         */
        onLoadErrorObservable: Observable<string>;
        /**
         * Create an instance of this class and pass through the parameters to the relevant classes- Texture, StandardMaterial, and Mesh.
         * @param name Element's name, child elements will append suffixes for their own names.
         * @param textureUrlOrElement defines the url(s) or the (video) HTML element to use
         * @param options An object containing optional or exposed sub element properties
         */
        constructor(name: string, textureUrlOrElement: string | string[] | HTMLVideoElement, options: {
            resolution?: number;
            clickToPlay?: boolean;
            autoPlay?: boolean;
            loop?: boolean;
            size?: number;
            poster?: string;
            faceForward?: boolean;
            useDirectMapping?: boolean;
            halfDomeMode?: boolean;
        }, scene: Scene, onError?: Nullable<(message?: string, exception?: any) => void>);
        protected abstract _initTexture(urlsOrElement: string | string[] | HTMLElement, scene: Scene, options: any): T;
        protected _changeTextureMode(value: number): void;
        /**
         * Releases resources associated with this node.
         * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
         * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
         */
        dispose(doNotRecurse?: boolean, disposeMaterialAndTextures?: boolean): void;
    }
}
declare module BABYLON {
    /**
     * Display a 360 degree photo on an approximately spherical surface, useful for VR applications or skyboxes.
     * As a subclass of TransformNode, this allow parenting to the camera with different locations in the scene.
     * This class achieves its effect with a Texture and a correctly configured BackgroundMaterial on an inverted sphere.
     * Potential additions to this helper include zoom and and non-infinite distance rendering effects.
     */
    export class PhotoDome extends TextureDome<Texture> {
        /**
         * Define the image as a Monoscopic panoramic 360 image.
         */
        static readonly MODE_MONOSCOPIC: number;
        /**
         * Define the image as a Stereoscopic TopBottom/OverUnder panoramic 360 image.
         */
        static readonly MODE_TOPBOTTOM: number;
        /**
         * Define the image as a Stereoscopic Side by Side panoramic 360 image.
         */
        static readonly MODE_SIDEBYSIDE: number;
        /**
         * Gets or sets the texture being displayed on the sphere
         */
        get photoTexture(): Texture;
        /**
         * sets the texture being displayed on the sphere
         */
        set photoTexture(value: Texture);
        /**
         * Gets the current video mode for the video. It can be:
         * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.
         * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.
         * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.
         */
        get imageMode(): number;
        /**
         * Sets the current video mode for the video. It can be:
         * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.
         * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.
         * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.
         */
        set imageMode(value: number);
        protected _initTexture(urlsOrElement: string, scene: Scene, options: any): Texture;
    }
}
declare module BABYLON {
    /**
     * Class used to host RGBD texture specific utilities
     */
    export class RGBDTextureTools {
        /**
         * Expand the RGBD Texture from RGBD to Half Float if possible.
         * @param texture the texture to expand.
         */
        static ExpandRGBDTexture(texture: Texture): void;
    }
}
declare module BABYLON {
    /**
     * Class used to host texture specific utilities
     */
    export class BRDFTextureTools {
        /**
         * Prevents texture cache collision
         */
        private static _instanceNumber;
        /**
         * Gets a default environment BRDF for MS-BRDF Height Correlated BRDF
         * @param scene defines the hosting scene
         * @returns the environment BRDF texture
         */
        static GetEnvironmentBRDFTexture(scene: Scene): BaseTexture;
        private static _environmentBRDFBase64Texture;
    }
}
declare module BABYLON {
    /**
     * @hidden
     */
    export interface IMaterialClearCoatDefines {
        CLEARCOAT: boolean;
        CLEARCOAT_DEFAULTIOR: boolean;
        CLEARCOAT_TEXTURE: boolean;
        CLEARCOAT_TEXTUREDIRECTUV: number;
        CLEARCOAT_BUMP: boolean;
        CLEARCOAT_BUMPDIRECTUV: number;
        CLEARCOAT_TINT: boolean;
        CLEARCOAT_TINT_TEXTURE: boolean;
        CLEARCOAT_TINT_TEXTUREDIRECTUV: number;
        /** @hidden */
        _areTexturesDirty: boolean;
    }
    /**
     * Define the code related to the clear coat parameters of the pbr material.
     */
    export class PBRClearCoatConfiguration {
        /**
         * This defaults to 1.5 corresponding to a 0.04 f0 or a 4% reflectance at normal incidence
         * The default fits with a polyurethane material.
         */
        private static readonly _DefaultIndexOfRefraction;
        private _isEnabled;
        /**
         * Defines if the clear coat is enabled in the material.
         */
        isEnabled: boolean;
        /**
         * Defines the clear coat layer strength (between 0 and 1) it defaults to 1.
         */
        intensity: number;
        /**
         * Defines the clear coat layer roughness.
         */
        roughness: number;
        private _indexOfRefraction;
        /**
         * Defines the index of refraction of the clear coat.
         * This defaults to 1.5 corresponding to a 0.04 f0 or a 4% reflectance at normal incidence
         * The default fits with a polyurethane material.
         * Changing the default value is more performance intensive.
         */
        indexOfRefraction: number;
        private _texture;
        /**
         * Stores the clear coat values in a texture.
         */
        texture: Nullable<BaseTexture>;
        private _bumpTexture;
        /**
         * Define the clear coat specific bump texture.
         */
        bumpTexture: Nullable<BaseTexture>;
        private _isTintEnabled;
        /**
         * Defines if the clear coat tint is enabled in the material.
         */
        isTintEnabled: boolean;
        /**
         * Defines the clear coat tint of the material.
         * This is only use if tint is enabled
         */
        tintColor: Color3;
        /**
         * Defines the distance at which the tint color should be found in the
         * clear coat media.
         * This is only use if tint is enabled
         */
        tintColorAtDistance: number;
        /**
         * Defines the clear coat layer thickness.
         * This is only use if tint is enabled
         */
        tintThickness: number;
        private _tintTexture;
        /**
         * Stores the clear tint values in a texture.
         * rgb is tint
         * a is a thickness factor
         */
        tintTexture: Nullable<BaseTexture>;
        /** @hidden */
        private _internalMarkAllSubMeshesAsTexturesDirty;
        /** @hidden */
        _markAllSubMeshesAsTexturesDirty(): void;
        /**
         * Instantiate a new istance of clear coat configuration.
         * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty
         */
        constructor(markAllSubMeshesAsTexturesDirty: () => void);
        /**
         * Gets wehter the submesh is ready to be used or not.
         * @param defines the list of "defines" to update.
         * @param scene defines the scene the material belongs to.
         * @param engine defines the engine the material belongs to.
         * @param disableBumpMap defines wether the material disables bump or not.
         * @returns - boolean indicating that the submesh is ready or not.
         */
        isReadyForSubMesh(defines: IMaterialClearCoatDefines, scene: Scene, engine: Engine, disableBumpMap: boolean): boolean;
        /**
         * Checks to see if a texture is used in the material.
         * @param defines the list of "defines" to update.
         * @param scene defines the scene to the material belongs to.
         */
        prepareDefines(defines: IMaterialClearCoatDefines, scene: Scene): void;
        /**
         * Binds the material data.
         * @param uniformBuffer defines the Uniform buffer to fill in.
         * @param scene defines the scene the material belongs to.
         * @param engine defines the engine the material belongs to.
         * @param disableBumpMap defines wether the material disables bump or not.
         * @param isFrozen defines wether the material is frozen or not.
         * @param invertNormalMapX If sets to true, x component of normal map value will be inverted (x = 1.0 - x).
         * @param invertNormalMapY If sets to true, y component of normal map value will be inverted (y = 1.0 - y).
         */
        bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, disableBumpMap: boolean, isFrozen: boolean, invertNormalMapX: boolean, invertNormalMapY: boolean): void;
        /**
         * Checks to see if a texture is used in the material.
         * @param texture - Base texture to use.
         * @returns - Boolean specifying if a texture is used in the material.
         */
        hasTexture(texture: BaseTexture): boolean;
        /**
         * Returns an array of the actively used textures.
         * @param activeTextures Array of BaseTextures
         */
        getActiveTextures(activeTextures: BaseTexture[]): void;
        /**
         * Returns the animatable textures.
         * @param animatables Array of animatable textures.
         */
        getAnimatables(animatables: IAnimatable[]): void;
        /**
         * Disposes the resources of the material.
         * @param forceDisposeTextures - Forces the disposal of all textures.
         */
        dispose(forceDisposeTextures?: boolean): void;
        /**
        * Get the current class name of the texture useful for serialization or dynamic coding.
        * @returns "PBRClearCoatConfiguration"
        */
        getClassName(): string;
        /**
         * Add fallbacks to the effect fallbacks list.
         * @param defines defines the Base texture to use.
         * @param fallbacks defines the current fallback list.
         * @param currentRank defines the current fallback rank.
         * @returns the new fallback rank.
         */
        static AddFallbacks(defines: IMaterialClearCoatDefines, fallbacks: EffectFallbacks, currentRank: number): number;
        /**
         * Add the required uniforms to the current list.
         * @param uniforms defines the current uniform list.
         */
        static AddUniforms(uniforms: string[]): void;
        /**
         * Add the required samplers to the current list.
         * @param samplers defines the current sampler list.
         */
        static AddSamplers(samplers: string[]): void;
        /**
         * Add the required uniforms to the current buffer.
         * @param uniformBuffer defines the current uniform buffer.
         */
        static PrepareUniformBuffer(uniformBuffer: UniformBuffer): void;
        /**
         * Makes a duplicate of the current configuration into another one.
         * @param clearCoatConfiguration define the config where to copy the info
         */
        copyTo(clearCoatConfiguration: PBRClearCoatConfiguration): void;
        /**
         * Serializes this clear coat configuration.
         * @returns - An object with the serialized config.
         */
        serialize(): any;
        /**
         * Parses a anisotropy Configuration from a serialized object.
         * @param source - Serialized object.
         * @param scene Defines the scene we are parsing for
         * @param rootUrl Defines the rootUrl to load from
         */
        parse(source: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * @hidden
     */
    export interface IMaterialAnisotropicDefines {
        ANISOTROPIC: boolean;
        ANISOTROPIC_TEXTURE: boolean;
        ANISOTROPIC_TEXTUREDIRECTUV: number;
        MAINUV1: boolean;
        _areTexturesDirty: boolean;
        _needUVs: boolean;
    }
    /**
     * Define the code related to the anisotropic parameters of the pbr material.
     */
    export class PBRAnisotropicConfiguration {
        private _isEnabled;
        /**
         * Defines if the anisotropy is enabled in the material.
         */
        isEnabled: boolean;
        /**
         * Defines the anisotropy strength (between 0 and 1) it defaults to 1.
         */
        intensity: number;
        /**
         * Defines if the effect is along the tangents, bitangents or in between.
         * By default, the effect is "strectching" the highlights along the tangents.
         */
        direction: Vector2;
        private _texture;
        /**
         * Stores the anisotropy values in a texture.
         * rg is direction (like normal from -1 to 1)
         * b is a intensity
         */
        texture: Nullable<BaseTexture>;
        /** @hidden */
        private _internalMarkAllSubMeshesAsTexturesDirty;
        /** @hidden */
        _markAllSubMeshesAsTexturesDirty(): void;
        /**
         * Instantiate a new istance of anisotropy configuration.
         * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty
         */
        constructor(markAllSubMeshesAsTexturesDirty: () => void);
        /**
         * Specifies that the submesh is ready to be used.
         * @param defines the list of "defines" to update.
         * @param scene defines the scene the material belongs to.
         * @returns - boolean indicating that the submesh is ready or not.
         */
        isReadyForSubMesh(defines: IMaterialAnisotropicDefines, scene: Scene): boolean;
        /**
         * Checks to see if a texture is used in the material.
         * @param defines the list of "defines" to update.
         * @param mesh the mesh we are preparing the defines for.
         * @param scene defines the scene the material belongs to.
         */
        prepareDefines(defines: IMaterialAnisotropicDefines, mesh: AbstractMesh, scene: Scene): void;
        /**
         * Binds the material data.
         * @param uniformBuffer defines the Uniform buffer to fill in.
         * @param scene defines the scene the material belongs to.
         * @param isFrozen defines wether the material is frozen or not.
         */
        bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, isFrozen: boolean): void;
        /**
         * Checks to see if a texture is used in the material.
         * @param texture - Base texture to use.
         * @returns - Boolean specifying if a texture is used in the material.
         */
        hasTexture(texture: BaseTexture): boolean;
        /**
         * Returns an array of the actively used textures.
         * @param activeTextures Array of BaseTextures
         */
        getActiveTextures(activeTextures: BaseTexture[]): void;
        /**
         * Returns the animatable textures.
         * @param animatables Array of animatable textures.
         */
        getAnimatables(animatables: IAnimatable[]): void;
        /**
         * Disposes the resources of the material.
         * @param forceDisposeTextures - Forces the disposal of all textures.
         */
        dispose(forceDisposeTextures?: boolean): void;
        /**
        * Get the current class name of the texture useful for serialization or dynamic coding.
        * @returns "PBRAnisotropicConfiguration"
        */
        getClassName(): string;
        /**
         * Add fallbacks to the effect fallbacks list.
         * @param defines defines the Base texture to use.
         * @param fallbacks defines the current fallback list.
         * @param currentRank defines the current fallback rank.
         * @returns the new fallback rank.
         */
        static AddFallbacks(defines: IMaterialAnisotropicDefines, fallbacks: EffectFallbacks, currentRank: number): number;
        /**
         * Add the required uniforms to the current list.
         * @param uniforms defines the current uniform list.
         */
        static AddUniforms(uniforms: string[]): void;
        /**
         * Add the required uniforms to the current buffer.
         * @param uniformBuffer defines the current uniform buffer.
         */
        static PrepareUniformBuffer(uniformBuffer: UniformBuffer): void;
        /**
         * Add the required samplers to the current list.
         * @param samplers defines the current sampler list.
         */
        static AddSamplers(samplers: string[]): void;
        /**
         * Makes a duplicate of the current configuration into another one.
         * @param anisotropicConfiguration define the config where to copy the info
         */
        copyTo(anisotropicConfiguration: PBRAnisotropicConfiguration): void;
        /**
         * Serializes this anisotropy configuration.
         * @returns - An object with the serialized config.
         */
        serialize(): any;
        /**
         * Parses a anisotropy Configuration from a serialized object.
         * @param source - Serialized object.
         * @param scene Defines the scene we are parsing for
         * @param rootUrl Defines the rootUrl to load from
         */
        parse(source: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * @hidden
     */
    export interface IMaterialBRDFDefines {
        BRDF_V_HEIGHT_CORRELATED: boolean;
        MS_BRDF_ENERGY_CONSERVATION: boolean;
        SPHERICAL_HARMONICS: boolean;
        SPECULAR_GLOSSINESS_ENERGY_CONSERVATION: boolean;
        /** @hidden */
        _areMiscDirty: boolean;
    }
    /**
     * Define the code related to the BRDF parameters of the pbr material.
     */
    export class PBRBRDFConfiguration {
        /**
         * Default value used for the energy conservation.
         * This should only be changed to adapt to the type of texture in scene.environmentBRDFTexture.
         */
        static DEFAULT_USE_ENERGY_CONSERVATION: boolean;
        /**
         * Default value used for the Smith Visibility Height Correlated mode.
         * This should only be changed to adapt to the type of texture in scene.environmentBRDFTexture.
         */
        static DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED: boolean;
        /**
         * Default value used for the IBL diffuse part.
         * This can help switching back to the polynomials mode globally which is a tiny bit
         * less GPU intensive at the drawback of a lower quality.
         */
        static DEFAULT_USE_SPHERICAL_HARMONICS: boolean;
        /**
         * Default value used for activating energy conservation for the specular workflow.
         * If activated, the albedo color is multiplied with (1. - maxChannel(specular color)).
         * If deactivated, a material is only physically plausible, when (albedo color + specular color) < 1.
         */
        static DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION: boolean;
        private _useEnergyConservation;
        /**
         * Defines if the material uses energy conservation.
         */
        useEnergyConservation: boolean;
        private _useSmithVisibilityHeightCorrelated;
        /**
         * LEGACY Mode set to false
         * Defines if the material uses height smith correlated visibility term.
         * If you intent to not use our default BRDF, you need to load a separate BRDF Texture for the PBR
         * You can either load https://assets.babylonjs.com/environments/uncorrelatedBRDF.png
         * or https://assets.babylonjs.com/environments/uncorrelatedBRDF.dds to have more precision
         * Not relying on height correlated will also disable energy conservation.
         */
        useSmithVisibilityHeightCorrelated: boolean;
        private _useSphericalHarmonics;
        /**
         * LEGACY Mode set to false
         * Defines if the material uses spherical harmonics vs spherical polynomials for the
         * diffuse part of the IBL.
         * The harmonics despite a tiny bigger cost has been proven to provide closer results
         * to the ground truth.
         */
        useSphericalHarmonics: boolean;
        private _useSpecularGlossinessInputEnergyConservation;
        /**
         * Defines if the material uses energy conservation, when the specular workflow is active.
         * If activated, the albedo color is multiplied with (1. - maxChannel(specular color)).
         * If deactivated, a material is only physically plausible, when (albedo color + specular color) < 1.
         * In the deactivated case, the material author has to ensure energy conservation, for a physically plausible rendering.
         */
        useSpecularGlossinessInputEnergyConservation: boolean;
        /** @hidden */
        private _internalMarkAllSubMeshesAsMiscDirty;
        /** @hidden */
        _markAllSubMeshesAsMiscDirty(): void;
        /**
         * Instantiate a new istance of clear coat configuration.
         * @param markAllSubMeshesAsMiscDirty Callback to flag the material to dirty
         */
        constructor(markAllSubMeshesAsMiscDirty: () => void);
        /**
         * Checks to see if a texture is used in the material.
         * @param defines the list of "defines" to update.
         */
        prepareDefines(defines: IMaterialBRDFDefines): void;
        /**
        * Get the current class name of the texture useful for serialization or dynamic coding.
        * @returns "PBRClearCoatConfiguration"
        */
        getClassName(): string;
        /**
         * Makes a duplicate of the current configuration into another one.
         * @param brdfConfiguration define the config where to copy the info
         */
        copyTo(brdfConfiguration: PBRBRDFConfiguration): void;
        /**
         * Serializes this BRDF configuration.
         * @returns - An object with the serialized config.
         */
        serialize(): any;
        /**
         * Parses a anisotropy Configuration from a serialized object.
         * @param source - Serialized object.
         * @param scene Defines the scene we are parsing for
         * @param rootUrl Defines the rootUrl to load from
         */
        parse(source: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * @hidden
     */
    export interface IMaterialSheenDefines {
        SHEEN: boolean;
        SHEEN_TEXTURE: boolean;
        SHEEN_TEXTUREDIRECTUV: number;
        SHEEN_LINKWITHALBEDO: boolean;
        SHEEN_ROUGHNESS: boolean;
        SHEEN_ALBEDOSCALING: boolean;
        /** @hidden */
        _areTexturesDirty: boolean;
    }
    /**
     * Define the code related to the Sheen parameters of the pbr material.
     */
    export class PBRSheenConfiguration {
        private _isEnabled;
        /**
         * Defines if the material uses sheen.
         */
        isEnabled: boolean;
        private _linkSheenWithAlbedo;
        /**
         * Defines if the sheen is linked to the sheen color.
         */
        linkSheenWithAlbedo: boolean;
        /**
         * Defines the sheen intensity.
         */
        intensity: number;
        /**
         * Defines the sheen color.
         */
        color: Color3;
        private _texture;
        /**
         * Stores the sheen tint values in a texture.
         * rgb is tint
         * a is a intensity or roughness if roughness has been defined
         */
        texture: Nullable<BaseTexture>;
        private _roughness;
        /**
         * Defines the sheen roughness.
         * It is not taken into account if linkSheenWithAlbedo is true.
         * To stay backward compatible, material roughness is used instead if sheen roughness = null
         */
        roughness: Nullable<number>;
        private _albedoScaling;
        /**
         * If true, the sheen effect is layered above the base BRDF with the albedo-scaling technique.
         * It allows the strength of the sheen effect to not depend on the base color of the material,
         * making it easier to setup and tweak the effect
         */
        albedoScaling: boolean;
        /** @hidden */
        private _internalMarkAllSubMeshesAsTexturesDirty;
        /** @hidden */
        _markAllSubMeshesAsTexturesDirty(): void;
        /**
         * Instantiate a new istance of clear coat configuration.
         * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty
         */
        constructor(markAllSubMeshesAsTexturesDirty: () => void);
        /**
         * Specifies that the submesh is ready to be used.
         * @param defines the list of "defines" to update.
         * @param scene defines the scene the material belongs to.
         * @returns - boolean indicating that the submesh is ready or not.
         */
        isReadyForSubMesh(defines: IMaterialSheenDefines, scene: Scene): boolean;
        /**
         * Checks to see if a texture is used in the material.
         * @param defines the list of "defines" to update.
         * @param scene defines the scene the material belongs to.
         */
        prepareDefines(defines: IMaterialSheenDefines, scene: Scene): void;
        /**
         * Binds the material data.
         * @param uniformBuffer defines the Uniform buffer to fill in.
         * @param scene defines the scene the material belongs to.
         * @param isFrozen defines wether the material is frozen or not.
         */
        bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, isFrozen: boolean): void;
        /**
         * Checks to see if a texture is used in the material.
         * @param texture - Base texture to use.
         * @returns - Boolean specifying if a texture is used in the material.
         */
        hasTexture(texture: BaseTexture): boolean;
        /**
         * Returns an array of the actively used textures.
         * @param activeTextures Array of BaseTextures
         */
        getActiveTextures(activeTextures: BaseTexture[]): void;
        /**
         * Returns the animatable textures.
         * @param animatables Array of animatable textures.
         */
        getAnimatables(animatables: IAnimatable[]): void;
        /**
         * Disposes the resources of the material.
         * @param forceDisposeTextures - Forces the disposal of all textures.
         */
        dispose(forceDisposeTextures?: boolean): void;
        /**
        * Get the current class name of the texture useful for serialization or dynamic coding.
        * @returns "PBRSheenConfiguration"
        */
        getClassName(): string;
        /**
         * Add fallbacks to the effect fallbacks list.
         * @param defines defines the Base texture to use.
         * @param fallbacks defines the current fallback list.
         * @param currentRank defines the current fallback rank.
         * @returns the new fallback rank.
         */
        static AddFallbacks(defines: IMaterialSheenDefines, fallbacks: EffectFallbacks, currentRank: number): number;
        /**
         * Add the required uniforms to the current list.
         * @param uniforms defines the current uniform list.
         */
        static AddUniforms(uniforms: string[]): void;
        /**
         * Add the required uniforms to the current buffer.
         * @param uniformBuffer defines the current uniform buffer.
         */
        static PrepareUniformBuffer(uniformBuffer: UniformBuffer): void;
        /**
         * Add the required samplers to the current list.
         * @param samplers defines the current sampler list.
         */
        static AddSamplers(samplers: string[]): void;
        /**
         * Makes a duplicate of the current configuration into another one.
         * @param sheenConfiguration define the config where to copy the info
         */
        copyTo(sheenConfiguration: PBRSheenConfiguration): void;
        /**
         * Serializes this BRDF configuration.
         * @returns - An object with the serialized config.
         */
        serialize(): any;
        /**
         * Parses a anisotropy Configuration from a serialized object.
         * @param source - Serialized object.
         * @param scene Defines the scene we are parsing for
         * @param rootUrl Defines the rootUrl to load from
         */
        parse(source: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * @hidden
     */
    export interface IMaterialSubSurfaceDefines {
        SUBSURFACE: boolean;
        SS_REFRACTION: boolean;
        SS_TRANSLUCENCY: boolean;
        SS_SCATTERING: boolean;
        SS_THICKNESSANDMASK_TEXTURE: boolean;
        SS_THICKNESSANDMASK_TEXTUREDIRECTUV: number;
        SS_REFRACTIONMAP_3D: boolean;
        SS_REFRACTIONMAP_OPPOSITEZ: boolean;
        SS_LODINREFRACTIONALPHA: boolean;
        SS_GAMMAREFRACTION: boolean;
        SS_RGBDREFRACTION: boolean;
        SS_LINEARSPECULARREFRACTION: boolean;
        SS_LINKREFRACTIONTOTRANSPARENCY: boolean;
        SS_ALBEDOFORREFRACTIONTINT: boolean;
        SS_MASK_FROM_THICKNESS_TEXTURE: boolean;
        /** @hidden */
        _areTexturesDirty: boolean;
    }
    /**
     * Define the code related to the sub surface parameters of the pbr material.
     */
    export class PBRSubSurfaceConfiguration {
        private _isRefractionEnabled;
        /**
         * Defines if the refraction is enabled in the material.
         */
        isRefractionEnabled: boolean;
        private _isTranslucencyEnabled;
        /**
         * Defines if the translucency is enabled in the material.
         */
        isTranslucencyEnabled: boolean;
        private _isScatteringEnabled;
        /**
         * Defines if the sub surface scattering is enabled in the material.
         */
        isScatteringEnabled: boolean;
        private _scatteringDiffusionProfileIndex;
        /**
         * Diffusion profile for subsurface scattering.
         * Useful for better scattering in the skins or foliages.
         */
        get scatteringDiffusionProfile(): Nullable<Color3>;
        set scatteringDiffusionProfile(c: Nullable<Color3>);
        /**
         * Defines the refraction intensity of the material.
         * The refraction when enabled replaces the Diffuse part of the material.
         * The intensity helps transitionning between diffuse and refraction.
         */
        refractionIntensity: number;
        /**
         * Defines the translucency intensity of the material.
         * When translucency has been enabled, this defines how much of the "translucency"
         * is addded to the diffuse part of the material.
         */
        translucencyIntensity: number;
        /**
         * When enabled, transparent surfaces will be tinted with the albedo colour (independent of thickness)
         */
        useAlbedoToTintRefraction: boolean;
        private _thicknessTexture;
        /**
         * Stores the average thickness of a mesh in a texture (The texture is holding the values linearly).
         * The red channel of the texture should contain the thickness remapped between 0 and 1.
         * 0 would mean minimumThickness
         * 1 would mean maximumThickness
         * The other channels might be use as a mask to vary the different effects intensity.
         */
        thicknessTexture: Nullable<BaseTexture>;
        private _refractionTexture;
        /**
         * Defines the texture to use for refraction.
         */
        refractionTexture: Nullable<BaseTexture>;
        private _indexOfRefraction;
        /**
         * Index of refraction of the material base layer.
         * https://en.wikipedia.org/wiki/List_of_refractive_indices
         *
         * This does not only impact refraction but also the Base F0 of Dielectric Materials.
         *
         * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))
         */
        indexOfRefraction: number;
        private _volumeIndexOfRefraction;
        /**
         * Index of refraction of the material's volume.
         * https://en.wikipedia.org/wiki/List_of_refractive_indices
         *
         * This ONLY impacts refraction. If not provided or given a non-valid value,
         * the volume will use the same IOR as the surface.
         */
        get volumeIndexOfRefraction(): number;
        set volumeIndexOfRefraction(value: number);
        private _invertRefractionY;
        /**
         * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.
         */
        invertRefractionY: boolean;
        private _linkRefractionWithTransparency;
        /**
         * This parameters will make the material used its opacity to control how much it is refracting aginst not.
         * Materials half opaque for instance using refraction could benefit from this control.
         */
        linkRefractionWithTransparency: boolean;
        /**
         * Defines the minimum thickness stored in the thickness map.
         * If no thickness map is defined, this value will be used to simulate thickness.
         */
        minimumThickness: number;
        /**
         * Defines the maximum thickness stored in the thickness map.
         */
        maximumThickness: number;
        /**
         * Defines the volume tint of the material.
         * This is used for both translucency and scattering.
         */
        tintColor: Color3;
        /**
         * Defines the distance at which the tint color should be found in the media.
         * This is used for refraction only.
         */
        tintColorAtDistance: number;
        /**
         * Defines how far each channel transmit through the media.
         * It is defined as a color to simplify it selection.
         */
        diffusionDistance: Color3;
        private _useMaskFromThicknessTexture;
        /**
         * Stores the intensity of the different subsurface effects in the thickness texture.
         * * the green channel is the translucency intensity.
         * * the blue channel is the scattering intensity.
         * * the alpha channel is the refraction intensity.
         */
        useMaskFromThicknessTexture: boolean;
        private _scene;
        /** @hidden */
        private _internalMarkAllSubMeshesAsTexturesDirty;
        private _internalMarkScenePrePassDirty;
        /** @hidden */
        _markAllSubMeshesAsTexturesDirty(): void;
        /** @hidden */
        _markScenePrePassDirty(): void;
        /**
         * Instantiate a new istance of sub surface configuration.
         * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty
         * @param markScenePrePassDirty Callback to flag the scene as prepass dirty
         * @param scene The scene
         */
        constructor(markAllSubMeshesAsTexturesDirty: () => void, markScenePrePassDirty: () => void, scene: Scene);
        /**
         * Gets wehter the submesh is ready to be used or not.
         * @param defines the list of "defines" to update.
         * @param scene defines the scene the material belongs to.
         * @returns - boolean indicating that the submesh is ready or not.
         */
        isReadyForSubMesh(defines: IMaterialSubSurfaceDefines, scene: Scene): boolean;
        /**
         * Checks to see if a texture is used in the material.
         * @param defines the list of "defines" to update.
         * @param scene defines the scene to the material belongs to.
         */
        prepareDefines(defines: IMaterialSubSurfaceDefines, scene: Scene): void;
        /**
         * Binds the material data.
         * @param uniformBuffer defines the Uniform buffer to fill in.
         * @param scene defines the scene the material belongs to.
         * @param engine defines the engine the material belongs to.
         * @param isFrozen defines whether the material is frozen or not.
         * @param lodBasedMicrosurface defines whether the material relies on lod based microsurface or not.
         * @param realTimeFiltering defines whether the textures should be filtered on the fly.
         */
        bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, isFrozen: boolean, lodBasedMicrosurface: boolean, realTimeFiltering: boolean): void;
        /**
         * Unbinds the material from the mesh.
         * @param activeEffect defines the effect that should be unbound from.
         * @returns true if unbound, otherwise false
         */
        unbind(activeEffect: Effect): boolean;
        /**
         * Returns the texture used for refraction or null if none is used.
         * @param scene defines the scene the material belongs to.
         * @returns - Refraction texture if present.  If no refraction texture and refraction
         * is linked with transparency, returns environment texture.  Otherwise, returns null.
         */
        private _getRefractionTexture;
        /**
         * Returns true if alpha blending should be disabled.
         */
        get disableAlphaBlending(): boolean;
        /**
         * Fills the list of render target textures.
         * @param renderTargets the list of render targets to update
         */
        fillRenderTargetTextures(renderTargets: SmartArray<RenderTargetTexture>): void;
        /**
         * Checks to see if a texture is used in the material.
         * @param texture - Base texture to use.
         * @returns - Boolean specifying if a texture is used in the material.
         */
        hasTexture(texture: BaseTexture): boolean;
        /**
         * Gets a boolean indicating that current material needs to register RTT
         * @returns true if this uses a render target otherwise false.
         */
        hasRenderTargetTextures(): boolean;
        /**
         * Returns an array of the actively used textures.
         * @param activeTextures Array of BaseTextures
         */
        getActiveTextures(activeTextures: BaseTexture[]): void;
        /**
         * Returns the animatable textures.
         * @param animatables Array of animatable textures.
         */
        getAnimatables(animatables: IAnimatable[]): void;
        /**
         * Disposes the resources of the material.
         * @param forceDisposeTextures - Forces the disposal of all textures.
         */
        dispose(forceDisposeTextures?: boolean): void;
        /**
        * Get the current class name of the texture useful for serialization or dynamic coding.
        * @returns "PBRSubSurfaceConfiguration"
        */
        getClassName(): string;
        /**
         * Add fallbacks to the effect fallbacks list.
         * @param defines defines the Base texture to use.
         * @param fallbacks defines the current fallback list.
         * @param currentRank defines the current fallback rank.
         * @returns the new fallback rank.
         */
        static AddFallbacks(defines: IMaterialSubSurfaceDefines, fallbacks: EffectFallbacks, currentRank: number): number;
        /**
         * Add the required uniforms to the current list.
         * @param uniforms defines the current uniform list.
         */
        static AddUniforms(uniforms: string[]): void;
        /**
         * Add the required samplers to the current list.
         * @param samplers defines the current sampler list.
         */
        static AddSamplers(samplers: string[]): void;
        /**
         * Add the required uniforms to the current buffer.
         * @param uniformBuffer defines the current uniform buffer.
         */
        static PrepareUniformBuffer(uniformBuffer: UniformBuffer): void;
        /**
         * Makes a duplicate of the current configuration into another one.
         * @param configuration define the config where to copy the info
         */
        copyTo(configuration: PBRSubSurfaceConfiguration): void;
        /**
         * Serializes this Sub Surface configuration.
         * @returns - An object with the serialized config.
         */
        serialize(): any;
        /**
         * Parses a anisotropy Configuration from a serialized object.
         * @param source - Serialized object.
         * @param scene Defines the scene we are parsing for
         * @param rootUrl Defines the rootUrl to load from
         */
        parse(source: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /** @hidden */
    export var pbrFragmentDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrUboDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrFragmentExtraDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrFragmentSamplersDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var importanceSampling: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrHelperFunctions: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var harmonicsFunctions: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrDirectLightingSetupFunctions: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrDirectLightingFalloffFunctions: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBRDFFunctions: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var hdrFilteringFunctions: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrDirectLightingFunctions: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrIBLFunctions: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBlockAlbedoOpacity: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBlockReflectivity: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBlockAmbientOcclusion: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBlockAlphaFresnel: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBlockAnisotropic: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBlockReflection: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBlockSheen: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBlockClearcoat: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBlockSubSurface: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBlockNormalGeometric: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBlockNormalFinal: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBlockLightmapInit: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBlockGeometryInfo: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBlockReflectance0: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBlockReflectance: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBlockDirectLighting: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBlockFinalLitComponents: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBlockFinalUnlitComponents: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBlockFinalColorComposition: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrBlockImageProcessing: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrDebug: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrVertexDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pbrVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Manages the defines for the PBR Material.
     * @hidden
     */
    export class PBRMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines, IMaterialClearCoatDefines, IMaterialAnisotropicDefines, IMaterialBRDFDefines, IMaterialSheenDefines, IMaterialSubSurfaceDefines, IMaterialDetailMapDefines {
        PBR: boolean;
        NUM_SAMPLES: string;
        REALTIME_FILTERING: boolean;
        MAINUV1: boolean;
        MAINUV2: boolean;
        UV1: boolean;
        UV2: boolean;
        ALBEDO: boolean;
        GAMMAALBEDO: boolean;
        ALBEDODIRECTUV: number;
        VERTEXCOLOR: boolean;
        DETAIL: boolean;
        DETAILDIRECTUV: number;
        DETAIL_NORMALBLENDMETHOD: number;
        AMBIENT: boolean;
        AMBIENTDIRECTUV: number;
        AMBIENTINGRAYSCALE: boolean;
        OPACITY: boolean;
        VERTEXALPHA: boolean;
        OPACITYDIRECTUV: number;
        OPACITYRGB: boolean;
        ALPHATEST: boolean;
        DEPTHPREPASS: boolean;
        ALPHABLEND: boolean;
        ALPHAFROMALBEDO: boolean;
        ALPHATESTVALUE: string;
        SPECULAROVERALPHA: boolean;
        RADIANCEOVERALPHA: boolean;
        ALPHAFRESNEL: boolean;
        LINEARALPHAFRESNEL: boolean;
        PREMULTIPLYALPHA: boolean;
        EMISSIVE: boolean;
        EMISSIVEDIRECTUV: number;
        REFLECTIVITY: boolean;
        REFLECTIVITYDIRECTUV: number;
        SPECULARTERM: boolean;
        MICROSURFACEFROMREFLECTIVITYMAP: boolean;
        MICROSURFACEAUTOMATIC: boolean;
        LODBASEDMICROSFURACE: boolean;
        MICROSURFACEMAP: boolean;
        MICROSURFACEMAPDIRECTUV: number;
        METALLICWORKFLOW: boolean;
        ROUGHNESSSTOREINMETALMAPALPHA: boolean;
        ROUGHNESSSTOREINMETALMAPGREEN: boolean;
        METALLNESSSTOREINMETALMAPBLUE: boolean;
        AOSTOREINMETALMAPRED: boolean;
        METALLIC_REFLECTANCE: boolean;
        METALLIC_REFLECTANCEDIRECTUV: number;
        ENVIRONMENTBRDF: boolean;
        ENVIRONMENTBRDF_RGBD: boolean;
        NORMAL: boolean;
        TANGENT: boolean;
        BUMP: boolean;
        BUMPDIRECTUV: number;
        OBJECTSPACE_NORMALMAP: boolean;
        PARALLAX: boolean;
        PARALLAXOCCLUSION: boolean;
        NORMALXYSCALE: boolean;
        LIGHTMAP: boolean;
        LIGHTMAPDIRECTUV: number;
        USELIGHTMAPASSHADOWMAP: boolean;
        GAMMALIGHTMAP: boolean;
        RGBDLIGHTMAP: boolean;
        REFLECTION: boolean;
        REFLECTIONMAP_3D: boolean;
        REFLECTIONMAP_SPHERICAL: boolean;
        REFLECTIONMAP_PLANAR: boolean;
        REFLECTIONMAP_CUBIC: boolean;
        USE_LOCAL_REFLECTIONMAP_CUBIC: boolean;
        REFLECTIONMAP_PROJECTION: boolean;
        REFLECTIONMAP_SKYBOX: boolean;
        REFLECTIONMAP_EXPLICIT: boolean;
        REFLECTIONMAP_EQUIRECTANGULAR: boolean;
        REFLECTIONMAP_EQUIRECTANGULAR_FIXED: boolean;
        REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED: boolean;
        INVERTCUBICMAP: boolean;
        USESPHERICALFROMREFLECTIONMAP: boolean;
        USEIRRADIANCEMAP: boolean;
        SPHERICAL_HARMONICS: boolean;
        USESPHERICALINVERTEX: boolean;
        REFLECTIONMAP_OPPOSITEZ: boolean;
        LODINREFLECTIONALPHA: boolean;
        GAMMAREFLECTION: boolean;
        RGBDREFLECTION: boolean;
        LINEARSPECULARREFLECTION: boolean;
        RADIANCEOCCLUSION: boolean;
        HORIZONOCCLUSION: boolean;
        INSTANCES: boolean;
        THIN_INSTANCES: boolean;
        PREPASS: boolean;
        SCENE_MRT_COUNT: number;
        NUM_BONE_INFLUENCERS: number;
        BonesPerMesh: number;
        BONETEXTURE: boolean;
        NONUNIFORMSCALING: boolean;
        MORPHTARGETS: boolean;
        MORPHTARGETS_NORMAL: boolean;
        MORPHTARGETS_TANGENT: boolean;
        MORPHTARGETS_UV: boolean;
        NUM_MORPH_INFLUENCERS: number;
        IMAGEPROCESSING: boolean;
        VIGNETTE: boolean;
        VIGNETTEBLENDMODEMULTIPLY: boolean;
        VIGNETTEBLENDMODEOPAQUE: boolean;
        TONEMAPPING: boolean;
        TONEMAPPING_ACES: boolean;
        CONTRAST: boolean;
        COLORCURVES: boolean;
        COLORGRADING: boolean;
        COLORGRADING3D: boolean;
        SAMPLER3DGREENDEPTH: boolean;
        SAMPLER3DBGRMAP: boolean;
        IMAGEPROCESSINGPOSTPROCESS: boolean;
        EXPOSURE: boolean;
        MULTIVIEW: boolean;
        USEPHYSICALLIGHTFALLOFF: boolean;
        USEGLTFLIGHTFALLOFF: boolean;
        TWOSIDEDLIGHTING: boolean;
        SHADOWFLOAT: boolean;
        CLIPPLANE: boolean;
        CLIPPLANE2: boolean;
        CLIPPLANE3: boolean;
        CLIPPLANE4: boolean;
        CLIPPLANE5: boolean;
        CLIPPLANE6: boolean;
        POINTSIZE: boolean;
        FOG: boolean;
        LOGARITHMICDEPTH: boolean;
        FORCENORMALFORWARD: boolean;
        SPECULARAA: boolean;
        CLEARCOAT: boolean;
        CLEARCOAT_DEFAULTIOR: boolean;
        CLEARCOAT_TEXTURE: boolean;
        CLEARCOAT_TEXTUREDIRECTUV: number;
        CLEARCOAT_BUMP: boolean;
        CLEARCOAT_BUMPDIRECTUV: number;
        CLEARCOAT_TINT: boolean;
        CLEARCOAT_TINT_TEXTURE: boolean;
        CLEARCOAT_TINT_TEXTUREDIRECTUV: number;
        ANISOTROPIC: boolean;
        ANISOTROPIC_TEXTURE: boolean;
        ANISOTROPIC_TEXTUREDIRECTUV: number;
        BRDF_V_HEIGHT_CORRELATED: boolean;
        MS_BRDF_ENERGY_CONSERVATION: boolean;
        SPECULAR_GLOSSINESS_ENERGY_CONSERVATION: boolean;
        SHEEN: boolean;
        SHEEN_TEXTURE: boolean;
        SHEEN_TEXTUREDIRECTUV: number;
        SHEEN_LINKWITHALBEDO: boolean;
        SHEEN_ROUGHNESS: boolean;
        SHEEN_ALBEDOSCALING: boolean;
        SUBSURFACE: boolean;
        SS_REFRACTION: boolean;
        SS_TRANSLUCENCY: boolean;
        SS_SCATTERING: boolean;
        SS_THICKNESSANDMASK_TEXTURE: boolean;
        SS_THICKNESSANDMASK_TEXTUREDIRECTUV: number;
        SS_REFRACTIONMAP_3D: boolean;
        SS_REFRACTIONMAP_OPPOSITEZ: boolean;
        SS_LODINREFRACTIONALPHA: boolean;
        SS_GAMMAREFRACTION: boolean;
        SS_RGBDREFRACTION: boolean;
        SS_LINEARSPECULARREFRACTION: boolean;
        SS_LINKREFRACTIONTOTRANSPARENCY: boolean;
        SS_ALBEDOFORREFRACTIONTINT: boolean;
        SS_MASK_FROM_THICKNESS_TEXTURE: boolean;
        UNLIT: boolean;
        DEBUGMODE: number;
        /**
         * Initializes the PBR Material defines.
         */
        constructor();
        /**
         * Resets the PBR Material defines.
         */
        reset(): void;
    }
    /**
     * The Physically based material base class of BJS.
     *
     * This offers the main features of a standard PBR material.
     * For more information, please refer to the documentation :
     * https://doc.babylonjs.com/how_to/physically_based_rendering
     */
    export abstract class PBRBaseMaterial extends PushMaterial {
        /**
         * PBRMaterialTransparencyMode: No transparency mode, Alpha channel is not use.
         */
        static readonly PBRMATERIAL_OPAQUE: number;
        /**
         * PBRMaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.
         */
        static readonly PBRMATERIAL_ALPHATEST: number;
        /**
         * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
         */
        static readonly PBRMATERIAL_ALPHABLEND: number;
        /**
         * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
         * They are also discarded below the alpha cutoff threshold to improve performances.
         */
        static readonly PBRMATERIAL_ALPHATESTANDBLEND: number;
        /**
         * Defines the default value of how much AO map is occluding the analytical lights
         * (point spot...).
         */
        static DEFAULT_AO_ON_ANALYTICAL_LIGHTS: number;
        /**
         * PBRMaterialLightFalloff Physical: light is falling off following the inverse squared distance law.
         */
        static readonly LIGHTFALLOFF_PHYSICAL: number;
        /**
         * PBRMaterialLightFalloff gltf: light is falling off as described in the gltf moving to PBR document
         * to enhance interoperability with other engines.
         */
        static readonly LIGHTFALLOFF_GLTF: number;
        /**
         * PBRMaterialLightFalloff Standard: light is falling off like in the standard material
         * to enhance interoperability with other materials.
         */
        static readonly LIGHTFALLOFF_STANDARD: number;
        /**
         * Intensity of the direct lights e.g. the four lights available in your scene.
         * This impacts both the direct diffuse and specular highlights.
         */
        protected _directIntensity: number;
        /**
         * Intensity of the emissive part of the material.
         * This helps controlling the emissive effect without modifying the emissive color.
         */
        protected _emissiveIntensity: number;
        /**
         * Intensity of the environment e.g. how much the environment will light the object
         * either through harmonics for rough material or through the refelction for shiny ones.
         */
        protected _environmentIntensity: number;
        /**
         * This is a special control allowing the reduction of the specular highlights coming from the
         * four lights of the scene. Those highlights may not be needed in full environment lighting.
         */
        protected _specularIntensity: number;
        /**
         * This stores the direct, emissive, environment, and specular light intensities into a Vector4.
         */
        private _lightingInfos;
        /**
         * Debug Control allowing disabling the bump map on this material.
         */
        protected _disableBumpMap: boolean;
        /**
         * AKA Diffuse Texture in standard nomenclature.
         */
        protected _albedoTexture: Nullable<BaseTexture>;
        /**
         * AKA Occlusion Texture in other nomenclature.
         */
        protected _ambientTexture: Nullable<BaseTexture>;
        /**
         * AKA Occlusion Texture Intensity in other nomenclature.
         */
        protected _ambientTextureStrength: number;
        /**
         * Defines how much the AO map is occluding the analytical lights (point spot...).
         * 1 means it completely occludes it
         * 0 mean it has no impact
         */
        protected _ambientTextureImpactOnAnalyticalLights: number;
        /**
         * Stores the alpha values in a texture.
         */
        protected _opacityTexture: Nullable<BaseTexture>;
        /**
         * Stores the reflection values in a texture.
         */
        protected _reflectionTexture: Nullable<BaseTexture>;
        /**
         * Stores the emissive values in a texture.
         */
        protected _emissiveTexture: Nullable<BaseTexture>;
        /**
         * AKA Specular texture in other nomenclature.
         */
        protected _reflectivityTexture: Nullable<BaseTexture>;
        /**
         * Used to switch from specular/glossiness to metallic/roughness workflow.
         */
        protected _metallicTexture: Nullable<BaseTexture>;
        /**
         * Specifies the metallic scalar of the metallic/roughness workflow.
         * Can also be used to scale the metalness values of the metallic texture.
         */
        protected _metallic: Nullable<number>;
        /**
         * Specifies the roughness scalar of the metallic/roughness workflow.
         * Can also be used to scale the roughness values of the metallic texture.
         */
        protected _roughness: Nullable<number>;
        /**
         * In metallic workflow, specifies an F0 factor to help configuring the material F0.
         * By default the indexOfrefraction is used to compute F0;
         *
         * This is used as a factor against the default reflectance at normal incidence to tweak it.
         *
         * F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor;
         * F90 = metallicReflectanceColor;
         */
        protected _metallicF0Factor: number;
        /**
         * In metallic workflow, specifies an F90 color to help configuring the material F90.
         * By default the F90 is always 1;
         *
         * Please note that this factor is also used as a factor against the default reflectance at normal incidence.
         *
         * F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor
         * F90 = metallicReflectanceColor;
         */
        protected _metallicReflectanceColor: Color3;
        /**
         * Defines to store metallicReflectanceColor in RGB and metallicF0Factor in A
         * This is multiply against the scalar values defined in the material.
         */
        protected _metallicReflectanceTexture: Nullable<BaseTexture>;
        /**
         * Used to enable roughness/glossiness fetch from a separate channel depending on the current mode.
         * Gray Scale represents roughness in metallic mode and glossiness in specular mode.
         */
        protected _microSurfaceTexture: Nullable<BaseTexture>;
        /**
         * Stores surface normal data used to displace a mesh in a texture.
         */
        protected _bumpTexture: Nullable<BaseTexture>;
        /**
         * Stores the pre-calculated light information of a mesh in a texture.
         */
        protected _lightmapTexture: Nullable<BaseTexture>;
        /**
         * The color of a material in ambient lighting.
         */
        protected _ambientColor: Color3;
        /**
         * AKA Diffuse Color in other nomenclature.
         */
        protected _albedoColor: Color3;
        /**
         * AKA Specular Color in other nomenclature.
         */
        protected _reflectivityColor: Color3;
        /**
         * The color applied when light is reflected from a material.
         */
        protected _reflectionColor: Color3;
        /**
         * The color applied when light is emitted from a material.
         */
        protected _emissiveColor: Color3;
        /**
         * AKA Glossiness in other nomenclature.
         */
        protected _microSurface: number;
        /**
         * Specifies that the material will use the light map as a show map.
         */
        protected _useLightmapAsShadowmap: boolean;
        /**
         * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal
         * makes the reflect vector face the model (under horizon).
         */
        protected _useHorizonOcclusion: boolean;
        /**
         * This parameters will enable/disable radiance occlusion by preventing the radiance to lit
         * too much the area relying on ambient texture to define their ambient occlusion.
         */
        protected _useRadianceOcclusion: boolean;
        /**
         * Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.
         */
        protected _useAlphaFromAlbedoTexture: boolean;
        /**
         * Specifies that the material will keeps the specular highlights over a transparent surface (only the most limunous ones).
         * A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.
         */
        protected _useSpecularOverAlpha: boolean;
        /**
         * Specifies if the reflectivity texture contains the glossiness information in its alpha channel.
         */
        protected _useMicroSurfaceFromReflectivityMapAlpha: boolean;
        /**
         * Specifies if the metallic texture contains the roughness information in its alpha channel.
         */
        protected _useRoughnessFromMetallicTextureAlpha: boolean;
        /**
         * Specifies if the metallic texture contains the roughness information in its green channel.
         */
        protected _useRoughnessFromMetallicTextureGreen: boolean;
        /**
         * Specifies if the metallic texture contains the metallness information in its blue channel.
         */
        protected _useMetallnessFromMetallicTextureBlue: boolean;
        /**
         * Specifies if the metallic texture contains the ambient occlusion information in its red channel.
         */
        protected _useAmbientOcclusionFromMetallicTextureRed: boolean;
        /**
         * Specifies if the ambient texture contains the ambient occlusion information in its red channel only.
         */
        protected _useAmbientInGrayScale: boolean;
        /**
         * In case the reflectivity map does not contain the microsurface information in its alpha channel,
         * The material will try to infer what glossiness each pixel should be.
         */
        protected _useAutoMicroSurfaceFromReflectivityMap: boolean;
        /**
         * Defines the  falloff type used in this material.
         * It by default is Physical.
         */
        protected _lightFalloff: number;
        /**
         * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).
         * A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.
         */
        protected _useRadianceOverAlpha: boolean;
        /**
         * Allows using an object space normal map (instead of tangent space).
         */
        protected _useObjectSpaceNormalMap: boolean;
        /**
         * Allows using the bump map in parallax mode.
         */
        protected _useParallax: boolean;
        /**
         * Allows using the bump map in parallax occlusion mode.
         */
        protected _useParallaxOcclusion: boolean;
        /**
         * Controls the scale bias of the parallax mode.
         */
        protected _parallaxScaleBias: number;
        /**
         * If sets to true, disables all the lights affecting the material.
         */
        protected _disableLighting: boolean;
        /**
         * Number of Simultaneous lights allowed on the material.
         */
        protected _maxSimultaneousLights: number;
        /**
         * If sets to true, x component of normal map value will be inverted (x = 1.0 - x).
         */
        protected _invertNormalMapX: boolean;
        /**
         * If sets to true, y component of normal map value will be inverted (y = 1.0 - y).
         */
        protected _invertNormalMapY: boolean;
        /**
         * If sets to true and backfaceCulling is false, normals will be flipped on the backside.
         */
        protected _twoSidedLighting: boolean;
        /**
         * Defines the alpha limits in alpha test mode.
         */
        protected _alphaCutOff: number;
        /**
         * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.
         */
        protected _forceAlphaTest: boolean;
        /**
         * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
         * And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)
         */
        protected _useAlphaFresnel: boolean;
        /**
         * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
         * And/Or occlude the blended part. (alpha stays linear to compute the fresnel)
         */
        protected _useLinearAlphaFresnel: boolean;
        /**
         * Specifies the environment BRDF texture used to comput the scale and offset roughness values
         * from cos thetav and roughness:
         * http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf
         */
        protected _environmentBRDFTexture: Nullable<BaseTexture>;
        /**
         * Force the shader to compute irradiance in the fragment shader in order to take bump in account.
         */
        protected _forceIrradianceInFragment: boolean;
        private _realTimeFiltering;
        /**
         * Enables realtime filtering on the texture.
         */
        get realTimeFiltering(): boolean;
        set realTimeFiltering(b: boolean);
        private _realTimeFilteringQuality;
        /**
         * Quality switch for realtime filtering
         */
        get realTimeFilteringQuality(): number;
        set realTimeFilteringQuality(n: number);
        /**
         * Can this material render to several textures at once
         */
        get canRenderToMRT(): boolean;
        /**
         * Force normal to face away from face.
         */
        protected _forceNormalForward: boolean;
        /**
         * Enables specular anti aliasing in the PBR shader.
         * It will both interacts on the Geometry for analytical and IBL lighting.
         * It also prefilter the roughness map based on the bump values.
         */
        protected _enableSpecularAntiAliasing: boolean;
        /**
         * Default configuration related to image processing available in the PBR Material.
         */
        protected _imageProcessingConfiguration: ImageProcessingConfiguration;
        /**
         * Keep track of the image processing observer to allow dispose and replace.
         */
        private _imageProcessingObserver;
        /**
         * Attaches a new image processing configuration to the PBR Material.
         * @param configuration
         */
        protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void;
        /**
         * Stores the available render targets.
         */
        private _renderTargets;
        /**
         * Sets the global ambient color for the material used in lighting calculations.
         */
        private _globalAmbientColor;
        /**
         * Enables the use of logarithmic depth buffers, which is good for wide depth buffers.
         */
        private _useLogarithmicDepth;
        /**
         * If set to true, no lighting calculations will be applied.
         */
        private _unlit;
        private _debugMode;
        /**
         * @hidden
         * This is reserved for the inspector.
         * Defines the material debug mode.
         * It helps seeing only some components of the material while troubleshooting.
         */
        debugMode: number;
        /**
         * @hidden
         * This is reserved for the inspector.
         * Specify from where on screen the debug mode should start.
         * The value goes from -1 (full screen) to 1 (not visible)
         * It helps with side by side comparison against the final render
         * This defaults to -1
         */
        private debugLimit;
        /**
         * @hidden
         * This is reserved for the inspector.
         * As the default viewing range might not be enough (if the ambient is really small for instance)
         * You can use the factor to better multiply the final value.
         */
        private debugFactor;
        /**
         * Defines the clear coat layer parameters for the material.
         */
        readonly clearCoat: PBRClearCoatConfiguration;
        /**
         * Defines the anisotropic parameters for the material.
         */
        readonly anisotropy: PBRAnisotropicConfiguration;
        /**
         * Defines the BRDF parameters for the material.
         */
        readonly brdf: PBRBRDFConfiguration;
        /**
         * Defines the Sheen parameters for the material.
         */
        readonly sheen: PBRSheenConfiguration;
        /**
         * Defines the SubSurface parameters for the material.
         */
        readonly subSurface: PBRSubSurfaceConfiguration;
        /**
         * Defines the detail map parameters for the material.
         */
        readonly detailMap: DetailMapConfiguration;
        protected _rebuildInParallel: boolean;
        /**
         * Instantiates a new PBRMaterial instance.
         *
         * @param name The material name
         * @param scene The scene the material will be use in.
         */
        constructor(name: string, scene: Scene);
        /**
         * Gets a boolean indicating that current material needs to register RTT
         */
        get hasRenderTargetTextures(): boolean;
        /**
         * Gets the name of the material class.
         */
        getClassName(): string;
        /**
         * Enabled the use of logarithmic depth buffers, which is good for wide depth buffers.
         */
        get useLogarithmicDepth(): boolean;
        /**
         * Enabled the use of logarithmic depth buffers, which is good for wide depth buffers.
         */
        set useLogarithmicDepth(value: boolean);
        /**
         * Returns true if alpha blending should be disabled.
         */
        protected get _disableAlphaBlending(): boolean;
        /**
         * Specifies whether or not this material should be rendered in alpha blend mode.
         */
        needAlphaBlending(): boolean;
        /**
         * Specifies whether or not this material should be rendered in alpha test mode.
         */
        needAlphaTesting(): boolean;
        /**
         * Specifies whether or not the alpha value of the albedo texture should be used for alpha blending.
         */
        protected _shouldUseAlphaFromAlbedoTexture(): boolean;
        /**
         * Gets the texture used for the alpha test.
         */
        getAlphaTestTexture(): Nullable<BaseTexture>;
        /**
         * Specifies that the submesh is ready to be used.
         * @param mesh - BJS mesh.
         * @param subMesh - A submesh of the BJS mesh.  Used to check if it is ready.
         * @param useInstances - Specifies that instances should be used.
         * @returns - boolean indicating that the submesh is ready or not.
         */
        isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean;
        /**
         * Specifies if the material uses metallic roughness workflow.
         * @returns boolean specifiying if the material uses metallic roughness workflow.
        */
        isMetallicWorkflow(): boolean;
        private _prepareEffect;
        private _prepareDefines;
        /**
         * Force shader compilation
         */
        forceCompilation(mesh: AbstractMesh, onCompiled?: (material: Material) => void, options?: Partial<IMaterialCompilationOptions>): void;
        /**
         * Initializes the uniform buffer layout for the shader.
         */
        buildUniformLayout(): void;
        /**
         * Unbinds the material from the mesh
         */
        unbind(): void;
        /**
         * Binds the submesh data.
         * @param world - The world matrix.
         * @param mesh - The BJS mesh.
         * @param subMesh - A submesh of the BJS mesh.
         */
        bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void;
        /**
         * Returns the animatable textures.
         * @returns - Array of animatable textures.
         */
        getAnimatables(): IAnimatable[];
        /**
         * Returns the texture used for reflections.
         * @returns - Reflection texture if present.  Otherwise, returns the environment texture.
         */
        private _getReflectionTexture;
        /**
         * Returns an array of the actively used textures.
         * @returns - Array of BaseTextures
         */
        getActiveTextures(): BaseTexture[];
        /**
         * Checks to see if a texture is used in the material.
         * @param texture - Base texture to use.
         * @returns - Boolean specifying if a texture is used in the material.
         */
        hasTexture(texture: BaseTexture): boolean;
        /**
         * Sets the required values to the prepass renderer.
         * @param prePassRenderer defines the prepass renderer to setup
         */
        setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean;
        /**
         * Disposes the resources of the material.
         * @param forceDisposeEffect - Forces the disposal of effects.
         * @param forceDisposeTextures - Forces the disposal of all textures.
         */
        dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean): void;
    }
}
declare module BABYLON {
    /**
     * The Physically based material of BJS.
     *
     * This offers the main features of a standard PBR material.
     * For more information, please refer to the documentation :
     * https://doc.babylonjs.com/how_to/physically_based_rendering
     */
    export class PBRMaterial extends PBRBaseMaterial {
        /**
         * PBRMaterialTransparencyMode: No transparency mode, Alpha channel is not use.
         */
        static readonly PBRMATERIAL_OPAQUE: number;
        /**
         * PBRMaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.
         */
        static readonly PBRMATERIAL_ALPHATEST: number;
        /**
         * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
         */
        static readonly PBRMATERIAL_ALPHABLEND: number;
        /**
         * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
         * They are also discarded below the alpha cutoff threshold to improve performances.
         */
        static readonly PBRMATERIAL_ALPHATESTANDBLEND: number;
        /**
         * Defines the default value of how much AO map is occluding the analytical lights
         * (point spot...).
         */
        static DEFAULT_AO_ON_ANALYTICAL_LIGHTS: number;
        /**
         * Intensity of the direct lights e.g. the four lights available in your scene.
         * This impacts both the direct diffuse and specular highlights.
         */
        directIntensity: number;
        /**
         * Intensity of the emissive part of the material.
         * This helps controlling the emissive effect without modifying the emissive color.
         */
        emissiveIntensity: number;
        /**
         * Intensity of the environment e.g. how much the environment will light the object
         * either through harmonics for rough material or through the refelction for shiny ones.
         */
        environmentIntensity: number;
        /**
         * This is a special control allowing the reduction of the specular highlights coming from the
         * four lights of the scene. Those highlights may not be needed in full environment lighting.
         */
        specularIntensity: number;
        /**
         * Debug Control allowing disabling the bump map on this material.
         */
        disableBumpMap: boolean;
        /**
         * AKA Diffuse Texture in standard nomenclature.
         */
        albedoTexture: BaseTexture;
        /**
         * AKA Occlusion Texture in other nomenclature.
         */
        ambientTexture: BaseTexture;
        /**
         * AKA Occlusion Texture Intensity in other nomenclature.
         */
        ambientTextureStrength: number;
        /**
         * Defines how much the AO map is occluding the analytical lights (point spot...).
         * 1 means it completely occludes it
         * 0 mean it has no impact
         */
        ambientTextureImpactOnAnalyticalLights: number;
        /**
         * Stores the alpha values in a texture. Use luminance if texture.getAlphaFromRGB is true.
         */
        opacityTexture: BaseTexture;
        /**
         * Stores the reflection values in a texture.
         */
        reflectionTexture: Nullable<BaseTexture>;
        /**
         * Stores the emissive values in a texture.
         */
        emissiveTexture: BaseTexture;
        /**
         * AKA Specular texture in other nomenclature.
         */
        reflectivityTexture: BaseTexture;
        /**
         * Used to switch from specular/glossiness to metallic/roughness workflow.
         */
        metallicTexture: BaseTexture;
        /**
         * Specifies the metallic scalar of the metallic/roughness workflow.
         * Can also be used to scale the metalness values of the metallic texture.
         */
        metallic: Nullable<number>;
        /**
         * Specifies the roughness scalar of the metallic/roughness workflow.
         * Can also be used to scale the roughness values of the metallic texture.
         */
        roughness: Nullable<number>;
        /**
         * In metallic workflow, specifies an F0 factor to help configuring the material F0.
         * By default the indexOfrefraction is used to compute F0;
         *
         * This is used as a factor against the default reflectance at normal incidence to tweak it.
         *
         * F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor;
         * F90 = metallicReflectanceColor;
         */
        metallicF0Factor: number;
        /**
         * In metallic workflow, specifies an F90 color to help configuring the material F90.
         * By default the F90 is always 1;
         *
         * Please note that this factor is also used as a factor against the default reflectance at normal incidence.
         *
         * F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor
         * F90 = metallicReflectanceColor;
         */
        metallicReflectanceColor: Color3;
        /**
         * Defines to store metallicReflectanceColor in RGB and metallicF0Factor in A
         * This is multiply against the scalar values defined in the material.
         */
        metallicReflectanceTexture: Nullable<BaseTexture>;
        /**
         * Used to enable roughness/glossiness fetch from a separate channel depending on the current mode.
         * Gray Scale represents roughness in metallic mode and glossiness in specular mode.
         */
        microSurfaceTexture: BaseTexture;
        /**
         * Stores surface normal data used to displace a mesh in a texture.
         */
        bumpTexture: BaseTexture;
        /**
         * Stores the pre-calculated light information of a mesh in a texture.
         */
        lightmapTexture: BaseTexture;
        /**
         * Stores the refracted light information in a texture.
         */
        get refractionTexture(): Nullable<BaseTexture>;
        set refractionTexture(value: Nullable<BaseTexture>);
        /**
         * The color of a material in ambient lighting.
         */
        ambientColor: Color3;
        /**
         * AKA Diffuse Color in other nomenclature.
         */
        albedoColor: Color3;
        /**
         * AKA Specular Color in other nomenclature.
         */
        reflectivityColor: Color3;
        /**
         * The color reflected from the material.
         */
        reflectionColor: Color3;
        /**
         * The color emitted from the material.
         */
        emissiveColor: Color3;
        /**
         * AKA Glossiness in other nomenclature.
         */
        microSurface: number;
        /**
         * Index of refraction of the material base layer.
         * https://en.wikipedia.org/wiki/List_of_refractive_indices
         *
         * This does not only impact refraction but also the Base F0 of Dielectric Materials.
         *
         * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))
         */
        get indexOfRefraction(): number;
        set indexOfRefraction(value: number);
        /**
         * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.
         */
        get invertRefractionY(): boolean;
        set invertRefractionY(value: boolean);
        /**
         * This parameters will make the material used its opacity to control how much it is refracting aginst not.
         * Materials half opaque for instance using refraction could benefit from this control.
         */
        get linkRefractionWithTransparency(): boolean;
        set linkRefractionWithTransparency(value: boolean);
        /**
         * If true, the light map contains occlusion information instead of lighting info.
         */
        useLightmapAsShadowmap: boolean;
        /**
         * Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.
         */
        useAlphaFromAlbedoTexture: boolean;
        /**
         * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.
         */
        forceAlphaTest: boolean;
        /**
         * Defines the alpha limits in alpha test mode.
         */
        alphaCutOff: number;
        /**
         * Specifies that the material will keep the specular highlights over a transparent surface (only the most limunous ones).
         * A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.
         */
        useSpecularOverAlpha: boolean;
        /**
         * Specifies if the reflectivity texture contains the glossiness information in its alpha channel.
         */
        useMicroSurfaceFromReflectivityMapAlpha: boolean;
        /**
         * Specifies if the metallic texture contains the roughness information in its alpha channel.
         */
        useRoughnessFromMetallicTextureAlpha: boolean;
        /**
         * Specifies if the metallic texture contains the roughness information in its green channel.
         */
        useRoughnessFromMetallicTextureGreen: boolean;
        /**
         * Specifies if the metallic texture contains the metallness information in its blue channel.
         */
        useMetallnessFromMetallicTextureBlue: boolean;
        /**
         * Specifies if the metallic texture contains the ambient occlusion information in its red channel.
         */
        useAmbientOcclusionFromMetallicTextureRed: boolean;
        /**
         * Specifies if the ambient texture contains the ambient occlusion information in its red channel only.
         */
        useAmbientInGrayScale: boolean;
        /**
         * In case the reflectivity map does not contain the microsurface information in its alpha channel,
         * The material will try to infer what glossiness each pixel should be.
         */
        useAutoMicroSurfaceFromReflectivityMap: boolean;
        /**
         * BJS is using an harcoded light falloff based on a manually sets up range.
         * In PBR, one way to represents the fallof is to use the inverse squared root algorythm.
         * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
         */
        get usePhysicalLightFalloff(): boolean;
        /**
         * BJS is using an harcoded light falloff based on a manually sets up range.
         * In PBR, one way to represents the fallof is to use the inverse squared root algorythm.
         * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
         */
        set usePhysicalLightFalloff(value: boolean);
        /**
         * In order to support the falloff compatibility with gltf, a special mode has been added
         * to reproduce the gltf light falloff.
         */
        get useGLTFLightFalloff(): boolean;
        /**
         * In order to support the falloff compatibility with gltf, a special mode has been added
         * to reproduce the gltf light falloff.
         */
        set useGLTFLightFalloff(value: boolean);
        /**
         * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).
         * A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.
         */
        useRadianceOverAlpha: boolean;
        /**
         * Allows using an object space normal map (instead of tangent space).
         */
        useObjectSpaceNormalMap: boolean;
        /**
         * Allows using the bump map in parallax mode.
         */
        useParallax: boolean;
        /**
         * Allows using the bump map in parallax occlusion mode.
         */
        useParallaxOcclusion: boolean;
        /**
         * Controls the scale bias of the parallax mode.
         */
        parallaxScaleBias: number;
        /**
         * If sets to true, disables all the lights affecting the material.
         */
        disableLighting: boolean;
        /**
         * Force the shader to compute irradiance in the fragment shader in order to take bump in account.
         */
        forceIrradianceInFragment: boolean;
        /**
         * Number of Simultaneous lights allowed on the material.
         */
        maxSimultaneousLights: number;
        /**
         * If sets to true, x component of normal map value will invert (x = 1.0 - x).
         */
        invertNormalMapX: boolean;
        /**
         * If sets to true, y component of normal map value will invert (y = 1.0 - y).
         */
        invertNormalMapY: boolean;
        /**
         * If sets to true and backfaceCulling is false, normals will be flipped on the backside.
         */
        twoSidedLighting: boolean;
        /**
         * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
         * And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)
         */
        useAlphaFresnel: boolean;
        /**
         * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
         * And/Or occlude the blended part. (alpha stays linear to compute the fresnel)
         */
        useLinearAlphaFresnel: boolean;
        /**
         * Let user defines the brdf lookup texture used for IBL.
         * A default 8bit version is embedded but you could point at :
         * * Default texture: https://assets.babylonjs.com/environments/correlatedMSBRDF_RGBD.png
         * * Default 16bit pixel depth texture: https://assets.babylonjs.com/environments/correlatedMSBRDF.dds
         * * LEGACY Default None correlated https://assets.babylonjs.com/environments/uncorrelatedBRDF_RGBD.png
         * * LEGACY Default None correlated 16bit pixel depth https://assets.babylonjs.com/environments/uncorrelatedBRDF.dds
         */
        environmentBRDFTexture: Nullable<BaseTexture>;
        /**
         * Force normal to face away from face.
         */
        forceNormalForward: boolean;
        /**
         * Enables specular anti aliasing in the PBR shader.
         * It will both interacts on the Geometry for analytical and IBL lighting.
         * It also prefilter the roughness map based on the bump values.
         */
        enableSpecularAntiAliasing: boolean;
        /**
         * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal
         * makes the reflect vector face the model (under horizon).
         */
        useHorizonOcclusion: boolean;
        /**
         * This parameters will enable/disable radiance occlusion by preventing the radiance to lit
         * too much the area relying on ambient texture to define their ambient occlusion.
         */
        useRadianceOcclusion: boolean;
        /**
         * If set to true, no lighting calculations will be applied.
         */
        unlit: boolean;
        /**
         * Gets the image processing configuration used either in this material.
         */
        get imageProcessingConfiguration(): ImageProcessingConfiguration;
        /**
         * Sets the Default image processing configuration used either in the this material.
         *
         * If sets to null, the scene one is in use.
         */
        set imageProcessingConfiguration(value: ImageProcessingConfiguration);
        /**
         * Gets wether the color curves effect is enabled.
         */
        get cameraColorCurvesEnabled(): boolean;
        /**
         * Sets wether the color curves effect is enabled.
         */
        set cameraColorCurvesEnabled(value: boolean);
        /**
         * Gets wether the color grading effect is enabled.
         */
        get cameraColorGradingEnabled(): boolean;
        /**
         * Gets wether the color grading effect is enabled.
         */
        set cameraColorGradingEnabled(value: boolean);
        /**
         * Gets wether tonemapping is enabled or not.
         */
        get cameraToneMappingEnabled(): boolean;
        /**
         * Sets wether tonemapping is enabled or not
         */
        set cameraToneMappingEnabled(value: boolean);
        /**
         * The camera exposure used on this material.
         * This property is here and not in the camera to allow controlling exposure without full screen post process.
         * This corresponds to a photographic exposure.
         */
        get cameraExposure(): number;
        /**
         * The camera exposure used on this material.
         * This property is here and not in the camera to allow controlling exposure without full screen post process.
         * This corresponds to a photographic exposure.
         */
        set cameraExposure(value: number);
        /**
         * Gets The camera contrast used on this material.
         */
        get cameraContrast(): number;
        /**
         * Sets The camera contrast used on this material.
         */
        set cameraContrast(value: number);
        /**
         * Gets the Color Grading 2D Lookup Texture.
         */
        get cameraColorGradingTexture(): Nullable<BaseTexture>;
        /**
         * Sets the Color Grading 2D Lookup Texture.
         */
        set cameraColorGradingTexture(value: Nullable<BaseTexture>);
        /**
         * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
         * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
         * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
         * corresponding to low luminance, medium luminance, and high luminance areas respectively.
         */
        get cameraColorCurves(): Nullable<ColorCurves>;
        /**
         * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
         * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
         * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
         * corresponding to low luminance, medium luminance, and high luminance areas respectively.
         */
        set cameraColorCurves(value: Nullable<ColorCurves>);
        /**
         * Instantiates a new PBRMaterial instance.
         *
         * @param name The material name
         * @param scene The scene the material will be use in.
         */
        constructor(name: string, scene: Scene);
        /**
         * Returns the name of this material class.
         */
        getClassName(): string;
        /**
         * Makes a duplicate of the current material.
         * @param name - name to use for the new material.
         */
        clone(name: string): PBRMaterial;
        /**
         * Serializes this PBR Material.
         * @returns - An object with the serialized material.
         */
        serialize(): any;
        /**
         * Parses a PBR Material from a serialized object.
         * @param source - Serialized object.
         * @param scene - BJS scene instance.
         * @param rootUrl - url for the scene object
         * @returns - PBRMaterial
         */
        static Parse(source: any, scene: Scene, rootUrl: string): PBRMaterial;
    }
}
declare module BABYLON {
    /**
     * Direct draw surface info
     * @see https://docs.microsoft.com/en-us/windows/desktop/direct3ddds/dx-graphics-dds-pguide
     */
    export interface DDSInfo {
        /**
         * Width of the texture
         */
        width: number;
        /**
         * Width of the texture
         */
        height: number;
        /**
         * Number of Mipmaps for the texture
         * @see https://en.wikipedia.org/wiki/Mipmap
         */
        mipmapCount: number;
        /**
         * If the textures format is a known fourCC format
         * @see https://www.fourcc.org/
         */
        isFourCC: boolean;
        /**
         * If the texture is an RGB format eg. DXGI_FORMAT_B8G8R8X8_UNORM format
         */
        isRGB: boolean;
        /**
         * If the texture is a lumincance format
         */
        isLuminance: boolean;
        /**
         * If this is a cube texture
         * @see https://docs.microsoft.com/en-us/windows/desktop/direct3ddds/dds-file-layout-for-cubic-environment-maps
         */
        isCube: boolean;
        /**
         * If the texture is a compressed format eg. FOURCC_DXT1
         */
        isCompressed: boolean;
        /**
         * The dxgiFormat of the texture
         * @see https://docs.microsoft.com/en-us/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format
         */
        dxgiFormat: number;
        /**
         * Texture type eg. Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT
         */
        textureType: number;
        /**
         * Sphericle polynomial created for the dds texture
         */
        sphericalPolynomial?: SphericalPolynomial;
    }
    /**
     * Class used to provide DDS decompression tools
     */
    export class DDSTools {
        /**
         * Gets or sets a boolean indicating that LOD info is stored in alpha channel (false by default)
         */
        static StoreLODInAlphaChannel: boolean;
        /**
         * Gets DDS information from an array buffer
         * @param data defines the array buffer view to read data from
         * @returns the DDS information
         */
        static GetDDSInfo(data: ArrayBufferView): DDSInfo;
        private static _FloatView;
        private static _Int32View;
        private static _ToHalfFloat;
        private static _FromHalfFloat;
        private static _GetHalfFloatAsFloatRGBAArrayBuffer;
        private static _GetHalfFloatRGBAArrayBuffer;
        private static _GetFloatRGBAArrayBuffer;
        private static _GetFloatAsUIntRGBAArrayBuffer;
        private static _GetHalfFloatAsUIntRGBAArrayBuffer;
        private static _GetRGBAArrayBuffer;
        private static _ExtractLongWordOrder;
        private static _GetRGBArrayBuffer;
        private static _GetLuminanceArrayBuffer;
        /**
         * Uploads DDS Levels to a Babylon Texture
         * @hidden
         */
        static UploadDDSLevels(engine: ThinEngine, texture: InternalTexture, data: ArrayBufferView, info: DDSInfo, loadMipmaps: boolean, faces: number, lodIndex?: number, currentFace?: number): void;
    }
        interface ThinEngine {
            /**
             * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)
             * @param rootUrl defines the url where the file to load is located
             * @param scene defines the current scene
             * @param lodScale defines scale to apply to the mip map selection
             * @param lodOffset defines offset to apply to the mip map selection
             * @param onLoad defines an optional callback raised when the texture is loaded
             * @param onError defines an optional callback raised if there is an issue to load the texture
             * @param format defines the format of the data
             * @param forcedExtension defines the extension to use to pick the right loader
             * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture
             * @returns the cube texture as an InternalTexture
             */
            createPrefilteredCubeTexture(rootUrl: string, scene: Nullable<Scene>, lodScale: number, lodOffset: number, onLoad?: Nullable<(internalTexture: Nullable<InternalTexture>) => void>, onError?: Nullable<(message?: string, exception?: any) => void>, format?: number, forcedExtension?: any, createPolynomials?: boolean): InternalTexture;
        }
}
declare module BABYLON {
    /**
     * Implementation of the DDS Texture Loader.
     * @hidden
     */
    export class _DDSTextureLoader implements IInternalTextureLoader {
        /**
         * Defines wether the loader supports cascade loading the different faces.
         */
        readonly supportCascades: boolean;
        /**
         * This returns if the loader support the current file information.
         * @param extension defines the file extension of the file being loaded
         * @returns true if the loader can load the specified file
         */
        canLoad(extension: string): boolean;
        /**
         * Uploads the cube texture data to the WebGL texture. It has already been bound.
         * @param data contains the texture data
         * @param texture defines the BabylonJS internal texture
         * @param createPolynomials will be true if polynomials have been requested
         * @param onLoad defines the callback to trigger once the texture is ready
         * @param onError defines the callback to trigger in case of error
         */
        loadCubeData(imgs: ArrayBufferView | ArrayBufferView[], texture: InternalTexture, createPolynomials: boolean, onLoad: Nullable<(data?: any) => void>, onError: Nullable<(message?: string, exception?: any) => void>): void;
        /**
         * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.
         * @param data contains the texture data
         * @param texture defines the BabylonJS internal texture
         * @param callback defines the method to call once ready to upload
         */
        loadData(data: ArrayBufferView, texture: InternalTexture, callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void) => void): void;
    }
}
declare module BABYLON {
    /**
     * Implementation of the ENV Texture Loader.
     * @hidden
     */
    export class _ENVTextureLoader implements IInternalTextureLoader {
        /**
         * Defines wether the loader supports cascade loading the different faces.
         */
        readonly supportCascades: boolean;
        /**
         * This returns if the loader support the current file information.
         * @param extension defines the file extension of the file being loaded
         * @returns true if the loader can load the specified file
         */
        canLoad(extension: string): boolean;
        /**
         * Uploads the cube texture data to the WebGL texture. It has already been bound.
         * @param data contains the texture data
         * @param texture defines the BabylonJS internal texture
         * @param createPolynomials will be true if polynomials have been requested
         * @param onLoad defines the callback to trigger once the texture is ready
         * @param onError defines the callback to trigger in case of error
         */
        loadCubeData(data: ArrayBufferView | ArrayBufferView[], texture: InternalTexture, createPolynomials: boolean, onLoad: Nullable<(data?: any) => void>, onError: Nullable<(message?: string, exception?: any) => void>): void;
        /**
         * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.
         * @param data contains the texture data
         * @param texture defines the BabylonJS internal texture
         * @param callback defines the method to call once ready to upload
         */
        loadData(data: ArrayBufferView, texture: InternalTexture, callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void) => void): void;
    }
}
declare module BABYLON {
    /**
     * for description see https://www.khronos.org/opengles/sdk/tools/KTX/
     * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
     */
    export class KhronosTextureContainer {
        /** contents of the KTX container file */
        data: ArrayBufferView;
        private static HEADER_LEN;
        private static COMPRESSED_2D;
        private static COMPRESSED_3D;
        private static TEX_2D;
        private static TEX_3D;
        /**
         * Gets the openGL type
         */
        glType: number;
        /**
         * Gets the openGL type size
         */
        glTypeSize: number;
        /**
         * Gets the openGL format
         */
        glFormat: number;
        /**
         * Gets the openGL internal format
         */
        glInternalFormat: number;
        /**
         * Gets the base internal format
         */
        glBaseInternalFormat: number;
        /**
         * Gets image width in pixel
         */
        pixelWidth: number;
        /**
         * Gets image height in pixel
         */
        pixelHeight: number;
        /**
         * Gets image depth in pixels
         */
        pixelDepth: number;
        /**
         * Gets the number of array elements
         */
        numberOfArrayElements: number;
        /**
         * Gets the number of faces
         */
        numberOfFaces: number;
        /**
         * Gets the number of mipmap levels
         */
        numberOfMipmapLevels: number;
        /**
         * Gets the bytes of key value data
         */
        bytesOfKeyValueData: number;
        /**
         * Gets the load type
         */
        loadType: number;
        /**
         * If the container has been made invalid (eg. constructor failed to correctly load array buffer)
         */
        isInvalid: boolean;
        /**
         * Creates a new KhronosTextureContainer
         * @param data contents of the KTX container file
         * @param facesExpected should be either 1 or 6, based whether a cube texture or or
         * @param threeDExpected provision for indicating that data should be a 3D texture, not implemented
         * @param textureArrayExpected provision for indicating that data should be a texture array, not implemented
         */
        constructor(
        /** contents of the KTX container file */
        data: ArrayBufferView, facesExpected: number, threeDExpected?: boolean, textureArrayExpected?: boolean);
        /**
         * Uploads KTX content to a Babylon Texture.
         * It is assumed that the texture has already been created & is currently bound
         * @hidden
         */
        uploadLevels(texture: InternalTexture, loadMipmaps: boolean): void;
        private _upload2DCompressedLevels;
        /**
         * Checks if the given data starts with a KTX file identifier.
         * @param data the data to check
         * @returns true if the data is a KTX file or false otherwise
         */
        static IsValid(data: ArrayBufferView): boolean;
    }
}
declare module BABYLON {
    /**
     * Helper class to push actions to a pool of workers.
     */
    export class WorkerPool implements IDisposable {
        private _workerInfos;
        private _pendingActions;
        /**
         * Constructor
         * @param workers Array of workers to use for actions
         */
        constructor(workers: Array<Worker>);
        /**
         * Terminates all workers and clears any pending actions.
         */
        dispose(): void;
        /**
         * Pushes an action to the worker pool. If all the workers are active, the action will be
         * pended until a worker has completed its action.
         * @param action The action to perform. Call onComplete when the action is complete.
         */
        push(action: (worker: Worker, onComplete: () => void) => void): void;
        private _execute;
    }
}
declare module BABYLON {
    /**
     * Class for loading KTX2 files
     * @hidden
     */
    export class KhronosTextureContainer2 {
        private static _WorkerPoolPromise?;
        private static _Initialized;
        private static _Ktx2Decoder;
        /**
         * URL to use when loading the KTX2 decoder module
         */
        static JSModuleURL: string;
        /**
         * Default number of workers used to handle data decoding
         */
        static DefaultNumWorkers: number;
        private static GetDefaultNumWorkers;
        private _engine;
        private static _CreateWorkerPool;
        /**
         * Constructor
         * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.
         */
        constructor(engine: ThinEngine, numWorkers?: number);
        uploadAsync(data: ArrayBufferView, internalTexture: InternalTexture): Promise<void>;
        /**
         * Stop all async operations and release resources.
         */
        dispose(): void;
        protected _createTexture(data: any, internalTexture: InternalTexture): void;
        /**
         * Checks if the given data starts with a KTX2 file identifier.
         * @param data the data to check
         * @returns true if the data is a KTX2 file or false otherwise
         */
        static IsValid(data: ArrayBufferView): boolean;
    }
    export function workerFunc(): void;
}
declare module BABYLON {
    /**
     * Implementation of the KTX Texture Loader.
     * @hidden
     */
    export class _KTXTextureLoader implements IInternalTextureLoader {
        /**
         * Defines wether the loader supports cascade loading the different faces.
         */
        readonly supportCascades: boolean;
        /**
         * This returns if the loader support the current file information.
         * @param extension defines the file extension of the file being loaded
         * @param mimeType defines the optional mime type of the file being loaded
         * @returns true if the loader can load the specified file
         */
        canLoad(extension: string, mimeType?: string): boolean;
        /**
         * Uploads the cube texture data to the WebGL texture. It has already been bound.
         * @param data contains the texture data
         * @param texture defines the BabylonJS internal texture
         * @param createPolynomials will be true if polynomials have been requested
         * @param onLoad defines the callback to trigger once the texture is ready
         * @param onError defines the callback to trigger in case of error
         */
        loadCubeData(data: ArrayBufferView | ArrayBufferView[], texture: InternalTexture, createPolynomials: boolean, onLoad: Nullable<(data?: any) => void>, onError: Nullable<(message?: string, exception?: any) => void>): void;
        /**
         * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.
         * @param data contains the texture data
         * @param texture defines the BabylonJS internal texture
         * @param callback defines the method to call once ready to upload
         */
        loadData(data: ArrayBufferView, texture: InternalTexture, callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void, loadFailed: boolean) => void): void;
    }
}
declare module BABYLON {
    /** @hidden */
    export var _forceSceneHelpersToBundle: boolean;
        interface Scene {
            /**
             * Creates a default light for the scene.
             * @see https://doc.babylonjs.com/How_To/Fast_Build#create-default-light
             * @param replace has the default false, when true replaces the existing lights in the scene with a hemispheric light
             */
            createDefaultLight(replace?: boolean): void;
            /**
             * Creates a default camera for the scene.
             * @see https://doc.babylonjs.com/How_To/Fast_Build#create-default-camera
             * @param createArcRotateCamera has the default false which creates a free camera, when true creates an arc rotate camera
             * @param replace has default false, when true replaces the active camera in the scene
             * @param attachCameraControls has default false, when true attaches camera controls to the canvas.
             */
            createDefaultCamera(createArcRotateCamera?: boolean, replace?: boolean, attachCameraControls?: boolean): void;
            /**
             * Creates a default camera and a default light.
             * @see https://doc.babylonjs.com/how_to/Fast_Build#create-default-camera-or-light
             * @param createArcRotateCamera has the default false which creates a free camera, when true creates an arc rotate camera
             * @param replace has the default false, when true replaces the active camera/light in the scene
             * @param attachCameraControls has the default false, when true attaches camera controls to the canvas.
             */
            createDefaultCameraOrLight(createArcRotateCamera?: boolean, replace?: boolean, attachCameraControls?: boolean): void;
            /**
             * Creates a new sky box
             * @see https://doc.babylonjs.com/how_to/Fast_Build#create-default-skybox
             * @param environmentTexture defines the texture to use as environment texture
             * @param pbr has default false which requires the StandardMaterial to be used, when true PBRMaterial must be used
             * @param scale defines the overall scale of the skybox
             * @param blur is only available when pbr is true, default is 0, no blur, maximum value is 1
             * @param setGlobalEnvTexture has default true indicating that scene.environmentTexture must match the current skybox texture
             * @returns a new mesh holding the sky box
             */
            createDefaultSkybox(environmentTexture?: BaseTexture, pbr?: boolean, scale?: number, blur?: number, setGlobalEnvTexture?: boolean): Nullable<Mesh>;
            /**
             * Creates a new environment
             * @see https://doc.babylonjs.com/How_To/Fast_Build#create-default-environment
             * @param options defines the options you can use to configure the environment
             * @returns the new EnvironmentHelper
             */
            createDefaultEnvironment(options?: Partial<IEnvironmentHelperOptions>): Nullable<EnvironmentHelper>;
            /**
             * Creates a new VREXperienceHelper
             * @see https://doc.babylonjs.com/how_to/webvr_helper
             * @param webVROptions defines the options used to create the new VREXperienceHelper
             * @returns a new VREXperienceHelper
             */
            createDefaultVRExperience(webVROptions?: VRExperienceHelperOptions): VRExperienceHelper;
            /**
             * Creates a new WebXRDefaultExperience
             * @see https://doc.babylonjs.com/how_to/introduction_to_webxr
             * @param options experience options
             * @returns a promise for a new WebXRDefaultExperience
             */
            createDefaultXRExperienceAsync(options: WebXRDefaultExperienceOptions): Promise<WebXRDefaultExperience>;
        }
}
declare module BABYLON {
    /**
     * Display a 360/180 degree video on an approximately spherical surface, useful for VR applications or skyboxes.
     * As a subclass of TransformNode, this allow parenting to the camera or multiple videos with different locations in the scene.
     * This class achieves its effect with a VideoTexture and a correctly configured BackgroundMaterial on an inverted sphere.
     * Potential additions to this helper include zoom and and non-infinite distance rendering effects.
     */
    export class VideoDome extends TextureDome<VideoTexture> {
        /**
         * Define the video source as a Monoscopic panoramic 360 video.
         */
        static readonly MODE_MONOSCOPIC: number;
        /**
         * Define the video source as a Stereoscopic TopBottom/OverUnder panoramic 360 video.
         */
        static readonly MODE_TOPBOTTOM: number;
        /**
         * Define the video source as a Stereoscopic Side by Side panoramic 360 video.
         */
        static readonly MODE_SIDEBYSIDE: number;
        /**
         * Get the video texture associated with this video dome
         */
        get videoTexture(): VideoTexture;
        /**
         * Get the video mode of this dome
         */
        get videoMode(): number;
        /**
         * Set the video mode of this dome.
         * @see textureMode
         */
        set videoMode(value: number);
        protected _initTexture(urlsOrElement: string | string[] | HTMLVideoElement, scene: Scene, options: any): VideoTexture;
    }
}
declare module BABYLON {
    /**
     * This class can be used to get instrumentation data from a Babylon engine
     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#engineinstrumentation
     */
    export class EngineInstrumentation implements IDisposable {
        /**
         * Define the instrumented engine.
         */
        engine: Engine;
        private _captureGPUFrameTime;
        private _gpuFrameTimeToken;
        private _gpuFrameTime;
        private _captureShaderCompilationTime;
        private _shaderCompilationTime;
        private _onBeginFrameObserver;
        private _onEndFrameObserver;
        private _onBeforeShaderCompilationObserver;
        private _onAfterShaderCompilationObserver;
        /**
         * Gets the perf counter used for GPU frame time
         */
        get gpuFrameTimeCounter(): PerfCounter;
        /**
         * Gets the GPU frame time capture status
         */
        get captureGPUFrameTime(): boolean;
        /**
         * Enable or disable the GPU frame time capture
         */
        set captureGPUFrameTime(value: boolean);
        /**
         * Gets the perf counter used for shader compilation time
         */
        get shaderCompilationTimeCounter(): PerfCounter;
        /**
         * Gets the shader compilation time capture status
         */
        get captureShaderCompilationTime(): boolean;
        /**
         * Enable or disable the shader compilation time capture
         */
        set captureShaderCompilationTime(value: boolean);
        /**
         * Instantiates a new engine instrumentation.
         * This class can be used to get instrumentation data from a Babylon engine
         * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#engineinstrumentation
         * @param engine Defines the engine to instrument
         */
        constructor(
        /**
         * Define the instrumented engine.
         */
        engine: Engine);
        /**
         * Dispose and release associated resources.
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * This class can be used to get instrumentation data from a Babylon engine
     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#sceneinstrumentation
     */
    export class SceneInstrumentation implements IDisposable {
        /**
         * Defines the scene to instrument
         */
        scene: Scene;
        private _captureActiveMeshesEvaluationTime;
        private _activeMeshesEvaluationTime;
        private _captureRenderTargetsRenderTime;
        private _renderTargetsRenderTime;
        private _captureFrameTime;
        private _frameTime;
        private _captureRenderTime;
        private _renderTime;
        private _captureInterFrameTime;
        private _interFrameTime;
        private _captureParticlesRenderTime;
        private _particlesRenderTime;
        private _captureSpritesRenderTime;
        private _spritesRenderTime;
        private _capturePhysicsTime;
        private _physicsTime;
        private _captureAnimationsTime;
        private _animationsTime;
        private _captureCameraRenderTime;
        private _cameraRenderTime;
        private _onBeforeActiveMeshesEvaluationObserver;
        private _onAfterActiveMeshesEvaluationObserver;
        private _onBeforeRenderTargetsRenderObserver;
        private _onAfterRenderTargetsRenderObserver;
        private _onAfterRenderObserver;
        private _onBeforeDrawPhaseObserver;
        private _onAfterDrawPhaseObserver;
        private _onBeforeAnimationsObserver;
        private _onBeforeParticlesRenderingObserver;
        private _onAfterParticlesRenderingObserver;
        private _onBeforeSpritesRenderingObserver;
        private _onAfterSpritesRenderingObserver;
        private _onBeforePhysicsObserver;
        private _onAfterPhysicsObserver;
        private _onAfterAnimationsObserver;
        private _onBeforeCameraRenderObserver;
        private _onAfterCameraRenderObserver;
        /**
         * Gets the perf counter used for active meshes evaluation time
         */
        get activeMeshesEvaluationTimeCounter(): PerfCounter;
        /**
         * Gets the active meshes evaluation time capture status
         */
        get captureActiveMeshesEvaluationTime(): boolean;
        /**
         * Enable or disable the active meshes evaluation time capture
         */
        set captureActiveMeshesEvaluationTime(value: boolean);
        /**
         * Gets the perf counter used for render targets render time
         */
        get renderTargetsRenderTimeCounter(): PerfCounter;
        /**
         * Gets the render targets render time capture status
         */
        get captureRenderTargetsRenderTime(): boolean;
        /**
         * Enable or disable the render targets render time capture
         */
        set captureRenderTargetsRenderTime(value: boolean);
        /**
         * Gets the perf counter used for particles render time
         */
        get particlesRenderTimeCounter(): PerfCounter;
        /**
         * Gets the particles render time capture status
         */
        get captureParticlesRenderTime(): boolean;
        /**
         * Enable or disable the particles render time capture
         */
        set captureParticlesRenderTime(value: boolean);
        /**
         * Gets the perf counter used for sprites render time
         */
        get spritesRenderTimeCounter(): PerfCounter;
        /**
         * Gets the sprites render time capture status
         */
        get captureSpritesRenderTime(): boolean;
        /**
         * Enable or disable the sprites render time capture
         */
        set captureSpritesRenderTime(value: boolean);
        /**
         * Gets the perf counter used for physics time
         */
        get physicsTimeCounter(): PerfCounter;
        /**
         * Gets the physics time capture status
         */
        get capturePhysicsTime(): boolean;
        /**
         * Enable or disable the physics time capture
         */
        set capturePhysicsTime(value: boolean);
        /**
         * Gets the perf counter used for animations time
         */
        get animationsTimeCounter(): PerfCounter;
        /**
         * Gets the animations time capture status
         */
        get captureAnimationsTime(): boolean;
        /**
         * Enable or disable the animations time capture
         */
        set captureAnimationsTime(value: boolean);
        /**
         * Gets the perf counter used for frame time capture
         */
        get frameTimeCounter(): PerfCounter;
        /**
         * Gets the frame time capture status
         */
        get captureFrameTime(): boolean;
        /**
         * Enable or disable the frame time capture
         */
        set captureFrameTime(value: boolean);
        /**
         * Gets the perf counter used for inter-frames time capture
         */
        get interFrameTimeCounter(): PerfCounter;
        /**
         * Gets the inter-frames time capture status
         */
        get captureInterFrameTime(): boolean;
        /**
         * Enable or disable the inter-frames time capture
         */
        set captureInterFrameTime(value: boolean);
        /**
         * Gets the perf counter used for render time capture
         */
        get renderTimeCounter(): PerfCounter;
        /**
         * Gets the render time capture status
         */
        get captureRenderTime(): boolean;
        /**
         * Enable or disable the render time capture
         */
        set captureRenderTime(value: boolean);
        /**
         * Gets the perf counter used for camera render time capture
         */
        get cameraRenderTimeCounter(): PerfCounter;
        /**
         * Gets the camera render time capture status
         */
        get captureCameraRenderTime(): boolean;
        /**
         * Enable or disable the camera render time capture
         */
        set captureCameraRenderTime(value: boolean);
        /**
         * Gets the perf counter used for draw calls
         */
        get drawCallsCounter(): PerfCounter;
        /**
         * Instantiates a new scene instrumentation.
         * This class can be used to get instrumentation data from a Babylon engine
         * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#sceneinstrumentation
         * @param scene Defines the scene to instrument
         */
        constructor(
        /**
         * Defines the scene to instrument
         */
        scene: Scene);
        /**
         * Dispose and release associated resources.
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /** @hidden */
    export var glowMapGenerationPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var glowMapGenerationVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Effect layer options. This helps customizing the behaviour
     * of the effect layer.
     */
    export interface IEffectLayerOptions {
        /**
         * Multiplication factor apply to the canvas size to compute the render target size
         * used to generated the objects (the smaller the faster).
         */
        mainTextureRatio: number;
        /**
         * Enforces a fixed size texture to ensure effect stability across devices.
         */
        mainTextureFixedSize?: number;
        /**
         * Alpha blending mode used to apply the blur. Default depends of the implementation.
         */
        alphaBlendingMode: number;
        /**
         * The camera attached to the layer.
         */
        camera: Nullable<Camera>;
        /**
         * The rendering group to draw the layer in.
         */
        renderingGroupId: number;
    }
    /**
     * The effect layer Helps adding post process effect blended with the main pass.
     *
     * This can be for instance use to generate glow or higlight effects on the scene.
     *
     * The effect layer class can not be used directly and is intented to inherited from to be
     * customized per effects.
     */
    export abstract class EffectLayer {
        private _vertexBuffers;
        private _indexBuffer;
        private _cachedDefines;
        private _effectLayerMapGenerationEffect;
        private _effectLayerOptions;
        private _mergeEffect;
        protected _scene: Scene;
        protected _engine: Engine;
        protected _maxSize: number;
        protected _mainTextureDesiredSize: ISize;
        protected _mainTexture: RenderTargetTexture;
        protected _shouldRender: boolean;
        protected _postProcesses: PostProcess[];
        protected _textures: BaseTexture[];
        protected _emissiveTextureAndColor: {
            texture: Nullable<BaseTexture>;
            color: Color4;
        };
        /**
         * The name of the layer
         */
        name: string;
        /**
         * The clear color of the texture used to generate the glow map.
         */
        neutralColor: Color4;
        /**
         * Specifies whether the highlight layer is enabled or not.
         */
        isEnabled: boolean;
        /**
         * Gets the camera attached to the layer.
         */
        get camera(): Nullable<Camera>;
        /**
         * Gets the rendering group id the layer should render in.
         */
        get renderingGroupId(): number;
        set renderingGroupId(renderingGroupId: number);
        /**
         * An event triggered when the effect layer has been disposed.
         */
        onDisposeObservable: Observable<EffectLayer>;
        /**
         * An event triggered when the effect layer is about rendering the main texture with the glowy parts.
         */
        onBeforeRenderMainTextureObservable: Observable<EffectLayer>;
        /**
         * An event triggered when the generated texture is being merged in the scene.
         */
        onBeforeComposeObservable: Observable<EffectLayer>;
        /**
         * An event triggered when the mesh is rendered into the effect render target.
         */
        onBeforeRenderMeshToEffect: Observable<AbstractMesh>;
        /**
         * An event triggered after the mesh has been rendered into the effect render target.
         */
        onAfterRenderMeshToEffect: Observable<AbstractMesh>;
        /**
         * An event triggered when the generated texture has been merged in the scene.
         */
        onAfterComposeObservable: Observable<EffectLayer>;
        /**
         * An event triggered when the efffect layer changes its size.
         */
        onSizeChangedObservable: Observable<EffectLayer>;
        /** @hidden */
        static _SceneComponentInitialization: (scene: Scene) => void;
        /**
         * Instantiates a new effect Layer and references it in the scene.
         * @param name The name of the layer
         * @param scene The scene to use the layer in
         */
        constructor(
        /** The Friendly of the effect in the scene */
        name: string, scene: Scene);
        /**
         * Get the effect name of the layer.
         * @return The effect name
         */
        abstract getEffectName(): string;
        /**
         * Checks for the readiness of the element composing the layer.
         * @param subMesh the mesh to check for
         * @param useInstances specify whether or not to use instances to render the mesh
         * @return true if ready otherwise, false
         */
        abstract isReady(subMesh: SubMesh, useInstances: boolean): boolean;
        /**
         * Returns whether or nood the layer needs stencil enabled during the mesh rendering.
         * @returns true if the effect requires stencil during the main canvas render pass.
         */
        abstract needStencil(): boolean;
        /**
         * Create the merge effect. This is the shader use to blit the information back
         * to the main canvas at the end of the scene rendering.
         * @returns The effect containing the shader used to merge the effect on the  main canvas
         */
        protected abstract _createMergeEffect(): Effect;
        /**
         * Creates the render target textures and post processes used in the effect layer.
         */
        protected abstract _createTextureAndPostProcesses(): void;
        /**
         * Implementation specific of rendering the generating effect on the main canvas.
         * @param effect The effect used to render through
         */
        protected abstract _internalRender(effect: Effect): void;
        /**
         * Sets the required values for both the emissive texture and and the main color.
         */
        protected abstract _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void;
        /**
         * Free any resources and references associated to a mesh.
         * Internal use
         * @param mesh The mesh to free.
         */
        abstract _disposeMesh(mesh: Mesh): void;
        /**
         * Serializes this layer (Glow or Highlight for example)
         * @returns a serialized layer object
         */
        abstract serialize?(): any;
        /**
         * Initializes the effect layer with the required options.
         * @param options Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)
         */
        protected _init(options: Partial<IEffectLayerOptions>): void;
        /**
         * Generates the index buffer of the full screen quad blending to the main canvas.
         */
        private _generateIndexBuffer;
        /**
         * Generates the vertex buffer of the full screen quad blending to the main canvas.
         */
        private _generateVertexBuffer;
        /**
         * Sets the main texture desired size which is the closest power of two
         * of the engine canvas size.
         */
        private _setMainTextureSize;
        /**
         * Creates the main texture for the effect layer.
         */
        protected _createMainTexture(): void;
        /**
         * Adds specific effects defines.
         * @param defines The defines to add specifics to.
         */
        protected _addCustomEffectDefines(defines: string[]): void;
        /**
         * Checks for the readiness of the element composing the layer.
         * @param subMesh the mesh to check for
         * @param useInstances specify whether or not to use instances to render the mesh
         * @param emissiveTexture the associated emissive texture used to generate the glow
         * @return true if ready otherwise, false
         */
        protected _isReady(subMesh: SubMesh, useInstances: boolean, emissiveTexture: Nullable<BaseTexture>): boolean;
        /**
         * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.
         */
        render(): void;
        /**
         * Determine if a given mesh will be used in the current effect.
         * @param mesh mesh to test
         * @returns true if the mesh will be used
         */
        hasMesh(mesh: AbstractMesh): boolean;
        /**
         * Returns true if the layer contains information to display, otherwise false.
         * @returns true if the glow layer should be rendered
         */
        shouldRender(): boolean;
        /**
         * Returns true if the mesh should render, otherwise false.
         * @param mesh The mesh to render
         * @returns true if it should render otherwise false
         */
        protected _shouldRenderMesh(mesh: AbstractMesh): boolean;
        /**
         * Returns true if the mesh can be rendered, otherwise false.
         * @param mesh The mesh to render
         * @param material The material used on the mesh
         * @returns true if it can be rendered otherwise false
         */
        protected _canRenderMesh(mesh: AbstractMesh, material: Material): boolean;
        /**
         * Returns true if the mesh should render, otherwise false.
         * @param mesh The mesh to render
         * @returns true if it should render otherwise false
         */
        protected _shouldRenderEmissiveTextureForMesh(): boolean;
        /**
         * Renders the submesh passed in parameter to the generation map.
         */
        protected _renderSubMesh(subMesh: SubMesh, enableAlphaMode?: boolean): void;
        /**
         * Defines whether the current material of the mesh should be use to render the effect.
         * @param mesh defines the current mesh to render
         */
        protected _useMeshMaterial(mesh: AbstractMesh): boolean;
        /**
         * Rebuild the required buffers.
         * @hidden Internal use only.
         */
        _rebuild(): void;
        /**
         * Dispose only the render target textures and post process.
         */
        private _disposeTextureAndPostProcesses;
        /**
         * Dispose the highlight layer and free resources.
         */
        dispose(): void;
        /**
          * Gets the class name of the effect layer
          * @returns the string with the class name of the effect layer
          */
        getClassName(): string;
        /**
         * Creates an effect layer from parsed effect layer data
         * @param parsedEffectLayer defines effect layer data
         * @param scene defines the current scene
         * @param rootUrl defines the root URL containing the effect layer information
         * @returns a parsed effect Layer
         */
        static Parse(parsedEffectLayer: any, scene: Scene, rootUrl: string): EffectLayer;
    }
}
declare module BABYLON {
        interface AbstractScene {
            /**
             * The list of effect layers (highlights/glow) added to the scene
             * @see https://doc.babylonjs.com/how_to/highlight_layer
             * @see https://doc.babylonjs.com/how_to/glow_layer
             */
            effectLayers: Array<EffectLayer>;
            /**
             * Removes the given effect layer from this scene.
             * @param toRemove defines the effect layer to remove
             * @returns the index of the removed effect layer
             */
            removeEffectLayer(toRemove: EffectLayer): number;
            /**
             * Adds the given effect layer to this scene
             * @param newEffectLayer defines the effect layer to add
             */
            addEffectLayer(newEffectLayer: EffectLayer): void;
        }
    /**
     * Defines the layer scene component responsible to manage any effect layers
     * in a given scene.
     */
    export class EffectLayerSceneComponent implements ISceneSerializableComponent {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        readonly name: string;
        /**
         * The scene the component belongs to.
         */
        scene: Scene;
        private _engine;
        private _renderEffects;
        private _needStencil;
        private _previousStencilState;
        /**
         * Creates a new instance of the component for the given scene
         * @param scene Defines the scene to register the component in
         */
        constructor(scene: Scene);
        /**
         * Registers the component in a given scene
         */
        register(): void;
        /**
         * Rebuilds the elements related to this component in case of
         * context lost for instance.
         */
        rebuild(): void;
        /**
         * Serializes the component data to the specified json object
         * @param serializationObject The object to serialize to
         */
        serialize(serializationObject: any): void;
        /**
         * Adds all the elements from the container to the scene
         * @param container the container holding the elements
         */
        addFromContainer(container: AbstractScene): void;
        /**
         * Removes all the elements in the container from the scene
         * @param container contains the elements to remove
         * @param dispose if the removed element should be disposed (default: false)
         */
        removeFromContainer(container: AbstractScene, dispose?: boolean): void;
        /**
         * Disposes the component and the associated ressources.
         */
        dispose(): void;
        private _isReadyForMesh;
        private _renderMainTexture;
        private _setStencil;
        private _setStencilBack;
        private _draw;
        private _drawCamera;
        private _drawRenderingGroup;
    }
}
declare module BABYLON {
    /** @hidden */
    export var glowMapMergePixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var glowMapMergeVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
        interface AbstractScene {
            /**
             * Return a the first highlight layer of the scene with a given name.
             * @param name The name of the highlight layer to look for.
             * @return The highlight layer if found otherwise null.
             */
            getGlowLayerByName(name: string): Nullable<GlowLayer>;
        }
    /**
     * Glow layer options. This helps customizing the behaviour
     * of the glow layer.
     */
    export interface IGlowLayerOptions {
        /**
         * Multiplication factor apply to the canvas size to compute the render target size
         * used to generated the glowing objects (the smaller the faster).
         */
        mainTextureRatio: number;
        /**
         * Enforces a fixed size texture to ensure resize independant blur.
         */
        mainTextureFixedSize?: number;
        /**
         * How big is the kernel of the blur texture.
         */
        blurKernelSize: number;
        /**
         * The camera attached to the layer.
         */
        camera: Nullable<Camera>;
        /**
         * Enable MSAA by chosing the number of samples.
         */
        mainTextureSamples?: number;
        /**
         * The rendering group to draw the layer in.
         */
        renderingGroupId: number;
    }
    /**
     * The glow layer Helps adding a glow effect around the emissive parts of a mesh.
     *
     * Once instantiated in a scene, by default, all the emissive meshes will glow.
     *
     * Documentation: https://doc.babylonjs.com/how_to/glow_layer
     */
    export class GlowLayer extends EffectLayer {
        /**
         * Effect Name of the layer.
         */
        static readonly EffectName: string;
        /**
         * The default blur kernel size used for the glow.
         */
        static DefaultBlurKernelSize: number;
        /**
         * The default texture size ratio used for the glow.
         */
        static DefaultTextureRatio: number;
        /**
         * Sets the kernel size of the blur.
         */
        set blurKernelSize(value: number);
        /**
         * Gets the kernel size of the blur.
         */
        get blurKernelSize(): number;
        /**
         * Sets the glow intensity.
         */
        set intensity(value: number);
        /**
         * Gets the glow intensity.
         */
        get intensity(): number;
        private _options;
        private _intensity;
        private _horizontalBlurPostprocess1;
        private _verticalBlurPostprocess1;
        private _horizontalBlurPostprocess2;
        private _verticalBlurPostprocess2;
        private _blurTexture1;
        private _blurTexture2;
        private _postProcesses1;
        private _postProcesses2;
        private _includedOnlyMeshes;
        private _excludedMeshes;
        private _meshesUsingTheirOwnMaterials;
        /**
         * Callback used to let the user override the color selection on a per mesh basis
         */
        customEmissiveColorSelector: (mesh: Mesh, subMesh: SubMesh, material: Material, result: Color4) => void;
        /**
         * Callback used to let the user override the texture selection on a per mesh basis
         */
        customEmissiveTextureSelector: (mesh: Mesh, subMesh: SubMesh, material: Material) => Texture;
        /**
         * Instantiates a new glow Layer and references it to the scene.
         * @param name The name of the layer
         * @param scene The scene to use the layer in
         * @param options Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)
         */
        constructor(name: string, scene: Scene, options?: Partial<IGlowLayerOptions>);
        /**
         * Get the effect name of the layer.
         * @return The effect name
         */
        getEffectName(): string;
        /**
         * Create the merge effect. This is the shader use to blit the information back
         * to the main canvas at the end of the scene rendering.
         */
        protected _createMergeEffect(): Effect;
        /**
         * Creates the render target textures and post processes used in the glow layer.
         */
        protected _createTextureAndPostProcesses(): void;
        /**
         * Checks for the readiness of the element composing the layer.
         * @param subMesh the mesh to check for
         * @param useInstances specify wether or not to use instances to render the mesh
         * @param emissiveTexture the associated emissive texture used to generate the glow
         * @return true if ready otherwise, false
         */
        isReady(subMesh: SubMesh, useInstances: boolean): boolean;
        /**
         * Returns whether or nood the layer needs stencil enabled during the mesh rendering.
         */
        needStencil(): boolean;
        /**
         * Returns true if the mesh can be rendered, otherwise false.
         * @param mesh The mesh to render
         * @param material The material used on the mesh
         * @returns true if it can be rendered otherwise false
         */
        protected _canRenderMesh(mesh: AbstractMesh, material: Material): boolean;
        /**
         * Implementation specific of rendering the generating effect on the main canvas.
         * @param effect The effect used to render through
         */
        protected _internalRender(effect: Effect): void;
        /**
         * Sets the required values for both the emissive texture and and the main color.
         */
        protected _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void;
        /**
         * Returns true if the mesh should render, otherwise false.
         * @param mesh The mesh to render
         * @returns true if it should render otherwise false
         */
        protected _shouldRenderMesh(mesh: Mesh): boolean;
        /**
         * Adds specific effects defines.
         * @param defines The defines to add specifics to.
         */
        protected _addCustomEffectDefines(defines: string[]): void;
        /**
         * Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.
         * @param mesh The mesh to exclude from the glow layer
         */
        addExcludedMesh(mesh: Mesh): void;
        /**
          * Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.
          * @param mesh The mesh to remove
          */
        removeExcludedMesh(mesh: Mesh): void;
        /**
         * Add a mesh in the inclusion list to impact or being impacted by the glow layer.
         * @param mesh The mesh to include in the glow layer
         */
        addIncludedOnlyMesh(mesh: Mesh): void;
        /**
          * Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.
          * @param mesh The mesh to remove
          */
        removeIncludedOnlyMesh(mesh: Mesh): void;
        /**
         * Determine if a given mesh will be used in the glow layer
         * @param mesh The mesh to test
         * @returns true if the mesh will be highlighted by the current glow layer
         */
        hasMesh(mesh: AbstractMesh): boolean;
        /**
         * Defines whether the current material of the mesh should be use to render the effect.
         * @param mesh defines the current mesh to render
         */
        protected _useMeshMaterial(mesh: AbstractMesh): boolean;
        /**
         * Add a mesh to be rendered through its own material and not with emissive only.
         * @param mesh The mesh for which we need to use its material
         */
        referenceMeshToUseItsOwnMaterial(mesh: AbstractMesh): void;
        /**
         * Remove a mesh from being rendered through its own material and not with emissive only.
         * @param mesh The mesh for which we need to not use its material
         */
        unReferenceMeshFromUsingItsOwnMaterial(mesh: AbstractMesh): void;
        /**
         * Free any resources and references associated to a mesh.
         * Internal use
         * @param mesh The mesh to free.
         * @hidden
         */
        _disposeMesh(mesh: Mesh): void;
        /**
          * Gets the class name of the effect layer
          * @returns the string with the class name of the effect layer
          */
        getClassName(): string;
        /**
         * Serializes this glow layer
         * @returns a serialized glow layer object
         */
        serialize(): any;
        /**
         * Creates a Glow Layer from parsed glow layer data
         * @param parsedGlowLayer defines glow layer data
         * @param scene defines the current scene
         * @param rootUrl defines the root URL containing the glow layer information
         * @returns a parsed Glow Layer
         */
        static Parse(parsedGlowLayer: any, scene: Scene, rootUrl: string): GlowLayer;
    }
}
declare module BABYLON {
    /** @hidden */
    export var glowBlurPostProcessPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
        interface AbstractScene {
            /**
             * Return a the first highlight layer of the scene with a given name.
             * @param name The name of the highlight layer to look for.
             * @return The highlight layer if found otherwise null.
             */
            getHighlightLayerByName(name: string): Nullable<HighlightLayer>;
        }
    /**
     * Highlight layer options. This helps customizing the behaviour
     * of the highlight layer.
     */
    export interface IHighlightLayerOptions {
        /**
         * Multiplication factor apply to the canvas size to compute the render target size
         * used to generated the glowing objects (the smaller the faster).
         */
        mainTextureRatio: number;
        /**
         * Enforces a fixed size texture to ensure resize independant blur.
         */
        mainTextureFixedSize?: number;
        /**
         * Multiplication factor apply to the main texture size in the first step of the blur to reduce the size
         * of the picture to blur (the smaller the faster).
         */
        blurTextureSizeRatio: number;
        /**
         * How big in texel of the blur texture is the vertical blur.
         */
        blurVerticalSize: number;
        /**
         * How big in texel of the blur texture is the horizontal blur.
         */
        blurHorizontalSize: number;
        /**
         * Alpha blending mode used to apply the blur. Default is combine.
         */
        alphaBlendingMode: number;
        /**
         * The camera attached to the layer.
         */
        camera: Nullable<Camera>;
        /**
         * Should we display highlight as a solid stroke?
         */
        isStroke?: boolean;
        /**
         * The rendering group to draw the layer in.
         */
        renderingGroupId: number;
    }
    /**
     * The highlight layer Helps adding a glow effect around a mesh.
     *
     * Once instantiated in a scene, simply use the addMesh or removeMesh method to add or remove
     * glowy meshes to your scene.
     *
     * !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!
     */
    export class HighlightLayer extends EffectLayer {
        name: string;
        /**
         * Effect Name of the highlight layer.
         */
        static readonly EffectName: string;
        /**
         * The neutral color used during the preparation of the glow effect.
         * This is black by default as the blend operation is a blend operation.
         */
        static NeutralColor: Color4;
        /**
         * Stencil value used for glowing meshes.
         */
        static GlowingMeshStencilReference: number;
        /**
         * Stencil value used for the other meshes in the scene.
         */
        static NormalMeshStencilReference: number;
        /**
         * Specifies whether or not the inner glow is ACTIVE in the layer.
         */
        innerGlow: boolean;
        /**
         * Specifies whether or not the outer glow is ACTIVE in the layer.
         */
        outerGlow: boolean;
        /**
         * Specifies the horizontal size of the blur.
         */
        set blurHorizontalSize(value: number);
        /**
         * Specifies the vertical size of the blur.
         */
        set blurVerticalSize(value: number);
        /**
         * Gets the horizontal size of the blur.
         */
        get blurHorizontalSize(): number;
        /**
         * Gets the vertical size of the blur.
         */
        get blurVerticalSize(): number;
        /**
         * An event triggered when the highlight layer is being blurred.
         */
        onBeforeBlurObservable: Observable<HighlightLayer>;
        /**
         * An event triggered when the highlight layer has been blurred.
         */
        onAfterBlurObservable: Observable<HighlightLayer>;
        private _instanceGlowingMeshStencilReference;
        private _options;
        private _downSamplePostprocess;
        private _horizontalBlurPostprocess;
        private _verticalBlurPostprocess;
        private _blurTexture;
        private _meshes;
        private _excludedMeshes;
        /**
         * Instantiates a new highlight Layer and references it to the scene..
         * @param name The name of the layer
         * @param scene The scene to use the layer in
         * @param options Sets of none mandatory options to use with the layer (see IHighlightLayerOptions for more information)
         */
        constructor(name: string, scene: Scene, options?: Partial<IHighlightLayerOptions>);
        /**
         * Get the effect name of the layer.
         * @return The effect name
         */
        getEffectName(): string;
        /**
         * Create the merge effect. This is the shader use to blit the information back
         * to the main canvas at the end of the scene rendering.
         */
        protected _createMergeEffect(): Effect;
        /**
         * Creates the render target textures and post processes used in the highlight layer.
         */
        protected _createTextureAndPostProcesses(): void;
        /**
         * Returns wether or nood the layer needs stencil enabled during the mesh rendering.
         */
        needStencil(): boolean;
        /**
         * Checks for the readiness of the element composing the layer.
         * @param subMesh the mesh to check for
         * @param useInstances specify wether or not to use instances to render the mesh
         * @param emissiveTexture the associated emissive texture used to generate the glow
         * @return true if ready otherwise, false
         */
        isReady(subMesh: SubMesh, useInstances: boolean): boolean;
        /**
         * Implementation specific of rendering the generating effect on the main canvas.
         * @param effect The effect used to render through
         */
        protected _internalRender(effect: Effect): void;
        /**
         * Returns true if the layer contains information to display, otherwise false.
         */
        shouldRender(): boolean;
        /**
         * Returns true if the mesh should render, otherwise false.
         * @param mesh The mesh to render
         * @returns true if it should render otherwise false
         */
        protected _shouldRenderMesh(mesh: Mesh): boolean;
        /**
         * Returns true if the mesh can be rendered, otherwise false.
         * @param mesh The mesh to render
         * @param material The material used on the mesh
         * @returns true if it can be rendered otherwise false
         */
        protected _canRenderMesh(mesh: AbstractMesh, material: Material): boolean;
        /**
         * Adds specific effects defines.
         * @param defines The defines to add specifics to.
         */
        protected _addCustomEffectDefines(defines: string[]): void;
        /**
         * Sets the required values for both the emissive texture and and the main color.
         */
        protected _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void;
        /**
         * Add a mesh in the exclusion list to prevent it to impact or being impacted by the highlight layer.
         * @param mesh The mesh to exclude from the highlight layer
         */
        addExcludedMesh(mesh: Mesh): void;
        /**
          * Remove a mesh from the exclusion list to let it impact or being impacted by the highlight layer.
          * @param mesh The mesh to highlight
          */
        removeExcludedMesh(mesh: Mesh): void;
        /**
         * Determine if a given mesh will be highlighted by the current HighlightLayer
         * @param mesh mesh to test
         * @returns true if the mesh will be highlighted by the current HighlightLayer
         */
        hasMesh(mesh: AbstractMesh): boolean;
        /**
         * Add a mesh in the highlight layer in order to make it glow with the chosen color.
         * @param mesh The mesh to highlight
         * @param color The color of the highlight
         * @param glowEmissiveOnly Extract the glow from the emissive texture
         */
        addMesh(mesh: Mesh, color: Color3, glowEmissiveOnly?: boolean): void;
        /**
         * Remove a mesh from the highlight layer in order to make it stop glowing.
         * @param mesh The mesh to highlight
         */
        removeMesh(mesh: Mesh): void;
        /**
         * Remove all the meshes currently referenced in the highlight layer
         */
        removeAllMeshes(): void;
        /**
         * Force the stencil to the normal expected value for none glowing parts
         */
        private _defaultStencilReference;
        /**
         * Free any resources and references associated to a mesh.
         * Internal use
         * @param mesh The mesh to free.
         * @hidden
         */
        _disposeMesh(mesh: Mesh): void;
        /**
         * Dispose the highlight layer and free resources.
         */
        dispose(): void;
        /**
          * Gets the class name of the effect layer
          * @returns the string with the class name of the effect layer
          */
        getClassName(): string;
        /**
         * Serializes this Highlight layer
         * @returns a serialized Highlight layer object
         */
        serialize(): any;
        /**
         * Creates a Highlight layer from parsed Highlight layer data
         * @param parsedHightlightLayer defines the Highlight layer data
         * @param scene defines the current scene
         * @param rootUrl defines the root URL containing the Highlight layer information
         * @returns a parsed Highlight layer
         */
        static Parse(parsedHightlightLayer: any, scene: Scene, rootUrl: string): HighlightLayer;
    }
}
declare module BABYLON {
        interface AbstractScene {
            /**
             * The list of layers (background and foreground) of the scene
             */
            layers: Array<Layer>;
        }
    /**
     * Defines the layer scene component responsible to manage any layers
     * in a given scene.
     */
    export class LayerSceneComponent implements ISceneComponent {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        readonly name: string;
        /**
         * The scene the component belongs to.
         */
        scene: Scene;
        private _engine;
        /**
         * Creates a new instance of the component for the given scene
         * @param scene Defines the scene to register the component in
         */
        constructor(scene: Scene);
        /**
         * Registers the component in a given scene
         */
        register(): void;
        /**
         * Rebuilds the elements related to this component in case of
         * context lost for instance.
         */
        rebuild(): void;
        /**
         * Disposes the component and the associated ressources.
         */
        dispose(): void;
        private _draw;
        private _drawCameraPredicate;
        private _drawCameraBackground;
        private _drawCameraForeground;
        private _drawRenderTargetPredicate;
        private _drawRenderTargetBackground;
        private _drawRenderTargetForeground;
        /**
         * Adds all the elements from the container to the scene
         * @param container the container holding the elements
         */
        addFromContainer(container: AbstractScene): void;
        /**
         * Removes all the elements in the container from the scene
         * @param container contains the elements to remove
         * @param dispose if the removed element should be disposed (default: false)
         */
        removeFromContainer(container: AbstractScene, dispose?: boolean): void;
    }
}
declare module BABYLON {
    /** @hidden */
    export var layerPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var layerVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * This represents a full screen 2d layer.
     * This can be useful to display a picture in the  background of your scene for instance.
     * @see https://www.babylonjs-playground.com/#08A2BS#1
     */
    export class Layer {
        /**
         * Define the name of the layer.
         */
        name: string;
        /**
         * Define the texture the layer should display.
         */
        texture: Nullable<Texture>;
        /**
         * Is the layer in background or foreground.
         */
        isBackground: boolean;
        /**
         * Define the color of the layer (instead of texture).
         */
        color: Color4;
        /**
         * Define the scale of the layer in order to zoom in out of the texture.
         */
        scale: Vector2;
        /**
         * Define an offset for the layer in order to shift the texture.
         */
        offset: Vector2;
        /**
         * Define the alpha blending mode used in the layer in case the texture or color has an alpha.
         */
        alphaBlendingMode: number;
        /**
         * Define if the layer should alpha test or alpha blend with the rest of the scene.
         * Alpha test will not mix with the background color in case of transparency.
         * It will either use the texture color or the background depending on the alpha value of the current pixel.
         */
        alphaTest: boolean;
        /**
         * Define a mask to restrict the layer to only some of the scene cameras.
         */
        layerMask: number;
        /**
         * Define the list of render target the layer is visible into.
         */
        renderTargetTextures: RenderTargetTexture[];
        /**
         * Define if the layer is only used in renderTarget or if it also
         * renders in the main frame buffer of the canvas.
         */
        renderOnlyInRenderTargetTextures: boolean;
        private _scene;
        private _vertexBuffers;
        private _indexBuffer;
        private _effect;
        private _previousDefines;
        /**
         * An event triggered when the layer is disposed.
         */
        onDisposeObservable: Observable<Layer>;
        private _onDisposeObserver;
        /**
         * Back compatibility with callback before the onDisposeObservable existed.
         * The set callback will be triggered when the layer has been disposed.
         */
        set onDispose(callback: () => void);
        /**
        * An event triggered before rendering the scene
        */
        onBeforeRenderObservable: Observable<Layer>;
        private _onBeforeRenderObserver;
        /**
         * Back compatibility with callback before the onBeforeRenderObservable existed.
         * The set callback will be triggered just before rendering the layer.
         */
        set onBeforeRender(callback: () => void);
        /**
        * An event triggered after rendering the scene
        */
        onAfterRenderObservable: Observable<Layer>;
        private _onAfterRenderObserver;
        /**
         * Back compatibility with callback before the onAfterRenderObservable existed.
         * The set callback will be triggered just after rendering the layer.
         */
        set onAfterRender(callback: () => void);
        /**
         * Instantiates a new layer.
         * This represents a full screen 2d layer.
         * This can be useful to display a picture in the  background of your scene for instance.
         * @see https://www.babylonjs-playground.com/#08A2BS#1
         * @param name Define the name of the layer in the scene
         * @param imgUrl Define the url of the texture to display in the layer
         * @param scene Define the scene the layer belongs to
         * @param isBackground Defines whether the layer is displayed in front or behind the scene
         * @param color Defines a color for the layer
         */
        constructor(
        /**
         * Define the name of the layer.
         */
        name: string, imgUrl: Nullable<string>, scene: Nullable<Scene>, isBackground?: boolean, color?: Color4);
        private _createIndexBuffer;
        /** @hidden */
        _rebuild(): void;
        /**
         * Renders the layer in the scene.
         */
        render(): void;
        /**
         * Disposes and releases the associated ressources.
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /** @hidden */
    export var lensFlarePixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var lensFlareVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.
     * It is usually composed of several `lensFlare`.
     * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares
     */
    export class LensFlareSystem {
        /**
         * Define the name of the lens flare system
         */
        name: string;
        /**
         * List of lens flares used in this system.
         */
        lensFlares: LensFlare[];
        /**
         * Define a limit from the border the lens flare can be visible.
         */
        borderLimit: number;
        /**
         * Define a viewport border we do not want to see the lens flare in.
         */
        viewportBorder: number;
        /**
         * Define a predicate which could limit the list of meshes able to occlude the effect.
         */
        meshesSelectionPredicate: (mesh: AbstractMesh) => boolean;
        /**
         * Restricts the rendering of the effect to only the camera rendering this layer mask.
         */
        layerMask: number;
        /**
         * Define the id of the lens flare system in the scene.
         * (equal to name by default)
         */
        id: string;
        private _scene;
        private _emitter;
        private _vertexBuffers;
        private _indexBuffer;
        private _effect;
        private _positionX;
        private _positionY;
        private _isEnabled;
        /** @hidden */
        static _SceneComponentInitialization: (scene: Scene) => void;
        /**
         * Instantiates a lens flare system.
         * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.
         * It is usually composed of several `lensFlare`.
         * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares
         * @param name Define the name of the lens flare system in the scene
         * @param emitter Define the source (the emitter) of the lens flares (it can be a camera, a light or a mesh).
         * @param scene Define the scene the lens flare system belongs to
         */
        constructor(
        /**
         * Define the name of the lens flare system
         */
        name: string, emitter: any, scene: Scene);
        /**
         * Define if the lens flare system is enabled.
         */
        get isEnabled(): boolean;
        set isEnabled(value: boolean);
        /**
         * Get the scene the effects belongs to.
         * @returns the scene holding the lens flare system
         */
        getScene(): Scene;
        /**
         * Get the emitter of the lens flare system.
         * It defines the source of the lens flares (it can be a camera, a light or a mesh).
         * @returns the emitter of the lens flare system
         */
        getEmitter(): any;
        /**
         * Set the emitter of the lens flare system.
         * It defines the source of the lens flares (it can be a camera, a light or a mesh).
         * @param newEmitter Define the new emitter of the system
         */
        setEmitter(newEmitter: any): void;
        /**
         * Get the lens flare system emitter position.
         * The emitter defines the source of the lens flares (it can be a camera, a light or a mesh).
         * @returns the position
         */
        getEmitterPosition(): Vector3;
        /**
         * @hidden
         */
        computeEffectivePosition(globalViewport: Viewport): boolean;
        /** @hidden */
        _isVisible(): boolean;
        /**
         * @hidden
         */
        render(): boolean;
        /**
         * Dispose and release the lens flare with its associated resources.
         */
        dispose(): void;
        /**
         * Parse a lens flare system from a JSON repressentation
         * @param parsedLensFlareSystem Define the JSON to parse
         * @param scene Define the scene the parsed system should be instantiated in
         * @param rootUrl Define the rootUrl of the load sequence to easily find a load relative dependencies such as textures
         * @returns the parsed system
         */
        static Parse(parsedLensFlareSystem: any, scene: Scene, rootUrl: string): LensFlareSystem;
        /**
         * Serialize the current Lens Flare System into a JSON representation.
         * @returns the serialized JSON
         */
        serialize(): any;
    }
}
declare module BABYLON {
    /**
     * This represents one of the lens effect in a `lensFlareSystem`.
     * It controls one of the indiviual texture used in the effect.
     * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares
     */
    export class LensFlare {
        /**
         * Define the size of the lens flare in the system (a floating value between 0 and 1)
         */
        size: number;
        /**
         * Define the position of the lens flare in the system. (a floating value between -1 and 1). A value of 0 is located on the emitter. A value greater than 0 is beyond the emitter and a value lesser than 0 is behind.
         */
        position: number;
        /**
         * Define the lens color.
         */
        color: Color3;
        /**
         * Define the lens texture.
         */
        texture: Nullable<Texture>;
        /**
         * Define the alpha mode to render this particular lens.
         */
        alphaMode: number;
        private _system;
        /**
         * Creates a new Lens Flare.
         * This represents one of the lens effect in a `lensFlareSystem`.
         * It controls one of the indiviual texture used in the effect.
         * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares
         * @param size Define the size of the lens flare (a floating value between 0 and 1)
         * @param position Define the position of the lens flare in the system. (a floating value between -1 and 1). A value of 0 is located on the emitter. A value greater than 0 is beyond the emitter and a value lesser than 0 is behind.
         * @param color Define the lens color
         * @param imgUrl Define the lens texture url
         * @param system Define the `lensFlareSystem` this flare is part of
         * @returns The newly created Lens Flare
         */
        static AddFlare(size: number, position: number, color: Color3, imgUrl: string, system: LensFlareSystem): LensFlare;
        /**
         * Instantiates a new Lens Flare.
         * This represents one of the lens effect in a `lensFlareSystem`.
         * It controls one of the indiviual texture used in the effect.
         * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares
         * @param size Define the size of the lens flare in the system (a floating value between 0 and 1)
         * @param position Define the position of the lens flare in the system. (a floating value between -1 and 1). A value of 0 is located on the emitter. A value greater than 0 is beyond the emitter and a value lesser than 0 is behind.
         * @param color Define the lens color
         * @param imgUrl Define the lens texture url
         * @param system Define the `lensFlareSystem` this flare is part of
         */
        constructor(
        /**
         * Define the size of the lens flare in the system (a floating value between 0 and 1)
         */
        size: number, 
        /**
         * Define the position of the lens flare in the system. (a floating value between -1 and 1). A value of 0 is located on the emitter. A value greater than 0 is beyond the emitter and a value lesser than 0 is behind.
         */
        position: number, color: Color3, imgUrl: string, system: LensFlareSystem);
        /**
         * Dispose and release the lens flare with its associated resources.
         */
        dispose(): void;
    }
}
declare module BABYLON {
        interface AbstractScene {
            /**
             * The list of lens flare system added to the scene
             * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares
             */
            lensFlareSystems: Array<LensFlareSystem>;
            /**
             * Removes the given lens flare system from this scene.
             * @param toRemove The lens flare system to remove
             * @returns The index of the removed lens flare system
             */
            removeLensFlareSystem(toRemove: LensFlareSystem): number;
            /**
             * Adds the given lens flare system to this scene
             * @param newLensFlareSystem The lens flare system to add
             */
            addLensFlareSystem(newLensFlareSystem: LensFlareSystem): void;
            /**
             * Gets a lens flare system using its name
             * @param name defines the name to look for
             * @returns the lens flare system or null if not found
             */
            getLensFlareSystemByName(name: string): Nullable<LensFlareSystem>;
            /**
             * Gets a lens flare system using its id
             * @param id defines the id to look for
             * @returns the lens flare system or null if not found
             */
            getLensFlareSystemByID(id: string): Nullable<LensFlareSystem>;
        }
    /**
     * Defines the lens flare scene component responsible to manage any lens flares
     * in a given scene.
     */
    export class LensFlareSystemSceneComponent implements ISceneSerializableComponent {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        readonly name: string;
        /**
         * The scene the component belongs to.
         */
        scene: Scene;
        /**
         * Creates a new instance of the component for the given scene
         * @param scene Defines the scene to register the component in
         */
        constructor(scene: Scene);
        /**
         * Registers the component in a given scene
         */
        register(): void;
        /**
         * Rebuilds the elements related to this component in case of
         * context lost for instance.
         */
        rebuild(): void;
        /**
         * Adds all the elements from the container to the scene
         * @param container the container holding the elements
         */
        addFromContainer(container: AbstractScene): void;
        /**
         * Removes all the elements in the container from the scene
         * @param container contains the elements to remove
         * @param dispose if the removed element should be disposed (default: false)
         */
        removeFromContainer(container: AbstractScene, dispose?: boolean): void;
        /**
         * Serializes the component data to the specified json object
         * @param serializationObject The object to serialize to
         */
        serialize(serializationObject: any): void;
        /**
         * Disposes the component and the associated ressources.
         */
        dispose(): void;
        private _draw;
    }
}
declare module BABYLON {
    /** @hidden */
    export var depthPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var depthVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * This represents a depth renderer in Babylon.
     * A depth renderer will render to it's depth map every frame which can be displayed or used in post processing
     */
    export class DepthRenderer {
        private _scene;
        private _depthMap;
        private _effect;
        private readonly _storeNonLinearDepth;
        private readonly _clearColor;
        /** Get if the depth renderer is using packed depth or not */
        readonly isPacked: boolean;
        private _cachedDefines;
        private _camera;
        /** Enable or disable the depth renderer. When disabled, the depth texture is not updated */
        enabled: boolean;
        /**
         * Specifiess that the depth renderer will only be used within
         * the camera it is created for.
         * This can help forcing its rendering during the camera processing.
         */
        useOnlyInActiveCamera: boolean;
        /** @hidden */
        static _SceneComponentInitialization: (scene: Scene) => void;
        /**
         * Instantiates a depth renderer
         * @param scene The scene the renderer belongs to
         * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)
         * @param camera The camera to be used to render the depth map (default: scene's active camera)
         * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z
         */
        constructor(scene: Scene, type?: number, camera?: Nullable<Camera>, storeNonLinearDepth?: boolean);
        /**
         * Creates the depth rendering effect and checks if the effect is ready.
         * @param subMesh The submesh to be used to render the depth map of
         * @param useInstances If multiple world instances should be used
         * @returns if the depth renderer is ready to render the depth map
         */
        isReady(subMesh: SubMesh, useInstances: boolean): boolean;
        /**
         * Gets the texture which the depth map will be written to.
         * @returns The depth map texture
         */
        getDepthMap(): RenderTargetTexture;
        /**
         * Disposes of the depth renderer.
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /** @hidden */
    export var minmaxReduxPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * This class computes a min/max reduction from a texture: it means it computes the minimum
     * and maximum values from all values of the texture.
     * It is performed on the GPU for better performances, thanks to a succession of post processes.
     * The source values are read from the red channel of the texture.
     */
    export class MinMaxReducer {
        /**
         * Observable triggered when the computation has been performed
         */
        onAfterReductionPerformed: Observable<{
            min: number;
            max: number;
        }>;
        protected _camera: Camera;
        protected _sourceTexture: Nullable<RenderTargetTexture>;
        protected _reductionSteps: Nullable<Array<PostProcess>>;
        protected _postProcessManager: PostProcessManager;
        protected _onAfterUnbindObserver: Nullable<Observer<RenderTargetTexture>>;
        protected _forceFullscreenViewport: boolean;
        /**
         * Creates a min/max reducer
         * @param camera The camera to use for the post processes
         */
        constructor(camera: Camera);
        /**
         * Gets the texture used to read the values from.
         */
        get sourceTexture(): Nullable<RenderTargetTexture>;
        /**
         * Sets the source texture to read the values from.
         * One must indicate if the texture is a depth texture or not through the depthRedux parameter
         * because in such textures '1' value must not be taken into account to compute the maximum
         * as this value is used to clear the texture.
         * Note that the computation is not activated by calling this function, you must call activate() for that!
         * @param sourceTexture The texture to read the values from. The values should be in the red channel.
         * @param depthRedux Indicates if the texture is a depth texture or not
         * @param type The type of the textures created for the reduction (defaults to TEXTURETYPE_HALF_FLOAT)
         * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)
         */
        setSourceTexture(sourceTexture: RenderTargetTexture, depthRedux: boolean, type?: number, forceFullscreenViewport?: boolean): void;
        /**
         * Defines the refresh rate of the computation.
         * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...
         */
        get refreshRate(): number;
        set refreshRate(value: number);
        protected _activated: boolean;
        /**
         * Gets the activation status of the reducer
         */
        get activated(): boolean;
        /**
         * Activates the reduction computation.
         * When activated, the observers registered in onAfterReductionPerformed are
         * called after the compuation is performed
         */
        activate(): void;
        /**
         * Deactivates the reduction computation.
         */
        deactivate(): void;
        /**
         * Disposes the min/max reducer
         * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.
         */
        dispose(disposeAll?: boolean): void;
    }
}
declare module BABYLON {
    /**
     * This class is a small wrapper around the MinMaxReducer class to compute the min/max values of a depth texture
     */
    export class DepthReducer extends MinMaxReducer {
        private _depthRenderer;
        private _depthRendererId;
        /**
         * Gets the depth renderer used for the computation.
         * Note that the result is null if you provide your own renderer when calling setDepthRenderer.
         */
        get depthRenderer(): Nullable<DepthRenderer>;
        /**
         * Creates a depth reducer
         * @param camera The camera used to render the depth texture
         */
        constructor(camera: Camera);
        /**
         * Sets the depth renderer to use to generate the depth map
         * @param depthRenderer The depth renderer to use. If not provided, a new one will be created automatically
         * @param type The texture type of the depth map (default: TEXTURETYPE_HALF_FLOAT)
         * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)
         */
        setDepthRenderer(depthRenderer?: Nullable<DepthRenderer>, type?: number, forceFullscreenViewport?: boolean): void;
        /** @hidden */
        setSourceTexture(sourceTexture: RenderTargetTexture, depthRedux: boolean, type?: number, forceFullscreenViewport?: boolean): void;
        /**
         * Activates the reduction computation.
         * When activated, the observers registered in onAfterReductionPerformed are
         * called after the compuation is performed
         */
        activate(): void;
        /**
         * Deactivates the reduction computation.
         */
        deactivate(): void;
        /**
         * Disposes the depth reducer
         * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.
         */
        dispose(disposeAll?: boolean): void;
    }
}
declare module BABYLON {
    /**
     * A CSM implementation allowing casting shadows on large scenes.
     * Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows
     * Based on: https://github.com/TheRealMJP/Shadows and https://johanmedestrom.wordpress.com/2016/03/18/opengl-cascaded-shadow-maps/
     */
    export class CascadedShadowGenerator extends ShadowGenerator {
        private static readonly frustumCornersNDCSpace;
        /**
         * Name of the CSM class
         */
        static CLASSNAME: string;
        /**
         * Defines the default number of cascades used by the CSM.
         */
        static readonly DEFAULT_CASCADES_COUNT: number;
        /**
         * Defines the minimum number of cascades used by the CSM.
         */
        static readonly MIN_CASCADES_COUNT: number;
        /**
         * Defines the maximum number of cascades used by the CSM.
         */
        static readonly MAX_CASCADES_COUNT: number;
        protected _validateFilter(filter: number): number;
        /**
         * Gets or sets the actual darkness of the soft shadows while using PCSS filtering (value between 0. and 1.)
         */
        penumbraDarkness: number;
        private _numCascades;
        /**
         * Gets or set the number of cascades used by the CSM.
         */
        get numCascades(): number;
        set numCascades(value: number);
        /**
         * Sets this to true if you want that the edges of the shadows don't "swimm" / "shimmer" when rotating the camera.
         * The trade off is that you lose some precision in the shadow rendering when enabling this setting.
         */
        stabilizeCascades: boolean;
        private _freezeShadowCastersBoundingInfo;
        private _freezeShadowCastersBoundingInfoObservable;
        /**
         * Enables or disables the shadow casters bounding info computation.
         * If your shadow casters don't move, you can disable this feature.
         * If it is enabled, the bounding box computation is done every frame.
         */
        get freezeShadowCastersBoundingInfo(): boolean;
        set freezeShadowCastersBoundingInfo(freeze: boolean);
        private _scbiMin;
        private _scbiMax;
        protected _computeShadowCastersBoundingInfo(): void;
        protected _shadowCastersBoundingInfo: BoundingInfo;
        /**
         * Gets or sets the shadow casters bounding info.
         * If you provide your own shadow casters bounding info, first enable freezeShadowCastersBoundingInfo
         * so that the system won't overwrite the bounds you provide
         */
        get shadowCastersBoundingInfo(): BoundingInfo;
        set shadowCastersBoundingInfo(boundingInfo: BoundingInfo);
        protected _breaksAreDirty: boolean;
        protected _minDistance: number;
        protected _maxDistance: number;
        /**
         * Sets the minimal and maximal distances to use when computing the cascade breaks.
         *
         * The values of min / max are typically the depth zmin and zmax values of your scene, for a given frame.
         * If you don't know these values, simply leave them to their defaults and don't call this function.
         * @param min minimal distance for the breaks (default to 0.)
         * @param max maximal distance for the breaks (default to 1.)
         */
        setMinMaxDistance(min: number, max: number): void;
        /** Gets the minimal distance used in the cascade break computation */
        get minDistance(): number;
        /** Gets the maximal distance used in the cascade break computation */
        get maxDistance(): number;
        /**
         * Gets the class name of that object
         * @returns "CascadedShadowGenerator"
         */
        getClassName(): string;
        private _cascadeMinExtents;
        private _cascadeMaxExtents;
        /**
         * Gets a cascade minimum extents
         * @param cascadeIndex index of the cascade
         * @returns the minimum cascade extents
         */
        getCascadeMinExtents(cascadeIndex: number): Nullable<Vector3>;
        /**
         * Gets a cascade maximum extents
         * @param cascadeIndex index of the cascade
         * @returns the maximum cascade extents
         */
        getCascadeMaxExtents(cascadeIndex: number): Nullable<Vector3>;
        private _cascades;
        private _currentLayer;
        private _viewSpaceFrustumsZ;
        private _viewMatrices;
        private _projectionMatrices;
        private _transformMatrices;
        private _transformMatricesAsArray;
        private _frustumLengths;
        private _lightSizeUVCorrection;
        private _depthCorrection;
        private _frustumCornersWorldSpace;
        private _frustumCenter;
        private _shadowCameraPos;
        private _shadowMaxZ;
        /**
         * Gets the shadow max z distance. It's the limit beyond which shadows are not displayed.
         * It defaults to camera.maxZ
         */
        get shadowMaxZ(): number;
        /**
         * Sets the shadow max z distance.
         */
        set shadowMaxZ(value: number);
        protected _debug: boolean;
        /**
         * Gets or sets the debug flag.
         * When enabled, the cascades are materialized by different colors on the screen.
         */
        get debug(): boolean;
        set debug(dbg: boolean);
        private _depthClamp;
        /**
         * Gets or sets the depth clamping value.
         *
         * When enabled, it improves the shadow quality because the near z plane of the light frustum don't need to be adjusted
         * to account for the shadow casters far away.
         *
         * Note that this property is incompatible with PCSS filtering, so it won't be used in that case.
         */
        get depthClamp(): boolean;
        set depthClamp(value: boolean);
        private _cascadeBlendPercentage;
        /**
         * Gets or sets the percentage of blending between two cascades (value between 0. and 1.).
         * It defaults to 0.1 (10% blending).
         */
        get cascadeBlendPercentage(): number;
        set cascadeBlendPercentage(value: number);
        private _lambda;
        /**
         * Gets or set the lambda parameter.
         * This parameter is used to split the camera frustum and create the cascades.
         * It's a value between 0. and 1.: If 0, the split is a uniform split of the frustum, if 1 it is a logarithmic split.
         * For all values in-between, it's a linear combination of the uniform and logarithm split algorithm.
         */
        get lambda(): number;
        set lambda(value: number);
        /**
         * Gets the view matrix corresponding to a given cascade
         * @param cascadeNum cascade to retrieve the view matrix from
         * @returns the cascade view matrix
         */
        getCascadeViewMatrix(cascadeNum: number): Nullable<Matrix>;
        /**
         * Gets the projection matrix corresponding to a given cascade
         * @param cascadeNum cascade to retrieve the projection matrix from
         * @returns the cascade projection matrix
         */
        getCascadeProjectionMatrix(cascadeNum: number): Nullable<Matrix>;
        /**
         * Gets the transformation matrix corresponding to a given cascade
         * @param cascadeNum cascade to retrieve the transformation matrix from
         * @returns the cascade transformation matrix
         */
        getCascadeTransformMatrix(cascadeNum: number): Nullable<Matrix>;
        private _depthRenderer;
        /**
         * Sets the depth renderer to use when autoCalcDepthBounds is enabled.
         *
         * Note that if no depth renderer is set, a new one will be automatically created internally when necessary.
         *
         * You should call this function if you already have a depth renderer enabled in your scene, to avoid
         * doing multiple depth rendering each frame. If you provide your own depth renderer, make sure it stores linear depth!
         * @param depthRenderer The depth renderer to use when autoCalcDepthBounds is enabled. If you pass null or don't call this function at all, a depth renderer will be automatically created
         */
        setDepthRenderer(depthRenderer: Nullable<DepthRenderer>): void;
        private _depthReducer;
        private _autoCalcDepthBounds;
        /**
         * Gets or sets the autoCalcDepthBounds property.
         *
         * When enabled, a depth rendering pass is first performed (with an internally created depth renderer or with the one
         * you provide by calling setDepthRenderer). Then, a min/max reducing is applied on the depth map to compute the
         * minimal and maximal depth of the map and those values are used as inputs for the setMinMaxDistance() function.
         * It can greatly enhance the shadow quality, at the expense of more GPU works.
         * When using this option, you should increase the value of the lambda parameter, and even set it to 1 for best results.
         */
        get autoCalcDepthBounds(): boolean;
        set autoCalcDepthBounds(value: boolean);
        /**
         * Defines the refresh rate of the min/max computation used when autoCalcDepthBounds is set to true
         * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...
         * Note that if you provided your own depth renderer through a call to setDepthRenderer, you are responsible
         * for setting the refresh rate on the renderer yourself!
         */
        get autoCalcDepthBoundsRefreshRate(): number;
        set autoCalcDepthBoundsRefreshRate(value: number);
        /**
         * Create the cascade breaks according to the lambda, shadowMaxZ and min/max distance properties, as well as the camera near and far planes.
         * This function is automatically called when updating lambda, shadowMaxZ and min/max distances, however you should call it yourself if
         * you change the camera near/far planes!
         */
        splitFrustum(): void;
        private _splitFrustum;
        private _computeMatrices;
        private _computeFrustumInWorldSpace;
        private _computeCascadeFrustum;
        /**
        *  Support test.
        */
        static get IsSupported(): boolean;
        /** @hidden */
        static _SceneComponentInitialization: (scene: Scene) => void;
        /**
         * Creates a Cascaded Shadow Generator object.
         * A ShadowGenerator is the required tool to use the shadows.
         * Each directional light casting shadows needs to use its own ShadowGenerator.
         * Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows
         * @param mapSize The size of the texture what stores the shadows. Example : 1024.
         * @param light The directional light object generating the shadows.
         * @param usefulFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.
         */
        constructor(mapSize: number, light: DirectionalLight, usefulFloatFirst?: boolean);
        protected _initializeGenerator(): void;
        protected _createTargetRenderTexture(): void;
        protected _initializeShadowMap(): void;
        protected _bindCustomEffectForRenderSubMeshForShadowMap(subMesh: SubMesh, effect: Effect, matriceNames: any, mesh: AbstractMesh): void;
        protected _isReadyCustomDefines(defines: any, subMesh: SubMesh, useInstances: boolean): void;
        /**
         * Prepare all the defines in a material relying on a shadow map at the specified light index.
         * @param defines Defines of the material we want to update
         * @param lightIndex Index of the light in the enabled light list of the material
         */
        prepareDefines(defines: any, lightIndex: number): void;
        /**
         * Binds the shadow related information inside of an effect (information like near, far, darkness...
         * defined in the generator but impacting the effect).
         * @param lightIndex Index of the light in the enabled light list of the material owning the effect
         * @param effect The effect we are binfing the information for
         */
        bindShadowLight(lightIndex: string, effect: Effect): void;
        /**
         * Gets the transformation matrix of the first cascade used to project the meshes into the map from the light point of view.
         * (eq to view projection * shadow projection matrices)
         * @returns The transform matrix used to create the shadow map
         */
        getTransformMatrix(): Matrix;
        /**
         * Disposes the ShadowGenerator.
         * Returns nothing.
         */
        dispose(): void;
        /**
         * Serializes the shadow generator setup to a json object.
         * @returns The serialized JSON object
         */
        serialize(): any;
        /**
         * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.
         * @param parsedShadowGenerator The JSON object to parse
         * @param scene The scene to create the shadow map for
         * @returns The parsed shadow generator
         */
        static Parse(parsedShadowGenerator: any, scene: Scene): ShadowGenerator;
    }
}
declare module BABYLON {
    /**
     * Defines the shadow generator component responsible to manage any shadow generators
     * in a given scene.
     */
    export class ShadowGeneratorSceneComponent implements ISceneSerializableComponent {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        readonly name: string;
        /**
         * The scene the component belongs to.
         */
        scene: Scene;
        /**
         * Creates a new instance of the component for the given scene
         * @param scene Defines the scene to register the component in
         */
        constructor(scene: Scene);
        /**
         * Registers the component in a given scene
         */
        register(): void;
        /**
         * Rebuilds the elements related to this component in case of
         * context lost for instance.
         */
        rebuild(): void;
        /**
         * Serializes the component data to the specified json object
         * @param serializationObject The object to serialize to
         */
        serialize(serializationObject: any): void;
        /**
         * Adds all the elements from the container to the scene
         * @param container the container holding the elements
         */
        addFromContainer(container: AbstractScene): void;
        /**
         * Removes all the elements in the container from the scene
         * @param container contains the elements to remove
         * @param dispose if the removed element should be disposed (default: false)
         */
        removeFromContainer(container: AbstractScene, dispose?: boolean): void;
        /**
         * Rebuilds the elements related to this component in case of
         * context lost for instance.
         */
        dispose(): void;
        private _gatherRenderTargets;
    }
}
declare module BABYLON {
    /**
     * A point light is a light defined by an unique point in world space.
     * The light is emitted in every direction from this point.
     * A good example of a point light is a standard light bulb.
     * Documentation: https://doc.babylonjs.com/babylon101/lights
     */
    export class PointLight extends ShadowLight {
        private _shadowAngle;
        /**
         * Getter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
         * This specifies what angle the shadow will use to be created.
         *
         * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.
         */
        get shadowAngle(): number;
        /**
         * Setter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
         * This specifies what angle the shadow will use to be created.
         *
         * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.
         */
        set shadowAngle(value: number);
        /**
         * Gets the direction if it has been set.
         * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
         */
        get direction(): Vector3;
        /**
         * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
         */
        set direction(value: Vector3);
        /**
         * Creates a PointLight object from the passed name and position (Vector3) and adds it in the scene.
         * A PointLight emits the light in every direction.
         * It can cast shadows.
         * If the scene camera is already defined and you want to set your PointLight at the camera position, just set it :
         * ```javascript
         * var pointLight = new PointLight("pl", camera.position, scene);
         * ```
         * Documentation : https://doc.babylonjs.com/babylon101/lights
         * @param name The light friendly name
         * @param position The position of the point light in the scene
         * @param scene The scene the lights belongs to
         */
        constructor(name: string, position: Vector3, scene: Scene);
        /**
         * Returns the string "PointLight"
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Returns the integer 0.
         * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
         */
        getTypeID(): number;
        /**
         * Specifies wether or not the shadowmap should be a cube texture.
         * @returns true if the shadowmap needs to be a cube texture.
         */
        needCube(): boolean;
        /**
         * Returns a new Vector3 aligned with the PointLight cube system according to the passed cube face index (integer).
         * @param faceIndex The index of the face we are computed the direction to generate shadow
         * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true
         */
        getShadowDirection(faceIndex?: number): Vector3;
        /**
         * Sets the passed matrix "matrix" as a left-handed perspective projection matrix with the following settings :
         * - fov = PI / 2
         * - aspect ratio : 1.0
         * - z-near and far equal to the active camera minZ and maxZ.
         * Returns the PointLight.
         */
        protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void;
        protected _buildUniformLayout(): void;
        /**
         * Sets the passed Effect "effect" with the PointLight transformed position (or position, if none) and passed name (string).
         * @param effect The effect to update
         * @param lightIndex The index of the light in the effect to update
         * @returns The point light
         */
        transferToEffect(effect: Effect, lightIndex: string): PointLight;
        transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): this;
        /**
         * Prepares the list of defines specific to the light type.
         * @param defines the list of defines
         * @param lightIndex defines the index of the light for the effect
         */
        prepareLightSpecificDefines(defines: any, lightIndex: number): void;
    }
}
declare module BABYLON {
    /**
     * Header information of HDR texture files.
     */
    export interface HDRInfo {
        /**
         * The height of the texture in pixels.
         */
        height: number;
        /**
         * The width of the texture in pixels.
         */
        width: number;
        /**
         * The index of the beginning of the data in the binary file.
         */
        dataPosition: number;
    }
    /**
     * This groups tools to convert HDR texture to native colors array.
     */
    export class HDRTools {
        private static Ldexp;
        private static Rgbe2float;
        private static readStringLine;
        /**
         * Reads header information from an RGBE texture stored in a native array.
         * More information on this format are available here:
         * https://en.wikipedia.org/wiki/RGBE_image_format
         *
         * @param uint8array The binary file stored in  native array.
         * @return The header information.
         */
        static RGBE_ReadHeader(uint8array: Uint8Array): HDRInfo;
        /**
         * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.
         * This RGBE texture needs to store the information as a panorama.
         *
         * More information on this format are available here:
         * https://en.wikipedia.org/wiki/RGBE_image_format
         *
         * @param buffer The binary file stored in an array buffer.
         * @param size The expected size of the extracted cubemap.
         * @return The Cube Map information.
         */
        static GetCubeMapTextureData(buffer: ArrayBuffer, size: number): CubeMapInfo;
        /**
         * Returns the pixels data extracted from an RGBE texture.
         * This pixels will be stored left to right up to down in the R G B order in one array.
         *
         * More information on this format are available here:
         * https://en.wikipedia.org/wiki/RGBE_image_format
         *
         * @param uint8array The binary file stored in an array buffer.
         * @param hdrInfo The header information of the file.
         * @return The pixels data in RGB right to left up to down order.
         */
        static RGBE_ReadPixels(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array;
        private static RGBE_ReadPixels_RLE;
        private static RGBE_ReadPixels_NOT_RLE;
    }
}
declare module BABYLON {
    /**
     * Effect Render Options
     */
    export interface IEffectRendererOptions {
        /**
         * Defines the vertices positions.
         */
        positions?: number[];
        /**
         * Defines the indices.
         */
        indices?: number[];
    }
    /**
     * Helper class to render one or more effects.
     * You can access the previous rendering in your shader by declaring a sampler named textureSampler
     */
    export class EffectRenderer {
        private engine;
        private static _DefaultOptions;
        private _vertexBuffers;
        private _indexBuffer;
        private _fullscreenViewport;
        /**
         * Creates an effect renderer
         * @param engine the engine to use for rendering
         * @param options defines the options of the effect renderer
         */
        constructor(engine: ThinEngine, options?: IEffectRendererOptions);
        /**
         * Sets the current viewport in normalized coordinates 0-1
         * @param viewport Defines the viewport to set (defaults to 0 0 1 1)
         */
        setViewport(viewport?: Viewport): void;
        /**
         * Binds the embedded attributes buffer to the effect.
         * @param effect Defines the effect to bind the attributes for
         */
        bindBuffers(effect: Effect): void;
        /**
         * Sets the current effect wrapper to use during draw.
         * The effect needs to be ready before calling this api.
         * This also sets the default full screen position attribute.
         * @param effectWrapper Defines the effect to draw with
         */
        applyEffectWrapper(effectWrapper: EffectWrapper): void;
        /**
         * Restores engine states
         */
        restoreStates(): void;
        /**
         * Draws a full screen quad.
         */
        draw(): void;
        private isRenderTargetTexture;
        /**
         * renders one or more effects to a specified texture
         * @param effectWrapper the effect to renderer
         * @param outputTexture texture to draw to, if null it will render to the screen.
         */
        render(effectWrapper: EffectWrapper, outputTexture?: Nullable<InternalTexture | RenderTargetTexture>): void;
        /**
         * Disposes of the effect renderer
         */
        dispose(): void;
    }
    /**
     * Options to create an EffectWrapper
     */
    interface EffectWrapperCreationOptions {
        /**
         * Engine to use to create the effect
         */
        engine: ThinEngine;
        /**
         * Fragment shader for the effect
         */
        fragmentShader: string;
        /**
         * Use the shader store instead of direct source code
         */
        useShaderStore?: boolean;
        /**
         * Vertex shader for the effect
         */
        vertexShader?: string;
        /**
         * Attributes to use in the shader
         */
        attributeNames?: Array<string>;
        /**
         * Uniforms to use in the shader
         */
        uniformNames?: Array<string>;
        /**
         * Texture sampler names to use in the shader
         */
        samplerNames?: Array<string>;
        /**
          * Defines to use in the shader
          */
        defines?: Array<string>;
        /**
          * Callback when effect is compiled
          */
        onCompiled?: Nullable<(effect: Effect) => void>;
        /**
         * The friendly name of the effect displayed in Spector.
         */
        name?: string;
    }
    /**
     * Wraps an effect to be used for rendering
     */
    export class EffectWrapper {
        /**
         * Event that is fired right before the effect is drawn (should be used to update uniforms)
         */
        onApplyObservable: Observable<{}>;
        /**
         * The underlying effect
         */
        effect: Effect;
        /**
         * Creates an effect to be renderer
         * @param creationOptions options to create the effect
         */
        constructor(creationOptions: EffectWrapperCreationOptions);
        /**
        * Disposes of the effect wrapper
        */
        dispose(): void;
    }
}
declare module BABYLON {
    /** @hidden */
    export var hdrFilteringVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var hdrFilteringPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Options for texture filtering
     */
    interface IHDRFilteringOptions {
        /**
         * Scales pixel intensity for the input HDR map.
         */
        hdrScale?: number;
        /**
         * Quality of the filter. Should be `Constants.TEXTURE_FILTERING_QUALITY_OFFLINE` for prefiltering
         */
        quality?: number;
    }
    /**
     * Filters HDR maps to get correct renderings of PBR reflections
     */
    export class HDRFiltering {
        private _engine;
        private _effectRenderer;
        private _effectWrapper;
        private _lodGenerationOffset;
        private _lodGenerationScale;
        /**
         * Quality switch for prefiltering. Should be set to `Constants.TEXTURE_FILTERING_QUALITY_OFFLINE` unless
         * you care about baking speed.
         */
        quality: number;
        /**
         * Scales pixel intensity for the input HDR map.
         */
        hdrScale: number;
        /**
         * Instantiates HDR filter for reflection maps
         *
         * @param engine Thin engine
         * @param options Options
         */
        constructor(engine: ThinEngine, options?: IHDRFilteringOptions);
        private _createRenderTarget;
        private _prefilterInternal;
        private _createEffect;
        /**
         * Get a value indicating if the filter is ready to be used
         * @param texture Texture to filter
         * @returns true if the filter is ready
         */
        isReady(texture: BaseTexture): boolean;
        /**
          * Prefilters a cube texture to have mipmap levels representing roughness values.
          * Prefiltering will be invoked at the end of next rendering pass.
          * This has to be done once the map is loaded, and has not been prefiltered by a third party software.
          * See http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf for more information
          * @param texture Texture to filter
          * @param onFinished Callback when filtering is done
          * @return Promise called when prefiltering is done
          */
        prefilter(texture: BaseTexture, onFinished?: Nullable<() => void>): Promise<unknown> | undefined;
    }
}
declare module BABYLON {
    /**
     * This represents a texture coming from an HDR input.
     *
     * The only supported format is currently panorama picture stored in RGBE format.
     * Example of such files can be found on HDRLib: http://hdrlib.com/
     */
    export class HDRCubeTexture extends BaseTexture {
        private static _facesMapping;
        private _generateHarmonics;
        private _noMipmap;
        private _prefilterOnLoad;
        private _textureMatrix;
        private _size;
        private _onLoad;
        private _onError;
        /**
         * The texture URL.
         */
        url: string;
        protected _isBlocking: boolean;
        /**
         * Sets wether or not the texture is blocking during loading.
         */
        set isBlocking(value: boolean);
        /**
         * Gets wether or not the texture is blocking during loading.
         */
        get isBlocking(): boolean;
        protected _rotationY: number;
        /**
         * Sets texture matrix rotation angle around Y axis in radians.
         */
        set rotationY(value: number);
        /**
         * Gets texture matrix rotation angle around Y axis radians.
         */
        get rotationY(): number;
        /**
         * Gets or sets the center of the bounding box associated with the cube texture
         * It must define where the camera used to render the texture was set
         */
        boundingBoxPosition: Vector3;
        private _boundingBoxSize;
        /**
         * Gets or sets the size of the bounding box associated with the cube texture
         * When defined, the cubemap will switch to local mode
         * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity
         * @example https://www.babylonjs-playground.com/#RNASML
         */
        set boundingBoxSize(value: Vector3);
        get boundingBoxSize(): Vector3;
        /**
         * Instantiates an HDRTexture from the following parameters.
         *
         * @param url The location of the HDR raw data (Panorama stored in RGBE format)
         * @param sceneOrEngine The scene or engine the texture will be used in
         * @param size The cubemap desired size (the more it increases the longer the generation will be)
         * @param noMipmap Forces to not generate the mipmap if true
         * @param generateHarmonics Specifies whether you want to extract the polynomial harmonics during the generation process
         * @param gammaSpace Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space)
         * @param prefilterOnLoad Prefilters HDR texture to allow use of this texture as a PBR reflection texture.
         */
        constructor(url: string, sceneOrEngine: Scene | ThinEngine, size: number, noMipmap?: boolean, generateHarmonics?: boolean, gammaSpace?: boolean, prefilterOnLoad?: boolean, onLoad?: Nullable<() => void>, onError?: Nullable<(message?: string, exception?: any) => void>);
        /**
         * Get the current class name of the texture useful for serialization or dynamic coding.
         * @returns "HDRCubeTexture"
         */
        getClassName(): string;
        /**
         * Occurs when the file is raw .hdr file.
         */
        private loadTexture;
        clone(): HDRCubeTexture;
        delayLoad(): void;
        /**
         * Get the texture reflection matrix used to rotate/transform the reflection.
         * @returns the reflection matrix
         */
        getReflectionTextureMatrix(): Matrix;
        /**
         * Set the texture reflection matrix used to rotate/transform the reflection.
         * @param value Define the reflection matrix to set
         */
        setReflectionTextureMatrix(value: Matrix): void;
        /**
         * Parses a JSON representation of an HDR Texture in order to create the texture
         * @param parsedTexture Define the JSON representation
         * @param scene Define the scene the texture should be created in
         * @param rootUrl Define the root url in case we need to load relative dependencies
         * @returns the newly created texture after parsing
         */
        static Parse(parsedTexture: any, scene: Scene, rootUrl: string): Nullable<HDRCubeTexture>;
        serialize(): any;
    }
}
declare module BABYLON {
    /**
     * Class used to control physics engine
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
     */
    export class PhysicsEngine implements IPhysicsEngine {
        private _physicsPlugin;
        /**
         * Global value used to control the smallest number supported by the simulation
         */
        static Epsilon: number;
        private _impostors;
        private _joints;
        private _subTimeStep;
        /**
         * Gets the gravity vector used by the simulation
         */
        gravity: Vector3;
        /**
         * Factory used to create the default physics plugin.
         * @returns The default physics plugin
         */
        static DefaultPluginFactory(): IPhysicsEnginePlugin;
        /**
         * Creates a new Physics Engine
         * @param gravity defines the gravity vector used by the simulation
         * @param _physicsPlugin defines the plugin to use (CannonJS by default)
         */
        constructor(gravity: Nullable<Vector3>, _physicsPlugin?: IPhysicsEnginePlugin);
        /**
         * Sets the gravity vector used by the simulation
         * @param gravity defines the gravity vector to use
         */
        setGravity(gravity: Vector3): void;
        /**
         * Set the time step of the physics engine.
         * Default is 1/60.
         * To slow it down, enter 1/600 for example.
         * To speed it up, 1/30
         * @param newTimeStep defines the new timestep to apply to this world.
         */
        setTimeStep(newTimeStep?: number): void;
        /**
         * Get the time step of the physics engine.
         * @returns the current time step
         */
        getTimeStep(): number;
        /**
         * Set the sub time step of the physics engine.
         * Default is 0 meaning there is no sub steps
         * To increase physics resolution precision, set a small value (like 1 ms)
         * @param subTimeStep defines the new sub timestep used for physics resolution.
         */
        setSubTimeStep(subTimeStep?: number): void;
        /**
         * Get the sub time step of the physics engine.
         * @returns the current sub time step
         */
        getSubTimeStep(): number;
        /**
         * Release all resources
         */
        dispose(): void;
        /**
         * Gets the name of the current physics plugin
         * @returns the name of the plugin
         */
        getPhysicsPluginName(): string;
        /**
         * Adding a new impostor for the impostor tracking.
         * This will be done by the impostor itself.
         * @param impostor the impostor to add
         */
        addImpostor(impostor: PhysicsImpostor): void;
        /**
         * Remove an impostor from the engine.
         * This impostor and its mesh will not longer be updated by the physics engine.
         * @param impostor the impostor to remove
         */
        removeImpostor(impostor: PhysicsImpostor): void;
        /**
         * Add a joint to the physics engine
         * @param mainImpostor defines the main impostor to which the joint is added.
         * @param connectedImpostor defines the impostor that is connected to the main impostor using this joint
         * @param joint defines the joint that will connect both impostors.
         */
        addJoint(mainImpostor: PhysicsImpostor, connectedImpostor: PhysicsImpostor, joint: PhysicsJoint): void;
        /**
         * Removes a joint from the simulation
         * @param mainImpostor defines the impostor used with the joint
         * @param connectedImpostor defines the other impostor connected to the main one by the joint
         * @param joint defines the joint to remove
         */
        removeJoint(mainImpostor: PhysicsImpostor, connectedImpostor: PhysicsImpostor, joint: PhysicsJoint): void;
        /**
         * Called by the scene. No need to call it.
         * @param delta defines the timespam between frames
         */
        _step(delta: number): void;
        /**
         * Gets the current plugin used to run the simulation
         * @returns current plugin
         */
        getPhysicsPlugin(): IPhysicsEnginePlugin;
        /**
         * Gets the list of physic impostors
         * @returns an array of PhysicsImpostor
         */
        getImpostors(): Array<PhysicsImpostor>;
        /**
         * Gets the impostor for a physics enabled object
         * @param object defines the object impersonated by the impostor
         * @returns the PhysicsImpostor or null if not found
         */
        getImpostorForPhysicsObject(object: IPhysicsEnabledObject): Nullable<PhysicsImpostor>;
        /**
         * Gets the impostor for a physics body object
         * @param body defines physics body used by the impostor
         * @returns the PhysicsImpostor or null if not found
         */
        getImpostorWithPhysicsBody(body: any): Nullable<PhysicsImpostor>;
        /**
         * Does a raycast in the physics world
         * @param from when should the ray start?
         * @param to when should the ray end?
         * @returns PhysicsRaycastResult
         */
        raycast(from: Vector3, to: Vector3): PhysicsRaycastResult;
    }
}
declare module BABYLON {
    /** @hidden */
    export class CannonJSPlugin implements IPhysicsEnginePlugin {
        private _useDeltaForWorldStep;
        world: any;
        name: string;
        private _physicsMaterials;
        private _fixedTimeStep;
        private _cannonRaycastResult;
        private _raycastResult;
        private _physicsBodysToRemoveAfterStep;
        private _firstFrame;
        BJSCANNON: any;
        constructor(_useDeltaForWorldStep?: boolean, iterations?: number, cannonInjection?: any);
        setGravity(gravity: Vector3): void;
        setTimeStep(timeStep: number): void;
        getTimeStep(): number;
        executeStep(delta: number, impostors: Array<PhysicsImpostor>): void;
        private _removeMarkedPhysicsBodiesFromWorld;
        applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3): void;
        applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3): void;
        generatePhysicsBody(impostor: PhysicsImpostor): void;
        private _processChildMeshes;
        removePhysicsBody(impostor: PhysicsImpostor): void;
        generateJoint(impostorJoint: PhysicsImpostorJoint): void;
        removeJoint(impostorJoint: PhysicsImpostorJoint): void;
        private _addMaterial;
        private _checkWithEpsilon;
        private _createShape;
        private _createHeightmap;
        private _minus90X;
        private _plus90X;
        private _tmpPosition;
        private _tmpDeltaPosition;
        private _tmpUnityRotation;
        private _updatePhysicsBodyTransformation;
        setTransformationFromPhysicsBody(impostor: PhysicsImpostor): void;
        setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion): void;
        isSupported(): boolean;
        setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3): void;
        setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3): void;
        getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3>;
        getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3>;
        setBodyMass(impostor: PhysicsImpostor, mass: number): void;
        getBodyMass(impostor: PhysicsImpostor): number;
        getBodyFriction(impostor: PhysicsImpostor): number;
        setBodyFriction(impostor: PhysicsImpostor, friction: number): void;
        getBodyRestitution(impostor: PhysicsImpostor): number;
        setBodyRestitution(impostor: PhysicsImpostor, restitution: number): void;
        sleepBody(impostor: PhysicsImpostor): void;
        wakeUpBody(impostor: PhysicsImpostor): void;
        updateDistanceJoint(joint: PhysicsJoint, maxDistance: number): void;
        setMotor(joint: IMotorEnabledJoint, speed?: number, maxForce?: number, motorIndex?: number): void;
        setLimit(joint: IMotorEnabledJoint, upperLimit: number, lowerLimit?: number): void;
        syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor): void;
        getRadius(impostor: PhysicsImpostor): number;
        getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void;
        dispose(): void;
        private _extendNamespace;
        /**
         * Does a raycast in the physics world
         * @param from when should the ray start?
         * @param to when should the ray end?
         * @returns PhysicsRaycastResult
         */
        raycast(from: Vector3, to: Vector3): PhysicsRaycastResult;
    }
}
declare module BABYLON {
    /** @hidden */
    export class OimoJSPlugin implements IPhysicsEnginePlugin {
        private _useDeltaForWorldStep;
        world: any;
        name: string;
        BJSOIMO: any;
        private _raycastResult;
        private _fixedTimeStep;
        constructor(_useDeltaForWorldStep?: boolean, iterations?: number, oimoInjection?: any);
        setGravity(gravity: Vector3): void;
        setTimeStep(timeStep: number): void;
        getTimeStep(): number;
        private _tmpImpostorsArray;
        executeStep(delta: number, impostors: Array<PhysicsImpostor>): void;
        applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3): void;
        applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3): void;
        generatePhysicsBody(impostor: PhysicsImpostor): void;
        private _tmpPositionVector;
        removePhysicsBody(impostor: PhysicsImpostor): void;
        generateJoint(impostorJoint: PhysicsImpostorJoint): void;
        removeJoint(impostorJoint: PhysicsImpostorJoint): void;
        isSupported(): boolean;
        setTransformationFromPhysicsBody(impostor: PhysicsImpostor): void;
        setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion): void;
        setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3): void;
        setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3): void;
        getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3>;
        getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3>;
        setBodyMass(impostor: PhysicsImpostor, mass: number): void;
        getBodyMass(impostor: PhysicsImpostor): number;
        getBodyFriction(impostor: PhysicsImpostor): number;
        setBodyFriction(impostor: PhysicsImpostor, friction: number): void;
        getBodyRestitution(impostor: PhysicsImpostor): number;
        setBodyRestitution(impostor: PhysicsImpostor, restitution: number): void;
        sleepBody(impostor: PhysicsImpostor): void;
        wakeUpBody(impostor: PhysicsImpostor): void;
        updateDistanceJoint(joint: PhysicsJoint, maxDistance: number, minDistance?: number): void;
        setMotor(joint: IMotorEnabledJoint, speed: number, force?: number, motorIndex?: number): void;
        setLimit(joint: IMotorEnabledJoint, upperLimit: number, lowerLimit?: number, motorIndex?: number): void;
        syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor): void;
        getRadius(impostor: PhysicsImpostor): number;
        getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void;
        dispose(): void;
        /**
         * Does a raycast in the physics world
         * @param from when should the ray start?
         * @param to when should the ray end?
         * @returns PhysicsRaycastResult
         */
        raycast(from: Vector3, to: Vector3): PhysicsRaycastResult;
    }
}
declare module BABYLON {
    /**
     * AmmoJS Physics plugin
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
     * @see https://github.com/kripken/ammo.js/
     */
    export class AmmoJSPlugin implements IPhysicsEnginePlugin {
        private _useDeltaForWorldStep;
        /**
         * Reference to the Ammo library
         */
        bjsAMMO: any;
        /**
         * Created ammoJS world which physics bodies are added to
         */
        world: any;
        /**
         * Name of the plugin
         */
        name: string;
        private _timeStep;
        private _fixedTimeStep;
        private _maxSteps;
        private _tmpQuaternion;
        private _tmpAmmoTransform;
        private _tmpAmmoQuaternion;
        private _tmpAmmoConcreteContactResultCallback;
        private _collisionConfiguration;
        private _dispatcher;
        private _overlappingPairCache;
        private _solver;
        private _softBodySolver;
        private _tmpAmmoVectorA;
        private _tmpAmmoVectorB;
        private _tmpAmmoVectorC;
        private _tmpAmmoVectorD;
        private _tmpContactCallbackResult;
        private _tmpAmmoVectorRCA;
        private _tmpAmmoVectorRCB;
        private _raycastResult;
        private static readonly DISABLE_COLLISION_FLAG;
        private static readonly KINEMATIC_FLAG;
        private static readonly DISABLE_DEACTIVATION_FLAG;
        /**
         * Initializes the ammoJS plugin
         * @param _useDeltaForWorldStep if the time between frames should be used when calculating physics steps (Default: true)
         * @param ammoInjection can be used to inject your own ammo reference
         * @param overlappingPairCache can be used to specify your own overlapping pair cache
         */
        constructor(_useDeltaForWorldStep?: boolean, ammoInjection?: any, overlappingPairCache?: any);
        /**
         * Sets the gravity of the physics world (m/(s^2))
         * @param gravity Gravity to set
         */
        setGravity(gravity: Vector3): void;
        /**
         * Amount of time to step forward on each frame (only used if useDeltaForWorldStep is false in the constructor)
         * @param timeStep timestep to use in seconds
         */
        setTimeStep(timeStep: number): void;
        /**
         * Increment to step forward in the physics engine (If timeStep is set to 1/60 and fixedTimeStep is set to 1/120 the physics engine should run 2 steps per frame) (Default: 1/60)
         * @param fixedTimeStep fixedTimeStep to use in seconds
         */
        setFixedTimeStep(fixedTimeStep: number): void;
        /**
         * Sets the maximum number of steps by the physics engine per frame (Default: 5)
         * @param maxSteps the maximum number of steps by the physics engine per frame
         */
        setMaxSteps(maxSteps: number): void;
        /**
         * Gets the current timestep (only used if useDeltaForWorldStep is false in the constructor)
         * @returns the current timestep in seconds
         */
        getTimeStep(): number;
        /**
         * The create custom shape handler function to be called when using BABYLON.PhysicsImposter.CustomImpostor
         */
        onCreateCustomShape: (impostor: PhysicsImpostor) => any;
        private _isImpostorInContact;
        private _isImpostorPairInContact;
        private _stepSimulation;
        /**
         * Moves the physics simulation forward delta seconds and updates the given physics imposters
         * Prior to the step the imposters physics location is set to the position of the babylon meshes
         * After the step the babylon meshes are set to the position of the physics imposters
         * @param delta amount of time to step forward
         * @param impostors array of imposters to update before/after the step
         */
        executeStep(delta: number, impostors: Array<PhysicsImpostor>): void;
        /**
         * Update babylon mesh to match physics world object
         * @param impostor imposter to match
         */
        private _afterSoftStep;
        /**
         * Update babylon mesh vertices vertices to match physics world softbody or cloth
         * @param impostor imposter to match
         */
        private _ropeStep;
        /**
         * Update babylon mesh vertices vertices to match physics world softbody or cloth
         * @param impostor imposter to match
         */
        private _softbodyOrClothStep;
        private _tmpMatrix;
        /**
         * Applies an impulse on the imposter
         * @param impostor imposter to apply impulse to
         * @param force amount of force to be applied to the imposter
         * @param contactPoint the location to apply the impulse on the imposter
         */
        applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3): void;
        /**
         * Applies a force on the imposter
         * @param impostor imposter to apply force
         * @param force amount of force to be applied to the imposter
         * @param contactPoint the location to apply the force on the imposter
         */
        applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3): void;
        /**
         * Creates a physics body using the plugin
         * @param impostor the imposter to create the physics body on
         */
        generatePhysicsBody(impostor: PhysicsImpostor): void;
        /**
         * Removes the physics body from the imposter and disposes of the body's memory
         * @param impostor imposter to remove the physics body from
         */
        removePhysicsBody(impostor: PhysicsImpostor): void;
        /**
         * Generates a joint
         * @param impostorJoint the imposter joint to create the joint with
         */
        generateJoint(impostorJoint: PhysicsImpostorJoint): void;
        /**
         * Removes a joint
         * @param impostorJoint the imposter joint to remove the joint from
         */
        removeJoint(impostorJoint: PhysicsImpostorJoint): void;
        private _addMeshVerts;
        /**
         * Initialise the soft body vertices to match its object's (mesh) vertices
         * Softbody vertices (nodes) are in world space and to match this
         * The object's position and rotation is set to zero and so its vertices are also then set in world space
         * @param impostor to create the softbody for
         */
        private _softVertexData;
        /**
         * Create an impostor's soft body
         * @param impostor to create the softbody for
         */
        private _createSoftbody;
        /**
         * Create cloth for an impostor
         * @param impostor to create the softbody for
         */
        private _createCloth;
        /**
         * Create rope for an impostor
         * @param impostor to create the softbody for
         */
        private _createRope;
        /**
         * Create a custom physics impostor shape using the plugin's onCreateCustomShape handler
         * @param impostor to create the custom physics shape for
         */
        private _createCustom;
        private _addHullVerts;
        private _createShape;
        /**
         * Sets the physics body position/rotation from the babylon mesh's position/rotation
         * @param impostor imposter containing the physics body and babylon object
         */
        setTransformationFromPhysicsBody(impostor: PhysicsImpostor): void;
        /**
         * Sets the babylon object's position/rotation from the physics body's position/rotation
         * @param impostor imposter containing the physics body and babylon object
         * @param newPosition new position
         * @param newRotation new rotation
         */
        setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion): void;
        /**
         * If this plugin is supported
         * @returns true if its supported
         */
        isSupported(): boolean;
        /**
         * Sets the linear velocity of the physics body
         * @param impostor imposter to set the velocity on
         * @param velocity velocity to set
         */
        setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3): void;
        /**
         * Sets the angular velocity of the physics body
         * @param impostor imposter to set the velocity on
         * @param velocity velocity to set
         */
        setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3): void;
        /**
         * gets the linear velocity
         * @param impostor imposter to get linear velocity from
         * @returns linear velocity
         */
        getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3>;
        /**
         * gets the angular velocity
         * @param impostor imposter to get angular velocity from
         * @returns angular velocity
         */
        getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3>;
        /**
         * Sets the mass of physics body
         * @param impostor imposter to set the mass on
         * @param mass mass to set
         */
        setBodyMass(impostor: PhysicsImpostor, mass: number): void;
        /**
         * Gets the mass of the physics body
         * @param impostor imposter to get the mass from
         * @returns mass
         */
        getBodyMass(impostor: PhysicsImpostor): number;
        /**
         * Gets friction of the impostor
         * @param impostor impostor to get friction from
         * @returns friction value
         */
        getBodyFriction(impostor: PhysicsImpostor): number;
        /**
         * Sets friction of the impostor
         * @param impostor impostor to set friction on
         * @param friction friction value
         */
        setBodyFriction(impostor: PhysicsImpostor, friction: number): void;
        /**
         * Gets restitution of the impostor
         * @param impostor impostor to get restitution from
         * @returns restitution value
         */
        getBodyRestitution(impostor: PhysicsImpostor): number;
        /**
         * Sets resitution of the impostor
         * @param impostor impostor to set resitution on
         * @param restitution resitution value
         */
        setBodyRestitution(impostor: PhysicsImpostor, restitution: number): void;
        /**
         * Gets pressure inside the impostor
         * @param impostor impostor to get pressure from
         * @returns pressure value
         */
        getBodyPressure(impostor: PhysicsImpostor): number;
        /**
         * Sets pressure inside a soft body impostor
         * Cloth and rope must remain 0 pressure
         * @param impostor impostor to set pressure on
         * @param pressure pressure value
         */
        setBodyPressure(impostor: PhysicsImpostor, pressure: number): void;
        /**
         * Gets stiffness of the impostor
         * @param impostor impostor to get stiffness from
         * @returns pressure value
         */
        getBodyStiffness(impostor: PhysicsImpostor): number;
        /**
         * Sets stiffness of the impostor
         * @param impostor impostor to set stiffness on
         * @param stiffness stiffness value from 0 to 1
         */
        setBodyStiffness(impostor: PhysicsImpostor, stiffness: number): void;
        /**
         * Gets velocityIterations of the impostor
         * @param impostor impostor to get velocity iterations from
         * @returns velocityIterations value
         */
        getBodyVelocityIterations(impostor: PhysicsImpostor): number;
        /**
         * Sets velocityIterations of the impostor
         * @param impostor impostor to set velocity iterations on
         * @param velocityIterations velocityIterations value
         */
        setBodyVelocityIterations(impostor: PhysicsImpostor, velocityIterations: number): void;
        /**
         * Gets positionIterations of the impostor
         * @param impostor impostor to get position iterations from
         * @returns positionIterations value
         */
        getBodyPositionIterations(impostor: PhysicsImpostor): number;
        /**
         * Sets positionIterations of the impostor
         * @param impostor impostor to set position on
         * @param positionIterations positionIterations value
         */
        setBodyPositionIterations(impostor: PhysicsImpostor, positionIterations: number): void;
        /**
        * Append an anchor to a cloth object
        * @param impostor is the cloth impostor to add anchor to
        * @param otherImpostor is the rigid impostor to anchor to
        * @param width ratio across width from 0 to 1
        * @param height ratio up height from 0 to 1
        * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little strech
        * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false
        */
        appendAnchor(impostor: PhysicsImpostor, otherImpostor: PhysicsImpostor, width: number, height: number, influence?: number, noCollisionBetweenLinkedBodies?: boolean): void;
        /**
         * Append an hook to a rope object
         * @param impostor is the rope impostor to add hook to
         * @param otherImpostor is the rigid impostor to hook to
         * @param length ratio along the rope from 0 to 1
         * @param influence the elasticity between soft impostor and anchor from 0, very stretchy to 1, little strech
         * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false
         */
        appendHook(impostor: PhysicsImpostor, otherImpostor: PhysicsImpostor, length: number, influence?: number, noCollisionBetweenLinkedBodies?: boolean): void;
        /**
         * Sleeps the physics body and stops it from being active
         * @param impostor impostor to sleep
         */
        sleepBody(impostor: PhysicsImpostor): void;
        /**
         * Activates the physics body
         * @param impostor impostor to activate
         */
        wakeUpBody(impostor: PhysicsImpostor): void;
        /**
         * Updates the distance parameters of the joint
         * @param joint joint to update
         * @param maxDistance maximum distance of the joint
         * @param minDistance minimum distance of the joint
         */
        updateDistanceJoint(joint: PhysicsJoint, maxDistance: number, minDistance?: number): void;
        /**
         * Sets a motor on the joint
         * @param joint joint to set motor on
         * @param speed speed of the motor
         * @param maxForce maximum force of the motor
         * @param motorIndex index of the motor
         */
        setMotor(joint: IMotorEnabledJoint, speed?: number, maxForce?: number, motorIndex?: number): void;
        /**
         * Sets the motors limit
         * @param joint joint to set limit on
         * @param upperLimit upper limit
         * @param lowerLimit lower limit
         */
        setLimit(joint: IMotorEnabledJoint, upperLimit: number, lowerLimit?: number): void;
        /**
         * Syncs the position and rotation of a mesh with the impostor
         * @param mesh mesh to sync
         * @param impostor impostor to update the mesh with
         */
        syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor): void;
        /**
         * Gets the radius of the impostor
         * @param impostor impostor to get radius from
         * @returns the radius
         */
        getRadius(impostor: PhysicsImpostor): number;
        /**
         * Gets the box size of the impostor
         * @param impostor impostor to get box size from
         * @param result the resulting box size
         */
        getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void;
        /**
         * Disposes of the impostor
         */
        dispose(): void;
        /**
         * Does a raycast in the physics world
         * @param from when should the ray start?
         * @param to when should the ray end?
         * @returns PhysicsRaycastResult
         */
        raycast(from: Vector3, to: Vector3): PhysicsRaycastResult;
    }
}
declare module BABYLON {
        interface AbstractScene {
            /**
             * The list of reflection probes added to the scene
             * @see https://doc.babylonjs.com/how_to/how_to_use_reflection_probes
             */
            reflectionProbes: Array<ReflectionProbe>;
            /**
             * Removes the given reflection probe from this scene.
             * @param toRemove The reflection probe to remove
             * @returns The index of the removed reflection probe
             */
            removeReflectionProbe(toRemove: ReflectionProbe): number;
            /**
             * Adds the given reflection probe to this scene.
             * @param newReflectionProbe The reflection probe to add
             */
            addReflectionProbe(newReflectionProbe: ReflectionProbe): void;
        }
    /**
     * Class used to generate realtime reflection / refraction cube textures
     * @see https://doc.babylonjs.com/how_to/how_to_use_reflection_probes
     */
    export class ReflectionProbe {
        /** defines the name of the probe */
        name: string;
        private _scene;
        private _renderTargetTexture;
        private _projectionMatrix;
        private _viewMatrix;
        private _target;
        private _add;
        private _attachedMesh;
        private _invertYAxis;
        /** Gets or sets probe position (center of the cube map) */
        position: Vector3;
        /**
         * Creates a new reflection probe
         * @param name defines the name of the probe
         * @param size defines the texture resolution (for each face)
         * @param scene defines the hosting scene
         * @param generateMipMaps defines if mip maps should be generated automatically (true by default)
         * @param useFloat defines if HDR data (flaot data) should be used to store colors (false by default)
         */
        constructor(
        /** defines the name of the probe */
        name: string, size: number, scene: Scene, generateMipMaps?: boolean, useFloat?: boolean);
        /** Gets or sets the number of samples to use for multi-sampling (0 by default). Required WebGL2 */
        get samples(): number;
        set samples(value: number);
        /** Gets or sets the refresh rate to use (on every frame by default) */
        get refreshRate(): number;
        set refreshRate(value: number);
        /**
         * Gets the hosting scene
         * @returns a Scene
         */
        getScene(): Scene;
        /** Gets the internal CubeTexture used to render to */
        get cubeTexture(): RenderTargetTexture;
        /** Gets the list of meshes to render */
        get renderList(): Nullable<AbstractMesh[]>;
        /**
         * Attach the probe to a specific mesh (Rendering will be done from attached mesh's position)
         * @param mesh defines the mesh to attach to
         */
        attachToMesh(mesh: Nullable<AbstractMesh>): void;
        /**
         * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups
         * @param renderingGroupId The rendering group id corresponding to its index
         * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
         */
        setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean): void;
        /**
         * Clean all associated resources
         */
        dispose(): void;
        /**
         * Converts the reflection probe information to a readable string for debug purpose.
         * @param fullDetails Supports for multiple levels of logging within scene loading
         * @returns the human readable reflection probe info
         */
        toString(fullDetails?: boolean): string;
        /**
         * Get the class name of the relfection probe.
         * @returns "ReflectionProbe"
         */
        getClassName(): string;
        /**
         * Serialize the reflection probe to a JSON representation we can easily use in the resepective Parse function.
         * @returns The JSON representation of the texture
         */
        serialize(): any;
        /**
         * Parse the JSON representation of a reflection probe in order to recreate the reflection probe in the given scene.
         * @param parsedReflectionProbe Define the JSON representation of the reflection probe
         * @param scene Define the scene the parsed reflection probe should be instantiated in
         * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies
         * @returns The parsed reflection probe if successful
         */
        static Parse(parsedReflectionProbe: any, scene: Scene, rootUrl: string): Nullable<ReflectionProbe>;
    }
}
declare module BABYLON {
    /** @hidden */
    export var _BabylonLoaderRegistered: boolean;
    /**
     * Helps setting up some configuration for the babylon file loader.
     */
    export class BabylonFileLoaderConfiguration {
        /**
         * The loader does not allow injecting custom physix engine into the plugins.
         * Unfortunately in ES6, we need to manually inject them into the plugin.
         * So you could set this variable to your engine import to make it work.
         */
        static LoaderInjectedPhysicsEngine: any;
    }
}
declare module BABYLON {
    /**
     * The Physically based simple base material of BJS.
     *
     * This enables better naming and convention enforcements on top of the pbrMaterial.
     * It is used as the base class for both the specGloss and metalRough conventions.
     */
    export abstract class PBRBaseSimpleMaterial extends PBRBaseMaterial {
        /**
         * Number of Simultaneous lights allowed on the material.
         */
        maxSimultaneousLights: number;
        /**
         * If sets to true, disables all the lights affecting the material.
         */
        disableLighting: boolean;
        /**
         * Environment Texture used in the material (this is use for both reflection and environment lighting).
         */
        environmentTexture: BaseTexture;
        /**
         * If sets to true, x component of normal map value will invert (x = 1.0 - x).
         */
        invertNormalMapX: boolean;
        /**
         * If sets to true, y component of normal map value will invert (y = 1.0 - y).
         */
        invertNormalMapY: boolean;
        /**
         * Normal map used in the model.
         */
        normalTexture: BaseTexture;
        /**
         * Emissivie color used to self-illuminate the model.
         */
        emissiveColor: Color3;
        /**
         * Emissivie texture used to self-illuminate the model.
         */
        emissiveTexture: BaseTexture;
        /**
         * Occlusion Channel Strenght.
         */
        occlusionStrength: number;
        /**
         * Occlusion Texture of the material (adding extra occlusion effects).
         */
        occlusionTexture: BaseTexture;
        /**
         * Defines the alpha limits in alpha test mode.
         */
        alphaCutOff: number;
        /**
         * Gets the current double sided mode.
         */
        get doubleSided(): boolean;
        /**
         * If sets to true and backfaceCulling is false, normals will be flipped on the backside.
         */
        set doubleSided(value: boolean);
        /**
         * Stores the pre-calculated light information of a mesh in a texture.
         */
        lightmapTexture: BaseTexture;
        /**
         * If true, the light map contains occlusion information instead of lighting info.
         */
        useLightmapAsShadowmap: boolean;
        /**
         * Instantiates a new PBRMaterial instance.
         *
         * @param name The material name
         * @param scene The scene the material will be use in.
         */
        constructor(name: string, scene: Scene);
        getClassName(): string;
    }
}
declare module BABYLON {
    /**
     * The PBR material of BJS following the metal roughness convention.
     *
     * This fits to the PBR convention in the GLTF definition:
     * https://github.com/KhronosGroup/glTF/tree/2.0/specification/2.0
     */
    export class PBRMetallicRoughnessMaterial extends PBRBaseSimpleMaterial {
        /**
         * The base color has two different interpretations depending on the value of metalness.
         * When the material is a metal, the base color is the specific measured reflectance value
         * at normal incidence (F0). For a non-metal the base color represents the reflected diffuse color
         * of the material.
         */
        baseColor: Color3;
        /**
         * Base texture of the metallic workflow. It contains both the baseColor information in RGB as
         * well as opacity information in the alpha channel.
         */
        baseTexture: BaseTexture;
        /**
         * Specifies the metallic scalar value of the material.
         * Can also be used to scale the metalness values of the metallic texture.
         */
        metallic: number;
        /**
         * Specifies the roughness scalar value of the material.
         * Can also be used to scale the roughness values of the metallic texture.
         */
        roughness: number;
        /**
         * Texture containing both the metallic value in the B channel and the
         * roughness value in the G channel to keep better precision.
         */
        metallicRoughnessTexture: BaseTexture;
        /**
         * Instantiates a new PBRMetalRoughnessMaterial instance.
         *
         * @param name The material name
         * @param scene The scene the material will be use in.
         */
        constructor(name: string, scene: Scene);
        /**
         * Return the currrent class name of the material.
         */
        getClassName(): string;
        /**
         * Makes a duplicate of the current material.
         * @param name - name to use for the new material.
         */
        clone(name: string): PBRMetallicRoughnessMaterial;
        /**
         * Serialize the material to a parsable JSON object.
         */
        serialize(): any;
        /**
         * Parses a JSON object correponding to the serialize function.
         */
        static Parse(source: any, scene: Scene, rootUrl: string): PBRMetallicRoughnessMaterial;
    }
}
declare module BABYLON {
    /**
     * The PBR material of BJS following the specular glossiness convention.
     *
     * This fits to the PBR convention in the GLTF definition:
     * https://github.com/KhronosGroup/glTF/tree/2.0/extensions/Khronos/KHR_materials_pbrSpecularGlossiness
     */
    export class PBRSpecularGlossinessMaterial extends PBRBaseSimpleMaterial {
        /**
         * Specifies the diffuse color of the material.
         */
        diffuseColor: Color3;
        /**
         * Specifies the diffuse texture of the material. This can also contains the opcity value in its alpha
         * channel.
         */
        diffuseTexture: BaseTexture;
        /**
         * Specifies the specular color of the material. This indicates how reflective is the material (none to mirror).
         */
        specularColor: Color3;
        /**
         * Specifies the glossiness of the material. This indicates "how sharp is the reflection".
         */
        glossiness: number;
        /**
         * Specifies both the specular color RGB and the glossiness A of the material per pixels.
         */
        specularGlossinessTexture: BaseTexture;
        /**
         * Instantiates a new PBRSpecularGlossinessMaterial instance.
         *
         * @param name The material name
         * @param scene The scene the material will be use in.
         */
        constructor(name: string, scene: Scene);
        /**
         * Return the currrent class name of the material.
         */
        getClassName(): string;
        /**
         * Makes a duplicate of the current material.
         * @param name - name to use for the new material.
         */
        clone(name: string): PBRSpecularGlossinessMaterial;
        /**
         * Serialize the material to a parsable JSON object.
         */
        serialize(): any;
        /**
         * Parses a JSON object correponding to the serialize function.
         */
        static Parse(source: any, scene: Scene, rootUrl: string): PBRSpecularGlossinessMaterial;
    }
}
declare module BABYLON {
    /**
     * This represents a color grading texture. This acts as a lookup table LUT, useful during post process
     * It can help converting any input color in a desired output one. This can then be used to create effects
     * from sepia, black and white to sixties or futuristic rendering...
     *
     * The only supported format is currently 3dl.
     * More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table
     */
    export class ColorGradingTexture extends BaseTexture {
        /**
         * The texture URL.
         */
        url: string;
        /**
         * Empty line regex stored for GC.
         */
        private static _noneEmptyLineRegex;
        private _textureMatrix;
        private _onLoad;
        /**
         * Instantiates a ColorGradingTexture from the following parameters.
         *
         * @param url The location of the color gradind data (currently only supporting 3dl)
         * @param sceneOrEngine The scene or engine the texture will be used in
         * @param onLoad defines a callback triggered when the texture has been loaded
         */
        constructor(url: string, sceneOrEngine: Scene | ThinEngine, onLoad?: Nullable<() => void>);
        /**
         * Fires the onload event from the constructor if requested.
         */
        private _triggerOnLoad;
        /**
         * Returns the texture matrix used in most of the material.
         * This is not used in color grading but keep for troubleshooting purpose (easily swap diffuse by colorgrading to look in).
         */
        getTextureMatrix(): Matrix;
        /**
         * Occurs when the file being loaded is a .3dl LUT file.
         */
        private load3dlTexture;
        /**
         * Starts the loading process of the texture.
         */
        private loadTexture;
        /**
         * Clones the color gradind texture.
         */
        clone(): ColorGradingTexture;
        /**
         * Called during delayed load for textures.
         */
        delayLoad(): void;
        /**
         * Parses a color grading texture serialized by Babylon.
         * @param parsedTexture The texture information being parsedTexture
         * @param scene The scene to load the texture in
         * @param rootUrl The root url of the data assets to load
         * @return A color gradind texture
         */
        static Parse(parsedTexture: any, scene: Scene): Nullable<ColorGradingTexture>;
        /**
         * Serializes the LUT texture to json format.
         */
        serialize(): any;
    }
}
declare module BABYLON {
    /**
     * This represents a texture coming from an equirectangular image supported by the web browser canvas.
     */
    export class EquiRectangularCubeTexture extends BaseTexture {
        /** The six faces of the cube. */
        private static _FacesMapping;
        private _noMipmap;
        private _onLoad;
        private _onError;
        /** The size of the cubemap. */
        private _size;
        /** The buffer of the image. */
        private _buffer;
        /** The width of the input image. */
        private _width;
        /** The height of the input image. */
        private _height;
        /** The URL to the image. */
        url: string;
        /**
         * Instantiates an EquiRectangularCubeTexture from the following parameters.
         * @param url The location of the image
         * @param scene The scene the texture will be used in
         * @param size The cubemap desired size (the more it increases the longer the generation will be)
         * @param noMipmap Forces to not generate the mipmap if true
         * @param gammaSpace Specifies if the texture will be used in gamma or linear space
         * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)
         * @param onLoad  defines a callback called when texture is loaded
         * @param onError  defines a callback called if there is an error
         */
        constructor(url: string, scene: Scene, size: number, noMipmap?: boolean, gammaSpace?: boolean, onLoad?: Nullable<() => void>, onError?: Nullable<(message?: string, exception?: any) => void>);
        /**
         * Load the image data, by putting the image on a canvas and extracting its buffer.
         */
        private loadImage;
        /**
         * Convert the image buffer into a cubemap and create a CubeTexture.
         */
        private loadTexture;
        /**
         * Convert the ArrayBuffer into a Float32Array and drop the transparency channel.
         * @param buffer The ArrayBuffer that should be converted.
         * @returns The buffer as Float32Array.
         */
        private getFloat32ArrayFromArrayBuffer;
        /**
         * Get the current class name of the texture useful for serialization or dynamic coding.
         * @returns "EquiRectangularCubeTexture"
         */
        getClassName(): string;
        /**
         * Create a clone of the current EquiRectangularCubeTexture and return it.
         * @returns A clone of the current EquiRectangularCubeTexture.
         */
        clone(): EquiRectangularCubeTexture;
    }
}
declare module BABYLON {
    /**
     * Defines the options related to the creation of an HtmlElementTexture
     */
    export interface IHtmlElementTextureOptions {
        /**
         * Defines wether mip maps should be created or not.
         */
        generateMipMaps?: boolean;
        /**
         * Defines the sampling mode of the texture.
         */
        samplingMode?: number;
        /**
         * Defines the engine instance to use the texture with. It is not mandatory if you define a scene.
         */
        engine: Nullable<ThinEngine>;
        /**
         * Defines the scene the texture belongs to. It is not mandatory if you define an engine.
         */
        scene: Nullable<Scene>;
    }
    /**
     * This represents the smallest workload to use an already existing element (Canvas or Video) as a texture.
     * To be as efficient as possible depending on your constraints nothing aside the first upload
     * is automatically managed.
     * It is a cheap VideoTexture or DynamicTexture if you prefer to keep full control of the elements
     * in your application.
     *
     * As the update is not automatic, you need to call them manually.
     */
    export class HtmlElementTexture extends BaseTexture {
        /**
         * The texture URL.
         */
        element: HTMLVideoElement | HTMLCanvasElement;
        private static readonly DefaultOptions;
        private _textureMatrix;
        private _isVideo;
        private _generateMipMaps;
        private _samplingMode;
        /**
         * Instantiates a HtmlElementTexture from the following parameters.
         *
         * @param name Defines the name of the texture
         * @param element Defines the video or canvas the texture is filled with
         * @param options Defines the other none mandatory texture creation options
         */
        constructor(name: string, element: HTMLVideoElement | HTMLCanvasElement, options: IHtmlElementTextureOptions);
        private _createInternalTexture;
        /**
         * Returns the texture matrix used in most of the material.
         */
        getTextureMatrix(): Matrix;
        /**
         * Updates the content of the texture.
         * @param invertY Defines wether the texture should be inverted on Y (false by default on video and true on canvas)
         */
        update(invertY?: Nullable<boolean>): void;
    }
}
declare module BABYLON {
    /**
     * Based on jsTGALoader - Javascript loader for TGA file
     * By Vincent Thibault
     * @see http://blog.robrowser.com/javascript-tga-loader.html
     */
    export class TGATools {
        private static _TYPE_INDEXED;
        private static _TYPE_RGB;
        private static _TYPE_GREY;
        private static _TYPE_RLE_INDEXED;
        private static _TYPE_RLE_RGB;
        private static _TYPE_RLE_GREY;
        private static _ORIGIN_MASK;
        private static _ORIGIN_SHIFT;
        private static _ORIGIN_BL;
        private static _ORIGIN_BR;
        private static _ORIGIN_UL;
        private static _ORIGIN_UR;
        /**
         * Gets the header of a TGA file
         * @param data defines the TGA data
         * @returns the header
         */
        static GetTGAHeader(data: Uint8Array): any;
        /**
         * Uploads TGA content to a Babylon Texture
         * @hidden
         */
        static UploadContent(texture: InternalTexture, data: Uint8Array): void;
        /** @hidden */
        static _getImageData8bits(header: any, palettes: Uint8Array, pixel_data: Uint8Array, y_start: number, y_step: number, y_end: number, x_start: number, x_step: number, x_end: number): Uint8Array;
        /** @hidden */
        static _getImageData16bits(header: any, palettes: Uint8Array, pixel_data: Uint8Array, y_start: number, y_step: number, y_end: number, x_start: number, x_step: number, x_end: number): Uint8Array;
        /** @hidden */
        static _getImageData24bits(header: any, palettes: Uint8Array, pixel_data: Uint8Array, y_start: number, y_step: number, y_end: number, x_start: number, x_step: number, x_end: number): Uint8Array;
        /** @hidden */
        static _getImageData32bits(header: any, palettes: Uint8Array, pixel_data: Uint8Array, y_start: number, y_step: number, y_end: number, x_start: number, x_step: number, x_end: number): Uint8Array;
        /** @hidden */
        static _getImageDataGrey8bits(header: any, palettes: Uint8Array, pixel_data: Uint8Array, y_start: number, y_step: number, y_end: number, x_start: number, x_step: number, x_end: number): Uint8Array;
        /** @hidden */
        static _getImageDataGrey16bits(header: any, palettes: Uint8Array, pixel_data: Uint8Array, y_start: number, y_step: number, y_end: number, x_start: number, x_step: number, x_end: number): Uint8Array;
    }
}
declare module BABYLON {
    /**
     * Implementation of the TGA Texture Loader.
     * @hidden
     */
    export class _TGATextureLoader implements IInternalTextureLoader {
        /**
         * Defines wether the loader supports cascade loading the different faces.
         */
        readonly supportCascades: boolean;
        /**
         * This returns if the loader support the current file information.
         * @param extension defines the file extension of the file being loaded
         * @returns true if the loader can load the specified file
         */
        canLoad(extension: string): boolean;
        /**
         * Uploads the cube texture data to the WebGL texture. It has already been bound.
         * @param data contains the texture data
         * @param texture defines the BabylonJS internal texture
         * @param createPolynomials will be true if polynomials have been requested
         * @param onLoad defines the callback to trigger once the texture is ready
         * @param onError defines the callback to trigger in case of error
         */
        loadCubeData(data: ArrayBufferView | ArrayBufferView[], texture: InternalTexture, createPolynomials: boolean, onLoad: Nullable<(data?: any) => void>, onError: Nullable<(message?: string, exception?: any) => void>): void;
        /**
         * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.
         * @param data contains the texture data
         * @param texture defines the BabylonJS internal texture
         * @param callback defines the method to call once ready to upload
         */
        loadData(data: ArrayBufferView, texture: InternalTexture, callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void) => void): void;
    }
}
declare module BABYLON {
    /**
     * Info about the .basis files
     */
    class BasisFileInfo {
        /**
         * If the file has alpha
         */
        hasAlpha: boolean;
        /**
         * Info about each image of the basis file
         */
        images: Array<{
            levels: Array<{
                width: number;
                height: number;
                transcodedPixels: ArrayBufferView;
            }>;
        }>;
    }
    /**
     * Result of transcoding a basis file
     */
    class TranscodeResult {
        /**
         * Info about the .basis file
         */
        fileInfo: BasisFileInfo;
        /**
         * Format to use when loading the file
         */
        format: number;
    }
    /**
     * Configuration options for the Basis transcoder
     */
    export class BasisTranscodeConfiguration {
        /**
         * Supported compression formats used to determine the supported output format of the transcoder
         */
        supportedCompressionFormats?: {
            /**
             * etc1 compression format
             */
            etc1?: boolean;
            /**
             * s3tc compression format
             */
            s3tc?: boolean;
            /**
             * pvrtc compression format
             */
            pvrtc?: boolean;
            /**
             * etc2 compression format
             */
            etc2?: boolean;
        };
        /**
         * If mipmap levels should be loaded for transcoded images (Default: true)
         */
        loadMipmapLevels?: boolean;
        /**
         * Index of a single image to load (Default: all images)
         */
        loadSingleImage?: number;
    }
    /**
     * Used to load .Basis files
     * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl
     */
    export class BasisTools {
        private static _IgnoreSupportedFormats;
        /**
         * URL to use when loading the basis transcoder
         */
        static JSModuleURL: string;
        /**
         * URL to use when loading the wasm module for the transcoder
         */
        static WasmModuleURL: string;
        /**
         * Get the internal format to be passed to texImage2D corresponding to the .basis format value
         * @param basisFormat format chosen from GetSupportedTranscodeFormat
         * @returns internal format corresponding to the Basis format
         */
        static GetInternalFormatFromBasisFormat(basisFormat: number): number;
        private static _WorkerPromise;
        private static _Worker;
        private static _actionId;
        private static _CreateWorkerAsync;
        /**
         * Transcodes a loaded image file to compressed pixel data
         * @param data image data to transcode
         * @param config configuration options for the transcoding
         * @returns a promise resulting in the transcoded image
         */
        static TranscodeAsync(data: ArrayBuffer | ArrayBufferView, config: BasisTranscodeConfiguration): Promise<TranscodeResult>;
        /**
         * Loads a texture from the transcode result
         * @param texture texture load to
         * @param transcodeResult the result of transcoding the basis file to load from
         */
        static LoadTextureFromTranscodeResult(texture: InternalTexture, transcodeResult: TranscodeResult): void;
    }
}
declare module BABYLON {
    /**
     * Loader for .basis file format
     */
    export class _BasisTextureLoader implements IInternalTextureLoader {
        /**
         * Defines whether the loader supports cascade loading the different faces.
         */
        readonly supportCascades: boolean;
        /**
         * This returns if the loader support the current file information.
         * @param extension defines the file extension of the file being loaded
         * @returns true if the loader can load the specified file
         */
        canLoad(extension: string): boolean;
        /**
         * Uploads the cube texture data to the WebGL texture. It has already been bound.
         * @param data contains the texture data
         * @param texture defines the BabylonJS internal texture
         * @param createPolynomials will be true if polynomials have been requested
         * @param onLoad defines the callback to trigger once the texture is ready
         * @param onError defines the callback to trigger in case of error
         */
        loadCubeData(data: ArrayBufferView | ArrayBufferView[], texture: InternalTexture, createPolynomials: boolean, onLoad: Nullable<(data?: any) => void>, onError: Nullable<(message?: string, exception?: any) => void>): void;
        /**
         * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.
         * @param data contains the texture data
         * @param texture defines the BabylonJS internal texture
         * @param callback defines the method to call once ready to upload
         */
        loadData(data: ArrayBufferView, texture: InternalTexture, callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void) => void): void;
    }
}
declare module BABYLON {
    /**
     * Defines the basic options interface of a TexturePacker Frame
     */
    export interface ITexturePackerFrame {
        /**
         * The frame ID
         */
        id: number;
        /**
         * The frames Scale
         */
        scale: Vector2;
        /**
        * The Frames offset
        */
        offset: Vector2;
    }
    /**
     * This is a support class for frame Data on texture packer sets.
     */
    export class TexturePackerFrame implements ITexturePackerFrame {
        /**
         * The frame ID
         */
        id: number;
        /**
         * The frames Scale
         */
        scale: Vector2;
        /**
         * The Frames offset
         */
        offset: Vector2;
        /**
         * Initializes a texture package frame.
         * @param id The numerical frame identifier
         * @param scale Scalar Vector2 for UV frame
         * @param offset Vector2 for the frame position in UV units.
         * @returns TexturePackerFrame
         */
        constructor(id: number, scale: Vector2, offset: Vector2);
    }
}
declare module BABYLON {
    /**
    * Defines the basic options interface of a TexturePacker
    */
    export interface ITexturePackerOptions {
        /**
        * Custom targets for the channels of a texture packer.  Default is all the channels of the Standard Material
        */
        map?: string[];
        /**
        * the UV input targets, as a single value for all meshes. Defaults to VertexBuffer.UVKind
        */
        uvsIn?: string;
        /**
        * the UV output targets, as a single value for all meshes.  Defaults to VertexBuffer.UVKind
        */
        uvsOut?: string;
        /**
        * number representing the layout style. Defaults to LAYOUT_STRIP
        */
        layout?: number;
        /**
        * number of columns if using custom column count layout(2).  This defaults to 4.
        */
        colnum?: number;
        /**
        * flag to update the input meshes to the new packed texture after compilation. Defaults to true.
        */
        updateInputMeshes?: boolean;
        /**
        * boolean flag to dispose all the source textures.  Defaults to true.
        */
        disposeSources?: boolean;
        /**
        * Fills the blank cells in a set to the customFillColor.  Defaults to true.
        */
        fillBlanks?: boolean;
        /**
        * string value representing the context fill style color.  Defaults to 'black'.
        */
        customFillColor?: string;
        /**
        * Width and Height Value of each Frame in the TexturePacker Sets
        */
        frameSize?: number;
        /**
        * Ratio of the value to add padding wise to each cell.  Defaults to 0.0115
        */
        paddingRatio?: number;
        /**
        * Number that declares the fill method for the padding gutter.
        */
        paddingMode?: number;
        /**
        * If in SUBUV_COLOR padding mode what color to use.
        */
        paddingColor?: Color3 | Color4;
    }
    /**
    * Defines the basic interface of a TexturePacker JSON File
    */
    export interface ITexturePackerJSON {
        /**
        * The frame ID
        */
        name: string;
        /**
        * The base64 channel data
        */
        sets: any;
        /**
        * The options of the Packer
        */
        options: ITexturePackerOptions;
        /**
        * The frame data of the Packer
        */
        frames: Array<number>;
    }
    /**
    * This is a support class that generates a series of packed texture sets.
    * @see https://doc.babylonjs.com/babylon101/materials
    */
    export class TexturePacker {
        /** Packer Layout Constant 0 */
        static readonly LAYOUT_STRIP: number;
        /** Packer Layout Constant 1 */
        static readonly LAYOUT_POWER2: number;
        /** Packer Layout Constant 2 */
        static readonly LAYOUT_COLNUM: number;
        /** Packer Layout Constant 0 */
        static readonly SUBUV_WRAP: number;
        /** Packer Layout Constant 1 */
        static readonly SUBUV_EXTEND: number;
        /** Packer Layout Constant 2 */
        static readonly SUBUV_COLOR: number;
        /** The Name of the Texture Package */
        name: string;
        /** The scene scope of the TexturePacker */
        scene: Scene;
        /** The Meshes to target */
        meshes: AbstractMesh[];
        /** Arguments passed with the Constructor */
        options: ITexturePackerOptions;
        /** The promise that is started upon initialization */
        promise: Nullable<Promise<TexturePacker | string>>;
        /** The Container object for the channel sets that are generated */
        sets: object;
        /** The Container array for the frames that are generated */
        frames: TexturePackerFrame[];
        /** The expected number of textures the system is parsing. */
        private _expecting;
        /** The padding value from Math.ceil(frameSize * paddingRatio) */
        private _paddingValue;
        /**
        * Initializes a texture package series from an array of meshes or a single mesh.
        * @param name The name of the package
        * @param meshes The target meshes to compose the package from
        * @param options The arguments that texture packer should follow while building.
        * @param scene The scene which the textures are scoped to.
        * @returns TexturePacker
        */
        constructor(name: string, meshes: AbstractMesh[], options: ITexturePackerOptions, scene: Scene);
        /**
        * Starts the package process
        * @param resolve The promises resolution function
        * @returns TexturePacker
        */
        private _createFrames;
        /**
        * Calculates the Size of the Channel Sets
        * @returns Vector2
        */
        private _calculateSize;
        /**
        * Calculates the UV data for the frames.
        * @param baseSize the base frameSize
        * @param padding the base frame padding
        * @param dtSize size of the Dynamic Texture for that channel
        * @param dtUnits is 1/dtSize
        * @param update flag to update the input meshes
        */
        private _calculateMeshUVFrames;
        /**
        * Calculates the frames Offset.
        * @param index of the frame
        * @returns Vector2
        */
        private _getFrameOffset;
        /**
        * Updates a Mesh to the frame data
        * @param mesh that is the target
        * @param frameID or the frame index
        */
        private _updateMeshUV;
        /**
        * Updates a Meshes materials to use the texture packer channels
        * @param m is the mesh to target
        * @param force all channels on the packer to be set.
        */
        private _updateTextureReferences;
        /**
        * Public method to set a Mesh to a frame
        * @param m that is the target
        * @param frameID or the frame index
        * @param updateMaterial trigger for if the Meshes attached Material be updated?
        */
        setMeshToFrame(m: AbstractMesh, frameID: number, updateMaterial?: boolean): void;
        /**
        * Starts the async promise to compile the texture packer.
        * @returns Promise<void>
        */
        processAsync(): Promise<void>;
        /**
        * Disposes all textures associated with this packer
        */
        dispose(): void;
        /**
        * Starts the download process for all the channels converting them to base64 data and embedding it all in a JSON file.
        * @param imageType is the image type to use.
        * @param quality of the image if downloading as jpeg, Ranges from >0 to 1.
        */
        download(imageType?: string, quality?: number): void;
        /**
        * Public method to load a texturePacker JSON file.
        * @param data of the JSON file in string format.
        */
        updateFromJSON(data: string): void;
    }
}
declare module BABYLON {
    /**
     * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
     * Custom Procedural textures are the easiest way to create your own procedural in your application.
     * @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures#creating-custom-procedural-textures
     */
    export class CustomProceduralTexture extends ProceduralTexture {
        private _animate;
        private _time;
        private _config;
        private _texturePath;
        /**
         * Instantiates a new Custom Procedural Texture.
         * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
         * Custom Procedural textures are the easiest way to create your own procedural in your application.
         * @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures#creating-custom-procedural-textures
         * @param name Define the name of the texture
         * @param texturePath Define the folder path containing all the cutom texture related files (config, shaders...)
         * @param size Define the size of the texture to create
         * @param scene Define the scene the texture belongs to
         * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture
         * @param generateMipMaps Define if the texture should creates mip maps or not
         */
        constructor(name: string, texturePath: string, size: number, scene: Scene, fallbackTexture?: Texture, generateMipMaps?: boolean);
        private _loadJson;
        /**
         * Is the texture ready to be used ? (rendered at least once)
         * @returns true if ready, otherwise, false.
         */
        isReady(): boolean;
        /**
         * Render the texture to its associated render target.
         * @param useCameraPostProcess Define if camera post process should be applied to the texture
         */
        render(useCameraPostProcess?: boolean): void;
        /**
         * Update the list of dependant textures samplers in the shader.
         */
        updateTextures(): void;
        /**
         * Update the uniform values of the procedural texture in the shader.
         */
        updateShaderUniforms(): void;
        /**
         * Define if the texture animates or not.
         */
        get animate(): boolean;
        set animate(value: boolean);
    }
}
declare module BABYLON {
    /** @hidden */
    export var noisePixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Class used to generate noise procedural textures
     */
    export class NoiseProceduralTexture extends ProceduralTexture {
        /** Gets or sets the start time (default is 0) */
        time: number;
        /** Gets or sets a value between 0 and 1 indicating the overall brightness of the texture (default is 0.2) */
        brightness: number;
        /** Defines the number of octaves to process */
        octaves: number;
        /** Defines the level of persistence (0.8 by default) */
        persistence: number;
        /** Gets or sets animation speed factor (default is 1) */
        animationSpeedFactor: number;
        /**
         * Creates a new NoiseProceduralTexture
         * @param name defines the name fo the texture
         * @param size defines the size of the texture (default is 256)
         * @param scene defines the hosting scene
         * @param fallbackTexture defines the texture to use if the NoiseProceduralTexture can't be created
         * @param generateMipMaps defines if mipmaps must be generated (true by default)
         */
        constructor(name: string, size?: number, scene?: Nullable<Scene>, fallbackTexture?: Texture, generateMipMaps?: boolean);
        private _updateShaderUniforms;
        protected _getDefines(): string;
        /** Generate the current state of the procedural texture */
        render(useCameraPostProcess?: boolean): void;
        /**
         * Serializes this noise procedural texture
         * @returns a serialized noise procedural texture object
         */
        serialize(): any;
        /**
         * Clone the texture.
         * @returns the cloned texture
         */
        clone(): NoiseProceduralTexture;
        /**
         * Creates a NoiseProceduralTexture from parsed noise procedural texture data
         * @param parsedTexture defines parsed texture data
         * @param scene defines the current scene
         * @param rootUrl defines the root URL containing noise procedural texture information
         * @returns a parsed NoiseProceduralTexture
         */
        static Parse(parsedTexture: any, scene: Scene): NoiseProceduralTexture;
    }
}
declare module BABYLON {
    /**
     * Raw cube texture where the raw buffers are passed in
     */
    export class RawCubeTexture extends CubeTexture {
        /**
         * Creates a cube texture where the raw buffers are passed in.
         * @param scene defines the scene the texture is attached to
         * @param data defines the array of data to use to create each face
         * @param size defines the size of the textures
         * @param format defines the format of the data
         * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)
         * @param generateMipMaps  defines if the engine should generate the mip levels
         * @param invertY defines if data must be stored with Y axis inverted
         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)
         * @param compression defines the compression used (null by default)
         */
        constructor(scene: Scene, data: Nullable<ArrayBufferView[]>, size: number, format?: number, type?: number, generateMipMaps?: boolean, invertY?: boolean, samplingMode?: number, compression?: Nullable<string>);
        /**
         * Updates the raw cube texture.
         * @param data defines the data to store
         * @param format defines the data format
         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)
         * @param invertY defines if data must be stored with Y axis inverted
         * @param compression defines the compression used (null by default)
         * @param level defines which level of the texture to update
         */
        update(data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression?: Nullable<string>): void;
        /**
         * Updates a raw cube texture with RGBD encoded data.
         * @param data defines the array of data [mipmap][face] to use to create each face
         * @param sphericalPolynomial defines the spherical polynomial for irradiance
         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness
         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness
         * @returns a promsie that resolves when the operation is complete
         */
        updateRGBDAsync(data: ArrayBufferView[][], sphericalPolynomial?: Nullable<SphericalPolynomial>, lodScale?: number, lodOffset?: number): Promise<void>;
        /**
         * Clones the raw cube texture.
         * @return a new cube texture
         */
        clone(): CubeTexture;
        /** @hidden */
        static _UpdateRGBDAsync(internalTexture: InternalTexture, data: ArrayBufferView[][], sphericalPolynomial: Nullable<SphericalPolynomial>, lodScale: number, lodOffset: number): Promise<void>;
    }
}
declare module BABYLON {
    /**
     * Class used to store 2D array textures containing user data
     */
    export class RawTexture2DArray extends Texture {
        /** Gets or sets the texture format to use */
        format: number;
        /**
         * Create a new RawTexture2DArray
         * @param data defines the data of the texture
         * @param width defines the width of the texture
         * @param height defines the height of the texture
         * @param depth defines the number of layers of the texture
         * @param format defines the texture format to use
         * @param scene defines the hosting scene
         * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)
         * @param invertY defines if texture must be stored with Y axis inverted
         * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)
         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)
         */
        constructor(data: ArrayBufferView, width: number, height: number, depth: number, 
        /** Gets or sets the texture format to use */
        format: number, scene: Scene, generateMipMaps?: boolean, invertY?: boolean, samplingMode?: number, textureType?: number);
        /**
         * Update the texture with new data
         * @param data defines the data to store in the texture
         */
        update(data: ArrayBufferView): void;
    }
}
declare module BABYLON {
    /**
     * Class used to store 3D textures containing user data
     */
    export class RawTexture3D extends Texture {
        /** Gets or sets the texture format to use */
        format: number;
        /**
         * Create a new RawTexture3D
         * @param data defines the data of the texture
         * @param width defines the width of the texture
         * @param height defines the height of the texture
         * @param depth defines the depth of the texture
         * @param format defines the texture format to use
         * @param scene defines the hosting scene
         * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)
         * @param invertY defines if texture must be stored with Y axis inverted
         * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)
         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)
         */
        constructor(data: ArrayBufferView, width: number, height: number, depth: number, 
        /** Gets or sets the texture format to use */
        format: number, scene: Scene, generateMipMaps?: boolean, invertY?: boolean, samplingMode?: number, textureType?: number);
        /**
         * Update the texture with new data
         * @param data defines the data to store in the texture
         */
        update(data: ArrayBufferView): void;
    }
}
declare module BABYLON {
    /**
     * Creates a refraction texture used by refraction channel of the standard material.
     * It is like a mirror but to see through a material.
     * @see https://doc.babylonjs.com/how_to/reflect#refraction
     */
    export class RefractionTexture extends RenderTargetTexture {
        /**
         * Define the reflection plane we want to use. The refractionPlane is usually set to the constructed refractor.
         * It is possible to directly set the refractionPlane by directly using a Plane(a, b, c, d) where a, b and c give the plane normal vector (a, b, c) and d is a scalar displacement from the refractionPlane to the origin. However in all but the very simplest of situations it is more straight forward to set it to the refractor as stated in the doc.
         * @see https://doc.babylonjs.com/how_to/reflect#refraction
         */
        refractionPlane: Plane;
        /**
         * Define how deep under the surface we should see.
         */
        depth: number;
        /**
         * Creates a refraction texture used by refraction channel of the standard material.
         * It is like a mirror but to see through a material.
         * @see https://doc.babylonjs.com/how_to/reflect#refraction
         * @param name Define the texture name
         * @param size Define the size of the underlying texture
         * @param scene Define the scene the refraction belongs to
         * @param generateMipMaps Define if we need to generate mips level for the refraction
         */
        constructor(name: string, size: number, scene: Scene, generateMipMaps?: boolean);
        /**
         * Clone the refraction texture.
         * @returns the cloned texture
         */
        clone(): RefractionTexture;
        /**
         * Serialize the texture to a JSON representation you could use in Parse later on
         * @returns the serialized JSON representation
         */
        serialize(): any;
    }
}
declare module BABYLON {
    /**
     * Block used to add support for vertex skinning (bones)
     */
    export class BonesBlock extends NodeMaterialBlock {
        /**
         * Creates a new BonesBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Initialize the block and prepare the context for build
         * @param state defines the state that will be used for the build
         */
        initialize(state: NodeMaterialBuildState): void;
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the matrix indices input component
         */
        get matricesIndices(): NodeMaterialConnectionPoint;
        /**
         * Gets the matrix weights input component
         */
        get matricesWeights(): NodeMaterialConnectionPoint;
        /**
         * Gets the extra matrix indices input component
         */
        get matricesIndicesExtra(): NodeMaterialConnectionPoint;
        /**
         * Gets the extra matrix weights input component
         */
        get matricesWeightsExtra(): NodeMaterialConnectionPoint;
        /**
         * Gets the world input component
         */
        get world(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        autoConfigure(material: NodeMaterial): void;
        provideFallbacks(mesh: AbstractMesh, fallbacks: EffectFallbacks): void;
        bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh): void;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to add support for instances
     * @see https://doc.babylonjs.com/how_to/how_to_use_instances
     */
    export class InstancesBlock extends NodeMaterialBlock {
        /**
         * Creates a new InstancesBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the first world row input component
         */
        get world0(): NodeMaterialConnectionPoint;
        /**
         * Gets the second world row input component
         */
        get world1(): NodeMaterialConnectionPoint;
        /**
         * Gets the third world row input component
         */
        get world2(): NodeMaterialConnectionPoint;
        /**
         * Gets the forth world row input component
         */
        get world3(): NodeMaterialConnectionPoint;
        /**
         * Gets the world input component
         */
        get world(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        /**
         * Gets the isntanceID component
         */
        get instanceID(): NodeMaterialConnectionPoint;
        autoConfigure(material: NodeMaterial): void;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances?: boolean, subMesh?: SubMesh): void;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to add morph targets support to vertex shader
     */
    export class MorphTargetsBlock extends NodeMaterialBlock {
        private _repeatableContentAnchor;
        /**
         * Create a new MorphTargetsBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the position input component
         */
        get position(): NodeMaterialConnectionPoint;
        /**
         * Gets the normal input component
         */
        get normal(): NodeMaterialConnectionPoint;
        /**
         * Gets the tangent input component
         */
        get tangent(): NodeMaterialConnectionPoint;
        /**
         * Gets the tangent input component
         */
        get uv(): NodeMaterialConnectionPoint;
        /**
         * Gets the position output component
         */
        get positionOutput(): NodeMaterialConnectionPoint;
        /**
         * Gets the normal output component
         */
        get normalOutput(): NodeMaterialConnectionPoint;
        /**
         * Gets the tangent output component
         */
        get tangentOutput(): NodeMaterialConnectionPoint;
        /**
         * Gets the tangent output component
         */
        get uvOutput(): NodeMaterialConnectionPoint;
        initialize(state: NodeMaterialBuildState): void;
        autoConfigure(material: NodeMaterial): void;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
        bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh): void;
        replaceRepeatableContent(vertexShaderState: NodeMaterialBuildState, fragmentShaderState: NodeMaterialBuildState, mesh: AbstractMesh, defines: NodeMaterialDefines): void;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to get data information from a light
     */
    export class LightInformationBlock extends NodeMaterialBlock {
        private _lightDataUniformName;
        private _lightColorUniformName;
        private _lightTypeDefineName;
        /**
         * Gets or sets the light associated with this block
         */
        light: Nullable<Light>;
        /**
         * Creates a new LightInformationBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the world position input component
         */
        get worldPosition(): NodeMaterialConnectionPoint;
        /**
         * Gets the direction output component
         */
        get direction(): NodeMaterialConnectionPoint;
        /**
         * Gets the direction output component
         */
        get color(): NodeMaterialConnectionPoint;
        /**
     * Gets the direction output component
     */
        get intensity(): NodeMaterialConnectionPoint;
        bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh): void;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
        protected _buildBlock(state: NodeMaterialBuildState): this;
        serialize(): any;
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * Block used to add image processing support to fragment shader
     */
    export class ImageProcessingBlock extends NodeMaterialBlock {
        /**
         * Create a new ImageProcessingBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the color input component
         */
        get color(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        /**
         * Initialize the block and prepare the context for build
         * @param state defines the state that will be used for the build
         */
        initialize(state: NodeMaterialBuildState): void;
        isReady(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): boolean;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
        bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh): void;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to pertub normals based on a normal map
     */
    export class PerturbNormalBlock extends NodeMaterialBlock {
        private _tangentSpaceParameterName;
        /** Gets or sets a boolean indicating that normal should be inverted on X axis */
        invertX: boolean;
        /** Gets or sets a boolean indicating that normal should be inverted on Y axis */
        invertY: boolean;
        /**
         * Create a new PerturbNormalBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the world position input component
         */
        get worldPosition(): NodeMaterialConnectionPoint;
        /**
         * Gets the world normal input component
         */
        get worldNormal(): NodeMaterialConnectionPoint;
        /**
         * Gets the world tangent input component
         */
        get worldTangent(): NodeMaterialConnectionPoint;
        /**
         * Gets the uv input component
         */
        get uv(): NodeMaterialConnectionPoint;
        /**
        * Gets the normal map color input component
        */
        get normalMapColor(): NodeMaterialConnectionPoint;
        /**
        * Gets the strength input component
        */
        get strength(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
        bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh): void;
        autoConfigure(material: NodeMaterial): void;
        protected _buildBlock(state: NodeMaterialBuildState): this;
        protected _dumpPropertiesCode(): string;
        serialize(): any;
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * Block used to discard a pixel if a value is smaller than a cutoff
     */
    export class DiscardBlock extends NodeMaterialBlock {
        /**
         * Create a new DiscardBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the color input component
         */
        get value(): NodeMaterialConnectionPoint;
        /**
         * Gets the cutoff input component
         */
        get cutoff(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to test if the fragment shader is front facing
     */
    export class FrontFacingBlock extends NodeMaterialBlock {
        /**
         * Creates a new FrontFacingBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to get the derivative value on x and y of a given input
     */
    export class DerivativeBlock extends NodeMaterialBlock {
        /**
         * Create a new DerivativeBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the input component
         */
        get input(): NodeMaterialConnectionPoint;
        /**
         * Gets the derivative output on x
         */
        get dx(): NodeMaterialConnectionPoint;
        /**
         * Gets the derivative output on y
         */
        get dy(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to make gl_FragCoord available
     */
    export class FragCoordBlock extends NodeMaterialBlock {
        /**
         * Creates a new FragCoordBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the xy component
         */
        get xy(): NodeMaterialConnectionPoint;
        /**
         * Gets the xyz component
         */
        get xyz(): NodeMaterialConnectionPoint;
        /**
         * Gets the xyzw component
         */
        get xyzw(): NodeMaterialConnectionPoint;
        /**
         * Gets the x component
         */
        get x(): NodeMaterialConnectionPoint;
        /**
         * Gets the y component
         */
        get y(): NodeMaterialConnectionPoint;
        /**
         * Gets the z component
         */
        get z(): NodeMaterialConnectionPoint;
        /**
         * Gets the w component
         */
        get output(): NodeMaterialConnectionPoint;
        protected writeOutputs(state: NodeMaterialBuildState): string;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to get the screen sizes
     */
    export class ScreenSizeBlock extends NodeMaterialBlock {
        private _varName;
        private _scene;
        /**
         * Creates a new ScreenSizeBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the xy component
         */
        get xy(): NodeMaterialConnectionPoint;
        /**
         * Gets the x component
         */
        get x(): NodeMaterialConnectionPoint;
        /**
         * Gets the y component
         */
        get y(): NodeMaterialConnectionPoint;
        bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh): void;
        protected writeOutputs(state: NodeMaterialBuildState, varName: string): string;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to add support for scene fog
     */
    export class FogBlock extends NodeMaterialBlock {
        private _fogDistanceName;
        private _fogParameters;
        /**
         * Create a new FogBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the world position input component
         */
        get worldPosition(): NodeMaterialConnectionPoint;
        /**
         * Gets the view input component
         */
        get view(): NodeMaterialConnectionPoint;
        /**
         * Gets the color input component
         */
        get input(): NodeMaterialConnectionPoint;
        /**
         * Gets the fog color input component
         */
        get fogColor(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        autoConfigure(material: NodeMaterial): void;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
        bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh): void;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to add light in the fragment shader
     */
    export class LightBlock extends NodeMaterialBlock {
        private _lightId;
        /**
         * Gets or sets the light associated with this block
         */
        light: Nullable<Light>;
        /**
         * Create a new LightBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the world position input component
         */
        get worldPosition(): NodeMaterialConnectionPoint;
        /**
         * Gets the world normal input component
         */
        get worldNormal(): NodeMaterialConnectionPoint;
        /**
        * Gets the camera (or eye) position component
        */
        get cameraPosition(): NodeMaterialConnectionPoint;
        /**
        * Gets the glossiness component
        */
        get glossiness(): NodeMaterialConnectionPoint;
        /**
        * Gets the glossinness power component
        */
        get glossPower(): NodeMaterialConnectionPoint;
        /**
        * Gets the diffuse color component
        */
        get diffuseColor(): NodeMaterialConnectionPoint;
        /**
        * Gets the specular color component
        */
        get specularColor(): NodeMaterialConnectionPoint;
        /**
         * Gets the diffuse output component
         */
        get diffuseOutput(): NodeMaterialConnectionPoint;
        /**
         * Gets the specular output component
         */
        get specularOutput(): NodeMaterialConnectionPoint;
        /**
         * Gets the shadow output component
         */
        get shadow(): NodeMaterialConnectionPoint;
        autoConfigure(material: NodeMaterial): void;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
        updateUniformsAndSamples(state: NodeMaterialBuildState, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, uniformBuffers: string[]): void;
        bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh): void;
        private _injectVertexCode;
        protected _buildBlock(state: NodeMaterialBuildState): this | undefined;
        serialize(): any;
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * Block used to read a reflection texture from a sampler
     */
    export class ReflectionTextureBlock extends ReflectionTextureBaseBlock {
        /**
         * Create a new ReflectionTextureBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the world position input component
         */
        get position(): NodeMaterialConnectionPoint;
        /**
         * Gets the world position input component
         */
        get worldPosition(): NodeMaterialConnectionPoint;
        /**
         * Gets the world normal input component
         */
        get worldNormal(): NodeMaterialConnectionPoint;
        /**
         * Gets the world input component
         */
        get world(): NodeMaterialConnectionPoint;
        /**
        * Gets the camera (or eye) position component
        */
        get cameraPosition(): NodeMaterialConnectionPoint;
        /**
         * Gets the view input component
         */
        get view(): NodeMaterialConnectionPoint;
        /**
         * Gets the rgb output component
         */
        get rgb(): NodeMaterialConnectionPoint;
        /**
         * Gets the rgba output component
         */
        get rgba(): NodeMaterialConnectionPoint;
        /**
         * Gets the r output component
         */
        get r(): NodeMaterialConnectionPoint;
        /**
         * Gets the g output component
         */
        get g(): NodeMaterialConnectionPoint;
        /**
         * Gets the b output component
         */
        get b(): NodeMaterialConnectionPoint;
        /**
         * Gets the a output component
         */
        get a(): NodeMaterialConnectionPoint;
        autoConfigure(material: NodeMaterial): void;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to add 2 vectors
     */
    export class AddBlock extends NodeMaterialBlock {
        /**
         * Creates a new AddBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the left operand input component
         */
        get left(): NodeMaterialConnectionPoint;
        /**
         * Gets the right operand input component
         */
        get right(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to scale a vector by a float
     */
    export class ScaleBlock extends NodeMaterialBlock {
        /**
         * Creates a new ScaleBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the input component
         */
        get input(): NodeMaterialConnectionPoint;
        /**
         * Gets the factor input component
         */
        get factor(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to clamp a float
     */
    export class ClampBlock extends NodeMaterialBlock {
        /** Gets or sets the minimum range */
        minimum: number;
        /** Gets or sets the maximum range */
        maximum: number;
        /**
         * Creates a new ClampBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the value input component
         */
        get value(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
        protected _dumpPropertiesCode(): string;
        serialize(): any;
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * Block used to apply a cross product between 2 vectors
     */
    export class CrossBlock extends NodeMaterialBlock {
        /**
         * Creates a new CrossBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the left operand input component
         */
        get left(): NodeMaterialConnectionPoint;
        /**
         * Gets the right operand input component
         */
        get right(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to apply a dot product between 2 vectors
     */
    export class DotBlock extends NodeMaterialBlock {
        /**
         * Creates a new DotBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the left operand input component
         */
        get left(): NodeMaterialConnectionPoint;
        /**
         * Gets the right operand input component
         */
        get right(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to normalize a vector
     */
    export class NormalizeBlock extends NodeMaterialBlock {
        /**
         * Creates a new NormalizeBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the input component
         */
        get input(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to create a Color3/4 out of individual inputs (one for each component)
     */
    export class ColorMergerBlock extends NodeMaterialBlock {
        /**
         * Create a new ColorMergerBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the rgb component (input)
         */
        get rgbIn(): NodeMaterialConnectionPoint;
        /**
         * Gets the r component (input)
         */
        get r(): NodeMaterialConnectionPoint;
        /**
         * Gets the g component (input)
         */
        get g(): NodeMaterialConnectionPoint;
        /**
         * Gets the b component (input)
         */
        get b(): NodeMaterialConnectionPoint;
        /**
         * Gets the a component (input)
         */
        get a(): NodeMaterialConnectionPoint;
        /**
         * Gets the rgba component (output)
         */
        get rgba(): NodeMaterialConnectionPoint;
        /**
         * Gets the rgb component (output)
         */
        get rgbOut(): NodeMaterialConnectionPoint;
        /**
         * Gets the rgb component (output)
         * @deprecated Please use rgbOut instead.
         */
        get rgb(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to expand a Vector3/4 into 4 outputs (one for each component)
     */
    export class VectorSplitterBlock extends NodeMaterialBlock {
        /**
         * Create a new VectorSplitterBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the xyzw component (input)
         */
        get xyzw(): NodeMaterialConnectionPoint;
        /**
         * Gets the xyz component (input)
         */
        get xyzIn(): NodeMaterialConnectionPoint;
        /**
         * Gets the xy component (input)
         */
        get xyIn(): NodeMaterialConnectionPoint;
        /**
         * Gets the xyz component (output)
         */
        get xyzOut(): NodeMaterialConnectionPoint;
        /**
         * Gets the xy component (output)
         */
        get xyOut(): NodeMaterialConnectionPoint;
        /**
         * Gets the x component (output)
         */
        get x(): NodeMaterialConnectionPoint;
        /**
         * Gets the y component (output)
         */
        get y(): NodeMaterialConnectionPoint;
        /**
         * Gets the z component (output)
         */
        get z(): NodeMaterialConnectionPoint;
        /**
         * Gets the w component (output)
         */
        get w(): NodeMaterialConnectionPoint;
        protected _inputRename(name: string): string;
        protected _outputRename(name: string): string;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to lerp between 2 values
     */
    export class LerpBlock extends NodeMaterialBlock {
        /**
         * Creates a new LerpBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the left operand input component
         */
        get left(): NodeMaterialConnectionPoint;
        /**
         * Gets the right operand input component
         */
        get right(): NodeMaterialConnectionPoint;
        /**
         * Gets the gradient operand input component
         */
        get gradient(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to divide 2 vectors
     */
    export class DivideBlock extends NodeMaterialBlock {
        /**
         * Creates a new DivideBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the left operand input component
         */
        get left(): NodeMaterialConnectionPoint;
        /**
         * Gets the right operand input component
         */
        get right(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to subtract 2 vectors
     */
    export class SubtractBlock extends NodeMaterialBlock {
        /**
         * Creates a new SubtractBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the left operand input component
         */
        get left(): NodeMaterialConnectionPoint;
        /**
         * Gets the right operand input component
         */
        get right(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to step a value
     */
    export class StepBlock extends NodeMaterialBlock {
        /**
         * Creates a new StepBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the value operand input component
         */
        get value(): NodeMaterialConnectionPoint;
        /**
         * Gets the edge operand input component
         */
        get edge(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to get the opposite (1 - x) of a value
     */
    export class OneMinusBlock extends NodeMaterialBlock {
        /**
         * Creates a new OneMinusBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the input component
         */
        get input(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to get the view direction
     */
    export class ViewDirectionBlock extends NodeMaterialBlock {
        /**
         * Creates a new ViewDirectionBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the world position component
         */
        get worldPosition(): NodeMaterialConnectionPoint;
        /**
         * Gets the camera position component
         */
        get cameraPosition(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        autoConfigure(material: NodeMaterial): void;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to compute fresnel value
     */
    export class FresnelBlock extends NodeMaterialBlock {
        /**
         * Create a new FresnelBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the world normal input component
         */
        get worldNormal(): NodeMaterialConnectionPoint;
        /**
        * Gets the view direction input component
        */
        get viewDirection(): NodeMaterialConnectionPoint;
        /**
        * Gets the bias input component
        */
        get bias(): NodeMaterialConnectionPoint;
        /**
        * Gets the camera (or eye) position component
        */
        get power(): NodeMaterialConnectionPoint;
        /**
         * Gets the fresnel output component
         */
        get fresnel(): NodeMaterialConnectionPoint;
        autoConfigure(material: NodeMaterial): void;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to get the max of 2 values
     */
    export class MaxBlock extends NodeMaterialBlock {
        /**
         * Creates a new MaxBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the left operand input component
         */
        get left(): NodeMaterialConnectionPoint;
        /**
         * Gets the right operand input component
         */
        get right(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to get the min of 2 values
     */
    export class MinBlock extends NodeMaterialBlock {
        /**
         * Creates a new MinBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the left operand input component
         */
        get left(): NodeMaterialConnectionPoint;
        /**
         * Gets the right operand input component
         */
        get right(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to get the distance between 2 values
     */
    export class DistanceBlock extends NodeMaterialBlock {
        /**
         * Creates a new DistanceBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the left operand input component
         */
        get left(): NodeMaterialConnectionPoint;
        /**
         * Gets the right operand input component
         */
        get right(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to get the length of a vector
     */
    export class LengthBlock extends NodeMaterialBlock {
        /**
         * Creates a new LengthBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the value input component
         */
        get value(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to get negative version of a value (i.e. x * -1)
     */
    export class NegateBlock extends NodeMaterialBlock {
        /**
         * Creates a new NegateBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the value input component
         */
        get value(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to get the value of the first parameter raised to the power of the second
     */
    export class PowBlock extends NodeMaterialBlock {
        /**
         * Creates a new PowBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the value operand input component
         */
        get value(): NodeMaterialConnectionPoint;
        /**
         * Gets the power operand input component
         */
        get power(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to get a random number
     */
    export class RandomNumberBlock extends NodeMaterialBlock {
        /**
         * Creates a new RandomNumberBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the seed input component
         */
        get seed(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to compute arc tangent of 2 values
     */
    export class ArcTan2Block extends NodeMaterialBlock {
        /**
         * Creates a new ArcTan2Block
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the x operand input component
         */
        get x(): NodeMaterialConnectionPoint;
        /**
         * Gets the y operand input component
         */
        get y(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to smooth step a value
     */
    export class SmoothStepBlock extends NodeMaterialBlock {
        /**
         * Creates a new SmoothStepBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the value operand input component
         */
        get value(): NodeMaterialConnectionPoint;
        /**
         * Gets the first edge operand input component
         */
        get edge0(): NodeMaterialConnectionPoint;
        /**
         * Gets the second edge operand input component
         */
        get edge1(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to get the reciprocal (1 / x) of a value
     */
    export class ReciprocalBlock extends NodeMaterialBlock {
        /**
         * Creates a new ReciprocalBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the input component
         */
        get input(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to replace a color by another one
     */
    export class ReplaceColorBlock extends NodeMaterialBlock {
        /**
         * Creates a new ReplaceColorBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the value input component
         */
        get value(): NodeMaterialConnectionPoint;
        /**
         * Gets the reference input component
         */
        get reference(): NodeMaterialConnectionPoint;
        /**
         * Gets the distance input component
         */
        get distance(): NodeMaterialConnectionPoint;
        /**
         * Gets the replacement input component
         */
        get replacement(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to posterize a value
     * @see https://en.wikipedia.org/wiki/Posterization
     */
    export class PosterizeBlock extends NodeMaterialBlock {
        /**
         * Creates a new PosterizeBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the value input component
         */
        get value(): NodeMaterialConnectionPoint;
        /**
         * Gets the steps input component
         */
        get steps(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Operations supported by the Wave block
     */
    export enum WaveBlockKind {
        /** SawTooth */
        SawTooth = 0,
        /** Square */
        Square = 1,
        /** Triangle */
        Triangle = 2
    }
    /**
     * Block used to apply wave operation to floats
     */
    export class WaveBlock extends NodeMaterialBlock {
        /**
         * Gets or sets the kibnd of wave to be applied by the block
         */
        kind: WaveBlockKind;
        /**
         * Creates a new WaveBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the input component
         */
        get input(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
        serialize(): any;
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * Class used to store a color step for the GradientBlock
     */
    export class GradientBlockColorStep {
        private _step;
        /**
         * Gets value indicating which step this color is associated with (between 0 and 1)
         */
        get step(): number;
        /**
         * Sets a value indicating which step this color is associated with (between 0 and 1)
        */
        set step(val: number);
        private _color;
        /**
         * Gets the color associated with this step
         */
        get color(): Color3;
        /**
         * Sets the color associated with this step
         */
        set color(val: Color3);
        /**
         * Creates a new GradientBlockColorStep
         * @param step defines a value indicating which step this color is associated with (between 0 and 1)
         * @param color defines the color associated with this step
         */
        constructor(step: number, color: Color3);
    }
    /**
     * Block used to return a color from a gradient based on an input value between 0 and 1
     */
    export class GradientBlock extends NodeMaterialBlock {
        /**
         * Gets or sets the list of color steps
         */
        colorSteps: GradientBlockColorStep[];
        /** Gets an observable raised when the value is changed */
        onValueChangedObservable: Observable<GradientBlock>;
        /** calls observable when the value is changed*/
        colorStepsUpdated(): void;
        /**
         * Creates a new GradientBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the gradient input component
         */
        get gradient(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        private _writeColorConstant;
        protected _buildBlock(state: NodeMaterialBuildState): this | undefined;
        serialize(): any;
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
        protected _dumpPropertiesCode(): string;
    }
}
declare module BABYLON {
    /**
     * Block used to normalize lerp between 2 values
     */
    export class NLerpBlock extends NodeMaterialBlock {
        /**
         * Creates a new NLerpBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the left operand input component
         */
        get left(): NodeMaterialConnectionPoint;
        /**
         * Gets the right operand input component
         */
        get right(): NodeMaterialConnectionPoint;
        /**
         * Gets the gradient operand input component
         */
        get gradient(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * block used to Generate a Worley Noise 3D Noise Pattern
     */
    export class WorleyNoise3DBlock extends NodeMaterialBlock {
        /** Gets or sets a boolean indicating that normal should be inverted on X axis */
        manhattanDistance: boolean;
        /**
         * Creates a new WorleyNoise3DBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the seed input component
         */
        get seed(): NodeMaterialConnectionPoint;
        /**
         * Gets the jitter input component
         */
        get jitter(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this | undefined;
        /**
         * Exposes the properties to the UI?
         */
        protected _dumpPropertiesCode(): string;
        /**
         * Exposes the properties to the Seralize?
         */
        serialize(): any;
        /**
         * Exposes the properties to the deseralize?
         */
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * block used to Generate a Simplex Perlin 3d Noise Pattern
     */
    export class SimplexPerlin3DBlock extends NodeMaterialBlock {
        /**
         * Creates a new SimplexPerlin3DBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the seed operand input component
         */
        get seed(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this | undefined;
    }
}
declare module BABYLON {
    /**
     * Block used to blend normals
     */
    export class NormalBlendBlock extends NodeMaterialBlock {
        /**
         * Creates a new NormalBlendBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the first input component
         */
        get normalMap0(): NodeMaterialConnectionPoint;
        /**
         * Gets the second input component
         */
        get normalMap1(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to rotate a 2d vector by a given angle
     */
    export class Rotate2dBlock extends NodeMaterialBlock {
        /**
         * Creates a new Rotate2dBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the input vector
         */
        get input(): NodeMaterialConnectionPoint;
        /**
         * Gets the input angle
         */
        get angle(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        autoConfigure(material: NodeMaterial): void;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to get the reflected vector from a direction and a normal
     */
    export class ReflectBlock extends NodeMaterialBlock {
        /**
         * Creates a new ReflectBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the incident component
         */
        get incident(): NodeMaterialConnectionPoint;
        /**
         * Gets the normal component
         */
        get normal(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to get the refracted vector from a direction and a normal
     */
    export class RefractBlock extends NodeMaterialBlock {
        /**
         * Creates a new RefractBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the incident component
         */
        get incident(): NodeMaterialConnectionPoint;
        /**
         * Gets the normal component
         */
        get normal(): NodeMaterialConnectionPoint;
        /**
         * Gets the index of refraction component
         */
        get ior(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to desaturate a color
     */
    export class DesaturateBlock extends NodeMaterialBlock {
        /**
         * Creates a new DesaturateBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the color operand input component
         */
        get color(): NodeMaterialConnectionPoint;
        /**
         * Gets the level operand input component
         */
        get level(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to implement the ambient occlusion module of the PBR material
     */
    export class AmbientOcclusionBlock extends NodeMaterialBlock {
        /**
         * Create a new AmbientOcclusionBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Specifies if the ambient texture contains the ambient occlusion information in its red channel only.
         */
        useAmbientInGrayScale: boolean;
        /**
         * Initialize the block and prepare the context for build
         * @param state defines the state that will be used for the build
         */
        initialize(state: NodeMaterialBuildState): void;
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the texture input component
         */
        get texture(): NodeMaterialConnectionPoint;
        /**
         * Gets the texture intensity component
         */
        get intensity(): NodeMaterialConnectionPoint;
        /**
         * Gets the direct light intensity input component
         */
        get directLightIntensity(): NodeMaterialConnectionPoint;
        /**
         * Gets the ambient occlusion object output component
         */
        get ambientOcclusion(): NodeMaterialConnectionPoint;
        /**
         * Gets the main code of the block (fragment side)
         * @param block instance of an AmbientOcclusionBlock or null if the code must be generated without an active ambient occlusion module
         * @returns the shader code
         */
        static GetCode(block: Nullable<AmbientOcclusionBlock>): string;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
        protected _buildBlock(state: NodeMaterialBuildState): this;
        protected _dumpPropertiesCode(): string;
        serialize(): any;
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * Block used to implement the reflection module of the PBR material
     */
    export class ReflectionBlock extends ReflectionTextureBaseBlock {
        /** @hidden */
        _defineLODReflectionAlpha: string;
        /** @hidden */
        _defineLinearSpecularReflection: string;
        private _vEnvironmentIrradianceName;
        /** @hidden */
        _vReflectionMicrosurfaceInfosName: string;
        /** @hidden */
        _vReflectionInfosName: string;
        /** @hidden */
        _vReflectionFilteringInfoName: string;
        private _scene;
        /**
         * The three properties below are set by the main PBR block prior to calling methods of this class.
         * This is to avoid having to add them as inputs here whereas they are already inputs of the main block, so already known.
         * It's less burden on the user side in the editor part.
        */
        /** @hidden */
        worldPositionConnectionPoint: NodeMaterialConnectionPoint;
        /** @hidden */
        worldNormalConnectionPoint: NodeMaterialConnectionPoint;
        /** @hidden */
        cameraPositionConnectionPoint: NodeMaterialConnectionPoint;
        /**
         * Defines if the material uses spherical harmonics vs spherical polynomials for the
         * diffuse part of the IBL.
         */
        useSphericalHarmonics: boolean;
        /**
         * Force the shader to compute irradiance in the fragment shader in order to take bump in account.
         */
        forceIrradianceInFragment: boolean;
        /**
         * Create a new ReflectionBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the position input component
         */
        get position(): NodeMaterialConnectionPoint;
        /**
         * Gets the world position input component
         */
        get worldPosition(): NodeMaterialConnectionPoint;
        /**
         * Gets the world normal input component
         */
        get worldNormal(): NodeMaterialConnectionPoint;
        /**
         * Gets the world input component
         */
        get world(): NodeMaterialConnectionPoint;
        /**
        * Gets the camera (or eye) position component
        */
        get cameraPosition(): NodeMaterialConnectionPoint;
        /**
         * Gets the view input component
         */
        get view(): NodeMaterialConnectionPoint;
        /**
         * Gets the color input component
         */
        get color(): NodeMaterialConnectionPoint;
        /**
         * Gets the reflection object output component
         */
        get reflection(): NodeMaterialConnectionPoint;
        /**
         * Returns true if the block has a texture (either its own texture or the environment texture from the scene, if set)
         */
        get hasTexture(): boolean;
        /**
         * Gets the reflection color (either the name of the variable if the color input is connected, else a default value)
         */
        get reflectionColor(): string;
        protected _getTexture(): Nullable<BaseTexture>;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
        bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh, subMesh?: SubMesh): void;
        /**
         * Gets the code to inject in the vertex shader
         * @param state current state of the node material building
         * @returns the shader code
         */
        handleVertexSide(state: NodeMaterialBuildState): string;
        /**
         * Gets the main code of the block (fragment side)
         * @param state current state of the node material building
         * @param normalVarName name of the existing variable corresponding to the normal
         * @returns the shader code
         */
        getCode(state: NodeMaterialBuildState, normalVarName: string): string;
        protected _buildBlock(state: NodeMaterialBuildState): this;
        protected _dumpPropertiesCode(): string;
        serialize(): any;
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * Block used to implement the sheen module of the PBR material
     */
    export class SheenBlock extends NodeMaterialBlock {
        /**
         * Create a new SheenBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * If true, the sheen effect is layered above the base BRDF with the albedo-scaling technique.
         * It allows the strength of the sheen effect to not depend on the base color of the material,
         * making it easier to setup and tweak the effect
         */
        albedoScaling: boolean;
        /**
         * Defines if the sheen is linked to the sheen color.
         */
        linkSheenWithAlbedo: boolean;
        /**
         * Initialize the block and prepare the context for build
         * @param state defines the state that will be used for the build
         */
        initialize(state: NodeMaterialBuildState): void;
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the intensity input component
         */
        get intensity(): NodeMaterialConnectionPoint;
        /**
         * Gets the color input component
         */
        get color(): NodeMaterialConnectionPoint;
        /**
         * Gets the roughness input component
         */
        get roughness(): NodeMaterialConnectionPoint;
        /**
         * Gets the sheen object output component
         */
        get sheen(): NodeMaterialConnectionPoint;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
        /**
         * Gets the main code of the block (fragment side)
         * @param reflectionBlock instance of a ReflectionBlock null if the code must be generated without an active reflection module
         * @returns the shader code
         */
        getCode(reflectionBlock: Nullable<ReflectionBlock>): string;
        protected _buildBlock(state: NodeMaterialBuildState): this;
        protected _dumpPropertiesCode(): string;
        serialize(): any;
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * Block used to implement the reflectivity module of the PBR material
     */
    export class ReflectivityBlock extends NodeMaterialBlock {
        private _metallicReflectanceColor;
        private _metallicF0Factor;
        /** @hidden */
        _vMetallicReflectanceFactorsName: string;
        /**
         * The property below is set by the main PBR block prior to calling methods of this class.
        */
        /** @hidden */
        indexOfRefractionConnectionPoint: Nullable<NodeMaterialConnectionPoint>;
        /**
         * Specifies if the metallic texture contains the ambient occlusion information in its red channel.
         */
        useAmbientOcclusionFromMetallicTextureRed: boolean;
        /**
         * Specifies if the metallic texture contains the metallness information in its blue channel.
         */
        useMetallnessFromMetallicTextureBlue: boolean;
        /**
         * Specifies if the metallic texture contains the roughness information in its alpha channel.
         */
        useRoughnessFromMetallicTextureAlpha: boolean;
        /**
         * Specifies if the metallic texture contains the roughness information in its green channel.
         */
        useRoughnessFromMetallicTextureGreen: boolean;
        /**
         * Create a new ReflectivityBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Initialize the block and prepare the context for build
         * @param state defines the state that will be used for the build
         */
        initialize(state: NodeMaterialBuildState): void;
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the metallic input component
         */
        get metallic(): NodeMaterialConnectionPoint;
        /**
         * Gets the roughness input component
         */
        get roughness(): NodeMaterialConnectionPoint;
        /**
         * Gets the texture input component
         */
        get texture(): NodeMaterialConnectionPoint;
        /**
         * Gets the reflectivity object output component
         */
        get reflectivity(): NodeMaterialConnectionPoint;
        bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh, subMesh?: SubMesh): void;
        /**
         * Gets the main code of the block (fragment side)
         * @param state current state of the node material building
         * @param aoIntensityVarName name of the variable with the ambient occlusion intensity
         * @returns the shader code
         */
        getCode(state: NodeMaterialBuildState, aoIntensityVarName: string): string;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
        protected _buildBlock(state: NodeMaterialBuildState): this;
        protected _dumpPropertiesCode(): string;
        serialize(): any;
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * Block used to implement the anisotropy module of the PBR material
     */
    export class AnisotropyBlock extends NodeMaterialBlock {
        /**
         * The two properties below are set by the main PBR block prior to calling methods of this class.
         * This is to avoid having to add them as inputs here whereas they are already inputs of the main block, so already known.
         * It's less burden on the user side in the editor part.
        */
        /** @hidden */
        worldPositionConnectionPoint: NodeMaterialConnectionPoint;
        /** @hidden */
        worldNormalConnectionPoint: NodeMaterialConnectionPoint;
        /**
         * Create a new AnisotropyBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Initialize the block and prepare the context for build
         * @param state defines the state that will be used for the build
         */
        initialize(state: NodeMaterialBuildState): void;
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the intensity input component
         */
        get intensity(): NodeMaterialConnectionPoint;
        /**
         * Gets the direction input component
         */
        get direction(): NodeMaterialConnectionPoint;
        /**
         * Gets the texture input component
         */
        get texture(): NodeMaterialConnectionPoint;
        /**
         * Gets the uv input component
         */
        get uv(): NodeMaterialConnectionPoint;
        /**
         * Gets the worldTangent input component
         */
        get worldTangent(): NodeMaterialConnectionPoint;
        /**
         * Gets the anisotropy object output component
         */
        get anisotropy(): NodeMaterialConnectionPoint;
        private _generateTBNSpace;
        /**
         * Gets the main code of the block (fragment side)
         * @param state current state of the node material building
         * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated
         * @returns the shader code
         */
        getCode(state: NodeMaterialBuildState, generateTBNSpace?: boolean): string;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to implement the clear coat module of the PBR material
     */
    export class ClearCoatBlock extends NodeMaterialBlock {
        private _scene;
        /**
         * Create a new ClearCoatBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Initialize the block and prepare the context for build
         * @param state defines the state that will be used for the build
         */
        initialize(state: NodeMaterialBuildState): void;
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the intensity input component
         */
        get intensity(): NodeMaterialConnectionPoint;
        /**
         * Gets the roughness input component
         */
        get roughness(): NodeMaterialConnectionPoint;
        /**
         * Gets the ior input component
         */
        get ior(): NodeMaterialConnectionPoint;
        /**
         * Gets the texture input component
         */
        get texture(): NodeMaterialConnectionPoint;
        /**
         * Gets the bump texture input component
         */
        get bumpTexture(): NodeMaterialConnectionPoint;
        /**
         * Gets the uv input component
         */
        get uv(): NodeMaterialConnectionPoint;
        /**
         * Gets the tint color input component
         */
        get tintColor(): NodeMaterialConnectionPoint;
        /**
         * Gets the tint "at distance" input component
         */
        get tintAtDistance(): NodeMaterialConnectionPoint;
        /**
         * Gets the tint thickness input component
         */
        get tintThickness(): NodeMaterialConnectionPoint;
        /**
         * Gets the world tangent input component
         */
        get worldTangent(): NodeMaterialConnectionPoint;
        /**
         * Gets the clear coat object output component
         */
        get clearcoat(): NodeMaterialConnectionPoint;
        autoConfigure(material: NodeMaterial): void;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
        bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh, subMesh?: SubMesh): void;
        private _generateTBNSpace;
        /**
         * Gets the main code of the block (fragment side)
         * @param state current state of the node material building
         * @param ccBlock instance of a ClearCoatBlock or null if the code must be generated without an active clear coat module
         * @param reflectionBlock instance of a ReflectionBlock null if the code must be generated without an active reflection module
         * @param worldPosVarName name of the variable holding the world position
         * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated
         * @param vTBNAvailable indicate that the vTBN variable is already existing because it has already been generated by another block (PerturbNormal or Anisotropy)
         * @param worldNormalVarName name of the variable holding the world normal
         * @returns the shader code
         */
        static GetCode(state: NodeMaterialBuildState, ccBlock: Nullable<ClearCoatBlock>, reflectionBlock: Nullable<ReflectionBlock>, worldPosVarName: string, generateTBNSpace: boolean, vTBNAvailable: boolean, worldNormalVarName: string): string;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to implement the sub surface module of the PBR material
     */
    export class SubSurfaceBlock extends NodeMaterialBlock {
        /**
         * Create a new SubSurfaceBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Stores the intensity of the different subsurface effects in the thickness texture.
         * * the green channel is the translucency intensity.
         * * the blue channel is the scattering intensity.
         * * the alpha channel is the refraction intensity.
         */
        useMaskFromThicknessTexture: boolean;
        /**
         * Initialize the block and prepare the context for build
         * @param state defines the state that will be used for the build
         */
        initialize(state: NodeMaterialBuildState): void;
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the min thickness input component
         */
        get minThickness(): NodeMaterialConnectionPoint;
        /**
         * Gets the max thickness input component
         */
        get maxThickness(): NodeMaterialConnectionPoint;
        /**
         * Gets the thickness texture component
         */
        get thicknessTexture(): NodeMaterialConnectionPoint;
        /**
         * Gets the tint color input component
         */
        get tintColor(): NodeMaterialConnectionPoint;
        /**
         * Gets the translucency intensity input component
         */
        get translucencyIntensity(): NodeMaterialConnectionPoint;
        /**
         * Gets the translucency diffusion distance input component
         */
        get translucencyDiffusionDistance(): NodeMaterialConnectionPoint;
        /**
         * Gets the refraction object parameters
         */
        get refraction(): NodeMaterialConnectionPoint;
        /**
         * Gets the sub surface object output component
         */
        get subsurface(): NodeMaterialConnectionPoint;
        autoConfigure(material: NodeMaterial): void;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
        /**
         * Gets the main code of the block (fragment side)
         * @param state current state of the node material building
         * @param ssBlock instance of a SubSurfaceBlock or null if the code must be generated without an active sub surface module
         * @param reflectionBlock instance of a ReflectionBlock null if the code must be generated without an active reflection module
         * @param worldPosVarName name of the variable holding the world position
         * @returns the shader code
         */
        static GetCode(state: NodeMaterialBuildState, ssBlock: Nullable<SubSurfaceBlock>, reflectionBlock: Nullable<ReflectionBlock>, worldPosVarName: string): string;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Block used to implement the PBR metallic/roughness model
     */
    export class PBRMetallicRoughnessBlock extends NodeMaterialBlock {
        /**
         * Gets or sets the light associated with this block
         */
        light: Nullable<Light>;
        private _lightId;
        private _scene;
        private _environmentBRDFTexture;
        private _environmentBrdfSamplerName;
        private _vNormalWName;
        private _invertNormalName;
        /**
         * Create a new ReflectionBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Intensity of the direct lights e.g. the four lights available in your scene.
         * This impacts both the direct diffuse and specular highlights.
         */
        directIntensity: number;
        /**
         * Intensity of the environment e.g. how much the environment will light the object
         * either through harmonics for rough material or through the refelction for shiny ones.
         */
        environmentIntensity: number;
        /**
         * This is a special control allowing the reduction of the specular highlights coming from the
         * four lights of the scene. Those highlights may not be needed in full environment lighting.
         */
        specularIntensity: number;
        /**
         * Defines the  falloff type used in this material.
         * It by default is Physical.
         */
        lightFalloff: number;
        /**
         * Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.
         */
        useAlphaFromAlbedoTexture: boolean;
        /**
         * Specifies that alpha test should be used
         */
        useAlphaTest: boolean;
        /**
         * Defines the alpha limits in alpha test mode.
         */
        alphaTestCutoff: number;
        /**
         * Specifies that alpha blending should be used
         */
        useAlphaBlending: boolean;
        /**
         * Defines if the alpha value should be determined via the rgb values.
         * If true the luminance of the pixel might be used to find the corresponding alpha value.
         */
        opacityRGB: boolean;
        /**
         * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most luminous ones).
         * A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.
         */
        useRadianceOverAlpha: boolean;
        /**
         * Specifies that the material will keeps the specular highlights over a transparent surface (only the most luminous ones).
         * A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.
         */
        useSpecularOverAlpha: boolean;
        /**
         * Enables specular anti aliasing in the PBR shader.
         * It will both interacts on the Geometry for analytical and IBL lighting.
         * It also prefilter the roughness map based on the bump values.
         */
        enableSpecularAntiAliasing: boolean;
        /**
         * Enables realtime filtering on the texture.
         */
        realTimeFiltering: boolean;
        /**
         * Quality switch for realtime filtering
         */
        realTimeFilteringQuality: number;
        /**
         * Defines if the material uses energy conservation.
         */
        useEnergyConservation: boolean;
        /**
         * This parameters will enable/disable radiance occlusion by preventing the radiance to lit
         * too much the area relying on ambient texture to define their ambient occlusion.
         */
        useRadianceOcclusion: boolean;
        /**
         * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal
         * makes the reflect vector face the model (under horizon).
         */
        useHorizonOcclusion: boolean;
        /**
         * If set to true, no lighting calculations will be applied.
         */
        unlit: boolean;
        /**
         * Force normal to face away from face.
         */
        forceNormalForward: boolean;
        /**
         * Defines the material debug mode.
         * It helps seeing only some components of the material while troubleshooting.
         */
        debugMode: number;
        /**
         * Specify from where on screen the debug mode should start.
         * The value goes from -1 (full screen) to 1 (not visible)
         * It helps with side by side comparison against the final render
         * This defaults to 0
         */
        debugLimit: number;
        /**
         * As the default viewing range might not be enough (if the ambient is really small for instance)
         * You can use the factor to better multiply the final value.
         */
        debugFactor: number;
        /**
         * Initialize the block and prepare the context for build
         * @param state defines the state that will be used for the build
         */
        initialize(state: NodeMaterialBuildState): void;
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the world position input component
         */
        get worldPosition(): NodeMaterialConnectionPoint;
        /**
         * Gets the world normal input component
         */
        get worldNormal(): NodeMaterialConnectionPoint;
        /**
         * Gets the perturbed normal input component
         */
        get perturbedNormal(): NodeMaterialConnectionPoint;
        /**
         * Gets the camera position input component
         */
        get cameraPosition(): NodeMaterialConnectionPoint;
        /**
         * Gets the base color input component
         */
        get baseColor(): NodeMaterialConnectionPoint;
        /**
         * Gets the opacity texture input component
         */
        get opacityTexture(): NodeMaterialConnectionPoint;
        /**
         * Gets the ambient color input component
         */
        get ambientColor(): NodeMaterialConnectionPoint;
        /**
         * Gets the reflectivity object parameters
         */
        get reflectivity(): NodeMaterialConnectionPoint;
        /**
         * Gets the ambient occlusion object parameters
         */
        get ambientOcclusion(): NodeMaterialConnectionPoint;
        /**
         * Gets the reflection object parameters
         */
        get reflection(): NodeMaterialConnectionPoint;
        /**
         * Gets the sheen object parameters
         */
        get sheen(): NodeMaterialConnectionPoint;
        /**
         * Gets the clear coat object parameters
         */
        get clearcoat(): NodeMaterialConnectionPoint;
        /**
         * Gets the sub surface object parameters
         */
        get subsurface(): NodeMaterialConnectionPoint;
        /**
         * Gets the anisotropy object parameters
         */
        get anisotropy(): NodeMaterialConnectionPoint;
        /**
         * Gets the ambient output component
         */
        get ambient(): NodeMaterialConnectionPoint;
        /**
         * Gets the diffuse output component
         */
        get diffuse(): NodeMaterialConnectionPoint;
        /**
         * Gets the specular output component
         */
        get specular(): NodeMaterialConnectionPoint;
        /**
         * Gets the sheen output component
         */
        get sheenDir(): NodeMaterialConnectionPoint;
        /**
         * Gets the clear coat output component
         */
        get clearcoatDir(): NodeMaterialConnectionPoint;
        /**
         * Gets the indirect diffuse output component
         */
        get diffuseIndirect(): NodeMaterialConnectionPoint;
        /**
         * Gets the indirect specular output component
         */
        get specularIndirect(): NodeMaterialConnectionPoint;
        /**
         * Gets the indirect sheen output component
         */
        get sheenIndirect(): NodeMaterialConnectionPoint;
        /**
         * Gets the indirect clear coat output component
         */
        get clearcoatIndirect(): NodeMaterialConnectionPoint;
        /**
         * Gets the refraction output component
         */
        get refraction(): NodeMaterialConnectionPoint;
        /**
         * Gets the global lighting output component
         */
        get lighting(): NodeMaterialConnectionPoint;
        /**
         * Gets the shadow output component
         */
        get shadow(): NodeMaterialConnectionPoint;
        /**
         * Gets the alpha output component
         */
        get alpha(): NodeMaterialConnectionPoint;
        autoConfigure(material: NodeMaterial): void;
        prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines): void;
        updateUniformsAndSamples(state: NodeMaterialBuildState, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, uniformBuffers: string[]): void;
        bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh): void;
        private _injectVertexCode;
        /**
         * Gets the code corresponding to the albedo/opacity module
         * @returns the shader code
         */
        getAlbedoOpacityCode(): string;
        protected _buildBlock(state: NodeMaterialBuildState): this;
        protected _dumpPropertiesCode(): string;
        serialize(): any;
        _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
    }
}
declare module BABYLON {
    /**
     * Block used to compute value of one parameter modulo another
     */
    export class ModBlock extends NodeMaterialBlock {
        /**
         * Creates a new ModBlock
         * @param name defines the block name
         */
        constructor(name: string);
        /**
         * Gets the current class name
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Gets the left operand input component
         */
        get left(): NodeMaterialConnectionPoint;
        /**
         * Gets the right operand input component
         */
        get right(): NodeMaterialConnectionPoint;
        /**
         * Gets the output component
         */
        get output(): NodeMaterialConnectionPoint;
        protected _buildBlock(state: NodeMaterialBuildState): this;
    }
}
declare module BABYLON {
    /**
     * Configuration for Draco compression
     */
    export interface IDracoCompressionConfiguration {
        /**
         * Configuration for the decoder.
         */
        decoder: {
            /**
             * The url to the WebAssembly module.
             */
            wasmUrl?: string;
            /**
             * The url to the WebAssembly binary.
             */
            wasmBinaryUrl?: string;
            /**
             * The url to the fallback JavaScript module.
             */
            fallbackUrl?: string;
        };
    }
    /**
     * Draco compression (https://google.github.io/draco/)
     *
     * This class wraps the Draco module.
     *
     * **Encoder**
     *
     * The encoder is not currently implemented.
     *
     * **Decoder**
     *
     * By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.
     *
     * To update the configuration, use the following code:
     * ```javascript
     *     DracoCompression.Configuration = {
     *         decoder: {
     *             wasmUrl: "<url to the WebAssembly library>",
     *             wasmBinaryUrl: "<url to the WebAssembly binary>",
     *             fallbackUrl: "<url to the fallback JavaScript library>",
     *         }
     *     };
     * ```
     *
     * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support Webssembly or only support the JavaScript version.
     * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.
     * Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.
     *
     * To decode Draco compressed data, get the default DracoCompression object and call decodeMeshAsync:
     * ```javascript
     *     var vertexData = await DracoCompression.Default.decodeMeshAsync(data);
     * ```
     *
     * @see https://www.babylonjs-playground.com/#N3EK4B#0
     */
    export class DracoCompression implements IDisposable {
        private _workerPoolPromise?;
        private _decoderModulePromise?;
        /**
         * The configuration. Defaults to the following urls:
         * - wasmUrl: "https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js"
         * - wasmBinaryUrl: "https://preview.babylonjs.com/draco_decoder_gltf.wasm"
         * - fallbackUrl: "https://preview.babylonjs.com/draco_decoder_gltf.js"
         */
        static Configuration: IDracoCompressionConfiguration;
        /**
         * Returns true if the decoder configuration is available.
         */
        static get DecoderAvailable(): boolean;
        /**
         * Default number of workers to create when creating the draco compression object.
         */
        static DefaultNumWorkers: number;
        private static GetDefaultNumWorkers;
        private static _Default;
        /**
         * Default instance for the draco compression object.
         */
        static get Default(): DracoCompression;
        /**
         * Constructor
         * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.
         */
        constructor(numWorkers?: number);
        /**
         * Stop all async operations and release resources.
         */
        dispose(): void;
        /**
         * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.
         * @returns a promise that resolves when ready
         */
        whenReadyAsync(): Promise<void>;
        /**
          * Decode Draco compressed mesh data to vertex data.
          * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data
          * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids
          * @returns A promise that resolves with the decoded vertex data
          */
        decodeMeshAsync(data: ArrayBuffer | ArrayBufferView, attributes?: {
            [kind: string]: number;
        }): Promise<VertexData>;
    }
}
declare module BABYLON {
    /**
     * Class for building Constructive Solid Geometry
     */
    export class CSG {
        private polygons;
        /**
         * The world matrix
         */
        matrix: Matrix;
        /**
         * Stores the position
         */
        position: Vector3;
        /**
         * Stores the rotation
         */
        rotation: Vector3;
        /**
         * Stores the rotation quaternion
         */
        rotationQuaternion: Nullable<Quaternion>;
        /**
         * Stores the scaling vector
         */
        scaling: Vector3;
        /**
         * Convert the Mesh to CSG
         * @param mesh The Mesh to convert to CSG
         * @returns A new CSG from the Mesh
         */
        static FromMesh(mesh: Mesh): CSG;
        /**
         * Construct a CSG solid from a list of `CSG.Polygon` instances.
         * @param polygons Polygons used to construct a CSG solid
         */
        private static FromPolygons;
        /**
         * Clones, or makes a deep copy, of the CSG
         * @returns A new CSG
         */
        clone(): CSG;
        /**
         * Unions this CSG with another CSG
         * @param csg The CSG to union against this CSG
         * @returns The unioned CSG
         */
        union(csg: CSG): CSG;
        /**
         * Unions this CSG with another CSG in place
         * @param csg The CSG to union against this CSG
         */
        unionInPlace(csg: CSG): void;
        /**
         * Subtracts this CSG with another CSG
         * @param csg The CSG to subtract against this CSG
         * @returns A new CSG
         */
        subtract(csg: CSG): CSG;
        /**
         * Subtracts this CSG with another CSG in place
         * @param csg The CSG to subtact against this CSG
         */
        subtractInPlace(csg: CSG): void;
        /**
         * Intersect this CSG with another CSG
         * @param csg The CSG to intersect against this CSG
         * @returns A new CSG
         */
        intersect(csg: CSG): CSG;
        /**
         * Intersects this CSG with another CSG in place
         * @param csg The CSG to intersect against this CSG
         */
        intersectInPlace(csg: CSG): void;
        /**
         * Return a new CSG solid with solid and empty space switched. This solid is
         * not modified.
         * @returns A new CSG solid with solid and empty space switched
         */
        inverse(): CSG;
        /**
         * Inverses the CSG in place
         */
        inverseInPlace(): void;
        /**
         * This is used to keep meshes transformations so they can be restored
         * when we build back a Babylon Mesh
         * NB : All CSG operations are performed in world coordinates
         * @param csg The CSG to copy the transform attributes from
         * @returns This CSG
         */
        copyTransformAttributes(csg: CSG): CSG;
        /**
         * Build Raw mesh from CSG
         * Coordinates here are in world space
         * @param name The name of the mesh geometry
         * @param scene The Scene
         * @param keepSubMeshes Specifies if the submeshes should be kept
         * @returns A new Mesh
         */
        buildMeshGeometry(name: string, scene?: Scene, keepSubMeshes?: boolean): Mesh;
        /**
         * Build Mesh from CSG taking material and transforms into account
         * @param name The name of the Mesh
         * @param material The material of the Mesh
         * @param scene The Scene
         * @param keepSubMeshes Specifies if submeshes should be kept
         * @returns The new Mesh
         */
        toMesh(name: string, material?: Nullable<Material>, scene?: Scene, keepSubMeshes?: boolean): Mesh;
    }
}
declare module BABYLON {
    /**
     * Class used to create a trail following a mesh
     */
    export class TrailMesh extends Mesh {
        private _generator;
        private _autoStart;
        private _running;
        private _diameter;
        private _length;
        private _sectionPolygonPointsCount;
        private _sectionVectors;
        private _sectionNormalVectors;
        private _beforeRenderObserver;
        /**
         * @constructor
         * @param name The value used by scene.getMeshByName() to do a lookup.
         * @param generator The mesh or transform node to generate a trail.
         * @param scene The scene to add this mesh to.
         * @param diameter Diameter of trailing mesh. Default is 1.
         * @param length Length of trailing mesh. Default is 60.
         * @param autoStart Automatically start trailing mesh. Default true.
         */
        constructor(name: string, generator: TransformNode, scene: Scene, diameter?: number, length?: number, autoStart?: boolean);
        /**
         * "TrailMesh"
         * @returns "TrailMesh"
         */
        getClassName(): string;
        private _createMesh;
        /**
         * Start trailing mesh.
         */
        start(): void;
        /**
         * Stop trailing mesh.
         */
        stop(): void;
        /**
         * Update trailing mesh geometry.
         */
        update(): void;
        /**
         * Returns a new TrailMesh object.
         * @param name is a string, the name given to the new mesh
         * @param newGenerator use new generator object for cloned trail mesh
         * @returns a new mesh
         */
        clone(name: string | undefined, newGenerator: TransformNode): TrailMesh;
        /**
         * Serializes this trail mesh
         * @param serializationObject object to write serialization to
         */
        serialize(serializationObject: any): void;
        /**
         * Parses a serialized trail mesh
         * @param parsedMesh the serialized mesh
         * @param scene the scene to create the trail mesh in
         * @returns the created trail mesh
         */
        static Parse(parsedMesh: any, scene: Scene): TrailMesh;
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class TiledBoxBuilder {
        /**
         * Creates a box mesh
         * faceTiles sets the pattern, tile size and number of tiles for a face     * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)
         * * Please read this tutorial : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the box mesh
         */
        static CreateTiledBox(name: string, options: {
            pattern?: number;
            width?: number;
            height?: number;
            depth?: number;
            tileSize?: number;
            tileWidth?: number;
            tileHeight?: number;
            alignHorizontal?: number;
            alignVertical?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            sideOrientation?: number;
            updatable?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class TorusKnotBuilder {
        /**
         * Creates a torus knot mesh
         * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)
         * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)
         * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)
         * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the torus knot mesh
         * @see  https://doc.babylonjs.com/how_to/set_shapes#torus-knot
         */
        static CreateTorusKnot(name: string, options: {
            radius?: number;
            tube?: number;
            radialSegments?: number;
            tubularSegments?: number;
            p?: number;
            q?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }, scene: any): Mesh;
    }
}
declare module BABYLON {
    /**
     * Polygon
     * @see https://doc.babylonjs.com/how_to/parametric_shapes#non-regular-polygon
     */
    export class Polygon {
        /**
         * Creates a rectangle
         * @param xmin bottom X coord
         * @param ymin bottom Y coord
         * @param xmax top X coord
         * @param ymax top Y coord
         * @returns points that make the resulting rectation
         */
        static Rectangle(xmin: number, ymin: number, xmax: number, ymax: number): Vector2[];
        /**
         * Creates a circle
         * @param radius radius of circle
         * @param cx scale in x
         * @param cy scale in y
         * @param numberOfSides number of sides that make up the circle
         * @returns points that make the resulting circle
         */
        static Circle(radius: number, cx?: number, cy?: number, numberOfSides?: number): Vector2[];
        /**
         * Creates a polygon from input string
         * @param input Input polygon data
         * @returns the parsed points
         */
        static Parse(input: string): Vector2[];
        /**
         * Starts building a polygon from x and y coordinates
         * @param x x coordinate
         * @param y y coordinate
         * @returns the started path2
         */
        static StartingAt(x: number, y: number): Path2;
    }
    /**
     * Builds a polygon
     * @see https://doc.babylonjs.com/how_to/polygonmeshbuilder
     */
    export class PolygonMeshBuilder {
        private _points;
        private _outlinepoints;
        private _holes;
        private _name;
        private _scene;
        private _epoints;
        private _eholes;
        private _addToepoint;
        /**
         * Babylon reference to the earcut plugin.
         */
        bjsEarcut: any;
        /**
         * Creates a PolygonMeshBuilder
         * @param name name of the builder
         * @param contours Path of the polygon
         * @param scene scene to add to when creating the mesh
         * @param earcutInjection can be used to inject your own earcut reference
         */
        constructor(name: string, contours: Path2 | Vector2[] | any, scene?: Scene, earcutInjection?: any);
        /**
         * Adds a whole within the polygon
         * @param hole Array of points defining the hole
         * @returns this
         */
        addHole(hole: Vector2[]): PolygonMeshBuilder;
        /**
         * Creates the polygon
         * @param updatable If the mesh should be updatable
         * @param depth The depth of the mesh created
         * @returns the created mesh
         */
        build(updatable?: boolean, depth?: number): Mesh;
        /**
         * Creates the polygon
         * @param depth The depth of the mesh created
         * @returns the created VertexData
         */
        buildVertexData(depth?: number): VertexData;
        /**
         * Adds a side to the polygon
         * @param positions points that make the polygon
         * @param normals normals of the polygon
         * @param uvs uvs of the polygon
         * @param indices indices of the polygon
         * @param bounds bounds of the polygon
         * @param points points of the polygon
         * @param depth depth of the polygon
         * @param flip flip of the polygon
         */
        private addSide;
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class PolygonBuilder {
        /**
         * Creates a polygon mesh
         * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh
         * * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors
         * * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)
         * * Remember you can only change the shape positions, not their number when updating a polygon
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @param earcutInjection can be used to inject your own earcut reference
         * @returns the polygon mesh
         */
        static CreatePolygon(name: string, options: {
            shape: Vector3[];
            holes?: Vector3[][];
            depth?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            wrap?: boolean;
        }, scene?: Nullable<Scene>, earcutInjection?: any): Mesh;
        /**
         * Creates an extruded polygon mesh, with depth in the Y direction.
         * * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)
         * @see https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @param earcutInjection can be used to inject your own earcut reference
         * @returns the polygon mesh
         */
        static ExtrudePolygon(name: string, options: {
            shape: Vector3[];
            holes?: Vector3[][];
            depth?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            wrap?: boolean;
        }, scene?: Nullable<Scene>, earcutInjection?: any): Mesh;
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class LatheBuilder {
        /**
         * Creates lathe mesh.
         * The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe
         * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero
         * * The parameter `radius` (positive float, default 1) is the radius value of the lathe
         * * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe
         * * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides
         * * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape
         * * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter "arc"
         * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the lathe mesh
         * @see https://doc.babylonjs.com/how_to/parametric_shapes#lathe
         */
        static CreateLathe(name: string, options: {
            shape: Vector3[];
            radius?: number;
            tessellation?: number;
            clip?: number;
            arc?: number;
            closed?: boolean;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            cap?: number;
            invertUV?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class TiledPlaneBuilder {
        /**
         * Creates a tiled plane mesh
         * * The parameter `pattern` will, depending on value, do nothing or
         * * * flip (reflect about central vertical) alternate tiles across and up
         * * * flip every tile on alternate rows
         * * * rotate (180 degs) alternate tiles across and up
         * * * rotate every tile on alternate rows
         * * * flip and rotate alternate tiles across and up
         * * * flip and rotate every tile on alternate rows
         * * The parameter `tileSize` sets the size (float) of each tile side (default 1)
         * * You can set some different tile dimensions by using the parameters `tileWidth` and `tileHeight` (both by default have the same value of `tileSize`)
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
         * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
         * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @see https://doc.babylonjs.com/how_to/set_shapes#box
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the box mesh
         */
        static CreateTiledPlane(name: string, options: {
            pattern?: number;
            tileSize?: number;
            tileWidth?: number;
            tileHeight?: number;
            size?: number;
            width?: number;
            height?: number;
            alignHorizontal?: number;
            alignVertical?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            updatable?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class TubeBuilder {
        /**
         * Creates a tube mesh.
         * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters
         * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube
         * * The parameter `radius` (positive float, default 1) sets the tube radius size
         * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface
         * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`
         * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)
         * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc
         * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
         * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#tube
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the tube mesh
         * @see https://doc.babylonjs.com/how_to/parametric_shapes
         * @see https://doc.babylonjs.com/how_to/set_shapes#tube
         */
        static CreateTube(name: string, options: {
            path: Vector3[];
            radius?: number;
            tessellation?: number;
            radiusFunction?: {
                (i: number, distance: number): number;
            };
            cap?: number;
            arc?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            instance?: Mesh;
            invertUV?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class IcoSphereBuilder {
        /**
         * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided
         * * The parameter `radius` sets the radius size (float) of the icosphere (default 1)
         * * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value of `radius`)
         * * The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size
         * * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the icosahedron mesh
         * @see https://doc.babylonjs.com/how_to/polyhedra_shapes#icosphere
         */
        static CreateIcoSphere(name: string, options: {
            radius?: number;
            radiusX?: number;
            radiusY?: number;
            radiusZ?: number;
            flat?: boolean;
            subdivisions?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            updatable?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class DecalBuilder {
        /**
         * Creates a decal mesh.
         * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal
         * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates
         * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates
         * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling
         * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal
         * @param name defines the name of the mesh
         * @param sourceMesh defines the mesh where the decal must be applied
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the decal mesh
         * @see https://doc.babylonjs.com/how_to/decals
         */
        static CreateDecal(name: string, sourceMesh: AbstractMesh, options: {
            position?: Vector3;
            normal?: Vector3;
            size?: Vector3;
            angle?: number;
        }): Mesh;
    }
}
declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    export class MeshBuilder {
        /**
         * Creates a box mesh
         * * The parameter `size` sets the size (float) of each box side (default 1)
         * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)
         * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)
         * * Please read this tutorial : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @see https://doc.babylonjs.com/how_to/set_shapes#box
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the box mesh
         */
        static CreateBox(name: string, options: {
            size?: number;
            width?: number;
            height?: number;
            depth?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            wrap?: boolean;
            topBaseAt?: number;
            bottomBaseAt?: number;
            updatable?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates a tiled box mesh
         * * faceTiles sets the pattern, tile size and number of tiles for a face
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the tiled box mesh
         */
        static CreateTiledBox(name: string, options: {
            pattern?: number;
            size?: number;
            width?: number;
            height?: number;
            depth: number;
            tileSize?: number;
            tileWidth?: number;
            tileHeight?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            alignHorizontal?: number;
            alignVertical?: number;
            sideOrientation?: number;
            updatable?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates a sphere mesh
         * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)
         * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)
         * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)
         * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio
         * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the sphere mesh
         * @see https://doc.babylonjs.com/how_to/set_shapes#sphere
         */
        static CreateSphere(name: string, options: {
            segments?: number;
            diameter?: number;
            diameterX?: number;
            diameterY?: number;
            diameterZ?: number;
            arc?: number;
            slice?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            updatable?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates a plane polygonal mesh.  By default, this is a disc
         * * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)
         * * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc
         * * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the plane polygonal mesh
         * @see https://doc.babylonjs.com/how_to/set_shapes#disc-or-regular-polygon
         */
        static CreateDisc(name: string, options: {
            radius?: number;
            tessellation?: number;
            arc?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided
         * * The parameter `radius` sets the radius size (float) of the icosphere (default 1)
         * * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value of `radius`)
         * * The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size
         * * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the icosahedron mesh
         * @see https://doc.babylonjs.com/how_to/polyhedra_shapes#icosphere
         */
        static CreateIcoSphere(name: string, options: {
            radius?: number;
            radiusX?: number;
            radiusY?: number;
            radiusZ?: number;
            flat?: boolean;
            subdivisions?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            updatable?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters
         * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry
         * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array
         * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array
         * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path
         * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11
         * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#ribbon
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
         * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones
         * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values
         * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry
         * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the ribbon mesh
         * @see https://doc.babylonjs.com/how_to/ribbon_tutorial
         * @see https://doc.babylonjs.com/how_to/parametric_shapes
         */
        static CreateRibbon(name: string, options: {
            pathArray: Vector3[][];
            closeArray?: boolean;
            closePath?: boolean;
            offset?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            instance?: Mesh;
            invertUV?: boolean;
            uvs?: Vector2[];
            colors?: Color4[];
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates a cylinder or a cone mesh
         * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).
         * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).
         * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter "diameterBottom" can't be zero.
         * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.
         * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).
         * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.
         * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.
         * * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).
         * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.
         * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).
         * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3
         * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7
         * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17
         * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.
         * * If `enclose` is false, a ring surface is one element.
         * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.
         * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the cylinder mesh
         * @see https://doc.babylonjs.com/how_to/set_shapes#cylinder-or-cone
         */
        static CreateCylinder(name: string, options: {
            height?: number;
            diameterTop?: number;
            diameterBottom?: number;
            diameter?: number;
            tessellation?: number;
            subdivisions?: number;
            arc?: number;
            faceColors?: Color4[];
            faceUV?: Vector4[];
            updatable?: boolean;
            hasRings?: boolean;
            enclose?: boolean;
            cap?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates a torus mesh
         * * The parameter `diameter` sets the diameter size (float) of the torus (default 1)
         * * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)
         * * The parameter `tessellation` sets the number of torus sides (postive integer, default 16)
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the torus mesh
         * @see https://doc.babylonjs.com/how_to/set_shapes#torus
         */
        static CreateTorus(name: string, options: {
            diameter?: number;
            thickness?: number;
            tessellation?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates a torus knot mesh
         * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)
         * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)
         * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)
         * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the torus knot mesh
         * @see  https://doc.babylonjs.com/how_to/set_shapes#torus-knot
         */
        static CreateTorusKnot(name: string, options: {
            radius?: number;
            tube?: number;
            radialSegments?: number;
            tubularSegments?: number;
            p?: number;
            q?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh
         * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter
         * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function
         * * The parameter `lines` is an array of lines, each line being an array of successive Vector3
         * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter
         * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point
         * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)
         * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
         * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @see https://doc.babylonjs.com/how_to/parametric_shapes#line-system
         * @param name defines the name of the new line system
         * @param options defines the options used to create the line system
         * @param scene defines the hosting scene
         * @returns a new line system mesh
         */
        static CreateLineSystem(name: string, options: {
            lines: Vector3[][];
            updatable?: boolean;
            instance?: Nullable<LinesMesh>;
            colors?: Nullable<Color4[][]>;
            useVertexAlpha?: boolean;
        }, scene: Nullable<Scene>): LinesMesh;
        /**
         * Creates a line mesh
         * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
         * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
         * * The parameter `points` is an array successive Vector3
         * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
         * * The optional parameter `colors` is an array of successive Color4, one per line point
         * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)
         * * When updating an instance, remember that only point positions can change, not the number of points
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @see https://doc.babylonjs.com/how_to/parametric_shapes#lines
         * @param name defines the name of the new line system
         * @param options defines the options used to create the line system
         * @param scene defines the hosting scene
         * @returns a new line mesh
         */
        static CreateLines(name: string, options: {
            points: Vector3[];
            updatable?: boolean;
            instance?: Nullable<LinesMesh>;
            colors?: Color4[];
            useVertexAlpha?: boolean;
        }, scene?: Nullable<Scene>): LinesMesh;
        /**
         * Creates a dashed line mesh
         * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
         * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
         * * The parameter `points` is an array successive Vector3
         * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)
         * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)
         * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)
         * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
         * * When updating an instance, remember that only point positions can change, not the number of points
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the dashed line mesh
         * @see https://doc.babylonjs.com/how_to/parametric_shapes#dashed-lines
         */
        static CreateDashedLines(name: string, options: {
            points: Vector3[];
            dashSize?: number;
            gapSize?: number;
            dashNb?: number;
            updatable?: boolean;
            instance?: LinesMesh;
        }, scene?: Nullable<Scene>): LinesMesh;
        /**
         * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
         * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
         * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
         * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.
         * * The parameter `scale` (float, default 1) is the value to scale the shape.
         * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
         * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape
         * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the extruded shape mesh
         * @see https://doc.babylonjs.com/how_to/parametric_shapes
         * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
         */
        static ExtrudeShape(name: string, options: {
            shape: Vector3[];
            path: Vector3[];
            scale?: number;
            rotation?: number;
            cap?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            instance?: Mesh;
            invertUV?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates an custom extruded shape mesh.
         * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
         * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
         * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
         * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path
         * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.
         * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path
         * * It must returns a float value that will be the scale value applied to the shape on each path point
         * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`
         * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`
         * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
         * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape
         * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the custom extruded shape mesh
         * @see https://doc.babylonjs.com/how_to/parametric_shapes#custom-extruded-shapes
         * @see https://doc.babylonjs.com/how_to/parametric_shapes
         * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
         */
        static ExtrudeShapeCustom(name: string, options: {
            shape: Vector3[];
            path: Vector3[];
            scaleFunction?: any;
            rotationFunction?: any;
            ribbonCloseArray?: boolean;
            ribbonClosePath?: boolean;
            cap?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            instance?: Mesh;
            invertUV?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates lathe mesh.
         * The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe
         * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero
         * * The parameter `radius` (positive float, default 1) is the radius value of the lathe
         * * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe
         * * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides
         * * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape
         * * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter "arc"
         * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the lathe mesh
         * @see https://doc.babylonjs.com/how_to/parametric_shapes#lathe
         */
        static CreateLathe(name: string, options: {
            shape: Vector3[];
            radius?: number;
            tessellation?: number;
            clip?: number;
            arc?: number;
            closed?: boolean;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            cap?: number;
            invertUV?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates a tiled plane mesh
         * * You can set a limited pattern arrangement with the tiles
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the plane mesh
         * @see https://doc.babylonjs.com/how_to/set_shapes#plane
         */
        static CreateTiledPlane(name: string, options: {
            pattern?: number;
            tileSize?: number;
            tileWidth?: number;
            tileHeight?: number;
            size?: number;
            width?: number;
            height?: number;
            alignHorizontal?: number;
            alignVertical?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            updatable?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates a plane mesh
         * * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)
         * * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value of `size`)
         * * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the plane mesh
         * @see https://doc.babylonjs.com/how_to/set_shapes#plane
         */
        static CreatePlane(name: string, options: {
            size?: number;
            width?: number;
            height?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            updatable?: boolean;
            sourcePlane?: Plane;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates a ground mesh
         * * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground
         * * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the ground mesh
         * @see https://doc.babylonjs.com/how_to/set_shapes#ground
         */
        static CreateGround(name: string, options: {
            width?: number;
            height?: number;
            subdivisions?: number;
            subdivisionsX?: number;
            subdivisionsY?: number;
            updatable?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates a tiled ground mesh
         * * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates
         * * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates
         * * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile
         * * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the tiled ground mesh
         * @see https://doc.babylonjs.com/how_to/set_shapes#tiled-ground
         */
        static CreateTiledGround(name: string, options: {
            xmin: number;
            zmin: number;
            xmax: number;
            zmax: number;
            subdivisions?: {
                w: number;
                h: number;
            };
            precision?: {
                w: number;
                h: number;
            };
            updatable?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates a ground mesh from a height map
         * * The parameter `url` sets the URL of the height map image resource.
         * * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.
         * * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.
         * * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.
         * * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.
         * * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.
         * * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).
         * * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         * @param name defines the name of the mesh
         * @param url defines the url to the height map
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the ground mesh
         * @see https://doc.babylonjs.com/babylon101/height_map
         * @see https://doc.babylonjs.com/how_to/set_shapes#ground-from-a-height-map
         */
        static CreateGroundFromHeightMap(name: string, url: string, options: {
            width?: number;
            height?: number;
            subdivisions?: number;
            minHeight?: number;
            maxHeight?: number;
            colorFilter?: Color3;
            alphaFilter?: number;
            updatable?: boolean;
            onReady?: (mesh: GroundMesh) => void;
        }, scene?: Nullable<Scene>): GroundMesh;
        /**
         * Creates a polygon mesh
         * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh
         * * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors
         * * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)
         * * Remember you can only change the shape positions, not their number when updating a polygon
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @param earcutInjection can be used to inject your own earcut reference
         * @returns the polygon mesh
         */
        static CreatePolygon(name: string, options: {
            shape: Vector3[];
            holes?: Vector3[][];
            depth?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }, scene?: Nullable<Scene>, earcutInjection?: any): Mesh;
        /**
         * Creates an extruded polygon mesh, with depth in the Y direction.
         * * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)
         * @see https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @param earcutInjection can be used to inject your own earcut reference
         * @returns the polygon mesh
         */
        static ExtrudePolygon(name: string, options: {
            shape: Vector3[];
            holes?: Vector3[][];
            depth?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            wrap?: boolean;
        }, scene?: Nullable<Scene>, earcutInjection?: any): Mesh;
        /**
         * Creates a tube mesh.
         * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters
         * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube
         * * The parameter `radius` (positive float, default 1) sets the tube radius size
         * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface
         * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`
         * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)
         * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc
         * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
         * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#tube
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the tube mesh
         * @see https://doc.babylonjs.com/how_to/parametric_shapes
         * @see https://doc.babylonjs.com/how_to/set_shapes#tube
         */
        static CreateTube(name: string, options: {
            path: Vector3[];
            radius?: number;
            tessellation?: number;
            radiusFunction?: {
                (i: number, distance: number): number;
            };
            cap?: number;
            arc?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            instance?: Mesh;
            invertUV?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates a polyhedron mesh
         * * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type
         * * The parameter `size` (positive float, default 1) sets the polygon size
         * * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)
         * * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`
         * * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron
         * * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)
         * * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
         * * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the polyhedron mesh
         * @see https://doc.babylonjs.com/how_to/polyhedra_shapes
         */
        static CreatePolyhedron(name: string, options: {
            type?: number;
            size?: number;
            sizeX?: number;
            sizeY?: number;
            sizeZ?: number;
            custom?: any;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            flat?: boolean;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates a decal mesh.
         * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal
         * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates
         * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates
         * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling
         * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal
         * @param name defines the name of the mesh
         * @param sourceMesh defines the mesh where the decal must be applied
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the decal mesh
         * @see https://doc.babylonjs.com/how_to/decals
         */
        static CreateDecal(name: string, sourceMesh: AbstractMesh, options: {
            position?: Vector3;
            normal?: Vector3;
            size?: Vector3;
            angle?: number;
        }): Mesh;
        /**
         * Creates a Capsule Mesh
         * @param name defines the name of the mesh.
         * @param options the constructors options used to shape the mesh.
         * @param scene defines the scene the mesh is scoped to.
         * @returns the capsule mesh
         * @see https://doc.babylonjs.com/how_to/capsule_shape
         */
        static CreateCapsule(name: string, options?: ICreateCapsuleOptions, scene?: Nullable<Scene>): Mesh;
    }
}
declare module BABYLON {
    /**
     * A simplifier interface for future simplification implementations
     * @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification
     */
    export interface ISimplifier {
        /**
         * Simplification of a given mesh according to the given settings.
         * Since this requires computation, it is assumed that the function runs async.
         * @param settings The settings of the simplification, including quality and distance
         * @param successCallback A callback that will be called after the mesh was simplified.
         * @param errorCallback in case of an error, this callback will be called. optional.
         */
        simplify(settings: ISimplificationSettings, successCallback: (simplifiedMeshes: Mesh) => void, errorCallback?: () => void): void;
    }
    /**
     * Expected simplification settings.
     * Quality should be between 0 and 1 (1 being 100%, 0 being 0%)
     * @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification
     */
    export interface ISimplificationSettings {
        /**
         * Gets or sets the expected quality
         */
        quality: number;
        /**
         * Gets or sets the distance when this optimized version should be used
         */
        distance: number;
        /**
         * Gets an already optimized mesh
         */
        optimizeMesh?: boolean;
    }
    /**
     * Class used to specify simplification options
     * @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification
     */
    export class SimplificationSettings implements ISimplificationSettings {
        /** expected quality */
        quality: number;
        /** distance when this optimized version should be used */
        distance: number;
        /** already optimized mesh  */
        optimizeMesh?: boolean | undefined;
        /**
         * Creates a SimplificationSettings
         * @param quality expected quality
         * @param distance distance when this optimized version should be used
         * @param optimizeMesh already optimized mesh
         */
        constructor(
        /** expected quality */
        quality: number, 
        /** distance when this optimized version should be used */
        distance: number, 
        /** already optimized mesh  */
        optimizeMesh?: boolean | undefined);
    }
    /**
     * Interface used to define a simplification task
     */
    export interface ISimplificationTask {
        /**
         * Array of settings
         */
        settings: Array<ISimplificationSettings>;
        /**
         * Simplification type
         */
        simplificationType: SimplificationType;
        /**
         * Mesh to simplify
         */
        mesh: Mesh;
        /**
         * Callback called on success
         */
        successCallback?: () => void;
        /**
         * Defines if parallel processing can be used
         */
        parallelProcessing: boolean;
    }
    /**
     * Queue used to order the simplification tasks
     * @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification
     */
    export class SimplificationQueue {
        private _simplificationArray;
        /**
         * Gets a boolean indicating that the process is still running
         */
        running: boolean;
        /**
         * Creates a new queue
         */
        constructor();
        /**
         * Adds a new simplification task
         * @param task defines a task to add
         */
        addTask(task: ISimplificationTask): void;
        /**
         * Execute next task
         */
        executeNext(): void;
        /**
         * Execute a simplification task
         * @param task defines the task to run
         */
        runSimplification(task: ISimplificationTask): void;
        private getSimplifier;
    }
    /**
     * The implemented types of simplification
     * At the moment only Quadratic Error Decimation is implemented
     * @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification
     */
    export enum SimplificationType {
        /** Quadratic error decimation */
        QUADRATIC = 0
    }
    /**
     * An implementation of the Quadratic Error simplification algorithm.
     * Original paper : http://www1.cs.columbia.edu/~cs4162/html05s/garland97.pdf
     * Ported mostly from QSlim and http://voxels.blogspot.de/2014/05/quadric-mesh-simplification-with-source.html to babylon JS
     * @author RaananW
     * @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification
     */
    export class QuadraticErrorSimplification implements ISimplifier {
        private _mesh;
        private triangles;
        private vertices;
        private references;
        private _reconstructedMesh;
        /** Gets or sets the number pf sync interations */
        syncIterations: number;
        /** Gets or sets the aggressiveness of the simplifier */
        aggressiveness: number;
        /** Gets or sets the number of allowed iterations for decimation */
        decimationIterations: number;
        /** Gets or sets the espilon to use for bounding box computation */
        boundingBoxEpsilon: number;
        /**
         * Creates a new QuadraticErrorSimplification
         * @param _mesh defines the target mesh
         */
        constructor(_mesh: Mesh);
        /**
         * Simplification of a given mesh according to the given settings.
         * Since this requires computation, it is assumed that the function runs async.
         * @param settings The settings of the simplification, including quality and distance
         * @param successCallback A callback that will be called after the mesh was simplified.
         */
        simplify(settings: ISimplificationSettings, successCallback: (simplifiedMesh: Mesh) => void): void;
        private runDecimation;
        private initWithMesh;
        private init;
        private reconstructMesh;
        private initDecimatedMesh;
        private isFlipped;
        private updateTriangles;
        private identifyBorder;
        private updateMesh;
        private vertexError;
        private calculateError;
    }
}
declare module BABYLON {
        interface Scene {
            /** @hidden (Backing field) */
            _simplificationQueue: SimplificationQueue;
            /**
             * Gets or sets the simplification queue attached to the scene
             * @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification
             */
            simplificationQueue: SimplificationQueue;
        }
        interface Mesh {
            /**
             * Simplify the mesh according to the given array of settings.
             * Function will return immediately and will simplify async
             * @param settings a collection of simplification settings
             * @param parallelProcessing should all levels calculate parallel or one after the other
             * @param simplificationType the type of simplification to run
             * @param successCallback optional success callback to be called after the simplification finished processing all settings
             * @returns the current mesh
             */
            simplify(settings: Array<ISimplificationSettings>, parallelProcessing?: boolean, simplificationType?: SimplificationType, successCallback?: (mesh?: Mesh, submeshIndex?: number) => void): Mesh;
        }
    /**
     * Defines the simplification queue scene component responsible to help scheduling the various simplification task
     * created in a scene
     */
    export class SimplicationQueueSceneComponent implements ISceneComponent {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        readonly name: string;
        /**
         * The scene the component belongs to.
         */
        scene: Scene;
        /**
         * Creates a new instance of the component for the given scene
         * @param scene Defines the scene to register the component in
         */
        constructor(scene: Scene);
        /**
         * Registers the component in a given scene
         */
        register(): void;
        /**
         * Rebuilds the elements related to this component in case of
         * context lost for instance.
         */
        rebuild(): void;
        /**
         * Disposes the component and the associated ressources
         */
        dispose(): void;
        private _beforeCameraUpdate;
    }
}
declare module BABYLON {
        interface Mesh {
            /**
             * Gets or sets a boolean defining if we want picking to pick thin instances as well
             */
            thinInstanceEnablePicking: boolean;
            /**
             * Creates a new thin instance
             * @param matrix the matrix or array of matrices (position, rotation, scale) of the thin instance(s) to create
             * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance
             * @returns the thin instance index number. If you pass an array of matrices, other instance indexes are index+1, index+2, etc
             */
            thinInstanceAdd(matrix: DeepImmutableObject<Matrix> | Array<DeepImmutableObject<Matrix>>, refresh: boolean): number;
            /**
             * Adds the transformation (matrix) of the current mesh as a thin instance
             * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance
             * @returns the thin instance index number
             */
            thinInstanceAddSelf(refresh: boolean): number;
            /**
             * Registers a custom attribute to be used with thin instances
             * @param kind name of the attribute
             * @param stride size in floats of the attribute
             */
            thinInstanceRegisterAttribute(kind: string, stride: number): void;
            /**
             * Sets the matrix of a thin instance
             * @param index index of the thin instance
             * @param matrix matrix to set
             * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance
             */
            thinInstanceSetMatrixAt(index: number, matrix: DeepImmutableObject<Matrix>, refresh: boolean): void;
            /**
             * Sets the value of a custom attribute for a thin instance
             * @param kind name of the attribute
             * @param index index of the thin instance
             * @param value value to set
             * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance
             */
            thinInstanceSetAttributeAt(kind: string, index: number, value: Array<number>, refresh: boolean): void;
            /**
             * Gets / sets the number of thin instances to display. Note that you can't set a number higher than what the underlying buffer can handle.
             */
            thinInstanceCount: number;
            /**
             * Sets a buffer to be used with thin instances. This method is a faster way to setup multiple instances than calling thinInstanceAdd repeatedly
             * @param kind name of the attribute. Use "matrix" to setup the buffer of matrices
             * @param buffer buffer to set
             * @param stride size in floats of each value of the buffer
             * @param staticBuffer indicates that the buffer is static, so that you won't change it after it is set (better performances - false by default)
             */
            thinInstanceSetBuffer(kind: string, buffer: Nullable<Float32Array>, stride: number, staticBuffer: boolean): void;
            /**
             * Gets the list of world matrices
             * @return an array containing all the world matrices from the thin instances
             */
            thinInstanceGetWorldMatrices(): Matrix[];
            /**
             * Synchronize the gpu buffers with a thin instance buffer. Call this method if you update later on the buffers passed to thinInstanceSetBuffer
             * @param kind name of the attribute to update. Use "matrix" to update the buffer of matrices
             */
            thinInstanceBufferUpdated(kind: string): void;
            /**
             * Applies a partial update to a buffer directly on the GPU
             * Note that the buffer located on the CPU is NOT updated! It's up to you to update it (or not) with the same data you pass to this method
             * @param kind name of the attribute to update. Use "matrix" to update the buffer of matrices
             * @param data the data to set in the GPU buffer
             * @param offset the offset in the GPU buffer where to update the data
             */
            thinInstancePartialBufferUpdate(kind: string, data: Float32Array, offset: number): void;
            /**
             * Refreshes the bounding info, taking into account all the thin instances defined
             * @param forceRefreshParentInfo true to force recomputing the mesh bounding info and use it to compute the aggregated bounding info
             */
            thinInstanceRefreshBoundingInfo(forceRefreshParentInfo: boolean): void;
            /** @hidden */
            _thinInstanceInitializeUserStorage(): void;
            /** @hidden */
            _thinInstanceUpdateBufferSize(kind: string, numInstances: number): void;
            /** @hidden */
            _userThinInstanceBuffersStorage: {
                data: {
                    [key: string]: Float32Array;
                };
                sizes: {
                    [key: string]: number;
                };
                vertexBuffers: {
                    [key: string]: Nullable<VertexBuffer>;
                };
                strides: {
                    [key: string]: number;
                };
            };
        }
}
declare module BABYLON {
    /**
     * Navigation plugin interface to add navigation constrained by a navigation mesh
     */
    export interface INavigationEnginePlugin {
        /**
         * plugin name
         */
        name: string;
        /**
         * Creates a navigation mesh
         * @param meshes array of all the geometry used to compute the navigatio mesh
         * @param parameters bunch of parameters used to filter geometry
         */
        createNavMesh(meshes: Array<Mesh>, parameters: INavMeshParameters): void;
        /**
         * Create a navigation mesh debug mesh
         * @param scene is where the mesh will be added
         * @returns debug display mesh
         */
        createDebugNavMesh(scene: Scene): Mesh;
        /**
         * Get a navigation mesh constrained position, closest to the parameter position
         * @param position world position
         * @returns the closest point to position constrained by the navigation mesh
         */
        getClosestPoint(position: Vector3): Vector3;
        /**
         * Get a navigation mesh constrained position, closest to the parameter position
         * @param position world position
         * @param result output the closest point to position constrained by the navigation mesh
         */
        getClosestPointToRef(position: Vector3, result: Vector3): void;
        /**
         * Get a navigation mesh constrained position, within a particular radius
         * @param position world position
         * @param maxRadius the maximum distance to the constrained world position
         * @returns the closest point to position constrained by the navigation mesh
         */
        getRandomPointAround(position: Vector3, maxRadius: number): Vector3;
        /**
         * Get a navigation mesh constrained position, within a particular radius
         * @param position world position
         * @param maxRadius the maximum distance to the constrained world position
         * @param result output the closest point to position constrained by the navigation mesh
         */
        getRandomPointAroundToRef(position: Vector3, maxRadius: number, result: Vector3): void;
        /**
         * Compute the final position from a segment made of destination-position
         * @param position world position
         * @param destination world position
         * @returns the resulting point along the navmesh
         */
        moveAlong(position: Vector3, destination: Vector3): Vector3;
        /**
         * Compute the final position from a segment made of destination-position
         * @param position world position
         * @param destination world position
         * @param result output the resulting point along the navmesh
         */
        moveAlongToRef(position: Vector3, destination: Vector3, result: Vector3): void;
        /**
         * Compute a navigation path from start to end. Returns an empty array if no path can be computed
         * @param start world position
         * @param end world position
         * @returns array containing world position composing the path
         */
        computePath(start: Vector3, end: Vector3): Vector3[];
        /**
         * If this plugin is supported
         * @returns true if plugin is supported
         */
        isSupported(): boolean;
        /**
         * Create a new Crowd so you can add agents
         * @param maxAgents the maximum agent count in the crowd
         * @param maxAgentRadius the maximum radius an agent can have
         * @param scene to attach the crowd to
         * @returns the crowd you can add agents to
         */
        createCrowd(maxAgents: number, maxAgentRadius: number, scene: Scene): ICrowd;
        /**
         * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)
         * The queries will try to find a solution within those bounds
         * default is (1,1,1)
         * @param extent x,y,z value that define the extent around the queries point of reference
         */
        setDefaultQueryExtent(extent: Vector3): void;
        /**
         * Get the Bounding box extent specified by setDefaultQueryExtent
         * @returns the box extent values
         */
        getDefaultQueryExtent(): Vector3;
        /**
         * build the navmesh from a previously saved state using getNavmeshData
         * @param data the Uint8Array returned by getNavmeshData
         */
        buildFromNavmeshData(data: Uint8Array): void;
        /**
         * returns the navmesh data that can be used later. The navmesh must be built before retrieving the data
         * @returns data the Uint8Array that can be saved and reused
         */
        getNavmeshData(): Uint8Array;
        /**
         * Get the Bounding box extent result specified by setDefaultQueryExtent
         * @param result output the box extent values
         */
        getDefaultQueryExtentToRef(result: Vector3): void;
        /**
         * Release all resources
         */
        dispose(): void;
    }
    /**
     * Crowd Interface. A Crowd is a collection of moving agents constrained by a navigation mesh
     */
    export interface ICrowd {
        /**
         * Add a new agent to the crowd with the specified parameter a corresponding transformNode.
         * You can attach anything to that node. The node position is updated in the scene update tick.
         * @param pos world position that will be constrained by the navigation mesh
         * @param parameters agent parameters
         * @param transform hooked to the agent that will be update by the scene
         * @returns agent index
         */
        addAgent(pos: Vector3, parameters: IAgentParameters, transform: TransformNode): number;
        /**
         * Returns the agent position in world space
         * @param index agent index returned by addAgent
         * @returns world space position
         */
        getAgentPosition(index: number): Vector3;
        /**
         * Gets the agent position result in world space
         * @param index agent index returned by addAgent
         * @param result output world space position
         */
        getAgentPositionToRef(index: number, result: Vector3): void;
        /**
         * Gets the agent velocity in world space
         * @param index agent index returned by addAgent
         * @returns world space velocity
         */
        getAgentVelocity(index: number): Vector3;
        /**
         * Gets the agent velocity result in world space
         * @param index agent index returned by addAgent
         * @param result output world space velocity
         */
        getAgentVelocityToRef(index: number, result: Vector3): void;
        /**
         * remove a particular agent previously created
         * @param index agent index returned by addAgent
         */
        removeAgent(index: number): void;
        /**
         * get the list of all agents attached to this crowd
         * @returns list of agent indices
         */
        getAgents(): number[];
        /**
         * Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function
         * @param deltaTime in seconds
         */
        update(deltaTime: number): void;
        /**
         * Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh
         * @param index agent index returned by addAgent
         * @param destination targeted world position
         */
        agentGoto(index: number, destination: Vector3): void;
        /**
         * Teleport the agent to a new position
         * @param index agent index returned by addAgent
         * @param destination targeted world position
         */
        agentTeleport(index: number, destination: Vector3): void;
        /**
         * Update agent parameters
         * @param index agent index returned by addAgent
         * @param parameters agent parameters
         */
        updateAgentParameters(index: number, parameters: IAgentParameters): void;
        /**
         * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)
         * The queries will try to find a solution within those bounds
         * default is (1,1,1)
         * @param extent x,y,z value that define the extent around the queries point of reference
         */
        setDefaultQueryExtent(extent: Vector3): void;
        /**
         * Get the Bounding box extent specified by setDefaultQueryExtent
         * @returns the box extent values
         */
        getDefaultQueryExtent(): Vector3;
        /**
         * Get the Bounding box extent result specified by setDefaultQueryExtent
         * @param result output the box extent values
         */
        getDefaultQueryExtentToRef(result: Vector3): void;
        /**
         * Release all resources
         */
        dispose(): void;
    }
    /**
     * Configures an agent
     */
    export interface IAgentParameters {
        /**
         *  Agent radius. [Limit: >= 0]
         */
        radius: number;
        /**
         * Agent height. [Limit: > 0]
         */
        height: number;
        /**
         *  Maximum allowed acceleration. [Limit: >= 0]
         */
        maxAcceleration: number;
        /**
         * Maximum allowed speed. [Limit: >= 0]
         */
        maxSpeed: number;
        /**
         * Defines how close a collision element must be before it is considered for steering behaviors. [Limits: > 0]
         */
        collisionQueryRange: number;
        /**
         * The path visibility optimization range. [Limit: > 0]
         */
        pathOptimizationRange: number;
        /**
         * How aggresive the agent manager should be at avoiding collisions with this agent. [Limit: >= 0]
         */
        separationWeight: number;
    }
    /**
     * Configures the navigation mesh creation
     */
    export interface INavMeshParameters {
        /**
         * The xz-plane cell size to use for fields. [Limit: > 0] [Units: wu]
         */
        cs: number;
        /**
         * The y-axis cell size to use for fields. [Limit: > 0] [Units: wu]
         */
        ch: number;
        /**
         * The maximum slope that is considered walkable. [Limits: 0 <= value < 90] [Units: Degrees]
         */
        walkableSlopeAngle: number;
        /**
         * Minimum floor to 'ceiling' height that will still allow the floor area to
         * be considered walkable. [Limit: >= 3] [Units: vx]
         */
        walkableHeight: number;
        /**
         * Maximum ledge height that is considered to still be traversable. [Limit: >=0] [Units: vx]
         */
        walkableClimb: number;
        /**
         * The distance to erode/shrink the walkable area of the heightfield away from
         * obstructions.  [Limit: >=0] [Units: vx]
         */
        walkableRadius: number;
        /**
         * The maximum allowed length for contour edges along the border of the mesh. [Limit: >=0] [Units: vx]
         */
        maxEdgeLen: number;
        /**
         * The maximum distance a simplfied contour's border edges should deviate
         * the original raw contour. [Limit: >=0] [Units: vx]
         */
        maxSimplificationError: number;
        /**
         * The minimum number of cells allowed to form isolated island areas. [Limit: >=0] [Units: vx]
         */
        minRegionArea: number;
        /**
         * Any regions with a span count smaller than this value will, if possible,
         * be merged with larger regions. [Limit: >=0] [Units: vx]
         */
        mergeRegionArea: number;
        /**
         * The maximum number of vertices allowed for polygons generated during the
         * contour to polygon conversion process. [Limit: >= 3]
         */
        maxVertsPerPoly: number;
        /**
         * Sets the sampling distance to use when generating the detail mesh.
         * (For height detail only.) [Limits: 0 or >= 0.9] [Units: wu]
         */
        detailSampleDist: number;
        /**
         * The maximum distance the detail mesh surface should deviate from heightfield
         * data. (For height detail only.) [Limit: >=0] [Units: wu]
         */
        detailSampleMaxError: number;
    }
}
declare module BABYLON {
    /**
     * RecastJS navigation plugin
     */
    export class RecastJSPlugin implements INavigationEnginePlugin {
        /**
         * Reference to the Recast library
         */
        bjsRECAST: any;
        /**
         * plugin name
         */
        name: string;
        /**
         * the first navmesh created. We might extend this to support multiple navmeshes
         */
        navMesh: any;
        /**
         * Initializes the recastJS plugin
         * @param recastInjection can be used to inject your own recast reference
         */
        constructor(recastInjection?: any);
        /**
         * Creates a navigation mesh
         * @param meshes array of all the geometry used to compute the navigatio mesh
         * @param parameters bunch of parameters used to filter geometry
         */
        createNavMesh(meshes: Array<Mesh>, parameters: INavMeshParameters): void;
        /**
         * Create a navigation mesh debug mesh
         * @param scene is where the mesh will be added
         * @returns debug display mesh
         */
        createDebugNavMesh(scene: Scene): Mesh;
        /**
         * Get a navigation mesh constrained position, closest to the parameter position
         * @param position world position
         * @returns the closest point to position constrained by the navigation mesh
         */
        getClosestPoint(position: Vector3): Vector3;
        /**
         * Get a navigation mesh constrained position, closest to the parameter position
         * @param position world position
         * @param result output the closest point to position constrained by the navigation mesh
         */
        getClosestPointToRef(position: Vector3, result: Vector3): void;
        /**
         * Get a navigation mesh constrained position, within a particular radius
         * @param position world position
         * @param maxRadius the maximum distance to the constrained world position
         * @returns the closest point to position constrained by the navigation mesh
         */
        getRandomPointAround(position: Vector3, maxRadius: number): Vector3;
        /**
         * Get a navigation mesh constrained position, within a particular radius
         * @param position world position
         * @param maxRadius the maximum distance to the constrained world position
         * @param result output the closest point to position constrained by the navigation mesh
         */
        getRandomPointAroundToRef(position: Vector3, maxRadius: number, result: Vector3): void;
        /**
         * Compute the final position from a segment made of destination-position
         * @param position world position
         * @param destination world position
         * @returns the resulting point along the navmesh
         */
        moveAlong(position: Vector3, destination: Vector3): Vector3;
        /**
         * Compute the final position from a segment made of destination-position
         * @param position world position
         * @param destination world position
         * @param result output the resulting point along the navmesh
         */
        moveAlongToRef(position: Vector3, destination: Vector3, result: Vector3): void;
        /**
         * Compute a navigation path from start to end. Returns an empty array if no path can be computed
         * @param start world position
         * @param end world position
         * @returns array containing world position composing the path
         */
        computePath(start: Vector3, end: Vector3): Vector3[];
        /**
         * Create a new Crowd so you can add agents
         * @param maxAgents the maximum agent count in the crowd
         * @param maxAgentRadius the maximum radius an agent can have
         * @param scene to attach the crowd to
         * @returns the crowd you can add agents to
         */
        createCrowd(maxAgents: number, maxAgentRadius: number, scene: Scene): ICrowd;
        /**
         * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)
         * The queries will try to find a solution within those bounds
         * default is (1,1,1)
         * @param extent x,y,z value that define the extent around the queries point of reference
         */
        setDefaultQueryExtent(extent: Vector3): void;
        /**
         * Get the Bounding box extent specified by setDefaultQueryExtent
         * @returns the box extent values
         */
        getDefaultQueryExtent(): Vector3;
        /**
         * build the navmesh from a previously saved state using getNavmeshData
         * @param data the Uint8Array returned by getNavmeshData
         */
        buildFromNavmeshData(data: Uint8Array): void;
        /**
         * returns the navmesh data that can be used later. The navmesh must be built before retrieving the data
         * @returns data the Uint8Array that can be saved and reused
         */
        getNavmeshData(): Uint8Array;
        /**
         * Get the Bounding box extent result specified by setDefaultQueryExtent
         * @param result output the box extent values
         */
        getDefaultQueryExtentToRef(result: Vector3): void;
        /**
         * Disposes
         */
        dispose(): void;
        /**
         * If this plugin is supported
         * @returns true if plugin is supported
         */
        isSupported(): boolean;
    }
    /**
     * Recast detour crowd implementation
     */
    export class RecastJSCrowd implements ICrowd {
        /**
         * Recast/detour plugin
         */
        bjsRECASTPlugin: RecastJSPlugin;
        /**
         * Link to the detour crowd
         */
        recastCrowd: any;
        /**
         * One transform per agent
         */
        transforms: TransformNode[];
        /**
         * All agents created
         */
        agents: number[];
        /**
         * Link to the scene is kept to unregister the crowd from the scene
         */
        private _scene;
        /**
         * Observer for crowd updates
         */
        private _onBeforeAnimationsObserver;
        /**
         * Constructor
         * @param plugin recastJS plugin
         * @param maxAgents the maximum agent count in the crowd
         * @param maxAgentRadius the maximum radius an agent can have
         * @param scene to attach the crowd to
         * @returns the crowd you can add agents to
         */
        constructor(plugin: RecastJSPlugin, maxAgents: number, maxAgentRadius: number, scene: Scene);
        /**
         * Add a new agent to the crowd with the specified parameter a corresponding transformNode.
         * You can attach anything to that node. The node position is updated in the scene update tick.
         * @param pos world position that will be constrained by the navigation mesh
         * @param parameters agent parameters
         * @param transform hooked to the agent that will be update by the scene
         * @returns agent index
         */
        addAgent(pos: Vector3, parameters: IAgentParameters, transform: TransformNode): number;
        /**
         * Returns the agent position in world space
         * @param index agent index returned by addAgent
         * @returns world space position
         */
        getAgentPosition(index: number): Vector3;
        /**
         * Returns the agent position result in world space
         * @param index agent index returned by addAgent
         * @param result output world space position
         */
        getAgentPositionToRef(index: number, result: Vector3): void;
        /**
         * Returns the agent velocity in world space
         * @param index agent index returned by addAgent
         * @returns world space velocity
         */
        getAgentVelocity(index: number): Vector3;
        /**
         * Returns the agent velocity result in world space
         * @param index agent index returned by addAgent
         * @param result output world space velocity
         */
        getAgentVelocityToRef(index: number, result: Vector3): void;
        /**
         * Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh
         * @param index agent index returned by addAgent
         * @param destination targeted world position
         */
        agentGoto(index: number, destination: Vector3): void;
        /**
         * Teleport the agent to a new position
         * @param index agent index returned by addAgent
         * @param destination targeted world position
         */
        agentTeleport(index: number, destination: Vector3): void;
        /**
         * Update agent parameters
         * @param index agent index returned by addAgent
         * @param parameters agent parameters
         */
        updateAgentParameters(index: number, parameters: IAgentParameters): void;
        /**
         * remove a particular agent previously created
         * @param index agent index returned by addAgent
         */
        removeAgent(index: number): void;
        /**
         * get the list of all agents attached to this crowd
         * @returns list of agent indices
         */
        getAgents(): number[];
        /**
         * Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function
         * @param deltaTime in seconds
         */
        update(deltaTime: number): void;
        /**
         * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)
         * The queries will try to find a solution within those bounds
         * default is (1,1,1)
         * @param extent x,y,z value that define the extent around the queries point of reference
         */
        setDefaultQueryExtent(extent: Vector3): void;
        /**
         * Get the Bounding box extent specified by setDefaultQueryExtent
         * @returns the box extent values
         */
        getDefaultQueryExtent(): Vector3;
        /**
         * Get the Bounding box extent result specified by setDefaultQueryExtent
         * @param result output the box extent values
         */
        getDefaultQueryExtentToRef(result: Vector3): void;
        /**
         * Release all resources
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * Class used to enable access to IndexedDB
     * @see https://doc.babylonjs.com/how_to/caching_resources_in_indexeddb
     */
    export class Database implements IOfflineProvider {
        private _callbackManifestChecked;
        private _currentSceneUrl;
        private _db;
        private _enableSceneOffline;
        private _enableTexturesOffline;
        private _manifestVersionFound;
        private _mustUpdateRessources;
        private _hasReachedQuota;
        private _isSupported;
        private _idbFactory;
        /** Gets a boolean indicating if the user agent supports blob storage (this value will be updated after creating the first Database object) */
        private static IsUASupportingBlobStorage;
        /**
         * Gets a boolean indicating if Database storate is enabled (off by default)
         */
        static IDBStorageEnabled: boolean;
        /**
         * Gets a boolean indicating if scene must be saved in the database
         */
        get enableSceneOffline(): boolean;
        /**
         * Gets a boolean indicating if textures must be saved in the database
         */
        get enableTexturesOffline(): boolean;
        /**
         * Creates a new Database
         * @param urlToScene defines the url to load the scene
         * @param callbackManifestChecked defines the callback to use when manifest is checked
         * @param disableManifestCheck defines a boolean indicating that we want to skip the manifest validation (it will be considered validated and up to date)
         */
        constructor(urlToScene: string, callbackManifestChecked: (checked: boolean) => any, disableManifestCheck?: boolean);
        private static _ParseURL;
        private static _ReturnFullUrlLocation;
        private _checkManifestFile;
        /**
         * Open the database and make it available
         * @param successCallback defines the callback to call on success
         * @param errorCallback defines the callback to call on error
         */
        open(successCallback: () => void, errorCallback: () => void): void;
        /**
         * Loads an image from the database
         * @param url defines the url to load from
         * @param image defines the target DOM image
         */
        loadImage(url: string, image: HTMLImageElement): void;
        private _loadImageFromDBAsync;
        private _saveImageIntoDBAsync;
        private _checkVersionFromDB;
        private _loadVersionFromDBAsync;
        private _saveVersionIntoDBAsync;
        /**
         * Loads a file from database
         * @param url defines the URL to load from
         * @param sceneLoaded defines a callback to call on success
         * @param progressCallBack defines a callback to call when progress changed
         * @param errorCallback defines a callback to call on error
         * @param useArrayBuffer defines a boolean to use array buffer instead of text string
         */
        loadFile(url: string, sceneLoaded: (data: any) => void, progressCallBack?: (data: any) => void, errorCallback?: () => void, useArrayBuffer?: boolean): void;
        private _loadFileAsync;
        private _saveFileAsync;
        /**
         * Validates if xhr data is correct
         * @param xhr defines the request to validate
         * @param dataType defines the expected data type
         * @returns true if data is correct
         */
        private static _ValidateXHRData;
    }
}
declare module BABYLON {
    /** @hidden */
    export var gpuUpdateParticlesPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var gpuUpdateParticlesVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var clipPlaneFragmentDeclaration2: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var gpuRenderParticlesPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var clipPlaneVertexDeclaration2: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var gpuRenderParticlesVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * This represents a GPU particle system in Babylon
     * This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data
     * @see https://www.babylonjs-playground.com/#PU4WYI#4
     */
    export class GPUParticleSystem extends BaseParticleSystem implements IDisposable, IParticleSystem, IAnimatable {
        /**
         * The layer mask we are rendering the particles through.
         */
        layerMask: number;
        private _capacity;
        private _activeCount;
        private _currentActiveCount;
        private _accumulatedCount;
        private _renderEffect;
        private _updateEffect;
        private _buffer0;
        private _buffer1;
        private _spriteBuffer;
        private _updateVAO;
        private _renderVAO;
        private _targetIndex;
        private _sourceBuffer;
        private _targetBuffer;
        private _currentRenderId;
        private _started;
        private _stopped;
        private _timeDelta;
        private _randomTexture;
        private _randomTexture2;
        private _attributesStrideSize;
        private _updateEffectOptions;
        private _randomTextureSize;
        private _actualFrame;
        private _customEffect;
        private readonly _rawTextureWidth;
        /**
         * Gets a boolean indicating if the GPU particles can be rendered on current browser
         */
        static get IsSupported(): boolean;
        /**
        * An event triggered when the system is disposed.
        */
        onDisposeObservable: Observable<IParticleSystem>;
        /**
         * Gets the maximum number of particles active at the same time.
         * @returns The max number of active particles.
         */
        getCapacity(): number;
        /**
         * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls
         * to override the particles.
         */
        forceDepthWrite: boolean;
        /**
         * Gets or set the number of active particles
         */
        get activeParticleCount(): number;
        set activeParticleCount(value: number);
        private _preWarmDone;
        /**
         * Specifies if the particles are updated in emitter local space or world space.
         */
        isLocal: boolean;
        /** Gets or sets a matrix to use to compute projection */
        defaultProjectionMatrix: Matrix;
        /**
         * Is this system ready to be used/rendered
         * @return true if the system is ready
         */
        isReady(): boolean;
        /**
         * Gets if the system has been started. (Note: this will still be true after stop is called)
         * @returns True if it has been started, otherwise false.
         */
        isStarted(): boolean;
        /**
         * Gets if the system has been stopped. (Note: rendering is still happening but the system is frozen)
         * @returns True if it has been stopped, otherwise false.
         */
        isStopped(): boolean;
        /**
         * Gets a boolean indicating that the system is stopping
         * @returns true if the system is currently stopping
         */
        isStopping(): boolean;
        /**
         * Gets the number of particles active at the same time.
         * @returns The number of active particles.
         */
        getActiveCount(): number;
        /**
         * Starts the particle system and begins to emit
         * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)
         */
        start(delay?: number): void;
        /**
         * Stops the particle system.
         */
        stop(): void;
        /**
         * Remove all active particles
         */
        reset(): void;
        /**
         * Returns the string "GPUParticleSystem"
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Gets the custom effect used to render the particles
         * @param blendMode Blend mode for which the effect should be retrieved
         * @returns The effect
         */
        getCustomEffect(blendMode?: number): Nullable<Effect>;
        /**
         * Sets the custom effect used to render the particles
         * @param effect The effect to set
         * @param blendMode Blend mode for which the effect should be set
         */
        setCustomEffect(effect: Nullable<Effect>, blendMode?: number): void;
        /** @hidden */
        protected _onBeforeDrawParticlesObservable: Nullable<Observable<Nullable<Effect>>>;
        /**
         * Observable that will be called just before the particles are drawn
         */
        get onBeforeDrawParticlesObservable(): Observable<Nullable<Effect>>;
        /**
         * Gets the name of the particle vertex shader
         */
        get vertexShaderName(): string;
        private _colorGradientsTexture;
        protected _removeGradientAndTexture(gradient: number, gradients: Nullable<IValueGradient[]>, texture: RawTexture): BaseParticleSystem;
        /**
         * Adds a new color gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param color1 defines the color to affect to the specified gradient
         * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from
         * @returns the current particle system
         */
        addColorGradient(gradient: number, color1: Color4, color2?: Color4): GPUParticleSystem;
        private _refreshColorGradient;
        /** Force the system to rebuild all gradients that need to be resync */
        forceRefreshGradients(): void;
        /**
         * Remove a specific color gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeColorGradient(gradient: number): GPUParticleSystem;
        private _angularSpeedGradientsTexture;
        private _sizeGradientsTexture;
        private _velocityGradientsTexture;
        private _limitVelocityGradientsTexture;
        private _dragGradientsTexture;
        private _addFactorGradient;
        /**
         * Adds a new size gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the size factor to affect to the specified gradient
         * @returns the current particle system
         */
        addSizeGradient(gradient: number, factor: number): GPUParticleSystem;
        /**
         * Remove a specific size gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeSizeGradient(gradient: number): GPUParticleSystem;
        private _refreshFactorGradient;
        /**
         * Adds a new angular speed gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the angular speed to affect to the specified gradient
         * @returns the current particle system
         */
        addAngularSpeedGradient(gradient: number, factor: number): GPUParticleSystem;
        /**
         * Remove a specific angular speed gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeAngularSpeedGradient(gradient: number): GPUParticleSystem;
        /**
         * Adds a new velocity gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the velocity to affect to the specified gradient
         * @returns the current particle system
         */
        addVelocityGradient(gradient: number, factor: number): GPUParticleSystem;
        /**
         * Remove a specific velocity gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeVelocityGradient(gradient: number): GPUParticleSystem;
        /**
         * Adds a new limit velocity gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the limit velocity value to affect to the specified gradient
         * @returns the current particle system
         */
        addLimitVelocityGradient(gradient: number, factor: number): GPUParticleSystem;
        /**
         * Remove a specific limit velocity gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeLimitVelocityGradient(gradient: number): GPUParticleSystem;
        /**
         * Adds a new drag gradient
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the drag value to affect to the specified gradient
         * @returns the current particle system
         */
        addDragGradient(gradient: number, factor: number): GPUParticleSystem;
        /**
         * Remove a specific drag gradient
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeDragGradient(gradient: number): GPUParticleSystem;
        /**
         * Not supported by GPUParticleSystem
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the emit rate value to affect to the specified gradient
         * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
         * @returns the current particle system
         */
        addEmitRateGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;
        /**
         * Not supported by GPUParticleSystem
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeEmitRateGradient(gradient: number): IParticleSystem;
        /**
         * Not supported by GPUParticleSystem
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the start size value to affect to the specified gradient
         * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
         * @returns the current particle system
         */
        addStartSizeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;
        /**
         * Not supported by GPUParticleSystem
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeStartSizeGradient(gradient: number): IParticleSystem;
        /**
         * Not supported by GPUParticleSystem
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param min defines the color remap minimal range
         * @param max defines the color remap maximal range
         * @returns the current particle system
         */
        addColorRemapGradient(gradient: number, min: number, max: number): IParticleSystem;
        /**
         * Not supported by GPUParticleSystem
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeColorRemapGradient(): IParticleSystem;
        /**
         * Not supported by GPUParticleSystem
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param min defines the alpha remap minimal range
         * @param max defines the alpha remap maximal range
         * @returns the current particle system
         */
        addAlphaRemapGradient(gradient: number, min: number, max: number): IParticleSystem;
        /**
         * Not supported by GPUParticleSystem
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeAlphaRemapGradient(): IParticleSystem;
        /**
         * Not supported by GPUParticleSystem
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param color defines the color to affect to the specified gradient
         * @returns the current particle system
         */
        addRampGradient(gradient: number, color: Color3): IParticleSystem;
        /**
         * Not supported by GPUParticleSystem
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeRampGradient(): IParticleSystem;
        /**
         * Not supported by GPUParticleSystem
         * @returns the list of ramp gradients
         */
        getRampGradients(): Nullable<Array<Color3Gradient>>;
        /**
         * Not supported by GPUParticleSystem
         * Gets or sets a boolean indicating that ramp gradients must be used
         * @see https://doc.babylonjs.com/babylon101/particles#ramp-gradients
         */
        get useRampGradients(): boolean;
        set useRampGradients(value: boolean);
        /**
         * Not supported by GPUParticleSystem
         * @param gradient defines the gradient to use (between 0 and 1)
         * @param factor defines the life time factor to affect to the specified gradient
         * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
         * @returns the current particle system
         */
        addLifeTimeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem;
        /**
         * Not supported by GPUParticleSystem
         * @param gradient defines the gradient to remove
         * @returns the current particle system
         */
        removeLifeTimeGradient(gradient: number): IParticleSystem;
        /**
         * Instantiates a GPU particle system.
         * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
         * @param name The name of the particle system
         * @param options The options used to create the system
         * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene
         * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture
         * @param customEffect a custom effect used to change the way particles are rendered by default
         */
        constructor(name: string, options: Partial<{
            capacity: number;
            randomTextureSize: number;
        }>, sceneOrEngine: Scene | ThinEngine, isAnimationSheetEnabled?: boolean, customEffect?: Nullable<Effect>);
        protected _reset(): void;
        private _createUpdateVAO;
        private _createRenderVAO;
        private _initialize;
        /** @hidden */
        _recreateUpdateEffect(): void;
        private _getEffect;
        /**
         * Fill the defines array according to the current settings of the particle system
         * @param defines Array to be updated
         * @param blendMode blend mode to take into account when updating the array
         */
        fillDefines(defines: Array<string>, blendMode?: number): void;
        /**
         * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system
         * @param uniforms Uniforms array to fill
         * @param attributes Attributes array to fill
         * @param samplers Samplers array to fill
         */
        fillUniformsAttributesAndSamplerNames(uniforms: Array<string>, attributes: Array<string>, samplers: Array<string>): void;
        /** @hidden */
        _recreateRenderEffect(): Effect;
        /**
         * Animates the particle system for the current frame by emitting new particles and or animating the living ones.
         * @param preWarm defines if we are in the pre-warmimg phase
         */
        animate(preWarm?: boolean): void;
        private _createFactorGradientTexture;
        private _createSizeGradientTexture;
        private _createAngularSpeedGradientTexture;
        private _createVelocityGradientTexture;
        private _createLimitVelocityGradientTexture;
        private _createDragGradientTexture;
        private _createColorGradientTexture;
        /**
         * Renders the particle system in its current state
         * @param preWarm defines if the system should only update the particles but not render them
         * @returns the current number of particles
         */
        render(preWarm?: boolean): number;
        /**
         * Rebuilds the particle system
         */
        rebuild(): void;
        private _releaseBuffers;
        private _releaseVAOs;
        /**
         * Disposes the particle system and free the associated resources
         * @param disposeTexture defines if the particule texture must be disposed as well (true by default)
         */
        dispose(disposeTexture?: boolean): void;
        /**
         * Clones the particle system.
         * @param name The name of the cloned object
         * @param newEmitter The new emitter to use
         * @returns the cloned particle system
         */
        clone(name: string, newEmitter: any): GPUParticleSystem;
        /**
         * Serializes the particle system to a JSON object
         * @param serializeTexture defines if the texture must be serialized as well
         * @returns the JSON object
         */
        serialize(serializeTexture?: boolean): any;
        /**
         * Parses a JSON object to create a GPU particle system.
         * @param parsedParticleSystem The JSON object to parse
         * @param sceneOrEngine The scene or the engine to create the particle system in
         * @param rootUrl The root url to use to load external dependencies like texture
         * @param doNotStart Ignore the preventAutoStart attribute and does not start
         * @returns the parsed GPU particle system
         */
        static Parse(parsedParticleSystem: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string, doNotStart?: boolean): GPUParticleSystem;
    }
}
declare module BABYLON {
    /**
     * Represents a set of particle systems working together to create a specific effect
     */
    export class ParticleSystemSet implements IDisposable {
        /**
         * Gets or sets base Assets URL
         */
        static BaseAssetsUrl: string;
        private _emitterCreationOptions;
        private _emitterNode;
        /**
         * Gets the particle system list
         */
        systems: IParticleSystem[];
        /**
         * Gets the emitter node used with this set
         */
        get emitterNode(): Nullable<TransformNode>;
        /**
         * Creates a new emitter mesh as a sphere
         * @param options defines the options used to create the sphere
         * @param renderingGroupId defines the renderingGroupId to use for the sphere
         * @param scene defines the hosting scene
         */
        setEmitterAsSphere(options: {
            diameter: number;
            segments: number;
            color: Color3;
        }, renderingGroupId: number, scene: Scene): void;
        /**
         * Starts all particle systems of the set
         * @param emitter defines an optional mesh to use as emitter for the particle systems
         */
        start(emitter?: AbstractMesh): void;
        /**
         * Release all associated resources
         */
        dispose(): void;
        /**
         * Serialize the set into a JSON compatible object
         * @param serializeTexture defines if the texture must be serialized as well
         * @returns a JSON compatible representation of the set
         */
        serialize(serializeTexture?: boolean): any;
        /**
         * Parse a new ParticleSystemSet from a serialized source
         * @param data defines a JSON compatible representation of the set
         * @param scene defines the hosting scene
         * @param gpu defines if we want GPU particles or CPU particles
         * @returns a new ParticleSystemSet
         */
        static Parse(data: any, scene: Scene, gpu?: boolean): ParticleSystemSet;
    }
}
declare module BABYLON {
    /**
     * This class is made for on one-liner static method to help creating particle system set.
     */
    export class ParticleHelper {
        /**
         * Gets or sets base Assets URL
         */
        static BaseAssetsUrl: string;
        /** Define the Url to load snippets */
        static SnippetUrl: string;
        /**
         * Create a default particle system that you can tweak
         * @param emitter defines the emitter to use
         * @param capacity defines the system capacity (default is 500 particles)
         * @param scene defines the hosting scene
         * @param useGPU defines if a GPUParticleSystem must be created (default is false)
         * @returns the new Particle system
         */
        static CreateDefault(emitter: Nullable<AbstractMesh | Vector3>, capacity?: number, scene?: Scene, useGPU?: boolean): IParticleSystem;
        /**
         * This is the main static method (one-liner) of this helper to create different particle systems
         * @param type This string represents the type to the particle system to create
         * @param scene The scene where the particle system should live
         * @param gpu If the system will use gpu
         * @returns the ParticleSystemSet created
         */
        static CreateAsync(type: string, scene: Nullable<Scene>, gpu?: boolean): Promise<ParticleSystemSet>;
        /**
         * Static function used to export a particle system to a ParticleSystemSet variable.
         * Please note that the emitter shape is not exported
         * @param systems defines the particle systems to export
         * @returns the created particle system set
         */
        static ExportSet(systems: IParticleSystem[]): ParticleSystemSet;
        /**
         * Creates a particle system from a snippet saved in a remote file
         * @param name defines the name of the particle system to create (can be null or empty to use the one from the json data)
         * @param url defines the url to load from
         * @param scene defines the hosting scene
         * @param gpu If the system will use gpu
         * @param rootUrl defines the root URL to use to load textures and relative dependencies
         * @returns a promise that will resolve to the new particle system
         */
        static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, gpu?: boolean, rootUrl?: string): Promise<IParticleSystem>;
        /**
         * Creates a particle system from a snippet saved by the particle system editor
         * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)
         * @param scene defines the hosting scene
         * @param gpu If the system will use gpu
         * @param rootUrl defines the root URL to use to load textures and relative dependencies
         * @returns a promise that will resolve to the new particle system
         */
        static CreateFromSnippetAsync(snippetId: string, scene: Scene, gpu?: boolean, rootUrl?: string): Promise<IParticleSystem>;
    }
}
declare module BABYLON {
        interface Engine {
            /**
             * Create an effect to use with particle systems.
             * Please note that some parameters like animation sheets or not being billboard are not supported in this configuration, except if you pass
             * the particle system for which you want to create a custom effect in the last parameter
             * @param fragmentName defines the base name of the effect (The name of file without .fragment.fx)
             * @param uniformsNames defines a list of attribute names
             * @param samplers defines an array of string used to represent textures
             * @param defines defines the string containing the defines to use to compile the shaders
             * @param fallbacks defines the list of potential fallbacks to use if shader conmpilation fails
             * @param onCompiled defines a function to call when the effect creation is successful
             * @param onError defines a function to call when the effect creation has failed
             * @param particleSystem the particle system you want to create the effect for
             * @returns the new Effect
             */
            createEffectForParticles(fragmentName: string, uniformsNames: string[], samplers: string[], defines: string, fallbacks?: EffectFallbacks, onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void, particleSystem?: IParticleSystem): Effect;
        }
        interface Mesh {
            /**
             * Returns an array populated with IParticleSystem objects whose the mesh is the emitter
             * @returns an array of IParticleSystem
             */
            getEmittedParticleSystems(): IParticleSystem[];
            /**
             * Returns an array populated with IParticleSystem objects whose the mesh or its children are the emitter
             * @returns an array of IParticleSystem
             */
            getHierarchyEmittedParticleSystems(): IParticleSystem[];
        }
}
declare module BABYLON {
    /** Defines the 4 color options */
    export enum PointColor {
        /** color value */
        Color = 2,
        /** uv value */
        UV = 1,
        /** random value */
        Random = 0,
        /** stated value */
        Stated = 3
    }
    /**
     * The PointCloudSystem (PCS) is a single updatable mesh. The points corresponding to the vertices of this big mesh.
     * As it is just a mesh, the PointCloudSystem has all the same properties as any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.
     * The PointCloudSytem is also a particle system, with each point being a particle. It provides some methods to manage the particles.
     * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.
     *
     * Full documentation here : TO BE ENTERED
     */
    export class PointsCloudSystem implements IDisposable {
        /**
         *  The PCS array of cloud point objects. Just access each particle as with any classic array.
         *  Example : var p = SPS.particles[i];
         */
        particles: CloudPoint[];
        /**
         * The PCS total number of particles. Read only. Use PCS.counter instead if you need to set your own value.
         */
        nbParticles: number;
        /**
         * This a counter for your own usage. It's not set by any SPS functions.
         */
        counter: number;
        /**
         * The PCS name. This name is also given to the underlying mesh.
         */
        name: string;
        /**
         * The PCS mesh. It's a standard BJS Mesh, so all the methods from the Mesh class are avalaible.
         */
        mesh: Mesh;
        /**
         * This empty object is intended to store some PCS specific or temporary values in order to lower the Garbage Collector activity.
         * Please read :
         */
        vars: any;
        /**
         * @hidden
         */
        _size: number;
        private _scene;
        private _promises;
        private _positions;
        private _indices;
        private _normals;
        private _colors;
        private _uvs;
        private _indices32;
        private _positions32;
        private _colors32;
        private _uvs32;
        private _updatable;
        private _isVisibilityBoxLocked;
        private _alwaysVisible;
        private _groups;
        private _groupCounter;
        private _computeParticleColor;
        private _computeParticleTexture;
        private _computeParticleRotation;
        private _computeBoundingBox;
        private _isReady;
        /**
         * Creates a PCS (Points Cloud System) object
         * @param name (String) is the PCS name, this will be the underlying mesh name
         * @param pointSize (number) is the size for each point
         * @param scene (Scene) is the scene in which the PCS is added
         * @param options defines the options of the PCS e.g.
         * * updatable (optional boolean, default true) : if the PCS must be updatable or immutable
         */
        constructor(name: string, pointSize: number, scene: Scene, options?: {
            updatable?: boolean;
        });
        /**
         * Builds the PCS underlying mesh. Returns a standard Mesh.
         * If no points were added to the PCS, the returned mesh is just a single point.
         * @returns a promise for the created mesh
         */
        buildMeshAsync(): Promise<Mesh>;
        /**
         * @hidden
         */
        private _buildMesh;
        private _addParticle;
        private _randomUnitVector;
        private _getColorIndicesForCoord;
        private _setPointsColorOrUV;
        private _colorFromTexture;
        private _calculateDensity;
        /**
         * Adds points to the PCS in random positions within a unit sphere
         * @param nb (positive integer) the number of particles to be created from this model
         * @param pointFunction is an optional javascript function to be called for each particle on PCS creation
         * @returns the number of groups in the system
         */
        addPoints(nb: number, pointFunction?: any): number;
        /**
         * Adds points to the PCS from the surface of the model shape
         * @param mesh is any Mesh object that will be used as a surface model for the points
         * @param nb (positive integer) the number of particles to be created from this model
         * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)
         * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position
         * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color
         * @returns the number of groups in the system
         */
        addSurfacePoints(mesh: Mesh, nb: number, colorWith?: number, color?: Color4 | number, range?: number): number;
        /**
         * Adds points to the PCS inside the model shape
         * @param mesh is any Mesh object that will be used as a surface model for the points
         * @param nb (positive integer) the number of particles to be created from this model
         * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)
         * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position
         * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color
         * @returns the number of groups in the system
         */
        addVolumePoints(mesh: Mesh, nb: number, colorWith?: number, color?: Color4 | number, range?: number): number;
        /**
         *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.
         *  This method calls `updateParticle()` for each particle of the SPS.
         *  For an animated SPS, it is usually called within the render loop.
         * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_
         * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_
         * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_
         * @returns the PCS.
         */
        setParticles(start?: number, end?: number, update?: boolean): PointsCloudSystem;
        /**
        * Disposes the PCS.
        */
        dispose(): void;
        /**
         * Visibilty helper : Recomputes the visible size according to the mesh bounding box
         * doc :
         * @returns the PCS.
         */
        refreshVisibleSize(): PointsCloudSystem;
        /**
         * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.
         * @param size the size (float) of the visibility box
         * note : this doesn't lock the PCS mesh bounding box.
         * doc :
         */
        setVisibilityBox(size: number): void;
        /**
         * Gets whether the PCS is always visible or not
         * doc :
         */
        get isAlwaysVisible(): boolean;
        /**
         * Sets the PCS as always visible or not
         * doc :
         */
        set isAlwaysVisible(val: boolean);
        /**
         * Tells to `setParticles()` to compute the particle rotations or not
         * Default value : false. The PCS is faster when it's set to false
         * Note : particle rotations are only applied to parent particles
         * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate
         */
        set computeParticleRotation(val: boolean);
        /**
         * Tells to `setParticles()` to compute the particle colors or not.
         * Default value : true. The PCS is faster when it's set to false.
         * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.
         */
        set computeParticleColor(val: boolean);
        set computeParticleTexture(val: boolean);
        /**
         * Gets if `setParticles()` computes the particle colors or not.
         * Default value : false. The PCS is faster when it's set to false.
         * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.
         */
        get computeParticleColor(): boolean;
        /**
         * Gets if `setParticles()` computes the particle textures or not.
         * Default value : false. The PCS is faster when it's set to false.
         * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.
         */
        get computeParticleTexture(): boolean;
        /**
         * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.
         */
        set computeBoundingBox(val: boolean);
        /**
         * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.
         */
        get computeBoundingBox(): boolean;
        /**
         * This function does nothing. It may be overwritten to set all the particle first values.
         * The PCS doesn't call this function, you may have to call it by your own.
         * doc :
         */
        initParticles(): void;
        /**
         * This function does nothing. It may be overwritten to recycle a particle
         * The PCS doesn't call this function, you can to call it
         * doc :
         * @param particle The particle to recycle
         * @returns the recycled particle
         */
        recycleParticle(particle: CloudPoint): CloudPoint;
        /**
         * Updates a particle : this function should  be overwritten by the user.
         * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.
         * doc :
         * @example : just set a particle position or velocity and recycle conditions
         * @param particle The particle to update
         * @returns the updated particle
         */
        updateParticle(particle: CloudPoint): CloudPoint;
        /**
         * This will be called before any other treatment by `setParticles()` and will be passed three parameters.
         * This does nothing and may be overwritten by the user.
         * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()
         * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
         * @param update the boolean update value actually passed to setParticles()
         */
        beforeUpdateParticles(start?: number, stop?: number, update?: boolean): void;
        /**
         * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.
         * This will be passed three parameters.
         * This does nothing and may be overwritten by the user.
         * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()
         * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
         * @param update the boolean update value actually passed to setParticles()
         */
        afterUpdateParticles(start?: number, stop?: number, update?: boolean): void;
    }
}
declare module BABYLON {
    /**
     * Represents one particle of a points cloud system.
     */
    export class CloudPoint {
        /**
         * particle global index
         */
        idx: number;
        /**
         * The color of the particle
         */
        color: Nullable<Color4>;
        /**
         * The world space position of the particle.
         */
        position: Vector3;
        /**
         * The world space rotation of the particle. (Not use if rotationQuaternion is set)
         */
        rotation: Vector3;
        /**
         * The world space rotation quaternion of the particle.
         */
        rotationQuaternion: Nullable<Quaternion>;
        /**
         * The uv of the particle.
         */
        uv: Nullable<Vector2>;
        /**
         * The current speed of the particle.
         */
        velocity: Vector3;
        /**
         * The pivot point in the particle local space.
         */
        pivot: Vector3;
        /**
         * Must the particle be translated from its pivot point in its local space ?
         * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.
         * Default : false
         */
        translateFromPivot: boolean;
        /**
         * Index of this particle in the global "positions" array (Internal use)
         * @hidden
         */
        _pos: number;
        /**
         * @hidden Index of this particle in the global "indices" array (Internal use)
         */
        _ind: number;
        /**
         * Group this particle belongs to
         */
        _group: PointsGroup;
        /**
         * Group id of this particle
         */
        groupId: number;
        /**
         * Index of the particle in its group id (Internal use)
         */
        idxInGroup: number;
        /**
         * @hidden Particle BoundingInfo object (Internal use)
         */
        _boundingInfo: BoundingInfo;
        /**
         * @hidden Reference to the PCS that the particle belongs to (Internal use)
         */
        _pcs: PointsCloudSystem;
        /**
         * @hidden Still set as invisible in order to skip useless computations (Internal use)
         */
        _stillInvisible: boolean;
        /**
         * @hidden Last computed particle rotation matrix
         */
        _rotationMatrix: number[];
        /**
         * Parent particle Id, if any.
         * Default null.
         */
        parentId: Nullable<number>;
        /**
         * @hidden Internal global position in the PCS.
         */
        _globalPosition: Vector3;
        /**
         * Creates a Point Cloud object.
         * Don't create particles manually, use instead the PCS internal tools like _addParticle()
         * @param particleIndex (integer) is the particle index in the PCS pool. It's also the particle identifier.
         * @param group (PointsGroup) is the group the particle belongs to
         * @param groupId (integer) is the group identifier in the PCS.
         * @param idxInGroup (integer) is the index of the particle in the current point group (ex: the 10th point of addPoints(30))
         * @param pcs defines the PCS it is associated to
         */
        constructor(particleIndex: number, group: PointsGroup, groupId: number, idxInGroup: number, pcs: PointsCloudSystem);
        /**
         * get point size
         */
        get size(): Vector3;
        /**
         * Set point size
         */
        set size(scale: Vector3);
        /**
         * Legacy support, changed quaternion to rotationQuaternion
         */
        get quaternion(): Nullable<Quaternion>;
        /**
         * Legacy support, changed quaternion to rotationQuaternion
         */
        set quaternion(q: Nullable<Quaternion>);
        /**
         * Returns a boolean. True if the particle intersects a mesh, else false
         * The intersection is computed on the particle position and Axis Aligned Bounding Box (AABB) or Sphere
         * @param target is the object (point or mesh) what the intersection is computed against
         * @param isSphere is boolean flag when false (default) bounding box of mesh is used, when true the bouding sphere is used
         * @returns true if it intersects
         */
        intersectsMesh(target: Mesh, isSphere: boolean): boolean;
        /**
         * get the rotation matrix of the particle
         * @hidden
         */
        getRotationMatrix(m: Matrix): void;
    }
    /**
     * Represents a group of points in a points cloud system
     *  * PCS internal tool, don't use it manually.
     */
    export class PointsGroup {
        /**
         * The group id
         * @hidden
         */
        groupID: number;
        /**
         * image data for group (internal use)
         * @hidden
         */
        _groupImageData: Nullable<ArrayBufferView>;
        /**
         * Image Width (internal use)
         * @hidden
         */
        _groupImgWidth: number;
        /**
         * Image Height (internal use)
         * @hidden
         */
        _groupImgHeight: number;
        /**
         * Custom position function (internal use)
         * @hidden
         */
        _positionFunction: Nullable<(particle: CloudPoint, i?: number, s?: number) => void>;
        /**
         * density per facet for surface points
         * @hidden
         */
        _groupDensity: number[];
        /**
         * Only when points are colored by texture carries pointer to texture list array
         * @hidden
         */
        _textureNb: number;
        /**
         * Creates a points group object. This is an internal reference to produce particles for the PCS.
         * PCS internal tool, don't use it manually.
         * @hidden
         */
        constructor(id: number, posFunction: Nullable<(particle: CloudPoint, i?: number, s?: number) => void>);
    }
}
declare module BABYLON {
        interface Scene {
            /** @hidden (Backing field) */
            _physicsEngine: Nullable<IPhysicsEngine>;
            /** @hidden */
            _physicsTimeAccumulator: number;
            /**
             * Gets the current physics engine
             * @returns a IPhysicsEngine or null if none attached
             */
            getPhysicsEngine(): Nullable<IPhysicsEngine>;
            /**
             * Enables physics to the current scene
             * @param gravity defines the scene's gravity for the physics engine
             * @param plugin defines the physics engine to be used. defaults to OimoJS.
             * @return a boolean indicating if the physics engine was initialized
             */
            enablePhysics(gravity: Nullable<Vector3>, plugin?: IPhysicsEnginePlugin): boolean;
            /**
             * Disables and disposes the physics engine associated with the scene
             */
            disablePhysicsEngine(): void;
            /**
             * Gets a boolean indicating if there is an active physics engine
             * @returns a boolean indicating if there is an active physics engine
             */
            isPhysicsEnabled(): boolean;
            /**
             * Deletes a physics compound impostor
             * @param compound defines the compound to delete
             */
            deleteCompoundImpostor(compound: any): void;
            /**
            * An event triggered when physic simulation is about to be run
            */
            onBeforePhysicsObservable: Observable<Scene>;
            /**
             * An event triggered when physic simulation has been done
             */
            onAfterPhysicsObservable: Observable<Scene>;
        }
        interface AbstractMesh {
            /** @hidden */
            _physicsImpostor: Nullable<PhysicsImpostor>;
            /**
             * Gets or sets impostor used for physic simulation
             * @see https://doc.babylonjs.com/features/physics_engine
             */
            physicsImpostor: Nullable<PhysicsImpostor>;
            /**
             * Gets the current physics impostor
             * @see https://doc.babylonjs.com/features/physics_engine
             * @returns a physics impostor or null
             */
            getPhysicsImpostor(): Nullable<PhysicsImpostor>;
            /** Apply a physic impulse to the mesh
             * @param force defines the force to apply
             * @param contactPoint defines where to apply the force
             * @returns the current mesh
             * @see https://doc.babylonjs.com/how_to/using_the_physics_engine
             */
            applyImpulse(force: Vector3, contactPoint: Vector3): AbstractMesh;
            /**
             * Creates a physic joint between two meshes
             * @param otherMesh defines the other mesh to use
             * @param pivot1 defines the pivot to use on this mesh
             * @param pivot2 defines the pivot to use on the other mesh
             * @param options defines additional options (can be plugin dependent)
             * @returns the current mesh
             * @see https://www.babylonjs-playground.com/#0BS5U0#0
             */
            setPhysicsLinkWith(otherMesh: Mesh, pivot1: Vector3, pivot2: Vector3, options?: any): AbstractMesh;
            /** @hidden */
            _disposePhysicsObserver: Nullable<Observer<Node>>;
        }
    /**
     * Defines the physics engine scene component responsible to manage a physics engine
     */
    export class PhysicsEngineSceneComponent implements ISceneComponent {
        /**
         * The component name helpful to identify the component in the list of scene components.
         */
        readonly name: string;
        /**
         * The scene the component belongs to.
         */
        scene: Scene;
        /**
         * Creates a new instance of the component for the given scene
         * @param scene Defines the scene to register the component in
         */
        constructor(scene: Scene);
        /**
         * Registers the component in a given scene
         */
        register(): void;
        /**
         * Rebuilds the elements related to this component in case of
         * context lost for instance.
         */
        rebuild(): void;
        /**
         * Disposes the component and the associated ressources
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * A helper for physics simulations
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
     */
    export class PhysicsHelper {
        private _scene;
        private _physicsEngine;
        /**
         * Initializes the Physics helper
         * @param scene Babylon.js scene
         */
        constructor(scene: Scene);
        /**
         * Applies a radial explosion impulse
         * @param origin the origin of the explosion
         * @param radiusOrEventOptions the radius or the options of radial explosion
         * @param strength the explosion strength
         * @param falloff possible options: Constant & Linear. Defaults to Constant
         * @returns A physics radial explosion event, or null
         */
        applyRadialExplosionImpulse(origin: Vector3, radiusOrEventOptions: number | PhysicsRadialExplosionEventOptions, strength?: number, falloff?: PhysicsRadialImpulseFalloff): Nullable<PhysicsRadialExplosionEvent>;
        /**
         * Applies a radial explosion force
         * @param origin the origin of the explosion
         * @param radiusOrEventOptions the radius or the options of radial explosion
         * @param strength the explosion strength
         * @param falloff possible options: Constant & Linear. Defaults to Constant
         * @returns A physics radial explosion event, or null
         */
        applyRadialExplosionForce(origin: Vector3, radiusOrEventOptions: number | PhysicsRadialExplosionEventOptions, strength?: number, falloff?: PhysicsRadialImpulseFalloff): Nullable<PhysicsRadialExplosionEvent>;
        /**
         * Creates a gravitational field
         * @param origin the origin of the explosion
         * @param radiusOrEventOptions the radius or the options of radial explosion
         * @param strength the explosion strength
         * @param falloff possible options: Constant & Linear. Defaults to Constant
         * @returns A physics gravitational field event, or null
         */
        gravitationalField(origin: Vector3, radiusOrEventOptions: number | PhysicsRadialExplosionEventOptions, strength?: number, falloff?: PhysicsRadialImpulseFalloff): Nullable<PhysicsGravitationalFieldEvent>;
        /**
         * Creates a physics updraft event
         * @param origin the origin of the updraft
         * @param radiusOrEventOptions the radius or the options of the updraft
         * @param strength the strength of the updraft
         * @param height the height of the updraft
         * @param updraftMode possible options: Center & Perpendicular. Defaults to Center
         * @returns A physics updraft event, or null
         */
        updraft(origin: Vector3, radiusOrEventOptions: number | PhysicsUpdraftEventOptions, strength?: number, height?: number, updraftMode?: PhysicsUpdraftMode): Nullable<PhysicsUpdraftEvent>;
        /**
         * Creates a physics vortex event
         * @param origin the of the vortex
         * @param radiusOrEventOptions the radius or the options of the vortex
         * @param strength the strength of the vortex
         * @param height   the height of the vortex
         * @returns a Physics vortex event, or null
         * A physics vortex event or null
         */
        vortex(origin: Vector3, radiusOrEventOptions: number | PhysicsVortexEventOptions, strength?: number, height?: number): Nullable<PhysicsVortexEvent>;
    }
    /**
     * Represents a physics radial explosion event
     */
    class PhysicsRadialExplosionEvent {
        private _scene;
        private _options;
        private _sphere;
        private _dataFetched;
        /**
         * Initializes a radial explosioin event
         * @param _scene BabylonJS scene
         * @param _options The options for the vortex event
         */
        constructor(_scene: Scene, _options: PhysicsRadialExplosionEventOptions);
        /**
         * Returns the data related to the radial explosion event (sphere).
         * @returns The radial explosion event data
         */
        getData(): PhysicsRadialExplosionEventData;
        /**
         * Returns the force and contact point of the impostor or false, if the impostor is not affected by the force/impulse.
         * @param impostor A physics imposter
         * @param origin the origin of the explosion
         * @returns {Nullable<PhysicsHitData>} A physics force and contact point, or null
         */
        getImpostorHitData(impostor: PhysicsImpostor, origin: Vector3): Nullable<PhysicsHitData>;
        /**
         * Triggers affecterd impostors callbacks
         * @param affectedImpostorsWithData defines the list of affected impostors (including associated data)
         */
        triggerAffectedImpostorsCallback(affectedImpostorsWithData: Array<PhysicsAffectedImpostorWithData>): void;
        /**
         * Disposes the sphere.
         * @param force Specifies if the sphere should be disposed by force
         */
        dispose(force?: boolean): void;
        /*** Helpers ***/
        private _prepareSphere;
        private _intersectsWithSphere;
    }
    /**
     * Represents a gravitational field event
     */
    class PhysicsGravitationalFieldEvent {
        private _physicsHelper;
        private _scene;
        private _origin;
        private _options;
        private _tickCallback;
        private _sphere;
        private _dataFetched;
        /**
         * Initializes the physics gravitational field event
         * @param _physicsHelper A physics helper
         * @param _scene BabylonJS scene
         * @param _origin The origin position of the gravitational field event
         * @param _options The options for the vortex event
         */
        constructor(_physicsHelper: PhysicsHelper, _scene: Scene, _origin: Vector3, _options: PhysicsRadialExplosionEventOptions);
        /**
         * Returns the data related to the gravitational field event (sphere).
         * @returns A gravitational field event
         */
        getData(): PhysicsGravitationalFieldEventData;
        /**
         * Enables the gravitational field.
         */
        enable(): void;
        /**
         * Disables the gravitational field.
         */
        disable(): void;
        /**
         * Disposes the sphere.
         * @param force The force to dispose from the gravitational field event
         */
        dispose(force?: boolean): void;
        private _tick;
    }
    /**
     * Represents a physics updraft event
     */
    class PhysicsUpdraftEvent {
        private _scene;
        private _origin;
        private _options;
        private _physicsEngine;
        private _originTop;
        private _originDirection;
        private _tickCallback;
        private _cylinder;
        private _cylinderPosition;
        private _dataFetched;
        /**
         * Initializes the physics updraft event
         * @param _scene BabylonJS scene
         * @param _origin The origin position of the updraft
         * @param _options The options for the updraft event
         */
        constructor(_scene: Scene, _origin: Vector3, _options: PhysicsUpdraftEventOptions);
        /**
         * Returns the data related to the updraft event (cylinder).
         * @returns A physics updraft event
         */
        getData(): PhysicsUpdraftEventData;
        /**
         * Enables the updraft.
         */
        enable(): void;
        /**
         * Disables the updraft.
         */
        disable(): void;
        /**
         * Disposes the cylinder.
         * @param force Specifies if the updraft should be disposed by force
         */
        dispose(force?: boolean): void;
        private getImpostorHitData;
        private _tick;
        /*** Helpers ***/
        private _prepareCylinder;
        private _intersectsWithCylinder;
    }
    /**
     * Represents a physics vortex event
     */
    class PhysicsVortexEvent {
        private _scene;
        private _origin;
        private _options;
        private _physicsEngine;
        private _originTop;
        private _tickCallback;
        private _cylinder;
        private _cylinderPosition;
        private _dataFetched;
        /**
         * Initializes the physics vortex event
         * @param _scene The BabylonJS scene
         * @param _origin The origin position of the vortex
         * @param _options The options for the vortex event
         */
        constructor(_scene: Scene, _origin: Vector3, _options: PhysicsVortexEventOptions);
        /**
         * Returns the data related to the vortex event (cylinder).
         * @returns The physics vortex event data
         */
        getData(): PhysicsVortexEventData;
        /**
         * Enables the vortex.
         */
        enable(): void;
        /**
         * Disables the cortex.
         */
        disable(): void;
        /**
         * Disposes the sphere.
         * @param force
         */
        dispose(force?: boolean): void;
        private getImpostorHitData;
        private _tick;
        /*** Helpers ***/
        private _prepareCylinder;
        private _intersectsWithCylinder;
    }
    /**
     * Options fot the radial explosion event
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
     */
    export class PhysicsRadialExplosionEventOptions {
        /**
         * The radius of the sphere for the radial explosion.
         */
        radius: number;
        /**
         * The strenth of the explosion.
         */
        strength: number;
        /**
         * The strenght of the force in correspondence to the distance of the affected object
         */
        falloff: PhysicsRadialImpulseFalloff;
        /**
         * Sphere options for the radial explosion.
         */
        sphere: {
            segments: number;
            diameter: number;
        };
        /**
         * Sphere options for the radial explosion.
         */
        affectedImpostorsCallback: (affectedImpostorsWithData: Array<PhysicsAffectedImpostorWithData>) => void;
    }
    /**
     * Options fot the updraft event
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
     */
    export class PhysicsUpdraftEventOptions {
        /**
         * The radius of the cylinder for the vortex
         */
        radius: number;
        /**
         * The strenth of the updraft.
         */
        strength: number;
        /**
         * The height of the cylinder for the updraft.
         */
        height: number;
        /**
         * The mode for the the updraft.
         */
        updraftMode: PhysicsUpdraftMode;
    }
    /**
     * Options fot the vortex event
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
     */
    export class PhysicsVortexEventOptions {
        /**
         * The radius of the cylinder for the vortex
         */
        radius: number;
        /**
         * The strenth of the vortex.
         */
        strength: number;
        /**
         * The height of the cylinder for the vortex.
         */
        height: number;
        /**
         * At which distance, relative to the radius the centripetal forces should kick in? Range: 0-1
         */
        centripetalForceThreshold: number;
        /**
         * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when below the treshold.
         */
        centripetalForceMultiplier: number;
        /**
         * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when above the treshold.
         */
        centrifugalForceMultiplier: number;
        /**
         * This multiplier determines with how much force the objects will be pushed upwards, when in the vortex.
         */
        updraftForceMultiplier: number;
    }
    /**
    * The strenght of the force in correspondence to the distance of the affected object
    * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
    */
    export enum PhysicsRadialImpulseFalloff {
        /** Defines that impulse is constant in strength across it's whole radius */
        Constant = 0,
        /** Defines that impulse gets weaker if it's further from the origin */
        Linear = 1
    }
    /**
     * The strength of the force in correspondence to the distance of the affected object
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
     */
    export enum PhysicsUpdraftMode {
        /** Defines that the upstream forces will pull towards the top center of the cylinder */
        Center = 0,
        /** Defines that once a impostor is inside the cylinder, it will shoot out perpendicular from the ground of the cylinder */
        Perpendicular = 1
    }
    /**
     * Interface for a physics hit data
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
     */
    export interface PhysicsHitData {
        /**
         * The force applied at the contact point
         */
        force: Vector3;
        /**
         * The contact point
         */
        contactPoint: Vector3;
        /**
         * The distance from the origin to the contact point
         */
        distanceFromOrigin: number;
    }
    /**
     * Interface for radial explosion event data
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
     */
    export interface PhysicsRadialExplosionEventData {
        /**
         * A sphere used for the radial explosion event
         */
        sphere: Mesh;
    }
    /**
     * Interface for gravitational field event data
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
     */
    export interface PhysicsGravitationalFieldEventData {
        /**
         * A sphere mesh used for the gravitational field event
         */
        sphere: Mesh;
    }
    /**
     * Interface for updraft event data
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
     */
    export interface PhysicsUpdraftEventData {
        /**
         * A cylinder used for the updraft event
         */
        cylinder: Mesh;
    }
    /**
     * Interface for vortex event data
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
     */
    export interface PhysicsVortexEventData {
        /**
         * A cylinder used for the vortex event
         */
        cylinder: Mesh;
    }
    /**
     * Interface for an affected physics impostor
     * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class
     */
    export interface PhysicsAffectedImpostorWithData {
        /**
         * The impostor affected by the effect
         */
        impostor: PhysicsImpostor;
        /**
         * The data about the hit/horce from the explosion
         */
        hitData: PhysicsHitData;
    }
}
declare module BABYLON {
    /** @hidden */
    export var blackAndWhitePixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Post process used to render in black and white
     */
    export class BlackAndWhitePostProcess extends PostProcess {
        /**
         * Linear about to convert he result to black and white (default: 1)
         */
        degree: number;
        /**
         * Gets a string identifying the name of the class
         * @returns "BlackAndWhitePostProcess" string
         */
        getClassName(): string;
        /**
         * Creates a black and white post process
         * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#black-and-white
         * @param name The name of the effect.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         */
        constructor(name: string, options: number | PostProcessOptions, camera: Camera, samplingMode?: number, engine?: Engine, reusable?: boolean);
        /** @hidden */
        static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<BlackAndWhitePostProcess>;
    }
}
declare module BABYLON {
    /**
     * This represents a set of one or more post processes in Babylon.
     * A post process can be used to apply a shader to a texture after it is rendered.
     * @example https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline
     */
    export class PostProcessRenderEffect {
        private _postProcesses;
        private _getPostProcesses;
        private _singleInstance;
        private _cameras;
        private _indicesForCamera;
        /**
         * Name of the effect
         * @hidden
         */
        _name: string;
        /**
         * Instantiates a post process render effect.
         * A post process can be used to apply a shader to a texture after it is rendered.
         * @param engine The engine the effect is tied to
         * @param name The name of the effect
         * @param getPostProcesses A function that returns a set of post processes which the effect will run in order to be run.
         * @param singleInstance False if this post process can be run on multiple cameras. (default: true)
         */
        constructor(engine: Engine, name: string, getPostProcesses: () => Nullable<PostProcess | Array<PostProcess>>, singleInstance?: boolean);
        /**
         * Checks if all the post processes in the effect are supported.
         */
        get isSupported(): boolean;
        /**
         * Updates the current state of the effect
         * @hidden
         */
        _update(): void;
        /**
         * Attaches the effect on cameras
         * @param cameras The camera to attach to.
         * @hidden
         */
        _attachCameras(cameras: Camera): void;
        /**
         * Attaches the effect on cameras
         * @param cameras The camera to attach to.
         * @hidden
         */
        _attachCameras(cameras: Camera[]): void;
        /**
         * Detaches the effect on cameras
         * @param cameras The camera to detatch from.
         * @hidden
         */
        _detachCameras(cameras: Camera): void;
        /**
         * Detatches the effect on cameras
         * @param cameras The camera to detatch from.
         * @hidden
         */
        _detachCameras(cameras: Camera[]): void;
        /**
         * Enables the effect on given cameras
         * @param cameras The camera to enable.
         * @hidden
         */
        _enable(cameras: Camera): void;
        /**
         * Enables the effect on given cameras
         * @param cameras The camera to enable.
         * @hidden
         */
        _enable(cameras: Nullable<Camera[]>): void;
        /**
         * Disables the effect on the given cameras
         * @param cameras The camera to disable.
         * @hidden
         */
        _disable(cameras: Camera): void;
        /**
         * Disables the effect on the given cameras
         * @param cameras The camera to disable.
         * @hidden
         */
        _disable(cameras: Nullable<Camera[]>): void;
        /**
         * Gets a list of the post processes contained in the effect.
         * @param camera The camera to get the post processes on.
         * @returns The list of the post processes in the effect.
         */
        getPostProcesses(camera?: Camera): Nullable<Array<PostProcess>>;
    }
}
declare module BABYLON {
    /** @hidden */
    export var extractHighlightsPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * The extract highlights post process sets all pixels to black except pixels above the specified luminance threshold. Used as the first step for a bloom effect.
     */
    export class ExtractHighlightsPostProcess extends PostProcess {
        /**
         * The luminance threshold, pixels below this value will be set to black.
         */
        threshold: number;
        /** @hidden */
        _exposure: number;
        /**
         * Post process which has the input texture to be used when performing highlight extraction
         * @hidden
         */
        _inputPostProcess: Nullable<PostProcess>;
        /**
         * Gets a string identifying the name of the class
         * @returns "ExtractHighlightsPostProcess" string
         */
        getClassName(): string;
        constructor(name: string, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
    }
}
declare module BABYLON {
    /** @hidden */
    export var bloomMergePixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * The BloomMergePostProcess merges blurred images with the original based on the values of the circle of confusion.
     */
    export class BloomMergePostProcess extends PostProcess {
        /** Weight of the bloom to be added to the original input. */
        weight: number;
        /**
         * Gets a string identifying the name of the class
         * @returns "BloomMergePostProcess" string
         */
        getClassName(): string;
        /**
         * Creates a new instance of @see BloomMergePostProcess
         * @param name The name of the effect.
         * @param originalFromInput Post process which's input will be used for the merge.
         * @param blurred Blurred highlights post process which's output will be used.
         * @param weight Weight of the bloom to be added to the original input.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, originalFromInput: PostProcess, blurred: PostProcess, 
        /** Weight of the bloom to be added to the original input. */
        weight: number, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
    }
}
declare module BABYLON {
    /**
     * The bloom effect spreads bright areas of an image to simulate artifacts seen in cameras
     */
    export class BloomEffect extends PostProcessRenderEffect {
        private bloomScale;
        /**
         * @hidden Internal
         */
        _effects: Array<PostProcess>;
        /**
         * @hidden Internal
         */
        _downscale: ExtractHighlightsPostProcess;
        private _blurX;
        private _blurY;
        private _merge;
        /**
         * The luminance threshold to find bright areas of the image to bloom.
         */
        get threshold(): number;
        set threshold(value: number);
        /**
         * The strength of the bloom.
         */
        get weight(): number;
        set weight(value: number);
        /**
         * Specifies the size of the bloom blur kernel, relative to the final output size
         */
        get kernel(): number;
        set kernel(value: number);
        /**
         * Creates a new instance of @see BloomEffect
         * @param scene The scene the effect belongs to.
         * @param bloomScale The ratio of the blur texture to the input texture that should be used to compute the bloom.
         * @param bloomKernel The size of the kernel to be used when applying the blur.
         * @param bloomWeight The the strength of bloom.
         * @param pipelineTextureType The type of texture to be used when performing the post processing.
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(scene: Scene, bloomScale: number, bloomWeight: number, bloomKernel: number, pipelineTextureType?: number, blockCompilation?: boolean);
        /**
         * Disposes each of the internal effects for a given camera.
         * @param camera The camera to dispose the effect on.
         */
        disposeEffects(camera: Camera): void;
        /**
         * @hidden Internal
         */
        _updateEffects(): void;
        /**
         * Internal
         * @returns if all the contained post processes are ready.
         * @hidden
         */
        _isReady(): boolean;
    }
}
declare module BABYLON {
    /** @hidden */
    export var chromaticAberrationPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * The ChromaticAberrationPostProcess separates the rgb channels in an image to produce chromatic distortion around the edges of the screen
     */
    export class ChromaticAberrationPostProcess extends PostProcess {
        /**
         * The amount of seperation of rgb channels (default: 30)
         */
        aberrationAmount: number;
        /**
         * The amount the effect will increase for pixels closer to the edge of the screen. (default: 0)
         */
        radialIntensity: number;
        /**
         * The normilized direction in which the rgb channels should be seperated. If set to 0,0 radial direction will be used. (default: Vector2(0.707,0.707))
         */
        direction: Vector2;
        /**
         * The center position where the radialIntensity should be around. [0.5,0.5 is center of screen, 1,1 is top right corder] (default: Vector2(0.5 ,0.5))
         */
        centerPosition: Vector2;
        /** The width of the screen to apply the effect on */
        screenWidth: number;
        /** The height of the screen to apply the effect on */
        screenHeight: number;
        /**
         * Gets a string identifying the name of the class
         * @returns "ChromaticAberrationPostProcess" string
         */
        getClassName(): string;
        /**
         * Creates a new instance ChromaticAberrationPostProcess
         * @param name The name of the effect.
         * @param screenWidth The width of the screen to apply the effect on.
         * @param screenHeight The height of the screen to apply the effect on.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, screenWidth: number, screenHeight: number, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
        /** @hidden */
        static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<ChromaticAberrationPostProcess>;
    }
}
declare module BABYLON {
    /** @hidden */
    export var circleOfConfusionPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * The CircleOfConfusionPostProcess computes the circle of confusion value for each pixel given required lens parameters. See https://en.wikipedia.org/wiki/Circle_of_confusion
     */
    export class CircleOfConfusionPostProcess extends PostProcess {
        /**
         * Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diamater of the resulting aperture can be computed by lensSize/fStop.
         */
        lensSize: number;
        /**
         * F-Stop of the effect's camera. The diamater of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)
         */
        fStop: number;
        /**
         * Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)
         */
        focusDistance: number;
        /**
         * Focal length of the effect's camera in scene units/1000 (eg. millimeter). (default: 50)
         */
        focalLength: number;
        /**
         * Gets a string identifying the name of the class
         * @returns "CircleOfConfusionPostProcess" string
         */
        getClassName(): string;
        private _depthTexture;
        /**
         * Creates a new instance CircleOfConfusionPostProcess
         * @param name The name of the effect.
         * @param depthTexture The depth texture of the scene to compute the circle of confusion. This must be set in order for this to function but may be set after initialization if needed.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, depthTexture: Nullable<RenderTargetTexture>, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
        /**
         * Depth texture to be used to compute the circle of confusion. This must be set here or in the constructor in order for the post process to function.
         */
        set depthTexture(value: RenderTargetTexture);
    }
}
declare module BABYLON {
    /** @hidden */
    export var colorCorrectionPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     *
     * This post-process allows the modification of rendered colors by using
     * a 'look-up table' (LUT). This effect is also called Color Grading.
     *
     * The object needs to be provided an url to a texture containing the color
     * look-up table: the texture must be 256 pixels wide and 16 pixels high.
     * Use an image editing software to tweak the LUT to match your needs.
     *
     * For an example of a color LUT, see here:
     * @see http://udn.epicgames.com/Three/rsrc/Three/ColorGrading/RGBTable16x1.png
     * For explanations on color grading, see here:
     * @see http://udn.epicgames.com/Three/ColorGrading.html
     *
     */
    export class ColorCorrectionPostProcess extends PostProcess {
        private _colorTableTexture;
        /**
         * Gets the color table url used to create the LUT texture
         */
        colorTableUrl: string;
        /**
         * Gets a string identifying the name of the class
         * @returns "ColorCorrectionPostProcess" string
         */
        getClassName(): string;
        constructor(name: string, colorTableUrl: string, options: number | PostProcessOptions, camera: Camera, samplingMode?: number, engine?: Engine, reusable?: boolean);
        /** @hidden */
        static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<ColorCorrectionPostProcess>;
    }
}
declare module BABYLON {
    /** @hidden */
    export var convolutionPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * The ConvolutionPostProcess applies a 3x3 kernel to every pixel of the
     * input texture to perform effects such as edge detection or sharpening
     * See http://en.wikipedia.org/wiki/Kernel_(image_processing)
     */
    export class ConvolutionPostProcess extends PostProcess {
        /** Array of 9 values corresponding to the 3x3 kernel to be applied */
        kernel: number[];
        /**
         * Gets a string identifying the name of the class
         * @returns "ConvolutionPostProcess" string
         */
        getClassName(): string;
        /**
         * Creates a new instance ConvolutionPostProcess
         * @param name The name of the effect.
         * @param kernel Array of 9 values corresponding to the 3x3 kernel to be applied
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         */
        constructor(name: string, kernel: number[], options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number);
        /** @hidden */
        static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<ConvolutionPostProcess>;
        /**
         * Edge detection 0 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
         */
        static EdgeDetect0Kernel: number[];
        /**
         * Edge detection 1 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
         */
        static EdgeDetect1Kernel: number[];
        /**
         * Edge detection 2 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
         */
        static EdgeDetect2Kernel: number[];
        /**
         * Kernel to sharpen an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
         */
        static SharpenKernel: number[];
        /**
         * Kernel to emboss an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
         */
        static EmbossKernel: number[];
        /**
         * Kernel to blur an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
         */
        static GaussianKernel: number[];
    }
}
declare module BABYLON {
    /**
     * The DepthOfFieldBlurPostProcess applied a blur in a give direction.
     * This blur differs from the standard BlurPostProcess as it attempts to avoid blurring pixels
     * based on samples that have a large difference in distance than the center pixel.
     * See section 2.6.2 http://fileadmin.cs.lth.se/cs/education/edan35/lectures/12dof.pdf
     */
    export class DepthOfFieldBlurPostProcess extends BlurPostProcess {
        /**
         * The direction the blur should be applied
         */
        direction: Vector2;
        /**
         * Gets a string identifying the name of the class
         * @returns "DepthOfFieldBlurPostProcess" string
         */
        getClassName(): string;
        /**
         * Creates a new instance CircleOfConfusionPostProcess
         * @param name The name of the effect.
         * @param scene The scene the effect belongs to.
         * @param direction The direction the blur should be applied.
         * @param kernel The size of the kernel used to blur.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param circleOfConfusion The circle of confusion + depth map to be used to avoid blurring accross edges
         * @param imageToBlur The image to apply the blur to (default: Current rendered frame)
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, scene: Scene, direction: Vector2, kernel: number, options: number | PostProcessOptions, camera: Nullable<Camera>, circleOfConfusion: PostProcess, imageToBlur?: Nullable<PostProcess>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
    }
}
declare module BABYLON {
    /** @hidden */
    export var depthOfFieldMergePixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Options to be set when merging outputs from the default pipeline.
     */
    export class DepthOfFieldMergePostProcessOptions {
        /**
         * The original image to merge on top of
         */
        originalFromInput: PostProcess;
        /**
         * Parameters to perform the merge of the depth of field effect
         */
        depthOfField?: {
            circleOfConfusion: PostProcess;
            blurSteps: Array<PostProcess>;
        };
        /**
         * Parameters to perform the merge of bloom effect
         */
        bloom?: {
            blurred: PostProcess;
            weight: number;
        };
    }
    /**
     * The DepthOfFieldMergePostProcess merges blurred images with the original based on the values of the circle of confusion.
     */
    export class DepthOfFieldMergePostProcess extends PostProcess {
        private blurSteps;
        /**
         * Gets a string identifying the name of the class
         * @returns "DepthOfFieldMergePostProcess" string
         */
        getClassName(): string;
        /**
         * Creates a new instance of DepthOfFieldMergePostProcess
         * @param name The name of the effect.
         * @param originalFromInput Post process which's input will be used for the merge.
         * @param circleOfConfusion Circle of confusion post process which's output will be used to blur each pixel.
         * @param blurSteps Blur post processes from low to high which will be mixed with the original image.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, originalFromInput: PostProcess, circleOfConfusion: PostProcess, blurSteps: Array<PostProcess>, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
        /**
         * Updates the effect with the current post process compile time values and recompiles the shader.
         * @param defines Define statements that should be added at the beginning of the shader. (default: null)
         * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)
         * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)
         * @param indexParameters The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx
         * @param onCompiled Called when the shader has been compiled.
         * @param onError Called if there is an error when compiling a shader.
         */
        updateEffect(defines?: Nullable<string>, uniforms?: Nullable<string[]>, samplers?: Nullable<string[]>, indexParameters?: any, onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void): void;
    }
}
declare module BABYLON {
    /**
     * Specifies the level of max blur that should be applied when using the depth of field effect
     */
    export enum DepthOfFieldEffectBlurLevel {
        /**
         * Subtle blur
         */
        Low = 0,
        /**
         * Medium blur
         */
        Medium = 1,
        /**
         * Large blur
         */
        High = 2
    }
    /**
     * The depth of field effect applies a blur to objects that are closer or further from where the camera is focusing.
     */
    export class DepthOfFieldEffect extends PostProcessRenderEffect {
        private _circleOfConfusion;
        /**
         * @hidden Internal, blurs from high to low
         */
        _depthOfFieldBlurX: Array<DepthOfFieldBlurPostProcess>;
        private _depthOfFieldBlurY;
        private _dofMerge;
        /**
         * @hidden Internal post processes in depth of field effect
         */
        _effects: Array<PostProcess>;
        /**
         * The focal the length of the camera used in the effect in scene units/1000 (eg. millimeter)
         */
        set focalLength(value: number);
        get focalLength(): number;
        /**
         * F-Stop of the effect's camera. The diameter of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)
         */
        set fStop(value: number);
        get fStop(): number;
        /**
         * Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)
         */
        set focusDistance(value: number);
        get focusDistance(): number;
        /**
         * Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diamater of the resulting aperture can be computed by lensSize/fStop.
         */
        set lensSize(value: number);
        get lensSize(): number;
        /**
         * Creates a new instance DepthOfFieldEffect
         * @param scene The scene the effect belongs to.
         * @param depthTexture The depth texture of the scene to compute the circle of confusion.This must be set in order for this to function but may be set after initialization if needed.
         * @param pipelineTextureType The type of texture to be used when performing the post processing.
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(scene: Scene, depthTexture: Nullable<RenderTargetTexture>, blurLevel?: DepthOfFieldEffectBlurLevel, pipelineTextureType?: number, blockCompilation?: boolean);
        /**
        * Get the current class name of the current effet
        * @returns "DepthOfFieldEffect"
        */
        getClassName(): string;
        /**
         * Depth texture to be used to compute the circle of confusion. This must be set here or in the constructor in order for the post process to function.
         */
        set depthTexture(value: RenderTargetTexture);
        /**
         * Disposes each of the internal effects for a given camera.
         * @param camera The camera to dispose the effect on.
         */
        disposeEffects(camera: Camera): void;
        /**
         * @hidden Internal
         */
        _updateEffects(): void;
        /**
         * Internal
         * @returns if all the contained post processes are ready.
         * @hidden
         */
        _isReady(): boolean;
    }
}
declare module BABYLON {
    /** @hidden */
    export var displayPassPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * DisplayPassPostProcess which produces an output the same as it's input
     */
    export class DisplayPassPostProcess extends PostProcess {
        /**
         * Gets a string identifying the name of the class
         * @returns "DisplayPassPostProcess" string
         */
        getClassName(): string;
        /**
         * Creates the DisplayPassPostProcess
         * @param name The name of the effect.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         */
        constructor(name: string, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean);
        /** @hidden */
        static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<DisplayPassPostProcess>;
    }
}
declare module BABYLON {
    /** @hidden */
    export var filterPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Applies a kernel filter to the image
     */
    export class FilterPostProcess extends PostProcess {
        /** The matrix to be applied to the image */
        kernelMatrix: Matrix;
        /**
         * Gets a string identifying the name of the class
         * @returns "FilterPostProcess" string
         */
        getClassName(): string;
        /**
         *
         * @param name The name of the effect.
         * @param kernelMatrix The matrix to be applied to the image
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         */
        constructor(name: string, kernelMatrix: Matrix, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean);
        /** @hidden */
        static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<FilterPostProcess>;
    }
}
declare module BABYLON {
    /** @hidden */
    export var fxaaPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var fxaaVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Fxaa post process
     * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#fxaa
     */
    export class FxaaPostProcess extends PostProcess {
        /**
         * Gets a string identifying the name of the class
         * @returns "FxaaPostProcess" string
         */
        getClassName(): string;
        constructor(name: string, options: number | PostProcessOptions, camera?: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number);
        private _getDefines;
        /** @hidden */
        static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): FxaaPostProcess;
    }
}
declare module BABYLON {
    /** @hidden */
    export var grainPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * The GrainPostProcess adds noise to the image at mid luminance levels
     */
    export class GrainPostProcess extends PostProcess {
        /**
         * The intensity of the grain added (default: 30)
         */
        intensity: number;
        /**
         * If the grain should be randomized on every frame
         */
        animated: boolean;
        /**
         * Gets a string identifying the name of the class
         * @returns "GrainPostProcess" string
         */
        getClassName(): string;
        /**
         * Creates a new instance of @see GrainPostProcess
         * @param name The name of the effect.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
        /** @hidden */
        static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): GrainPostProcess;
    }
}
declare module BABYLON {
    /** @hidden */
    export var highlightsPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Extracts highlights from the image
     * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses
     */
    export class HighlightsPostProcess extends PostProcess {
        /**
         * Gets a string identifying the name of the class
         * @returns "HighlightsPostProcess" string
         */
        getClassName(): string;
        /**
         * Extracts highlights from the image
         * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses
         * @param name The name of the effect.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of texture for the post process (default: Engine.TEXTURETYPE_UNSIGNED_INT)
         */
        constructor(name: string, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number);
    }
}
declare module BABYLON {
    /** @hidden */
    export var mrtFragmentDeclaration: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var geometryPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var geometryVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    interface ISavedTransformationMatrix {
        world: Matrix;
        viewProjection: Matrix;
    }
    /**
     * This renderer is helpfull to fill one of the render target with a geometry buffer.
     */
    export class GeometryBufferRenderer {
        /**
         * Constant used to retrieve the position texture index in the G-Buffer textures array
         * using getIndex(GeometryBufferRenderer.POSITION_TEXTURE_INDEX)
         */
        static readonly POSITION_TEXTURE_TYPE: number;
        /**
         * Constant used to retrieve the velocity texture index in the G-Buffer textures array
         * using getIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_INDEX)
         */
        static readonly VELOCITY_TEXTURE_TYPE: number;
        /**
         * Constant used to retrieve the reflectivity texture index in the G-Buffer textures array
         * using the getIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE)
         */
        static readonly REFLECTIVITY_TEXTURE_TYPE: number;
        /**
         * Dictionary used to store the previous transformation matrices of each rendered mesh
         * in order to compute objects velocities when enableVelocity is set to "true"
         * @hidden
         */
        _previousTransformationMatrices: {
            [index: number]: ISavedTransformationMatrix;
        };
        /**
         * Dictionary used to store the previous bones transformation matrices of each rendered mesh
         * in order to compute objects velocities when enableVelocity is set to "true"
         * @hidden
         */
        _previousBonesTransformationMatrices: {
            [index: number]: Float32Array;
        };
        /**
         * Array used to store the ignored skinned meshes while computing velocity map (typically used by the motion blur post-process).
         * Avoids computing bones velocities and computes only mesh's velocity itself (position, rotation, scaling).
         */
        excludedSkinnedMeshesFromVelocity: AbstractMesh[];
        /** Gets or sets a boolean indicating if transparent meshes should be rendered */
        renderTransparentMeshes: boolean;
        private _scene;
        private _resizeObserver;
        private _multiRenderTarget;
        private _ratio;
        private _enablePosition;
        private _enableVelocity;
        private _enableReflectivity;
        private _positionIndex;
        private _velocityIndex;
        private _reflectivityIndex;
        protected _effect: Effect;
        protected _cachedDefines: string;
        /**
         * Set the render list (meshes to be rendered) used in the G buffer.
         */
        set renderList(meshes: Mesh[]);
        /**
         * Gets wether or not G buffer are supported by the running hardware.
         * This requires draw buffer supports
         */
        get isSupported(): boolean;
        /**
         * Returns the index of the given texture type in the G-Buffer textures array
         * @param textureType The texture type constant. For example GeometryBufferRenderer.POSITION_TEXTURE_INDEX
         * @returns the index of the given texture type in the G-Buffer textures array
         */
        getTextureIndex(textureType: number): number;
        /**
         * Gets a boolean indicating if objects positions are enabled for the G buffer.
         */
        get enablePosition(): boolean;
        /**
         * Sets whether or not objects positions are enabled for the G buffer.
         */
        set enablePosition(enable: boolean);
        /**
         * Gets a boolean indicating if objects velocities are enabled for the G buffer.
         */
        get enableVelocity(): boolean;
        /**
         * Sets wether or not objects velocities are enabled for the G buffer.
         */
        set enableVelocity(enable: boolean);
        /**
         * Gets a boolean indicating if objects roughness are enabled in the G buffer.
         */
        get enableReflectivity(): boolean;
        /**
         * Sets wether or not objects roughness are enabled for the G buffer.
         */
        set enableReflectivity(enable: boolean);
        /**
         * Gets the scene associated with the buffer.
         */
        get scene(): Scene;
        /**
         * Gets the ratio used by the buffer during its creation.
         * How big is the buffer related to the main canvas.
         */
        get ratio(): number;
        /** @hidden */
        static _SceneComponentInitialization: (scene: Scene) => void;
        /**
         * Creates a new G Buffer for the scene
         * @param scene The scene the buffer belongs to
         * @param ratio How big is the buffer related to the main canvas.
         */
        constructor(scene: Scene, ratio?: number);
        /**
         * Checks wether everything is ready to render a submesh to the G buffer.
         * @param subMesh the submesh to check readiness for
         * @param useInstances is the mesh drawn using instance or not
         * @returns true if ready otherwise false
         */
        isReady(subMesh: SubMesh, useInstances: boolean): boolean;
        /**
         * Gets the current underlying G Buffer.
         * @returns the buffer
         */
        getGBuffer(): MultiRenderTarget;
        /**
         * Gets the number of samples used to render the buffer (anti aliasing).
         */
        get samples(): number;
        /**
         * Sets the number of samples used to render the buffer (anti aliasing).
         */
        set samples(value: number);
        /**
         * Disposes the renderer and frees up associated resources.
         */
        dispose(): void;
        protected _createRenderTargets(): void;
        private _copyBonesTransformationMatrices;
    }
}
declare module BABYLON {
        interface Scene {
            /** @hidden (Backing field) */
            _geometryBufferRenderer: Nullable<GeometryBufferRenderer>;
            /**
             * Gets or Sets the current geometry buffer associated to the scene.
             */
            geometryBufferRenderer: Nullable<GeometryBufferRenderer>;
            /**
             * Enables a GeometryBufferRender and associates it with the scene
             * @param ratio defines the scaling ratio to apply to the renderer (1 by default which means same resolution)
             * @returns the GeometryBufferRenderer
             */
            enableGeometryBufferRenderer(ratio?: number): Nullable<GeometryBufferRenderer>;
            /**
             * Disables the GeometryBufferRender associated with the scene
             */
            disableGeometryBufferRenderer(): void;
        }
    /**
     * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful
     * in several rendering techniques.
     */
    export class GeometryBufferRendererSceneComponent implements ISceneComponent {
        /**
         * The component name helpful to identify the component in the list of scene components.
         */
        readonly name: string;
        /**
         * The scene the component belongs to.
         */
        scene: Scene;
        /**
         * Creates a new instance of the component for the given scene
         * @param scene Defines the scene to register the component in
         */
        constructor(scene: Scene);
        /**
         * Registers the component in a given scene
         */
        register(): void;
        /**
         * Rebuilds the elements related to this component in case of
         * context lost for instance.
         */
        rebuild(): void;
        /**
         * Disposes the component and the associated ressources
         */
        dispose(): void;
        private _gatherRenderTargets;
    }
}
declare module BABYLON {
    /** @hidden */
    export var motionBlurPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * The Motion Blur Post Process which blurs an image based on the objects velocity in scene.
     * Velocity can be affected by each object's rotation, position and scale depending on the transformation speed.
     * As an example, all you have to do is to create the post-process:
     *  var mb = new BABYLON.MotionBlurPostProcess(
     *      'mb', // The name of the effect.
     *      scene, // The scene containing the objects to blur according to their velocity.
     *      1.0, // The required width/height ratio to downsize to before computing the render pass.
     *      camera // The camera to apply the render pass to.
     * );
     * Then, all objects moving, rotating and/or scaling will be blurred depending on the transformation speed.
     */
    export class MotionBlurPostProcess extends PostProcess {
        /**
         * Defines how much the image is blurred by the movement. Default value is equal to 1
         */
        motionStrength: number;
        /**
         * Gets the number of iterations are used for motion blur quality. Default value is equal to 32
         */
        get motionBlurSamples(): number;
        /**
         * Sets the number of iterations to be used for motion blur quality
         */
        set motionBlurSamples(samples: number);
        private _motionBlurSamples;
        private _geometryBufferRenderer;
        /**
         * Gets a string identifying the name of the class
         * @returns "MotionBlurPostProcess" string
         */
        getClassName(): string;
        /**
         * Creates a new instance MotionBlurPostProcess
         * @param name The name of the effect.
         * @param scene The scene containing the objects to blur according to their velocity.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, scene: Scene, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
        /**
         * Excludes the given skinned mesh from computing bones velocities.
         * Computing bones velocities can have a cost and that cost. The cost can be saved by calling this function and by passing the skinned mesh reference to ignore.
         * @param skinnedMesh The mesh containing the skeleton to ignore when computing the velocity map.
         */
        excludeSkinnedMesh(skinnedMesh: AbstractMesh): void;
        /**
         * Removes the given skinned mesh from the excluded meshes to integrate bones velocities while rendering the velocity map.
         * @param skinnedMesh The mesh containing the skeleton that has been ignored previously.
         * @see excludeSkinnedMesh to exclude a skinned mesh from bones velocity computation.
         */
        removeExcludedSkinnedMesh(skinnedMesh: AbstractMesh): void;
        /**
         * Disposes the post process.
         * @param camera The camera to dispose the post process on.
         */
        dispose(camera?: Camera): void;
        /** @hidden */
        static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<MotionBlurPostProcess>;
    }
}
declare module BABYLON {
    /** @hidden */
    export var refractionPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Post process which applies a refractin texture
     * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#refraction
     */
    export class RefractionPostProcess extends PostProcess {
        private _refTexture;
        private _ownRefractionTexture;
        /** the base color of the refraction (used to taint the rendering) */
        color: Color3;
        /** simulated refraction depth */
        depth: number;
        /** the coefficient of the base color (0 to remove base color tainting) */
        colorLevel: number;
        /** Gets the url used to load the refraction texture */
        refractionTextureUrl: string;
        /**
         * Gets or sets the refraction texture
         * Please note that you are responsible for disposing the texture if you set it manually
         */
        get refractionTexture(): Texture;
        set refractionTexture(value: Texture);
        /**
         * Gets a string identifying the name of the class
         * @returns "RefractionPostProcess" string
         */
        getClassName(): string;
        /**
         * Initializes the RefractionPostProcess
         * @see https://doc.babylonjs.com/how_to/how_to_use_postprocesses#refraction
         * @param name The name of the effect.
         * @param refractionTextureUrl Url of the refraction texture to use
         * @param color the base color of the refraction (used to taint the rendering)
         * @param depth simulated refraction depth
         * @param colorLevel the coefficient of the base color (0 to remove base color tainting)
         * @param camera The camera to apply the render pass to.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         */
        constructor(name: string, refractionTextureUrl: string, color: Color3, depth: number, colorLevel: number, options: number | PostProcessOptions, camera: Camera, samplingMode?: number, engine?: Engine, reusable?: boolean);
        /**
         * Disposes of the post process
         * @param camera Camera to dispose post process on
         */
        dispose(camera: Camera): void;
        /** @hidden */
        static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): RefractionPostProcess;
    }
}
declare module BABYLON {
    /** @hidden */
    export var sharpenPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * The SharpenPostProcess applies a sharpen kernel to every pixel
     * See http://en.wikipedia.org/wiki/Kernel_(image_processing)
     */
    export class SharpenPostProcess extends PostProcess {
        /**
         * How much of the original color should be applied. Setting this to 0 will display edge detection. (default: 1)
         */
        colorAmount: number;
        /**
         * How much sharpness should be applied (default: 0.3)
         */
        edgeAmount: number;
        /**
         * Gets a string identifying the name of the class
         * @returns "SharpenPostProcess" string
         */
        getClassName(): string;
        /**
         * Creates a new instance ConvolutionPostProcess
         * @param name The name of the effect.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
        /** @hidden */
        static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): SharpenPostProcess;
    }
}
declare module BABYLON {
    /**
     * PostProcessRenderPipeline
     * @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline
     */
    export class PostProcessRenderPipeline {
        private engine;
        private _renderEffects;
        private _renderEffectsForIsolatedPass;
        /**
         * List of inspectable custom properties (used by the Inspector)
         * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility
         */
        inspectableCustomProperties: IInspectable[];
        /**
         * @hidden
         */
        protected _cameras: Camera[];
        /** @hidden */
        _name: string;
        /**
         * Gets pipeline name
         */
        get name(): string;
        /** Gets the list of attached cameras */
        get cameras(): Camera[];
        /**
         * Initializes a PostProcessRenderPipeline
         * @param engine engine to add the pipeline to
         * @param name name of the pipeline
         */
        constructor(engine: Engine, name: string);
        /**
         * Gets the class name
         * @returns "PostProcessRenderPipeline"
         */
        getClassName(): string;
        /**
         * If all the render effects in the pipeline are supported
         */
        get isSupported(): boolean;
        /**
         * Adds an effect to the pipeline
         * @param renderEffect the effect to add
         */
        addEffect(renderEffect: PostProcessRenderEffect): void;
        /** @hidden */
        _rebuild(): void;
        /** @hidden */
        _enableEffect(renderEffectName: string, cameras: Camera): void;
        /** @hidden */
        _enableEffect(renderEffectName: string, cameras: Camera[]): void;
        /** @hidden */
        _disableEffect(renderEffectName: string, cameras: Nullable<Camera[]>): void;
        /** @hidden */
        _disableEffect(renderEffectName: string, cameras: Nullable<Camera[]>): void;
        /** @hidden */
        _attachCameras(cameras: Camera, unique: boolean): void;
        /** @hidden */
        _attachCameras(cameras: Camera[], unique: boolean): void;
        /** @hidden */
        _detachCameras(cameras: Camera): void;
        /** @hidden */
        _detachCameras(cameras: Nullable<Camera[]>): void;
        /** @hidden */
        _update(): void;
        /** @hidden */
        _reset(): void;
        protected _enableMSAAOnFirstPostProcess(sampleCount: number): boolean;
        /**
         * Sets the required values to the prepass renderer.
         * @param prePassRenderer defines the prepass renderer to setup.
         * @returns true if the pre pass is needed.
         */
        setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean;
        /**
         * Disposes of the pipeline
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * PostProcessRenderPipelineManager class
     * @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline
     */
    export class PostProcessRenderPipelineManager {
        private _renderPipelines;
        /**
         * Initializes a PostProcessRenderPipelineManager
         * @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline
         */
        constructor();
        /**
         * Gets the list of supported render pipelines
         */
        get supportedPipelines(): PostProcessRenderPipeline[];
        /**
         * Adds a pipeline to the manager
         * @param renderPipeline The pipeline to add
         */
        addPipeline(renderPipeline: PostProcessRenderPipeline): void;
        /**
         * Attaches a camera to the pipeline
         * @param renderPipelineName The name of the pipeline to attach to
         * @param cameras the camera to attach
         * @param unique if the camera can be attached multiple times to the pipeline
         */
        attachCamerasToRenderPipeline(renderPipelineName: string, cameras: any | Camera[] | Camera, unique?: boolean): void;
        /**
         * Detaches a camera from the pipeline
         * @param renderPipelineName The name of the pipeline to detach from
         * @param cameras the camera to detach
         */
        detachCamerasFromRenderPipeline(renderPipelineName: string, cameras: any | Camera[] | Camera): void;
        /**
         * Enables an effect by name on a pipeline
         * @param renderPipelineName the name of the pipeline to enable the effect in
         * @param renderEffectName the name of the effect to enable
         * @param cameras the cameras that the effect should be enabled on
         */
        enableEffectInPipeline(renderPipelineName: string, renderEffectName: string, cameras: any | Camera[] | Camera): void;
        /**
         * Disables an effect by name on a pipeline
         * @param renderPipelineName the name of the pipeline to disable the effect in
         * @param renderEffectName the name of the effect to disable
         * @param cameras the cameras that the effect should be disabled on
         */
        disableEffectInPipeline(renderPipelineName: string, renderEffectName: string, cameras: any | Camera[] | Camera): void;
        /**
         * Updates the state of all contained render pipelines and disposes of any non supported pipelines
         */
        update(): void;
        /** @hidden */
        _rebuild(): void;
        /**
         * Disposes of the manager and pipelines
         */
        dispose(): void;
    }
}
declare module BABYLON {
        interface Scene {
            /** @hidden (Backing field) */
            _postProcessRenderPipelineManager: PostProcessRenderPipelineManager;
            /**
             * Gets the postprocess render pipeline manager
             * @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline
             * @see https://doc.babylonjs.com/how_to/using_default_rendering_pipeline
             */
            readonly postProcessRenderPipelineManager: PostProcessRenderPipelineManager;
        }
    /**
     * Defines the Render Pipeline scene component responsible to rendering pipelines
     */
    export class PostProcessRenderPipelineManagerSceneComponent implements ISceneComponent {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        readonly name: string;
        /**
         * The scene the component belongs to.
         */
        scene: Scene;
        /**
         * Creates a new instance of the component for the given scene
         * @param scene Defines the scene to register the component in
         */
        constructor(scene: Scene);
        /**
         * Registers the component in a given scene
         */
        register(): void;
        /**
         * Rebuilds the elements related to this component in case of
         * context lost for instance.
         */
        rebuild(): void;
        /**
         * Disposes the component and the associated ressources
         */
        dispose(): void;
        private _gatherRenderTargets;
    }
}
declare module BABYLON {
    /**
     * The default rendering pipeline can be added to a scene to apply common post processing effects such as anti-aliasing or depth of field.
     * See https://doc.babylonjs.com/how_to/using_default_rendering_pipeline
     */
    export class DefaultRenderingPipeline extends PostProcessRenderPipeline implements IDisposable, IAnimatable {
        private _scene;
        private _camerasToBeAttached;
        /**
         * ID of the sharpen post process,
         */
        private readonly SharpenPostProcessId;
        /**
         * @ignore
         * ID of the image processing post process;
         */
        readonly ImageProcessingPostProcessId: string;
        /**
         * @ignore
         * ID of the Fast Approximate Anti-Aliasing post process;
         */
        readonly FxaaPostProcessId: string;
        /**
         * ID of the chromatic aberration post process,
         */
        private readonly ChromaticAberrationPostProcessId;
        /**
         * ID of the grain post process
         */
        private readonly GrainPostProcessId;
        /**
         * Sharpen post process which will apply a sharpen convolution to enhance edges
         */
        sharpen: SharpenPostProcess;
        private _sharpenEffect;
        private bloom;
        /**
         * Depth of field effect, applies a blur based on how far away objects are from the focus distance.
         */
        depthOfField: DepthOfFieldEffect;
        /**
         * The Fast Approximate Anti-Aliasing post process which attemps to remove aliasing from an image.
         */
        fxaa: FxaaPostProcess;
        /**
         * Image post processing pass used to perform operations such as tone mapping or color grading.
         */
        imageProcessing: ImageProcessingPostProcess;
        /**
         * Chromatic aberration post process which will shift rgb colors in the image
         */
        chromaticAberration: ChromaticAberrationPostProcess;
        private _chromaticAberrationEffect;
        /**
         * Grain post process which add noise to the image
         */
        grain: GrainPostProcess;
        private _grainEffect;
        /**
         * Glow post process which adds a glow to emissive areas of the image
         */
        private _glowLayer;
        /**
         * Animations which can be used to tweak settings over a period of time
         */
        animations: Animation[];
        private _imageProcessingConfigurationObserver;
        private _sharpenEnabled;
        private _bloomEnabled;
        private _depthOfFieldEnabled;
        private _depthOfFieldBlurLevel;
        private _fxaaEnabled;
        private _imageProcessingEnabled;
        private _defaultPipelineTextureType;
        private _bloomScale;
        private _chromaticAberrationEnabled;
        private _grainEnabled;
        private _buildAllowed;
        /**
         * Gets active scene
         */
        get scene(): Scene;
        /**
         * Enable or disable the sharpen process from the pipeline
         */
        set sharpenEnabled(enabled: boolean);
        get sharpenEnabled(): boolean;
        private _resizeObserver;
        private _hardwareScaleLevel;
        private _bloomKernel;
        /**
         * Specifies the size of the bloom blur kernel, relative to the final output size
         */
        get bloomKernel(): number;
        set bloomKernel(value: number);
        /**
         * Specifies the weight of the bloom in the final rendering
         */
        private _bloomWeight;
        /**
         * Specifies the luma threshold for the area that will be blurred by the bloom
         */
        private _bloomThreshold;
        private _hdr;
        /**
         * The strength of the bloom.
         */
        set bloomWeight(value: number);
        get bloomWeight(): number;
        /**
         * The strength of the bloom.
         */
        set bloomThreshold(value: number);
        get bloomThreshold(): number;
        /**
         * The scale of the bloom, lower value will provide better performance.
         */
        set bloomScale(value: number);
        get bloomScale(): number;
        /**
         * Enable or disable the bloom from the pipeline
         */
        set bloomEnabled(enabled: boolean);
        get bloomEnabled(): boolean;
        private _rebuildBloom;
        /**
         * If the depth of field is enabled.
         */
        get depthOfFieldEnabled(): boolean;
        set depthOfFieldEnabled(enabled: boolean);
        /**
         * Blur level of the depth of field effect. (Higher blur will effect performance)
         */
        get depthOfFieldBlurLevel(): DepthOfFieldEffectBlurLevel;
        set depthOfFieldBlurLevel(value: DepthOfFieldEffectBlurLevel);
        /**
         * If the anti aliasing is enabled.
         */
        set fxaaEnabled(enabled: boolean);
        get fxaaEnabled(): boolean;
        private _samples;
        /**
         * MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)
         */
        set samples(sampleCount: number);
        get samples(): number;
        /**
         * If image processing is enabled.
         */
        set imageProcessingEnabled(enabled: boolean);
        get imageProcessingEnabled(): boolean;
        /**
         * If glow layer is enabled. (Adds a glow effect to emmissive materials)
         */
        set glowLayerEnabled(enabled: boolean);
        get glowLayerEnabled(): boolean;
        /**
         * Gets the glow layer (or null if not defined)
         */
        get glowLayer(): Nullable<GlowLayer>;
        /**
         * Enable or disable the chromaticAberration process from the pipeline
         */
        set chromaticAberrationEnabled(enabled: boolean);
        get chromaticAberrationEnabled(): boolean;
        /**
         * Enable or disable the grain process from the pipeline
         */
        set grainEnabled(enabled: boolean);
        get grainEnabled(): boolean;
        /**
         * @constructor
         * @param name - The rendering pipeline name (default: "")
         * @param hdr - If high dynamic range textures should be used (default: true)
         * @param scene - The scene linked to this pipeline (default: the last created scene)
         * @param cameras - The array of cameras that the rendering pipeline will be attached to (default: scene.cameras)
         * @param automaticBuild - if false, you will have to manually call prepare() to update the pipeline (default: true)
         */
        constructor(name?: string, hdr?: boolean, scene?: Scene, cameras?: Camera[], automaticBuild?: boolean);
        /**
         * Get the class name
         * @returns "DefaultRenderingPipeline"
         */
        getClassName(): string;
        /**
         * Force the compilation of the entire pipeline.
         */
        prepare(): void;
        private _hasCleared;
        private _prevPostProcess;
        private _prevPrevPostProcess;
        private _setAutoClearAndTextureSharing;
        private _depthOfFieldSceneObserver;
        private _buildPipeline;
        private _disposePostProcesses;
        /**
         * Adds a camera to the pipeline
         * @param camera the camera to be added
         */
        addCamera(camera: Camera): void;
        /**
         * Removes a camera from the pipeline
         * @param camera the camera to remove
         */
        removeCamera(camera: Camera): void;
        /**
         * Dispose of the pipeline and stop all post processes
         */
        dispose(): void;
        /**
         * Serialize the rendering pipeline (Used when exporting)
         * @returns the serialized object
         */
        serialize(): any;
        /**
         * Parse the serialized pipeline
         * @param source Source pipeline.
         * @param scene The scene to load the pipeline to.
         * @param rootUrl The URL of the serialized pipeline.
         * @returns An instantiated pipeline from the serialized object.
         */
        static Parse(source: any, scene: Scene, rootUrl: string): DefaultRenderingPipeline;
    }
}
declare module BABYLON {
    /** @hidden */
    export var lensHighlightsPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var depthOfFieldPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * BABYLON.JS Chromatic Aberration GLSL Shader
     * Author: Olivier Guyot
     * Separates very slightly R, G and B colors on the edges of the screen
     * Inspired by Francois Tarlier & Martins Upitis
     */
    export class LensRenderingPipeline extends PostProcessRenderPipeline {
        /**
         * @ignore
         * The chromatic aberration PostProcess id in the pipeline
         */
        LensChromaticAberrationEffect: string;
        /**
         * @ignore
         * The highlights enhancing PostProcess id in the pipeline
         */
        HighlightsEnhancingEffect: string;
        /**
         * @ignore
        * The depth-of-field PostProcess id in the pipeline
        */
        LensDepthOfFieldEffect: string;
        private _scene;
        private _depthTexture;
        private _grainTexture;
        private _chromaticAberrationPostProcess;
        private _highlightsPostProcess;
        private _depthOfFieldPostProcess;
        private _edgeBlur;
        private _grainAmount;
        private _chromaticAberration;
        private _distortion;
        private _highlightsGain;
        private _highlightsThreshold;
        private _dofDistance;
        private _dofAperture;
        private _dofDarken;
        private _dofPentagon;
        private _blurNoise;
        /**
         * @constructor
         *
         * Effect parameters are as follow:
         * {
         *      chromatic_aberration: number;       // from 0 to x (1 for realism)
         *      edge_blur: number;                  // from 0 to x (1 for realism)
         *      distortion: number;                 // from 0 to x (1 for realism)
         *      grain_amount: number;               // from 0 to 1
         *      grain_texture: BABYLON.Texture;     // texture to use for grain effect; if unset, use random B&W noise
         *      dof_focus_distance: number;         // depth-of-field: focus distance; unset to disable (disabled by default)
         *      dof_aperture: number;               // depth-of-field: focus blur bias (default: 1)
         *      dof_darken: number;                 // depth-of-field: darken that which is out of focus (from 0 to 1, disabled by default)
         *      dof_pentagon: boolean;              // depth-of-field: makes a pentagon-like "bokeh" effect
         *      dof_gain: number;                   // depth-of-field: highlights gain; unset to disable (disabled by default)
         *      dof_threshold: number;              // depth-of-field: highlights threshold (default: 1)
         *      blur_noise: boolean;                // add a little bit of noise to the blur (default: true)
         * }
         * Note: if an effect parameter is unset, effect is disabled
         *
         * @param name The rendering pipeline name
         * @param parameters - An object containing all parameters (see above)
         * @param scene The scene linked to this pipeline
         * @param ratio The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)
         * @param cameras The array of cameras that the rendering pipeline will be attached to
         */
        constructor(name: string, parameters: any, scene: Scene, ratio?: number, cameras?: Camera[]);
        /**
         * Get the class name
         * @returns "LensRenderingPipeline"
         */
        getClassName(): string;
        /**
         * Gets associated scene
         */
        get scene(): Scene;
        /**
         * Gets or sets the edge blur
         */
        get edgeBlur(): number;
        set edgeBlur(value: number);
        /**
         * Gets or sets the grain amount
         */
        get grainAmount(): number;
        set grainAmount(value: number);
        /**
         * Gets or sets the chromatic aberration amount
         */
        get chromaticAberration(): number;
        set chromaticAberration(value: number);
        /**
         * Gets or sets the depth of field aperture
         */
        get dofAperture(): number;
        set dofAperture(value: number);
        /**
         * Gets or sets the edge distortion
         */
        get edgeDistortion(): number;
        set edgeDistortion(value: number);
        /**
         * Gets or sets the depth of field distortion
         */
        get dofDistortion(): number;
        set dofDistortion(value: number);
        /**
         * Gets or sets the darken out of focus amount
         */
        get darkenOutOfFocus(): number;
        set darkenOutOfFocus(value: number);
        /**
         * Gets or sets a boolean indicating if blur noise is enabled
         */
        get blurNoise(): boolean;
        set blurNoise(value: boolean);
        /**
         * Gets or sets a boolean indicating if pentagon bokeh is enabled
         */
        get pentagonBokeh(): boolean;
        set pentagonBokeh(value: boolean);
        /**
         * Gets or sets the highlight grain amount
         */
        get highlightsGain(): number;
        set highlightsGain(value: number);
        /**
         * Gets or sets the highlight threshold
         */
        get highlightsThreshold(): number;
        set highlightsThreshold(value: number);
        /**
         * Sets the amount of blur at the edges
         * @param amount blur amount
         */
        setEdgeBlur(amount: number): void;
        /**
         * Sets edge blur to 0
         */
        disableEdgeBlur(): void;
        /**
         * Sets the amout of grain
         * @param amount Amount of grain
         */
        setGrainAmount(amount: number): void;
        /**
         * Set grain amount to 0
         */
        disableGrain(): void;
        /**
         * Sets the chromatic aberration amount
         * @param amount amount of chromatic aberration
         */
        setChromaticAberration(amount: number): void;
        /**
         * Sets chromatic aberration amount to 0
         */
        disableChromaticAberration(): void;
        /**
         * Sets the EdgeDistortion amount
         * @param amount amount of EdgeDistortion
         */
        setEdgeDistortion(amount: number): void;
        /**
         * Sets edge distortion to 0
         */
        disableEdgeDistortion(): void;
        /**
         * Sets the FocusDistance amount
         * @param amount amount of FocusDistance
         */
        setFocusDistance(amount: number): void;
        /**
        * Disables depth of field
        */
        disableDepthOfField(): void;
        /**
         * Sets the Aperture amount
         * @param amount amount of Aperture
         */
        setAperture(amount: number): void;
        /**
         * Sets the DarkenOutOfFocus amount
         * @param amount amount of DarkenOutOfFocus
         */
        setDarkenOutOfFocus(amount: number): void;
        private _pentagonBokehIsEnabled;
        /**
         * Creates a pentagon bokeh effect
         */
        enablePentagonBokeh(): void;
        /**
         * Disables the pentagon bokeh effect
         */
        disablePentagonBokeh(): void;
        /**
         * Enables noise blur
         */
        enableNoiseBlur(): void;
        /**
         * Disables noise blur
         */
        disableNoiseBlur(): void;
        /**
         * Sets the HighlightsGain amount
         * @param amount amount of HighlightsGain
         */
        setHighlightsGain(amount: number): void;
        /**
         * Sets the HighlightsThreshold amount
         * @param amount amount of HighlightsThreshold
         */
        setHighlightsThreshold(amount: number): void;
        /**
         * Disables highlights
         */
        disableHighlights(): void;
        /**
         * Removes the internal pipeline assets and detaches the pipeline from the scene cameras
         * @param disableDepthRender If the scens depth rendering should be disabled (default: false)
         */
        dispose(disableDepthRender?: boolean): void;
        private _createChromaticAberrationPostProcess;
        private _createHighlightsPostProcess;
        private _createDepthOfFieldPostProcess;
        private _createGrainTexture;
    }
}
declare module BABYLON {
    /** @hidden */
    export var ssao2PixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var ssaoCombinePixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Render pipeline to produce ssao effect
     */
    export class SSAO2RenderingPipeline extends PostProcessRenderPipeline {
        /**
         * @ignore
        * The PassPostProcess id in the pipeline that contains the original scene color
        */
        SSAOOriginalSceneColorEffect: string;
        /**
         * @ignore
        * The SSAO PostProcess id in the pipeline
        */
        SSAORenderEffect: string;
        /**
         * @ignore
        * The horizontal blur PostProcess id in the pipeline
        */
        SSAOBlurHRenderEffect: string;
        /**
         * @ignore
        * The vertical blur PostProcess id in the pipeline
        */
        SSAOBlurVRenderEffect: string;
        /**
         * @ignore
        * The PostProcess id in the pipeline that combines the SSAO-Blur output with the original scene color (SSAOOriginalSceneColorEffect)
        */
        SSAOCombineRenderEffect: string;
        /**
        * The output strength of the SSAO post-process. Default value is 1.0.
        */
        totalStrength: number;
        /**
        * Maximum depth value to still render AO. A smooth falloff makes the dimming more natural, so there will be no abrupt shading change.
        */
        maxZ: number;
        /**
        * In order to save performances, SSAO radius is clamped on close geometry. This ratio changes by how much
        */
        minZAspect: number;
        private _samples;
        /**
        * Number of samples used for the SSAO calculations. Default value is 8
        */
        set samples(n: number);
        get samples(): number;
        private _textureSamples;
        /**
        * Number of samples to use for antialiasing
        */
        set textureSamples(n: number);
        get textureSamples(): number;
        /**
         * Force rendering the geometry through geometry buffer
         */
        private _forceGeometryBuffer;
        /**
         * Ratio object used for SSAO ratio and blur ratio
         */
        private _ratio;
        /**
        * Dynamically generated sphere sampler.
        */
        private _sampleSphere;
        /**
        * Blur filter offsets
        */
        private _samplerOffsets;
        private _expensiveBlur;
        /**
        * If bilateral blur should be used
        */
        set expensiveBlur(b: boolean);
        get expensiveBlur(): boolean;
        /**
        * The radius around the analyzed pixel used by the SSAO post-process. Default value is 2.0
        */
        radius: number;
        /**
        * The base color of the SSAO post-process
        * The final result is "base + ssao" between [0, 1]
        */
        base: number;
        /**
        *  Support test.
        */
        static get IsSupported(): boolean;
        private _scene;
        private _randomTexture;
        private _originalColorPostProcess;
        private _ssaoPostProcess;
        private _blurHPostProcess;
        private _blurVPostProcess;
        private _ssaoCombinePostProcess;
        private _prePassRenderer;
        /**
         * Gets active scene
         */
        get scene(): Scene;
        /**
         * @constructor
         * @param name The rendering pipeline name
         * @param scene The scene linked to this pipeline
         * @param ratio The size of the postprocesses. Can be a number shared between passes or an object for more precision: { ssaoRatio: 0.5, blurRatio: 1.0 }
         * @param cameras The array of cameras that the rendering pipeline will be attached to
         * @param forceGeometryBuffer Set to true if you want to use the legacy geometry buffer renderer
         */
        constructor(name: string, scene: Scene, ratio: any, cameras?: Camera[], forceGeometryBuffer?: boolean);
        /**
         * Get the class name
         * @returns "SSAO2RenderingPipeline"
         */
        getClassName(): string;
        /**
         * Removes the internal pipeline assets and detatches the pipeline from the scene cameras
         */
        dispose(disableGeometryBufferRenderer?: boolean): void;
        private _createBlurPostProcess;
        /** @hidden */
        _rebuild(): void;
        private _bits;
        private _radicalInverse_VdC;
        private _hammersley;
        private _hemisphereSample_uniform;
        private _generateHemisphere;
        private _getDefinesForSSAO;
        private _createSSAOPostProcess;
        private _createSSAOCombinePostProcess;
        private _createRandomTexture;
        /**
         * Serialize the rendering pipeline (Used when exporting)
         * @returns the serialized object
         */
        serialize(): any;
        /**
         * Parse the serialized pipeline
         * @param source Source pipeline.
         * @param scene The scene to load the pipeline to.
         * @param rootUrl The URL of the serialized pipeline.
         * @returns An instantiated pipeline from the serialized object.
         */
        static Parse(source: any, scene: Scene, rootUrl: string): SSAO2RenderingPipeline;
        /**
         * Sets the required values to the prepass renderer.
         * @param prePassRenderer defines the prepass renderer to setup
         * @returns true if the pre pass is needed.
         */
        setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean;
    }
}
declare module BABYLON {
    /** @hidden */
    export var ssaoPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Render pipeline to produce ssao effect
     */
    export class SSAORenderingPipeline extends PostProcessRenderPipeline {
        /**
         * @ignore
        * The PassPostProcess id in the pipeline that contains the original scene color
        */
        SSAOOriginalSceneColorEffect: string;
        /**
         * @ignore
        * The SSAO PostProcess id in the pipeline
        */
        SSAORenderEffect: string;
        /**
         * @ignore
        * The horizontal blur PostProcess id in the pipeline
        */
        SSAOBlurHRenderEffect: string;
        /**
         * @ignore
        * The vertical blur PostProcess id in the pipeline
        */
        SSAOBlurVRenderEffect: string;
        /**
         * @ignore
        * The PostProcess id in the pipeline that combines the SSAO-Blur output with the original scene color (SSAOOriginalSceneColorEffect)
        */
        SSAOCombineRenderEffect: string;
        /**
        * The output strength of the SSAO post-process. Default value is 1.0.
        */
        totalStrength: number;
        /**
        * The radius around the analyzed pixel used by the SSAO post-process. Default value is 0.0006
        */
        radius: number;
        /**
        * Related to fallOff, used to interpolate SSAO samples (first interpolate function input) based on the occlusion difference of each pixel
        * Must not be equal to fallOff and superior to fallOff.
        * Default value is 0.0075
        */
        area: number;
        /**
        * Related to area, used to interpolate SSAO samples (second interpolate function input) based on the occlusion difference of each pixel
        * Must not be equal to area and inferior to area.
        * Default value is 0.000001
        */
        fallOff: number;
        /**
        * The base color of the SSAO post-process
        * The final result is "base + ssao" between [0, 1]
        */
        base: number;
        private _scene;
        private _depthTexture;
        private _randomTexture;
        private _originalColorPostProcess;
        private _ssaoPostProcess;
        private _blurHPostProcess;
        private _blurVPostProcess;
        private _ssaoCombinePostProcess;
        private _firstUpdate;
        /**
         * Gets active scene
         */
        get scene(): Scene;
        /**
         * @constructor
         * @param name - The rendering pipeline name
         * @param scene - The scene linked to this pipeline
         * @param ratio - The size of the postprocesses. Can be a number shared between passes or an object for more precision: { ssaoRatio: 0.5, combineRatio: 1.0 }
         * @param cameras - The array of cameras that the rendering pipeline will be attached to
         */
        constructor(name: string, scene: Scene, ratio: any, cameras?: Camera[]);
        /**
         * Get the class name
         * @returns "SSAORenderingPipeline"
         */
        getClassName(): string;
        /**
         * Removes the internal pipeline assets and detatches the pipeline from the scene cameras
         */
        dispose(disableDepthRender?: boolean): void;
        private _createBlurPostProcess;
        /** @hidden */
        _rebuild(): void;
        private _createSSAOPostProcess;
        private _createSSAOCombinePostProcess;
        private _createRandomTexture;
    }
}
declare module BABYLON {
    /** @hidden */
    export var screenSpaceReflectionPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * The ScreenSpaceReflectionPostProcess performs realtime reflections using only and only the available informations on the screen (positions and normals).
     * Basically, the screen space reflection post-process will compute reflections according the material's reflectivity.
     */
    export class ScreenSpaceReflectionPostProcess extends PostProcess {
        /**
         * Gets or sets a reflection threshold mainly used to adjust the reflection's height.
         */
        threshold: number;
        /**
         * Gets or sets the current reflection strength. 1.0 is an ideal value but can be increased/decreased for particular results.
         */
        strength: number;
        /**
         * Gets or sets the falloff exponent used while computing fresnel. More the exponent is high, more the reflections will be discrete.
         */
        reflectionSpecularFalloffExponent: number;
        /**
         * Gets or sets the step size used to iterate until the effect finds the color of the reflection's pixel. Typically in interval [0.1, 1.0]
         */
        step: number;
        /**
         * Gets or sets the factor applied when computing roughness. Default value is 0.2.
         */
        roughnessFactor: number;
        private _geometryBufferRenderer;
        private _enableSmoothReflections;
        private _reflectionSamples;
        private _smoothSteps;
        /**
         * Gets a string identifying the name of the class
         * @returns "ScreenSpaceReflectionPostProcess" string
         */
        getClassName(): string;
        /**
         * Creates a new instance of ScreenSpaceReflectionPostProcess.
         * @param name The name of the effect.
         * @param scene The scene containing the objects to calculate reflections.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, scene: Scene, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
        /**
         * Gets wether or not smoothing reflections is enabled.
         * Enabling smoothing will require more GPU power and can generate a drop in FPS.
         */
        get enableSmoothReflections(): boolean;
        /**
         * Sets wether or not smoothing reflections is enabled.
         * Enabling smoothing will require more GPU power and can generate a drop in FPS.
         */
        set enableSmoothReflections(enabled: boolean);
        /**
         * Gets the number of samples taken while computing reflections. More samples count is high,
         * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].
         */
        get reflectionSamples(): number;
        /**
         * Sets the number of samples taken while computing reflections. More samples count is high,
         * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].
         */
        set reflectionSamples(samples: number);
        /**
         * Gets the number of samples taken while smoothing reflections. More samples count is high,
         * more the post-process will require GPU power and can generate a drop in FPS.
         * Default value (5.0) work pretty well in all cases but can be adjusted.
         */
        get smoothSteps(): number;
        set smoothSteps(steps: number);
        private _updateEffectDefines;
        /** @hidden */
        static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): ScreenSpaceReflectionPostProcess;
    }
}
declare module BABYLON {
    /** @hidden */
    export var standardPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Standard rendering pipeline
     * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.
     * @see https://doc.babylonjs.com/how_to/using_standard_rendering_pipeline
     */
    export class StandardRenderingPipeline extends PostProcessRenderPipeline implements IDisposable, IAnimatable {
        /**
        * Public members
        */
        /**
         * Post-process which contains the original scene color before the pipeline applies all the effects
         */
        originalPostProcess: Nullable<PostProcess>;
        /**
         * Post-process used to down scale an image x4
         */
        downSampleX4PostProcess: Nullable<PostProcess>;
        /**
         * Post-process used to calculate the illuminated surfaces controlled by a threshold
         */
        brightPassPostProcess: Nullable<PostProcess>;
        /**
         * Post-process array storing all the horizontal blur post-processes used by the pipeline
         */
        blurHPostProcesses: PostProcess[];
        /**
         * Post-process array storing all the vertical blur post-processes used by the pipeline
         */
        blurVPostProcesses: PostProcess[];
        /**
         * Post-process used to add colors of 2 textures (typically brightness + real scene color)
         */
        textureAdderPostProcess: Nullable<PostProcess>;
        /**
         * Post-process used to create volumetric lighting effect
         */
        volumetricLightPostProcess: Nullable<PostProcess>;
        /**
         * Post-process used to smooth the previous volumetric light post-process on the X axis
         */
        volumetricLightSmoothXPostProcess: Nullable<BlurPostProcess>;
        /**
         * Post-process used to smooth the previous volumetric light post-process on the Y axis
         */
        volumetricLightSmoothYPostProcess: Nullable<BlurPostProcess>;
        /**
         * Post-process used to merge the volumetric light effect and the real scene color
         */
        volumetricLightMergePostProces: Nullable<PostProcess>;
        /**
         * Post-process used to store the final volumetric light post-process (attach/detach for debug purpose)
         */
        volumetricLightFinalPostProcess: Nullable<PostProcess>;
        /**
         * Base post-process used to calculate the average luminance of the final image for HDR
         */
        luminancePostProcess: Nullable<PostProcess>;
        /**
         * Post-processes used to create down sample post-processes in order to get
         * the average luminance of the final image for HDR
         * Array of length "StandardRenderingPipeline.LuminanceSteps"
         */
        luminanceDownSamplePostProcesses: PostProcess[];
        /**
         * Post-process used to create a HDR effect (light adaptation)
         */
        hdrPostProcess: Nullable<PostProcess>;
        /**
         * Post-process used to store the final texture adder post-process (attach/detach for debug purpose)
         */
        textureAdderFinalPostProcess: Nullable<PostProcess>;
        /**
         * Post-process used to store the final lens flare post-process (attach/detach for debug purpose)
         */
        lensFlareFinalPostProcess: Nullable<PostProcess>;
        /**
         * Post-process used to merge the final HDR post-process and the real scene color
         */
        hdrFinalPostProcess: Nullable<PostProcess>;
        /**
         * Post-process used to create a lens flare effect
         */
        lensFlarePostProcess: Nullable<PostProcess>;
        /**
         * Post-process that merges the result of the lens flare post-process and the real scene color
         */
        lensFlareComposePostProcess: Nullable<PostProcess>;
        /**
         * Post-process used to create a motion blur effect
         */
        motionBlurPostProcess: Nullable<PostProcess>;
        /**
         * Post-process used to create a depth of field effect
         */
        depthOfFieldPostProcess: Nullable<PostProcess>;
        /**
         * The Fast Approximate Anti-Aliasing post process which attemps to remove aliasing from an image.
         */
        fxaaPostProcess: Nullable<FxaaPostProcess>;
        /**
         * Post-process used to simulate realtime reflections using the screen space and geometry renderer.
         */
        screenSpaceReflectionPostProcess: Nullable<ScreenSpaceReflectionPostProcess>;
        /**
         * Represents the brightness threshold in order to configure the illuminated surfaces
         */
        brightThreshold: number;
        /**
         * Configures the blur intensity used for surexposed surfaces are highlighted surfaces (light halo)
         */
        blurWidth: number;
        /**
         * Sets if the blur for highlighted surfaces must be only horizontal
         */
        horizontalBlur: boolean;
        /**
         * Gets the overall exposure used by the pipeline
         */
        get exposure(): number;
        /**
         * Sets the overall exposure used by the pipeline
         */
        set exposure(value: number);
        /**
         * Texture used typically to simulate "dirty" on camera lens
         */
        lensTexture: Nullable<Texture>;
        /**
         * Represents the offset coefficient based on Rayleigh principle. Typically in interval [-0.2, 0.2]
         */
        volumetricLightCoefficient: number;
        /**
         * The overall power of volumetric lights, typically in interval [0, 10] maximum
         */
        volumetricLightPower: number;
        /**
         * Used the set the blur intensity to smooth the volumetric lights
         */
        volumetricLightBlurScale: number;
        /**
         * Light (spot or directional) used to generate the volumetric lights rays
         * The source light must have a shadow generate so the pipeline can get its
         * depth map
         */
        sourceLight: Nullable<SpotLight | DirectionalLight>;
        /**
         * For eye adaptation, represents the minimum luminance the eye can see
         */
        hdrMinimumLuminance: number;
        /**
         * For eye adaptation, represents the decrease luminance speed
         */
        hdrDecreaseRate: number;
        /**
         * For eye adaptation, represents the increase luminance speed
         */
        hdrIncreaseRate: number;
        /**
         * Gets wether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process
         */
        get hdrAutoExposure(): boolean;
        /**
         * Sets wether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process
         */
        set hdrAutoExposure(value: boolean);
        /**
         * Lens color texture used by the lens flare effect. Mandatory if lens flare effect enabled
         */
        lensColorTexture: Nullable<Texture>;
        /**
         * The overall strengh for the lens flare effect
         */
        lensFlareStrength: number;
        /**
         * Dispersion coefficient for lens flare ghosts
         */
        lensFlareGhostDispersal: number;
        /**
         * Main lens flare halo width
         */
        lensFlareHaloWidth: number;
        /**
         * Based on the lens distortion effect, defines how much the lens flare result
         * is distorted
         */
        lensFlareDistortionStrength: number;
        /**
         * Configures the blur intensity used for for lens flare (halo)
         */
        lensFlareBlurWidth: number;
        /**
         * Lens star texture must be used to simulate rays on the flares and is available
         * in the documentation
         */
        lensStarTexture: Nullable<Texture>;
        /**
         * As the "lensTexture" (can be the same texture or different), it is used to apply the lens
         * flare effect by taking account of the dirt texture
         */
        lensFlareDirtTexture: Nullable<Texture>;
        /**
         * Represents the focal length for the depth of field effect
         */
        depthOfFieldDistance: number;
        /**
         * Represents the blur intensity for the blurred part of the depth of field effect
         */
        depthOfFieldBlurWidth: number;
        /**
         * Gets how much the image is blurred by the movement while using the motion blur post-process
         */
        get motionStrength(): number;
        /**
         * Sets how much the image is blurred by the movement while using the motion blur post-process
         */
        set motionStrength(strength: number);
        /**
         * Gets wether or not the motion blur post-process is object based or screen based.
         */
        get objectBasedMotionBlur(): boolean;
        /**
         * Sets wether or not the motion blur post-process should be object based or screen based
         */
        set objectBasedMotionBlur(value: boolean);
        /**
         * List of animations for the pipeline (IAnimatable implementation)
         */
        animations: Animation[];
        /**
        * Private members
        */
        private _scene;
        private _currentDepthOfFieldSource;
        private _basePostProcess;
        private _fixedExposure;
        private _currentExposure;
        private _hdrAutoExposure;
        private _hdrCurrentLuminance;
        private _motionStrength;
        private _isObjectBasedMotionBlur;
        private _floatTextureType;
        private _camerasToBeAttached;
        private _ratio;
        private _bloomEnabled;
        private _depthOfFieldEnabled;
        private _vlsEnabled;
        private _lensFlareEnabled;
        private _hdrEnabled;
        private _motionBlurEnabled;
        private _fxaaEnabled;
        private _screenSpaceReflectionsEnabled;
        private _motionBlurSamples;
        private _volumetricLightStepsCount;
        private _samples;
        /**
         * @ignore
         * Specifies if the bloom pipeline is enabled
         */
        get BloomEnabled(): boolean;
        set BloomEnabled(enabled: boolean);
        /**
         * @ignore
         * Specifies if the depth of field pipeline is enabed
         */
        get DepthOfFieldEnabled(): boolean;
        set DepthOfFieldEnabled(enabled: boolean);
        /**
         * @ignore
         * Specifies if the lens flare pipeline is enabed
         */
        get LensFlareEnabled(): boolean;
        set LensFlareEnabled(enabled: boolean);
        /**
         * @ignore
         * Specifies if the HDR pipeline is enabled
         */
        get HDREnabled(): boolean;
        set HDREnabled(enabled: boolean);
        /**
         * @ignore
         * Specifies if the volumetric lights scattering effect is enabled
         */
        get VLSEnabled(): boolean;
        set VLSEnabled(enabled: boolean);
        /**
         * @ignore
         * Specifies if the motion blur effect is enabled
         */
        get MotionBlurEnabled(): boolean;
        set MotionBlurEnabled(enabled: boolean);
        /**
         * Specifies if anti-aliasing is enabled
         */
        get fxaaEnabled(): boolean;
        set fxaaEnabled(enabled: boolean);
        /**
         * Specifies if screen space reflections are enabled.
         */
        get screenSpaceReflectionsEnabled(): boolean;
        set screenSpaceReflectionsEnabled(enabled: boolean);
        /**
         * Specifies the number of steps used to calculate the volumetric lights
         * Typically in interval [50, 200]
         */
        get volumetricLightStepsCount(): number;
        set volumetricLightStepsCount(count: number);
        /**
         * Specifies the number of samples used for the motion blur effect
         * Typically in interval [16, 64]
         */
        get motionBlurSamples(): number;
        set motionBlurSamples(samples: number);
        /**
         * Specifies MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)
         */
        get samples(): number;
        set samples(sampleCount: number);
        /**
         * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.
         * @constructor
         * @param name The rendering pipeline name
         * @param scene The scene linked to this pipeline
         * @param ratio The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)
         * @param originalPostProcess the custom original color post-process. Must be "reusable". Can be null.
         * @param cameras The array of cameras that the rendering pipeline will be attached to
         */
        constructor(name: string, scene: Scene, ratio: number, originalPostProcess?: Nullable<PostProcess>, cameras?: Camera[]);
        private _buildPipeline;
        private _createDownSampleX4PostProcess;
        private _createBrightPassPostProcess;
        private _createBlurPostProcesses;
        private _createTextureAdderPostProcess;
        private _createVolumetricLightPostProcess;
        private _createLuminancePostProcesses;
        private _createHdrPostProcess;
        private _createLensFlarePostProcess;
        private _createDepthOfFieldPostProcess;
        private _createMotionBlurPostProcess;
        private _getDepthTexture;
        private _disposePostProcesses;
        /**
         * Dispose of the pipeline and stop all post processes
         */
        dispose(): void;
        /**
         * Serialize the rendering pipeline (Used when exporting)
         * @returns the serialized object
         */
        serialize(): any;
        /**
         * Parse the serialized pipeline
         * @param source Source pipeline.
         * @param scene The scene to load the pipeline to.
         * @param rootUrl The URL of the serialized pipeline.
         * @returns An instantiated pipeline from the serialized object.
         */
        static Parse(source: any, scene: Scene, rootUrl: string): StandardRenderingPipeline;
        /**
         * Luminance steps
         */
        static LuminanceSteps: number;
    }
}
declare module BABYLON {
    /** @hidden */
    export var stereoscopicInterlacePixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * StereoscopicInterlacePostProcessI used to render stereo views from a rigged camera with support for alternate line interlacing
     */
    export class StereoscopicInterlacePostProcessI extends PostProcess {
        private _stepSize;
        private _passedProcess;
        /**
         * Gets a string identifying the name of the class
         * @returns "StereoscopicInterlacePostProcessI" string
         */
        getClassName(): string;
        /**
         * Initializes a StereoscopicInterlacePostProcessI
         * @param name The name of the effect.
         * @param rigCameras The rig cameras to be appled to the post process
         * @param isStereoscopicHoriz If the rendered results are horizontal or vertical
         * @param isStereoscopicInterlaced If the rendered results are alternate line interlaced
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         */
        constructor(name: string, rigCameras: Camera[], isStereoscopicHoriz: boolean, isStereoscopicInterlaced: boolean, samplingMode?: number, engine?: Engine, reusable?: boolean);
    }
    /**
     * StereoscopicInterlacePostProcess used to render stereo views from a rigged camera
     */
    export class StereoscopicInterlacePostProcess extends PostProcess {
        private _stepSize;
        private _passedProcess;
        /**
         * Gets a string identifying the name of the class
         * @returns "StereoscopicInterlacePostProcess" string
         */
        getClassName(): string;
        /**
         * Initializes a StereoscopicInterlacePostProcess
         * @param name The name of the effect.
         * @param rigCameras The rig cameras to be appled to the post process
         * @param isStereoscopicHoriz If the rendered results are horizontal or verticle
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         */
        constructor(name: string, rigCameras: Camera[], isStereoscopicHoriz: boolean, samplingMode?: number, engine?: Engine, reusable?: boolean);
    }
}
declare module BABYLON {
    /** @hidden */
    export var tonemapPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** Defines operator used for tonemapping */
    export enum TonemappingOperator {
        /** Hable */
        Hable = 0,
        /** Reinhard */
        Reinhard = 1,
        /** HejiDawson */
        HejiDawson = 2,
        /** Photographic */
        Photographic = 3
    }
    /**
     * Defines a post process to apply tone mapping
     */
    export class TonemapPostProcess extends PostProcess {
        private _operator;
        /** Defines the required exposure adjustement */
        exposureAdjustment: number;
        /**
         * Gets a string identifying the name of the class
         * @returns "TonemapPostProcess" string
         */
        getClassName(): string;
        /**
         * Creates a new TonemapPostProcess
         * @param name defines the name of the postprocess
         * @param _operator defines the operator to use
         * @param exposureAdjustment defines the required exposure adjustement
         * @param camera defines the camera to use (can be null)
         * @param samplingMode defines the required sampling mode (BABYLON.Texture.BILINEAR_SAMPLINGMODE by default)
         * @param engine defines the hosting engine (can be ignore if camera is set)
         * @param textureFormat defines the texture format to use (BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT by default)
         */
        constructor(name: string, _operator: TonemappingOperator, 
        /** Defines the required exposure adjustement */
        exposureAdjustment: number, camera: Camera, samplingMode?: number, engine?: Engine, textureFormat?: number);
    }
}
declare module BABYLON {
    /** @hidden */
    export var volumetricLightScatteringPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var volumetricLightScatteringPassVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var volumetricLightScatteringPassPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     *  Inspired by http://http.developer.nvidia.com/GPUGems3/gpugems3_ch13.html
     */
    export class VolumetricLightScatteringPostProcess extends PostProcess {
        private _volumetricLightScatteringPass;
        private _volumetricLightScatteringRTT;
        private _viewPort;
        private _screenCoordinates;
        private _cachedDefines;
        /**
        * If not undefined, the mesh position is computed from the attached node position
        */
        attachedNode: {
            position: Vector3;
        };
        /**
        * Custom position of the mesh. Used if "useCustomMeshPosition" is set to "true"
        */
        customMeshPosition: Vector3;
        /**
        * Set if the post-process should use a custom position for the light source (true) or the internal mesh position (false)
        */
        useCustomMeshPosition: boolean;
        /**
        * If the post-process should inverse the light scattering direction
        */
        invert: boolean;
        /**
        * The internal mesh used by the post-process
        */
        mesh: Mesh;
        /**
         * @hidden
         * VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead
         */
        get useDiffuseColor(): boolean;
        set useDiffuseColor(useDiffuseColor: boolean);
        /**
        * Array containing the excluded meshes not rendered in the internal pass
        */
        excludedMeshes: AbstractMesh[];
        /**
        * Controls the overall intensity of the post-process
        */
        exposure: number;
        /**
        * Dissipates each sample's contribution in range [0, 1]
        */
        decay: number;
        /**
        * Controls the overall intensity of each sample
        */
        weight: number;
        /**
        * Controls the density of each sample
        */
        density: number;
        /**
         * @constructor
         * @param name The post-process name
         * @param ratio The size of the post-process and/or internal pass (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)
         * @param camera The camera that the post-process will be attached to
         * @param mesh The mesh used to create the light scattering
         * @param samples The post-process quality, default 100
         * @param samplingModeThe post-process filtering mode
         * @param engine The babylon engine
         * @param reusable If the post-process is reusable
         * @param scene The constructor needs a scene reference to initialize internal components. If "camera" is null a "scene" must be provided
         */
        constructor(name: string, ratio: any, camera: Camera, mesh?: Mesh, samples?: number, samplingMode?: number, engine?: Engine, reusable?: boolean, scene?: Scene);
        /**
         * Returns the string "VolumetricLightScatteringPostProcess"
         * @returns "VolumetricLightScatteringPostProcess"
         */
        getClassName(): string;
        private _isReady;
        /**
         * Sets the new light position for light scattering effect
         * @param position The new custom light position
         */
        setCustomMeshPosition(position: Vector3): void;
        /**
         * Returns the light position for light scattering effect
         * @return Vector3 The custom light position
         */
        getCustomMeshPosition(): Vector3;
        /**
         * Disposes the internal assets and detaches the post-process from the camera
         */
        dispose(camera: Camera): void;
        /**
         * Returns the render target texture used by the post-process
         * @return the render target texture used by the post-process
         */
        getPass(): RenderTargetTexture;
        private _meshExcluded;
        private _createPass;
        private _updateMeshScreenCoordinates;
        /**
        * Creates a default mesh for the Volumeric Light Scattering post-process
        * @param name The mesh name
        * @param scene The scene where to create the mesh
        * @return the default mesh
        */
        static CreateDefaultMesh(name: string, scene: Scene): Mesh;
    }
}
declare module BABYLON {
    /** @hidden */
    export var screenSpaceCurvaturePixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * The Screen Space curvature effect can help highlighting ridge and valley of a model.
     */
    export class ScreenSpaceCurvaturePostProcess extends PostProcess {
        /**
         * Defines how much ridge the curvature effect displays.
         */
        ridge: number;
        /**
         * Defines how much valley the curvature effect displays.
         */
        valley: number;
        private _geometryBufferRenderer;
        /**
         * Gets a string identifying the name of the class
         * @returns "ScreenSpaceCurvaturePostProcess" string
         */
        getClassName(): string;
        /**
         * Creates a new instance ScreenSpaceCurvaturePostProcess
         * @param name The name of the effect.
         * @param scene The scene containing the objects to blur according to their velocity.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, scene: Scene, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
        /**
         * Support test.
         */
        static get IsSupported(): boolean;
        /** @hidden */
        static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): ScreenSpaceCurvaturePostProcess;
    }
}
declare module BABYLON {
        interface Scene {
            /** @hidden (Backing field) */
            _boundingBoxRenderer: BoundingBoxRenderer;
            /** @hidden (Backing field) */
            _forceShowBoundingBoxes: boolean;
            /**
             * Gets or sets a boolean indicating if all bounding boxes must be rendered
             */
            forceShowBoundingBoxes: boolean;
            /**
             * Gets the bounding box renderer associated with the scene
             * @returns a BoundingBoxRenderer
             */
            getBoundingBoxRenderer(): BoundingBoxRenderer;
        }
        interface AbstractMesh {
            /** @hidden (Backing field) */
            _showBoundingBox: boolean;
            /**
             * Gets or sets a boolean indicating if the bounding box must be rendered as well (false by default)
             */
            showBoundingBox: boolean;
        }
    /**
     * Component responsible of rendering the bounding box of the meshes in a scene.
     * This is usually used through the mesh.showBoundingBox or the scene.forceShowBoundingBoxes properties
     */
    export class BoundingBoxRenderer implements ISceneComponent {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        readonly name: string;
        /**
         * The scene the component belongs to.
         */
        scene: Scene;
        /**
         * Color of the bounding box lines placed in front of an object
         */
        frontColor: Color3;
        /**
         * Color of the bounding box lines placed behind an object
         */
        backColor: Color3;
        /**
         * Defines if the renderer should show the back lines or not
         */
        showBackLines: boolean;
        /**
         * Observable raised before rendering a bounding box
         */
        onBeforeBoxRenderingObservable: Observable<BoundingBox>;
        /**
         * Observable raised after rendering a bounding box
         */
        onAfterBoxRenderingObservable: Observable<BoundingBox>;
        /**
         * @hidden
         */
        renderList: SmartArray<BoundingBox>;
        private _colorShader;
        private _vertexBuffers;
        private _indexBuffer;
        private _fillIndexBuffer;
        private _fillIndexData;
        /**
         * Instantiates a new bounding box renderer in a scene.
         * @param scene the scene the  renderer renders in
         */
        constructor(scene: Scene);
        /**
         * Registers the component in a given scene
         */
        register(): void;
        private _evaluateSubMesh;
        private _activeMesh;
        private _prepareRessources;
        private _createIndexBuffer;
        /**
         * Rebuilds the elements related to this component in case of
         * context lost for instance.
         */
        rebuild(): void;
        /**
         * @hidden
         */
        reset(): void;
        /**
         * Render the bounding boxes of a specific rendering group
         * @param renderingGroupId defines the rendering group to render
         */
        render(renderingGroupId: number): void;
        /**
         * In case of occlusion queries, we can render the occlusion bounding box through this method
         * @param mesh Define the mesh to render the occlusion bounding box for
         */
        renderOcclusionBoundingBox(mesh: AbstractMesh): void;
        /**
         * Dispose and release the resources attached to this renderer.
         */
        dispose(): void;
    }
}
declare module BABYLON {
        interface Scene {
            /** @hidden (Backing field) */
            _depthRenderer: {
                [id: string]: DepthRenderer;
            };
            /**
             * Creates a depth renderer a given camera which contains a depth map which can be used for post processing.
             * @param camera The camera to create the depth renderer on (default: scene's active camera)
             * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z
             * @returns the created depth renderer
             */
            enableDepthRenderer(camera?: Nullable<Camera>, storeNonLinearDepth?: boolean): DepthRenderer;
            /**
             * Disables a depth renderer for a given camera
             * @param camera The camera to disable the depth renderer on (default: scene's active camera)
             */
            disableDepthRenderer(camera?: Nullable<Camera>): void;
        }
    /**
     * Defines the Depth Renderer scene component responsible to manage a depth buffer useful
     * in several rendering techniques.
     */
    export class DepthRendererSceneComponent implements ISceneComponent {
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */
        readonly name: string;
        /**
         * The scene the component belongs to.
         */
        scene: Scene;
        /**
         * Creates a new instance of the component for the given scene
         * @param scene Defines the scene to register the component in
         */
        constructor(scene: Scene);
        /**
         * Registers the component in a given scene
         */
        register(): void;
        /**
         * Rebuilds the elements related to this component in case of
         * context lost for instance.
         */
        rebuild(): void;
        /**
         * Disposes the component and the associated ressources
         */
        dispose(): void;
        private _gatherRenderTargets;
        private _gatherActiveCameraRenderTargets;
    }
}
declare module BABYLON {
        interface AbstractScene {
            /** @hidden (Backing field) */
            _prePassRenderer: Nullable<PrePassRenderer>;
            /**
             * Gets or Sets the current prepass renderer associated to the scene.
             */
            prePassRenderer: Nullable<PrePassRenderer>;
            /**
             * Enables the prepass and associates it with the scene
             * @returns the PrePassRenderer
             */
            enablePrePassRenderer(): Nullable<PrePassRenderer>;
            /**
             * Disables the prepass associated with the scene
             */
            disablePrePassRenderer(): void;
        }
    /**
     * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful
     * in several rendering techniques.
     */
    export class PrePassRendererSceneComponent implements ISceneSerializableComponent {
        /**
         * The component name helpful to identify the component in the list of scene components.
         */
        readonly name: string;
        /**
         * The scene the component belongs to.
         */
        scene: Scene;
        /**
         * Creates a new instance of the component for the given scene
         * @param scene Defines the scene to register the component in
         */
        constructor(scene: Scene);
        /**
         * Registers the component in a given scene
         */
        register(): void;
        private _beforeCameraDraw;
        private _afterCameraDraw;
        private _beforeClearStage;
        /**
         * Serializes the component data to the specified json object
         * @param serializationObject The object to serialize to
         */
        serialize(serializationObject: any): void;
        /**
         * Adds all the elements from the container to the scene
         * @param container the container holding the elements
         */
        addFromContainer(container: AbstractScene): void;
        /**
         * Removes all the elements in the container from the scene
         * @param container contains the elements to remove
         * @param dispose if the removed element should be disposed (default: false)
         */
        removeFromContainer(container: AbstractScene, dispose?: boolean): void;
        /**
         * Rebuilds the elements related to this component in case of
         * context lost for instance.
         */
        rebuild(): void;
        /**
         * Disposes the component and the associated ressources
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /** @hidden */
    export var outlinePixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var outlineVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
        interface Scene {
            /** @hidden */
            _outlineRenderer: OutlineRenderer;
            /**
             * Gets the outline renderer associated with the scene
             * @returns a OutlineRenderer
             */
            getOutlineRenderer(): OutlineRenderer;
        }
        interface AbstractMesh {
            /** @hidden (Backing field) */
            _renderOutline: boolean;
            /**
             * Gets or sets a boolean indicating if the outline must be rendered as well
             * @see https://www.babylonjs-playground.com/#10WJ5S#3
             */
            renderOutline: boolean;
            /** @hidden (Backing field) */
            _renderOverlay: boolean;
            /**
             * Gets or sets a boolean indicating if the overlay must be rendered as well
             * @see https://www.babylonjs-playground.com/#10WJ5S#2
             */
            renderOverlay: boolean;
        }
    /**
     * This class is responsible to draw bothe outline/overlay of meshes.
     * It should not be used directly but through the available method on mesh.
     */
    export class OutlineRenderer implements ISceneComponent {
        /**
         * Stencil value used to avoid outline being seen within the mesh when the mesh is transparent
         */
        private static _StencilReference;
        /**
         * The name of the component. Each component must have a unique name.
         */
        name: string;
        /**
         * The scene the component belongs to.
         */
        scene: Scene;
        /**
         * Defines a zOffset to prevent zFighting between the overlay and the mesh.
         */
        zOffset: number;
        private _engine;
        private _effect;
        private _cachedDefines;
        private _savedDepthWrite;
        /**
         * Instantiates a new outline renderer. (There could be only one per scene).
         * @param scene Defines the scene it belongs to
         */
        constructor(scene: Scene);
        /**
         * Register the component to one instance of a scene.
         */
        register(): void;
        /**
         * Rebuilds the elements related to this component in case of
         * context lost for instance.
         */
        rebuild(): void;
        /**
         * Disposes the component and the associated ressources.
         */
        dispose(): void;
        /**
         * Renders the outline in the canvas.
         * @param subMesh Defines the sumesh to render
         * @param batch Defines the batch of meshes in case of instances
         * @param useOverlay Defines if the rendering is for the overlay or the outline
         */
        render(subMesh: SubMesh, batch: _InstancesBatch, useOverlay?: boolean): void;
        /**
         * Returns whether or not the outline renderer is ready for a given submesh.
         * All the dependencies e.g. submeshes, texture, effect... mus be ready
         * @param subMesh Defines the submesh to check readyness for
         * @param useInstances Defines wheter wee are trying to render instances or not
         * @returns true if ready otherwise false
         */
        isReady(subMesh: SubMesh, useInstances: boolean): boolean;
        private _beforeRenderingMesh;
        private _afterRenderingMesh;
    }
}
declare module BABYLON {
    /**
     * Defines the basic options interface of a Sprite Frame Source Size.
     */
    export interface ISpriteJSONSpriteSourceSize {
        /**
         * number of the original width of the Frame
         */
        w: number;
        /**
         * number of the original height of the Frame
         */
        h: number;
    }
    /**
     * Defines the basic options interface of a Sprite Frame Data.
     */
    export interface ISpriteJSONSpriteFrameData {
        /**
         * number of the x offset of the Frame
         */
        x: number;
        /**
         * number of the y offset of the Frame
         */
        y: number;
        /**
         * number of the width of the Frame
         */
        w: number;
        /**
         * number of the height of the Frame
         */
        h: number;
    }
    /**
     * Defines the basic options interface of a JSON Sprite.
     */
    export interface ISpriteJSONSprite {
        /**
         * string name of the Frame
         */
        filename: string;
        /**
         * ISpriteJSONSpriteFrame basic object of the frame data
         */
        frame: ISpriteJSONSpriteFrameData;
        /**
        * boolean to flag is the frame was rotated.
        */
        rotated: boolean;
        /**
        * boolean to flag is the frame was trimmed.
        */
        trimmed: boolean;
        /**
         * ISpriteJSONSpriteFrame basic object of the source data
         */
        spriteSourceSize: ISpriteJSONSpriteFrameData;
        /**
         * ISpriteJSONSpriteFrame basic object of the source data
         */
        sourceSize: ISpriteJSONSpriteSourceSize;
    }
    /**
     * Defines the basic options interface of a JSON atlas.
     */
    export interface ISpriteJSONAtlas {
        /**
         * Array of objects that contain the frame data.
         */
        frames: Array<ISpriteJSONSprite>;
        /**
         * object basic object containing the sprite meta data.
         */
        meta?: object;
    }
}
declare module BABYLON {
    /** @hidden */
    export var spriteMapPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var spriteMapVertexShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /**
     * Defines the basic options interface of a SpriteMap
     */
    export interface ISpriteMapOptions {
        /**
         * Vector2 of the number of cells in the grid.
         */
        stageSize?: Vector2;
        /**
         * Vector2 of the size of the output plane in World Units.
         */
        outputSize?: Vector2;
        /**
         * Vector3 of the position of the output plane in World Units.
         */
        outputPosition?: Vector3;
        /**
         * Vector3 of the rotation of the output plane.
         */
        outputRotation?: Vector3;
        /**
         * number of layers that the system will reserve in resources.
         */
        layerCount?: number;
        /**
         * number of max animation frames a single cell will reserve in resources.
         */
        maxAnimationFrames?: number;
        /**
         * number cell index of the base tile when the system compiles.
         */
        baseTile?: number;
        /**
        * boolean flip the sprite after its been repositioned by the framing data.
        */
        flipU?: boolean;
        /**
         * Vector3 scalar of the global RGB values of the SpriteMap.
         */
        colorMultiply?: Vector3;
    }
    /**
     * Defines the IDisposable interface in order to be cleanable from resources.
     */
    export interface ISpriteMap extends IDisposable {
        /**
         * String name of the SpriteMap.
         */
        name: string;
        /**
         * The JSON Array file from a https://www.codeandweb.com/texturepacker export.  Or similar structure.
         */
        atlasJSON: ISpriteJSONAtlas;
        /**
         * Texture of the SpriteMap.
         */
        spriteSheet: Texture;
        /**
         * The parameters to initialize the SpriteMap with.
         */
        options: ISpriteMapOptions;
    }
    /**
     * Class used to manage a grid restricted sprite deployment on an Output plane.
     */
    export class SpriteMap implements ISpriteMap {
        /** The Name of the spriteMap */
        name: string;
        /** The JSON file with the frame and meta data */
        atlasJSON: ISpriteJSONAtlas;
        /** The systems Sprite Sheet Texture */
        spriteSheet: Texture;
        /** Arguments passed with the Constructor */
        options: ISpriteMapOptions;
        /** Public Sprite Storage array, parsed from atlasJSON */
        sprites: Array<ISpriteJSONSprite>;
        /** Returns the Number of Sprites in the System */
        get spriteCount(): number;
        /** Returns the Position of Output Plane*/
        get position(): Vector3;
        /** Returns the Position of Output Plane*/
        set position(v: Vector3);
        /** Returns the Rotation of Output Plane*/
        get rotation(): Vector3;
        /** Returns the Rotation of Output Plane*/
        set rotation(v: Vector3);
        /** Sets the AnimationMap*/
        get animationMap(): RawTexture;
        /** Sets the AnimationMap*/
        set animationMap(v: RawTexture);
        /** Scene that the SpriteMap was created in */
        private _scene;
        /** Texture Buffer of Float32 that holds tile frame data*/
        private _frameMap;
        /** Texture Buffers of Float32 that holds tileMap data*/
        private _tileMaps;
        /** Texture Buffer of Float32 that holds Animation Data*/
        private _animationMap;
        /** Custom ShaderMaterial Central to the System*/
        private _material;
        /** Custom ShaderMaterial Central to the System*/
        private _output;
        /** Systems Time Ticker*/
        private _time;
        /**
         * Creates a new SpriteMap
         * @param name defines the SpriteMaps Name
         * @param atlasJSON is the JSON file that controls the Sprites Frames and Meta
         * @param spriteSheet is the Texture that the Sprites are on.
         * @param options a basic deployment configuration
         * @param scene The Scene that the map is deployed on
         */
        constructor(name: string, atlasJSON: ISpriteJSONAtlas, spriteSheet: Texture, options: ISpriteMapOptions, scene: Scene);
        /**
        * Returns tileID location
        * @returns Vector2 the cell position ID
        */
        getTileID(): Vector2;
        /**
        * Gets the UV location of the mouse over the SpriteMap.
        * @returns Vector2 the UV position of the mouse interaction
        */
        getMousePosition(): Vector2;
        /**
        * Creates the "frame" texture Buffer
        * -------------------------------------
        * Structure of frames
        *  "filename": "Falling-Water-2.png",
        * "frame": {"x":69,"y":103,"w":24,"h":32},
        * "rotated": true,
        * "trimmed": true,
        * "spriteSourceSize": {"x":4,"y":0,"w":24,"h":32},
        * "sourceSize": {"w":32,"h":32}
        * @returns RawTexture of the frameMap
        */
        private _createFrameBuffer;
        /**
        * Creates the tileMap texture Buffer
        * @param buffer normally and array of numbers, or a false to generate from scratch
        * @param _layer indicates what layer for a logic trigger dealing with the baseTile.  The system uses this
        * @returns RawTexture of the tileMap
        */
        private _createTileBuffer;
        /**
        * Modifies the data of the tileMaps
        * @param _layer is the ID of the layer you want to edit on the SpriteMap
        * @param pos is the iVector2 Coordinates of the Tile
        * @param tile The SpriteIndex of the new Tile
        */
        changeTiles(_layer: number | undefined, pos: Vector2 | Vector2[], tile?: number): void;
        /**
        * Creates the animationMap texture Buffer
        * @param buffer normally and array of numbers, or a false to generate from scratch
        * @returns RawTexture of the animationMap
        */
        private _createTileAnimationBuffer;
        /**
        * Modifies the data of the animationMap
        * @param cellID is the Index of the Sprite
        * @param _frame is the target Animation frame
        * @param toCell is the Target Index of the next frame of the animation
        * @param time is a value between 0-1 that is the trigger for when the frame should change tiles
        * @param speed is a global scalar of the time variable on the map.
        */
        addAnimationToTile(cellID?: number, _frame?: number, toCell?: number, time?: number, speed?: number): void;
        /**
        * Exports the .tilemaps file
        */
        saveTileMaps(): void;
        /**
        * Imports the .tilemaps file
        * @param url of the .tilemaps file
        */
        loadTileMaps(url: string): void;
        /**
         * Release associated resources
         */
        dispose(): void;
    }
}
declare module BABYLON {
    /**
     * Class used to manage multiple sprites of different sizes on the same spritesheet
     * @see https://doc.babylonjs.com/babylon101/sprites
     */
    export class SpritePackedManager extends SpriteManager {
        /** defines the packed manager's name */
        name: string;
        /**
         * Creates a new sprite manager from a packed sprite sheet
         * @param name defines the manager's name
         * @param imgUrl defines the sprite sheet url
         * @param capacity defines the maximum allowed number of sprites
         * @param scene defines the hosting scene
         * @param spriteJSON null otherwise a JSON object defining sprite sheet data
         * @param epsilon defines the epsilon value to align texture (0.01 by default)
         * @param samplingMode defines the smapling mode to use with spritesheet
         * @param fromPacked set to true; do not alter
         */
        constructor(
        /** defines the packed manager's name */
        name: string, imgUrl: string, capacity: number, scene: Scene, spriteJSON?: string | null, epsilon?: number, samplingMode?: number);
    }
}
declare module BABYLON {
    /**
     * Defines the list of states available for a task inside a AssetsManager
     */
    export enum AssetTaskState {
        /**
         * Initialization
         */
        INIT = 0,
        /**
         * Running
         */
        RUNNING = 1,
        /**
         * Done
         */
        DONE = 2,
        /**
         * Error
         */
        ERROR = 3
    }
    /**
     * Define an abstract asset task used with a AssetsManager class to load assets into a scene
     */
    export abstract class AbstractAssetTask {
        /**
         * Task name
         */ name: string;
        /**
         * Callback called when the task is successful
         */
        onSuccess: (task: any) => void;
        /**
         * Callback called when the task is not successful
         */
        onError: (task: any, message?: string, exception?: any) => void;
        /**
         * Creates a new AssetsManager
         * @param name defines the name of the task
         */
        constructor(
        /**
         * Task name
         */ name: string);
        private _isCompleted;
        private _taskState;
        private _errorObject;
        /**
         * Get if the task is completed
         */
        get isCompleted(): boolean;
        /**
         * Gets the current state of the task
         */
        get taskState(): AssetTaskState;
        /**
         * Gets the current error object (if task is in error)
         */
        get errorObject(): {
            message?: string;
            exception?: any;
        };
        /**
         * Internal only
         * @hidden
         */
        _setErrorObject(message?: string, exception?: any): void;
        /**
         * Execute the current task
         * @param scene defines the scene where you want your assets to be loaded
         * @param onSuccess is a callback called when the task is successfully executed
         * @param onError is a callback called if an error occurs
         */
        run(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void;
        /**
         * Execute the current task
         * @param scene defines the scene where you want your assets to be loaded
         * @param onSuccess is a callback called when the task is successfully executed
         * @param onError is a callback called if an error occurs
         */
        runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void;
        /**
         * Reset will set the task state back to INIT, so the next load call of the assets manager will execute this task again.
         * This can be used with failed tasks that have the reason for failure fixed.
         */
        reset(): void;
        private onErrorCallback;
        private onDoneCallback;
    }
    /**
     * Define the interface used by progress events raised during assets loading
     */
    export interface IAssetsProgressEvent {
        /**
         * Defines the number of remaining tasks to process
         */
        remainingCount: number;
        /**
         * Defines the total number of tasks
         */
        totalCount: number;
        /**
         * Defines the task that was just processed
         */
        task: AbstractAssetTask;
    }
    /**
     * Class used to share progress information about assets loading
     */
    export class AssetsProgressEvent implements IAssetsProgressEvent {
        /**
         * Defines the number of remaining tasks to process
         */
        remainingCount: number;
        /**
         * Defines the total number of tasks
         */
        totalCount: number;
        /**
         * Defines the task that was just processed
         */
        task: AbstractAssetTask;
        /**
         * Creates a AssetsProgressEvent
         * @param remainingCount defines the number of remaining tasks to process
         * @param totalCount defines the total number of tasks
         * @param task defines the task that was just processed
         */
        constructor(remainingCount: number, totalCount: number, task: AbstractAssetTask);
    }
    /**
     * Define a task used by AssetsManager to load assets into a container
     */
    export class ContainerAssetTask extends AbstractAssetTask {
        /**
         * Defines the name of the task
         */
        name: string;
        /**
         * Defines the list of mesh's names you want to load
         */
        meshesNames: any;
        /**
         * Defines the root url to use as a base to load your meshes and associated resources
         */
        rootUrl: string;
        /**
         * Defines the filename or File of the scene to load from
         */
        sceneFilename: string | File;
        /**
         * Get the loaded asset container
         */
        loadedContainer: AssetContainer;
        /**
         * Gets the list of loaded meshes
         */
        loadedMeshes: Array<AbstractMesh>;
        /**
         * Gets the list of loaded particle systems
         */
        loadedParticleSystems: Array<IParticleSystem>;
        /**
         * Gets the list of loaded skeletons
         */
        loadedSkeletons: Array<Skeleton>;
        /**
         * Gets the list of loaded animation groups
         */
        loadedAnimationGroups: Array<AnimationGroup>;
        /**
         * Callback called when the task is successful
         */
        onSuccess: (task: ContainerAssetTask) => void;
        /**
         * Callback called when the task is successful
         */
        onError: (task: ContainerAssetTask, message?: string, exception?: any) => void;
        /**
         * Creates a new ContainerAssetTask
         * @param name defines the name of the task
         * @param meshesNames defines the list of mesh's names you want to load
         * @param rootUrl defines the root url to use as a base to load your meshes and associated resources
         * @param sceneFilename defines the filename or File of the scene to load from
         */
        constructor(
        /**
         * Defines the name of the task
         */
        name: string, 
        /**
         * Defines the list of mesh's names you want to load
         */
        meshesNames: any, 
        /**
         * Defines the root url to use as a base to load your meshes and associated resources
         */
        rootUrl: string, 
        /**
         * Defines the filename or File of the scene to load from
         */
        sceneFilename: string | File);
        /**
         * Execute the current task
         * @param scene defines the scene where you want your assets to be loaded
         * @param onSuccess is a callback called when the task is successfully executed
         * @param onError is a callback called if an error occurs
         */
        runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void;
    }
    /**
     * Define a task used by AssetsManager to load meshes
     */
    export class MeshAssetTask extends AbstractAssetTask {
        /**
         * Defines the name of the task
         */
        name: string;
        /**
         * Defines the list of mesh's names you want to load
         */
        meshesNames: any;
        /**
         * Defines the root url to use as a base to load your meshes and associated resources
         */
        rootUrl: string;
        /**
         * Defines the filename or File of the scene to load from
         */
        sceneFilename: string | File;
        /**
         * Gets the list of loaded meshes
         */
        loadedMeshes: Array<AbstractMesh>;
        /**
         * Gets the list of loaded particle systems
         */
        loadedParticleSystems: Array<IParticleSystem>;
        /**
         * Gets the list of loaded skeletons
         */
        loadedSkeletons: Array<Skeleton>;
        /**
         * Gets the list of loaded animation groups
         */
        loadedAnimationGroups: Array<AnimationGroup>;
        /**
         * Callback called when the task is successful
         */
        onSuccess: (task: MeshAssetTask) => void;
        /**
         * Callback called when the task is successful
         */
        onError: (task: MeshAssetTask, message?: string, exception?: any) => void;
        /**
         * Creates a new MeshAssetTask
         * @param name defines the name of the task
         * @param meshesNames defines the list of mesh's names you want to load
         * @param rootUrl defines the root url to use as a base to load your meshes and associated resources
         * @param sceneFilename defines the filename or File of the scene to load from
         */
        constructor(
        /**
         * Defines the name of the task
         */
        name: string, 
        /**
         * Defines the list of mesh's names you want to load
         */
        meshesNames: any, 
        /**
         * Defines the root url to use as a base to load your meshes and associated resources
         */
        rootUrl: string, 
        /**
         * Defines the filename or File of the scene to load from
         */
        sceneFilename: string | File);
        /**
         * Execute the current task
         * @param scene defines the scene where you want your assets to be loaded
         * @param onSuccess is a callback called when the task is successfully executed
         * @param onError is a callback called if an error occurs
         */
        runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void;
    }
    /**
     * Define a task used by AssetsManager to load text content
     */
    export class TextFileAssetTask extends AbstractAssetTask {
        /**
         * Defines the name of the task
         */
        name: string;
        /**
         * Defines the location of the file to load
         */
        url: string;
        /**
         * Gets the loaded text string
         */
        text: string;
        /**
         * Callback called when the task is successful
         */
        onSuccess: (task: TextFileAssetTask) => void;
        /**
         * Callback called when the task is successful
         */
        onError: (task: TextFileAssetTask, message?: string, exception?: any) => void;
        /**
         * Creates a new TextFileAssetTask object
         * @param name defines the name of the task
         * @param url defines the location of the file to load
         */
        constructor(
        /**
         * Defines the name of the task
         */
        name: string, 
        /**
         * Defines the location of the file to load
         */
        url: string);
        /**
         * Execute the current task
         * @param scene defines the scene where you want your assets to be loaded
         * @param onSuccess is a callback called when the task is successfully executed
         * @param onError is a callback called if an error occurs
         */
        runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void;
    }
    /**
     * Define a task used by AssetsManager to load binary data
     */
    export class BinaryFileAssetTask extends AbstractAssetTask {
        /**
         * Defines the name of the task
         */
        name: string;
        /**
         * Defines the location of the file to load
         */
        url: string;
        /**
         * Gets the lodaded data (as an array buffer)
         */
        data: ArrayBuffer;
        /**
         * Callback called when the task is successful
         */
        onSuccess: (task: BinaryFileAssetTask) => void;
        /**
         * Callback called when the task is successful
         */
        onError: (task: BinaryFileAssetTask, message?: string, exception?: any) => void;
        /**
         * Creates a new BinaryFileAssetTask object
         * @param name defines the name of the new task
         * @param url defines the location of the file to load
         */
        constructor(
        /**
         * Defines the name of the task
         */
        name: string, 
        /**
         * Defines the location of the file to load
         */
        url: string);
        /**
         * Execute the current task
         * @param scene defines the scene where you want your assets to be loaded
         * @param onSuccess is a callback called when the task is successfully executed
         * @param onError is a callback called if an error occurs
         */
        runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void;
    }
    /**
     * Define a task used by AssetsManager to load images
     */
    export class ImageAssetTask extends AbstractAssetTask {
        /**
         * Defines the name of the task
         */
        name: string;
        /**
         * Defines the location of the image to load
         */
        url: string;
        /**
         * Gets the loaded images
         */
        image: HTMLImageElement;
        /**
         * Callback called when the task is successful
         */
        onSuccess: (task: ImageAssetTask) => void;
        /**
         * Callback called when the task is successful
         */
        onError: (task: ImageAssetTask, message?: string, exception?: any) => void;
        /**
         * Creates a new ImageAssetTask
         * @param name defines the name of the task
         * @param url defines the location of the image to load
         */
        constructor(
        /**
         * Defines the name of the task
         */
        name: string, 
        /**
         * Defines the location of the image to load
         */
        url: string);
        /**
         * Execute the current task
         * @param scene defines the scene where you want your assets to be loaded
         * @param onSuccess is a callback called when the task is successfully executed
         * @param onError is a callback called if an error occurs
         */
        runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void;
    }
    /**
     * Defines the interface used by texture loading tasks
     */
    export interface ITextureAssetTask<TEX extends BaseTexture> {
        /**
         * Gets the loaded texture
         */
        texture: TEX;
    }
    /**
     * Define a task used by AssetsManager to load 2D textures
     */
    export class TextureAssetTask extends AbstractAssetTask implements ITextureAssetTask<Texture> {
        /**
         * Defines the name of the task
         */
        name: string;
        /**
         * Defines the location of the file to load
         */
        url: string;
        /**
         * Defines if mipmap should not be generated (default is false)
         */
        noMipmap?: boolean | undefined;
        /**
         * Defines if texture must be inverted on Y axis (default is true)
         */
        invertY: boolean;
        /**
         * Defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)
         */
        samplingMode: number;
        /**
         * Gets the loaded texture
         */
        texture: Texture;
        /**
         * Callback called when the task is successful
         */
        onSuccess: (task: TextureAssetTask) => void;
        /**
         * Callback called when the task is successful
         */
        onError: (task: TextureAssetTask, message?: string, exception?: any) => void;
        /**
         * Creates a new TextureAssetTask object
         * @param name defines the name of the task
         * @param url defines the location of the file to load
         * @param noMipmap defines if mipmap should not be generated (default is false)
         * @param invertY defines if texture must be inverted on Y axis (default is true)
         * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)
         */
        constructor(
        /**
         * Defines the name of the task
         */
        name: string, 
        /**
         * Defines the location of the file to load
         */
        url: string, 
        /**
         * Defines if mipmap should not be generated (default is false)
         */
        noMipmap?: boolean | undefined, 
        /**
         * Defines if texture must be inverted on Y axis (default is true)
         */
        invertY?: boolean, 
        /**
         * Defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)
         */
        samplingMode?: number);
        /**
         * Execute the current task
         * @param scene defines the scene where you want your assets to be loaded
         * @param onSuccess is a callback called when the task is successfully executed
         * @param onError is a callback called if an error occurs
         */
        runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void;
    }
    /**
     * Define a task used by AssetsManager to load cube textures
     */
    export class CubeTextureAssetTask extends AbstractAssetTask implements ITextureAssetTask<CubeTexture> {
        /**
         * Defines the name of the task
         */
        name: string;
        /**
         * Defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)
         */
        url: string;
        /**
         * Defines the extensions to use to load files (["_px", "_py", "_pz", "_nx", "_ny", "_nz"] by default)
         */
        extensions?: string[] | undefined;
        /**
         * Defines if mipmaps should not be generated (default is false)
         */
        noMipmap?: boolean | undefined;
        /**
         * Defines the explicit list of files (undefined by default)
         */
        files?: string[] | undefined;
        /**
         * Gets the loaded texture
         */
        texture: CubeTexture;
        /**
         * Callback called when the task is successful
         */
        onSuccess: (task: CubeTextureAssetTask) => void;
        /**
         * Callback called when the task is successful
         */
        onError: (task: CubeTextureAssetTask, message?: string, exception?: any) => void;
        /**
         * Creates a new CubeTextureAssetTask
         * @param name defines the name of the task
         * @param url defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)
         * @param extensions defines the extensions to use to load files (["_px", "_py", "_pz", "_nx", "_ny", "_nz"] by default)
         * @param noMipmap defines if mipmaps should not be generated (default is false)
         * @param files defines the explicit list of files (undefined by default)
         */
        constructor(
        /**
         * Defines the name of the task
         */
        name: string, 
        /**
         * Defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)
         */
        url: string, 
        /**
         * Defines the extensions to use to load files (["_px", "_py", "_pz", "_nx", "_ny", "_nz"] by default)
         */
        extensions?: string[] | undefined, 
        /**
         * Defines if mipmaps should not be generated (default is false)
         */
        noMipmap?: boolean | undefined, 
        /**
         * Defines the explicit list of files (undefined by default)
         */
        files?: string[] | undefined);
        /**
         * Execute the current task
         * @param scene defines the scene where you want your assets to be loaded
         * @param onSuccess is a callback called when the task is successfully executed
         * @param onError is a callback called if an error occurs
         */
        runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void;
    }
    /**
     * Define a task used by AssetsManager to load HDR cube textures
     */
    export class HDRCubeTextureAssetTask extends AbstractAssetTask implements ITextureAssetTask<HDRCubeTexture> {
        /**
         * Defines the name of the task
         */
        name: string;
        /**
         * Defines the location of the file to load
         */
        url: string;
        /**
         * Defines the desired size (the more it increases the longer the generation will be)
         */
        size: number;
        /**
         * Defines if mipmaps should not be generated (default is false)
         */
        noMipmap: boolean;
        /**
         * Specifies whether you want to extract the polynomial harmonics during the generation process (default is true)
         */
        generateHarmonics: boolean;
        /**
         * Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
         */
        gammaSpace: boolean;
        /**
         * Internal Use Only
         */
        reserved: boolean;
        /**
         * Gets the loaded texture
         */
        texture: HDRCubeTexture;
        /**
         * Callback called when the task is successful
         */
        onSuccess: (task: HDRCubeTextureAssetTask) => void;
        /**
         * Callback called when the task is successful
         */
        onError: (task: HDRCubeTextureAssetTask, message?: string, exception?: any) => void;
        /**
         * Creates a new HDRCubeTextureAssetTask object
         * @param name defines the name of the task
         * @param url defines the location of the file to load
         * @param size defines the desired size (the more it increases the longer the generation will be) If the size is omitted this implies you are using a preprocessed cubemap.
         * @param noMipmap defines if mipmaps should not be generated (default is false)
         * @param generateHarmonics specifies whether you want to extract the polynomial harmonics during the generation process (default is true)
         * @param gammaSpace specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
         * @param reserved Internal use only
         */
        constructor(
        /**
         * Defines the name of the task
         */
        name: string, 
        /**
         * Defines the location of the file to load
         */
        url: string, 
        /**
         * Defines the desired size (the more it increases the longer the generation will be)
         */
        size: number, 
        /**
         * Defines if mipmaps should not be generated (default is false)
         */
        noMipmap?: boolean, 
        /**
         * Specifies whether you want to extract the polynomial harmonics during the generation process (default is true)
         */
        generateHarmonics?: boolean, 
        /**
         * Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
         */
        gammaSpace?: boolean, 
        /**
         * Internal Use Only
         */
        reserved?: boolean);
        /**
         * Execute the current task
         * @param scene defines the scene where you want your assets to be loaded
         * @param onSuccess is a callback called when the task is successfully executed
         * @param onError is a callback called if an error occurs
         */
        runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void;
    }
    /**
     * Define a task used by AssetsManager to load Equirectangular cube textures
     */
    export class EquiRectangularCubeTextureAssetTask extends AbstractAssetTask implements ITextureAssetTask<EquiRectangularCubeTexture> {
        /**
         * Defines the name of the task
         */
        name: string;
        /**
         * Defines the location of the file to load
         */
        url: string;
        /**
         * Defines the desired size (the more it increases the longer the generation will be)
         */
        size: number;
        /**
         * Defines if mipmaps should not be generated (default is false)
         */
        noMipmap: boolean;
        /**
         * Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space,
         * but the standard material would require them in Gamma space) (default is true)
         */
        gammaSpace: boolean;
        /**
         * Gets the loaded texture
         */
        texture: EquiRectangularCubeTexture;
        /**
         * Callback called when the task is successful
         */
        onSuccess: (task: EquiRectangularCubeTextureAssetTask) => void;
        /**
         * Callback called when the task is successful
         */
        onError: (task: EquiRectangularCubeTextureAssetTask, message?: string, exception?: any) => void;
        /**
         * Creates a new EquiRectangularCubeTextureAssetTask object
         * @param name defines the name of the task
         * @param url defines the location of the file to load
         * @param size defines the desired size (the more it increases the longer the generation will be)
         * If the size is omitted this implies you are using a preprocessed cubemap.
         * @param noMipmap defines if mipmaps should not be generated (default is false)
         * @param gammaSpace specifies if the texture will be used in gamma or linear space
         * (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space)
         * (default is true)
         */
        constructor(
        /**
         * Defines the name of the task
         */
        name: string, 
        /**
         * Defines the location of the file to load
         */
        url: string, 
        /**
         * Defines the desired size (the more it increases the longer the generation will be)
         */
        size: number, 
        /**
         * Defines if mipmaps should not be generated (default is false)
         */
        noMipmap?: boolean, 
        /**
         * Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space,
         * but the standard material would require them in Gamma space) (default is true)
         */
        gammaSpace?: boolean);
        /**
         * Execute the current task
         * @param scene defines the scene where you want your assets to be loaded
         * @param onSuccess is a callback called when the task is successfully executed
         * @param onError is a callback called if an error occurs
         */
        runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void;
    }
    /**
     * This class can be used to easily import assets into a scene
     * @see https://doc.babylonjs.com/how_to/how_to_use_assetsmanager
     */
    export class AssetsManager {
        private _scene;
        private _isLoading;
        protected _tasks: AbstractAssetTask[];
        protected _waitingTasksCount: number;
        protected _totalTasksCount: number;
        /**
         * Callback called when all tasks are processed
         */
        onFinish: (tasks: AbstractAssetTask[]) => void;
        /**
         * Callback called when a task is successful
         */
        onTaskSuccess: (task: AbstractAssetTask) => void;
        /**
         * Callback called when a task had an error
         */
        onTaskError: (task: AbstractAssetTask) => void;
        /**
         * Callback called when a task is done (whatever the result is)
         */
        onProgress: (remainingCount: number, totalCount: number, task: AbstractAssetTask) => void;
        /**
         * Observable called when all tasks are processed
         */
        onTaskSuccessObservable: Observable<AbstractAssetTask>;
        /**
         * Observable called when a task had an error
         */
        onTaskErrorObservable: Observable<AbstractAssetTask>;
        /**
         * Observable called when all tasks were executed
         */
        onTasksDoneObservable: Observable<AbstractAssetTask[]>;
        /**
         * Observable called when a task is done (whatever the result is)
         */
        onProgressObservable: Observable<IAssetsProgressEvent>;
        /**
         * Gets or sets a boolean defining if the AssetsManager should use the default loading screen
         * @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
         */
        useDefaultLoadingScreen: boolean;
        /**
         * Gets or sets a boolean defining if the AssetsManager should automatically hide the loading screen
         * when all assets have been downloaded.
         * If set to false, you need to manually call in hideLoadingUI() once your scene is ready.
         */
        autoHideLoadingUI: boolean;
        /**
         * Creates a new AssetsManager
         * @param scene defines the scene to work on
         */
        constructor(scene: Scene);
        /**
         * Add a ContainerAssetTask to the list of active tasks
         * @param taskName defines the name of the new task
         * @param meshesNames defines the name of meshes to load
         * @param rootUrl defines the root url to use to locate files
         * @param sceneFilename defines the filename of the scene file
         * @returns a new ContainerAssetTask object
         */
        addContainerTask(taskName: string, meshesNames: any, rootUrl: string, sceneFilename: string): ContainerAssetTask;
        /**
         * Add a MeshAssetTask to the list of active tasks
         * @param taskName defines the name of the new task
         * @param meshesNames defines the name of meshes to load
         * @param rootUrl defines the root url to use to locate files
         * @param sceneFilename defines the filename of the scene file
         * @returns a new MeshAssetTask object
         */
        addMeshTask(taskName: string, meshesNames: any, rootUrl: string, sceneFilename: string): MeshAssetTask;
        /**
         * Add a TextFileAssetTask to the list of active tasks
         * @param taskName defines the name of the new task
         * @param url defines the url of the file to load
         * @returns a new TextFileAssetTask object
         */
        addTextFileTask(taskName: string, url: string): TextFileAssetTask;
        /**
         * Add a BinaryFileAssetTask to the list of active tasks
         * @param taskName defines the name of the new task
         * @param url defines the url of the file to load
         * @returns a new BinaryFileAssetTask object
         */
        addBinaryFileTask(taskName: string, url: string): BinaryFileAssetTask;
        /**
         * Add a ImageAssetTask to the list of active tasks
         * @param taskName defines the name of the new task
         * @param url defines the url of the file to load
         * @returns a new ImageAssetTask object
         */
        addImageTask(taskName: string, url: string): ImageAssetTask;
        /**
         * Add a TextureAssetTask to the list of active tasks
         * @param taskName defines the name of the new task
         * @param url defines the url of the file to load
         * @param noMipmap defines if the texture must not receive mipmaps (false by default)
         * @param invertY defines if you want to invert Y axis of the loaded texture (false by default)
         * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)
         * @returns a new TextureAssetTask object
         */
        addTextureTask(taskName: string, url: string, noMipmap?: boolean, invertY?: boolean, samplingMode?: number): TextureAssetTask;
        /**
         * Add a CubeTextureAssetTask to the list of active tasks
         * @param taskName defines the name of the new task
         * @param url defines the url of the file to load
         * @param extensions defines the extension to use to load the cube map (can be null)
         * @param noMipmap defines if the texture must not receive mipmaps (false by default)
         * @param files defines the list of files to load (can be null)
         * @returns a new CubeTextureAssetTask object
         */
        addCubeTextureTask(taskName: string, url: string, extensions?: string[], noMipmap?: boolean, files?: string[]): CubeTextureAssetTask;
        /**
         *
         * Add a HDRCubeTextureAssetTask to the list of active tasks
         * @param taskName defines the name of the new task
         * @param url defines the url of the file to load
         * @param size defines the size you want for the cubemap (can be null)
         * @param noMipmap defines if the texture must not receive mipmaps (false by default)
         * @param generateHarmonics defines if you want to automatically generate (true by default)
         * @param gammaSpace specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
         * @param reserved Internal use only
         * @returns a new HDRCubeTextureAssetTask object
         */
        addHDRCubeTextureTask(taskName: string, url: string, size: number, noMipmap?: boolean, generateHarmonics?: boolean, gammaSpace?: boolean, reserved?: boolean): HDRCubeTextureAssetTask;
        /**
         *
         * Add a EquiRectangularCubeTextureAssetTask to the list of active tasks
         * @param taskName defines the name of the new task
         * @param url defines the url of the file to load
         * @param size defines the size you want for the cubemap (can be null)
         * @param noMipmap defines if the texture must not receive mipmaps (false by default)
         * @param gammaSpace Specifies if the texture will be used in gamma or linear space
         * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)
         * @returns a new EquiRectangularCubeTextureAssetTask object
         */
        addEquiRectangularCubeTextureAssetTask(taskName: string, url: string, size: number, noMipmap?: boolean, gammaSpace?: boolean): EquiRectangularCubeTextureAssetTask;
        /**
         * Remove a task from the assets manager.
         * @param task the task to remove
         */
        removeTask(task: AbstractAssetTask): void;
        private _decreaseWaitingTasksCount;
        private _runTask;
        /**
         * Reset the AssetsManager and remove all tasks
         * @return the current instance of the AssetsManager
         */
        reset(): AssetsManager;
        /**
         * Start the loading process
         * @return the current instance of the AssetsManager
         */
        load(): AssetsManager;
        /**
         * Start the loading process as an async operation
         * @return a promise returning the list of failed tasks
         */
        loadAsync(): Promise<void>;
    }
}
declare module BABYLON {
    /**
     * Wrapper class for promise with external resolve and reject.
     */
    export class Deferred<T> {
        /**
         * The promise associated with this deferred object.
         */
        readonly promise: Promise<T>;
        private _resolve;
        private _reject;
        /**
         * The resolve method of the promise associated with this deferred object.
         */
        get resolve(): (value?: T | PromiseLike<T> | undefined) => void;
        /**
         * The reject method of the promise associated with this deferred object.
         */
        get reject(): (reason?: any) => void;
        /**
         * Constructor for this deferred object.
         */
        constructor();
    }
}
declare module BABYLON {
    /**
     * Class used to explode meshes (ie. to have a center and move them away from that center to better see the overall organization)
     */
    export class MeshExploder {
        private _centerMesh;
        private _meshes;
        private _meshesOrigins;
        private _toCenterVectors;
        private _scaledDirection;
        private _newPosition;
        private _centerPosition;
        /**
         * Explodes meshes from a center mesh.
         * @param meshes The meshes to explode.
         * @param centerMesh The mesh to be center of explosion.
         */
        constructor(meshes: Array<Mesh>, centerMesh?: Mesh);
        private _setCenterMesh;
        /**
         * Get class name
         * @returns "MeshExploder"
         */
        getClassName(): string;
        /**
         * "Exploded meshes"
         * @returns Array of meshes with the centerMesh at index 0.
         */
        getMeshes(): Array<Mesh>;
        /**
         * Explodes meshes giving a specific direction
         * @param direction Number to multiply distance of each mesh's origin from center. Use a negative number to implode, or zero to reset.
         */
        explode(direction?: number): void;
    }
}
declare module BABYLON {
    /**
     * Class used to help managing file picking and drag'n'drop
     */
    export class FilesInput {
        /**
         * List of files ready to be loaded
         */
        static get FilesToLoad(): {
            [key: string]: File;
        };
        /**
         * Callback called when a file is processed
         */
        onProcessFileCallback: (file: File, name: string, extension: string) => boolean;
        private _engine;
        private _currentScene;
        private _sceneLoadedCallback;
        private _progressCallback;
        private _additionalRenderLoopLogicCallback;
        private _textureLoadingCallback;
        private _startingProcessingFilesCallback;
        private _onReloadCallback;
        private _errorCallback;
        private _elementToMonitor;
        private _sceneFileToLoad;
        private _filesToLoad;
        /**
         * Creates a new FilesInput
         * @param engine defines the rendering engine
         * @param scene defines the hosting scene
         * @param sceneLoadedCallback callback called when scene is loaded
         * @param progressCallback callback called to track progress
         * @param additionalRenderLoopLogicCallback callback called to add user logic to the rendering loop
         * @param textureLoadingCallback callback called when a texture is loading
         * @param startingProcessingFilesCallback callback called when the system is about to process all files
         * @param onReloadCallback callback called when a reload is requested
         * @param errorCallback callback call if an error occurs
         */
        constructor(engine: Engine, scene: Nullable<Scene>, sceneLoadedCallback: Nullable<(sceneFile: File, scene: Scene) => void>, progressCallback: Nullable<(progress: ISceneLoaderProgressEvent) => void>, additionalRenderLoopLogicCallback: Nullable<() => void>, textureLoadingCallback: Nullable<(remaining: number) => void>, startingProcessingFilesCallback: Nullable<(files?: File[]) => void>, onReloadCallback: Nullable<(sceneFile: File) => void>, errorCallback: Nullable<(sceneFile: File, scene: Nullable<Scene>, message: string) => void>);
        private _dragEnterHandler;
        private _dragOverHandler;
        private _dropHandler;
        /**
         * Calls this function to listen to drag'n'drop events on a specific DOM element
         * @param elementToMonitor defines the DOM element to track
         */
        monitorElementForDragNDrop(elementToMonitor: HTMLElement): void;
        /** Gets the current list of files to load */
        get filesToLoad(): File[];
        /**
         * Release all associated resources
         */
        dispose(): void;
        private renderFunction;
        private drag;
        private drop;
        private _traverseFolder;
        private _processFiles;
        /**
         * Load files from a drop event
         * @param event defines the drop event to use as source
         */
        loadFiles(event: any): void;
        private _processReload;
        /**
         * Reload the current scene from the loaded files
         */
        reload(): void;
    }
}
declare module BABYLON {
    /**
     * Defines the root class used to create scene optimization to use with SceneOptimizer
     * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    export class SceneOptimization {
        /**
         * Defines the priority of this optimization (0 by default which means first in the list)
         */
        priority: number;
        /**
         * Gets a string describing the action executed by the current optimization
         * @returns description string
         */
        getDescription(): string;
        /**
         * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
         * @param scene defines the current scene where to apply this optimization
         * @param optimizer defines the current optimizer
         * @returns true if everything that can be done was applied
         */
        apply(scene: Scene, optimizer: SceneOptimizer): boolean;
        /**
         * Creates the SceneOptimization object
         * @param priority defines the priority of this optimization (0 by default which means first in the list)
         * @param desc defines the description associated with the optimization
         */
        constructor(
        /**
         * Defines the priority of this optimization (0 by default which means first in the list)
         */
        priority?: number);
    }
    /**
     * Defines an optimization used to reduce the size of render target textures
     * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    export class TextureOptimization extends SceneOptimization {
        /**
         * Defines the priority of this optimization (0 by default which means first in the list)
         */
        priority: number;
        /**
         * Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter
         */
        maximumSize: number;
        /**
         * Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.
         */
        step: number;
        /**
         * Gets a string describing the action executed by the current optimization
         * @returns description string
         */
        getDescription(): string;
        /**
         * Creates the TextureOptimization object
         * @param priority defines the priority of this optimization (0 by default which means first in the list)
         * @param maximumSize defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter
         * @param step defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.
         */
        constructor(
        /**
         * Defines the priority of this optimization (0 by default which means first in the list)
         */
        priority?: number, 
        /**
         * Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter
         */
        maximumSize?: number, 
        /**
         * Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.
         */
        step?: number);
        /**
         * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
         * @param scene defines the current scene where to apply this optimization
         * @param optimizer defines the current optimizer
         * @returns true if everything that can be done was applied
         */
        apply(scene: Scene, optimizer: SceneOptimizer): boolean;
    }
    /**
     * Defines an optimization used to increase or decrease the rendering resolution
     * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    export class HardwareScalingOptimization extends SceneOptimization {
        /**
         * Defines the priority of this optimization (0 by default which means first in the list)
         */
        priority: number;
        /**
         * Defines the maximum scale to use (2 by default)
         */
        maximumScale: number;
        /**
         * Defines the step to use between two passes (0.5 by default)
         */
        step: number;
        private _currentScale;
        private _directionOffset;
        /**
         * Gets a string describing the action executed by the current optimization
         * @return description string
         */
        getDescription(): string;
        /**
         * Creates the HardwareScalingOptimization object
         * @param priority defines the priority of this optimization (0 by default which means first in the list)
         * @param maximumScale defines the maximum scale to use (2 by default)
         * @param step defines the step to use between two passes (0.5 by default)
         */
        constructor(
        /**
         * Defines the priority of this optimization (0 by default which means first in the list)
         */
        priority?: number, 
        /**
         * Defines the maximum scale to use (2 by default)
         */
        maximumScale?: number, 
        /**
         * Defines the step to use between two passes (0.5 by default)
         */
        step?: number);
        /**
         * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
         * @param scene defines the current scene where to apply this optimization
         * @param optimizer defines the current optimizer
         * @returns true if everything that can be done was applied
         */
        apply(scene: Scene, optimizer: SceneOptimizer): boolean;
    }
    /**
     * Defines an optimization used to remove shadows
     * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    export class ShadowsOptimization extends SceneOptimization {
        /**
         * Gets a string describing the action executed by the current optimization
         * @return description string
         */
        getDescription(): string;
        /**
         * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
         * @param scene defines the current scene where to apply this optimization
         * @param optimizer defines the current optimizer
         * @returns true if everything that can be done was applied
         */
        apply(scene: Scene, optimizer: SceneOptimizer): boolean;
    }
    /**
     * Defines an optimization used to turn post-processes off
     * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    export class PostProcessesOptimization extends SceneOptimization {
        /**
         * Gets a string describing the action executed by the current optimization
         * @return description string
         */
        getDescription(): string;
        /**
         * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
         * @param scene defines the current scene where to apply this optimization
         * @param optimizer defines the current optimizer
         * @returns true if everything that can be done was applied
         */
        apply(scene: Scene, optimizer: SceneOptimizer): boolean;
    }
    /**
     * Defines an optimization used to turn lens flares off
     * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    export class LensFlaresOptimization extends SceneOptimization {
        /**
         * Gets a string describing the action executed by the current optimization
         * @return description string
         */
        getDescription(): string;
        /**
         * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
         * @param scene defines the current scene where to apply this optimization
         * @param optimizer defines the current optimizer
         * @returns true if everything that can be done was applied
         */
        apply(scene: Scene, optimizer: SceneOptimizer): boolean;
    }
    /**
     * Defines an optimization based on user defined callback.
     * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    export class CustomOptimization extends SceneOptimization {
        /**
         * Callback called to apply the custom optimization.
         */
        onApply: (scene: Scene, optimizer: SceneOptimizer) => boolean;
        /**
         * Callback called to get custom description
         */
        onGetDescription: () => string;
        /**
         * Gets a string describing the action executed by the current optimization
         * @returns description string
         */
        getDescription(): string;
        /**
         * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
         * @param scene defines the current scene where to apply this optimization
         * @param optimizer defines the current optimizer
         * @returns true if everything that can be done was applied
         */
        apply(scene: Scene, optimizer: SceneOptimizer): boolean;
    }
    /**
     * Defines an optimization used to turn particles off
     * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    export class ParticlesOptimization extends SceneOptimization {
        /**
         * Gets a string describing the action executed by the current optimization
         * @return description string
         */
        getDescription(): string;
        /**
         * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
         * @param scene defines the current scene where to apply this optimization
         * @param optimizer defines the current optimizer
         * @returns true if everything that can be done was applied
         */
        apply(scene: Scene, optimizer: SceneOptimizer): boolean;
    }
    /**
     * Defines an optimization used to turn render targets off
     * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    export class RenderTargetsOptimization extends SceneOptimization {
        /**
         * Gets a string describing the action executed by the current optimization
         * @return description string
         */
        getDescription(): string;
        /**
         * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
         * @param scene defines the current scene where to apply this optimization
         * @param optimizer defines the current optimizer
         * @returns true if everything that can be done was applied
         */
        apply(scene: Scene, optimizer: SceneOptimizer): boolean;
    }
    /**
     * Defines an optimization used to merge meshes with compatible materials
     * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    export class MergeMeshesOptimization extends SceneOptimization {
        private static _UpdateSelectionTree;
        /**
         * Gets or sets a boolean which defines if optimization octree has to be updated
         */
        static get UpdateSelectionTree(): boolean;
        /**
         * Gets or sets a boolean which defines if optimization octree has to be updated
         */
        static set UpdateSelectionTree(value: boolean);
        /**
         * Gets a string describing the action executed by the current optimization
         * @return description string
         */
        getDescription(): string;
        private _canBeMerged;
        /**
         * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
         * @param scene defines the current scene where to apply this optimization
         * @param optimizer defines the current optimizer
         * @param updateSelectionTree defines that the selection octree has to be updated (false by default)
         * @returns true if everything that can be done was applied
         */
        apply(scene: Scene, optimizer: SceneOptimizer, updateSelectionTree?: boolean): boolean;
    }
    /**
     * Defines a list of options used by SceneOptimizer
     * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    export class SceneOptimizerOptions {
        /**
         * Defines the target frame rate to reach (60 by default)
         */
        targetFrameRate: number;
        /**
         * Defines the interval between two checkes (2000ms by default)
         */
        trackerDuration: number;
        /**
         * Gets the list of optimizations to apply
         */
        optimizations: SceneOptimization[];
        /**
         * Creates a new list of options used by SceneOptimizer
         * @param targetFrameRate defines the target frame rate to reach (60 by default)
         * @param trackerDuration defines the interval between two checkes (2000ms by default)
         */
        constructor(
        /**
         * Defines the target frame rate to reach (60 by default)
         */
        targetFrameRate?: number, 
        /**
         * Defines the interval between two checkes (2000ms by default)
         */
        trackerDuration?: number);
        /**
         * Add a new optimization
         * @param optimization defines the SceneOptimization to add to the list of active optimizations
         * @returns the current SceneOptimizerOptions
         */
        addOptimization(optimization: SceneOptimization): SceneOptimizerOptions;
        /**
         * Add a new custom optimization
         * @param onApply defines the callback called to apply the custom optimization (true if everything that can be done was applied)
         * @param onGetDescription defines the callback called to get the description attached with the optimization.
         * @param priority defines the priority of this optimization (0 by default which means first in the list)
         * @returns the current SceneOptimizerOptions
         */
        addCustomOptimization(onApply: (scene: Scene) => boolean, onGetDescription: () => string, priority?: number): SceneOptimizerOptions;
        /**
         * Creates a list of pre-defined optimizations aimed to reduce the visual impact on the scene
         * @param targetFrameRate defines the target frame rate (60 by default)
         * @returns a SceneOptimizerOptions object
         */
        static LowDegradationAllowed(targetFrameRate?: number): SceneOptimizerOptions;
        /**
         * Creates a list of pre-defined optimizations aimed to have a moderate impact on the scene visual
         * @param targetFrameRate defines the target frame rate (60 by default)
         * @returns a SceneOptimizerOptions object
         */
        static ModerateDegradationAllowed(targetFrameRate?: number): SceneOptimizerOptions;
        /**
         * Creates a list of pre-defined optimizations aimed to have a big impact on the scene visual
         * @param targetFrameRate defines the target frame rate (60 by default)
         * @returns a SceneOptimizerOptions object
         */
        static HighDegradationAllowed(targetFrameRate?: number): SceneOptimizerOptions;
    }
    /**
     * Class used to run optimizations in order to reach a target frame rate
     * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    export class SceneOptimizer implements IDisposable {
        private _isRunning;
        private _options;
        private _scene;
        private _currentPriorityLevel;
        private _targetFrameRate;
        private _trackerDuration;
        private _currentFrameRate;
        private _sceneDisposeObserver;
        private _improvementMode;
        /**
         * Defines an observable called when the optimizer reaches the target frame rate
         */
        onSuccessObservable: Observable<SceneOptimizer>;
        /**
         * Defines an observable called when the optimizer enables an optimization
         */
        onNewOptimizationAppliedObservable: Observable<SceneOptimization>;
        /**
         * Defines an observable called when the optimizer is not able to reach the target frame rate
         */
        onFailureObservable: Observable<SceneOptimizer>;
        /**
         * Gets a boolean indicating if the optimizer is in improvement mode
         */
        get isInImprovementMode(): boolean;
        /**
         * Gets the current priority level (0 at start)
         */
        get currentPriorityLevel(): number;
        /**
         * Gets the current frame rate checked by the SceneOptimizer
         */
        get currentFrameRate(): number;
        /**
         * Gets or sets the current target frame rate (60 by default)
         */
        get targetFrameRate(): number;
        /**
         * Gets or sets the current target frame rate (60 by default)
         */
        set targetFrameRate(value: number);
        /**
         * Gets or sets the current interval between two checks (every 2000ms by default)
         */
        get trackerDuration(): number;
        /**
         * Gets or sets the current interval between two checks (every 2000ms by default)
         */
        set trackerDuration(value: number);
        /**
         * Gets the list of active optimizations
         */
        get optimizations(): SceneOptimization[];
        /**
         * Creates a new SceneOptimizer
         * @param scene defines the scene to work on
         * @param options defines the options to use with the SceneOptimizer
         * @param autoGeneratePriorities defines if priorities must be generated and not read from SceneOptimization property (true by default)
         * @param improvementMode defines if the scene optimizer must run the maximum optimization while staying over a target frame instead of trying to reach the target framerate (false by default)
         */
        constructor(scene: Scene, options?: SceneOptimizerOptions, autoGeneratePriorities?: boolean, improvementMode?: boolean);
        /**
         * Stops the current optimizer
         */
        stop(): void;
        /**
         * Reset the optimizer to initial step (current priority level = 0)
         */
        reset(): void;
        /**
         * Start the optimizer. By default it will try to reach a specific framerate
         * but if the optimizer is set with improvementMode === true then it will run all optimiatiation while frame rate is above the target frame rate
         */
        start(): void;
        private _checkCurrentState;
        /**
         * Release all resources
         */
        dispose(): void;
        /**
         * Helper function to create a SceneOptimizer with one single line of code
         * @param scene defines the scene to work on
         * @param options defines the options to use with the SceneOptimizer
         * @param onSuccess defines a callback to call on success
         * @param onFailure defines a callback to call on failure
         * @returns the new SceneOptimizer object
         */
        static OptimizeAsync(scene: Scene, options?: SceneOptimizerOptions, onSuccess?: () => void, onFailure?: () => void): SceneOptimizer;
    }
}
declare module BABYLON {
    /**
     * Class used to serialize a scene into a string
     */
    export class SceneSerializer {
        /**
         * Clear cache used by a previous serialization
         */
        static ClearCache(): void;
        /**
         * Serialize a scene into a JSON compatible object
         * @param scene defines the scene to serialize
         * @returns a JSON compatible object
         */
        static Serialize(scene: Scene): any;
        /**
         * Serialize a mesh into a JSON compatible object
         * @param toSerialize defines the mesh to serialize
         * @param withParents defines if parents must be serialized as well
         * @param withChildren defines if children must be serialized as well
         * @returns a JSON compatible object
         */
        static SerializeMesh(toSerialize: any, withParents?: boolean, withChildren?: boolean): any;
    }
}
declare module BABYLON {
    /**
     * Class used to host texture specific utilities
     */
    export class TextureTools {
        /**
         * Uses the GPU to create a copy texture rescaled at a given size
         * @param texture Texture to copy from
         * @param width defines the desired width
         * @param height defines the desired height
         * @param useBilinearMode defines if bilinear mode has to be used
         * @return the generated texture
         */
        static CreateResizedCopy(texture: Texture, width: number, height: number, useBilinearMode?: boolean): Texture;
    }
}
declare module BABYLON {
    /**
     * This represents the different options available for the video capture.
     */
    export interface VideoRecorderOptions {
        /** Defines the mime type of the video. */
        mimeType: string;
        /** Defines the FPS the video should be recorded at. */
        fps: number;
        /** Defines the chunk size for the recording data. */
        recordChunckSize: number;
        /** The audio tracks to attach to the recording. */
        audioTracks?: MediaStreamTrack[];
    }
    /**
     * This can help with recording videos from BabylonJS.
     * This is based on the available WebRTC functionalities of the browser.
     *
     * @see https://doc.babylonjs.com/how_to/render_scene_on_a_video
     */
    export class VideoRecorder {
        private static readonly _defaultOptions;
        /**
         * Returns whether or not the VideoRecorder is available in your browser.
         * @param engine Defines the Babylon Engine.
         * @returns true if supported otherwise false.
         */
        static IsSupported(engine: Engine): boolean;
        private readonly _options;
        private _canvas;
        private _mediaRecorder;
        private _recordedChunks;
        private _fileName;
        private _resolve;
        private _reject;
        /**
         * True when a recording is already in progress.
         */
        get isRecording(): boolean;
        /**
         * Create a new VideoCapture object which can help converting what you see in Babylon to a video file.
         * @param engine Defines the BabylonJS Engine you wish to record.
         * @param options Defines options that can be used to customize the capture.
         */
        constructor(engine: Engine, options?: Nullable<VideoRecorderOptions>);
        /**
         * Stops the current recording before the default capture timeout passed in the startRecording function.
         */
        stopRecording(): void;
        /**
         * Starts recording the canvas for a max duration specified in parameters.
         * @param fileName Defines the name of the file to be downloaded when the recording stop.
         * If null no automatic download will start and you can rely on the promise to get the data back.
         * @param maxDuration Defines the maximum recording time in seconds.
         * It defaults to 7 seconds. A value of zero will not stop automatically, you would need to call stopRecording manually.
         * @return A promise callback at the end of the recording with the video data in Blob.
         */
        startRecording(fileName?: Nullable<string>, maxDuration?: number): Promise<Blob>;
        /**
         * Releases internal resources used during the recording.
         */
        dispose(): void;
        private _handleDataAvailable;
        private _handleError;
        private _handleStop;
    }
}
declare module BABYLON {
    /**
     * Class containing a set of static utilities functions for screenshots
     */
    export class ScreenshotTools {
        /**
         * Captures a screenshot of the current rendering
         * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png
         * @param engine defines the rendering engine
         * @param camera defines the source camera
         * @param size This parameter can be set to a single number or to an object with the
         * following (optional) properties: precision, width, height. If a single number is passed,
         * it will be used for both width and height. If an object is passed, the screenshot size
         * will be derived from the parameters. The precision property is a multiplier allowing
         * rendering at a higher or lower resolution
         * @param successCallback defines the callback receives a single parameter which contains the
         * screenshot as a string of base64-encoded characters. This string can be assigned to the
         * src parameter of an <img> to display it
         * @param mimeType defines the MIME type of the screenshot image (default: image/png).
         * Check your browser for supported MIME types
         */
        static CreateScreenshot(engine: Engine, camera: Camera, size: IScreenshotSize | number, successCallback?: (data: string) => void, mimeType?: string): void;
        /**
         * Captures a screenshot of the current rendering
         * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png
         * @param engine defines the rendering engine
         * @param camera defines the source camera
         * @param size This parameter can be set to a single number or to an object with the
         * following (optional) properties: precision, width, height. If a single number is passed,
         * it will be used for both width and height. If an object is passed, the screenshot size
         * will be derived from the parameters. The precision property is a multiplier allowing
         * rendering at a higher or lower resolution
         * @param mimeType defines the MIME type of the screenshot image (default: image/png).
         * Check your browser for supported MIME types
         * @returns screenshot as a string of base64-encoded characters. This string can be assigned
         * to the src parameter of an <img> to display it
         */
        static CreateScreenshotAsync(engine: Engine, camera: Camera, size: any, mimeType?: string): Promise<string>;
        /**
         * Generates an image screenshot from the specified camera.
         * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png
         * @param engine The engine to use for rendering
         * @param camera The camera to use for rendering
         * @param size This parameter can be set to a single number or to an object with the
         * following (optional) properties: precision, width, height. If a single number is passed,
         * it will be used for both width and height. If an object is passed, the screenshot size
         * will be derived from the parameters. The precision property is a multiplier allowing
         * rendering at a higher or lower resolution
         * @param successCallback The callback receives a single parameter which contains the
         * screenshot as a string of base64-encoded characters. This string can be assigned to the
         * src parameter of an <img> to display it
         * @param mimeType The MIME type of the screenshot image (default: image/png).
         * Check your browser for supported MIME types
         * @param samples Texture samples (default: 1)
         * @param antialiasing Whether antialiasing should be turned on or not (default: false)
         * @param fileName A name for for the downloaded file.
         * @param renderSprites Whether the sprites should be rendered or not (default: false)
         * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)
         */
        static CreateScreenshotUsingRenderTarget(engine: Engine, camera: Camera, size: IScreenshotSize | number, successCallback?: (data: string) => void, mimeType?: string, samples?: number, antialiasing?: boolean, fileName?: string, renderSprites?: boolean, enableStencilBuffer?: boolean): void;
        /**
         * Generates an image screenshot from the specified camera.
         * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png
         * @param engine The engine to use for rendering
         * @param camera The camera to use for rendering
         * @param size This parameter can be set to a single number or to an object with the
         * following (optional) properties: precision, width, height. If a single number is passed,
         * it will be used for both width and height. If an object is passed, the screenshot size
         * will be derived from the parameters. The precision property is a multiplier allowing
         * rendering at a higher or lower resolution
         * @param mimeType The MIME type of the screenshot image (default: image/png).
         * Check your browser for supported MIME types
         * @param samples Texture samples (default: 1)
         * @param antialiasing Whether antialiasing should be turned on or not (default: false)
         * @param fileName A name for for the downloaded file.
         * @param renderSprites Whether the sprites should be rendered or not (default: false)
         * @returns screenshot as a string of base64-encoded characters. This string can be assigned
         * to the src parameter of an <img> to display it
         */
        static CreateScreenshotUsingRenderTargetAsync(engine: Engine, camera: Camera, size: any, mimeType?: string, samples?: number, antialiasing?: boolean, fileName?: string, renderSprites?: boolean): Promise<string>;
        /**
         * Gets height and width for screenshot size
         * @private
         */
        private static _getScreenshotSize;
    }
}
declare module BABYLON {
    /**
     * Interface for a data buffer
     */
    export interface IDataBuffer {
        /**
         * Reads bytes from the data buffer.
         * @param byteOffset The byte offset to read
         * @param byteLength The byte length to read
         * @returns A promise that resolves when the bytes are read
         */
        readAsync(byteOffset: number, byteLength: number): Promise<ArrayBufferView>;
        /**
         * The byte length of the buffer.
         */
        readonly byteLength: number;
    }
    /**
     * Utility class for reading from a data buffer
     */
    export class DataReader {
        /**
         * The data buffer associated with this data reader.
         */
        readonly buffer: IDataBuffer;
        /**
         * The current byte offset from the beginning of the data buffer.
         */
        byteOffset: number;
        private _dataView;
        private _dataByteOffset;
        /**
         * Constructor
         * @param buffer The buffer to read
         */
        constructor(buffer: IDataBuffer);
        /**
         * Loads the given byte length.
         * @param byteLength The byte length to load
         * @returns A promise that resolves when the load is complete
         */
        loadAsync(byteLength: number): Promise<void>;
        /**
         * Read a unsigned 32-bit integer from the currently loaded data range.
         * @returns The 32-bit integer read
         */
        readUint32(): number;
        /**
         * Read a byte array from the currently loaded data range.
         * @param byteLength The byte length to read
         * @returns The byte array read
         */
        readUint8Array(byteLength: number): Uint8Array;
        /**
         * Read a string from the currently loaded data range.
         * @param byteLength The byte length to read
         * @returns The string read
         */
        readString(byteLength: number): string;
        /**
         * Skips the given byte length the currently loaded data range.
         * @param byteLength The byte length to skip
         */
        skipBytes(byteLength: number): void;
    }
}
declare module BABYLON {
    /**
     * Class for storing data to local storage if available or in-memory storage otherwise
     */
    export class DataStorage {
        private static _Storage;
        private static _GetStorage;
        /**
         * Reads a string from the data storage
         * @param key The key to read
         * @param defaultValue The value if the key doesn't exist
         * @returns The string value
         */
        static ReadString(key: string, defaultValue: string): string;
        /**
         * Writes a string to the data storage
         * @param key The key to write
         * @param value The value to write
         */
        static WriteString(key: string, value: string): void;
        /**
         * Reads a boolean from the data storage
         * @param key The key to read
         * @param defaultValue The value if the key doesn't exist
         * @returns The boolean value
         */
        static ReadBoolean(key: string, defaultValue: boolean): boolean;
        /**
         * Writes a boolean to the data storage
         * @param key The key to write
         * @param value The value to write
         */
        static WriteBoolean(key: string, value: boolean): void;
        /**
         * Reads a number from the data storage
         * @param key The key to read
         * @param defaultValue The value if the key doesn't exist
         * @returns The number value
         */
        static ReadNumber(key: string, defaultValue: number): number;
        /**
         * Writes a number to the data storage
         * @param key The key to write
         * @param value The value to write
         */
        static WriteNumber(key: string, value: number): void;
    }
}
declare module BABYLON {
    /**
     * Class used to record delta files between 2 scene states
     */
    export class SceneRecorder {
        private _trackedScene;
        private _savedJSON;
        /**
         * Track a given scene. This means the current scene state will be considered the original state
         * @param scene defines the scene to track
         */
        track(scene: Scene): void;
        /**
         * Get the delta between current state and original state
         * @returns a string containing the delta
         */
        getDelta(): any;
        private _compareArray;
        private _compareObjects;
        private _compareCollections;
        private static GetShadowGeneratorById;
        /**
         * Apply a given delta to a given scene
         * @param deltaJSON defines the JSON containing the delta
         * @param scene defines the scene to apply the delta to
         */
        static ApplyDelta(deltaJSON: any | string, scene: Scene): void;
        private static _ApplyPropertiesToEntity;
        private static _ApplyDeltaForEntity;
    }
}
declare module BABYLON {
    /**
     * An interface for all Hit test features
     */
    export interface IWebXRHitTestFeature<T extends IWebXRLegacyHitResult> extends IWebXRFeature {
        /**
         * Triggered when new babylon (transformed) hit test results are available
         */
        onHitTestResultObservable: Observable<T[]>;
    }
    /**
     * Options used for hit testing
     */
    export interface IWebXRLegacyHitTestOptions {
        /**
         * Only test when user interacted with the scene. Default - hit test every frame
         */
        testOnPointerDownOnly?: boolean;
        /**
         * The node to use to transform the local results to world coordinates
         */
        worldParentNode?: TransformNode;
    }
    /**
     * Interface defining the babylon result of raycasting/hit-test
     */
    export interface IWebXRLegacyHitResult {
        /**
         * Transformation matrix that can be applied to a node that will put it in the hit point location
         */
        transformationMatrix: Matrix;
        /**
         * The native hit test result
         */
        xrHitResult: XRHitResult | XRHitTestResult;
    }
    /**
     * The currently-working hit-test module.
     * Hit test (or Ray-casting) is used to interact with the real world.
     * For further information read here - https://github.com/immersive-web/hit-test
     */
    export class WebXRHitTestLegacy extends WebXRAbstractFeature implements IWebXRHitTestFeature<IWebXRLegacyHitResult> {
        /**
         * options to use when constructing this feature
         */
        readonly options: IWebXRLegacyHitTestOptions;
        private _direction;
        private _mat;
        private _onSelectEnabled;
        private _origin;
        /**
         * The module's name
         */
        static readonly Name: string;
        /**
         * The (Babylon) version of this module.
         * This is an integer representing the implementation version.
         * This number does not correspond to the WebXR specs version
         */
        static readonly Version: number;
        /**
         * Populated with the last native XR Hit Results
         */
        lastNativeXRHitResults: XRHitResult[];
        /**
         * Triggered when new babylon (transformed) hit test results are available
         */
        onHitTestResultObservable: Observable<IWebXRLegacyHitResult[]>;
        /**
         * Creates a new instance of the (legacy version) hit test feature
         * @param _xrSessionManager an instance of WebXRSessionManager
         * @param options options to use when constructing this feature
         */
        constructor(_xrSessionManager: WebXRSessionManager, 
        /**
         * options to use when constructing this feature
         */
        options?: IWebXRLegacyHitTestOptions);
        /**
         * execute a hit test with an XR Ray
         *
         * @param xrSession a native xrSession that will execute this hit test
         * @param xrRay the ray (position and direction) to use for ray-casting
         * @param referenceSpace native XR reference space to use for the hit-test
         * @param filter filter function that will filter the results
         * @returns a promise that resolves with an array of native XR hit result in xr coordinates system
         */
        static XRHitTestWithRay(xrSession: XRSession, xrRay: XRRay, referenceSpace: XRReferenceSpace, filter?: (result: XRHitResult) => boolean): Promise<XRHitResult[]>;
        /**
         * Execute a hit test on the current running session using a select event returned from a transient input (such as touch)
         * @param event the (select) event to use to select with
         * @param referenceSpace the reference space to use for this hit test
         * @returns a promise that resolves with an array of native XR hit result in xr coordinates system
         */
        static XRHitTestWithSelectEvent(event: XRInputSourceEvent, referenceSpace: XRReferenceSpace): Promise<XRHitResult[]>;
        /**
         * attach this feature
         * Will usually be called by the features manager
         *
         * @returns true if successful.
         */
        attach(): boolean;
        /**
         * detach this feature.
         * Will usually be called by the features manager
         *
         * @returns true if successful.
         */
        detach(): boolean;
        /**
         * Dispose this feature and all of the resources attached
         */
        dispose(): void;
        protected _onXRFrame(frame: XRFrame): void;
        private _onHitTestResults;
        private _onSelect;
    }
}
declare module BABYLON {
    /**
     * Options used for hit testing (version 2)
     */
    export interface IWebXRHitTestOptions extends IWebXRLegacyHitTestOptions {
        /**
         * Do not create a permanent hit test. Will usually be used when only
         * transient inputs are needed.
         */
        disablePermanentHitTest?: boolean;
        /**
         * Enable transient (for example touch-based) hit test inspections
         */
        enableTransientHitTest?: boolean;
        /**
         * Offset ray for the permanent hit test
         */
        offsetRay?: Vector3;
        /**
         * Offset ray for the transient hit test
         */
        transientOffsetRay?: Vector3;
        /**
         * Instead of using viewer space for hit tests, use the reference space defined in the session manager
         */
        useReferenceSpace?: boolean;
        /**
         * Override the default entity type(s) of the hit-test result
         */
        entityTypes?: XRHitTestTrackableType[];
    }
    /**
     * Interface defining the babylon result of hit-test
     */
    export interface IWebXRHitResult extends IWebXRLegacyHitResult {
        /**
         * The input source that generated this hit test (if transient)
         */
        inputSource?: XRInputSource;
        /**
         * Is this a transient hit test
         */
        isTransient?: boolean;
        /**
         * Position of the hit test result
         */
        position: Vector3;
        /**
         * Rotation of the hit test result
         */
        rotationQuaternion: Quaternion;
        /**
         * The native hit test result
         */
        xrHitResult: XRHitTestResult;
    }
    /**
     * The currently-working hit-test module.
     * Hit test (or Ray-casting) is used to interact with the real world.
     * For further information read here - https://github.com/immersive-web/hit-test
     *
     * Tested on chrome (mobile) 80.
     */
    export class WebXRHitTest extends WebXRAbstractFeature implements IWebXRHitTestFeature<IWebXRHitResult> {
        /**
         * options to use when constructing this feature
         */
        readonly options: IWebXRHitTestOptions;
        private _tmpMat;
        private _tmpPos;
        private _tmpQuat;
        private _transientXrHitTestSource;
        private _xrHitTestSource;
        private initHitTestSource;
        /**
         * The module's name
         */
        static readonly Name: string;
        /**
         * The (Babylon) version of this module.
         * This is an integer representing the implementation version.
         * This number does not correspond to the WebXR specs version
         */
        static readonly Version: number;
        /**
         * When set to true, each hit test will have its own position/rotation objects
         * When set to false, position and rotation objects will be reused for each hit test. It is expected that
         * the developers will clone them or copy them as they see fit.
         */
        autoCloneTransformation: boolean;
        /**
         * Triggered when new babylon (transformed) hit test results are available
         * Note - this will be called when results come back from the device. It can be an empty array!!
         */
        onHitTestResultObservable: Observable<IWebXRHitResult[]>;
        /**
         * Use this to temporarily pause hit test checks.
         */
        paused: boolean;
        /**
         * Creates a new instance of the hit test feature
         * @param _xrSessionManager an instance of WebXRSessionManager
         * @param options options to use when constructing this feature
         */
        constructor(_xrSessionManager: WebXRSessionManager, 
        /**
         * options to use when constructing this feature
         */
        options?: IWebXRHitTestOptions);
        /**
         * attach this feature
         * Will usually be called by the features manager
         *
         * @returns true if successful.
         */
        attach(): boolean;
        /**
         * detach this feature.
         * Will usually be called by the features manager
         *
         * @returns true if successful.
         */
        detach(): boolean;
        /**
         * Dispose this feature and all of the resources attached
         */
        dispose(): void;
        protected _onXRFrame(frame: XRFrame): void;
        private _processWebXRHitTestResult;
    }
}
declare module BABYLON {
    /**
     * Configuration options of the anchor system
     */
    export interface IWebXRAnchorSystemOptions {
        /**
         * a node that will be used to convert local to world coordinates
         */
        worldParentNode?: TransformNode;
        /**
         * If set to true a reference of the created anchors will be kept until the next session starts
         * If not defined, anchors will be removed from the array when the feature is detached or the session ended.
         */
        doNotRemoveAnchorsOnSessionEnded?: boolean;
    }
    /**
     * A babylon container for an XR Anchor
     */
    export interface IWebXRAnchor {
        /**
         * A babylon-assigned ID for this anchor
         */
        id: number;
        /**
         * Transformation matrix to apply to an object attached to this anchor
         */
        transformationMatrix: Matrix;
        /**
         * The native anchor object
         */
        xrAnchor: XRAnchor;
        /**
         * if defined, this object will be constantly updated by the anchor's position and rotation
         */
        attachedNode?: TransformNode;
    }
    /**
     * An implementation of the anchor system for WebXR.
     * For further information see https://github.com/immersive-web/anchors/
     */
    export class WebXRAnchorSystem extends WebXRAbstractFeature {
        private _options;
        private _lastFrameDetected;
        private _trackedAnchors;
        private _referenceSpaceForFrameAnchors;
        private _futureAnchors;
        /**
         * The module's name
         */
        static readonly Name: string;
        /**
         * The (Babylon) version of this module.
         * This is an integer representing the implementation version.
         * This number does not correspond to the WebXR specs version
         */
        static readonly Version: number;
        /**
         * Observers registered here will be executed when a new anchor was added to the session
         */
        onAnchorAddedObservable: Observable<IWebXRAnchor>;
        /**
         * Observers registered here will be executed when an anchor was removed from the session
         */
        onAnchorRemovedObservable: Observable<IWebXRAnchor>;
        /**
         * Observers registered here will be executed when an existing anchor updates
         * This can execute N times every frame
         */
        onAnchorUpdatedObservable: Observable<IWebXRAnchor>;
        /**
         * Set the reference space to use for anchor creation, when not using a hit test.
         * Will default to the session's reference space if not defined
         */
        set referenceSpaceForFrameAnchors(referenceSpace: XRReferenceSpace);
        /**
         * constructs a new anchor system
         * @param _xrSessionManager an instance of WebXRSessionManager
         * @param _options configuration object for this feature
         */
        constructor(_xrSessionManager: WebXRSessionManager, _options?: IWebXRAnchorSystemOptions);
        private _tmpVector;
        private _tmpQuaternion;
        private _populateTmpTransformation;
        /**
         * Create a new anchor point using a hit test result at a specific point in the scene
         * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.
         * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.
         *
         * @param hitTestResult The hit test result to use for this anchor creation
         * @param position an optional position offset for this anchor
         * @param rotationQuaternion an optional rotation offset for this anchor
         * @returns A promise that fulfills when the XR anchor was registered in the system (but not necessarily added to the tracked anchors)
         */
        addAnchorPointUsingHitTestResultAsync(hitTestResult: IWebXRHitResult, position?: Vector3, rotationQuaternion?: Quaternion): Promise<XRAnchor>;
        /**
         * Add a new anchor at a specific position and rotation
         * This function will add a new anchor per default in the next available frame. Unless forced, the createAnchor function
         * will be called in the next xrFrame loop to make sure that the anchor can be created correctly.
         * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.
         * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.
         *
         * @param position the position in which to add an anchor
         * @param rotationQuaternion an optional rotation for the anchor transformation
         * @param forceCreateInCurrentFrame force the creation of this anchor in the current frame. Must be called inside xrFrame loop!
         * @returns A promise that fulfills when the XR anchor was registered in the system (but not necessarily added to the tracked anchors)
         */
        addAnchorAtPositionAndRotationAsync(position: Vector3, rotationQuaternion?: Quaternion, forceCreateInCurrentFrame?: boolean): Promise<XRAnchor>;
        /**
         * detach this feature.
         * Will usually be called by the features manager
         *
         * @returns true if successful.
         */
        detach(): boolean;
        /**
         * Dispose this feature and all of the resources attached
         */
        dispose(): void;
        protected _onXRFrame(frame: XRFrame): void;
        /**
         * avoiding using Array.find for global support.
         * @param xrAnchor the plane to find in the array
         */
        private _findIndexInAnchorArray;
        private _updateAnchorWithXRFrame;
        private _createAnchorAtTransformation;
    }
}
declare module BABYLON {
    /**
     * Options used in the plane detector module
     */
    export interface IWebXRPlaneDetectorOptions {
        /**
         * The node to use to transform the local results to world coordinates
         */
        worldParentNode?: TransformNode;
        /**
         * If set to true a reference of the created planes will be kept until the next session starts
         * If not defined, planes will be removed from the array when the feature is detached or the session ended.
         */
        doNotRemovePlanesOnSessionEnded?: boolean;
    }
    /**
     * A babylon interface for a WebXR plane.
     * A Plane is actually a polygon, built from N points in space
     *
     * Supported in chrome 79, not supported in canary 81 ATM
     */
    export interface IWebXRPlane {
        /**
         * a babylon-assigned ID for this polygon
         */
        id: number;
        /**
         * an array of vector3 points in babylon space. right/left hand system is taken into account.
         */
        polygonDefinition: Array<Vector3>;
        /**
         * A transformation matrix to apply on the mesh that will be built using the polygonDefinition
         * Local vs. World are decided if worldParentNode was provided or not in the options when constructing the module
         */
        transformationMatrix: Matrix;
        /**
         * the native xr-plane object
         */
        xrPlane: XRPlane;
    }
    /**
     * The plane detector is used to detect planes in the real world when in AR
     * For more information see https://github.com/immersive-web/real-world-geometry/
     */
    export class WebXRPlaneDetector extends WebXRAbstractFeature {
        private _options;
        private _detectedPlanes;
        private _enabled;
        private _lastFrameDetected;
        /**
         * The module's name
         */
        static readonly Name: string;
        /**
         * The (Babylon) version of this module.
         * This is an integer representing the implementation version.
         * This number does not correspond to the WebXR specs version
         */
        static readonly Version: number;
        /**
         * Observers registered here will be executed when a new plane was added to the session
         */
        onPlaneAddedObservable: Observable<IWebXRPlane>;
        /**
         * Observers registered here will be executed when a plane is no longer detected in the session
         */
        onPlaneRemovedObservable: Observable<IWebXRPlane>;
        /**
         * Observers registered here will be executed when an existing plane updates (for example - expanded)
         * This can execute N times every frame
         */
        onPlaneUpdatedObservable: Observable<IWebXRPlane>;
        /**
         * construct a new Plane Detector
         * @param _xrSessionManager an instance of xr Session manager
         * @param _options configuration to use when constructing this feature
         */
        constructor(_xrSessionManager: WebXRSessionManager, _options?: IWebXRPlaneDetectorOptions);
        /**
         * detach this feature.
         * Will usually be called by the features manager
         *
         * @returns true if successful.
         */
        detach(): boolean;
        /**
         * Dispose this feature and all of the resources attached
         */
        dispose(): void;
        protected _onXRFrame(frame: XRFrame): void;
        private _init;
        private _updatePlaneWithXRPlane;
        /**
         * avoiding using Array.find for global support.
         * @param xrPlane the plane to find in the array
         */
        private findIndexInPlaneArray;
    }
}
declare module BABYLON {
    /**
     * Options interface for the background remover plugin
     */
    export interface IWebXRBackgroundRemoverOptions {
        /**
         * Further background meshes to disable when entering AR
         */
        backgroundMeshes?: AbstractMesh[];
        /**
         * flags to configure the removal of the environment helper.
         * If not set, the entire background will be removed. If set, flags should be set as well.
         */
        environmentHelperRemovalFlags?: {
            /**
             * Should the skybox be removed (default false)
             */
            skyBox?: boolean;
            /**
             * Should the ground be removed (default false)
             */
            ground?: boolean;
        };
        /**
         * don't disable the environment helper
         */
        ignoreEnvironmentHelper?: boolean;
    }
    /**
     * A module that will automatically disable background meshes when entering AR and will enable them when leaving AR.
     */
    export class WebXRBackgroundRemover extends WebXRAbstractFeature {
        /**
         * read-only options to be used in this module
         */
        readonly options: IWebXRBackgroundRemoverOptions;
        /**
         * The module's name
         */
        static readonly Name: string;
        /**
         * The (Babylon) version of this module.
         * This is an integer representing the implementation version.
         * This number does not correspond to the WebXR specs version
         */
        static readonly Version: number;
        /**
         * registered observers will be triggered when the background state changes
         */
        onBackgroundStateChangedObservable: Observable<boolean>;
        /**
         * constructs a new background remover module
         * @param _xrSessionManager the session manager for this module
         * @param options read-only options to be used in this module
         */
        constructor(_xrSessionManager: WebXRSessionManager, 
        /**
         * read-only options to be used in this module
         */
        options?: IWebXRBackgroundRemoverOptions);
        /**
         * attach this feature
         * Will usually be called by the features manager
         *
         * @returns true if successful.
         */
        attach(): boolean;
        /**
         * detach this feature.
         * Will usually be called by the features manager
         *
         * @returns true if successful.
         */
        detach(): boolean;
        /**
         * Dispose this feature and all of the resources attached
         */
        dispose(): void;
        protected _onXRFrame(_xrFrame: XRFrame): void;
        private _setBackgroundState;
    }
}
declare module BABYLON {
    /**
     * Options for the controller physics feature
     */
    export class IWebXRControllerPhysicsOptions {
        /**
         * Should the headset get its own impostor
         */
        enableHeadsetImpostor?: boolean;
        /**
         * Optional parameters for the headset impostor
         */
        headsetImpostorParams?: {
            /**
             * The type of impostor to create. Default is sphere
             */
            impostorType: number;
            /**
             * the size of the impostor. Defaults to 10cm
             */
            impostorSize?: number | {
                width: number;
                height: number;
                depth: number;
            };
            /**
             * Friction definitions
             */
            friction?: number;
            /**
             * Restitution
             */
            restitution?: number;
        };
        /**
         * The physics properties of the future impostors
         */
        physicsProperties?: {
            /**
             * If set to true, a mesh impostor will be created when the controller mesh was loaded
             * Note that this requires a physics engine that supports mesh impostors!
             */
            useControllerMesh?: boolean;
            /**
             * The type of impostor to create. Default is sphere
             */
            impostorType?: number;
            /**
             * the size of the impostor. Defaults to 10cm
             */
            impostorSize?: number | {
                width: number;
                height: number;
                depth: number;
            };
            /**
             * Friction definitions
             */
            friction?: number;
            /**
             * Restitution
             */
            restitution?: number;
        };
        /**
         * the xr input to use with this pointer selection
         */
        xrInput: WebXRInput;
    }
    /**
     * Add physics impostor to your webxr controllers,
     * including naive calculation of their linear and angular velocity
     */
    export class WebXRControllerPhysics extends WebXRAbstractFeature {
        private readonly _options;
        private _attachController;
        private _controllers;
        private _debugMode;
        private _delta;
        private _headsetImpostor?;
        private _headsetMesh?;
        private _lastTimestamp;
        private _tmpQuaternion;
        private _tmpVector;
        /**
         * The module's name
         */
        static readonly Name: string;
        /**
         * The (Babylon) version of this module.
         * This is an integer representing the implementation version.
         * This number does not correspond to the webxr specs version
         */
        static readonly Version: number;
        /**
         * Construct a new Controller Physics Feature
         * @param _xrSessionManager the corresponding xr session manager
         * @param _options options to create this feature with
         */
        constructor(_xrSessionManager: WebXRSessionManager, _options: IWebXRControllerPhysicsOptions);
        /**
         * @hidden
         * enable debugging - will show console outputs and the impostor mesh
         */
        _enablePhysicsDebug(): void;
        /**
         * Manually add a controller (if no xrInput was provided or physics engine was not enabled)
         * @param xrController the controller to add
         */
        addController(xrController: WebXRInputSource): void;
        /**
         * attach this feature
         * Will usually be called by the features manager
         *
         * @returns true if successful.
         */
        attach(): boolean;
        /**
         * detach this feature.
         * Will usually be called by the features manager
         *
         * @returns true if successful.
         */
        detach(): boolean;
        /**
         * Get the headset impostor, if enabled
         * @returns the impostor
         */
        getHeadsetImpostor(): PhysicsImpostor | undefined;
        /**
         * Get the physics impostor of a specific controller.
         * The impostor is not attached to a mesh because a mesh for each controller is not obligatory
         * @param controller the controller or the controller id of which to get the impostor
         * @returns the impostor or null
         */
        getImpostorForController(controller: WebXRInputSource | string): Nullable<PhysicsImpostor>;
        /**
         * Update the physics properties provided in the constructor
         * @param newProperties the new properties object
         */
        setPhysicsProperties(newProperties: {
            impostorType?: number;
            impostorSize?: number | {
                width: number;
                height: number;
                depth: number;
            };
            friction?: number;
            restitution?: number;
        }): void;
        protected _onXRFrame(_xrFrame: any): void;
        private _detachController;
    }
}
declare module BABYLON {
    /**
     * A babylon interface for a "WebXR" feature point.
     * Represents the position and confidence value of a given feature point.
     */
    export interface IWebXRFeaturePoint {
        /**
         * Represents the position of the feature point in world space.
         */
        position: Vector3;
        /**
         * Represents the confidence value of the feature point in world space. 0 being least confident, and 1 being most confident.
         */
        confidenceValue: number;
    }
    /**
     * The feature point system is used to detect feature points from real world geometry.
     * This feature is currently experimental and only supported on BabylonNative, and should not be used in the browser.
     * The newly introduced API can be seen in webxr.nativeextensions.d.ts and described in FeaturePoints.md.
     */
    export class WebXRFeaturePointSystem extends WebXRAbstractFeature {
        private _enabled;
        private _featurePointCloud;
        /**
         * The module's name
         */
        static readonly Name: string;
        /**
         * The (Babylon) version of this module.
         * This is an integer representing the implementation version.
         * This number does not correspond to the WebXR specs version
         */
        static readonly Version: number;
        /**
        * Observers registered here will be executed whenever new feature points are added (on XRFrame while the session is tracking).
        * Will notify the observers about which feature points have been added.
        */
        readonly onFeaturePointsAddedObservable: Observable<number[]>;
        /**
         * Observers registered here will be executed whenever a feature point has been updated (on XRFrame while the session is tracking).
         * Will notify the observers about which feature points have been updated.
         */
        readonly onFeaturePointsUpdatedObservable: Observable<number[]>;
        /**
         * The current feature point cloud maintained across frames.
         */
        get featurePointCloud(): Array<IWebXRFeaturePoint>;
        /**
         * construct the feature point system
         * @param _xrSessionManager an instance of xr Session manager
         */
        constructor(_xrSessionManager: WebXRSessionManager);
        /**
         * Detach this feature.
         * Will usually be called by the features manager
         *
         * @returns true if successful.
         */
        detach(): boolean;
        /**
         * Dispose this feature and all of the resources attached
         */
        dispose(): void;
        /**
         * On receiving a new XR frame if this feature is attached notify observers new feature point data is available.
         */
        protected _onXRFrame(frame: XRFrame): void;
        /**
         * Initializes the feature. If the feature point feature is not available for this environment do not mark the feature as enabled.
         */
        private _init;
    }
}
declare module BABYLON {
    /**
     * Configuration interface for the hand tracking feature
     */
    export interface IWebXRHandTrackingOptions {
        /**
         * The xrInput that will be used as source for new hands
         */
        xrInput: WebXRInput;
        /**
         * Configuration object for the joint meshes
         */
        jointMeshes?: {
            /**
             * Should the meshes created be invisible (defaults to false)
             */
            invisible?: boolean;
            /**
             * A source mesh to be used to create instances. Defaults to a sphere.
             * This mesh will be the source for all other (25) meshes.
             * It should have the general size of a single unit, as the instances will be scaled according to the provided radius
             */
            sourceMesh?: Mesh;
            /**
             * Should the source mesh stay visible. Defaults to false
             */
            keepOriginalVisible?: boolean;
            /**
             * Scale factor for all instances (defaults to 2)
             */
            scaleFactor?: number;
            /**
             * Should each instance have its own physics impostor
             */
            enablePhysics?: boolean;
            /**
             * If enabled, override default physics properties
             */
            physicsProps?: {
                friction?: number;
                restitution?: number;
                impostorType?: number;
            };
            /**
             * For future use - a single hand-mesh that will be updated according to the XRHand data provided
             */
            handMesh?: AbstractMesh;
        };
    }
    /**
     * Parts of the hands divided to writs and finger names
     */
    export const enum HandPart {
        /**
         * HandPart - Wrist
         */
        WRIST = "wrist",
        /**
         * HandPart - The THumb
         */
        THUMB = "thumb",
        /**
         * HandPart - Index finger
         */
        INDEX = "index",
        /**
         * HandPart - Middle finger
         */
        MIDDLE = "middle",
        /**
         * HandPart - Ring finger
         */
        RING = "ring",
        /**
         * HandPart - Little finger
         */
        LITTLE = "little"
    }
    /**
     * Representing a single hand (with its corresponding native XRHand object)
     */
    export class WebXRHand implements IDisposable {
        /** the controller to which the hand correlates */
        readonly xrController: WebXRInputSource;
        /** the meshes to be used to track the hand joints */
        readonly trackedMeshes: AbstractMesh[];
        /**
         * Hand-parts definition (key is HandPart)
         */
        handPartsDefinition: {
            [key: string]: number[];
        };
        /**
         * Populate the HandPartsDefinition object.
         * This is called as a side effect since certain browsers don't have XRHand defined.
         */
        private generateHandPartsDefinition;
        /**
         * Construct a new hand object
         * @param xrController the controller to which the hand correlates
         * @param trackedMeshes the meshes to be used to track the hand joints
         */
        constructor(
        /** the controller to which the hand correlates */
        xrController: WebXRInputSource, 
        /** the meshes to be used to track the hand joints */
        trackedMeshes: AbstractMesh[]);
        /**
         * Update this hand from the latest xr frame
         * @param xrFrame xrFrame to update from
         * @param referenceSpace The current viewer reference space
         * @param scaleFactor optional scale factor for the meshes
         */
        updateFromXRFrame(xrFrame: XRFrame, referenceSpace: XRReferenceSpace, scaleFactor?: number): void;
        /**
         * Get meshes of part of the hand
         * @param part the part of hand to get
         * @returns An array of meshes that correlate to the hand part requested
         */
        getHandPartMeshes(part: HandPart): AbstractMesh[];
        /**
         * Dispose this Hand object
         */
        dispose(): void;
    }
    /**
     * WebXR Hand Joint tracking feature, available for selected browsers and devices
     */
    export class WebXRHandTracking extends WebXRAbstractFeature {
        /**
         * options to use when constructing this feature
         */
        readonly options: IWebXRHandTrackingOptions;
        private static _idCounter;
        /**
         * The module's name
         */
        static readonly Name: string;
        /**
         * The (Babylon) version of this module.
         * This is an integer representing the implementation version.
         * This number does not correspond to the WebXR specs version
         */
        static readonly Version: number;
        /**
         * This observable will notify registered observers when a new hand object was added and initialized
         */
        onHandAddedObservable: Observable<WebXRHand>;
        /**
         * This observable will notify its observers right before the hand object is disposed
         */
        onHandRemovedObservable: Observable<WebXRHand>;
        private _hands;
        /**
         * Creates a new instance of the hit test feature
         * @param _xrSessionManager an instance of WebXRSessionManager
         * @param options options to use when constructing this feature
         */
        constructor(_xrSessionManager: WebXRSessionManager, 
        /**
         * options to use when constructing this feature
         */
        options: IWebXRHandTrackingOptions);
        /**
         * Check if the needed objects are defined.
         * This does not mean that the feature is enabled, but that the objects needed are well defined.
         */
        isCompatible(): boolean;
        /**
         * attach this feature
         * Will usually be called by the features manager
         *
         * @returns true if successful.
         */
        attach(): boolean;
        /**
         * detach this feature.
         * Will usually be called by the features manager
         *
         * @returns true if successful.
         */
        detach(): boolean;
        /**
         * Dispose this feature and all of the resources attached
         */
        dispose(): void;
        /**
         * Get the hand object according to the controller id
         * @param controllerId the controller id to which we want to get the hand
         * @returns null if not found or the WebXRHand object if found
         */
        getHandByControllerId(controllerId: string): Nullable<WebXRHand>;
        /**
         * Get a hand object according to the requested handedness
         * @param handedness the handedness to request
         * @returns null if not found or the WebXRHand object if found
         */
        getHandByHandedness(handedness: XRHandedness): Nullable<WebXRHand>;
        protected _onXRFrame(_xrFrame: XRFrame): void;
        private _attachHand;
        private _detachHand;
    }
}
declare module BABYLON {
    /**
     * The motion controller class for all microsoft mixed reality controllers
     */
    export class WebXRMicrosoftMixedRealityController extends WebXRAbstractMotionController {
        protected readonly _mapping: {
            defaultButton: {
                valueNodeName: string;
                unpressedNodeName: string;
                pressedNodeName: string;
            };
            defaultAxis: {
                valueNodeName: string;
                minNodeName: string;
                maxNodeName: string;
            };
            buttons: {
                "xr-standard-trigger": {
                    rootNodeName: string;
                    componentProperty: string;
                    states: string[];
                };
                "xr-standard-squeeze": {
                    rootNodeName: string;
                    componentProperty: string;
                    states: string[];
                };
                "xr-standard-touchpad": {
                    rootNodeName: string;
                    labelAnchorNodeName: string;
                    touchPointNodeName: string;
                };
                "xr-standard-thumbstick": {
                    rootNodeName: string;
                    componentProperty: string;
                    states: string[];
                };
            };
            axes: {
                "xr-standard-touchpad": {
                    "x-axis": {
                        rootNodeName: string;
                    };
                    "y-axis": {
                        rootNodeName: string;
                    };
                };
                "xr-standard-thumbstick": {
                    "x-axis": {
                        rootNodeName: string;
                    };
                    "y-axis": {
                        rootNodeName: string;
                    };
                };
            };
        };
        /**
         * The base url used to load the left and right controller models
         */
        static MODEL_BASE_URL: string;
        /**
         * The name of the left controller model file
         */
        static MODEL_LEFT_FILENAME: string;
        /**
         * The name of the right controller model file
         */
        static MODEL_RIGHT_FILENAME: string;
        profileId: string;
        constructor(scene: Scene, gamepadObject: IMinimalMotionControllerObject, handedness: MotionControllerHandedness);
        protected _getFilenameAndPath(): {
            filename: string;
            path: string;
        };
        protected _getModelLoadingConstraints(): boolean;
        protected _processLoadedModel(_meshes: AbstractMesh[]): void;
        protected _setRootMesh(meshes: AbstractMesh[]): void;
        protected _updateModel(): void;
    }
}
declare module BABYLON {
    /**
     * The motion controller class for oculus touch (quest, rift).
     * This class supports legacy mapping as well the standard xr mapping
     */
    export class WebXROculusTouchMotionController extends WebXRAbstractMotionController {
        private _forceLegacyControllers;
        private _modelRootNode;
        /**
         * The base url used to load the left and right controller models
         */
        static MODEL_BASE_URL: string;
        /**
         * The name of the left controller model file
         */
        static MODEL_LEFT_FILENAME: string;
        /**
         * The name of the right controller model file
         */
        static MODEL_RIGHT_FILENAME: string;
        /**
         * Base Url for the Quest controller model.
         */
        static QUEST_MODEL_BASE_URL: string;
        profileId: string;
        constructor(scene: Scene, gamepadObject: IMinimalMotionControllerObject, handedness: MotionControllerHandedness, legacyMapping?: boolean, _forceLegacyControllers?: boolean);
        protected _getFilenameAndPath(): {
            filename: string;
            path: string;
        };
        protected _getModelLoadingConstraints(): boolean;
        protected _processLoadedModel(_meshes: AbstractMesh[]): void;
        protected _setRootMesh(meshes: AbstractMesh[]): void;
        protected _updateModel(): void;
        /**
         * Is this the new type of oculus touch. At the moment both have the same profile and it is impossible to differentiate
         * between the touch and touch 2.
         */
        private _isQuest;
    }
}
declare module BABYLON {
    /**
     * The motion controller class for the standard HTC-Vive controllers
     */
    export class WebXRHTCViveMotionController extends WebXRAbstractMotionController {
        private _modelRootNode;
        /**
         * The base url used to load the left and right controller models
         */
        static MODEL_BASE_URL: string;
        /**
         * File name for the controller model.
         */
        static MODEL_FILENAME: string;
        profileId: string;
        /**
         * Create a new Vive motion controller object
         * @param scene the scene to use to create this controller
         * @param gamepadObject the corresponding gamepad object
         * @param handedness the handedness of the controller
         */
        constructor(scene: Scene, gamepadObject: IMinimalMotionControllerObject, handedness: MotionControllerHandedness);
        protected _getFilenameAndPath(): {
            filename: string;
            path: string;
        };
        protected _getModelLoadingConstraints(): boolean;
        protected _processLoadedModel(_meshes: AbstractMesh[]): void;
        protected _setRootMesh(meshes: AbstractMesh[]): void;
        protected _updateModel(): void;
    }
}
declare module BABYLON {
    /**
     * A cursor which tracks a point on a path
     */
    export class PathCursor {
        private path;
        /**
         * Stores path cursor callbacks for when an onchange event is triggered
         */
        private _onchange;
        /**
         * The value of the path cursor
         */
        value: number;
        /**
         * The animation array of the path cursor
         */
        animations: Animation[];
        /**
         * Initializes the path cursor
         * @param path The path to track
         */
        constructor(path: Path2);
        /**
         * Gets the cursor point on the path
         * @returns A point on the path cursor at the cursor location
         */
        getPoint(): Vector3;
        /**
         * Moves the cursor ahead by the step amount
         * @param step The amount to move the cursor forward
         * @returns This path cursor
         */
        moveAhead(step?: number): PathCursor;
        /**
         * Moves the cursor behind by the step amount
         * @param step The amount to move the cursor back
         * @returns This path cursor
         */
        moveBack(step?: number): PathCursor;
        /**
         * Moves the cursor by the step amount
         * If the step amount is greater than one, an exception is thrown
         * @param step The amount to move the cursor
         * @returns This path cursor
         */
        move(step: number): PathCursor;
        /**
         * Ensures that the value is limited between zero and one
         * @returns This path cursor
         */
        private ensureLimits;
        /**
         * Runs onchange callbacks on change (used by the animation engine)
         * @returns This path cursor
         */
        private raiseOnChange;
        /**
         * Executes a function on change
         * @param f A path cursor onchange callback
         * @returns This path cursor
         */
        onchange(f: (cursor: PathCursor) => void): PathCursor;
    }
}
declare module BABYLON {
    /** @hidden */
    export var blurPixelShader: {
        name: string;
        shader: string;
    };
}
declare module BABYLON {
    /** @hidden */
    export var pointCloudVertexDeclaration: {
        name: string;
        shader: string;
    };
}
// Mixins
interface Window {
    mozIndexedDB: IDBFactory;
    webkitIndexedDB: IDBFactory;
    msIndexedDB: IDBFactory;
    webkitURL: typeof URL;
    mozRequestAnimationFrame(callback: FrameRequestCallback): number;
    oRequestAnimationFrame(callback: FrameRequestCallback): number;
    WebGLRenderingContext: WebGLRenderingContext;
    MSGesture: MSGesture;
    CANNON: any;
    AudioContext: AudioContext;
    webkitAudioContext: AudioContext;
    PointerEvent: any;
    Math: Math;
    Uint8Array: Uint8ArrayConstructor;
    Float32Array: Float32ArrayConstructor;
    mozURL: typeof URL;
    msURL: typeof URL;
    VRFrameData: any; // WebVR, from specs 1.1
    DracoDecoderModule: any;
    setImmediate(handler: (...args: any[]) => void): number;
}

interface HTMLCanvasElement {
    requestPointerLock(): void;
    msRequestPointerLock?(): void;
    mozRequestPointerLock?(): void;
    webkitRequestPointerLock?(): void;

    /** Track wether a record is in progress */
    isRecording: boolean;
    /** Capture Stream method defined by some browsers */
    captureStream(fps?: number): MediaStream;
}

interface CanvasRenderingContext2D {
    msImageSmoothingEnabled: boolean;
}

interface MouseEvent {
    mozMovementX: number;
    mozMovementY: number;
    webkitMovementX: number;
    webkitMovementY: number;
    msMovementX: number;
    msMovementY: number;
}

interface Navigator {
    mozGetVRDevices: (any: any) => any;
    webkitGetUserMedia(constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback): void;
    mozGetUserMedia(constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback): void;
    msGetUserMedia(constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback): void;

    webkitGetGamepads(): Gamepad[];
    msGetGamepads(): Gamepad[];
    webkitGamepads(): Gamepad[];
}

interface HTMLVideoElement {
    mozSrcObject: any;
}

interface Math {
    fround(x: number): number;
    imul(a: number, b: number): number;
}

interface WebGLRenderingContext {
    drawArraysInstanced(mode: number, first: number, count: number, primcount: number): void;
    drawElementsInstanced(mode: number, count: number, type: number, offset: number, primcount: number): void;
    vertexAttribDivisor(index: number, divisor: number): void;

    createVertexArray(): any;
    bindVertexArray(vao?: WebGLVertexArrayObject | null): void;
    deleteVertexArray(vao: WebGLVertexArrayObject): void;

    blitFramebuffer(srcX0: number, srcY0: number, srcX1: number, srcY1: number, dstX0: number, dstY0: number, dstX1: number, dstY1: number, mask: number, filter: number): void;
    renderbufferStorageMultisample?(target: number, samples: number, internalformat: number, width: number, height: number): void;

    bindBufferBase(target: number, index: number, buffer: WebGLBuffer | null): void;
    getUniformBlockIndex(program: WebGLProgram, uniformBlockName: string): number;
    uniformBlockBinding(program: WebGLProgram, uniformBlockIndex: number, uniformBlockBinding: number): void;

    // Queries
    createQuery(): WebGLQuery;
    deleteQuery(query: WebGLQuery): void;
    beginQuery(target: number, query: WebGLQuery): void;
    endQuery(target: number): void;
    getQueryParameter(query: WebGLQuery, pname: number): any;
    getQuery(target: number, pname: number): any;

    MAX_SAMPLES: number;
    RGBA8: number;
    READ_FRAMEBUFFER: number;
    DRAW_FRAMEBUFFER: number;
    UNIFORM_BUFFER: number;

    HALF_FLOAT_OES: number;
    RGBA16F: number;
    RGBA32F: number;
    R32F: number;
    RG32F: number;
    RGB32F: number;
    R16F: number;
    RG16F: number;
    RGB16F: number;
    RED: number;
    RG: number;
    R8: number;
    RG8: number;

    UNSIGNED_INT_24_8: number;
    DEPTH24_STENCIL8: number;

    MIN: number;
    MAX: number;

    /* Multiple Render Targets */
    drawBuffers(buffers: number[]): void;
    readBuffer(src: number): void;

    readonly COLOR_ATTACHMENT0: number;                             // 0x8CE1
    readonly COLOR_ATTACHMENT1: number;                             // 0x8CE2
    readonly COLOR_ATTACHMENT2: number;                             // 0x8CE3
    readonly COLOR_ATTACHMENT3: number;                             // 0x8CE4

    // Occlusion Query
    ANY_SAMPLES_PASSED_CONSERVATIVE: number;
    ANY_SAMPLES_PASSED: number;
    QUERY_RESULT_AVAILABLE: number;
    QUERY_RESULT: number;
}

interface WebGLProgram {
    __SPECTOR_rebuildProgram?: ((vertexSourceCode: string, fragmentSourceCode: string, onCompiled: (program: WebGLProgram) => void, onError: (message: string) => void) => void) | null;
}

interface EXT_disjoint_timer_query {
    QUERY_COUNTER_BITS_EXT: number;
    TIME_ELAPSED_EXT: number;
    TIMESTAMP_EXT: number;
    GPU_DISJOINT_EXT: number;
    QUERY_RESULT_EXT: number;
    QUERY_RESULT_AVAILABLE_EXT: number;
    queryCounterEXT(query: WebGLQuery, target: number): void;
    createQueryEXT(): WebGLQuery;
    beginQueryEXT(target: number, query: WebGLQuery): void;
    endQueryEXT(target: number): void;
    getQueryObjectEXT(query: WebGLQuery, target: number): any;
    deleteQueryEXT(query: WebGLQuery): void;
}

interface WebGLUniformLocation {
    _currentState: any;
}
// Type definitions for WebGL 2, Editor's Draft Fri Feb 24 16:10:18 2017 -0800
// Project: https://www.khronos.org/registry/webgl/specs/latest/2.0/
// Definitions by: Nico Kemnitz <https://github.com/nkemnitz/>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

interface WebGLRenderingContext {
    readonly RASTERIZER_DISCARD: number;
    readonly DEPTH_COMPONENT24: number;
    readonly TEXTURE_3D: number;
    readonly TEXTURE_2D_ARRAY: number;
    readonly TEXTURE_COMPARE_FUNC: number;
    readonly TEXTURE_COMPARE_MODE: number;
    readonly COMPARE_REF_TO_TEXTURE: number;
    readonly TEXTURE_WRAP_R: number;
    readonly HALF_FLOAT: number;
    readonly RGB8: number;
    readonly RED_INTEGER: number;
    readonly RG_INTEGER: number;
    readonly RGB_INTEGER: number;
    readonly RGBA_INTEGER: number;
    readonly R8_SNORM: number;
    readonly RG8_SNORM: number;
    readonly RGB8_SNORM: number;
    readonly RGBA8_SNORM: number;
    readonly R8I: number;
    readonly RG8I: number;
    readonly RGB8I: number;
    readonly RGBA8I: number;
    readonly R8UI: number;
    readonly RG8UI: number;
    readonly RGB8UI: number;
    readonly RGBA8UI: number;
    readonly R16I: number;
    readonly RG16I: number;
    readonly RGB16I: number;
    readonly RGBA16I: number;
    readonly R16UI: number;
    readonly RG16UI: number;
    readonly RGB16UI: number;
    readonly RGBA16UI: number;
    readonly R32I: number;
    readonly RG32I: number;
    readonly RGB32I: number;
    readonly RGBA32I: number;
    readonly R32UI: number;
    readonly RG32UI: number;
    readonly RGB32UI: number;
    readonly RGBA32UI: number;
    readonly RGB10_A2UI: number;
    readonly R11F_G11F_B10F: number;
    readonly RGB9_E5: number;
    readonly RGB10_A2: number;
    readonly UNSIGNED_INT_2_10_10_10_REV: number;
    readonly UNSIGNED_INT_10F_11F_11F_REV: number;
    readonly UNSIGNED_INT_5_9_9_9_REV: number;
    readonly FLOAT_32_UNSIGNED_INT_24_8_REV: number;
    readonly DEPTH_COMPONENT32F: number;

    texImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, format: number, type: number, pixels: ArrayBufferView | null): void;
    texImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, format: number, type: number, pixels: ArrayBufferView, offset: number): void;
    texImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, format: number, type: number, pixels: ImageBitmap | ImageData | HTMLVideoElement | HTMLImageElement | HTMLCanvasElement): void;

    framebufferTextureLayer(target: number, attachment: number, texture: WebGLTexture | null, level: number, layer: number): void;

    compressedTexImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, data: ArrayBufferView, offset?: number, length?: number): void;

    readonly TRANSFORM_FEEDBACK: number;
    readonly INTERLEAVED_ATTRIBS: number;
    readonly TRANSFORM_FEEDBACK_BUFFER: number;
    createTransformFeedback(): WebGLTransformFeedback;
    deleteTransformFeedback(transformFeedbac: WebGLTransformFeedback): void;
    bindTransformFeedback(target: number, transformFeedback: WebGLTransformFeedback | null): void;
    beginTransformFeedback(primitiveMode: number): void;
    endTransformFeedback(): void;
    transformFeedbackVaryings(program: WebGLProgram, varyings: string[], bufferMode: number): void;

    clearBufferfv(buffer: number, drawbuffer: number, values: ArrayBufferView, srcOffset: number | null): void;
    clearBufferiv(buffer: number, drawbuffer: number, values: ArrayBufferView, srcOffset: number | null): void;
    clearBufferuiv(buffer: number, drawbuffer: number, values: ArrayBufferView, srcOffset: number | null): void;
    clearBufferfi(buffer: number, drawbuffer: number, depth: number, stencil: number): void;
}

interface ImageBitmap {
    readonly width: number;
    readonly height: number;
    close(): void;
}

interface WebGLQuery extends WebGLObject {
}

declare var WebGLQuery: {
    prototype: WebGLQuery;
    new(): WebGLQuery;
};

interface WebGLSampler extends WebGLObject {
}

declare var WebGLSampler: {
    prototype: WebGLSampler;
    new(): WebGLSampler;
};

interface WebGLSync extends WebGLObject {
}

declare var WebGLSync: {
    prototype: WebGLSync;
    new(): WebGLSync;
};

interface WebGLTransformFeedback extends WebGLObject {
}

declare var WebGLTransformFeedback: {
    prototype: WebGLTransformFeedback;
    new(): WebGLTransformFeedback;
};

interface WebGLVertexArrayObject extends WebGLObject {
}

declare var WebGLVertexArrayObject: {
    prototype: WebGLVertexArrayObject;
    new(): WebGLVertexArrayObject;
};

// Type definitions for WebVR API
// Project: https://w3c.github.io/webvr/
// Definitions by: six a <https://github.com/lostfictions>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

interface VRDisplay extends EventTarget {
    /**
     * Dictionary of capabilities describing the VRDisplay.
     */
    readonly capabilities: VRDisplayCapabilities;

    /**
     * z-depth defining the far plane of the eye view frustum
     * enables mapping of values in the render target depth
     * attachment to scene coordinates. Initially set to 10000.0.
     */
    depthFar: number;

    /**
     * z-depth defining the near plane of the eye view frustum
     * enables mapping of values in the render target depth
     * attachment to scene coordinates. Initially set to 0.01.
     */
    depthNear: number;

    /**
     * An identifier for this distinct VRDisplay. Used as an
     * association point in the Gamepad API.
     */
    readonly displayId: number;

    /**
     * A display name, a user-readable name identifying it.
     */
    readonly displayName: string;
    readonly isConnected: boolean;
    readonly isPresenting: boolean;

    /**
     * If this VRDisplay supports room-scale experiences, the optional
     * stage attribute contains details on the room-scale parameters.
     */
    readonly stageParameters: VRStageParameters | null;

    /**
     * Passing the value returned by `requestAnimationFrame` to
     * `cancelAnimationFrame` will unregister the callback.
     * @param handle Define the hanle of the request to cancel
     */
    cancelAnimationFrame(handle: number): void;

    /**
     * Stops presenting to the VRDisplay.
     * @returns a promise to know when it stopped
     */
    exitPresent(): Promise<void>;

    /**
     * Return the current VREyeParameters for the given eye.
     * @param whichEye Define the eye we want the parameter for
     * @returns the eye parameters
     */
    getEyeParameters(whichEye: string): VREyeParameters;

    /**
     * Populates the passed VRFrameData with the information required to render
     * the current frame.
     * @param frameData Define the data structure to populate
     * @returns true if ok otherwise false
     */
    getFrameData(frameData: VRFrameData): boolean;

    /**
     * Get the layers currently being presented.
     * @returns the list of VR layers
     */
    getLayers(): VRLayer[];

    /**
     * Return a VRPose containing the future predicted pose of the VRDisplay
     * when the current frame will be presented. The value returned will not
     * change until JavaScript has returned control to the browser.
     *
     * The VRPose will contain the position, orientation, velocity,
     * and acceleration of each of these properties.
     * @returns the pose object
     */
    getPose(): VRPose;

    /**
     * Return the current instantaneous pose of the VRDisplay, with no
     * prediction applied.
     * @returns the current instantaneous pose
     */
    getImmediatePose(): VRPose;

    /**
     * The callback passed to `requestAnimationFrame` will be called
     * any time a new frame should be rendered. When the VRDisplay is
     * presenting the callback will be called at the native refresh
     * rate of the HMD. When not presenting this function acts
     * identically to how window.requestAnimationFrame acts. Content should
     * make no assumptions of frame rate or vsync behavior as the HMD runs
     * asynchronously from other displays and at differing refresh rates.
     * @param callback Define the eaction to run next frame
     * @returns the request handle it
     */
    requestAnimationFrame(callback: FrameRequestCallback): number;

    /**
     * Begin presenting to the VRDisplay. Must be called in response to a user gesture.
     * Repeat calls while already presenting will update the VRLayers being displayed.
     * @param layers Define the list of layer to present
     * @returns a promise to know when the request has been fulfilled
     */
    requestPresent(layers: VRLayer[]): Promise<void>;

    /**
     * Reset the pose for this display, treating its current position and
     * orientation as the "origin/zero" values. VRPose.position,
     * VRPose.orientation, and VRStageParameters.sittingToStandingTransform may be
     * updated when calling resetPose(). This should be called in only
     * sitting-space experiences.
     */
    resetPose(): void;

    /**
     * The VRLayer provided to the VRDisplay will be captured and presented
     * in the HMD. Calling this function has the same effect on the source
     * canvas as any other operation that uses its source image, and canvases
     * created without preserveDrawingBuffer set to true will be cleared.
     * @param pose Define the pose to submit
     */
    submitFrame(pose?: VRPose): void;
}

declare var VRDisplay: {
    prototype: VRDisplay;
    new(): VRDisplay;
};

interface VRLayer {
    leftBounds?: number[] | Float32Array | null;
    rightBounds?: number[] | Float32Array | null;
    source?: HTMLCanvasElement | null;
}

interface VRDisplayCapabilities {
    readonly canPresent: boolean;
    readonly hasExternalDisplay: boolean;
    readonly hasOrientation: boolean;
    readonly hasPosition: boolean;
    readonly maxLayers: number;
}

interface VREyeParameters {
    /** @deprecated */
    readonly fieldOfView: VRFieldOfView;
    readonly offset: Float32Array;
    readonly renderHeight: number;
    readonly renderWidth: number;
}

interface VRFieldOfView {
    readonly downDegrees: number;
    readonly leftDegrees: number;
    readonly rightDegrees: number;
    readonly upDegrees: number;
}

interface VRFrameData {
    readonly leftProjectionMatrix: Float32Array;
    readonly leftViewMatrix: Float32Array;
    readonly pose: VRPose;
    readonly rightProjectionMatrix: Float32Array;
    readonly rightViewMatrix: Float32Array;
    readonly timestamp: number;
}

interface VRPose {
    readonly angularAcceleration: Float32Array | null;
    readonly angularVelocity: Float32Array | null;
    readonly linearAcceleration: Float32Array | null;
    readonly linearVelocity: Float32Array | null;
    readonly orientation: Float32Array | null;
    readonly position: Float32Array | null;
    readonly timestamp: number;
}

interface VRStageParameters {
    sittingToStandingTransform?: Float32Array;
    sizeX?: number;
    sizeY?: number;
}

interface Navigator {
    getVRDisplays(): Promise<VRDisplay[]>;
    readonly activeVRDisplays: ReadonlyArray<VRDisplay>;
}

interface Window {
    onvrdisplayconnected: ((this: Window, ev: Event) => any) | null;
    onvrdisplaydisconnected: ((this: Window, ev: Event) => any) | null;
    onvrdisplaypresentchange: ((this: Window, ev: Event) => any) | null;
    addEventListener(type: "vrdisplayconnected", listener: (ev: Event) => any, useCapture?: boolean): void;
    addEventListener(type: "vrdisplaydisconnected", listener: (ev: Event) => any, useCapture?: boolean): void;
    addEventListener(type: "vrdisplaypresentchange", listener: (ev: Event) => any, useCapture?: boolean): void;
}

interface Gamepad {
    readonly displayId: number;
}
type XRSessionMode = "inline" | "immersive-vr" | "immersive-ar";

type XRReferenceSpaceType = "viewer" | "local" | "local-floor" | "bounded-floor" | "unbounded";

type XREnvironmentBlendMode = "opaque" | "additive" | "alpha-blend";

type XRVisibilityState = "visible" | "visible-blurred" | "hidden";

type XRHandedness = "none" | "left" | "right";

type XRTargetRayMode = "gaze" | "tracked-pointer" | "screen";

type XREye = "none" | "left" | "right";

type XREventType = "devicechange" | "visibilitychange" | "end" | "inputsourceschange" | "select" | "selectstart" | "selectend" | "squeeze" | "squeezestart" | "squeezeend" | "reset";

interface XRSpace extends EventTarget {}

interface XRRenderState {
    depthNear?: number;
    depthFar?: number;
    inlineVerticalFieldOfView?: number;
    baseLayer?: XRWebGLLayer;
}

interface XRInputSource {
    handedness: XRHandedness;
    targetRayMode: XRTargetRayMode;
    targetRaySpace: XRSpace;
    gripSpace: XRSpace | undefined;
    gamepad: Gamepad | undefined;
    profiles: Array<string>;
    hand: XRHand | undefined;
}

interface XRSessionInit {
    optionalFeatures?: string[];
    requiredFeatures?: string[];
}

interface XRSession {
    addEventListener: Function;
    removeEventListener: Function;
    requestReferenceSpace(type: XRReferenceSpaceType): Promise<XRReferenceSpace>;
    updateRenderState(XRRenderStateInit: XRRenderState): Promise<void>;
    requestAnimationFrame: Function;
    end(): Promise<void>;
    renderState: XRRenderState;
    inputSources: Array<XRInputSource>;

    // hit test
    requestHitTestSource(options: XRHitTestOptionsInit): Promise<XRHitTestSource>;
    requestHitTestSourceForTransientInput(options: XRTransientInputHitTestOptionsInit): Promise<XRTransientInputHitTestSource>;

    // legacy AR hit test
    requestHitTest(ray: XRRay, referenceSpace: XRReferenceSpace): Promise<XRHitResult[]>;

    // legacy plane detection
    updateWorldTrackingState(options: { planeDetectionState?: { enabled: boolean } }): void;
}

interface XRReferenceSpace extends XRSpace {
    getOffsetReferenceSpace(originOffset: XRRigidTransform): XRReferenceSpace;
    onreset: any;
}

type XRPlaneSet = Set<XRPlane>;
type XRAnchorSet = Set<XRAnchor>;

interface XRFrame {
    session: XRSession;
    getViewerPose(referenceSpace: XRReferenceSpace): XRViewerPose | undefined;
    getPose(space: XRSpace, baseSpace: XRSpace): XRPose | undefined;

    // AR
    getHitTestResults(hitTestSource: XRHitTestSource): Array<XRHitTestResult>;
    getHitTestResultsForTransientInput(hitTestSource: XRTransientInputHitTestSource): Array<XRTransientInputHitTestResult>;
    // Anchors
    trackedAnchors?: XRAnchorSet;
    createAnchor(pose: XRRigidTransform, space: XRSpace): Promise<XRAnchor>;
    // Planes
    worldInformation: {
        detectedPlanes?: XRPlaneSet;
    };
    // Hand tracking
    getJointPose(joint: XRJointSpace, baseSpace: XRSpace): XRJointPose;
}

interface XRViewerPose extends XRPose {
    views: Array<XRView>;
}

interface XRPose {
    transform: XRRigidTransform;
    emulatedPosition: boolean;
}

interface XRWebGLLayerOptions {
    antialias?: boolean;
    depth?: boolean;
    stencil?: boolean;
    alpha?: boolean;
    multiview?: boolean;
    framebufferScaleFactor?: number;
}

declare var XRWebGLLayer: {
    prototype: XRWebGLLayer;
    new (session: XRSession, context: WebGLRenderingContext | undefined, options?: XRWebGLLayerOptions): XRWebGLLayer;
};
interface XRWebGLLayer {
    framebuffer: WebGLFramebuffer;
    framebufferWidth: number;
    framebufferHeight: number;
    getViewport: Function;
}

declare class XRRigidTransform {
    constructor(matrix: Float32Array | DOMPointInit, direction?: DOMPointInit);
    position: DOMPointReadOnly;
    orientation: DOMPointReadOnly;
    matrix: Float32Array;
    inverse: XRRigidTransform;
}

interface XRView {
    eye: XREye;
    projectionMatrix: Float32Array;
    transform: XRRigidTransform;
}

interface XRInputSourceChangeEvent {
    session: XRSession;
    removed: Array<XRInputSource>;
    added: Array<XRInputSource>;
}

interface XRInputSourceEvent extends Event {
    readonly frame: XRFrame;
    readonly inputSource: XRInputSource;
}

// Experimental(er) features
declare class XRRay {
    constructor(transformOrOrigin: XRRigidTransform | DOMPointInit, direction?: DOMPointInit);
    origin: DOMPointReadOnly;
    direction: DOMPointReadOnly;
    matrix: Float32Array;
}

declare enum XRHitTestTrackableType {
    "point",
    "plane",
    "mesh",
}

interface XRHitResult {
    hitMatrix: Float32Array;
}

interface XRTransientInputHitTestResult {
    readonly inputSource: XRInputSource;
    readonly results: Array<XRHitTestResult>;
}

interface XRHitTestResult {
    getPose(baseSpace: XRSpace): XRPose | undefined;
    // When anchor system is enabled
    createAnchor?(pose: XRRigidTransform): Promise<XRAnchor>;
}

interface XRHitTestSource {
    cancel(): void;
}

interface XRTransientInputHitTestSource {
    cancel(): void;
}

interface XRHitTestOptionsInit {
    space: XRSpace;
    entityTypes?: Array<XRHitTestTrackableType>;
    offsetRay?: XRRay;
}

interface XRTransientInputHitTestOptionsInit {
    profile: string;
    entityTypes?: Array<XRHitTestTrackableType>;
    offsetRay?: XRRay;
}

interface XRAnchor {
    anchorSpace: XRSpace;
    delete(): void;
}

interface XRPlane {
    orientation: "Horizontal" | "Vertical";
    planeSpace: XRSpace;
    polygon: Array<DOMPointReadOnly>;
    lastChangedTime: number;
}

interface XRJointSpace extends XRSpace {}

interface XRJointPose extends XRPose {
    radius: number | undefined;
}

interface XRHand /*extends Iterablele<XRJointSpace>*/ {
    readonly length: number;

    [index: number]: XRJointSpace;

    // Specs have the function 'joint(idx: number)', but chrome doesn't support it yet.

    readonly WRIST: number;

    readonly THUMB_METACARPAL: number;
    readonly THUMB_PHALANX_PROXIMAL: number;
    readonly THUMB_PHALANX_DISTAL: number;
    readonly THUMB_PHALANX_TIP: number;

    readonly INDEX_METACARPAL: number;
    readonly INDEX_PHALANX_PROXIMAL: number;
    readonly INDEX_PHALANX_INTERMEDIATE: number;
    readonly INDEX_PHALANX_DISTAL: number;
    readonly INDEX_PHALANX_TIP: number;

    readonly MIDDLE_METACARPAL: number;
    readonly MIDDLE_PHALANX_PROXIMAL: number;
    readonly MIDDLE_PHALANX_INTERMEDIATE: number;
    readonly MIDDLE_PHALANX_DISTAL: number;
    readonly MIDDLE_PHALANX_TIP: number;

    readonly RING_METACARPAL: number;
    readonly RING_PHALANX_PROXIMAL: number;
    readonly RING_PHALANX_INTERMEDIATE: number;
    readonly RING_PHALANX_DISTAL: number;
    readonly RING_PHALANX_TIP: number;

    readonly LITTLE_METACARPAL: number;
    readonly LITTLE_PHALANX_PROXIMAL: number;
    readonly LITTLE_PHALANX_INTERMEDIATE: number;
    readonly LITTLE_PHALANX_DISTAL: number;
    readonly LITTLE_PHALANX_TIP: number;
}

// This file contains native only extensions for WebXR  These APIs are not supported in the browser yet.
// They are intended for use with either Babylon Native https://github.com/BabylonJS/BabylonNative or
// Babylon React Native: https://github.com/BabylonJS/BabylonReactNative

interface XRSession {
    trySetFeaturePointCloudEnabled(enabled: boolean): boolean;
}

interface XRFrame {
    featurePointCloud? : Array<number>;
}