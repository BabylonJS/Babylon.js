!function(t, i) { "object" == typeof exports && "undefined" != typeof module ? i(exports) : "function" == typeof define && define.amd ? define(["exports"], i) : i(t.OIMO = t.OIMO || {}) }(this, function(t) { "use strict"; function s(t, i) { console.error("[OIMO] " + t + ": " + i) } function h(t) { this.parent = t, this.infos = new Float32Array(13), this.f = [0, 0, 0], this.times = [0, 0, 0, 0], this.broadPhase = this.parent.broadPhaseType, this.version = mt, this.fps = 0, this.tt = 0, this.broadPhaseTime = 0, this.narrowPhaseTime = 0, this.solvingTime = 0, this.totalTime = 0, this.updateTime = 0, this.MaxBroadPhaseTime = 0, this.MaxNarrowPhaseTime = 0, this.MaxSolvingTime = 0, this.MaxTotalTime = 0, this.MaxUpdateTime = 0 } function e(t, i, s) { this.x = t || 0, this.y = i || 0, this.z = s || 0 } function a(t, i, s, h) { this.x = t || 0, this.y = i || 0, this.z = s || 0, this.w = void 0 !== h ? h : 1 } function o(t, i, s, h, e, a, o, n, r) { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("OIMO.Mat33: the constructor no longer reads arguments. use .set() instead.") } function n(t, i, s, h, e, a) { this.elements = new Float32Array(6); var o = this.elements; o[0] = t || 0, o[1] = s || 0, o[2] = e || 0, o[3] = i || 0, o[4] = h || 0, o[5] = a || 0 } function r() { return Tt++ } function l(t) { this.type = ft, this.id = r(), this.prev = null, this.next = null, this.proxy = null, this.parent = null, this.contactLink = null, this.numContacts = 0, this.position = new e, this.rotation = new o, this.relativePosition = (new e).copy(t.relativePosition), this.relativeRotation = (new o).copy(t.relativeRotation), this.aabb = new n, this.density = t.density, this.friction = t.friction, this.restitution = t.restitution, this.belongsTo = t.belongsTo, this.collidesWith = t.collidesWith } function c(t, i, s, h) { l.call(this, t), this.type = vt, this.width = i, this.height = s, this.depth = h, this.halfWidth = .5 * i, this.halfHeight = .5 * s, this.halfDepth = .5 * h, this.dimentions = new Float32Array(18), this.elements = new Float32Array(24) } function m(t, i) { l.call(this, t), this.type = bt, this.radius = i } function p(t, i, s) { l.call(this, t), this.type = zt, this.radius = i, this.height = s, this.halfHeight = .5 * s, this.normalDirection = new e, this.halfDirection = new e } function u(t, i) { l.call(this, t), this.type = Nt, this.normal = new e(0, 1, 0) } function y(t, i) { l.call(this, t), this.type = kt } function x() { this.relativePosition = new e, this.relativeRotation = new o, this.friction = .2, this.restitution = .2, this.density = 1, this.belongsTo = 1, this.collidesWith = 4294967295 } function d(t, i) { i = i || !1, this.axis = t, this.angle = 0, this.lowerLimit = i ? 0 : 1, this.upperLimit = 0, this.motorSpeed = 0, this.maxMotorForce = 0, this.frequency = 0, this.dampingRatio = 0 } function f() { this.parent = null, this.body1 = null, this.body2 = null, this.addedToIsland = !1 } function b(t) { this.prev = null, this.next = null, this.body = null, this.joint = t } function v(t) { f.call(this), this.scale = 1, this.invScale = 1, this.name = "", this.id = NaN, this.type = wt, this.prev = null, this.next = null, this.body1 = t.body1, this.body2 = t.body2, this.localAnchorPoint1 = (new e).copy(t.localAnchorPoint1), this.localAnchorPoint2 = (new e).copy(t.localAnchorPoint2), this.relativeAnchorPoint1 = new e, this.relativeAnchorPoint2 = new e, this.anchorPoint1 = new e, this.anchorPoint2 = new e, this.allowCollision = t.allowCollision, this.b1Link = new b(this), this.b2Link = new b(this) } function z(t) { this.m1 = NaN, this.m2 = NaN, this.ii1 = null, this.ii2 = null, this.dd = null, this.r1x = NaN, this.r1y = NaN, this.r1z = NaN, this.r2x = NaN, this.r2y = NaN, this.r2z = NaN, this.ax1x = NaN, this.ax1y = NaN, this.ax1z = NaN, this.ay1x = NaN, this.ay1y = NaN, this.ay1z = NaN, this.az1x = NaN, this.az1y = NaN, this.az1z = NaN, this.ax2x = NaN, this.ax2y = NaN, this.ax2z = NaN, this.ay2x = NaN, this.ay2y = NaN, this.ay2z = NaN, this.az2x = NaN, this.az2y = NaN, this.az2z = NaN, this.vel = NaN, this.velx = NaN, this.vely = NaN, this.velz = NaN, this.joint = t, this.r1 = t.relativeAnchorPoint1, this.r2 = t.relativeAnchorPoint2, this.p1 = t.anchorPoint1, this.p2 = t.anchorPoint2, this.b1 = t.body1, this.b2 = t.body2, this.l1 = this.b1.linearVelocity, this.l2 = this.b2.linearVelocity, this.a1 = this.b1.angularVelocity, this.a2 = this.b2.angularVelocity, this.i1 = this.b1.inverseInertia, this.i2 = this.b2.inverseInertia, this.impx = 0, this.impy = 0, this.impz = 0 } function N(t, i, s, h) { this.cfm1 = NaN, this.cfm2 = NaN, this.cfm3 = NaN, this.i1e00 = NaN, this.i1e01 = NaN, this.i1e02 = NaN, this.i1e10 = NaN, this.i1e11 = NaN, this.i1e12 = NaN, this.i1e20 = NaN, this.i1e21 = NaN, this.i1e22 = NaN, this.i2e00 = NaN, this.i2e01 = NaN, this.i2e02 = NaN, this.i2e10 = NaN, this.i2e11 = NaN, this.i2e12 = NaN, this.i2e20 = NaN, this.i2e21 = NaN, this.i2e22 = NaN, this.ax1 = NaN, this.ay1 = NaN, this.az1 = NaN, this.ax2 = NaN, this.ay2 = NaN, this.az2 = NaN, this.ax3 = NaN, this.ay3 = NaN, this.az3 = NaN, this.a1x1 = NaN, this.a1y1 = NaN, this.a1z1 = NaN, this.a2x1 = NaN, this.a2y1 = NaN, this.a2z1 = NaN, this.a1x2 = NaN, this.a1y2 = NaN, this.a1z2 = NaN, this.a2x2 = NaN, this.a2y2 = NaN, this.a2z2 = NaN, this.a1x3 = NaN, this.a1y3 = NaN, this.a1z3 = NaN, this.a2x3 = NaN, this.a2y3 = NaN, this.a2z3 = NaN, this.lowerLimit1 = NaN, this.upperLimit1 = NaN, this.limitVelocity1 = NaN, this.limitState1 = 0, this.enableMotor1 = !1, this.motorSpeed1 = NaN, this.maxMotorForce1 = NaN, this.maxMotorImpulse1 = NaN, this.lowerLimit2 = NaN, this.upperLimit2 = NaN, this.limitVelocity2 = NaN, this.limitState2 = 0, this.enableMotor2 = !1, this.motorSpeed2 = NaN, this.maxMotorForce2 = NaN, this.maxMotorImpulse2 = NaN, this.lowerLimit3 = NaN, this.upperLimit3 = NaN, this.limitVelocity3 = NaN, this.limitState3 = 0, this.enableMotor3 = !1, this.motorSpeed3 = NaN, this.maxMotorForce3 = NaN, this.maxMotorImpulse3 = NaN, this.k00 = NaN, this.k01 = NaN, this.k02 = NaN, this.k10 = NaN, this.k11 = NaN, this.k12 = NaN, this.k20 = NaN, this.k21 = NaN, this.k22 = NaN, this.kv00 = NaN, this.kv11 = NaN, this.kv22 = NaN, this.dv00 = NaN, this.dv11 = NaN, this.dv22 = NaN, this.d00 = NaN, this.d01 = NaN, this.d02 = NaN, this.d10 = NaN, this.d11 = NaN, this.d12 = NaN, this.d20 = NaN, this.d21 = NaN, this.d22 = NaN, this.limitMotor1 = i, this.limitMotor2 = s, this.limitMotor3 = h, this.b1 = t.body1, this.b2 = t.body2, this.a1 = this.b1.angularVelocity, this.a2 = this.b2.angularVelocity, this.i1 = this.b1.inverseInertia, this.i2 = this.b2.inverseInertia, this.limitImpulse1 = 0, this.motorImpulse1 = 0, this.limitImpulse2 = 0, this.motorImpulse2 = 0, this.limitImpulse3 = 0, this.motorImpulse3 = 0 } function k(t, i, s) { v.call(this, t), this.type = It, this.localAxis1 = t.localAxis1.clone().normalize(), this.localAxis2 = t.localAxis2.clone().normalize(); var h = (new o).setQuat((new a).setFromUnitVectors(this.localAxis1, this.localAxis2)); this.localAngle1 = (new e).tangent(this.localAxis1).normalize(), this.localAngle2 = this.localAngle1.clone().applyMatrix3(h, !0), this.ax1 = new e, this.ax2 = new e, this.an1 = new e, this.an2 = new e, this.tmp = new e, this.nor = new e, this.tan = new e, this.bin = new e, this.limitMotor = new d(this.nor, !1), this.limitMotor.lowerLimit = i, this.limitMotor.upperLimit = s, this.lc = new z(this), this.r3 = new N(this, this.limitMotor, new d(this.tan, !0), new d(this.bin, !0)) } function w(t) { v.call(this, t), this.type = gt, this.lc = new z(this) } function M(t, i) { this.cfm = NaN, this.m1 = NaN, this.m2 = NaN, this.i1e00 = NaN, this.i1e01 = NaN, this.i1e02 = NaN, this.i1e10 = NaN, this.i1e11 = NaN, this.i1e12 = NaN, this.i1e20 = NaN, this.i1e21 = NaN, this.i1e22 = NaN, this.i2e00 = NaN, this.i2e01 = NaN, this.i2e02 = NaN, this.i2e10 = NaN, this.i2e11 = NaN, this.i2e12 = NaN, this.i2e20 = NaN, this.i2e21 = NaN, this.i2e22 = NaN, this.motorDenom = NaN, this.invMotorDenom = NaN, this.invDenom = NaN, this.ax = NaN, this.ay = NaN, this.az = NaN, this.r1x = NaN, this.r1y = NaN, this.r1z = NaN, this.r2x = NaN, this.r2y = NaN, this.r2z = NaN, this.t1x = NaN, this.t1y = NaN, this.t1z = NaN, this.t2x = NaN, this.t2y = NaN, this.t2z = NaN, this.l1x = NaN, this.l1y = NaN, this.l1z = NaN, this.l2x = NaN, this.l2y = NaN, this.l2z = NaN, this.a1x = NaN, this.a1y = NaN, this.a1z = NaN, this.a2x = NaN, this.a2y = NaN, this.a2z = NaN, this.lowerLimit = NaN, this.upperLimit = NaN, this.limitVelocity = NaN, this.limitState = 0, this.enableMotor = !1, this.motorSpeed = NaN, this.maxMotorForce = NaN, this.maxMotorImpulse = NaN, this.limitMotor = i, this.b1 = t.body1, this.b2 = t.body2, this.p1 = t.anchorPoint1, this.p2 = t.anchorPoint2, this.r1 = t.relativeAnchorPoint1, this.r2 = t.relativeAnchorPoint2, this.l1 = this.b1.linearVelocity, this.l2 = this.b2.linearVelocity, this.a1 = this.b1.angularVelocity, this.a2 = this.b2.angularVelocity, this.i1 = this.b1.inverseInertia, this.i2 = this.b2.inverseInertia, this.limitImpulse = 0, this.motorImpulse = 0 } function g(t, i, s) { v.call(this, t), this.type = Mt, this.nor = new e, this.limitMotor = new d(this.nor, !0), this.limitMotor.lowerLimit = i, this.limitMotor.upperLimit = s, this.t = new M(this, this.limitMotor) } function I(t, i) { this.joint = t, this.targetOrientation = (new a).invert(i), this.relativeOrientation = new a, this.ii1 = null, this.ii2 = null, this.dd = null, this.vel = new e, this.imp = new e, this.rn0 = new e, this.rn1 = new e, this.rn2 = new e, this.b1 = t.body1, this.b2 = t.body2, this.a1 = this.b1.angularVelocity, this.a2 = this.b2.angularVelocity, this.i1 = this.b1.inverseInertia, this.i2 = this.b2.inverseInertia } function V(t, i, s, h) { this.m1 = NaN, this.m2 = NaN, this.i1e00 = NaN, this.i1e01 = NaN, this.i1e02 = NaN, this.i1e10 = NaN, this.i1e11 = NaN, this.i1e12 = NaN, this.i1e20 = NaN, this.i1e21 = NaN, this.i1e22 = NaN, this.i2e00 = NaN, this.i2e01 = NaN, this.i2e02 = NaN, this.i2e10 = NaN, this.i2e11 = NaN, this.i2e12 = NaN, this.i2e20 = NaN, this.i2e21 = NaN, this.i2e22 = NaN, this.ax1 = NaN, this.ay1 = NaN, this.az1 = NaN, this.ax2 = NaN, this.ay2 = NaN, this.az2 = NaN, this.ax3 = NaN, this.ay3 = NaN, this.az3 = NaN, this.r1x = NaN, this.r1y = NaN, this.r1z = NaN, this.r2x = NaN, this.r2y = NaN, this.r2z = NaN, this.t1x1 = NaN, this.t1y1 = NaN, this.t1z1 = NaN, this.t2x1 = NaN, this.t2y1 = NaN, this.t2z1 = NaN, this.l1x1 = NaN, this.l1y1 = NaN, this.l1z1 = NaN, this.l2x1 = NaN, this.l2y1 = NaN, this.l2z1 = NaN, this.a1x1 = NaN, this.a1y1 = NaN, this.a1z1 = NaN, this.a2x1 = NaN, this.a2y1 = NaN, this.a2z1 = NaN, this.t1x2 = NaN, this.t1y2 = NaN, this.t1z2 = NaN, this.t2x2 = NaN, this.t2y2 = NaN, this.t2z2 = NaN, this.l1x2 = NaN, this.l1y2 = NaN, this.l1z2 = NaN, this.l2x2 = NaN, this.l2y2 = NaN, this.l2z2 = NaN, this.a1x2 = NaN, this.a1y2 = NaN, this.a1z2 = NaN, this.a2x2 = NaN, this.a2y2 = NaN, this.a2z2 = NaN, this.t1x3 = NaN, this.t1y3 = NaN, this.t1z3 = NaN, this.t2x3 = NaN, this.t2y3 = NaN, this.t2z3 = NaN, this.l1x3 = NaN, this.l1y3 = NaN, this.l1z3 = NaN, this.l2x3 = NaN, this.l2y3 = NaN, this.l2z3 = NaN, this.a1x3 = NaN, this.a1y3 = NaN, this.a1z3 = NaN, this.a2x3 = NaN, this.a2y3 = NaN, this.a2z3 = NaN, this.lowerLimit1 = NaN, this.upperLimit1 = NaN, this.limitVelocity1 = NaN, this.limitState1 = 0, this.enableMotor1 = !1, this.motorSpeed1 = NaN, this.maxMotorForce1 = NaN, this.maxMotorImpulse1 = NaN, this.lowerLimit2 = NaN, this.upperLimit2 = NaN, this.limitVelocity2 = NaN, this.limitState2 = 0, this.enableMotor2 = !1, this.motorSpeed2 = NaN, this.maxMotorForce2 = NaN, this.maxMotorImpulse2 = NaN, this.lowerLimit3 = NaN, this.upperLimit3 = NaN, this.limitVelocity3 = NaN, this.limitState3 = 0, this.enableMotor3 = !1, this.motorSpeed3 = NaN, this.maxMotorForce3 = NaN, this.maxMotorImpulse3 = NaN, this.k00 = NaN, this.k01 = NaN, this.k02 = NaN, this.k10 = NaN, this.k11 = NaN, this.k12 = NaN, this.k20 = NaN, this.k21 = NaN, this.k22 = NaN, this.kv00 = NaN, this.kv11 = NaN, this.kv22 = NaN, this.dv00 = NaN, this.dv11 = NaN, this.dv22 = NaN, this.d00 = NaN, this.d01 = NaN, this.d02 = NaN, this.d10 = NaN, this.d11 = NaN, this.d12 = NaN, this.d20 = NaN, this.d21 = NaN, this.d22 = NaN, this.limitMotor1 = i, this.limitMotor2 = s, this.limitMotor3 = h, this.b1 = t.body1, this.b2 = t.body2, this.p1 = t.anchorPoint1, this.p2 = t.anchorPoint2, this.r1 = t.relativeAnchorPoint1, this.r2 = t.relativeAnchorPoint2, this.l1 = this.b1.linearVelocity, this.l2 = this.b2.linearVelocity, this.a1 = this.b1.angularVelocity, this.a2 = this.b2.angularVelocity, this.i1 = this.b1.inverseInertia, this.i2 = this.b2.inverseInertia, this.limitImpulse1 = 0, this.motorImpulse1 = 0, this.limitImpulse2 = 0, this.motorImpulse2 = 0, this.limitImpulse3 = 0, this.motorImpulse3 = 0, this.cfm1 = 0, this.cfm2 = 0, this.cfm3 = 0, this.weight = -1 } function L(t, i, s) { v.call(this, t), this.type = St, this.localAxis1 = t.localAxis1.clone().normalize(), this.localAxis2 = t.localAxis2.clone().normalize(), this.ax1 = new e, this.ax2 = new e, this.nor = new e, this.tan = new e, this.bin = new e, this.ac = new I(this, (new a).setFromUnitVectors(this.localAxis1, this.localAxis2)), this.limitMotor = new d(this.nor, !0), this.limitMotor.lowerLimit = i, this.limitMotor.upperLimit = s, this.t3 = new V(this, this.limitMotor, new d(this.tan, !0), new d(this.bin, !0)) } function S(t, i, s) { v.call(this, t), this.type = Lt, this.localAxis1 = t.localAxis1.clone().normalize(), this.localAxis2 = t.localAxis2.clone().normalize(); var h = (new o).setQuat((new a).setFromUnitVectors(this.localAxis1, this.localAxis2)); this.localAngle1 = (new e).tangent(this.localAxis1).normalize(), this.localAngle2 = this.localAngle1.clone().applyMatrix3(h, !0), this.ax1 = new e, this.ax2 = new e, this.an1 = new e, this.an2 = new e, this.tmp = new e, this.nor = new e, this.tan = new e, this.bin = new e, this.rotationalLimitMotor = new d(this.nor, !1), this.r3 = new N(this, this.rotationalLimitMotor, new d(this.tan, !0), new d(this.bin, !0)), this.translationalLimitMotor = new d(this.nor, !0), this.translationalLimitMotor.lowerLimit = i, this.translationalLimitMotor.upperLimit = s, this.t3 = new V(this, this.translationalLimitMotor, new d(this.tan, !0), new d(this.bin, !0)) } function P(t) { v.call(this, t), this.type = Vt, this.localAxis1 = t.localAxis1.clone().normalize(), this.localAxis2 = t.localAxis2.clone().normalize(), this.localAngle1 = new e, this.localAngle2 = new e; var i = Pt.dotVectors(this.localAxis1, this.localAxis2); if (i > -1 && i < 1) this.localAngle1.set(this.localAxis2.x - i * this.localAxis1.x, this.localAxis2.y - i * this.localAxis1.y, this.localAxis2.z - i * this.localAxis1.z).normalize(), this.localAngle2.set(this.localAxis1.x - i * this.localAxis2.x, this.localAxis1.y - i * this.localAxis2.y, this.localAxis1.z - i * this.localAxis2.z).normalize(); else { var s = (new o).setQuat((new a).setFromUnitVectors(this.localAxis1, this.localAxis2)); this.localAngle1.tangent(this.localAxis1).normalize(), this.localAngle2 = this.localAngle1.clone().applyMatrix3(s, !0) } this.ax1 = new e, this.ax2 = new e, this.an1 = new e, this.an2 = new e, this.tmp = new e, this.nor = new e, this.tan = new e, this.bin = new e, this.translationalLimitMotor = new d(this.tan, !0), this.translationalLimitMotor.frequency = 8, this.translationalLimitMotor.dampingRatio = 1, this.rotationalLimitMotor1 = new d(this.tan, !1), this.rotationalLimitMotor2 = new d(this.bin, !1), this.t3 = new V(this, new d(this.nor, !0), this.translationalLimitMotor, new d(this.bin, !0)), this.t3.weight = 1, this.r3 = new N(this, new d(this.nor, !0), this.rotationalLimitMotor1, this.rotationalLimitMotor2) } function T() { this.scale = 1, this.invScale = 1, this.body1 = null, this.body2 = null, this.localAnchorPoint1 = new e, this.localAnchorPoint2 = new e, this.localAxis1 = new e, this.localAxis2 = new e, this.allowCollision = !1 } function A() { this.mass = 0, this.inertia = new o } function j(t) { this.prev = null, this.next = null, this.shape = null, this.body = null, this.contact = t } function O() { this.lp1X = NaN, this.lp1Y = NaN, this.lp1Z = NaN, this.lp2X = NaN, this.lp2Y = NaN, this.lp2Z = NaN, this.impulse = NaN } function C() { this.warmStarted = !1, this.position = new e, this.localPoint1 = new e, this.localPoint2 = new e, this.normal = new e, this.tangent = new e, this.binormal = new e, this.normalImpulse = 0, this.tangentImpulse = 0, this.binormalImpulse = 0, this.normalDenominator = 0, this.tangentDenominator = 0, this.binormalDenominator = 0, this.penetration = 0 } function D() { this.body1 = null, this.body2 = null, this.numPoints = 0, this.points = [new C, new C, new C, new C] } function E() { this.nor = new e, this.tan = new e, this.bin = new e, this.norU1 = new e, this.tanU1 = new e, this.binU1 = new e, this.norU2 = new e, this.tanU2 = new e, this.binU2 = new e, this.norT1 = new e, this.tanT1 = new e, this.binT1 = new e, this.norT2 = new e, this.tanT2 = new e, this.binT2 = new e, this.norTU1 = new e, this.tanTU1 = new e, this.binTU1 = new e, this.norTU2 = new e, this.tanTU2 = new e, this.binTU2 = new e, this.norImp = 0, this.tanImp = 0, this.binImp = 0, this.norDen = 0, this.tanDen = 0, this.binDen = 0, this.norTar = 0, this.next = null, this.last = !1 } function B(t) { f.call(this), this.manifold = t, this.restitution = NaN, this.friction = NaN, this.p1 = null, this.p2 = null, this.lv1 = null, this.lv2 = null, this.av1 = null, this.av2 = null, this.i1 = null, this.i2 = null, this.tmp = new e, this.tmpC1 = new e, this.tmpC2 = new e, this.tmpP1 = new e, this.tmpP2 = new e, this.tmplv1 = new e, this.tmplv2 = new e, this.tmpav1 = new e, this.tmpav2 = new e, this.m1 = NaN, this.m2 = NaN, this.num = 0, this.ps = t.points, this.cs = new E, this.cs.next = new E, this.cs.next.next = new E, this.cs.next.next.next = new E } function F() { this.shape1 = null, this.shape2 = null, this.body1 = null, this.body2 = null, this.prev = null, this.next = null, this.persisting = !1, this.sleeping = !1, this.detector = null, this.constraint = null, this.touching = !1, this.close = !1, this.dist = Pt.INF, this.b1Link = new j(this), this.b2Link = new j(this), this.s1Link = new j(this), this.s2Link = new j(this), this.manifold = new D, this.buffer = [new O, new O, new O, new O], this.points = this.manifold.points, this.constraint = new B(this.manifold) } function q(t, i) { this.position = t || new e, this.orientation = i || new a, this.scale = 1, this.invScale = 1, this.mesh = null, this.id = NaN, this.name = "", this.prev = null, this.next = null, this.type = dt, this.massInfo = new A, this.newPosition = new e, this.controlPos = !1, this.newOrientation = new a, this.newRotation = new e, this.currentRotation = new e, this.controlRot = !1, this.controlRotInTime = !1, this.quaternion = new a, this.pos = new e, this.linearVelocity = new e, this.angularVelocity = new e, this.parent = null, this.contactLink = null, this.numContacts = 0, this.shapes = null, this.numShapes = 0, this.jointLink = null, this.numJoints = 0, this.sleepPosition = new e, this.sleepOrientation = new a, this.isStatic = !1, this.isDynamic = !1, this.isKinematic = !1, this.rotation = new o, this.mass = 0, this.inverseMass = 0, this.inverseInertia = new o, this.localInertia = new o, this.inverseLocalInertia = new o, this.tmpInertia = new o, this.addedToIsland = !1, this.allowSleep = !0, this.sleepTime = 0, this.sleeping = !1 } function U(t, i) { this.shape1 = t || null, this.shape2 = i || null } function R() { this.types = pt, this.numPairChecks = 0, this.numPairs = 0, this.pairs = [] } function _() { return At++ } function J(t) { this.shape = t, this.aabb = t.aabb } function W(t) { J.call(this, t), this.id = _() } function H() { R.call(this), this.types = ut, this.proxies = [] } function Q() { this.numElements = 0, this.bufferSize = 256, this.elements = [], this.elements.length = this.bufferSize, this.stack = new Float32Array(64) } function X(t, i) { this.proxy = t, this.pair = null, this.min1 = null, this.max1 = null, this.min2 = null, this.max2 = null, this.max = i, this.value = 0 } function Y(t, i) { J.call(this, i), this.belongsTo = 0, this.max = [], this.min = [], this.sap = t, this.min[0] = new X(this, !1), this.max[0] = new X(this, !0), this.min[1] = new X(this, !1), this.max[1] = new X(this, !0), this.min[2] = new X(this, !1), this.max[2] = new X(this, !0), this.max[0].pair = this.min[0], this.max[1].pair = this.min[1], this.max[2].pair = this.min[2], this.min[0].min1 = this.min[1], this.min[0].max1 = this.max[1], this.min[0].min2 = this.min[2], this.min[0].max2 = this.max[2], this.min[1].min1 = this.min[0], this.min[1].max1 = this.max[0], this.min[1].min2 = this.min[2], this.min[1].max2 = this.max[2], this.min[2].min1 = this.min[0], this.min[2].max1 = this.max[0], this.min[2].min2 = this.min[1], this.min[2].max2 = this.max[1] } function Z() { R.call(this), this.types = yt, this.numElementsD = 0, this.numElementsS = 0, this.axesD = [new Q, new Q, new Q], this.axesS = [new Q, new Q, new Q], this.index1 = 0, this.index2 = 1 } function K() { this.child1 = null, this.child2 = null, this.parent = null, this.proxy = null, this.height = 0, this.aabb = new n } function G() { this.root = null, this.freeNodes = [], this.freeNodes.length = 16384, this.numFreeNodes = 0, this.aabb = new n } function $(t) { J.call(this, t), this.leaf = new K, this.leaf.proxy = this } function tt() { R.call(this), this.types = xt, this.tree = new G, this.stack = [], this.leaves = [], this.numLeaves = 0 } function it() { this.flip = !1 } function st() { it.call(this), this.clipVertices1 = new Float32Array(24), this.clipVertices2 = new Float32Array(24), this.used = new Float32Array(8), this.INF = 1 / 0 } function ht(t) { it.call(this), this.flip = t } function et() { it.call(this) } function at(t) { it.call(this), this.flip = t } function ot(t) { it.call(this), this.flip = t } function nt() { it.call(this) } function rt(t) { it.call(this), this.flip = t, this.n = new e, this.p = new e } function lt(t) { it.call(this), this.flip = t, this.n = new e, this.p = new e, this.dix = new e, this.diy = new e, this.diz = new e, this.cc = new e, this.cc2 = new e } function ct(t) { switch (t instanceof Object || (t = {}), this.scale = t.worldscale || 1, this.invScale = 1 / this.scale, this.timeStep = t.timestep || .01666, this.timerate = 1e3 * this.timeStep, this.timer = null, this.preLoop = null, this.postLoop = null, this.numIterations = t.iterations || 8, t.broadphase || 2) { case 1: this.broadPhase = new H; break; case 2: default: this.broadPhase = new Z; break; case 3: this.broadPhase = new tt }this.Btypes = ["None", "BruteForce", "Sweep & Prune", "Bounding Volume Tree"], this.broadPhaseType = this.Btypes[t.broadphase || 2], this.performance = null, this.isStat = void 0 !== t.info && t.info, this.isStat && (this.performance = new h(this)), this.enableRandomizer = void 0 === t.random || t.random, this.rigidBodies = null, this.numRigidBodies = 0, this.contacts = null, this.unusedContacts = null, this.numContacts = 0, this.numContactPoints = 0, this.joints = null, this.numJoints = 0, this.numIslands = 0, this.gravity = new e(0, -9.8, 0), void 0 !== t.gravity && this.gravity.fromArray(t.gravity); this.detectors = [], this.detectors.length = 5; for (var i = 5; i--;)this.detectors[i] = [], this.detectors[i].length = 5; this.detectors[bt][bt] = new nt, this.detectors[bt][vt] = new at(!1), this.detectors[vt][bt] = new at(!0), this.detectors[vt][vt] = new st, this.detectors[zt][zt] = new et, this.detectors[zt][vt] = new ht(!0), this.detectors[vt][zt] = new ht(!1), this.detectors[zt][bt] = new ot(!0), this.detectors[bt][zt] = new ot(!1), this.detectors[Nt][bt] = new rt(!0), this.detectors[bt][Nt] = new rt(!1), this.detectors[Nt][vt] = new lt(!0), this.detectors[vt][Nt] = new lt(!1), this.randX = 65535, this.randA = 98765, this.randB = 123456789, this.islandRigidBodies = [], this.islandStack = [], this.islandConstraints = [] } void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Math.sign && (Math.sign = function(t) { return t < 0 ? -1 : t > 0 ? 1 : +t }), void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", { get: function() { return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1] } }), void 0 === Object.assign && function() { Object.assign = function(t) { if (void 0 === t || null === t) throw new TypeError("Cannot convert undefined or null to object"); for (var i = Object(t), s = 1; s < arguments.length; s++) { var h = arguments[s]; if (void 0 !== h && null !== h) for (var e in h) Object.prototype.hasOwnProperty.call(h, e) && (i[e] = h[e]) } return i } }(); var mt = "1.0.9", pt = 0, ut = 1, yt = 2, xt = 3, dt = 0, ft = 0, bt = 1, vt = 2, zt = 3, Nt = 4, kt = 5, wt = 0, Mt = 1, gt = 2, It = 3, Vt = 4, Lt = 5, St = 6, Pt = { sqrt: Math.sqrt, abs: Math.abs, floor: Math.floor, cos: Math.cos, sin: Math.sin, acos: Math.acos, asin: Math.asin, atan2: Math.atan2, round: Math.round, pow: Math.pow, max: Math.max, min: Math.min, random: Math.random, degtorad: .017453292519943295, radtodeg: 57.29577951308232, PI: 3.141592653589793, TwoPI: 6.283185307179586, PI90: 1.570796326794896, PI270: 4.712388980384689, INF: 1 / 0, EPZ: 1e-5, EPZ2: 1e-6, lerp: function(t, i, s) { return (1 - s) * t + s * i }, randInt: function(t, i) { return t + Pt.floor(Pt.random() * (i - t + 1)) }, rand: function(t, i) { return t + Pt.random() * (i - t) }, generateUUID: function() { var t, i = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), s = new Array(36), h = 0; return function() { for (var e = 0; e < 36; e++)8 === e || 13 === e || 18 === e || 23 === e ? s[e] = "-" : 14 === e ? s[e] = "4" : (h <= 2 && (h = 33554432 + 16777216 * Math.random() | 0), t = 15 & h, h >>= 4, s[e] = i[19 === e ? 3 & t | 8 : t]); return s.join("") } }(), int: function(t) { return Pt.floor(t) }, fix: function(t, i) { return t.toFixed(i || 3, 10) }, clamp: function(t, i, s) { return Pt.max(i, Pt.min(s, t)) }, distance: function(t, i) { var s = i[0] - t[0], h = i[1] - t[1], e = i[2] - t[2]; return Pt.sqrt(s * s + h * h + e * e) }, acosClamp: function(t) { return t > 1 ? 0 : t < -1 ? Pt.PI : Pt.acos(t) }, distanceVector: function(t, i) { var s = t.x - i.x, h = t.y - i.y, e = t.z - i.z; return s * s + h * h + e * e }, dotVectors: function(t, i) { return t.x * i.x + t.y * i.y + t.z * i.z } }; Object.assign(h.prototype, { setTime: function(t) { this.times[t || 0] = performance.now() }, resetMax: function() { this.MaxBroadPhaseTime = 0, this.MaxNarrowPhaseTime = 0, this.MaxSolvingTime = 0, this.MaxTotalTime = 0, this.MaxUpdateTime = 0 }, calcBroadPhase: function() { this.setTime(2), this.broadPhaseTime = this.times[2] - this.times[1] }, calcNarrowPhase: function() { this.setTime(3), this.narrowPhaseTime = this.times[3] - this.times[2] }, calcEnd: function() { this.setTime(2), this.solvingTime = this.times[2] - this.times[1], this.totalTime = this.times[2] - this.times[0], this.updateTime = this.totalTime - (this.broadPhaseTime + this.narrowPhaseTime + this.solvingTime), 100 === this.tt && this.resetMax(), this.tt > 100 && (this.broadPhaseTime > this.MaxBroadPhaseTime && (this.MaxBroadPhaseTime = this.broadPhaseTime), this.narrowPhaseTime > this.MaxNarrowPhaseTime && (this.MaxNarrowPhaseTime = this.narrowPhaseTime), this.solvingTime > this.MaxSolvingTime && (this.MaxSolvingTime = this.solvingTime), this.totalTime > this.MaxTotalTime && (this.MaxTotalTime = this.totalTime), this.updateTime > this.MaxUpdateTime && (this.MaxUpdateTime = this.updateTime)), this.upfps(), ++this.tt > 500 && (this.tt = 0) }, upfps: function() { this.f[1] = Date.now(), this.f[1] - 1e3 > this.f[0] && (this.f[0] = this.f[1], this.fps = this.f[2], this.f[2] = 0), this.f[2]++ }, show: function() { return ["Oimo.js " + this.version + "<br>", this.broadPhase + "<br><br>", "FPS: " + this.fps + " fps<br><br>", "rigidbody " + this.parent.numRigidBodies + "<br>", "contact &nbsp;&nbsp;" + this.parent.numContacts + "<br>", "ct-point &nbsp;" + this.parent.numContactPoints + "<br>", "paircheck " + this.parent.broadPhase.numPairChecks + "<br>", "island &nbsp;&nbsp;&nbsp;" + this.parent.numIslands + "<br><br>", "Time in milliseconds<br><br>", "broadphase &nbsp;" + Pt.fix(this.broadPhaseTime) + " | " + Pt.fix(this.MaxBroadPhaseTime) + "<br>", "narrowphase " + Pt.fix(this.narrowPhaseTime) + " | " + Pt.fix(this.MaxNarrowPhaseTime) + "<br>", "solving &nbsp;&nbsp;&nbsp;&nbsp;" + Pt.fix(this.solvingTime) + " | " + Pt.fix(this.MaxSolvingTime) + "<br>", "total &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" + Pt.fix(this.totalTime) + " | " + Pt.fix(this.MaxTotalTime) + "<br>", "updating &nbsp;&nbsp;&nbsp;" + Pt.fix(this.updateTime) + " | " + Pt.fix(this.MaxUpdateTime) + "<br>"].join("\n") }, toArray: function() { return this.infos[0] = this.parent.broadPhase.types, this.infos[1] = this.parent.numRigidBodies, this.infos[2] = this.parent.numContacts, this.infos[3] = this.parent.broadPhase.numPairChecks, this.infos[4] = this.parent.numContactPoints, this.infos[5] = this.parent.numIslands, this.infos[6] = this.broadPhaseTime, this.infos[7] = this.narrowPhaseTime, this.infos[8] = this.solvingTime, this.infos[9] = this.updateTime, this.infos[10] = this.totalTime, this.infos[11] = this.fps, this.infos } }), Object.assign(e.prototype, { Vec3: !0, set: function(t, i, s) { return this.x = t, this.y = i, this.z = s, this }, add: function(t, i) { return void 0 !== i ? this.addVectors(t, i) : (this.x += t.x, this.y += t.y, this.z += t.z, this) }, addVectors: function(t, i) { return this.x = t.x + i.x, this.y = t.y + i.y, this.z = t.z + i.z, this }, addEqual: function(t) { return this.x += t.x, this.y += t.y, this.z += t.z, this }, sub: function(t, i) { return void 0 !== i ? this.subVectors(t, i) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this) }, subVectors: function(t, i) { return this.x = t.x - i.x, this.y = t.y - i.y, this.z = t.z - i.z, this }, subEqual: function(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z, this }, scale: function(t, i) { return this.x = t.x * i, this.y = t.y * i, this.z = t.z * i, this }, scaleEqual: function(t) { return this.x *= t, this.y *= t, this.z *= t, this }, multiply: function(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z, this }, multiplyScalar: function(t) { return this.x *= t, this.y *= t, this.z *= t, this }, addScaledVector: function(t, i) { return this.x += t.x * i, this.y += t.y * i, this.z += t.z * i, this }, subScaledVector: function(t, i) { return this.x -= t.x * i, this.y -= t.y * i, this.z -= t.z * i, this }, cross: function(t, i) { if (void 0 !== i) return this.crossVectors(t, i); var s = this.x, h = this.y, e = this.z; return this.x = h * t.z - e * t.y, this.y = e * t.x - s * t.z, this.z = s * t.y - h * t.x, this }, crossVectors: function(t, i) { var s = t.x, h = t.y, e = t.z, a = i.x, o = i.y, n = i.z; return this.x = h * n - e * o, this.y = e * a - s * n, this.z = s * o - h * a, this }, tangent: function(t) { var i = t.x, s = t.y, h = t.z; return this.x = s * i - h * h, this.y = -h * s - i * i, this.z = i * h + s * s, this }, invert: function(t) { return this.x = -t.x, this.y = -t.y, this.z = -t.z, this }, negate: function() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this }, dot: function(t) { return this.x * t.x + this.y * t.y + this.z * t.z }, addition: function() { return this.x + this.y + this.z }, lengthSq: function() { return this.x * this.x + this.y * this.y + this.z * this.z }, length: function() { return Pt.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }, copy: function(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this }, applyMatrix3: function(t, i) { var s = this.x, h = this.y, e = this.z, a = t.elements; return i ? (this.x = a[0] * s + a[1] * h + a[2] * e, this.y = a[3] * s + a[4] * h + a[5] * e, this.z = a[6] * s + a[7] * h + a[8] * e) : (this.x = a[0] * s + a[3] * h + a[6] * e, this.y = a[1] * s + a[4] * h + a[7] * e, this.z = a[2] * s + a[5] * h + a[8] * e), this }, applyQuaternion: function(t) { var i = this.x, s = this.y, h = this.z, e = t.x, a = t.y, o = t.z, n = t.w, r = n * i + a * h - o * s, l = n * s + o * i - e * h, c = n * h + e * s - a * i, m = -e * i - a * s - o * h; return this.x = r * n + m * -e + l * -o - c * -a, this.y = l * n + m * -a + c * -e - r * -o, this.z = c * n + m * -o + r * -a - l * -e, this }, testZero: function() { return 0 !== this.x || 0 !== this.y || 0 !== this.z }, testDiff: function(t) { return !this.equals(t) }, equals: function(t) { return t.x === this.x && t.y === this.y && t.z === this.z }, clone: function() { return new this.constructor(this.x, this.y, this.z) }, toString: function() { return "Vec3[" + this.x.toFixed(4) + ", " + this.y.toFixed(4) + ", " + this.z.toFixed(4) + "]" }, multiplyScalar: function(t) { return isFinite(t) ? (this.x *= t, this.y *= t, this.z *= t) : (this.x = 0, this.y = 0, this.z = 0), this }, divideScalar: function(t) { return this.multiplyScalar(1 / t) }, normalize: function() { return this.divideScalar(this.length()) }, toArray: function(t, i) { void 0 === i && (i = 0), t[i] = this.x, t[i + 1] = this.y, t[i + 2] = this.z }, fromArray: function(t, i) { return void 0 === i && (i = 0), this.x = t[i], this.y = t[i + 1], this.z = t[i + 2], this } }), Object.assign(a.prototype, { Quat: !0, set: function(t, i, s, h) { return this.x = t, this.y = i, this.z = s, this.w = h, this }, addTime: function(t, i) { var s = t.x, h = t.y, e = t.z, a = this.w, o = this.x, n = this.y, r = this.z; return i *= .5, this.x += i * (s * a + h * r - e * n), this.y += i * (h * a + e * o - s * r), this.z += i * (e * a + s * n - h * o), this.w += i * (-s * o - h * n - e * r), this.normalize(), this }, multiply: function(t, i) { return void 0 !== i ? this.multiplyQuaternions(t, i) : this.multiplyQuaternions(this, t) }, multiplyQuaternions: function(t, i) { var s = t.x, h = t.y, e = t.z, a = t.w, o = i.x, n = i.y, r = i.z, l = i.w; return this.x = s * l + a * o + h * r - e * n, this.y = h * l + a * n + e * o - s * r, this.z = e * l + a * r + s * n - h * o, this.w = a * l - s * o - h * n - e * r, this }, setFromUnitVectors: function(t, i) { var s = new e, h = t.dot(i) + 1; return h < Pt.EPS2 ? (h = 0, Pt.abs(t.x) > Pt.abs(t.z) ? s.set(-t.y, t.x, 0) : s.set(0, -t.z, t.y)) : s.crossVectors(t, i), this._x = s.x, this._y = s.y, this._z = s.z, this._w = h, this.normalize() }, arc: function(t, i) { var s = t.x, h = t.y, e = t.z, a = i.x, o = i.y, n = i.z, r = s * a + h * o + e * n; if (-1 == r) return a = h * s - e * e, o = -e * h - s * s, n = s * e + h * h, r = 1 / Pt.sqrt(a * a + o * o + n * n), this.w = 0, this.x = a * r, this.y = o * r, this.z = n * r, this; var l = h * n - e * o, c = e * a - s * n, m = s * o - h * a; return this.w = Pt.sqrt(.5 * (1 + r)), r = .5 / this.w, this.x = l * r, this.y = c * r, this.z = m * r, this }, normalize: function() { var t = this.length(); return 0 === t ? this.set(0, 0, 0, 1) : (t = 1 / t, this.x = this.x * t, this.y = this.y * t, this.z = this.z * t, this.w = this.w * t), this }, inverse: function() { return this.conjugate().normalize() }, invert: function(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this.conjugate().normalize(), this }, conjugate: function() { return this.x *= -1, this.y *= -1, this.z *= -1, this }, length: function() { return Pt.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }, lengthSq: function() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }, copy: function(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this }, clone: function(t) { return new a(this.x, this.y, this.z, this.w) }, testDiff: function(t) { return !this.equals(t) }, equals: function(t) { return this.x === t.x && this.y === t.y && this.z === t.z && this.w === t.w }, toString: function() { return "Quat[" + this.x.toFixed(4) + ", (" + this.y.toFixed(4) + ", " + this.z.toFixed(4) + ", " + this.w.toFixed(4) + ")]" }, setFromEuler: function(t, i, s) { var h = Math.cos(.5 * t), e = Math.cos(.5 * i), a = Math.cos(.5 * s), o = Math.sin(.5 * t), n = Math.sin(.5 * i), r = Math.sin(.5 * s); return this.x = o * e * a + h * n * r, this.y = h * n * a - o * e * r, this.z = h * e * r + o * n * a, this.w = h * e * a - o * n * r, this }, setFromAxis: function(t, i) { t.normalize(), i *= .5; var s = Pt.sin(i); return this.x = s * t.x, this.y = s * t.y, this.z = s * t.z, this.w = Pt.cos(i), this }, setFromMat33: function(t) { var i, s = t[0] + t[4] + t[8]; if (s > 0) i = Pt.sqrt(s + 1), this.w = .5 / i, i = .5 / i, this.x = (t[5] - t[7]) * i, this.y = (t[6] - t[2]) * i, this.z = (t[1] - t[3]) * i; else { var h = [], e = 0; t[4] > t[0] && (e = 1), t[8] > t[3 * e + e] && (e = 2); var a = (e + 1) % 3, o = (e + 2) % 3; i = Pt.sqrt(t[3 * e + e] - t[3 * a + a] - t[3 * o + o] + 1), h[e] = .5 * fRoot, i = .5 / fRoot, this.w = (t[3 * a + o] - t[3 * o + a]) * i, h[a] = (t[3 * a + e] + t[3 * e + a]) * i, h[o] = (t[3 * o + e] + t[3 * e + o]) * i, this.x = h[1], this.y = h[2], this.z = h[3] } return this }, toArray: function(t, i) { t[i = i || 0] = this.x, t[i + 1] = this.y, t[i + 2] = this.z, t[i + 3] = this.w }, fromArray: function(t, i) { return i = i || 0, this.set(t[i], t[i + 1], t[i + 2], t[i + 3]), this } }), Object.assign(o.prototype, { Mat33: !0, set: function(t, i, s, h, e, a, o, n, r) { var l = this.elements; return l[0] = t, l[1] = i, l[2] = s, l[3] = h, l[4] = e, l[5] = a, l[6] = o, l[7] = n, l[8] = r, this }, add: function(t, i) { if (void 0 !== i) return this.addMatrixs(t, i); var s = this.elements, h = t.elements; return s[0] += h[0], s[1] += h[1], s[2] += h[2], s[3] += h[3], s[4] += h[4], s[5] += h[5], s[6] += h[6], s[7] += h[7], s[8] += h[8], this }, addMatrixs: function(t, i) { var s = this.elements, h = t.elements, e = i.elements; return s[0] = h[0] + e[0], s[1] = h[1] + e[1], s[2] = h[2] + e[2], s[3] = h[3] + e[3], s[4] = h[4] + e[4], s[5] = h[5] + e[5], s[6] = h[6] + e[6], s[7] = h[7] + e[7], s[8] = h[8] + e[8], this }, addEqual: function(t) { var i = this.elements, s = t.elements; return i[0] += s[0], i[1] += s[1], i[2] += s[2], i[3] += s[3], i[4] += s[4], i[5] += s[5], i[6] += s[6], i[7] += s[7], i[8] += s[8], this }, sub: function(t, i) { if (void 0 !== i) return this.subMatrixs(t, i); var s = this.elements, h = t.elements; return s[0] -= h[0], s[1] -= h[1], s[2] -= h[2], s[3] -= h[3], s[4] -= h[4], s[5] -= h[5], s[6] -= h[6], s[7] -= h[7], s[8] -= h[8], this }, subMatrixs: function(t, i) { var s = this.elements, h = t.elements, e = i.elements; return s[0] = h[0] - e[0], s[1] = h[1] - e[1], s[2] = h[2] - e[2], s[3] = h[3] - e[3], s[4] = h[4] - e[4], s[5] = h[5] - e[5], s[6] = h[6] - e[6], s[7] = h[7] - e[7], s[8] = h[8] - e[8], this }, subEqual: function(t) { var i = this.elements, s = t.elements; return i[0] -= s[0], i[1] -= s[1], i[2] -= s[2], i[3] -= s[3], i[4] -= s[4], i[5] -= s[5], i[6] -= s[6], i[7] -= s[7], i[8] -= s[8], this }, scale: function(t, i) { var s = this.elements, h = t.elements; return s[0] = h[0] * i, s[1] = h[1] * i, s[2] = h[2] * i, s[3] = h[3] * i, s[4] = h[4] * i, s[5] = h[5] * i, s[6] = h[6] * i, s[7] = h[7] * i, s[8] = h[8] * i, this }, scaleEqual: function(t) { var i = this.elements; return i[0] *= t, i[1] *= t, i[2] *= t, i[3] *= t, i[4] *= t, i[5] *= t, i[6] *= t, i[7] *= t, i[8] *= t, this }, multiplyMatrices: function(t, i, s) { s && (i = i.clone().transpose()); var h = this.elements, e = t.elements, a = i.elements, o = e[0], n = e[3], r = e[6], l = e[1], c = e[4], m = e[7], p = e[2], u = e[5], y = e[8], x = a[0], d = a[3], f = a[6], b = a[1], v = a[4], z = a[7], N = a[2], k = a[5], w = a[8]; return h[0] = o * x + l * d + p * f, h[1] = o * b + l * v + p * z, h[2] = o * N + l * k + p * w, h[3] = n * x + c * d + u * f, h[4] = n * b + c * v + u * z, h[5] = n * N + c * k + u * w, h[6] = r * x + m * d + y * f, h[7] = r * b + m * v + y * z, h[8] = r * N + m * k + y * w, this }, transpose: function(t) { if (void 0 !== t) { var i = t.elements; return this.set(i[0], i[3], i[6], i[1], i[4], i[7], i[2], i[5], i[8]), this } var s = this.elements, h = s[1], e = s[2], a = s[5]; return s[1] = s[3], s[2] = s[6], s[3] = h, s[5] = s[7], s[6] = e, s[7] = a, this }, setQuat: function(t) { var i = this.elements, s = t.x, h = t.y, e = t.z, a = t.w, o = s + s, n = h + h, r = e + e, l = s * o, c = s * n, m = s * r, p = h * n, u = h * r, y = e * r, x = a * o, d = a * n, f = a * r; return i[0] = 1 - (p + y), i[1] = c - f, i[2] = m + d, i[3] = c + f, i[4] = 1 - (l + y), i[5] = u - x, i[6] = m - d, i[7] = u + x, i[8] = 1 - (l + p), this }, invert: function(t) { var i = this.elements, s = t.elements, h = s[0], e = s[3], a = s[6], o = s[1], n = s[4], r = s[7], l = s[2], c = s[5], m = s[8], p = m * n - c * r, u = -m * e + c * a, y = r * e - n * a, x = h * p + o * u + l * y; return 0 === x ? (console.log("can't invert matrix, determinant is 0"), this.identity()) : (x = 1 / x, i[0] = p * x, i[1] = (-m * o + l * r) * x, i[2] = (c * o - l * n) * x, i[3] = u * x, i[4] = (m * h - l * a) * x, i[5] = (-c * h + l * e) * x, i[6] = y * x, i[7] = (-r * h + o * a) * x, i[8] = (n * h - o * e) * x, this) }, addOffset: function(t, i) { var s = i.x, h = i.y, e = i.z, a = this.elements; a[0] += t * (h * h + e * e), a[4] += t * (s * s + e * e), a[8] += t * (s * s + h * h); var o = t * s * h, n = t * h * e, r = t * e * s; return a[1] -= o, a[3] -= o, a[2] -= n, a[6] -= n, a[5] -= r, a[7] -= r, this }, subOffset: function(t, i) { var s = i.x, h = i.y, e = i.z, a = this.elements; a[0] -= t * (h * h + e * e), a[4] -= t * (s * s + e * e), a[8] -= t * (s * s + h * h); var o = t * s * h, n = t * h * e, r = t * e * s; return a[1] += o, a[3] += o, a[2] += n, a[6] += n, a[5] += r, a[7] += r, this }, multiplyScalar: function(t) { var i = this.elements; return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= t, i[4] *= t, i[7] *= t, i[2] *= t, i[5] *= t, i[8] *= t, this }, identity: function() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this }, clone: function() { return (new o).fromArray(this.elements) }, copy: function(t) { for (var i = 0; i < 9; i++)this.elements[i] = t.elements[i]; return this }, determinant: function() { var t = this.elements, i = t[0], s = t[1], h = t[2], e = t[3], a = t[4], o = t[5], n = t[6], r = t[7], l = t[8]; return i * a * l - i * o * r - s * e * l + s * o * n + h * e * r - h * a * n }, fromArray: function(t, i) { void 0 === i && (i = 0); for (var s = 0; s < 9; s++)this.elements[s] = t[s + i]; return this }, toArray: function(t, i) { void 0 === t && (t = []), void 0 === i && (i = 0); var s = this.elements; return t[i] = s[0], t[i + 1] = s[1], t[i + 2] = s[2], t[i + 3] = s[3], t[i + 4] = s[4], t[i + 5] = s[5], t[i + 6] = s[6], t[i + 7] = s[7], t[i + 8] = s[8], t } }), Object.assign(n.prototype, { AABB: !0, set: function(t, i, s, h, e, a) { var o = this.elements; return o[0] = t, o[3] = i, o[1] = s, o[4] = h, o[2] = e, o[5] = a, this }, intersectTest: function(t) { var i = this.elements, s = t.elements; return i[0] > s[3] || i[1] > s[4] || i[2] > s[5] || i[3] < s[0] || i[4] < s[1] || i[5] < s[2] }, intersectTestTwo: function(t) { var i = this.elements, s = t.elements; return i[0] < s[0] || i[1] < s[1] || i[2] < s[2] || i[3] > s[3] || i[4] > s[4] || i[5] > s[5] }, clone: function() { return (new this.constructor).fromArray(this.elements) }, copy: function(t, i) { var s = i || 0, h = t.elements; return this.set(h[0] - s, h[3] + s, h[1] - s, h[4] + s, h[2] - s, h[5] + s), this }, fromArray: function(t) { return this.elements.set(t), this }, combine: function(t, i) { var s = t.elements, h = i.elements, e = this.elements; return e[0] = s[0] < h[0] ? s[0] : h[0], e[1] = s[1] < h[1] ? s[1] : h[1], e[2] = s[2] < h[2] ? s[2] : h[2], e[3] = s[3] > h[3] ? s[3] : h[3], e[4] = s[4] > h[4] ? s[4] : h[4], e[5] = s[5] > h[5] ? s[5] : h[5], this }, surfaceArea: function() { var t = this.elements, i = t[3] - t[0], s = t[4] - t[1], h = t[5] - t[2]; return 2 * (i * (s + h) + s * h) }, intersectsWithPoint: function(t, i, s) { var h = this.elements; return t >= h[0] && t <= h[3] && i >= h[1] && i <= h[4] && s >= h[2] && s <= h[5] }, setFromPoints: function(t) { this.makeEmpty(); for (var i = 0; i < t.length; i++)this.expandByPoint(t[i]) }, makeEmpty: function() { this.set(-1 / 0, -1 / 0, -1 / 0, 1 / 0, 1 / 0, 1 / 0) }, expandByPoint: function(t) { var i = this.elements; this.set(Pt.min(i[0], t.x), Pt.min(i[1], t.y), Pt.min(i[2], t.z), Pt.max(i[3], t.x), Pt.max(i[4], t.y), Pt.max(i[5], t.z)) }, expandByScalar: function(t) { var i = this.elements; i[0] += -t, i[1] += -t, i[2] += -t, i[3] += t, i[4] += t, i[5] += t } }); var Tt = 0; Object.assign(l.prototype, { Shape: !0, calculateMassInfo: function(t) { s("Shape", "Inheritance error.") }, updateProxy: function() { s("Shape", "Inheritance error.") } }), c.prototype = Object.assign(Object.create(l.prototype), { constructor: c, calculateMassInfo: function(t) { var i = this.width * this.height * this.depth * this.density; t.mass = i, t.inertia.set(i * (this.height * this.height + this.depth * this.depth) * (1 / 12), 0, 0, 0, i * (this.width * this.width + this.depth * this.depth) * (1 / 12), 0, 0, 0, i * (this.width * this.width + this.height * this.height) * (1 / 12)) }, updateProxy: function() { var t = this.rotation.elements, i = this.dimentions; i[0] = t[0], i[1] = t[3], i[2] = t[6], i[3] = t[1], i[4] = t[4], i[5] = t[7], i[6] = t[2], i[7] = t[5], i[8] = t[8], i[9] = t[0] * this.halfWidth, i[10] = t[3] * this.halfWidth, i[11] = t[6] * this.halfWidth, i[12] = t[1] * this.halfHeight, i[13] = t[4] * this.halfHeight, i[14] = t[7] * this.halfHeight, i[15] = t[2] * this.halfDepth, i[16] = t[5] * this.halfDepth, i[17] = t[8] * this.halfDepth; var s = i[9], h = i[10], e = i[11], a = i[12], o = i[13], n = i[14], r = i[15], l = i[16], c = i[17], m = this.position.x, p = this.position.y, u = this.position.z, y = this.elements; y[0] = m + s + a + r, y[1] = p + h + o + l, y[2] = u + e + n + c, y[3] = m + s + a - r, y[4] = p + h + o - l, y[5] = u + e + n - c, y[6] = m + s - a + r, y[7] = p + h - o + l, y[8] = u + e - n + c, y[9] = m + s - a - r, y[10] = p + h - o - l, y[11] = u + e - n - c, y[12] = m - s + a + r, y[13] = p - h + o + l, y[14] = u - e + n + c, y[15] = m - s + a - r, y[16] = p - h + o - l, y[17] = u - e + n - c, y[18] = m - s - a + r, y[19] = p - h - o + l, y[20] = u - e - n + c, y[21] = m - s - a - r, y[22] = p - h - o - l, y[23] = u - e - n - c; var x = i[9] < 0 ? -i[9] : i[9], d = i[10] < 0 ? -i[10] : i[10], f = i[11] < 0 ? -i[11] : i[11]; x = i[12] < 0 ? x - i[12] : x + i[12], d = i[13] < 0 ? d - i[13] : d + i[13], f = i[14] < 0 ? f - i[14] : f + i[14], x = i[15] < 0 ? x - i[15] : x + i[15], d = i[16] < 0 ? d - i[16] : d + i[16], f = i[17] < 0 ? f - i[17] : f + i[17]; var b = .005; this.aabb.set(this.position.x - x - b, this.position.x + x + b, this.position.y - d - b, this.position.y + d + b, this.position.z - f - b, this.position.z + f + b), null != this.proxy && this.proxy.update() } }), m.prototype = Object.assign(Object.create(l.prototype), { constructor: m, volume: function() { return Pt.PI * this.radius * 1.333333 }, calculateMassInfo: function(t) { var i = this.volume() * this.radius * this.radius * this.density; t.mass = i; var s = i * this.radius * this.radius * .4; t.inertia.set(s, 0, 0, 0, s, 0, 0, 0, s) }, updateProxy: function() { var t = .005; this.aabb.set(this.position.x - this.radius - t, this.position.x + this.radius + t, this.position.y - this.radius - t, this.position.y + this.radius + t, this.position.z - this.radius - t, this.position.z + this.radius + t), null != this.proxy && this.proxy.update() } }), p.prototype = Object.assign(Object.create(l.prototype), { constructor: p, calculateMassInfo: function(t) { var i = this.radius * this.radius, s = Pt.PI * i * this.height * this.density, h = (.25 * i + .0833 * this.height * this.height) * s, e = .5 * i; t.mass = s, t.inertia.set(h, 0, 0, 0, e, 0, 0, 0, h) }, updateProxy: function() { var t, i, s, h, e, a, o, n, r, l, c, m = this.rotation.elements; e = m[1] * m[1], a = m[4] * m[4], o = m[7] * m[7], this.normalDirection.set(m[1], m[4], m[7]), this.halfDirection.scale(this.normalDirection, this.halfHeight), i = 1 - e, (t = Pt.sqrt(i * i + e * a + e * o)) > 0 && (t = this.radius / t), i *= t, s = 1 - a, (t = Pt.sqrt(a * e + s * s + a * o)) > 0 && (t = this.radius / t), s *= t, h = 1 - o, (t = Pt.sqrt(o * e + o * a + h * h)) > 0 && (t = this.radius / t), h *= t, n = this.halfDirection.x < 0 ? -this.halfDirection.x : this.halfDirection.x, r = this.halfDirection.y < 0 ? -this.halfDirection.y : this.halfDirection.y, l = this.halfDirection.z < 0 ? -this.halfDirection.z : this.halfDirection.z, n = i < 0 ? n - i : n + i, r = s < 0 ? r - s : r + s, l = h < 0 ? l - h : l + h, c = .005, this.aabb.set(this.position.x - n - c, this.position.x + n + c, this.position.y - r - c, this.position.y + r + c, this.position.z - l - c, this.position.z + l + c), null != this.proxy && this.proxy.update() } }), u.prototype = Object.assign(Object.create(l.prototype), { constructor: u, volume: function() { return Number.MAX_VALUE }, calculateMassInfo: function(t) { t.mass = this.density; t.inertia.set(1, 0, 0, 0, 1, 0, 0, 0, 1) }, updateProxy: function() { var t = .005, i = -Pt.INF, s = Pt.INF, h = this.normal; this.aabb.set(-1 === h.x ? this.position.x - t : i, 1 === h.x ? this.position.x + t : s, -1 === h.y ? this.position.y - t : i, 1 === h.y ? this.position.y + t : s, -1 === h.z ? this.position.z - t : i, 1 === h.z ? this.position.z + t : s), null != this.proxy && this.proxy.update() } }), y.prototype = Object.assign(Object.create(l.prototype), { constructor: y, volume: function() { return Number.MAX_VALUE }, calculateMassInfo: function(t) { t.inertia.set(0, 0, 0, 0, 0, 0, 0, 0, 0) }, updateProxy: function() { this.aabb.set(this.position.x - 0, this.position.x + 0, this.position.y - 0, this.position.y + 0, this.position.z - 0, this.position.z + 0), null != this.proxy && this.proxy.update() } }), Object.assign(d.prototype, { LimitMotor: !0, setLimit: function(t, i) { this.lowerLimit = t, this.upperLimit = i }, setMotor: function(t, i) { this.motorSpeed = t, this.maxMotorForce = i }, setSpring: function(t, i) { this.frequency = t, this.dampingRatio = i } }), Object.assign(f.prototype, { Constraint: !0, preSolve: function(t, i) { s("Constraint", "Inheritance error.") }, solve: function() { s("Constraint", "Inheritance error.") }, postSolve: function() { s("Constraint", "Inheritance error.") } }), v.prototype = Object.assign(Object.create(f.prototype), { constructor: v, setId: function(t) { this.id = i }, setParent: function(t) { this.parent = t, this.scale = this.parent.scale, this.invScale = this.parent.invScale, this.id = this.parent.numJoints, this.name || (this.name = "J" + this.id) }, updateAnchorPoints: function() { this.relativeAnchorPoint1.copy(this.localAnchorPoint1).applyMatrix3(this.body1.rotation, !0), this.relativeAnchorPoint2.copy(this.localAnchorPoint2).applyMatrix3(this.body2.rotation, !0), this.anchorPoint1.add(this.relativeAnchorPoint1, this.body1.position), this.anchorPoint2.add(this.relativeAnchorPoint2, this.body2.position) }, attach: function(t) { this.b1Link.body = this.body2, this.b2Link.body = this.body1, t ? (this.body1.jointLink.push(this.b1Link), this.body2.jointLink.push(this.b2Link)) : (null != this.body1.jointLink ? (this.b1Link.next = this.body1.jointLink).prev = this.b1Link : this.b1Link.next = null, this.body1.jointLink = this.b1Link, this.body1.numJoints++ , null != this.body2.jointLink ? (this.b2Link.next = this.body2.jointLink).prev = this.b2Link : this.b2Link.next = null, this.body2.jointLink = this.b2Link, this.body2.numJoints++) }, detach: function(t) { if (t) this.body1.jointLink.splice(this.body1.jointLink.indexOf(this.b1Link), 1), this.body2.jointLink.splice(this.body2.jointLink.indexOf(this.b2Link), 1); else { var i = this.b1Link.prev, s = this.b1Link.next; null != i && (i.next = s), null != s && (s.prev = i), this.body1.jointLink == this.b1Link && (this.body1.jointLink = s), this.b1Link.prev = null, this.b1Link.next = null, this.b1Link.body = null, this.body1.numJoints-- , i = this.b2Link.prev, s = this.b2Link.next, null != i && (i.next = s), null != s && (s.prev = i), this.body2.jointLink == this.b2Link && (this.body2.jointLink = s), this.b2Link.prev = null, this.b2Link.next = null, this.b2Link.body = null, this.body2.numJoints-- } this.b1Link.body = null, this.b2Link.body = null }, awake: function() { this.body1.awake(), this.body2.awake() }, preSolve: function(t, i) { }, solve: function() { }, postSolve: function() { }, remove: function() { this.dispose() }, dispose: function() { this.parent.removeJoint(this) }, getPosition: function() { return [(new e).scale(this.anchorPoint1, this.scale), (new e).scale(this.anchorPoint2, this.scale)] } }), Object.assign(z.prototype, { LinearConstraint: !0, preSolve: function(t, i) { this.r1x = this.r1.x, this.r1y = this.r1.y, this.r1z = this.r1.z, this.r2x = this.r2.x, this.r2y = this.r2.y, this.r2z = this.r2.z, this.m1 = this.b1.inverseMass, this.m2 = this.b2.inverseMass, this.ii1 = this.i1.clone(), this.ii2 = this.i2.clone(); var s = this.ii1.elements, h = this.ii2.elements; this.ax1x = this.r1z * s[1] + -this.r1y * s[2], this.ax1y = this.r1z * s[4] + -this.r1y * s[5], this.ax1z = this.r1z * s[7] + -this.r1y * s[8], this.ay1x = -this.r1z * s[0] + this.r1x * s[2], this.ay1y = -this.r1z * s[3] + this.r1x * s[5], this.ay1z = -this.r1z * s[6] + this.r1x * s[8], this.az1x = this.r1y * s[0] + -this.r1x * s[1], this.az1y = this.r1y * s[3] + -this.r1x * s[4], this.az1z = this.r1y * s[6] + -this.r1x * s[7], this.ax2x = this.r2z * h[1] + -this.r2y * h[2], this.ax2y = this.r2z * h[4] + -this.r2y * h[5], this.ax2z = this.r2z * h[7] + -this.r2y * h[8], this.ay2x = -this.r2z * h[0] + this.r2x * h[2], this.ay2y = -this.r2z * h[3] + this.r2x * h[5], this.ay2z = -this.r2z * h[6] + this.r2x * h[8], this.az2x = this.r2y * h[0] + -this.r2x * h[1], this.az2y = this.r2y * h[3] + -this.r2x * h[4], this.az2z = this.r2y * h[6] + -this.r2x * h[7]; var e = this.m1 + this.m2, a = (new o).set(e, 0, 0, 0, e, 0, 0, 0, e).elements; a[0] += s[4] * this.r1z * this.r1z - (s[7] + s[5]) * this.r1y * this.r1z + s[8] * this.r1y * this.r1y, a[1] += (s[6] * this.r1y + s[5] * this.r1x) * this.r1z - s[3] * this.r1z * this.r1z - s[8] * this.r1x * this.r1y, a[2] += (s[3] * this.r1y - s[4] * this.r1x) * this.r1z - s[6] * this.r1y * this.r1y + s[7] * this.r1x * this.r1y, a[3] += (s[2] * this.r1y + s[7] * this.r1x) * this.r1z - s[1] * this.r1z * this.r1z - s[8] * this.r1x * this.r1y, a[4] += s[0] * this.r1z * this.r1z - (s[6] + s[2]) * this.r1x * this.r1z + s[8] * this.r1x * this.r1x, a[5] += (s[1] * this.r1x - s[0] * this.r1y) * this.r1z - s[7] * this.r1x * this.r1x + s[6] * this.r1x * this.r1y, a[6] += (s[1] * this.r1y - s[4] * this.r1x) * this.r1z - s[2] * this.r1y * this.r1y + s[5] * this.r1x * this.r1y, a[7] += (s[3] * this.r1x - s[0] * this.r1y) * this.r1z - s[5] * this.r1x * this.r1x + s[2] * this.r1x * this.r1y, a[8] += s[0] * this.r1y * this.r1y - (s[3] + s[1]) * this.r1x * this.r1y + s[4] * this.r1x * this.r1x, a[0] += h[4] * this.r2z * this.r2z - (h[7] + h[5]) * this.r2y * this.r2z + h[8] * this.r2y * this.r2y, a[1] += (h[6] * this.r2y + h[5] * this.r2x) * this.r2z - h[3] * this.r2z * this.r2z - h[8] * this.r2x * this.r2y, a[2] += (h[3] * this.r2y - h[4] * this.r2x) * this.r2z - h[6] * this.r2y * this.r2y + h[7] * this.r2x * this.r2y, a[3] += (h[2] * this.r2y + h[7] * this.r2x) * this.r2z - h[1] * this.r2z * this.r2z - h[8] * this.r2x * this.r2y, a[4] += h[0] * this.r2z * this.r2z - (h[6] + h[2]) * this.r2x * this.r2z + h[8] * this.r2x * this.r2x, a[5] += (h[1] * this.r2x - h[0] * this.r2y) * this.r2z - h[7] * this.r2x * this.r2x + h[6] * this.r2x * this.r2y, a[6] += (h[1] * this.r2y - h[4] * this.r2x) * this.r2z - h[2] * this.r2y * this.r2y + h[5] * this.r2x * this.r2y, a[7] += (h[3] * this.r2x - h[0] * this.r2y) * this.r2z - h[5] * this.r2x * this.r2x + h[2] * this.r2x * this.r2y, a[8] += h[0] * this.r2y * this.r2y - (h[3] + h[1]) * this.r2x * this.r2y + h[4] * this.r2x * this.r2x; var n = 1 / (a[0] * (a[4] * a[8] - a[7] * a[5]) + a[3] * (a[7] * a[2] - a[1] * a[8]) + a[6] * (a[1] * a[5] - a[4] * a[2])); this.dd = (new o).set(a[4] * a[8] - a[5] * a[7], a[2] * a[7] - a[1] * a[8], a[1] * a[5] - a[2] * a[4], a[5] * a[6] - a[3] * a[8], a[0] * a[8] - a[2] * a[6], a[2] * a[3] - a[0] * a[5], a[3] * a[7] - a[4] * a[6], a[1] * a[6] - a[0] * a[7], a[0] * a[4] - a[1] * a[3]).scaleEqual(n), this.velx = this.p2.x - this.p1.x, this.vely = this.p2.y - this.p1.y, this.velz = this.p2.z - this.p1.z; var r = Pt.sqrt(this.velx * this.velx + this.vely * this.vely + this.velz * this.velz); r > .005 ? (r = (.005 - r) / r * i * .05, this.velx *= r, this.vely *= r, this.velz *= r) : (this.velx = 0, this.vely = 0, this.velz = 0), this.impx *= .95, this.impy *= .95, this.impz *= .95, this.l1.x += this.impx * this.m1, this.l1.y += this.impy * this.m1, this.l1.z += this.impz * this.m1, this.a1.x += this.impx * this.ax1x + this.impy * this.ay1x + this.impz * this.az1x, this.a1.y += this.impx * this.ax1y + this.impy * this.ay1y + this.impz * this.az1y, this.a1.z += this.impx * this.ax1z + this.impy * this.ay1z + this.impz * this.az1z, this.l2.x -= this.impx * this.m2, this.l2.y -= this.impy * this.m2, this.l2.z -= this.impz * this.m2, this.a2.x -= this.impx * this.ax2x + this.impy * this.ay2x + this.impz * this.az2x, this.a2.y -= this.impx * this.ax2y + this.impy * this.ay2y + this.impz * this.az2y, this.a2.z -= this.impx * this.ax2z + this.impy * this.ay2z + this.impz * this.az2z }, solve: function() { var t = this.dd.elements, i = this.l2.x - this.l1.x + this.a2.y * this.r2z - this.a2.z * this.r2y - this.a1.y * this.r1z + this.a1.z * this.r1y - this.velx, s = this.l2.y - this.l1.y + this.a2.z * this.r2x - this.a2.x * this.r2z - this.a1.z * this.r1x + this.a1.x * this.r1z - this.vely, h = this.l2.z - this.l1.z + this.a2.x * this.r2y - this.a2.y * this.r2x - this.a1.x * this.r1y + this.a1.y * this.r1x - this.velz, e = i * t[0] + s * t[1] + h * t[2], a = i * t[3] + s * t[4] + h * t[5], o = i * t[6] + s * t[7] + h * t[8]; this.impx += e, this.impy += a, this.impz += o, this.l1.x += e * this.m1, this.l1.y += a * this.m1, this.l1.z += o * this.m1, this.a1.x += e * this.ax1x + a * this.ay1x + o * this.az1x, this.a1.y += e * this.ax1y + a * this.ay1y + o * this.az1y, this.a1.z += e * this.ax1z + a * this.ay1z + o * this.az1z, this.l2.x -= e * this.m2, this.l2.y -= a * this.m2, this.l2.z -= o * this.m2, this.a2.x -= e * this.ax2x + a * this.ay2x + o * this.az2x, this.a2.y -= e * this.ax2y + a * this.ay2y + o * this.az2y, this.a2.z -= e * this.ax2z + a * this.ay2z + o * this.az2z } }), Object.assign(N.prototype, { Rotational3Constraint: !0, preSolve: function(t, i) { this.ax1 = this.limitMotor1.axis.x, this.ay1 = this.limitMotor1.axis.y, this.az1 = this.limitMotor1.axis.z, this.ax2 = this.limitMotor2.axis.x, this.ay2 = this.limitMotor2.axis.y, this.az2 = this.limitMotor2.axis.z, this.ax3 = this.limitMotor3.axis.x, this.ay3 = this.limitMotor3.axis.y, this.az3 = this.limitMotor3.axis.z, this.lowerLimit1 = this.limitMotor1.lowerLimit, this.upperLimit1 = this.limitMotor1.upperLimit, this.motorSpeed1 = this.limitMotor1.motorSpeed, this.maxMotorForce1 = this.limitMotor1.maxMotorForce, this.enableMotor1 = this.maxMotorForce1 > 0, this.lowerLimit2 = this.limitMotor2.lowerLimit, this.upperLimit2 = this.limitMotor2.upperLimit, this.motorSpeed2 = this.limitMotor2.motorSpeed, this.maxMotorForce2 = this.limitMotor2.maxMotorForce, this.enableMotor2 = this.maxMotorForce2 > 0, this.lowerLimit3 = this.limitMotor3.lowerLimit, this.upperLimit3 = this.limitMotor3.upperLimit, this.motorSpeed3 = this.limitMotor3.motorSpeed, this.maxMotorForce3 = this.limitMotor3.maxMotorForce, this.enableMotor3 = this.maxMotorForce3 > 0; var s = this.i1.elements, h = this.i2.elements; this.i1e00 = s[0], this.i1e01 = s[1], this.i1e02 = s[2], this.i1e10 = s[3], this.i1e11 = s[4], this.i1e12 = s[5], this.i1e20 = s[6], this.i1e21 = s[7], this.i1e22 = s[8], this.i2e00 = h[0], this.i2e01 = h[1], this.i2e02 = h[2], this.i2e10 = h[3], this.i2e11 = h[4], this.i2e12 = h[5], this.i2e20 = h[6], this.i2e21 = h[7], this.i2e22 = h[8]; var e = this.limitMotor1.frequency, a = this.limitMotor2.frequency, o = this.limitMotor3.frequency, n = e > 0, r = a > 0, l = o > 0, c = this.lowerLimit1 <= this.upperLimit1, m = this.lowerLimit2 <= this.upperLimit2, p = this.lowerLimit3 <= this.upperLimit3, u = this.limitMotor1.angle; c ? (this.lowerLimit1 == this.upperLimit1 ? (0 != this.limitState1 && (this.limitState1 = 0, this.limitImpulse1 = 0), this.limitVelocity1 = this.lowerLimit1 - u) : u < this.lowerLimit1 ? (-1 != this.limitState1 && (this.limitState1 = -1, this.limitImpulse1 = 0), this.limitVelocity1 = this.lowerLimit1 - u) : u > this.upperLimit1 ? (1 != this.limitState1 && (this.limitState1 = 1, this.limitImpulse1 = 0), this.limitVelocity1 = this.upperLimit1 - u) : (this.limitState1 = 2, this.limitImpulse1 = 0, this.limitVelocity1 = 0), n || (this.limitVelocity1 > .02 ? this.limitVelocity1 -= .02 : this.limitVelocity1 < -.02 ? this.limitVelocity1 += .02 : this.limitVelocity1 = 0)) : (this.limitState1 = 2, this.limitImpulse1 = 0); var y = this.limitMotor2.angle; m ? (this.lowerLimit2 == this.upperLimit2 ? (0 != this.limitState2 && (this.limitState2 = 0, this.limitImpulse2 = 0), this.limitVelocity2 = this.lowerLimit2 - y) : y < this.lowerLimit2 ? (-1 != this.limitState2 && (this.limitState2 = -1, this.limitImpulse2 = 0), this.limitVelocity2 = this.lowerLimit2 - y) : y > this.upperLimit2 ? (1 != this.limitState2 && (this.limitState2 = 1, this.limitImpulse2 = 0), this.limitVelocity2 = this.upperLimit2 - y) : (this.limitState2 = 2, this.limitImpulse2 = 0, this.limitVelocity2 = 0), r || (this.limitVelocity2 > .02 ? this.limitVelocity2 -= .02 : this.limitVelocity2 < -.02 ? this.limitVelocity2 += .02 : this.limitVelocity2 = 0)) : (this.limitState2 = 2, this.limitImpulse2 = 0); var x = this.limitMotor3.angle; if (p ? (this.lowerLimit3 == this.upperLimit3 ? (0 != this.limitState3 && (this.limitState3 = 0, this.limitImpulse3 = 0), this.limitVelocity3 = this.lowerLimit3 - x) : x < this.lowerLimit3 ? (-1 != this.limitState3 && (this.limitState3 = -1, this.limitImpulse3 = 0), this.limitVelocity3 = this.lowerLimit3 - x) : x > this.upperLimit3 ? (1 != this.limitState3 && (this.limitState3 = 1, this.limitImpulse3 = 0), this.limitVelocity3 = this.upperLimit3 - x) : (this.limitState3 = 2, this.limitImpulse3 = 0, this.limitVelocity3 = 0), l || (this.limitVelocity3 > .02 ? this.limitVelocity3 -= .02 : this.limitVelocity3 < -.02 ? this.limitVelocity3 += .02 : this.limitVelocity3 = 0)) : (this.limitState3 = 2, this.limitImpulse3 = 0), this.enableMotor1 && (0 != this.limitState1 || n) ? this.maxMotorImpulse1 = this.maxMotorForce1 * t : (this.motorImpulse1 = 0, this.maxMotorImpulse1 = 0), this.enableMotor2 && (0 != this.limitState2 || r) ? this.maxMotorImpulse2 = this.maxMotorForce2 * t : (this.motorImpulse2 = 0, this.maxMotorImpulse2 = 0), this.enableMotor3 && (0 != this.limitState3 || l) ? this.maxMotorImpulse3 = this.maxMotorForce3 * t : (this.motorImpulse3 = 0, this.maxMotorImpulse3 = 0), this.a1x1 = this.ax1 * this.i1e00 + this.ay1 * this.i1e01 + this.az1 * this.i1e02, this.a1y1 = this.ax1 * this.i1e10 + this.ay1 * this.i1e11 + this.az1 * this.i1e12, this.a1z1 = this.ax1 * this.i1e20 + this.ay1 * this.i1e21 + this.az1 * this.i1e22, this.a2x1 = this.ax1 * this.i2e00 + this.ay1 * this.i2e01 + this.az1 * this.i2e02, this.a2y1 = this.ax1 * this.i2e10 + this.ay1 * this.i2e11 + this.az1 * this.i2e12, this.a2z1 = this.ax1 * this.i2e20 + this.ay1 * this.i2e21 + this.az1 * this.i2e22, this.a1x2 = this.ax2 * this.i1e00 + this.ay2 * this.i1e01 + this.az2 * this.i1e02, this.a1y2 = this.ax2 * this.i1e10 + this.ay2 * this.i1e11 + this.az2 * this.i1e12, this.a1z2 = this.ax2 * this.i1e20 + this.ay2 * this.i1e21 + this.az2 * this.i1e22, this.a2x2 = this.ax2 * this.i2e00 + this.ay2 * this.i2e01 + this.az2 * this.i2e02, this.a2y2 = this.ax2 * this.i2e10 + this.ay2 * this.i2e11 + this.az2 * this.i2e12, this.a2z2 = this.ax2 * this.i2e20 + this.ay2 * this.i2e21 + this.az2 * this.i2e22, this.a1x3 = this.ax3 * this.i1e00 + this.ay3 * this.i1e01 + this.az3 * this.i1e02, this.a1y3 = this.ax3 * this.i1e10 + this.ay3 * this.i1e11 + this.az3 * this.i1e12, this.a1z3 = this.ax3 * this.i1e20 + this.ay3 * this.i1e21 + this.az3 * this.i1e22, this.a2x3 = this.ax3 * this.i2e00 + this.ay3 * this.i2e01 + this.az3 * this.i2e02, this.a2y3 = this.ax3 * this.i2e10 + this.ay3 * this.i2e11 + this.az3 * this.i2e12, this.a2z3 = this.ax3 * this.i2e20 + this.ay3 * this.i2e21 + this.az3 * this.i2e22, this.k00 = this.ax1 * (this.a1x1 + this.a2x1) + this.ay1 * (this.a1y1 + this.a2y1) + this.az1 * (this.a1z1 + this.a2z1), this.k01 = this.ax1 * (this.a1x2 + this.a2x2) + this.ay1 * (this.a1y2 + this.a2y2) + this.az1 * (this.a1z2 + this.a2z2), this.k02 = this.ax1 * (this.a1x3 + this.a2x3) + this.ay1 * (this.a1y3 + this.a2y3) + this.az1 * (this.a1z3 + this.a2z3), this.k10 = this.ax2 * (this.a1x1 + this.a2x1) + this.ay2 * (this.a1y1 + this.a2y1) + this.az2 * (this.a1z1 + this.a2z1), this.k11 = this.ax2 * (this.a1x2 + this.a2x2) + this.ay2 * (this.a1y2 + this.a2y2) + this.az2 * (this.a1z2 + this.a2z2), this.k12 = this.ax2 * (this.a1x3 + this.a2x3) + this.ay2 * (this.a1y3 + this.a2y3) + this.az2 * (this.a1z3 + this.a2z3), this.k20 = this.ax3 * (this.a1x1 + this.a2x1) + this.ay3 * (this.a1y1 + this.a2y1) + this.az3 * (this.a1z1 + this.a2z1), this.k21 = this.ax3 * (this.a1x2 + this.a2x2) + this.ay3 * (this.a1y2 + this.a2y2) + this.az3 * (this.a1z2 + this.a2z2), this.k22 = this.ax3 * (this.a1x3 + this.a2x3) + this.ay3 * (this.a1y3 + this.a2y3) + this.az3 * (this.a1z3 + this.a2z3), this.kv00 = this.k00, this.kv11 = this.k11, this.kv22 = this.k22, this.dv00 = 1 / this.kv00, this.dv11 = 1 / this.kv11, this.dv22 = 1 / this.kv22, n && 2 != this.limitState1) { var d = 6.2831853 * e, f = d * d * t, b = i / (f + 2 * this.limitMotor1.dampingRatio * d); this.cfm1 = this.kv00 * b, this.limitVelocity1 *= f * b } else this.cfm1 = 0, this.limitVelocity1 *= .05 * i; r && 2 != this.limitState2 ? (b = i / ((f = (d = 6.2831853 * a) * d * t) + 2 * this.limitMotor2.dampingRatio * d), this.cfm2 = this.kv11 * b, this.limitVelocity2 *= f * b) : (this.cfm2 = 0, this.limitVelocity2 *= .05 * i), l && 2 != this.limitState3 ? (b = i / ((f = (d = 6.2831853 * o) * d * t) + 2 * this.limitMotor3.dampingRatio * d), this.cfm3 = this.kv22 * b, this.limitVelocity3 *= f * b) : (this.cfm3 = 0, this.limitVelocity3 *= .05 * i), this.k00 += this.cfm1, this.k11 += this.cfm2, this.k22 += this.cfm3; var v = 1 / (this.k00 * (this.k11 * this.k22 - this.k21 * this.k12) + this.k10 * (this.k21 * this.k02 - this.k01 * this.k22) + this.k20 * (this.k01 * this.k12 - this.k11 * this.k02)); this.d00 = (this.k11 * this.k22 - this.k12 * this.k21) * v, this.d01 = (this.k02 * this.k21 - this.k01 * this.k22) * v, this.d02 = (this.k01 * this.k12 - this.k02 * this.k11) * v, this.d10 = (this.k12 * this.k20 - this.k10 * this.k22) * v, this.d11 = (this.k00 * this.k22 - this.k02 * this.k20) * v, this.d12 = (this.k02 * this.k10 - this.k00 * this.k12) * v, this.d20 = (this.k10 * this.k21 - this.k11 * this.k20) * v, this.d21 = (this.k01 * this.k20 - this.k00 * this.k21) * v, this.d22 = (this.k00 * this.k11 - this.k01 * this.k10) * v, this.limitImpulse1 *= .95, this.motorImpulse1 *= .95, this.limitImpulse2 *= .95, this.motorImpulse2 *= .95, this.limitImpulse3 *= .95, this.motorImpulse3 *= .95; var z = this.limitImpulse1 + this.motorImpulse1, N = this.limitImpulse2 + this.motorImpulse2, k = this.limitImpulse3 + this.motorImpulse3; this.a1.x += z * this.a1x1 + N * this.a1x2 + k * this.a1x3, this.a1.y += z * this.a1y1 + N * this.a1y2 + k * this.a1y3, this.a1.z += z * this.a1z1 + N * this.a1z2 + k * this.a1z3, this.a2.x -= z * this.a2x1 + N * this.a2x2 + k * this.a2x3, this.a2.y -= z * this.a2y1 + N * this.a2y2 + k * this.a2y3, this.a2.z -= z * this.a2z1 + N * this.a2z2 + k * this.a2z3 }, solve_: function() { var t = this.a2.x - this.a1.x, i = this.a2.y - this.a1.y, s = this.a2.z - this.a1.z; this.limitVelocity3 = 30; var h = t * this.ax1 + i * this.ay1 + s * this.az1 - this.limitVelocity1, e = t * this.ax2 + i * this.ay2 + s * this.az2 - this.limitVelocity2, a = t * this.ax3 + i * this.ay3 + s * this.az3 - this.limitVelocity3, o = h * this.d00 + e * this.d01 + a * this.d02, n = h * this.d10 + e * this.d11 + a * this.d12, r = h * this.d20 + e * this.d21 + a * this.d22; this.limitImpulse1 += o, this.limitImpulse2 += n, this.limitImpulse3 += r, this.a1.x += o * this.a1x1 + n * this.a1x2 + r * this.a1x3, this.a1.y += o * this.a1y1 + n * this.a1y2 + r * this.a1y3, this.a1.z += o * this.a1z1 + n * this.a1z2 + r * this.a1z3, this.a2.x -= o * this.a2x1 + n * this.a2x2 + r * this.a2x3, this.a2.y -= o * this.a2y1 + n * this.a2y2 + r * this.a2y3, this.a2.z -= o * this.a2z1 + n * this.a2z2 + r * this.a2z3 }, solve: function() { var t = this.a2.x - this.a1.x, i = this.a2.y - this.a1.y, s = this.a2.z - this.a1.z, h = t * this.ax1 + i * this.ay1 + s * this.az1, e = t * this.ax2 + i * this.ay2 + s * this.az2, a = t * this.ax3 + i * this.ay3 + s * this.az3, o = this.motorImpulse1, n = this.motorImpulse2, r = this.motorImpulse3, l = 0, c = 0, m = 0; this.enableMotor1 && (l = (h - this.motorSpeed1) * this.dv00, this.motorImpulse1 += l, this.motorImpulse1 > this.maxMotorImpulse1 ? this.motorImpulse1 = this.maxMotorImpulse1 : this.motorImpulse1 < -this.maxMotorImpulse1 && (this.motorImpulse1 = -this.maxMotorImpulse1), l = this.motorImpulse1 - o), this.enableMotor2 && (c = (e - this.motorSpeed2) * this.dv11, this.motorImpulse2 += c, this.motorImpulse2 > this.maxMotorImpulse2 ? this.motorImpulse2 = this.maxMotorImpulse2 : this.motorImpulse2 < -this.maxMotorImpulse2 && (this.motorImpulse2 = -this.maxMotorImpulse2), c = this.motorImpulse2 - n), this.enableMotor3 && (m = (a - this.motorSpeed3) * this.dv22, this.motorImpulse3 += m, this.motorImpulse3 > this.maxMotorImpulse3 ? this.motorImpulse3 = this.maxMotorImpulse3 : this.motorImpulse3 < -this.maxMotorImpulse3 && (this.motorImpulse3 = -this.maxMotorImpulse3), m = this.motorImpulse3 - r), h += l * this.kv00 + c * this.k01 + m * this.k02, e += l * this.k10 + c * this.kv11 + m * this.k12, a += l * this.k20 + c * this.k21 + m * this.kv22, h -= this.limitVelocity1 + this.limitImpulse1 * this.cfm1, e -= this.limitVelocity2 + this.limitImpulse2 * this.cfm2, a -= this.limitVelocity3 + this.limitImpulse3 * this.cfm3; var p = this.limitImpulse1, u = this.limitImpulse2, y = this.limitImpulse3, x = h * this.d00 + e * this.d01 + a * this.d02, d = h * this.d10 + e * this.d11 + a * this.d12, f = h * this.d20 + e * this.d21 + a * this.d22; this.limitImpulse1 += x, this.limitImpulse2 += d, this.limitImpulse3 += f; var b = 0; (2 == this.limitState1 || this.limitImpulse1 * this.limitState1 < 0) && (e += (x = -p) * this.k10, a += x * this.k20, b |= 1), (2 == this.limitState2 || this.limitImpulse2 * this.limitState2 < 0) && (h += (d = -u) * this.k01, a += d * this.k21, b |= 2), (2 == this.limitState3 || this.limitImpulse3 * this.limitState3 < 0) && (h += (f = -y) * this.k02, e += f * this.k12, b |= 4); var v; switch (b) { case 1: v = 1 / (this.k11 * this.k22 - this.k12 * this.k21), d = (this.k22 * e + -this.k12 * a) * v, f = (-this.k21 * e + this.k11 * a) * v; break; case 2: v = 1 / (this.k00 * this.k22 - this.k02 * this.k20), x = (this.k22 * h + -this.k02 * a) * v, f = (-this.k20 * h + this.k00 * a) * v; break; case 3: f = a / this.k22; break; case 4: v = 1 / (this.k00 * this.k11 - this.k01 * this.k10), x = (this.k11 * h + -this.k01 * e) * v, d = (-this.k10 * h + this.k00 * e) * v; break; case 5: d = e / this.k11; break; case 6: x = h / this.k00 }this.limitImpulse1 = x + p, this.limitImpulse2 = d + u, this.limitImpulse3 = f + y; var z = l + x, N = c + d, k = m + f; this.a1.x += z * this.a1x1 + N * this.a1x2 + k * this.a1x3, this.a1.y += z * this.a1y1 + N * this.a1y2 + k * this.a1y3, this.a1.z += z * this.a1z1 + N * this.a1z2 + k * this.a1z3, this.a2.x -= z * this.a2x1 + N * this.a2x2 + k * this.a2x3, this.a2.y -= z * this.a2y1 + N * this.a2y2 + k * this.a2y3, this.a2.z -= z * this.a2z1 + N * this.a2z2 + k * this.a2z3, t = this.a2.x - this.a1.x, i = this.a2.y - this.a1.y, s = this.a2.z - this.a1.z, e = t * this.ax2 + i * this.ay2 + s * this.az2 } }), k.prototype = Object.assign(Object.create(v.prototype), { constructor: k, preSolve: function(t, i) { this.updateAnchorPoints(), this.ax1.copy(this.localAxis1).applyMatrix3(this.body1.rotation, !0), this.ax2.copy(this.localAxis2).applyMatrix3(this.body2.rotation, !0), this.an1.copy(this.localAngle1).applyMatrix3(this.body1.rotation, !0), this.an2.copy(this.localAngle2).applyMatrix3(this.body2.rotation, !0), this.nor.set(this.ax1.x * this.body2.inverseMass + this.ax2.x * this.body1.inverseMass, this.ax1.y * this.body2.inverseMass + this.ax2.y * this.body1.inverseMass, this.ax1.z * this.body2.inverseMass + this.ax2.z * this.body1.inverseMass).normalize(), this.tan.tangent(this.nor).normalize(), this.bin.crossVectors(this.nor, this.tan); var s = Pt.acosClamp(Pt.dotVectors(this.an1, this.an2)); this.tmp.crossVectors(this.an1, this.an2), Pt.dotVectors(this.nor, this.tmp) < 0 ? this.limitMotor.angle = -s : this.limitMotor.angle = s, this.tmp.crossVectors(this.ax1, this.ax2), this.r3.limitMotor2.angle = Pt.dotVectors(this.tan, this.tmp), this.r3.limitMotor3.angle = Pt.dotVectors(this.bin, this.tmp), this.r3.preSolve(t, i), this.lc.preSolve(t, i) }, solve: function() { this.r3.solve(), this.lc.solve() }, postSolve: function() { } }), w.prototype = Object.assign(Object.create(v.prototype), { constructor: w, preSolve: function(t, i) { this.updateAnchorPoints(), this.lc.preSolve(t, i) }, solve: function() { this.lc.solve() }, postSolve: function() { } }), Object.assign(M.prototype, { TranslationalConstraint: !0, preSolve: function(t, i) { this.ax = this.limitMotor.axis.x, this.ay = this.limitMotor.axis.y, this.az = this.limitMotor.axis.z, this.lowerLimit = this.limitMotor.lowerLimit, this.upperLimit = this.limitMotor.upperLimit, this.motorSpeed = this.limitMotor.motorSpeed, this.maxMotorForce = this.limitMotor.maxMotorForce, this.enableMotor = this.maxMotorForce > 0, this.m1 = this.b1.inverseMass, this.m2 = this.b2.inverseMass; var s = this.i1.elements, h = this.i2.elements; this.i1e00 = s[0], this.i1e01 = s[1], this.i1e02 = s[2], this.i1e10 = s[3], this.i1e11 = s[4], this.i1e12 = s[5], this.i1e20 = s[6], this.i1e21 = s[7], this.i1e22 = s[8], this.i2e00 = h[0], this.i2e01 = h[1], this.i2e02 = h[2], this.i2e10 = h[3], this.i2e11 = h[4], this.i2e12 = h[5], this.i2e20 = h[6], this.i2e21 = h[7], this.i2e22 = h[8]; var e = this.p2.x - this.p1.x, a = this.p2.y - this.p1.y, o = this.p2.z - this.p1.z, n = e * this.ax + a * this.ay + o * this.az, r = this.limitMotor.frequency, l = r > 0, c = this.lowerLimit <= this.upperLimit; (l && n > 20 || n < -20) && (l = !1), c ? (this.lowerLimit == this.upperLimit ? (0 != this.limitState && (this.limitState = 0, this.limitImpulse = 0), this.limitVelocity = this.lowerLimit - n, l || (n = this.lowerLimit)) : n < this.lowerLimit ? (-1 != this.limitState && (this.limitState = -1, this.limitImpulse = 0), this.limitVelocity = this.lowerLimit - n, l || (n = this.lowerLimit)) : n > this.upperLimit ? (1 != this.limitState && (this.limitState = 1, this.limitImpulse = 0), this.limitVelocity = this.upperLimit - n, l || (n = this.upperLimit)) : (this.limitState = 2, this.limitImpulse = 0, this.limitVelocity = 0), l || (this.limitVelocity > .005 ? this.limitVelocity -= .005 : this.limitVelocity < -.005 ? this.limitVelocity += .005 : this.limitVelocity = 0)) : (this.limitState = 2, this.limitImpulse = 0), this.enableMotor && (0 != this.limitState || l) ? this.maxMotorImpulse = this.maxMotorForce * t : (this.motorImpulse = 0, this.maxMotorImpulse = 0); var m = n * this.ax, p = n * this.ay, u = n * this.az, y = this.m1 / (this.m1 + this.m2), x = 1 - y; if (this.r1x = this.r1.x + m * y, this.r1y = this.r1.y + p * y, this.r1z = this.r1.z + u * y, this.r2x = this.r2.x - m * x, this.r2y = this.r2.y - p * x, this.r2z = this.r2.z - u * x, this.t1x = this.r1y * this.az - this.r1z * this.ay, this.t1y = this.r1z * this.ax - this.r1x * this.az, this.t1z = this.r1x * this.ay - this.r1y * this.ax, this.t2x = this.r2y * this.az - this.r2z * this.ay, this.t2y = this.r2z * this.ax - this.r2x * this.az, this.t2z = this.r2x * this.ay - this.r2y * this.ax, this.l1x = this.ax * this.m1, this.l1y = this.ay * this.m1, this.l1z = this.az * this.m1, this.l2x = this.ax * this.m2, this.l2y = this.ay * this.m2, this.l2z = this.az * this.m2, this.a1x = this.t1x * this.i1e00 + this.t1y * this.i1e01 + this.t1z * this.i1e02, this.a1y = this.t1x * this.i1e10 + this.t1y * this.i1e11 + this.t1z * this.i1e12, this.a1z = this.t1x * this.i1e20 + this.t1y * this.i1e21 + this.t1z * this.i1e22, this.a2x = this.t2x * this.i2e00 + this.t2y * this.i2e01 + this.t2z * this.i2e02, this.a2y = this.t2x * this.i2e10 + this.t2y * this.i2e11 + this.t2z * this.i2e12, this.a2z = this.t2x * this.i2e20 + this.t2y * this.i2e21 + this.t2z * this.i2e22, this.motorDenom = this.m1 + this.m2 + this.ax * (this.a1y * this.r1z - this.a1z * this.r1y + this.a2y * this.r2z - this.a2z * this.r2y) + this.ay * (this.a1z * this.r1x - this.a1x * this.r1z + this.a2z * this.r2x - this.a2x * this.r2z) + this.az * (this.a1x * this.r1y - this.a1y * this.r1x + this.a2x * this.r2y - this.a2y * this.r2x), this.invMotorDenom = 1 / this.motorDenom, l && 2 != this.limitState) { var d = 6.2831853 * r, f = d * d * t, b = i / (f + 2 * this.limitMotor.dampingRatio * d); this.cfm = this.motorDenom * b, this.limitVelocity *= f * b } else this.cfm = 0, this.limitVelocity *= .05 * i; this.invDenom = 1 / (this.motorDenom + this.cfm); var v = this.limitImpulse + this.motorImpulse; this.l1.x += v * this.l1x, this.l1.y += v * this.l1y, this.l1.z += v * this.l1z, this.a1.x += v * this.a1x, this.a1.y += v * this.a1y, this.a1.z += v * this.a1z, this.l2.x -= v * this.l2x, this.l2.y -= v * this.l2y, this.l2.z -= v * this.l2z, this.a2.x -= v * this.a2x, this.a2.y -= v * this.a2y, this.a2.z -= v * this.a2z }, solve: function() { var t, i = this.ax * (this.l2.x - this.l1.x) + this.ay * (this.l2.y - this.l1.y) + this.az * (this.l2.z - this.l1.z) + this.t2x * this.a2.x - this.t1x * this.a1.x + this.t2y * this.a2.y - this.t1y * this.a1.y + this.t2z * this.a2.z - this.t1z * this.a1.z; if (this.enableMotor) { t = (i - this.motorSpeed) * this.invMotorDenom; var s = this.motorImpulse; this.motorImpulse += t, this.motorImpulse > this.maxMotorImpulse ? this.motorImpulse = this.maxMotorImpulse : this.motorImpulse < -this.maxMotorImpulse && (this.motorImpulse = -this.maxMotorImpulse), i -= (t = this.motorImpulse - s) * this.motorDenom } else t = 0; var h; if (2 != this.limitState) { h = (i - this.limitVelocity - this.limitImpulse * this.cfm) * this.invDenom; var e = this.limitImpulse; this.limitImpulse += h, this.limitImpulse * this.limitState < 0 && (this.limitImpulse = 0), h = this.limitImpulse - e } else h = 0; var a = h + t; this.l1.x += a * this.l1x, this.l1.y += a * this.l1y, this.l1.z += a * this.l1z, this.a1.x += a * this.a1x, this.a1.y += a * this.a1y, this.a1.z += a * this.a1z, this.l2.x -= a * this.l2x, this.l2.y -= a * this.l2y, this.l2.z -= a * this.l2z, this.a2.x -= a * this.a2x, this.a2.y -= a * this.a2y, this.a2.z -= a * this.a2z } }), g.prototype = Object.assign(Object.create(v.prototype), { constructor: g, preSolve: function(t, i) { this.updateAnchorPoints(), this.nor.sub(this.anchorPoint2, this.anchorPoint1).normalize(), this.t.preSolve(t, i) }, solve: function() { this.t.solve() }, postSolve: function() { } }), Object.assign(I.prototype, { AngularConstraint: !0, preSolve: function(t, i) { var s, h, e; this.ii1 = this.i1.clone(), this.ii2 = this.i2.clone(), s = 1 / ((e = (new o).add(this.ii1, this.ii2).elements)[0] * (e[4] * e[8] - e[7] * e[5]) + e[3] * (e[7] * e[2] - e[1] * e[8]) + e[6] * (e[1] * e[5] - e[4] * e[2])), this.dd = (new o).set(e[4] * e[8] - e[5] * e[7], e[2] * e[7] - e[1] * e[8], e[1] * e[5] - e[2] * e[4], e[5] * e[6] - e[3] * e[8], e[0] * e[8] - e[2] * e[6], e[2] * e[3] - e[0] * e[5], e[3] * e[7] - e[4] * e[6], e[1] * e[6] - e[0] * e[7], e[0] * e[4] - e[1] * e[3]).multiplyScalar(s), this.relativeOrientation.invert(this.b1.orientation).multiply(this.targetOrientation).multiply(this.b2.orientation), s = 2 * this.relativeOrientation.w, this.vel.copy(this.relativeOrientation).multiplyScalar(s), (h = this.vel.length()) > .02 ? (h = (.02 - h) / h * i * .05, this.vel.multiplyScalar(h)) : this.vel.set(0, 0, 0), this.rn1.copy(this.imp).applyMatrix3(this.ii1, !0), this.rn2.copy(this.imp).applyMatrix3(this.ii2, !0), this.a1.add(this.rn1), this.a2.sub(this.rn2) }, solve: function() { var t = this.a2.clone().sub(this.a1).sub(this.vel); this.rn0.copy(t).applyMatrix3(this.dd, !0), this.rn1.copy(this.rn0).applyMatrix3(this.ii1, !0), this.rn2.copy(this.rn0).applyMatrix3(this.ii2, !0), this.imp.add(this.rn0), this.a1.add(this.rn1), this.a2.sub(this.rn2) } }), Object.assign(V.prototype, { Translational3Constraint: !0, preSolve: function(t, i) { this.ax1 = this.limitMotor1.axis.x, this.ay1 = this.limitMotor1.axis.y, this.az1 = this.limitMotor1.axis.z, this.ax2 = this.limitMotor2.axis.x, this.ay2 = this.limitMotor2.axis.y, this.az2 = this.limitMotor2.axis.z, this.ax3 = this.limitMotor3.axis.x, this.ay3 = this.limitMotor3.axis.y, this.az3 = this.limitMotor3.axis.z, this.lowerLimit1 = this.limitMotor1.lowerLimit, this.upperLimit1 = this.limitMotor1.upperLimit, this.motorSpeed1 = this.limitMotor1.motorSpeed, this.maxMotorForce1 = this.limitMotor1.maxMotorForce, this.enableMotor1 = this.maxMotorForce1 > 0, this.lowerLimit2 = this.limitMotor2.lowerLimit, this.upperLimit2 = this.limitMotor2.upperLimit, this.motorSpeed2 = this.limitMotor2.motorSpeed, this.maxMotorForce2 = this.limitMotor2.maxMotorForce, this.enableMotor2 = this.maxMotorForce2 > 0, this.lowerLimit3 = this.limitMotor3.lowerLimit, this.upperLimit3 = this.limitMotor3.upperLimit, this.motorSpeed3 = this.limitMotor3.motorSpeed, this.maxMotorForce3 = this.limitMotor3.maxMotorForce, this.enableMotor3 = this.maxMotorForce3 > 0, this.m1 = this.b1.inverseMass, this.m2 = this.b2.inverseMass; var s = this.i1.elements, h = this.i2.elements; this.i1e00 = s[0], this.i1e01 = s[1], this.i1e02 = s[2], this.i1e10 = s[3], this.i1e11 = s[4], this.i1e12 = s[5], this.i1e20 = s[6], this.i1e21 = s[7], this.i1e22 = s[8], this.i2e00 = h[0], this.i2e01 = h[1], this.i2e02 = h[2], this.i2e10 = h[3], this.i2e11 = h[4], this.i2e12 = h[5], this.i2e20 = h[6], this.i2e21 = h[7], this.i2e22 = h[8]; var e = this.p2.x - this.p1.x, a = this.p2.y - this.p1.y, o = this.p2.z - this.p1.z, n = e * this.ax1 + a * this.ay1 + o * this.az1, r = e * this.ax2 + a * this.ay2 + o * this.az2, l = e * this.ax3 + a * this.ay3 + o * this.az3, c = this.limitMotor1.frequency, m = this.limitMotor2.frequency, p = this.limitMotor3.frequency, u = c > 0, y = m > 0, x = p > 0, d = this.lowerLimit1 <= this.upperLimit1, f = this.lowerLimit2 <= this.upperLimit2, b = this.lowerLimit3 <= this.upperLimit3; (u && n > 20 || n < -20) && (u = !1), (y && r > 20 || r < -20) && (y = !1), (x && l > 20 || l < -20) && (x = !1), d ? (this.lowerLimit1 == this.upperLimit1 ? (0 != this.limitState1 && (this.limitState1 = 0, this.limitImpulse1 = 0), this.limitVelocity1 = this.lowerLimit1 - n, u || (n = this.lowerLimit1)) : n < this.lowerLimit1 ? (-1 != this.limitState1 && (this.limitState1 = -1, this.limitImpulse1 = 0), this.limitVelocity1 = this.lowerLimit1 - n, u || (n = this.lowerLimit1)) : n > this.upperLimit1 ? (1 != this.limitState1 && (this.limitState1 = 1, this.limitImpulse1 = 0), this.limitVelocity1 = this.upperLimit1 - n, u || (n = this.upperLimit1)) : (this.limitState1 = 2, this.limitImpulse1 = 0, this.limitVelocity1 = 0), u || (this.limitVelocity1 > .005 ? this.limitVelocity1 -= .005 : this.limitVelocity1 < -.005 ? this.limitVelocity1 += .005 : this.limitVelocity1 = 0)) : (this.limitState1 = 2, this.limitImpulse1 = 0), f ? (this.lowerLimit2 == this.upperLimit2 ? (0 != this.limitState2 && (this.limitState2 = 0, this.limitImpulse2 = 0), this.limitVelocity2 = this.lowerLimit2 - r, y || (r = this.lowerLimit2)) : r < this.lowerLimit2 ? (-1 != this.limitState2 && (this.limitState2 = -1, this.limitImpulse2 = 0), this.limitVelocity2 = this.lowerLimit2 - r, y || (r = this.lowerLimit2)) : r > this.upperLimit2 ? (1 != this.limitState2 && (this.limitState2 = 1, this.limitImpulse2 = 0), this.limitVelocity2 = this.upperLimit2 - r, y || (r = this.upperLimit2)) : (this.limitState2 = 2, this.limitImpulse2 = 0, this.limitVelocity2 = 0), y || (this.limitVelocity2 > .005 ? this.limitVelocity2 -= .005 : this.limitVelocity2 < -.005 ? this.limitVelocity2 += .005 : this.limitVelocity2 = 0)) : (this.limitState2 = 2, this.limitImpulse2 = 0), b ? (this.lowerLimit3 == this.upperLimit3 ? (0 != this.limitState3 && (this.limitState3 = 0, this.limitImpulse3 = 0), this.limitVelocity3 = this.lowerLimit3 - l, x || (l = this.lowerLimit3)) : l < this.lowerLimit3 ? (-1 != this.limitState3 && (this.limitState3 = -1, this.limitImpulse3 = 0), this.limitVelocity3 = this.lowerLimit3 - l, x || (l = this.lowerLimit3)) : l > this.upperLimit3 ? (1 != this.limitState3 && (this.limitState3 = 1, this.limitImpulse3 = 0), this.limitVelocity3 = this.upperLimit3 - l, x || (l = this.upperLimit3)) : (this.limitState3 = 2, this.limitImpulse3 = 0, this.limitVelocity3 = 0), x || (this.limitVelocity3 > .005 ? this.limitVelocity3 -= .005 : this.limitVelocity3 < -.005 ? this.limitVelocity3 += .005 : this.limitVelocity3 = 0)) : (this.limitState3 = 2, this.limitImpulse3 = 0), this.enableMotor1 && (0 != this.limitState1 || u) ? this.maxMotorImpulse1 = this.maxMotorForce1 * t : (this.motorImpulse1 = 0, this.maxMotorImpulse1 = 0), this.enableMotor2 && (0 != this.limitState2 || y) ? this.maxMotorImpulse2 = this.maxMotorForce2 * t : (this.motorImpulse2 = 0, this.maxMotorImpulse2 = 0), this.enableMotor3 && (0 != this.limitState3 || x) ? this.maxMotorImpulse3 = this.maxMotorForce3 * t : (this.motorImpulse3 = 0, this.maxMotorImpulse3 = 0); var v = n * this.ax1 + r * this.ax2 + l * this.ax2, z = n * this.ay1 + r * this.ay2 + l * this.ay2, N = n * this.az1 + r * this.az2 + l * this.az2, k = this.m2 / (this.m1 + this.m2); this.weight >= 0 && (k = this.weight); var w = 1 - k; this.r1x = this.r1.x + v * k, this.r1y = this.r1.y + z * k, this.r1z = this.r1.z + N * k, this.r2x = this.r2.x - v * w, this.r2y = this.r2.y - z * w, this.r2z = this.r2.z - N * w, this.t1x1 = this.r1y * this.az1 - this.r1z * this.ay1, this.t1y1 = this.r1z * this.ax1 - this.r1x * this.az1, this.t1z1 = this.r1x * this.ay1 - this.r1y * this.ax1, this.t2x1 = this.r2y * this.az1 - this.r2z * this.ay1, this.t2y1 = this.r2z * this.ax1 - this.r2x * this.az1, this.t2z1 = this.r2x * this.ay1 - this.r2y * this.ax1, this.l1x1 = this.ax1 * this.m1, this.l1y1 = this.ay1 * this.m1, this.l1z1 = this.az1 * this.m1, this.l2x1 = this.ax1 * this.m2, this.l2y1 = this.ay1 * this.m2, this.l2z1 = this.az1 * this.m2, this.a1x1 = this.t1x1 * this.i1e00 + this.t1y1 * this.i1e01 + this.t1z1 * this.i1e02, this.a1y1 = this.t1x1 * this.i1e10 + this.t1y1 * this.i1e11 + this.t1z1 * this.i1e12, this.a1z1 = this.t1x1 * this.i1e20 + this.t1y1 * this.i1e21 + this.t1z1 * this.i1e22, this.a2x1 = this.t2x1 * this.i2e00 + this.t2y1 * this.i2e01 + this.t2z1 * this.i2e02, this.a2y1 = this.t2x1 * this.i2e10 + this.t2y1 * this.i2e11 + this.t2z1 * this.i2e12, this.a2z1 = this.t2x1 * this.i2e20 + this.t2y1 * this.i2e21 + this.t2z1 * this.i2e22, this.t1x2 = this.r1y * this.az2 - this.r1z * this.ay2, this.t1y2 = this.r1z * this.ax2 - this.r1x * this.az2, this.t1z2 = this.r1x * this.ay2 - this.r1y * this.ax2, this.t2x2 = this.r2y * this.az2 - this.r2z * this.ay2, this.t2y2 = this.r2z * this.ax2 - this.r2x * this.az2, this.t2z2 = this.r2x * this.ay2 - this.r2y * this.ax2, this.l1x2 = this.ax2 * this.m1, this.l1y2 = this.ay2 * this.m1, this.l1z2 = this.az2 * this.m1, this.l2x2 = this.ax2 * this.m2, this.l2y2 = this.ay2 * this.m2, this.l2z2 = this.az2 * this.m2, this.a1x2 = this.t1x2 * this.i1e00 + this.t1y2 * this.i1e01 + this.t1z2 * this.i1e02, this.a1y2 = this.t1x2 * this.i1e10 + this.t1y2 * this.i1e11 + this.t1z2 * this.i1e12, this.a1z2 = this.t1x2 * this.i1e20 + this.t1y2 * this.i1e21 + this.t1z2 * this.i1e22, this.a2x2 = this.t2x2 * this.i2e00 + this.t2y2 * this.i2e01 + this.t2z2 * this.i2e02, this.a2y2 = this.t2x2 * this.i2e10 + this.t2y2 * this.i2e11 + this.t2z2 * this.i2e12, this.a2z2 = this.t2x2 * this.i2e20 + this.t2y2 * this.i2e21 + this.t2z2 * this.i2e22, this.t1x3 = this.r1y * this.az3 - this.r1z * this.ay3, this.t1y3 = this.r1z * this.ax3 - this.r1x * this.az3, this.t1z3 = this.r1x * this.ay3 - this.r1y * this.ax3, this.t2x3 = this.r2y * this.az3 - this.r2z * this.ay3, this.t2y3 = this.r2z * this.ax3 - this.r2x * this.az3, this.t2z3 = this.r2x * this.ay3 - this.r2y * this.ax3, this.l1x3 = this.ax3 * this.m1, this.l1y3 = this.ay3 * this.m1, this.l1z3 = this.az3 * this.m1, this.l2x3 = this.ax3 * this.m2, this.l2y3 = this.ay3 * this.m2, this.l2z3 = this.az3 * this.m2, this.a1x3 = this.t1x3 * this.i1e00 + this.t1y3 * this.i1e01 + this.t1z3 * this.i1e02, this.a1y3 = this.t1x3 * this.i1e10 + this.t1y3 * this.i1e11 + this.t1z3 * this.i1e12, this.a1z3 = this.t1x3 * this.i1e20 + this.t1y3 * this.i1e21 + this.t1z3 * this.i1e22, this.a2x3 = this.t2x3 * this.i2e00 + this.t2y3 * this.i2e01 + this.t2z3 * this.i2e02, this.a2y3 = this.t2x3 * this.i2e10 + this.t2y3 * this.i2e11 + this.t2z3 * this.i2e12, this.a2z3 = this.t2x3 * this.i2e20 + this.t2y3 * this.i2e21 + this.t2z3 * this.i2e22; var M = this.m1 + this.m2; if (this.k00 = (this.ax1 * this.ax1 + this.ay1 * this.ay1 + this.az1 * this.az1) * M, this.k01 = (this.ax1 * this.ax2 + this.ay1 * this.ay2 + this.az1 * this.az2) * M, this.k02 = (this.ax1 * this.ax3 + this.ay1 * this.ay3 + this.az1 * this.az3) * M, this.k10 = (this.ax2 * this.ax1 + this.ay2 * this.ay1 + this.az2 * this.az1) * M, this.k11 = (this.ax2 * this.ax2 + this.ay2 * this.ay2 + this.az2 * this.az2) * M, this.k12 = (this.ax2 * this.ax3 + this.ay2 * this.ay3 + this.az2 * this.az3) * M, this.k20 = (this.ax3 * this.ax1 + this.ay3 * this.ay1 + this.az3 * this.az1) * M, this.k21 = (this.ax3 * this.ax2 + this.ay3 * this.ay2 + this.az3 * this.az2) * M, this.k22 = (this.ax3 * this.ax3 + this.ay3 * this.ay3 + this.az3 * this.az3) * M, this.k00 += this.t1x1 * this.a1x1 + this.t1y1 * this.a1y1 + this.t1z1 * this.a1z1, this.k01 += this.t1x1 * this.a1x2 + this.t1y1 * this.a1y2 + this.t1z1 * this.a1z2, this.k02 += this.t1x1 * this.a1x3 + this.t1y1 * this.a1y3 + this.t1z1 * this.a1z3, this.k10 += this.t1x2 * this.a1x1 + this.t1y2 * this.a1y1 + this.t1z2 * this.a1z1, this.k11 += this.t1x2 * this.a1x2 + this.t1y2 * this.a1y2 + this.t1z2 * this.a1z2, this.k12 += this.t1x2 * this.a1x3 + this.t1y2 * this.a1y3 + this.t1z2 * this.a1z3, this.k20 += this.t1x3 * this.a1x1 + this.t1y3 * this.a1y1 + this.t1z3 * this.a1z1, this.k21 += this.t1x3 * this.a1x2 + this.t1y3 * this.a1y2 + this.t1z3 * this.a1z2, this.k22 += this.t1x3 * this.a1x3 + this.t1y3 * this.a1y3 + this.t1z3 * this.a1z3, this.k00 += this.t2x1 * this.a2x1 + this.t2y1 * this.a2y1 + this.t2z1 * this.a2z1, this.k01 += this.t2x1 * this.a2x2 + this.t2y1 * this.a2y2 + this.t2z1 * this.a2z2, this.k02 += this.t2x1 * this.a2x3 + this.t2y1 * this.a2y3 + this.t2z1 * this.a2z3, this.k10 += this.t2x2 * this.a2x1 + this.t2y2 * this.a2y1 + this.t2z2 * this.a2z1, this.k11 += this.t2x2 * this.a2x2 + this.t2y2 * this.a2y2 + this.t2z2 * this.a2z2, this.k12 += this.t2x2 * this.a2x3 + this.t2y2 * this.a2y3 + this.t2z2 * this.a2z3, this.k20 += this.t2x3 * this.a2x1 + this.t2y3 * this.a2y1 + this.t2z3 * this.a2z1, this.k21 += this.t2x3 * this.a2x2 + this.t2y3 * this.a2y2 + this.t2z3 * this.a2z2, this.k22 += this.t2x3 * this.a2x3 + this.t2y3 * this.a2y3 + this.t2z3 * this.a2z3, this.kv00 = this.k00, this.kv11 = this.k11, this.kv22 = this.k22, this.dv00 = 1 / this.kv00, this.dv11 = 1 / this.kv11, this.dv22 = 1 / this.kv22, u && 2 != this.limitState1) { var g = 6.2831853 * c, I = g * g * t, V = i / (I + 2 * this.limitMotor1.dampingRatio * g); this.cfm1 = this.kv00 * V, this.limitVelocity1 *= I * V } else this.cfm1 = 0, this.limitVelocity1 *= .05 * i; y && 2 != this.limitState2 ? (V = i / ((I = (g = 6.2831853 * m) * g * t) + 2 * this.limitMotor2.dampingRatio * g), this.cfm2 = this.kv11 * V, this.limitVelocity2 *= I * V) : (this.cfm2 = 0, this.limitVelocity2 *= .05 * i), x && 2 != this.limitState3 ? (V = i / ((I = (g = 6.2831853 * p) * g * t) + 2 * this.limitMotor3.dampingRatio * g), this.cfm3 = this.kv22 * V, this.limitVelocity3 *= I * V) : (this.cfm3 = 0, this.limitVelocity3 *= .05 * i), this.k00 += this.cfm1, this.k11 += this.cfm2, this.k22 += this.cfm3; var L = 1 / (this.k00 * (this.k11 * this.k22 - this.k21 * this.k12) + this.k10 * (this.k21 * this.k02 - this.k01 * this.k22) + this.k20 * (this.k01 * this.k12 - this.k11 * this.k02)); this.d00 = (this.k11 * this.k22 - this.k12 * this.k21) * L, this.d01 = (this.k02 * this.k21 - this.k01 * this.k22) * L, this.d02 = (this.k01 * this.k12 - this.k02 * this.k11) * L, this.d10 = (this.k12 * this.k20 - this.k10 * this.k22) * L, this.d11 = (this.k00 * this.k22 - this.k02 * this.k20) * L, this.d12 = (this.k02 * this.k10 - this.k00 * this.k12) * L, this.d20 = (this.k10 * this.k21 - this.k11 * this.k20) * L, this.d21 = (this.k01 * this.k20 - this.k00 * this.k21) * L, this.d22 = (this.k00 * this.k11 - this.k01 * this.k10) * L; var S = this.limitImpulse1 + this.motorImpulse1, P = this.limitImpulse2 + this.motorImpulse2, T = this.limitImpulse3 + this.motorImpulse3; this.l1.x += S * this.l1x1 + P * this.l1x2 + T * this.l1x3, this.l1.y += S * this.l1y1 + P * this.l1y2 + T * this.l1y3, this.l1.z += S * this.l1z1 + P * this.l1z2 + T * this.l1z3, this.a1.x += S * this.a1x1 + P * this.a1x2 + T * this.a1x3, this.a1.y += S * this.a1y1 + P * this.a1y2 + T * this.a1y3, this.a1.z += S * this.a1z1 + P * this.a1z2 + T * this.a1z3, this.l2.x -= S * this.l2x1 + P * this.l2x2 + T * this.l2x3, this.l2.y -= S * this.l2y1 + P * this.l2y2 + T * this.l2y3, this.l2.z -= S * this.l2z1 + P * this.l2z2 + T * this.l2z3, this.a2.x -= S * this.a2x1 + P * this.a2x2 + T * this.a2x3, this.a2.y -= S * this.a2y1 + P * this.a2y2 + T * this.a2y3, this.a2.z -= S * this.a2z1 + P * this.a2z2 + T * this.a2z3 }, solve: function() { var t = this.l2.x - this.l1.x + this.a2.y * this.r2z - this.a2.z * this.r2y - this.a1.y * this.r1z + this.a1.z * this.r1y, i = this.l2.y - this.l1.y + this.a2.z * this.r2x - this.a2.x * this.r2z - this.a1.z * this.r1x + this.a1.x * this.r1z, s = this.l2.z - this.l1.z + this.a2.x * this.r2y - this.a2.y * this.r2x - this.a1.x * this.r1y + this.a1.y * this.r1x, h = t * this.ax1 + i * this.ay1 + s * this.az1, e = t * this.ax2 + i * this.ay2 + s * this.az2, a = t * this.ax3 + i * this.ay3 + s * this.az3, o = this.motorImpulse1, n = this.motorImpulse2, r = this.motorImpulse3, l = 0, c = 0, m = 0; this.enableMotor1 && (l = (h - this.motorSpeed1) * this.dv00, this.motorImpulse1 += l, this.motorImpulse1 > this.maxMotorImpulse1 ? this.motorImpulse1 = this.maxMotorImpulse1 : this.motorImpulse1 < -this.maxMotorImpulse1 && (this.motorImpulse1 = -this.maxMotorImpulse1), l = this.motorImpulse1 - o), this.enableMotor2 && (c = (e - this.motorSpeed2) * this.dv11, this.motorImpulse2 += c, this.motorImpulse2 > this.maxMotorImpulse2 ? this.motorImpulse2 = this.maxMotorImpulse2 : this.motorImpulse2 < -this.maxMotorImpulse2 && (this.motorImpulse2 = -this.maxMotorImpulse2), c = this.motorImpulse2 - n), this.enableMotor3 && (m = (a - this.motorSpeed3) * this.dv22, this.motorImpulse3 += m, this.motorImpulse3 > this.maxMotorImpulse3 ? this.motorImpulse3 = this.maxMotorImpulse3 : this.motorImpulse3 < -this.maxMotorImpulse3 && (this.motorImpulse3 = -this.maxMotorImpulse3), m = this.motorImpulse3 - r), h += l * this.kv00 + c * this.k01 + m * this.k02, e += l * this.k10 + c * this.kv11 + m * this.k12, a += l * this.k20 + c * this.k21 + m * this.kv22, h -= this.limitVelocity1 + this.limitImpulse1 * this.cfm1, e -= this.limitVelocity2 + this.limitImpulse2 * this.cfm2, a -= this.limitVelocity3 + this.limitImpulse3 * this.cfm3; var p = this.limitImpulse1, u = this.limitImpulse2, y = this.limitImpulse3, x = h * this.d00 + e * this.d01 + a * this.d02, d = h * this.d10 + e * this.d11 + a * this.d12, f = h * this.d20 + e * this.d21 + a * this.d22; this.limitImpulse1 += x, this.limitImpulse2 += d, this.limitImpulse3 += f; var b = 0; (2 == this.limitState1 || this.limitImpulse1 * this.limitState1 < 0) && (e += (x = -p) * this.k10, a += x * this.k20, b |= 1), (2 == this.limitState2 || this.limitImpulse2 * this.limitState2 < 0) && (h += (d = -u) * this.k01, a += d * this.k21, b |= 2), (2 == this.limitState3 || this.limitImpulse3 * this.limitState3 < 0) && (h += (f = -y) * this.k02, e += f * this.k12, b |= 4); var v; switch (b) { case 1: v = 1 / (this.k11 * this.k22 - this.k12 * this.k21), d = (this.k22 * e + -this.k12 * a) * v, f = (-this.k21 * e + this.k11 * a) * v; break; case 2: v = 1 / (this.k00 * this.k22 - this.k02 * this.k20), x = (this.k22 * h + -this.k02 * a) * v, f = (-this.k20 * h + this.k00 * a) * v; break; case 3: f = a / this.k22; break; case 4: v = 1 / (this.k00 * this.k11 - this.k01 * this.k10), x = (this.k11 * h + -this.k01 * e) * v, d = (-this.k10 * h + this.k00 * e) * v; break; case 5: d = e / this.k11; break; case 6: x = h / this.k00 }this.limitImpulse1 = p + x, this.limitImpulse2 = u + d, this.limitImpulse3 = y + f; var z = l + x, N = c + d, k = m + f; this.l1.x += z * this.l1x1 + N * this.l1x2 + k * this.l1x3, this.l1.y += z * this.l1y1 + N * this.l1y2 + k * this.l1y3, this.l1.z += z * this.l1z1 + N * this.l1z2 + k * this.l1z3, this.a1.x += z * this.a1x1 + N * this.a1x2 + k * this.a1x3, this.a1.y += z * this.a1y1 + N * this.a1y2 + k * this.a1y3, this.a1.z += z * this.a1z1 + N * this.a1z2 + k * this.a1z3, this.l2.x -= z * this.l2x1 + N * this.l2x2 + k * this.l2x3, this.l2.y -= z * this.l2y1 + N * this.l2y2 + k * this.l2y3, this.l2.z -= z * this.l2z1 + N * this.l2z2 + k * this.l2z3, this.a2.x -= z * this.a2x1 + N * this.a2x2 + k * this.a2x3, this.a2.y -= z * this.a2y1 + N * this.a2y2 + k * this.a2y3, this.a2.z -= z * this.a2z1 + N * this.a2z2 + k * this.a2z3 } }), L.prototype = Object.assign(Object.create(v.prototype), { constructor: L, preSolve: function(t, i) { this.updateAnchorPoints(), this.ax1.copy(this.localAxis1).applyMatrix3(this.body1.rotation, !0), this.ax2.copy(this.localAxis2).applyMatrix3(this.body2.rotation, !0), this.nor.set(this.ax1.x * this.body2.inverseMass + this.ax2.x * this.body1.inverseMass, this.ax1.y * this.body2.inverseMass + this.ax2.y * this.body1.inverseMass, this.ax1.z * this.body2.inverseMass + this.ax2.z * this.body1.inverseMass).normalize(), this.tan.tangent(this.nor).normalize(), this.bin.crossVectors(this.nor, this.tan), this.ac.preSolve(t, i), this.t3.preSolve(t, i) }, solve: function() { this.ac.solve(), this.t3.solve() }, postSolve: function() { } }), S.prototype = Object.assign(Object.create(v.prototype), { constructor: S, preSolve: function(t, i) { this.updateAnchorPoints(), this.ax1.copy(this.localAxis1).applyMatrix3(this.body1.rotation, !0), this.an1.copy(this.localAngle1).applyMatrix3(this.body1.rotation, !0), this.ax2.copy(this.localAxis2).applyMatrix3(this.body2.rotation, !0), this.an2.copy(this.localAngle2).applyMatrix3(this.body2.rotation, !0), this.nor.set(this.ax1.x * this.body2.inverseMass + this.ax2.x * this.body1.inverseMass, this.ax1.y * this.body2.inverseMass + this.ax2.y * this.body1.inverseMass, this.ax1.z * this.body2.inverseMass + this.ax2.z * this.body1.inverseMass).normalize(), this.tan.tangent(this.nor).normalize(), this.bin.crossVectors(this.nor, this.tan), this.tmp.crossVectors(this.an1, this.an2); var s = Pt.acosClamp(Pt.dotVectors(this.an1, this.an2)); Pt.dotVectors(this.nor, this.tmp) < 0 ? this.rotationalLimitMotor.angle = -s : this.rotationalLimitMotor.angle = s, this.tmp.crossVectors(this.ax1, this.ax2), this.r3.limitMotor2.angle = Pt.dotVectors(this.tan, this.tmp), this.r3.limitMotor3.angle = Pt.dotVectors(this.bin, this.tmp), this.r3.preSolve(t, i), this.t3.preSolve(t, i) }, solve: function() { this.r3.solve(), this.t3.solve() }, postSolve: function() { } }), P.prototype = Object.assign(Object.create(v.prototype), { constructor: P, preSolve: function(t, i) { this.updateAnchorPoints(), this.ax1.copy(this.localAxis1).applyMatrix3(this.body1.rotation, !0), this.an1.copy(this.localAngle1).applyMatrix3(this.body1.rotation, !0), this.ax2.copy(this.localAxis2).applyMatrix3(this.body2.rotation, !0), this.an2.copy(this.localAngle2).applyMatrix3(this.body2.rotation, !0), this.r3.limitMotor1.angle = Pt.dotVectors(this.ax1, this.ax2); var s = Pt.dotVectors(this.an1, this.ax2); Pt.dotVectors(this.ax1, this.tmp.crossVectors(this.an1, this.ax2)) < 0 ? this.rotationalLimitMotor1.angle = -s : this.rotationalLimitMotor1.angle = s, s = Pt.dotVectors(this.an2, this.ax1), Pt.dotVectors(this.ax2, this.tmp.crossVectors(this.an2, this.ax1)) < 0 ? this.rotationalLimitMotor2.angle = -s : this.rotationalLimitMotor2.angle = s, this.nor.crossVectors(this.ax1, this.ax2).normalize(), this.tan.crossVectors(this.nor, this.ax2).normalize(), this.bin.crossVectors(this.nor, this.ax1).normalize(), this.r3.preSolve(t, i), this.t3.preSolve(t, i) }, solve: function() { this.r3.solve(), this.t3.solve() }, postSolve: function() { } }), D.prototype = { constructor: D, reset: function(t, i) { this.body1 = t.parent, this.body2 = i.parent, this.numPoints = 0 }, addPointVec: function(t, i, s, h) { var e = this.points[this.numPoints++]; e.position.copy(t), e.localPoint1.sub(t, this.body1.position).applyMatrix3(this.body1.rotation), e.localPoint2.sub(t, this.body2.position).applyMatrix3(this.body2.rotation), e.normal.copy(i), h && e.normal.negate(), e.normalImpulse = 0, e.penetration = s, e.warmStarted = !1 }, addPoint: function(t, i, s, h, e, a, o, n) { var r = this.points[this.numPoints++]; r.position.set(t, i, s), r.localPoint1.sub(r.position, this.body1.position).applyMatrix3(this.body1.rotation), r.localPoint2.sub(r.position, this.body2.position).applyMatrix3(this.body2.rotation), r.normalImpulse = 0, r.normal.set(h, e, a), n && r.normal.negate(), r.penetration = o, r.warmStarted = !1 } }, B.prototype = Object.assign(Object.create(f.prototype), { constructor: B, attach: function() { this.p1 = this.body1.position, this.p2 = this.body2.position, this.lv1 = this.body1.linearVelocity, this.av1 = this.body1.angularVelocity, this.lv2 = this.body2.linearVelocity, this.av2 = this.body2.angularVelocity, this.i1 = this.body1.inverseInertia, this.i2 = this.body2.inverseInertia }, detach: function() { this.p1 = null, this.p2 = null, this.lv1 = null, this.lv2 = null, this.av1 = null, this.av2 = null, this.i1 = null, this.i2 = null }, preSolve: function(t, i) { this.m1 = this.body1.inverseMass, this.m2 = this.body2.inverseMass; var s = this.m1 + this.m2; this.num = this.manifold.numPoints; for (var h, e, a, o, n, r, l, c = this.cs, m = 0; m < this.num; m++)h = this.ps[m], this.tmpP1.sub(h.position, this.p1), this.tmpP2.sub(h.position, this.p2), this.tmpC1.crossVectors(this.av1, this.tmpP1), this.tmpC2.crossVectors(this.av2, this.tmpP2), c.norImp = h.normalImpulse, c.tanImp = h.tangentImpulse, c.binImp = h.binormalImpulse, c.nor.copy(h.normal), this.tmp.set(this.lv2.x + this.tmpC2.x - (this.lv1.x + this.tmpC1.x), this.lv2.y + this.tmpC2.y - (this.lv1.y + this.tmpC1.y), this.lv2.z + this.tmpC2.z - (this.lv1.z + this.tmpC1.z)), e = Pt.dotVectors(c.nor, this.tmp), c.tan.set(this.tmp.x - e * c.nor.x, this.tmp.y - e * c.nor.y, this.tmp.z - e * c.nor.z), Pt.dotVectors(c.tan, c.tan) <= .04 && c.tan.tangent(c.nor), c.tan.normalize(), c.bin.crossVectors(c.nor, c.tan), c.norU1.scale(c.nor, this.m1), c.norU2.scale(c.nor, this.m2), c.tanU1.scale(c.tan, this.m1), c.tanU2.scale(c.tan, this.m2), c.binU1.scale(c.bin, this.m1), c.binU2.scale(c.bin, this.m2), c.norT1.crossVectors(this.tmpP1, c.nor), c.tanT1.crossVectors(this.tmpP1, c.tan), c.binT1.crossVectors(this.tmpP1, c.bin), c.norT2.crossVectors(this.tmpP2, c.nor), c.tanT2.crossVectors(this.tmpP2, c.tan), c.binT2.crossVectors(this.tmpP2, c.bin), r = this.i1, l = this.i2, c.norTU1.copy(c.norT1).applyMatrix3(r, !0), c.tanTU1.copy(c.tanT1).applyMatrix3(r, !0), c.binTU1.copy(c.binT1).applyMatrix3(r, !0), c.norTU2.copy(c.norT2).applyMatrix3(l, !0), c.tanTU2.copy(c.tanT2).applyMatrix3(l, !0), c.binTU2.copy(c.binT2).applyMatrix3(l, !0), this.tmpC1.crossVectors(c.norTU1, this.tmpP1), this.tmpC2.crossVectors(c.norTU2, this.tmpP2), this.tmp.add(this.tmpC1, this.tmpC2), c.norDen = 1 / (s + Pt.dotVectors(c.nor, this.tmp)), this.tmpC1.crossVectors(c.tanTU1, this.tmpP1), this.tmpC2.crossVectors(c.tanTU2, this.tmpP2), this.tmp.add(this.tmpC1, this.tmpC2), c.tanDen = 1 / (s + Pt.dotVectors(c.tan, this.tmp)), this.tmpC1.crossVectors(c.binTU1, this.tmpP1), this.tmpC2.crossVectors(c.binTU2, this.tmpP2), this.tmp.add(this.tmpC1, this.tmpC2), c.binDen = 1 / (s + Pt.dotVectors(c.bin, this.tmp)), h.warmStarted ? (a = h.normalImpulse, this.lv1.addScaledVector(c.norU1, a), this.av1.addScaledVector(c.norTU1, a), this.lv2.subScaledVector(c.norU2, a), this.av2.subScaledVector(c.norTU2, a), c.norImp = a, c.tanImp = 0, c.binImp = 0, e = 0) : (c.norImp = 0, c.tanImp = 0, c.binImp = 0), e > -1 && (e = 0), (o = this.restitution * -e) < (n = -(h.penetration + .005) * i * .05) && (o = n), c.norTar = o, c.last = m == this.num - 1, c = c.next }, solve: function() { this.tmplv1.copy(this.lv1), this.tmplv2.copy(this.lv2), this.tmpav1.copy(this.av1), this.tmpav2.copy(this.av2); for (var t, i, s, h, e, a, o, n, r, l, c = this.cs; ;) { if (a = c.norImp, o = c.tanImp, n = c.binImp, r = -a * this.friction, this.tmp.sub(this.tmplv2, this.tmplv1), e = Pt.dotVectors(this.tmp, c.tan) + Pt.dotVectors(this.tmpav2, c.tanT2) - Pt.dotVectors(this.tmpav1, c.tanT1), t = o, i = e * c.tanDen, o += i, e = Pt.dotVectors(this.tmp, c.bin) + Pt.dotVectors(this.tmpav2, c.binT2) - Pt.dotVectors(this.tmpav1, c.binT1), s = n, h = e * c.binDen, n += h, (l = o * o + n * n) > r * r && (o *= l = r / Pt.sqrt(l), n *= l), i = o - t, h = n - s, this.tmp.set(c.tanU1.x * i + c.binU1.x * h, c.tanU1.y * i + c.binU1.y * h, c.tanU1.z * i + c.binU1.z * h), this.tmplv1.addEqual(this.tmp), this.tmp.set(c.tanTU1.x * i + c.binTU1.x * h, c.tanTU1.y * i + c.binTU1.y * h, c.tanTU1.z * i + c.binTU1.z * h), this.tmpav1.addEqual(this.tmp), this.tmp.set(c.tanU2.x * i + c.binU2.x * h, c.tanU2.y * i + c.binU2.y * h, c.tanU2.z * i + c.binU2.z * h), this.tmplv2.subEqual(this.tmp), this.tmp.set(c.tanTU2.x * i + c.binTU2.x * h, c.tanTU2.y * i + c.binTU2.y * h, c.tanTU2.z * i + c.binTU2.z * h), this.tmpav2.subEqual(this.tmp), this.tmp.sub(this.tmplv2, this.tmplv1), e = Pt.dotVectors(this.tmp, c.nor) + Pt.dotVectors(this.tmpav2, c.norT2) - Pt.dotVectors(this.tmpav1, c.norT1), t = a, i = (e - c.norTar) * c.norDen, (a += i) > 0 && (a = 0), i = a - t, this.tmplv1.addScaledVector(c.norU1, i), this.tmpav1.addScaledVector(c.norTU1, i), this.tmplv2.subScaledVector(c.norU2, i), this.tmpav2.subScaledVector(c.norTU2, i), c.norImp = a, c.tanImp = o, c.binImp = n, c.last) break; c = c.next } this.lv1.copy(this.tmplv1), this.lv2.copy(this.tmplv2), this.av1.copy(this.tmpav1), this.av2.copy(this.tmpav2) }, postSolve: function() { for (var t, i = this.cs, s = this.num; s--;)(t = this.ps[s]).normal.copy(i.nor), t.tangent.copy(i.tan), t.binormal.copy(i.bin), t.normalImpulse = i.norImp, t.tangentImpulse = i.tanImp, t.binormalImpulse = i.binImp, t.normalDenominator = i.norDen, t.tangentDenominator = i.tanDen, t.binormalDenominator = i.binDen, i = i.next } }), Object.assign(F.prototype, { Contact: !0, mixRestitution: function(t, i) { return Pt.sqrt(t * i) }, mixFriction: function(t, i) { return Pt.sqrt(t * i) }, updateManifold: function() { this.constraint.restitution = this.mixRestitution(this.shape1.restitution, this.shape2.restitution), this.constraint.friction = this.mixFriction(this.shape1.friction, this.shape2.friction); for (var t = this.manifold.numPoints, i = t; i--;) { var s = this.buffer[i], h = this.points[i]; s.lp1X = h.localPoint1.x, s.lp1Y = h.localPoint1.y, s.lp1Z = h.localPoint1.z, s.lp2X = h.localPoint2.x, s.lp2Y = h.localPoint2.y, s.lp2Z = h.localPoint2.z, s.impulse = h.normalImpulse } this.manifold.numPoints = 0, this.detector.detectCollision(this.shape1, this.shape2, this.manifold); var e = this.manifold.numPoints; if (0 == e) return this.touching = !1, this.close = !1, void (this.dist = Pt.INF); for ((this.touching || this.dist < .001) && (this.close = !0), this.touching = !0, i = e; i--;) { for (var a = (h = this.points[i]).localPoint1.x, o = h.localPoint1.y, n = h.localPoint1.z, r = h.localPoint2.x, l = h.localPoint2.y, c = h.localPoint2.z, m = -1, p = 4e-4, u = t; u--;) { var y = (s = this.buffer[u]).lp1X - a, x = s.lp1Y - o, d = s.lp1Z - n, f = y * y + x * x + d * d, b = (y = s.lp2X - r) * y + (x = s.lp2Y - l) * x + (d = s.lp2Z - c) * d; f < b ? f < p && (p = f, m = u) : b < p && (p = b, m = u), p < this.dist && (this.dist = p) } if (-1 != m) { var v = this.buffer[m]; this.buffer[m] = this.buffer[--t], this.buffer[t] = v, h.normalImpulse = v.impulse, h.warmStarted = !0 } else h.normalImpulse = 0, h.warmStarted = !1 } }, attach: function(t, i) { this.shape1 = t, this.shape2 = i, this.body1 = t.parent, this.body2 = i.parent, this.manifold.body1 = this.body1, this.manifold.body2 = this.body2, this.constraint.body1 = this.body1, this.constraint.body2 = this.body2, this.constraint.attach(), this.s1Link.shape = i, this.s1Link.body = this.body2, this.s2Link.shape = t, this.s2Link.body = this.body1, null != t.contactLink ? (this.s1Link.next = t.contactLink).prev = this.s1Link : this.s1Link.next = null, t.contactLink = this.s1Link, t.numContacts++ , null != i.contactLink ? (this.s2Link.next = i.contactLink).prev = this.s2Link : this.s2Link.next = null, i.contactLink = this.s2Link, i.numContacts++ , this.b1Link.shape = i, this.b1Link.body = this.body2, this.b2Link.shape = t, this.b2Link.body = this.body1, null != this.body1.contactLink ? (this.b1Link.next = this.body1.contactLink).prev = this.b1Link : this.b1Link.next = null, this.body1.contactLink = this.b1Link, this.body1.numContacts++ , null != this.body2.contactLink ? (this.b2Link.next = this.body2.contactLink).prev = this.b2Link : this.b2Link.next = null, this.body2.contactLink = this.b2Link, this.body2.numContacts++ , this.prev = null, this.next = null, this.persisting = !0, this.sleeping = this.body1.sleeping && this.body2.sleeping, this.manifold.numPoints = 0 }, detach: function() { var t = this.s1Link.prev, i = this.s1Link.next; null !== t && (t.next = i), null !== i && (i.prev = t), this.shape1.contactLink == this.s1Link && (this.shape1.contactLink = i), this.s1Link.prev = null, this.s1Link.next = null, this.s1Link.shape = null, this.s1Link.body = null, this.shape1.numContacts-- , t = this.s2Link.prev, i = this.s2Link.next, null !== t && (t.next = i), null !== i && (i.prev = t), this.shape2.contactLink == this.s2Link && (this.shape2.contactLink = i), this.s2Link.prev = null, this.s2Link.next = null, this.s2Link.shape = null, this.s2Link.body = null, this.shape2.numContacts-- , t = this.b1Link.prev, i = this.b1Link.next, null !== t && (t.next = i), null !== i && (i.prev = t), this.body1.contactLink == this.b1Link && (this.body1.contactLink = i), this.b1Link.prev = null, this.b1Link.next = null, this.b1Link.shape = null, this.b1Link.body = null, this.body1.numContacts-- , t = this.b2Link.prev, i = this.b2Link.next, null !== t && (t.next = i), null !== i && (i.prev = t), this.body2.contactLink == this.b2Link && (this.body2.contactLink = i), this.b2Link.prev = null, this.b2Link.next = null, this.b2Link.shape = null, this.b2Link.body = null, this.body2.numContacts-- , this.manifold.body1 = null, this.manifold.body2 = null, this.constraint.body1 = null, this.constraint.body2 = null, this.constraint.detach(), this.shape1 = null, this.shape2 = null, this.body1 = null, this.body2 = null } }), Object.assign(q.prototype, { setParent: function(t) { this.parent = t, this.scale = this.parent.scale, this.invScale = this.parent.invScale, this.id = this.parent.numRigidBodies, this.name || (this.name = this.id), this.updateMesh() }, addShape: function(t) { t.parent && s("RigidBody", "It is not possible that you add a shape which already has an associated body."), null != this.shapes && ((this.shapes.prev = t).next = this.shapes), this.shapes = t, t.parent = this, this.parent && this.parent.addShape(t), this.numShapes++ }, removeShape: function(t) { var i = t; if (i.parent == this) { var s = i.prev, h = i.next; null != s && (s.next = h), null != h && (h.prev = s), this.shapes == i && (this.shapes = h), i.prev = null, i.next = null, i.parent = null, this.parent && this.parent.removeShape(i), this.numShapes-- } }, remove: function() { this.dispose() }, dispose: function() { this.parent.removeRigidBody(this) }, checkContact: function(t) { this.parent.checkContact(this.name, t) }, setupMass: function(t, i) { var s = void 0 === i || i; this.type = t || 2, this.isDynamic = 1 === this.type, this.isStatic = 2 === this.type, this.mass = 0, this.localInertia.set(0, 0, 0, 0, 0, 0, 0, 0, 0); for (var h = new o, a = new e, n = this.shapes; null !== n; n = n.next) { n.calculateMassInfo(this.massInfo); var r = this.massInfo.mass; a.addScaledVector(n.relativePosition, r), this.mass += r, this.rotateInertia(n.relativeRotation, this.massInfo.inertia, h), this.localInertia.add(h), this.localInertia.addOffset(r, n.relativePosition) } if (this.inverseMass = 1 / this.mass, a.scaleEqual(this.inverseMass), s) { for (this.position.add(a), n = this.shapes; null !== n; n = n.next)n.relativePosition.subEqual(a); this.localInertia.subOffset(this.mass, a) } this.inverseLocalInertia.invert(this.localInertia), 2 === this.type && (this.inverseMass = 0, this.inverseLocalInertia.set(0, 0, 0, 0, 0, 0, 0, 0, 0)), this.syncShapes(), this.awake() }, awake: function() { if (this.allowSleep && this.sleeping) { this.sleeping = !1, this.sleepTime = 0; for (var t = this.contactLink; null != t;)t.body.sleepTime = 0, t.body.sleeping = !1, t = t.next; for (var i = this.jointLink; null != i;)i.body.sleepTime = 0, i.body.sleeping = !1, i = i.next; for (var s = this.shapes; null != s; s = s.next)s.updateProxy() } }, sleep: function() { if (this.allowSleep && !this.sleeping) { this.linearVelocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0), this.sleepPosition.copy(this.position), this.sleepOrientation.copy(this.orientation), this.sleepTime = 0, this.sleeping = !0; for (var t = this.shapes; null != t; t = t.next)t.updateProxy() } }, testWakeUp: function() { (this.linearVelocity.testZero() || this.angularVelocity.testZero() || this.position.testDiff(this.sleepPosition) || this.orientation.testDiff(this.sleepOrientation)) && this.awake() }, isLonely: function() { return 0 == this.numJoints && 0 == this.numContacts }, updatePosition: function(t) { switch (this.type) { case 2: this.linearVelocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0), this.controlPos && (this.position.copy(this.newPosition), this.controlPos = !1), this.controlRot && (this.orientation.copy(this.newOrientation), this.controlRot = !1); break; case 1: this.isKinematic && (this.linearVelocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0)), this.controlPos && (this.linearVelocity.subVectors(this.newPosition, this.position).multiplyScalar(1 / t), this.controlPos = !1), this.controlRot && (this.angularVelocity.copy(this.getAxis()), this.orientation.copy(this.newOrientation), this.controlRot = !1), this.position.addScaledVector(this.linearVelocity, t), this.orientation.addTime(this.angularVelocity, t), this.updateMesh(); break; default: s("RigidBody", "Invalid type.") }this.syncShapes(), this.updateMesh() }, getAxis: function() { return new e(0, 1, 0).applyMatrix3(this.inverseLocalInertia, !0).normalize() }, rotateInertia: function(t, i, s) { this.tmpInertia.multiplyMatrices(t, i), s.multiplyMatrices(this.tmpInertia, t, !0) }, syncShapes: function() { this.rotation.setQuat(this.orientation), this.rotateInertia(this.rotation, this.inverseLocalInertia, this.inverseInertia); for (var t = this.shapes; null != t; t = t.next)t.position.copy(t.relativePosition).applyMatrix3(this.rotation, !0).add(this.position), t.rotation.multiplyMatrices(this.rotation, t.relativeRotation), t.updateProxy() }, applyImpulse: function(t, i) { this.linearVelocity.addScaledVector(i, this.inverseMass); var s = (new e).copy(t).sub(this.position).cross(i).applyMatrix3(this.inverseInertia, !0); this.angularVelocity.add(s) }, setPosition: function(t) { this.newPosition.copy(t).multiplyScalar(this.invScale), this.controlPos = !0, this.isKinematic || (this.isKinematic = !0) }, setQuaternion: function(t) { this.newOrientation.set(t.x, t.y, t.z, t.w), this.controlRot = !0, this.isKinematic || (this.isKinematic = !0) }, setRotation: function(t) { this.newOrientation = (new a).setFromEuler(t.x * Pt.degtorad, t.y * Pt.degtorad, t.z * Pt.degtorad), this.controlRot = !0 }, resetPosition: function(t, i, s) { this.linearVelocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0), this.position.set(t, i, s).multiplyScalar(this.invScale), this.awake() }, resetQuaternion: function(t) { this.angularVelocity.set(0, 0, 0), this.orientation = new a(t.x, t.y, t.z, t.w), this.awake() }, resetRotation: function(t, i, s) { this.angularVelocity.set(0, 0, 0), this.orientation = (new a).setFromEuler(t * Pt.degtorad, i * Pt.degtorad, s * Pt.degtorad), this.awake() }, getPosition: function() { return this.pos }, getQuaternion: function() { return this.quaternion }, connectMesh: function(t) { this.mesh = t, this.updateMesh() }, updateMesh: function() { this.pos.scale(this.position, this.scale), this.quaternion.copy(this.orientation), null !== this.mesh && (this.mesh.position.copy(this.getPosition()), this.mesh.quaternion.copy(this.getQuaternion())) } }), Object.assign(R.prototype, { BroadPhase: !0, createProxy: function(t) { s("BroadPhase", "Inheritance error.") }, addProxy: function(t) { s("BroadPhase", "Inheritance error.") }, removeProxy: function(t) { s("BroadPhase", "Inheritance error.") }, isAvailablePair: function(t, i) { var s = t.parent, h = i.parent; if (s == h || !s.isDynamic && !h.isDynamic || 0 == (t.belongsTo & i.collidesWith) || 0 == (i.belongsTo & t.collidesWith)) return !1; var e; for (e = s.numJoints < h.numJoints ? s.jointLink : h.jointLink; null !== e;) { var a = e.joint; if (!a.allowCollision && (a.body1 == s && a.body2 == h || a.body1 == h && a.body2 == s)) return !1; e = e.next } return !0 }, detectPairs: function() { this.pairs = [], this.numPairs = 0, this.numPairChecks = 0, this.collectPairs() }, collectPairs: function() { Error("BroadPhase", "Inheritance error.") }, addPair: function(t, i) { var s = new U(t, i); this.pairs.push(s), this.numPairs++ } }); var At = 0; Object.assign(J.prototype, { Proxy: !0, update: function() { s("Proxy", "Inheritance error.") } }), W.prototype = Object.assign(Object.create(J.prototype), { constructor: W, update: function() { } }), H.prototype = Object.assign(Object.create(R.prototype), { constructor: H, createProxy: function(t) { return new W(t) }, addProxy: function(t) { this.proxies.push(t) }, removeProxy: function(t) { var i = this.proxies.indexOf(t); i > -1 && this.proxies.splice(i, 1) }, collectPairs: function() { var t, i, s, h = 0, e = this.proxies, a = e.length; for (this.numPairChecks = a * (a - 1) >> 1; h < a;)for (i = e[h++], t = h + 1; t < a;)s = e[t++], !i.aabb.intersectTest(s.aabb) && this.isAvailablePair(i.shape, s.shape) && this.addPair(i.shape, s.shape) } }), Object.assign(Q.prototype, { SAPAxis: !0, addElements: function(t, i) { if (this.numElements + 2 >= this.bufferSize) { this.bufferSize *= 2; for (var s = [], h = this.numElements; h--;)s[h] = this.elements[h] } this.elements[this.numElements++] = t, this.elements[this.numElements++] = i }, removeElements: function(t, i) { for (var s = -1, h = -1, e = 0, a = this.numElements; e < a; e++) { var o = this.elements[e]; if (o == t || o == i) { if (-1 != s) { h = e; break } s = e } } for (e = s + 1, a = h; e < a; e++)this.elements[e - 1] = this.elements[e]; for (e = h + 1, a = this.numElements; e < a; e++)this.elements[e - 2] = this.elements[e]; this.elements[--this.numElements] = null, this.elements[--this.numElements] = null }, sort: function() { for (var t = 0, i = 1; this.numElements >> i != 0;)i++; i = i * this.numElements >> 2, t = 0; for (var s = !1, h = this.elements, e = 1, a = this.numElements; e < a; e++) { var o = h[e], n = o.value, r = h[e - 1]; if (r.value > n) { var l = e; do { if (h[l] = r, 0 == --l) break; r = h[l - 1] } while (r.value > n); if (h[l] = o, (t += e - l) > i) { s = !0; break } } } if (s) { t = 2; var c = this.stack; for (c[0] = 0, c[1] = this.numElements - 1; t > 0;) { var m = c[--t], p = c[--t], u = m - p; if (u > 16) { var y = p + Pt.floor(.5 * u); for (o = h[y], h[y] = h[m], h[m] = o, n = o.value, e = p - 1, l = m; ;) { var x, d; do { x = h[++e] } while (x.value < n); do { d = h[--l] } while (n < d.value && l != p); if (e >= l) break; h[e] = d, h[l] = x } h[m] = h[e], h[e] = o, e - p > m - e ? (c[t++] = p, c[t++] = e - 1, c[t++] = e + 1, c[t++] = m) : (c[t++] = e + 1, c[t++] = m, c[t++] = p, c[t++] = e - 1) } else for (e = p + 1; e <= m; e++)if (o = h[e], n = o.value, (r = h[e - 1]).value > n) { l = e; do { if (h[l] = r, 0 == --l) break; r = h[l - 1] } while (r.value > n); h[l] = o } } } }, calculateTestCount: function() { for (var t = 1, i = 0, s = 1, h = this.numElements; s < h; s++)this.elements[s].max ? t-- : (i += t, t++); return i } }), Y.prototype = Object.assign(Object.create(J.prototype), { constructor: Y, isDynamic: function() { var t = this.shape.parent; return t.isDynamic && !t.sleeping }, update: function() { var t = this.aabb.elements; this.min[0].value = t[0], this.min[1].value = t[1], this.min[2].value = t[2], this.max[0].value = t[3], this.max[1].value = t[4], this.max[2].value = t[5], (1 == this.belongsTo && !this.isDynamic() || 2 == this.belongsTo && this.isDynamic()) && (this.sap.removeProxy(this), this.sap.addProxy(this)) } }), Z.prototype = Object.assign(Object.create(R.prototype), { constructor: Z, createProxy: function(t) { return new Y(this, t) }, addProxy: function(t) { var i = t; i.isDynamic() ? (this.axesD[0].addElements(i.min[0], i.max[0]), this.axesD[1].addElements(i.min[1], i.max[1]), this.axesD[2].addElements(i.min[2], i.max[2]), i.belongsTo = 1, this.numElementsD += 2) : (this.axesS[0].addElements(i.min[0], i.max[0]), this.axesS[1].addElements(i.min[1], i.max[1]), this.axesS[2].addElements(i.min[2], i.max[2]), i.belongsTo = 2, this.numElementsS += 2) }, removeProxy: function(t) { var i = t; if (0 != i.belongsTo) { switch (i.belongsTo) { case 1: this.axesD[0].removeElements(i.min[0], i.max[0]), this.axesD[1].removeElements(i.min[1], i.max[1]), this.axesD[2].removeElements(i.min[2], i.max[2]), this.numElementsD -= 2; break; case 2: this.axesS[0].removeElements(i.min[0], i.max[0]), this.axesS[1].removeElements(i.min[1], i.max[1]), this.axesS[2].removeElements(i.min[2], i.max[2]), this.numElementsS -= 2 }i.belongsTo = 0 } }, collectPairs: function() { if (0 != this.numElementsD) { var t = this.axesD[this.index1], i = this.axesD[this.index2]; t.sort(), i.sort(); var s, h; t.calculateTestCount() <= i.calculateTestCount() ? ((i = this.axesS[this.index1]).sort(), s = t.elements, h = i.elements) : ((t = this.axesS[this.index2]).sort(), s = i.elements, h = t.elements, this.index1 ^= this.index2, this.index2 ^= this.index1, this.index1 ^= this.index2); for (var e, a, o = 0, n = 0; o < this.numElementsD;) { var r, l; if (n == this.numElementsS) r = s[o], l = !0, o++; else { var c = s[o], m = h[n]; c.value < m.value ? (r = c, l = !0, o++) : (r = m, l = !1, n++) } if (r.max) { var p = r.pair; if (l) { if (p == e) { e = e.pair; continue } r = e } else { if (p == a) { a = a.pair; continue } r = a } do { if ((b = r.pair) == p) { r.pair = b.pair; break } r = b } while (null != r) } else { for (var u = r.proxy.shape, y = r.min1.value, x = r.max1.value, d = r.min2.value, f = r.max2.value, b = e; null != b; b = b.pair) { var v = b.proxy.shape; this.numPairChecks++ , y > b.max1.value || x < b.min1.value || d > b.max2.value || f < b.min2.value || !this.isAvailablePair(u, v) || this.addPair(u, v) } if (l) { for (b = a; null != b; b = b.pair)v = b.proxy.shape, this.numPairChecks++ , y > b.max1.value || x < b.min1.value || d > b.max2.value || f < b.min2.value || !this.isAvailablePair(u, v) || this.addPair(u, v); r.pair = e, e = r } else r.pair = a, a = r } } this.index2 = 3 ^ (this.index1 | this.index2) } } }), Object.assign(G.prototype, { DBVT: !0, moveLeaf: function(t) { this.deleteLeaf(t), this.insertLeaf(t) }, insertLeaf: function(t) { if (null == this.root) return void (this.root = t); for (var i, s, h = t.aabb, e = this.root; null == e.proxy;) { var a = e.child1, o = e.child2, n = e.aabb, r = a.aabb, l = o.aabb; i = n.surfaceArea(), this.aabb.combine(h, n); var c = 2 * (s = this.aabb.surfaceArea()), m = 2 * (s - i), p = m; this.aabb.combine(h, r), null != a.proxy ? p += this.aabb.surfaceArea() : p += this.aabb.surfaceArea() - r.surfaceArea(); var u = m; if (this.aabb.combine(h, l), null != o.proxy ? u += this.aabb.surfaceArea() : u += this.aabb.surfaceArea() - l.surfaceArea(), p < u) { if (c < p) break; e = a } else { if (c < u) break; e = o } } var y, x = e.parent; (y = this.numFreeNodes > 0 ? this.freeNodes[--this.numFreeNodes] : new K).parent = x, y.child1 = t, y.child2 = e, y.aabb.combine(t.aabb, e.aabb), y.height = e.height + 1, e.parent = y, t.parent = y, e == this.root ? this.root = y : x.child1 == e ? x.child1 = y : x.child2 = y; do { y = this.balance(y), this.fix(y), y = y.parent } while (null != y) }, getBalance: function(t) { return null != t.proxy ? 0 : t.child1.height - t.child2.height }, deleteLeaf: function(t) { if (t == this.root) return void (this.root = null); var i, s = t.parent; if (i = s.child1 == t ? s.child2 : s.child1, s == this.root) return this.root = i, void (i.parent = null); var h = s.parent; i.parent = h, h.child1 == s ? h.child1 = i : h.child2 = i, this.numFreeNodes < 16384 && (this.freeNodes[this.numFreeNodes++] = s); do { h = this.balance(h), this.fix(h), h = h.parent } while (null != h) }, balance: function(t) { var i = t.height; if (i < 2) return t; var s, h = t.parent, e = t.child1, a = t.child2, o = e.height, n = a.height, r = o - n; if (r > 1) { var l = e.child1, c = e.child2, m = l.height, p = c.height; return m > p ? (e.child2 = t, t.parent = e, t.child1 = c, c.parent = t, t.aabb.combine(c.aabb, a.aabb), s = p - n, t.height = p - (s & s >> 31) + 1, e.aabb.combine(l.aabb, t.aabb), s = m - i, e.height = m - (s & s >> 31) + 1) : (e.child1 = t, t.parent = e, t.child1 = l, l.parent = t, t.aabb.combine(l.aabb, a.aabb), s = m - n, t.height = m - (s & s >> 31) + 1, e.aabb.combine(t.aabb, c.aabb), s = i - p, e.height = i - (s & s >> 31) + 1), null != h ? h.child1 == t ? h.child1 = e : h.child2 = e : this.root = e, e.parent = h, e } if (r < -1) { var u = a.child1, y = a.child2, x = u.height, d = y.height; return x > d ? (a.child2 = t, t.parent = a, t.child2 = y, y.parent = t, t.aabb.combine(e.aabb, y.aabb), s = o - d, t.height = o - (s & s >> 31) + 1, a.aabb.combine(u.aabb, t.aabb), s = x - i, a.height = x - (s & s >> 31) + 1) : (a.child1 = t, t.parent = a, t.child2 = u, u.parent = t, t.aabb.combine(e.aabb, u.aabb), s = o - x, t.height = o - (s & s >> 31) + 1, a.aabb.combine(t.aabb, y.aabb), s = i - d, a.height = i - (s & s >> 31) + 1), null != h ? h.child1 == t ? h.child1 = a : h.child2 = a : this.root = a, a.parent = h, a } return t }, fix: function(t) { var i = t.child1, s = t.child2; t.aabb.combine(i.aabb, s.aabb), t.height = i.height < s.height ? s.height + 1 : i.height + 1 } }), $.prototype = Object.assign(Object.create(J.prototype), { constructor: $, update: function() { } }), tt.prototype = Object.assign(Object.create(R.prototype), { constructor: tt, createProxy: function(t) { return new $(t) }, addProxy: function(t) { this.tree.insertLeaf(t.leaf), this.leaves.push(t.leaf), this.numLeaves++ }, removeProxy: function(t) { this.tree.deleteLeaf(t.leaf); var i = this.leaves.indexOf(t.leaf); i > -1 && (this.leaves.splice(i, 1), this.numLeaves--) }, collectPairs: function() { if (!(this.numLeaves < 2)) for (var t, i = this.numLeaves; i--;)(t = this.leaves[i]).proxy.aabb.intersectTestTwo(t.aabb) && (t.aabb.copy(t.proxy.aabb, .1), this.tree.deleteLeaf(t), this.tree.insertLeaf(t), this.collide(t, this.tree.root)) }, collide: function(t, i) { var s, h, e, a, o, n, r = 2; for (this.stack[0] = t, this.stack[1] = i; r > 0;)if (e = this.stack[--r], a = this.stack[--r], o = null != e.proxy, n = null != a.proxy, this.numPairChecks++ , o && n) { if (s = e.proxy.shape, h = a.proxy.shape, s == h || s.aabb.intersectTest(h.aabb) || !this.isAvailablePair(s, h)) continue; this.addPair(s, h) } else { if (e.aabb.intersectTest(a.aabb)) continue; n || !o && e.aabb.surfaceArea() > a.aabb.surfaceArea() ? (this.stack[r++] = e.child1, this.stack[r++] = a, this.stack[r++] = e.child2, this.stack[r++] = a) : (this.stack[r++] = e, this.stack[r++] = a.child1, this.stack[r++] = e, this.stack[r++] = a.child2) } } }), Object.assign(it.prototype, { CollisionDetector: !0, detectCollision: function(t, i, h) { s("CollisionDetector", "Inheritance error.") } }), st.prototype = Object.assign(Object.create(it.prototype), { constructor: st, detectCollision: function(t, i, s) { var h, e; t.id < i.id ? (h = t, e = i) : (h = i, e = t); var a, o, n, r, l, c, m, p, u, y, x, d, f, b, v, z, N, k, w, M, g, I, V, L, S, P, T, A, j, O, C, D, E, B, F, q, U = h.elements, R = e.elements, _ = h.dimentions, J = e.dimentions, W = h.position, H = e.position, Q = W.x, X = W.y, Y = W.z, Z = H.x, K = H.y, G = H.z, $ = Z - Q, tt = K - X, it = G - Y, st = h.halfWidth, ht = h.halfHeight, et = h.halfDepth, at = e.halfWidth, ot = e.halfHeight, nt = e.halfDepth, rt = _[0], lt = _[1], ct = _[2], mt = _[3], pt = _[4], ut = _[5], yt = _[6], xt = _[7], dt = _[8], ft = _[9], bt = _[10], vt = _[11], zt = _[12], Nt = _[13], kt = _[14], wt = _[15], Mt = _[16], gt = _[17], It = J[0], Vt = J[1], Lt = J[2], St = J[3], Tt = J[4], At = J[5], jt = J[6], Ot = J[7], Ct = J[8], Dt = J[9], Et = J[10], Bt = J[11], Ft = J[12], qt = J[13], Ut = J[14], Rt = J[15], _t = J[16], Jt = J[17], Wt = lt * Lt - ct * Vt, Ht = ct * It - rt * Lt, Qt = rt * Vt - lt * It, Xt = lt * At - ct * Tt, Yt = ct * St - rt * At, Zt = rt * Tt - lt * St, Kt = lt * Ct - ct * Ot, Gt = ct * jt - rt * Ct, $t = rt * Ot - lt * jt, ti = pt * Lt - ut * Vt, ii = ut * It - mt * Lt, si = mt * Vt - pt * It, hi = pt * At - ut * Tt, ei = ut * St - mt * At, ai = mt * Tt - pt * St, oi = pt * Ct - ut * Ot, ni = ut * jt - mt * Ct, ri = mt * Ot - pt * jt, li = xt * Lt - dt * Vt, ci = dt * It - yt * Lt, mi = yt * Vt - xt * It, pi = xt * At - dt * Tt, ui = dt * St - yt * At, yi = yt * Tt - xt * St, xi = xt * Ct - dt * Ot, di = dt * jt - yt * Ct, fi = yt * Ot - xt * jt, bi = !1, vi = !1, zi = !1, Ni = !1, ki = !1, wi = !1, Mi = !1, gi = !1, Ii = !1; if (C = rt * $ + lt * tt + ct * it, (a = C > 0) || (C = -C), D = st, B = rt * It + lt * Vt + ct * Lt, F = rt * St + lt * Tt + ct * At, q = rt * jt + lt * Ot + ct * Ct, B < 0 && (B = -B), F < 0 && (F = -F), q < 0 && (q = -q), E = B * at + F * ot + q * nt, !((z = C - D - E) > 0 || (C = mt * $ + pt * tt + ut * it, (o = C > 0) || (C = -C), D = ht, B = mt * It + pt * Vt + ut * Lt, F = mt * St + pt * Tt + ut * At, q = mt * jt + pt * Ot + ut * Ct, B < 0 && (B = -B), F < 0 && (F = -F), q < 0 && (q = -q), E = B * at + F * ot + q * nt, (N = C - D - E) > 0 || (C = yt * $ + xt * tt + dt * it, (n = C > 0) || (C = -C), D = et, B = yt * It + xt * Vt + dt * Lt, F = yt * St + xt * Tt + dt * At, q = yt * jt + xt * Ot + dt * Ct, B < 0 && (B = -B), F < 0 && (F = -F), q < 0 && (q = -q), E = B * at + F * ot + q * nt, (k = C - D - E) > 0 || (C = It * $ + Vt * tt + Lt * it, (r = C > 0) || (C = -C), B = It * rt + Vt * lt + Lt * ct, F = It * mt + Vt * pt + Lt * ut, q = It * yt + Vt * xt + Lt * dt, B < 0 && (B = -B), F < 0 && (F = -F), q < 0 && (q = -q), D = B * st + F * ht + q * et, E = at, (w = 1 * (C - D - E)) > 0 || (C = St * $ + Tt * tt + At * it, (l = C > 0) || (C = -C), B = St * rt + Tt * lt + At * ct, F = St * mt + Tt * pt + At * ut, q = St * yt + Tt * xt + At * dt, B < 0 && (B = -B), F < 0 && (F = -F), q < 0 && (q = -q), D = B * st + F * ht + q * et, E = ot, (M = 1 * (C - D - E)) > 0 || (C = jt * $ + Ot * tt + Ct * it, (c = C > 0) || (C = -C), B = jt * rt + Ot * lt + Ct * ct, F = jt * mt + Ot * pt + Ct * ut, q = jt * yt + Ot * xt + Ct * dt, B < 0 && (B = -B), F < 0 && (F = -F), q < 0 && (q = -q), D = B * st + F * ht + q * et, E = nt, (g = 1 * (C - D - E)) > 0))))))) { if ((C = Wt * Wt + Ht * Ht + Qt * Qt) > 1e-5) { if (C = 1 / Pt.sqrt(C), Wt *= C, Ht *= C, Qt *= C, C = Wt * $ + Ht * tt + Qt * it, (m = C > 0) || (C = -C), B = Wt * mt + Ht * pt + Qt * ut, F = Wt * yt + Ht * xt + Qt * dt, B < 0 && (B = -B), F < 0 && (F = -F), D = B * ht + F * et, B = Wt * St + Ht * Tt + Qt * At, F = Wt * jt + Ht * Ot + Qt * Ct, B < 0 && (B = -B), F < 0 && (F = -F), E = B * ot + F * nt, (I = C - D - E) > 0) return } else m = !1, I = 0, bi = !0; if ((C = Xt * Xt + Yt * Yt + Zt * Zt) > 1e-5) { if (C = 1 / Pt.sqrt(C), Xt *= C, Yt *= C, Zt *= C, C = Xt * $ + Yt * tt + Zt * it, (p = C > 0) || (C = -C), B = Xt * mt + Yt * pt + Zt * ut, F = Xt * yt + Yt * xt + Zt * dt, B < 0 && (B = -B), F < 0 && (F = -F), D = B * ht + F * et, B = Xt * It + Yt * Vt + Zt * Lt, F = Xt * jt + Yt * Ot + Zt * Ct, B < 0 && (B = -B), F < 0 && (F = -F), E = B * at + F * nt, (V = C - D - E) > 0) return } else p = !1, V = 0, vi = !0; if ((C = Kt * Kt + Gt * Gt + $t * $t) > 1e-5) { if (C = 1 / Pt.sqrt(C), Kt *= C, Gt *= C, $t *= C, C = Kt * $ + Gt * tt + $t * it, (u = C > 0) || (C = -C), B = Kt * mt + Gt * pt + $t * ut, F = Kt * yt + Gt * xt + $t * dt, B < 0 && (B = -B), F < 0 && (F = -F), D = B * ht + F * et, B = Kt * It + Gt * Vt + $t * Lt, F = Kt * St + Gt * Tt + $t * At, B < 0 && (B = -B), F < 0 && (F = -F), E = B * at + F * ot, (L = C - D - E) > 0) return } else u = !1, L = 0, zi = !0; if ((C = ti * ti + ii * ii + si * si) > 1e-5) { if (C = 1 / Pt.sqrt(C), ti *= C, ii *= C, si *= C, C = ti * $ + ii * tt + si * it, (y = C > 0) || (C = -C), B = ti * rt + ii * lt + si * ct, F = ti * yt + ii * xt + si * dt, B < 0 && (B = -B), F < 0 && (F = -F), D = B * st + F * et, B = ti * St + ii * Tt + si * At, F = ti * jt + ii * Ot + si * Ct, B < 0 && (B = -B), F < 0 && (F = -F), E = B * ot + F * nt, (S = C - D - E) > 0) return } else y = !1, S = 0, Ni = !0; if ((C = hi * hi + ei * ei + ai * ai) > 1e-5) { if (C = 1 / Pt.sqrt(C), hi *= C, ei *= C, ai *= C, C = hi * $ + ei * tt + ai * it, (x = C > 0) || (C = -C), B = hi * rt + ei * lt + ai * ct, F = hi * yt + ei * xt + ai * dt, B < 0 && (B = -B), F < 0 && (F = -F), D = B * st + F * et, B = hi * It + ei * Vt + ai * Lt, F = hi * jt + ei * Ot + ai * Ct, B < 0 && (B = -B), F < 0 && (F = -F), E = B * at + F * nt, (P = C - D - E) > 0) return } else x = !1, P = 0, ki = !0; if ((C = oi * oi + ni * ni + ri * ri) > 1e-5) { if (C = 1 / Pt.sqrt(C), oi *= C, ni *= C, ri *= C, C = oi * $ + ni * tt + ri * it, (d = C > 0) || (C = -C), B = oi * rt + ni * lt + ri * ct, F = oi * yt + ni * xt + ri * dt, B < 0 && (B = -B), F < 0 && (F = -F), D = B * st + F * et, B = oi * It + ni * Vt + ri * Lt, F = oi * St + ni * Tt + ri * At, B < 0 && (B = -B), F < 0 && (F = -F), E = B * at + F * ot, (T = C - D - E) > 0) return } else d = !1, T = 0, wi = !0; if ((C = li * li + ci * ci + mi * mi) > 1e-5) { if (C = 1 / Pt.sqrt(C), li *= C, ci *= C, mi *= C, C = li * $ + ci * tt + mi * it, (f = C > 0) || (C = -C), B = li * rt + ci * lt + mi * ct, F = li * mt + ci * pt + mi * ut, B < 0 && (B = -B), F < 0 && (F = -F), D = B * st + F * ht, B = li * St + ci * Tt + mi * At, F = li * jt + ci * Ot + mi * Ct, B < 0 && (B = -B), F < 0 && (F = -F), E = B * ot + F * nt, (A = C - D - E) > 0) return } else f = !1, A = 0, Mi = !0; if ((C = pi * pi + ui * ui + yi * yi) > 1e-5) { if (C = 1 / Pt.sqrt(C), pi *= C, ui *= C, yi *= C, C = pi * $ + ui * tt + yi * it, (b = C > 0) || (C = -C), B = pi * rt + ui * lt + yi * ct, F = pi * mt + ui * pt + yi * ut, B < 0 && (B = -B), F < 0 && (F = -F), D = B * st + F * ht, B = pi * It + ui * Vt + yi * Lt, F = pi * jt + ui * Ot + yi * Ct, B < 0 && (B = -B), F < 0 && (F = -F), E = B * at + F * nt, (j = C - D - E) > 0) return } else b = !1, j = 0, gi = !0; if ((C = xi * xi + di * di + fi * fi) > 1e-5) { if (C = 1 / Pt.sqrt(C), xi *= C, di *= C, fi *= C, C = xi * $ + di * tt + fi * it, (v = C > 0) || (C = -C), B = xi * rt + di * lt + fi * ct, F = xi * mt + di * pt + fi * ut, B < 0 && (B = -B), F < 0 && (F = -F), D = B * st + F * ht, B = xi * It + di * Vt + fi * Lt, F = xi * St + di * Tt + fi * At, B < 0 && (B = -B), F < 0 && (F = -F), E = B * at + F * ot, (O = C - D - E) > 0) return } else v = !1, O = 0, Ii = !0; var Vi = z, Li = z, Si = 0, Pi = a; N > Li && (Vi = N, Li = N, Si = 1, Pi = o), k > Li && (Vi = k, Li = k, Si = 2, Pi = n), w > Li && (Vi = w, Li = w, Si = 3, Pi = r), M > Li && (Vi = M, Li = M, Si = 4, Pi = l), g > Li && (Vi = g, Li = g, Si = 5, Pi = c), I - .01 > Li && !bi && (Vi = I, Li = I - .01, Si = 6, Pi = m), V - .01 > Li && !vi && (Vi = V, Li = V - .01, Si = 7, Pi = p), L - .01 > Li && !zi && (Vi = L, Li = L - .01, Si = 8, Pi = u), S - .01 > Li && !Ni && (Vi = S, Li = S - .01, Si = 9, Pi = y), P - .01 > Li && !ki && (Vi = P, Li = P - .01, Si = 10, Pi = x), T - .01 > Li && !wi && (Vi = T, Li = T - .01, Si = 11, Pi = d), A - .01 > Li && !Mi && (Vi = A, Li = A - .01, Si = 12, Pi = f), j - .01 > Li && !gi && (Vi = j, Li = j - .01, Si = 13, Pi = b), O - .01 > Li && !Ii && (Vi = O, Si = 14, Pi = v); var Ti = 0, Ai = 0, ji = 0, Oi = 0, Ci = 0, Di = 0, Ei = 0, Bi = 0, Fi = 0, qi = 0, Ui = 0, Ri = 0, _i = 0, Ji = 0, Wi = 0, Hi = 0, Qi = 0, Xi = 0, Yi = !1; if (0 == Si ? (Pi ? (qi = Q + ft, Ui = X + bt, Ri = Y + vt, Ti = rt, Ai = lt, ji = ct) : (qi = Q - ft, Ui = X - bt, Ri = Y - vt, Ti = -rt, Ai = -lt, ji = -ct), _i = zt, Ji = Nt, Wi = kt, Oi = -mt, Ci = -pt, Di = -ut, Hi = wt, Qi = Mt, Xi = gt, Ei = -yt, Bi = -xt, Fi = -dt) : 1 == Si ? (Pi ? (qi = Q + zt, Ui = X + Nt, Ri = Y + kt, Ti = mt, Ai = pt, ji = ut) : (qi = Q - zt, Ui = X - Nt, Ri = Y - kt, Ti = -mt, Ai = -pt, ji = -ut), _i = ft, Ji = bt, Wi = vt, Oi = -rt, Ci = -lt, Di = -ct, Hi = wt, Qi = Mt, Xi = gt, Ei = -yt, Bi = -xt, Fi = -dt) : 2 == Si ? (Pi ? (qi = Q + wt, Ui = X + Mt, Ri = Y + gt, Ti = yt, Ai = xt, ji = dt) : (qi = Q - wt, Ui = X - Mt, Ri = Y - gt, Ti = -yt, Ai = -xt, ji = -dt), _i = ft, Ji = bt, Wi = vt, Oi = -rt, Ci = -lt, Di = -ct, Hi = zt, Qi = Nt, Xi = kt, Ei = -mt, Bi = -pt, Fi = -ut) : 3 == Si ? (Yi = !0, Pi ? (qi = Z - Dt, Ui = K - Et, Ri = G - Bt, Ti = -It, Ai = -Vt, ji = -Lt) : (qi = Z + Dt, Ui = K + Et, Ri = G + Bt, Ti = It, Ai = Vt, ji = Lt), _i = Ft, Ji = qt, Wi = Ut, Oi = -St, Ci = -Tt, Di = -At, Hi = Rt, Qi = _t, Xi = Jt, Ei = -jt, Bi = -Ot, Fi = -Ct) : 4 == Si ? (Yi = !0, Pi ? (qi = Z - Ft, Ui = K - qt, Ri = G - Ut, Ti = -St, Ai = -Tt, ji = -At) : (qi = Z + Ft, Ui = K + qt, Ri = G + Ut, Ti = St, Ai = Tt, ji = At), _i = Dt, Ji = Et, Wi = Bt, Oi = -It, Ci = -Vt, Di = -Lt, Hi = Rt, Qi = _t, Xi = Jt, Ei = -jt, Bi = -Ot, Fi = -Ct) : 5 == Si ? (Yi = !0, Pi ? (qi = Z - Rt, Ui = K - _t, Ri = G - Jt, Ti = -jt, Ai = -Ot, ji = -Ct) : (qi = Z + Rt, Ui = K + _t, Ri = G + Jt, Ti = jt, Ai = Ot, ji = Ct), _i = Dt, Ji = Et, Wi = Bt, Oi = -It, Ci = -Vt, Di = -Lt, Hi = Ft, Qi = qt, Xi = Ut, Ei = -St, Bi = -Tt, Fi = -At) : 6 == Si ? (Ti = Wt, Ai = Ht, ji = Qt, Oi = rt, Ci = lt, Di = ct, Ei = It, Bi = Vt, Fi = Lt) : 7 == Si ? (Ti = Xt, Ai = Yt, ji = Zt, Oi = rt, Ci = lt, Di = ct, Ei = St, Bi = Tt, Fi = At) : 8 == Si ? (Ti = Kt, Ai = Gt, ji = $t, Oi = rt, Ci = lt, Di = ct, Ei = jt, Bi = Ot, Fi = Ct) : 9 == Si ? (Ti = ti, Ai = ii, ji = si, Oi = mt, Ci = pt, Di = ut, Ei = It, Bi = Vt, Fi = Lt) : 10 == Si ? (Ti = hi, Ai = ei, ji = ai, Oi = mt, Ci = pt, Di = ut, Ei = St, Bi = Tt, Fi = At) : 11 == Si ? (Ti = oi, Ai = ni, ji = ri, Oi = mt, Ci = pt, Di = ut, Ei = jt, Bi = Ot, Fi = Ct) : 12 == Si ? (Ti = li, Ai = ci, ji = mi, Oi = yt, Ci = xt, Di = dt, Ei = It, Bi = Vt, Fi = Lt) : 13 == Si ? (Ti = pi, Ai = ui, ji = yi, Oi = yt, Ci = xt, Di = dt, Ei = St, Bi = Tt, Fi = At) : 14 == Si && (Ti = xi, Ai = di, ji = fi, Oi = yt, Ci = xt, Di = dt, Ei = jt, Bi = Ot, Fi = Ct), Si > 5) { Pi || (Ti = -Ti, Ai = -Ai, ji = -ji); var Zi, Ki, Gi, $i, ts, is, ss, hs, es, as, os; Ki = Ti * (is = U[0]) + Ai * (ss = U[1]) + ji * (hs = U[2]), (Zi = Ti * (Gi = U[3]) + Ai * ($i = U[4]) + ji * (ts = U[5])) > Ki && (Ki = Zi, is = Gi, ss = $i, hs = ts), (Zi = Ti * (Gi = U[6]) + Ai * ($i = U[7]) + ji * (ts = U[8])) > Ki && (Ki = Zi, is = Gi, ss = $i, hs = ts), (Zi = Ti * (Gi = U[9]) + Ai * ($i = U[10]) + ji * (ts = U[11])) > Ki && (Ki = Zi, is = Gi, ss = $i, hs = ts), (Zi = Ti * (Gi = U[12]) + Ai * ($i = U[13]) + ji * (ts = U[14])) > Ki && (Ki = Zi, is = Gi, ss = $i, hs = ts), (Zi = Ti * (Gi = U[15]) + Ai * ($i = U[16]) + ji * (ts = U[17])) > Ki && (Ki = Zi, is = Gi, ss = $i, hs = ts), (Zi = Ti * (Gi = U[18]) + Ai * ($i = U[19]) + ji * (ts = U[20])) > Ki && (Ki = Zi, is = Gi, ss = $i, hs = ts), (Zi = Ti * (Gi = U[21]) + Ai * ($i = U[22]) + ji * (ts = U[23])) > Ki && (Ki = Zi, is = Gi, ss = $i, hs = ts), Ki = Ti * (es = R[0]) + Ai * (as = R[1]) + ji * (os = R[2]), (Zi = Ti * (Gi = R[3]) + Ai * ($i = R[4]) + ji * (ts = R[5])) < Ki && (Ki = Zi, es = Gi, as = $i, os = ts), (Zi = Ti * (Gi = R[6]) + Ai * ($i = R[7]) + ji * (ts = R[8])) < Ki && (Ki = Zi, es = Gi, as = $i, os = ts), (Zi = Ti * (Gi = R[9]) + Ai * ($i = R[10]) + ji * (ts = R[11])) < Ki && (Ki = Zi, es = Gi, as = $i, os = ts), (Zi = Ti * (Gi = R[12]) + Ai * ($i = R[13]) + ji * (ts = R[14])) < Ki && (Ki = Zi, es = Gi, as = $i, os = ts), (Zi = Ti * (Gi = R[15]) + Ai * ($i = R[16]) + ji * (ts = R[17])) < Ki && (Ki = Zi, es = Gi, as = $i, os = ts), (Zi = Ti * (Gi = R[18]) + Ai * ($i = R[19]) + ji * (ts = R[20])) < Ki && (Ki = Zi, es = Gi, as = $i, os = ts), (Zi = Ti * (Gi = R[21]) + Ai * ($i = R[22]) + ji * (ts = R[23])) < Ki && (Ki = Zi, es = Gi, as = $i, os = ts); var ns = ((Gi = es - is) * (Oi - Ei * (B = Oi * Ei + Ci * Bi + Di * Fi)) + ($i = as - ss) * (Ci - Bi * B) + (ts = os - hs) * (Di - Fi * B)) / (1 - B * B); return void s.addPoint(is + Oi * ns + Ti * Vi * .5, ss + Ci * ns + Ai * Vi * .5, hs + Di * ns + ji * Vi * .5, Ti, Ai, ji, Vi, !1) } var rs, ls, cs, ms, ps, us, ys, xs, ds, fs, bs, vs, zs = 1, Ns = 0, ks = 0; Yi ? ((Ns = rt * Ti + lt * Ai + ct * ji) < zs && (zs = Ns, ks = 0), -Ns < zs && (zs = -Ns, ks = 1), (Ns = mt * Ti + pt * Ai + ut * ji) < zs && (zs = Ns, ks = 2), -Ns < zs && (zs = -Ns, ks = 3), (Ns = yt * Ti + xt * Ai + dt * ji) < zs && (zs = Ns, ks = 4), -Ns < zs && (zs = -Ns, ks = 5), 0 == ks ? (rs = U[0], ls = U[1], cs = U[2], ms = U[6], ps = U[7], us = U[8], ys = U[9], xs = U[10], ds = U[11], fs = U[3], bs = U[4], vs = U[5]) : 1 == ks ? (rs = U[15], ls = U[16], cs = U[17], ms = U[21], ps = U[22], us = U[23], ys = U[18], xs = U[19], ds = U[20], fs = U[12], bs = U[13], vs = U[14]) : 2 == ks ? (rs = U[12], ls = U[13], cs = U[14], ms = U[0], ps = U[1], us = U[2], ys = U[3], xs = U[4], ds = U[5], fs = U[15], bs = U[16], vs = U[17]) : 3 == ks ? (rs = U[21], ls = U[22], cs = U[23], ms = U[9], ps = U[10], us = U[11], ys = U[6], xs = U[7], ds = U[8], fs = U[18], bs = U[19], vs = U[20]) : 4 == ks ? (rs = U[12], ls = U[13], cs = U[14], ms = U[18], ps = U[19], us = U[20], ys = U[6], xs = U[7], ds = U[8], fs = U[0], bs = U[1], vs = U[2]) : 5 == ks && (rs = U[3], ls = U[4], cs = U[5], ms = R[9], ps = R[10], us = R[11], ys = U[21], xs = U[22], ds = U[23], fs = U[15], bs = U[16], vs = U[17])) : ((Ns = It * Ti + Vt * Ai + Lt * ji) < zs && (zs = Ns, ks = 0), -Ns < zs && (zs = -Ns, ks = 1), (Ns = St * Ti + Tt * Ai + At * ji) < zs && (zs = Ns, ks = 2), -Ns < zs && (zs = -Ns, ks = 3), (Ns = jt * Ti + Ot * Ai + Ct * ji) < zs && (zs = Ns, ks = 4), -Ns < zs && (zs = -Ns, ks = 5), 0 == ks ? (rs = R[0], ls = R[1], cs = R[2], ms = R[6], ps = R[7], us = R[8], ys = R[9], xs = R[10], ds = R[11], fs = R[3], bs = R[4], vs = R[5]) : 1 == ks ? (rs = R[15], ls = R[16], cs = R[17], ms = R[21], ps = R[22], us = R[23], ys = R[18], xs = R[19], ds = R[20], fs = R[12], bs = R[13], vs = R[14]) : 2 == ks ? (rs = R[12], ls = R[13], cs = R[14], ms = R[0], ps = R[1], us = R[2], ys = R[3], xs = R[4], ds = R[5], fs = R[15], bs = R[16], vs = R[17]) : 3 == ks ? (rs = R[21], ls = R[22], cs = R[23], ms = R[9], ps = R[10], us = R[11], ys = R[6], xs = R[7], ds = R[8], fs = R[18], bs = R[19], vs = R[20]) : 4 == ks ? (rs = R[12], ls = R[13], cs = R[14], ms = R[18], ps = R[19], us = R[20], ys = R[6], xs = R[7], ds = R[8], fs = R[0], bs = R[1], vs = R[2]) : 5 == ks && (rs = R[3], ls = R[4], cs = R[5], ms = R[9], ps = R[10], us = R[11], ys = R[21], xs = R[22], ds = R[23], fs = R[15], bs = R[16], vs = R[17])); var ws, Ms, gs, Is, Vs, Ls, Ss, Ps, Ts; this.clipVertices1[0] = rs, this.clipVertices1[1] = ls, this.clipVertices1[2] = cs, this.clipVertices1[3] = ms, this.clipVertices1[4] = ps, this.clipVertices1[5] = us, this.clipVertices1[6] = ys, this.clipVertices1[7] = xs, this.clipVertices1[8] = ds, this.clipVertices1[9] = fs, this.clipVertices1[10] = bs, this.clipVertices1[11] = vs, Ms = 0, B = ((Is = this.clipVertices1[9]) - qi - _i) * Oi + ((Vs = this.clipVertices1[10]) - Ui - Ji) * Ci + ((Ls = this.clipVertices1[11]) - Ri - Wi) * Di; for (var As = 0; As < 4; As++)gs = 3 * As, F = ((Ss = this.clipVertices1[gs]) - qi - _i) * Oi + ((Ps = this.clipVertices1[gs + 1]) - Ui - Ji) * Ci + ((Ts = this.clipVertices1[gs + 2]) - Ri - Wi) * Di, B > 0 ? F > 0 ? (gs = 3 * Ms, Ms++ , this.clipVertices2[gs] = Ss, this.clipVertices2[gs + 1] = Ps, this.clipVertices2[gs + 2] = Ts) : (gs = 3 * Ms, Ms++ , ns = B / (B - F), this.clipVertices2[gs] = Is + (Ss - Is) * ns, this.clipVertices2[gs + 1] = Vs + (Ps - Vs) * ns, this.clipVertices2[gs + 2] = Ls + (Ts - Ls) * ns) : F > 0 && (gs = 3 * Ms, Ms++ , ns = B / (B - F), this.clipVertices2[gs] = Is + (Ss - Is) * ns, this.clipVertices2[gs + 1] = Vs + (Ps - Vs) * ns, this.clipVertices2[gs + 2] = Ls + (Ts - Ls) * ns, gs = 3 * Ms, Ms++ , this.clipVertices2[gs] = Ss, this.clipVertices2[gs + 1] = Ps, this.clipVertices2[gs + 2] = Ts), Is = Ss, Vs = Ps, Ls = Ts, B = F; if (0 != (ws = Ms)) { for (Ms = 0, gs = 3 * (ws - 1), B = ((Is = this.clipVertices2[gs]) - qi - Hi) * Ei + ((Vs = this.clipVertices2[gs + 1]) - Ui - Qi) * Bi + ((Ls = this.clipVertices2[gs + 2]) - Ri - Xi) * Fi, As = 0; As < ws; As++)gs = 3 * As, F = ((Ss = this.clipVertices2[gs]) - qi - Hi) * Ei + ((Ps = this.clipVertices2[gs + 1]) - Ui - Qi) * Bi + ((Ts = this.clipVertices2[gs + 2]) - Ri - Xi) * Fi, B > 0 ? F > 0 ? (gs = 3 * Ms, Ms++ , this.clipVertices1[gs] = Ss, this.clipVertices1[gs + 1] = Ps, this.clipVertices1[gs + 2] = Ts) : (gs = 3 * Ms, Ms++ , ns = B / (B - F), this.clipVertices1[gs] = Is + (Ss - Is) * ns, this.clipVertices1[gs + 1] = Vs + (Ps - Vs) * ns, this.clipVertices1[gs + 2] = Ls + (Ts - Ls) * ns) : F > 0 && (gs = 3 * Ms, Ms++ , ns = B / (B - F), this.clipVertices1[gs] = Is + (Ss - Is) * ns, this.clipVertices1[gs + 1] = Vs + (Ps - Vs) * ns, this.clipVertices1[gs + 2] = Ls + (Ts - Ls) * ns, gs = 3 * Ms, Ms++ , this.clipVertices1[gs] = Ss, this.clipVertices1[gs + 1] = Ps, this.clipVertices1[gs + 2] = Ts), Is = Ss, Vs = Ps, Ls = Ts, B = F; if (0 != (ws = Ms)) { for (Ms = 0, gs = 3 * (ws - 1), B = ((Is = this.clipVertices1[gs]) - qi + _i) * -Oi + ((Vs = this.clipVertices1[gs + 1]) - Ui + Ji) * -Ci + ((Ls = this.clipVertices1[gs + 2]) - Ri + Wi) * -Di, As = 0; As < ws; As++)gs = 3 * As, F = ((Ss = this.clipVertices1[gs]) - qi + _i) * -Oi + ((Ps = this.clipVertices1[gs + 1]) - Ui + Ji) * -Ci + ((Ts = this.clipVertices1[gs + 2]) - Ri + Wi) * -Di, B > 0 ? F > 0 ? (gs = 3 * Ms, Ms++ , this.clipVertices2[gs] = Ss, this.clipVertices2[gs + 1] = Ps, this.clipVertices2[gs + 2] = Ts) : (gs = 3 * Ms, Ms++ , ns = B / (B - F), this.clipVertices2[gs] = Is + (Ss - Is) * ns, this.clipVertices2[gs + 1] = Vs + (Ps - Vs) * ns, this.clipVertices2[gs + 2] = Ls + (Ts - Ls) * ns) : F > 0 && (gs = 3 * Ms, Ms++ , ns = B / (B - F), this.clipVertices2[gs] = Is + (Ss - Is) * ns, this.clipVertices2[gs + 1] = Vs + (Ps - Vs) * ns, this.clipVertices2[gs + 2] = Ls + (Ts - Ls) * ns, gs = 3 * Ms, Ms++ , this.clipVertices2[gs] = Ss, this.clipVertices2[gs + 1] = Ps, this.clipVertices2[gs + 2] = Ts), Is = Ss, Vs = Ps, Ls = Ts, B = F; if (0 != (ws = Ms)) { for (Ms = 0, gs = 3 * (ws - 1), B = ((Is = this.clipVertices2[gs]) - qi + Hi) * -Ei + ((Vs = this.clipVertices2[gs + 1]) - Ui + Qi) * -Bi + ((Ls = this.clipVertices2[gs + 2]) - Ri + Xi) * -Fi, As = 0; As < ws; As++)gs = 3 * As, F = ((Ss = this.clipVertices2[gs]) - qi + Hi) * -Ei + ((Ps = this.clipVertices2[gs + 1]) - Ui + Qi) * -Bi + ((Ts = this.clipVertices2[gs + 2]) - Ri + Xi) * -Fi, B > 0 ? F > 0 ? (gs = 3 * Ms, Ms++ , this.clipVertices1[gs] = Ss, this.clipVertices1[gs + 1] = Ps, this.clipVertices1[gs + 2] = Ts) : (gs = 3 * Ms, Ms++ , ns = B / (B - F), this.clipVertices1[gs] = Is + (Ss - Is) * ns, this.clipVertices1[gs + 1] = Vs + (Ps - Vs) * ns, this.clipVertices1[gs + 2] = Ls + (Ts - Ls) * ns) : F > 0 && (gs = 3 * Ms, Ms++ , ns = B / (B - F), this.clipVertices1[gs] = Is + (Ss - Is) * ns, this.clipVertices1[gs + 1] = Vs + (Ps - Vs) * ns, this.clipVertices1[gs + 2] = Ls + (Ts - Ls) * ns, gs = 3 * Ms, Ms++ , this.clipVertices1[gs] = Ss, this.clipVertices1[gs + 1] = Ps, this.clipVertices1[gs + 2] = Ts), Is = Ss, Vs = Ps, Ls = Ts, B = F; if (ws = Ms, Yi) { var js = h; h = e, e = js } if (0 != ws) { var Os = h != t; if (ws > 4) { Oi = rs - (Is = .25 * (rs + ms + ys + fs)), Ci = ls - (Vs = .25 * (ls + ps + xs + bs)), Di = cs - (Ls = .25 * (cs + us + ds + vs)), Ei = ms - Is, Bi = ps - Vs, Fi = us - Ls; var Cs = 0, Ds = 0, Es = 0, Bs = 0, Fs = -this.INF; for (zs = this.INF, As = 0; As < ws; As++)this.used[As] = !1, gs = 3 * As, (Ns = (Is = this.clipVertices1[gs]) * Oi + (Vs = this.clipVertices1[gs + 1]) * Ci + (Ls = this.clipVertices1[gs + 2]) * Di) < zs && (zs = Ns, Cs = As), Ns > Fs && (Fs = Ns, Es = As); for (this.used[Cs] = !0, this.used[Es] = !0, Fs = -this.INF, zs = this.INF, As = 0; As < ws; As++)this.used[As] || (gs = 3 * As, (Ns = (Is = this.clipVertices1[gs]) * Ei + (Vs = this.clipVertices1[gs + 1]) * Bi + (Ls = this.clipVertices1[gs + 2]) * Fi) < zs && (zs = Ns, Ds = As), Ns > Fs && (Fs = Ns, Bs = As)); gs = 3 * Cs, (Ns = ((Is = this.clipVertices1[gs]) - qi) * Ti + ((Vs = this.clipVertices1[gs + 1]) - Ui) * Ai + ((Ls = this.clipVertices1[gs + 2]) - Ri) * ji) < 0 && s.addPoint(Is, Vs, Ls, Ti, Ai, ji, Ns, Os), gs = 3 * Ds, (Ns = ((Is = this.clipVertices1[gs]) - qi) * Ti + ((Vs = this.clipVertices1[gs + 1]) - Ui) * Ai + ((Ls = this.clipVertices1[gs + 2]) - Ri) * ji) < 0 && s.addPoint(Is, Vs, Ls, Ti, Ai, ji, Ns, Os), gs = 3 * Es, (Ns = ((Is = this.clipVertices1[gs]) - qi) * Ti + ((Vs = this.clipVertices1[gs + 1]) - Ui) * Ai + ((Ls = this.clipVertices1[gs + 2]) - Ri) * ji) < 0 && s.addPoint(Is, Vs, Ls, Ti, Ai, ji, Ns, Os), gs = 3 * Bs, (Ns = ((Is = this.clipVertices1[gs]) - qi) * Ti + ((Vs = this.clipVertices1[gs + 1]) - Ui) * Ai + ((Ls = this.clipVertices1[gs + 2]) - Ri) * ji) < 0 && s.addPoint(Is, Vs, Ls, Ti, Ai, ji, Ns, Os) } else for (As = 0; As < ws; As++)gs = 3 * As, (Ns = ((Is = this.clipVertices1[gs]) - qi) * Ti + ((Vs = this.clipVertices1[gs + 1]) - Ui) * Ai + ((Ls = this.clipVertices1[gs + 2]) - Ri) * ji) < 0 && s.addPoint(Is, Vs, Ls, Ti, Ai, ji, Ns, Os) } } } } } } }), ht.prototype = Object.assign(Object.create(it.prototype), { constructor: ht, getSep: function(t, i, s, h, a) { var o, n, r, l, c, m, p, u, y, x, d, f, b, v = new e, z = t.position.x, N = t.position.y, k = t.position.z, w = i.position.x, M = i.position.y, g = i.position.z, I = w - z, V = M - N, L = g - k; I * I + V * V + L * L == 0 && (V = .001); var S = -I, P = -V, T = -L; this.supportPointB(t, -S, -P, -T, v); var A = v.x, j = v.y, O = v.z; this.supportPointC(i, S, P, T, v); var C = v.x, D = v.y, E = v.z, B = C - A, F = D - j, q = E - O; if (B * S + F * P + q * T <= 0) return !1; if (S = F * L - q * V, P = q * I - B * L, T = B * V - F * I, S * S + P * P + T * T == 0) return s.set(B - I, F - V, q - L).normalize(), h.set(.5 * (A + C), .5 * (j + D), .5 * (O + E)), !0; this.supportPointB(t, -S, -P, -T, v); var U = v.x, R = v.y, _ = v.z; this.supportPointC(i, S, P, T, v); var J = v.x, W = v.y, H = v.z, Q = J - U, X = W - R, Y = H - _; if (Q * S + X * P + Y * T <= 0) return !1; (S = (n = F - V) * (m = Y - L) - (r = q - L) * (c = X - V)) * I + (P = r * (l = Q - I) - (o = B - I) * m) * V + (T = o * c - n * l) * L > 0 && (o = B, n = F, r = q, B = Q, F = X, q = Y, Q = o, X = n, Y = r, o = A, n = j, r = O, A = U, j = R, O = _, U = o, R = n, _ = r, o = C, n = D, r = E, C = J, D = W, E = H, J = o, W = n, H = r, S = -S, P = -P, T = -T); for (var Z = 0; ;) { if (++Z > 100) return !1; this.supportPointB(t, -S, -P, -T, v); var K = v.x, G = v.y, $ = v.z; this.supportPointC(i, S, P, T, v); var tt = v.x, it = v.y, st = v.z, ht = tt - K, et = it - G, at = st - $; if (ht * S + et * P + at * T <= 0) return !1; if ((F * at - q * et) * I + (q * ht - B * at) * V + (B * et - F * ht) * L < 0) Q = ht, X = et, Y = at, U = K, R = G, _ = $, J = tt, W = it, H = st, S = (n = F - V) * (m = at - L) - (r = q - L) * (c = et - V), P = r * (l = ht - I) - (o = B - I) * m, T = o * c - n * l; else if ((et * Y - at * X) * I + (at * Q - ht * Y) * V + (ht * X - et * Q) * L < 0) B = ht, F = et, q = at, A = K, j = G, O = $, C = tt, D = it, E = st, S = (n = et - V) * (m = Y - L) - (r = at - L) * (c = X - V), P = r * (l = Q - I) - (o = ht - I) * m, T = o * c - n * l; else for (var ot = !1; ;) { if (o = Q - B, n = X - F, r = Y - q, l = ht - B, c = et - F, m = at - q, S = n * m - r * c, P = r * l - o * m, T = o * c - n * l, p = 1 / Pt.sqrt(S * S + P * P + T * T), S *= p, P *= p, T *= p, S * B + P * F + T * q >= 0 && !ot) { var nt = (F * Y - q * X) * ht + (q * Q - B * Y) * et + (B * X - F * Q) * at, rt = (et * Y - at * X) * I + (at * Q - ht * Y) * V + (ht * X - et * Q) * L, lt = (V * q - L * F) * ht + (L * B - I * q) * et + (I * F - V * B) * at, ct = (X * q - Y * F) * I + (Y * B - Q * q) * V + (Q * F - X * B) * L, mt = nt + rt + lt + ct; mt <= 0 && (nt = 0, mt = (rt = (X * at - Y * et) * S + (Y * ht - Q * at) * P + (Q * et - X * ht) * T) + (lt = (et * Y - at * X) * S + (at * Q - ht * Y) * P + (ht * X - et * Q) * T) + (ct = (F * Y - q * X) * S + (q * Q - B * Y) * P + (B * X - F * Q) * T)); var pt = 1 / mt; u = (z * nt + A * rt + U * lt + K * ct) * pt, y = (N * nt + j * rt + R * lt + G * ct) * pt, x = (k * nt + O * rt + _ * lt + $ * ct) * pt, d = (w * nt + C * rt + J * lt + tt * ct) * pt, f = (M * nt + D * rt + W * lt + it * ct) * pt, b = (g * nt + E * rt + H * lt + st * ct) * pt, ot = !0 } this.supportPointB(t, -S, -P, -T, v); var ut = v.x, yt = v.y, xt = v.z; this.supportPointC(i, S, P, T, v); var dt = v.x, ft = v.y, bt = v.z, vt = dt - ut, zt = ft - yt, Nt = bt - xt, kt = -(vt * S + zt * P + Nt * T); if ((vt - ht) * S + (zt - et) * P + (Nt - at) * T <= .01 || kt >= 0) return !!ot && (s.set(-S, -P, -T), h.set(.5 * (u + d), .5 * (y + f), .5 * (x + b)), a.x = kt, !0); (zt * q - Nt * F) * I + (Nt * B - vt * q) * V + (vt * F - zt * B) * L < 0 ? (zt * Y - Nt * X) * I + (Nt * Q - vt * Y) * V + (vt * X - zt * Q) * L < 0 ? (B = vt, F = zt, q = Nt, A = ut, j = yt, O = xt, C = dt, D = ft, E = bt) : (ht = vt, et = zt, at = Nt, K = ut, G = yt, $ = xt, tt = dt, it = ft, st = bt) : (zt * at - Nt * et) * I + (Nt * ht - vt * at) * V + (vt * et - zt * ht) * L < 0 ? (Q = vt, X = zt, Y = Nt, U = ut, R = yt, _ = xt, J = dt, W = ft, H = bt) : (B = vt, F = zt, q = Nt, A = ut, j = yt, O = xt, C = dt, D = ft, E = bt) } } }, supportPointB: function(t, i, s, h, e) { var a, o, n, r = t.rotation.elements, l = r[0] * i + r[3] * s + r[6] * h, c = r[1] * i + r[4] * s + r[7] * h, m = r[2] * i + r[5] * s + r[8] * h, p = t.halfWidth, u = t.halfHeight, y = t.halfDepth; a = l < 0 ? -p : p, o = c < 0 ? -u : u, n = m < 0 ? -y : y, l = r[0] * a + r[1] * o + r[2] * n + t.position.x, c = r[3] * a + r[4] * o + r[5] * n + t.position.y, m = r[6] * a + r[7] * o + r[8] * n + t.position.z, e.set(l, c, m) }, supportPointC: function(t, i, s, h, e) { var a, o, n, r = t.rotation.elements, l = r[0] * i + r[3] * s + r[6] * h, c = r[1] * i + r[4] * s + r[7] * h, m = r[2] * i + r[5] * s + r[8] * h, p = l, u = m, y = p * p + u * u, x = t.radius, d = t.halfHeight; 0 == y ? c < 0 ? (a = x, o = -d, n = 0) : (a = x, o = d, n = 0) : (y = t.radius / Pt.sqrt(y), c < 0 ? (a = p * y, o = -d, n = u * y) : (a = p * y, o = d, n = u * y)), l = r[0] * a + r[1] * o + r[2] * n + t.position.x, c = r[3] * a + r[4] * o + r[5] * n + t.position.y, m = r[6] * a + r[7] * o + r[8] * n + t.position.z, e.set(l, c, m) }, detectCollision: function(t, i, s) { var h, a; this.flip ? (h = i, a = t) : (h = t, a = i); var o = new e, n = new e, r = new e; if (this.getSep(h, a, o, n, r)) { var l = h.position.x, c = h.position.y, m = h.position.z, p = a.position.x, u = a.position.y, y = a.position.z, x = h.halfWidth, d = h.halfHeight, f = h.halfDepth, b = a.halfHeight, v = a.radius, z = h.dimentions, N = z[0], k = z[1], w = z[2], M = z[3], g = z[4], I = z[5], V = z[6], L = z[7], S = z[8], P = z[9], T = z[10], A = z[11], j = z[12], O = z[13], C = z[14], D = z[15], E = z[16], B = z[17], F = a.normalDirection.x, q = a.normalDirection.y, U = a.normalDirection.z, R = a.halfDirection.x, _ = a.halfDirection.y, J = a.halfDirection.z, W = o.x, H = o.y, Q = o.z, X = W * N + H * k + Q * w, Y = W * M + H * g + Q * I, Z = W * V + H * L + Q * S, K = W * F + H * q + Q * U, G = X > 0, $ = Y > 0, tt = Z > 0, it = K > 0; G || (X = -X), $ || (Y = -Y), tt || (Z = -Z), it || (K = -K); var st = 0; K > .999 ? st = X > .999 ? X > K ? 1 : 4 : Y > .999 ? Y > K ? 2 : 4 : Z > .999 && Z > K ? 3 : 4 : X > .999 ? st = 1 : Y > .999 ? st = 2 : Z > .999 && (st = 3); var ht, et, at, ot, nt, rt, lt, ct, mt, pt, ut, yt, xt, dt, ft, bt, vt, zt, Nt, kt, wt, Mt, gt, It, Vt, Lt, St, Tt, At, jt, Ot, Ct, Dt, Et, Bt, Ft, qt, Ut, Rt, _t, Jt, Wt, Ht, Qt, Xt, Yt, Zt, Kt, Gt, $t, ti, ii, si; if (0 == st) s.addPoint(n.x, n.y, n.z, W, H, Q, r.x, this.flip); else if (4 == st) { it ? (ot = p - R, nt = u - _, rt = y - J, W = -F, H = -q, Q = -U) : (ot = p + R, nt = u + _, rt = y + J, W = F, H = q, Q = U); var hi, ei, ai, oi, ni, ri, li, ci, mi, pi, ui, yi; st = 0, (Ht = N * W + k * H + w * Q) < (kt = 1) && (kt = Ht, st = 0), -Ht < kt && (kt = -Ht, st = 1), (Ht = M * W + g * H + I * Q) < kt && (kt = Ht, st = 2), -Ht < kt && (kt = -Ht, st = 3), (Ht = V * W + L * H + S * Q) < kt && (kt = Ht, st = 4), -Ht < kt && (kt = -Ht, st = 5); var xi = h.elements; switch (st) { case 0: hi = xi[0], ei = xi[1], ai = xi[2], oi = xi[6], ni = xi[7], ri = xi[8], li = xi[9], ci = xi[10], mi = xi[11], pi = xi[3], ui = xi[4], yi = xi[5]; break; case 1: hi = xi[15], ei = xi[16], ai = xi[17], oi = xi[21], ni = xi[22], ri = xi[23], li = xi[18], ci = xi[19], mi = xi[20], pi = xi[12], ui = xi[13], yi = xi[14]; break; case 2: hi = xi[12], ei = xi[13], ai = xi[14], oi = xi[0], ni = xi[1], ri = xi[2], li = xi[3], ci = xi[4], mi = xi[5], pi = xi[15], ui = xi[16], yi = xi[17]; break; case 3: hi = xi[21], ei = xi[22], ai = xi[23], oi = xi[9], ni = xi[10], ri = xi[11], li = xi[6], ci = xi[7], mi = xi[8], pi = xi[18], ui = xi[19], yi = xi[20]; break; case 4: hi = xi[12], ei = xi[13], ai = xi[14], oi = xi[18], ni = xi[19], ri = xi[20], li = xi[6], ci = xi[7], mi = xi[8], pi = xi[0], ui = xi[1], yi = xi[2]; break; case 5: hi = xi[3], ei = xi[4], ai = xi[5], oi = xi[9], ni = xi[10], ri = xi[11], li = xi[21], ci = xi[22], mi = xi[23], pi = xi[15], ui = xi[16], yi = xi[17] }(Nt = W * (hi - ot) + H * (ei - nt) + Q * (ai - rt)) <= 0 && s.addPoint(hi, ei, ai, -W, -H, -Q, Nt, this.flip), (Nt = W * (oi - ot) + H * (ni - nt) + Q * (ri - rt)) <= 0 && s.addPoint(oi, ni, ri, -W, -H, -Q, Nt, this.flip), (Nt = W * (li - ot) + H * (ci - nt) + Q * (mi - rt)) <= 0 && s.addPoint(li, ci, mi, -W, -H, -Q, Nt, this.flip), (Nt = W * (pi - ot) + H * (ui - nt) + Q * (yi - rt)) <= 0 && s.addPoint(pi, ui, yi, -W, -H, -Q, Nt, this.flip) } else { switch (st) { case 1: G ? (ht = l + P, et = c + T, at = m + A, W = N, H = k, Q = w) : (ht = l - P, et = c - T, at = m - A, W = -N, H = -k, Q = -w), Yt = M, Zt = g, Kt = I, ii = d, Gt = V, $t = L, ti = S, si = f; break; case 2: $ ? (ht = l + j, et = c + O, at = m + C, W = M, H = g, Q = I) : (ht = l - j, et = c - O, at = m - C, W = -M, H = -g, Q = -I), Yt = N, Zt = k, Kt = w, ii = x, Gt = V, $t = L, ti = S, si = f; break; case 3: tt ? (ht = l + D, et = c + E, at = m + B, W = V, H = L, Q = S) : (ht = l - D, et = c - E, at = m - B, W = -V, H = -L, Q = -S), Yt = N, Zt = k, Kt = w, ii = x, Gt = M, $t = g, ti = I, si = d }if (kt = W * F + H * q + Q * U, wt = kt < 0 ? b : -b, ot = p + wt * F, nt = u + wt * q, rt = y + wt * U, K >= .999999 ? (Mt = -H, gt = Q, It = W) : (Mt = W, gt = H, It = Q), wt = Mt * F + gt * q + It * U, Lt = wt * F - Mt, St = wt * q - gt, Tt = wt * U - It, 0 == (wt = Pt.sqrt(Lt * Lt + St * St + Tt * Tt))) return; if (wt = v / wt, Lt *= wt, St *= wt, Tt *= wt, Mt = ot + Lt, gt = nt + St, It = rt + Tt, kt < -.96 || kt > .96) lt = F * F * 1.5 - .5, ct = F * q * 1.5 - .866025403 * U, mt = F * U * 1.5 + .866025403 * q, pt = q * F * 1.5 + .866025403 * U, ut = q * q * 1.5 - .5, yt = q * U * 1.5 - .866025403 * F, xt = U * F * 1.5 - .866025403 * q, dt = U * q * 1.5 + .866025403 * F, ft = U * U * 1.5 - .5, Wt = Gt * (Mt = (bt = Mt) - (Nt = W * (bt - ht) + H * ((vt = gt) - et) + Q * ((zt = It) - at)) * W - ht) + $t * (gt = vt - Nt * H - et) + ti * (It = zt - Nt * Q - at), (Ut = Yt * Mt + Zt * gt + Kt * It) < -ii ? Ut = -ii : Ut > ii && (Ut = ii), Wt < -si ? Wt = -si : Wt > si && (Wt = si), bt = ht + (Mt = Ut * Yt + Wt * Gt), vt = et + (gt = Ut * Zt + Wt * $t), zt = at + (It = Ut * Kt + Wt * ti), s.addPoint(bt, vt, zt, W, H, Q, Nt, this.flip), vt = Lt * pt + St * ut + Tt * yt, zt = Lt * xt + St * dt + Tt * ft, (Nt = W * ((bt = (Lt = bt = Lt * lt + St * ct + Tt * mt) + ot) - ht) + H * ((vt = (St = vt) + nt) - et) + Q * ((zt = (Tt = zt) + rt) - at)) <= 0 && (Wt = Gt * (Mt = bt - Nt * W - ht) + $t * (gt = vt - Nt * H - et) + ti * (It = zt - Nt * Q - at), (Ut = Yt * Mt + Zt * gt + Kt * It) < -ii ? Ut = -ii : Ut > ii && (Ut = ii), Wt < -si ? Wt = -si : Wt > si && (Wt = si), bt = ht + (Mt = Ut * Yt + Wt * Gt), vt = et + (gt = Ut * Zt + Wt * $t), zt = at + (It = Ut * Kt + Wt * ti), s.addPoint(bt, vt, zt, W, H, Q, Nt, this.flip)), vt = Lt * pt + St * ut + Tt * yt, zt = Lt * xt + St * dt + Tt * ft, (Nt = W * ((bt = (Lt = bt = Lt * lt + St * ct + Tt * mt) + ot) - ht) + H * ((vt = (St = vt) + nt) - et) + Q * ((zt = (Tt = zt) + rt) - at)) <= 0 && (Wt = Gt * (Mt = bt - Nt * W - ht) + $t * (gt = vt - Nt * H - et) + ti * (It = zt - Nt * Q - at), (Ut = Yt * Mt + Zt * gt + Kt * It) < -ii ? Ut = -ii : Ut > ii && (Ut = ii), Wt < -si ? Wt = -si : Wt > si && (Wt = si), bt = ht + (Mt = Ut * Yt + Wt * Gt), vt = et + (gt = Ut * Zt + Wt * $t), zt = at + (It = Ut * Kt + Wt * ti), s.addPoint(bt, vt, zt, W, H, Q, Nt, this.flip)); else { if (Bt = Mt, Ft = gt, qt = It, Ut = W * (Bt - ht) + H * (Ft - et) + Q * (qt - at), Bt -= Ut * W, Ft -= Ut * H, qt -= Ut * Q, kt > 0 ? (Rt = Mt + 2 * R, _t = gt + 2 * _, Jt = It + 2 * J) : (Rt = Mt - 2 * R, _t = gt - 2 * _, Jt = It - 2 * J), Wt = W * (Rt - ht) + H * (_t - et) + Q * (Jt - at), Rt -= Wt * W, _t -= Wt * H, Jt -= Wt * Q, At = Bt - ht, jt = Ft - et, Ot = qt - at, Ct = Rt - ht, Dt = _t - et, Et = Jt - at, Mt = Rt - Bt, gt = _t - Ft, It = Jt - qt, Vt = Wt - Ut, X = At * Yt + jt * Zt + Ot * Kt, Y = Ct * Yt + Dt * Zt + Et * Kt, Ht = X - ii, Qt = Y - ii, Ht > 0) { if (Qt > 0) return; X = (At = (Bt += Mt * (Xt = Ht / (Ht - Qt))) - ht) * Yt + (jt = (Ft += gt * Xt) - et) * Zt + (Ot = (qt += It * Xt) - at) * Kt, Mt = Rt - Bt, gt = _t - Ft, It = Jt - qt, Vt = Wt - (Ut += Vt * Xt) } else Qt > 0 && (Y = (Ct = (Rt = Bt + Mt * (Xt = Ht / (Ht - Qt))) - ht) * Yt + (Dt = (_t = Ft + gt * Xt) - et) * Zt + (Et = (Jt = qt + It * Xt) - at) * Kt, Mt = Rt - Bt, gt = _t - Ft, It = Jt - qt, Vt = (Wt = Ut + Vt * Xt) - Ut); if (Ht = X + ii, Qt = Y + ii, Ht < 0) { if (Qt < 0) return; At = (Bt += Mt * (Xt = Ht / (Ht - Qt))) - ht, jt = (Ft += gt * Xt) - et, Ot = (qt += It * Xt) - at, Mt = Rt - Bt, gt = _t - Ft, It = Jt - qt, Vt = Wt - (Ut += Vt * Xt) } else Qt < 0 && (Ct = (Rt = Bt + Mt * (Xt = Ht / (Ht - Qt))) - ht, Dt = (_t = Ft + gt * Xt) - et, Et = (Jt = qt + It * Xt) - at, Mt = Rt - Bt, gt = _t - Ft, It = Jt - qt, Vt = (Wt = Ut + Vt * Xt) - Ut); if (X = At * Gt + jt * $t + Ot * ti, Y = Ct * Gt + Dt * $t + Et * ti, Ht = X - si, Qt = Y - si, Ht > 0) { if (Qt > 0) return; X = (At = (Bt += Mt * (Xt = Ht / (Ht - Qt))) - ht) * Gt + (jt = (Ft += gt * Xt) - et) * $t + (Ot = (qt += It * Xt) - at) * ti, Mt = Rt - Bt, gt = _t - Ft, It = Jt - qt, Vt = Wt - (Ut += Vt * Xt) } else Qt > 0 && (Y = (Ct = (Rt = Bt + Mt * (Xt = Ht / (Ht - Qt))) - ht) * Gt + (Dt = (_t = Ft + gt * Xt) - et) * $t + (Et = (Jt = qt + It * Xt) - at) * ti, Mt = Rt - Bt, gt = _t - Ft, It = Jt - qt, Vt = (Wt = Ut + Vt * Xt) - Ut); if (Ht = X + si, Qt = Y + si, Ht < 0) { if (Qt < 0) return; Bt += Mt * (Xt = Ht / (Ht - Qt)), Ft += gt * Xt, qt += It * Xt, Ut += Vt * Xt } else Qt < 0 && (Rt = Bt + Mt * (Xt = Ht / (Ht - Qt)), _t = Ft + gt * Xt, Jt = qt + It * Xt, Wt = Ut + Vt * Xt); Ut < 0 && s.addPoint(Bt, Ft, qt, W, H, Q, Ut, this.flip), Wt < 0 && s.addPoint(Rt, _t, Jt, W, H, Q, Wt, this.flip) } } } } }), et.prototype = Object.assign(Object.create(it.prototype), { constructor: et, getSep: function(t, i, s, h, a) { var o, n, r, l, c, m, p, u, y, x, d, f, b, v = new e, z = t.position.x, N = t.position.y, k = t.position.z, w = i.position.x, M = i.position.y, g = i.position.z, I = w - z, V = M - N, L = g - k; I * I + V * V + L * L == 0 && (V = .001); var S = -I, P = -V, T = -L; this.supportPoint(t, -S, -P, -T, v); var A = v.x, j = v.y, O = v.z; this.supportPoint(i, S, P, T, v); var C = v.x, D = v.y, E = v.z, B = C - A, F = D - j, q = E - O; if (B * S + F * P + q * T <= 0) return !1; if (S = F * L - q * V, P = q * I - B * L, T = B * V - F * I, S * S + P * P + T * T == 0) return s.set(B - I, F - V, q - L).normalize(), h.set(.5 * (A + C), .5 * (j + D), .5 * (O + E)), !0; this.supportPoint(t, -S, -P, -T, v); var U = v.x, R = v.y, _ = v.z; this.supportPoint(i, S, P, T, v); var J = v.x, W = v.y, H = v.z, Q = J - U, X = W - R, Y = H - _; if (Q * S + X * P + Y * T <= 0) return !1; (S = (n = F - V) * (m = Y - L) - (r = q - L) * (c = X - V)) * I + (P = r * (l = Q - I) - (o = B - I) * m) * V + (T = o * c - n * l) * L > 0 && (o = B, n = F, r = q, B = Q, F = X, q = Y, Q = o, X = n, Y = r, o = A, n = j, r = O, A = U, j = R, O = _, U = o, R = n, _ = r, o = C, n = D, r = E, C = J, D = W, E = H, J = o, W = n, H = r, S = -S, P = -P, T = -T); for (var Z = 0; ;) { if (++Z > 100) return !1; this.supportPoint(t, -S, -P, -T, v); var K = v.x, G = v.y, $ = v.z; this.supportPoint(i, S, P, T, v); var tt = v.x, it = v.y, st = v.z, ht = tt - K, et = it - G, at = st - $; if (ht * S + et * P + at * T <= 0) return !1; if ((F * at - q * et) * I + (q * ht - B * at) * V + (B * et - F * ht) * L < 0) Q = ht, X = et, Y = at, U = K, R = G, _ = $, J = tt, W = it, H = st, S = (n = F - V) * (m = at - L) - (r = q - L) * (c = et - V), P = r * (l = ht - I) - (o = B - I) * m, T = o * c - n * l; else if ((et * Y - at * X) * I + (at * Q - ht * Y) * V + (ht * X - et * Q) * L < 0) B = ht, F = et, q = at, A = K, j = G, O = $, C = tt, D = it, E = st, S = (n = et - V) * (m = Y - L) - (r = at - L) * (c = X - V), P = r * (l = Q - I) - (o = ht - I) * m, T = o * c - n * l; else for (var ot = !1; ;) { if (o = Q - B, n = X - F, r = Y - q, l = ht - B, c = et - F, m = at - q, S = n * m - r * c, P = r * l - o * m, T = o * c - n * l, p = 1 / Pt.sqrt(S * S + P * P + T * T), S *= p, P *= p, T *= p, S * B + P * F + T * q >= 0 && !ot) { var nt = (F * Y - q * X) * ht + (q * Q - B * Y) * et + (B * X - F * Q) * at, rt = (et * Y - at * X) * I + (at * Q - ht * Y) * V + (ht * X - et * Q) * L, lt = (V * q - L * F) * ht + (L * B - I * q) * et + (I * F - V * B) * at, ct = (X * q - Y * F) * I + (Y * B - Q * q) * V + (Q * F - X * B) * L, mt = nt + rt + lt + ct; mt <= 0 && (nt = 0, mt = (rt = (X * at - Y * et) * S + (Y * ht - Q * at) * P + (Q * et - X * ht) * T) + (lt = (et * Y - at * X) * S + (at * Q - ht * Y) * P + (ht * X - et * Q) * T) + (ct = (F * Y - q * X) * S + (q * Q - B * Y) * P + (B * X - F * Q) * T)); var pt = 1 / mt; u = (z * nt + A * rt + U * lt + K * ct) * pt, y = (N * nt + j * rt + R * lt + G * ct) * pt, x = (k * nt + O * rt + _ * lt + $ * ct) * pt, d = (w * nt + C * rt + J * lt + tt * ct) * pt, f = (M * nt + D * rt + W * lt + it * ct) * pt, b = (g * nt + E * rt + H * lt + st * ct) * pt, ot = !0 } this.supportPoint(t, -S, -P, -T, v); var ut = v.x, yt = v.y, xt = v.z; this.supportPoint(i, S, P, T, v); var dt = v.x, ft = v.y, bt = v.z, vt = dt - ut, zt = ft - yt, Nt = bt - xt, kt = -(vt * S + zt * P + Nt * T); if ((vt - ht) * S + (zt - et) * P + (Nt - at) * T <= .01 || kt >= 0) return !!ot && (s.set(-S, -P, -T), h.set(.5 * (u + d), .5 * (y + f), .5 * (x + b)), a.x = kt, !0); (zt * q - Nt * F) * I + (Nt * B - vt * q) * V + (vt * F - zt * B) * L < 0 ? (zt * Y - Nt * X) * I + (Nt * Q - vt * Y) * V + (vt * X - zt * Q) * L < 0 ? (B = vt, F = zt, q = Nt, A = ut, j = yt, O = xt, C = dt, D = ft, E = bt) : (ht = vt, et = zt, at = Nt, K = ut, G = yt, $ = xt, tt = dt, it = ft, st = bt) : (zt * at - Nt * et) * I + (Nt * ht - vt * at) * V + (vt * et - zt * ht) * L < 0 ? (Q = vt, X = zt, Y = Nt, U = ut, R = yt, _ = xt, J = dt, W = ft, H = bt) : (B = vt, F = zt, q = Nt, A = ut, j = yt, O = xt, C = dt, D = ft, E = bt) } } }, supportPoint: function(t, i, s, h, e) { var a, o, n, r = t.rotation.elements, l = r[0] * i + r[3] * s + r[6] * h, c = r[1] * i + r[4] * s + r[7] * h, m = r[2] * i + r[5] * s + r[8] * h, p = l, u = m, y = p * p + u * u, x = t.radius, d = t.halfHeight; 0 == y ? c < 0 ? (a = x, o = -d, n = 0) : (a = x, o = d, n = 0) : (y = t.radius / Pt.sqrt(y), c < 0 ? (a = p * y, o = -d, n = u * y) : (a = p * y, o = d, n = u * y)), l = r[0] * a + r[1] * o + r[2] * n + t.position.x, c = r[3] * a + r[4] * o + r[5] * n + t.position.y, m = r[6] * a + r[7] * o + r[8] * n + t.position.z, e.set(l, c, m) }, detectCollision: function(t, i, s) { var h, a; t.id < i.id ? (h = t, a = i) : (h = i, a = t); var o, n, r, l, c, m, p, u, y, x, d, f, b, v, z, N, k, w, M, g, I, V = h.position, L = a.position, S = V.x, P = V.y, T = V.z, A = L.x, j = L.y, O = L.z, C = h.halfHeight, D = a.halfHeight, E = h.normalDirection, B = a.normalDirection, F = h.halfDirection, q = a.halfDirection, U = h.radius, R = a.radius, _ = E.x, J = E.y, W = E.z, H = B.x, Q = B.y, X = B.z, Y = F.x, Z = F.y, K = F.z, G = q.x, $ = q.y, tt = q.z, it = S - A, st = P - j, ht = T - O, et = new e, at = new e, ot = new e; if (this.getSep(h, a, et, at, ot)) { var nt = et.x * _ + et.y * J + et.z * W, rt = et.x * H + et.y * Q + et.z * X, lt = nt > 0, ct = rt > 0; lt || (nt = -nt), ct || (rt = -rt); var mt = 0; (nt > .999 || rt > .999) && (mt = nt > rt ? 1 : 2); var pt, ut, yt, xt, dt, ft, bt, vt, zt, Nt, kt, wt, Mt, gt, It, Vt, Lt, St, Tt, At, jt = ot.x; switch (pt = et.x, ut = et.y, yt = et.z, mt) { case 0: s.addPoint(at.x, at.y, at.z, pt, ut, yt, jt, !1); break; case 1: if (lt ? (n = S + Y, r = P + Z, l = T + K, pt = _, ut = J, yt = W) : (n = S - Y, r = P - Z, l = T - K, pt = -_, ut = -J, yt = -W), M = pt * H + ut * Q + yt * X, o = M < 0 ? D : -D, c = A + o * H, m = j + o * Q, p = O + o * X, rt >= .999999 ? (u = -ut, y = yt, x = pt) : (u = pt, y = ut, x = yt), o = u * H + y * Q + x * X, it = o * H - u, st = o * Q - y, ht = o * X - x, 0 == (o = Pt.sqrt(it * it + st * st + ht * ht))) break; if (o = R / o, it *= o, st *= o, ht *= o, u = c + it, y = m + st, x = p + ht, M < -.96 || M > .96) xt = H * H * 1.5 - .5, dt = H * Q * 1.5 - .866025403 * X, ft = H * X * 1.5 + .866025403 * Q, bt = Q * H * 1.5 + .866025403 * X, vt = Q * Q * 1.5 - .5, zt = Q * X * 1.5 - .866025403 * H, Nt = X * H * 1.5 - .866025403 * Q, kt = X * Q * 1.5 + .866025403 * H, wt = X * X * 1.5 - .5, (o = (u = (Mt = u) - (Vt = pt * (Mt - n) + ut * ((gt = y) - r) + yt * ((It = x) - l)) * pt - n) * u + (y = gt - Vt * ut - r) * y + (x = It - Vt * yt - l) * x) > U * U && (u *= o = U / Pt.sqrt(o), y *= o, x *= o), Mt = n + u, gt = r + y, It = l + x, s.addPoint(Mt, gt, It, pt, ut, yt, Vt, !1), gt = it * bt + st * vt + ht * zt, It = it * Nt + st * kt + ht * wt, (Vt = pt * ((Mt = (it = Mt = it * xt + st * dt + ht * ft) + c) - n) + ut * ((gt = (st = gt) + m) - r) + yt * ((It = (ht = It) + p) - l)) <= 0 && ((o = (u = Mt - Vt * pt - n) * u + (y = gt - Vt * ut - r) * y + (x = It - Vt * yt - l) * x) > U * U && (u *= o = U / Pt.sqrt(o), y *= o, x *= o), Mt = n + u, gt = r + y, It = l + x, s.addPoint(Mt, gt, It, pt, ut, yt, Vt, !1)), gt = it * bt + st * vt + ht * zt, It = it * Nt + st * kt + ht * wt, (Vt = pt * ((Mt = (it = Mt = it * xt + st * dt + ht * ft) + c) - n) + ut * ((gt = (st = gt) + m) - r) + yt * ((It = (ht = It) + p) - l)) <= 0 && ((o = (u = Mt - Vt * pt - n) * u + (y = gt - Vt * ut - r) * y + (x = It - Vt * yt - l) * x) > U * U && (u *= o = U / Pt.sqrt(o), y *= o, x *= o), Mt = n + u, gt = r + y, It = l + x, s.addPoint(Mt, gt, It, pt, ut, yt, Vt, !1)); else { if (d = u, f = y, b = x, k = pt * (d - n) + ut * (f - r) + yt * (b - l), d -= k * pt, f -= k * ut, b -= k * yt, M > 0 ? (v = u + H * D * 2, z = y + Q * D * 2, N = x + X * D * 2) : (v = u - H * D * 2, z = y - Q * D * 2, N = x - X * D * 2), w = pt * (v - n) + ut * (z - r) + yt * (N - l), v -= w * pt, z -= w * ut, N -= w * yt, it = n - d, st = r - f, ht = l - b, u = v - d, y = z - f, x = N - b, Lt = it * it + st * st + ht * ht, St = it * u + st * y + ht * x, Tt = u * u + y * y + x * x, (At = St * St - Tt * (Lt - U * U)) < 0) break; (I = (St - (At = Pt.sqrt(At))) / Tt) < (g = (St + At) / Tt) && (o = g, g = I, I = o), I > 1 && (I = 1), g < 0 && (g = 0), u = d + (v - d) * g, y = f + (z - f) * g, x = b + (N - b) * g, v = d + (v - d) * I, z = f + (z - f) * I, N = b + (N - b) * I, d = u, f = y, b = x, o = k + (w - k) * g, w = k + (w - k) * I, (k = o) < 0 && s.addPoint(d, f, b, pt, ut, yt, Vt, !1), w < 0 && s.addPoint(v, z, N, pt, ut, yt, Vt, !1) } break; case 2: if (ct ? (c = A - G, m = j - $, p = O - tt, pt = -H, ut = -Q, yt = -X) : (c = A + G, m = j + $, p = O + tt, pt = H, ut = Q, yt = X), M = pt * _ + ut * J + yt * W, o = M < 0 ? C : -C, n = S + o * _, r = P + o * J, l = T + o * W, nt >= .999999 ? (u = -ut, y = yt, x = pt) : (u = pt, y = ut, x = yt), o = u * _ + y * J + x * W, it = o * _ - u, st = o * J - y, ht = o * W - x, 0 == (o = Pt.sqrt(it * it + st * st + ht * ht))) break; if (o = U / o, it *= o, st *= o, ht *= o, u = n + it, y = r + st, x = l + ht, M < -.96 || M > .96) xt = _ * _ * 1.5 - .5, dt = _ * J * 1.5 - .866025403 * W, ft = _ * W * 1.5 + .866025403 * J, bt = J * _ * 1.5 + .866025403 * W, vt = J * J * 1.5 - .5, zt = J * W * 1.5 - .866025403 * _, Nt = W * _ * 1.5 - .866025403 * J, kt = W * J * 1.5 + .866025403 * _, wt = W * W * 1.5 - .5, (o = (u = (Mt = u) - (Vt = pt * (Mt - c) + ut * ((gt = y) - m) + yt * ((It = x) - p)) * pt - c) * u + (y = gt - Vt * ut - m) * y + (x = It - Vt * yt - p) * x) > R * R && (u *= o = R / Pt.sqrt(o), y *= o, x *= o), Mt = c + u, gt = m + y, It = p + x, s.addPoint(Mt, gt, It, -pt, -ut, -yt, Vt, !1), gt = it * bt + st * vt + ht * zt, It = it * Nt + st * kt + ht * wt, (Vt = pt * ((Mt = (it = Mt = it * xt + st * dt + ht * ft) + n) - c) + ut * ((gt = (st = gt) + r) - m) + yt * ((It = (ht = It) + l) - p)) <= 0 && ((o = (u = Mt - Vt * pt - c) * u + (y = gt - Vt * ut - m) * y + (x = It - Vt * yt - p) * x) > R * R && (u *= o = R / Pt.sqrt(o), y *= o, x *= o), Mt = c + u, gt = m + y, It = p + x, s.addPoint(Mt, gt, It, -pt, -ut, -yt, Vt, !1)), gt = it * bt + st * vt + ht * zt, It = it * Nt + st * kt + ht * wt, (Vt = pt * ((Mt = (it = Mt = it * xt + st * dt + ht * ft) + n) - c) + ut * ((gt = (st = gt) + r) - m) + yt * ((It = (ht = It) + l) - p)) <= 0 && ((o = (u = Mt - Vt * pt - c) * u + (y = gt - Vt * ut - m) * y + (x = It - Vt * yt - p) * x) > R * R && (u *= o = R / Pt.sqrt(o), y *= o, x *= o), Mt = c + u, gt = m + y, It = p + x, s.addPoint(Mt, gt, It, -pt, -ut, -yt, Vt, !1)); else { if (d = u, f = y, b = x, k = pt * (d - c) + ut * (f - m) + yt * (b - p), d -= k * pt, f -= k * ut, b -= k * yt, M > 0 ? (v = u + _ * C * 2, z = y + J * C * 2, N = x + W * C * 2) : (v = u - _ * C * 2, z = y - J * C * 2, N = x - W * C * 2), w = pt * (v - c) + ut * (z - m) + yt * (N - p), v -= w * pt, z -= w * ut, N -= w * yt, it = c - d, st = m - f, ht = p - b, u = v - d, y = z - f, x = N - b, Lt = it * it + st * st + ht * ht, St = it * u + st * y + ht * x, Tt = u * u + y * y + x * x, (At = St * St - Tt * (Lt - R * R)) < 0) break; (I = (St - (At = Pt.sqrt(At))) / Tt) < (g = (St + At) / Tt) && (o = g, g = I, I = o), I > 1 && (I = 1), g < 0 && (g = 0), u = d + (v - d) * g, y = f + (z - f) * g, x = b + (N - b) * g, v = d + (v - d) * I, z = f + (z - f) * I, N = b + (N - b) * I, d = u, f = y, b = x, o = k + (w - k) * g, w = k + (w - k) * I, (k = o) < 0 && s.addPoint(d, f, b, -pt, -ut, -yt, k, !1), w < 0 && s.addPoint(v, z, N, -pt, -ut, -yt, w, !1) } } } } }), at.prototype = Object.assign(Object.create(it.prototype), { constructor: at, detectCollision: function(t, i, s) { var h, e; this.flip ? (h = i, e = t) : (h = t, e = i); var a, o, n, r, l, c = e.dimentions, m = h.position, p = m.x, u = m.y, y = m.z, x = e.position, d = x.x, f = x.y, b = x.z, v = h.radius, z = e.halfWidth, N = e.halfHeight, k = e.halfDepth, w = p - d, M = u - f, g = y - b, I = c[0] * w + c[1] * M + c[2] * g, V = c[3] * w + c[4] * M + c[5] * g, L = c[6] * w + c[7] * M + c[8] * g, S = 0; I > z ? I = z : I < -z ? I = -z : S = 1, V > N ? V = N : V < -N ? V = -N : S |= 2, L > k ? L = k : L < -k ? L = -k : S |= 4, 7 == S ? (w = I < 0 ? z + I : z - I, M = V < 0 ? N + V : N - V, g = L < 0 ? k + L : k - L, w < M ? w < g ? (r = w - z, I < 0 ? (I = -z, w = c[0], M = c[1], g = c[2]) : (I = z, w = -c[0], M = -c[1], g = -c[2])) : (r = g - k, L < 0 ? (L = -k, w = c[6], M = c[7], g = c[8]) : (L = k, w = -c[6], M = -c[7], g = -c[8])) : M < g ? (r = M - N, V < 0 ? (V = -N, w = c[3], M = c[4], g = c[5]) : (V = N, w = -c[3], M = -c[4], g = -c[5])) : (r = g - k, L < 0 ? (L = -k, w = c[6], M = c[7], g = c[8]) : (L = k, w = -c[6], M = -c[7], g = -c[8])), a = d + I * c[0] + V * c[3] + L * c[6], o = f + I * c[1] + V * c[4] + L * c[7], n = b + I * c[2] + V * c[5] + L * c[8], s.addPoint(p + v * w, u + v * M, y + v * g, w, M, g, r - v, this.flip)) : (a = d + I * c[0] + V * c[3] + L * c[6], o = f + I * c[1] + V * c[4] + L * c[7], n = b + I * c[2] + V * c[5] + L * c[8], (r = (w = a - m.x) * w + (M = o - m.y) * M + (g = n - m.z) * g) > 0 && r < v * v && (w *= l = 1 / (r = Pt.sqrt(r)), M *= l, g *= l, s.addPoint(p + v * w, u + v * M, y + v * g, w, M, g, r - v, this.flip))) } }), ot.prototype = Object.assign(Object.create(it.prototype), { constructor: ot, detectCollision: function(t, i, s) { var h, e; this.flip ? (h = i, e = t) : (h = t, e = i); var a = h.position, o = a.x, n = a.y, r = a.z, l = e.position, c = l.x, m = l.y, p = l.z, u = e.normalDirection.x, y = e.normalDirection.y, x = e.normalDirection.z, d = h.radius, f = e.radius, b = d + f, v = e.halfHeight, z = o - c, N = n - m, k = r - p, w = z * u + N * y + k * x; if (!(w < -v - d || w > v + d)) { var M = c + w * u, g = m + w * y, I = p + w * x, V = o - M, L = n - g, S = r - I, P = V * V + L * L + S * S; if (!(P > b * b)) { P > f * f && (V *= P = f / Pt.sqrt(P), L *= P, S *= P), w < -v ? w = -v : w > v && (w = v); var T; (P = (z = (M = c + w * u + V) - o) * z + (N = (g = m + w * y + L) - n) * N + (k = (I = p + w * x + S) - r) * k) > 0 && P < d * d && (z *= T = 1 / (P = Pt.sqrt(P)), N *= T, k *= T, s.addPoint(o + z * d, n + N * d, r + k * d, z, N, k, P - d, this.flip)) } } } }), nt.prototype = Object.assign(Object.create(it.prototype), { constructor: nt, detectCollision: function(t, i, s) { var h = t, e = i, a = h.position, o = e.position, n = o.x - a.x, r = o.y - a.y, l = o.z - a.z, c = n * n + r * r + l * l, m = h.radius, p = m + e.radius; if (c > 0 && c < p * p) { var u = 1 / (c = Pt.sqrt(c)); n *= u, r *= u, l *= u, s.addPoint(a.x + n * m, a.y + r * m, a.z + l * m, n, r, l, c - p, !1) } } }), rt.prototype = Object.assign(Object.create(it.prototype), { constructor: rt, detectCollision: function(t, i, s) { var h, e = this.n, a = this.p, o = this.flip ? i : t, n = this.flip ? t : i, r = o.radius; e.sub(o.position, n.position), e.x *= n.normal.x, e.y *= n.normal.y, e.z *= n.normal.z, (h = e.lengthSq()) > 0 && h < r * r && (h = Pt.sqrt(h), e.copy(n.normal).negate(), a.copy(o.position).addScaledVector(e, r), s.addPointVec(a, e, h - r, this.flip)) } }), lt.prototype = Object.assign(Object.create(it.prototype), { constructor: lt, detectCollision: function(t, i, s) { var h, e = this.n, a = this.p, o = this.cc, n = this.flip ? i : t, r = this.flip ? t : i, l = n.dimentions, c = n.halfWidth, m = n.halfHeight, p = n.halfDepth, u = 0; this.dix.set(l[0], l[1], l[2]), this.diy.set(l[3], l[4], l[5]), this.diz.set(l[6], l[7], l[8]), e.sub(n.position, r.position), e.x *= r.normal.x, e.y *= r.normal.y, e.z *= r.normal.z, o.set(Pt.dotVectors(this.dix, e), Pt.dotVectors(this.diy, e), Pt.dotVectors(this.diz, e)), o.x > c ? o.x = c : o.x < -c ? o.x = -c : u = 1, o.y > m ? o.y = m : o.y < -m ? o.y = -m : u |= 2, o.z > p ? o.z = p : o.z < -p ? o.z = -p : u |= 4, 7 === u && (e.set(o.x < 0 ? c + o.x : c - o.x, o.y < 0 ? m + o.y : m - o.y, o.z < 0 ? p + o.z : p - o.z), e.x < e.y ? e.x < e.z ? (h = e.x - c, o.x < 0 ? (o.x = -c, e.copy(this.dix)) : (o.x = c, e.subEqual(this.dix))) : (h = e.z - p, o.z < 0 ? (o.z = -p, e.copy(this.diz)) : (o.z = p, e.subEqual(this.diz))) : e.y < e.z ? (h = e.y - m, o.y < 0 ? (o.y = -m, e.copy(this.diy)) : (o.y = m, e.subEqual(this.diy))) : (h = e.z - p, o.z < 0 ? (o.z = -p, e.copy(this.diz)) : (o.z = p, e.subEqual(this.diz))), a.copy(r.position).addScaledVector(e, 1), s.addPointVec(a, e, h, this.flip)) } }), Object.assign(ct.prototype, { World: !0, play: function() { if (null === this.timer) { var t = this; this.timer = setInterval(function() { t.step() }, this.timerate) } }, stop: function() { null !== this.timer && (clearInterval(this.timer), this.timer = null) }, setGravity: function(t) { this.gravity.fromArray(t) }, getInfo: function() { return this.isStat ? this.performance.show() : "" }, clear: function() { for (this.stop(), this.preLoop = null, this.postLoop = null, this.randX = 65535; null !== this.joints;)this.removeJoint(this.joints); for (; null !== this.contacts;)this.removeContact(this.contacts); for (; null !== this.rigidBodies;)this.removeRigidBody(this.rigidBodies) }, addRigidBody: function(t) { t.parent && s("World", "It is not possible to be added to more than one world one of the rigid body"), t.setParent(this); for (var i = t.shapes; null !== i; i = i.next)this.addShape(i); null !== this.rigidBodies && ((this.rigidBodies.prev = t).next = this.rigidBodies), this.rigidBodies = t, this.numRigidBodies++ }, removeRigidBody: function(t) { var i = t; if (i.parent === this) { i.awake(); for (var s = i.jointLink; null != s;) { var h = s.joint; s = s.next, this.removeJoint(h) } for (var e = t.shapes; null !== e; e = e.next)this.removeShape(e); var a = i.prev, o = i.next; null !== a && (a.next = o), null !== o && (o.prev = a), this.rigidBodies == i && (this.rigidBodies = o), i.prev = null, i.next = null, i.parent = null, this.numRigidBodies-- } }, getByName: function(t) { for (var i = this.rigidBodies; null !== i;) { if (i.name === t) return i; i = i.next } for (var s = this.joints; null !== s;) { if (s.name === t) return s; s = s.next } return null }, addShape: function(t) { t.parent && t.parent.parent || s("World", "It is not possible to be added alone to shape world"), t.proxy = this.broadPhase.createProxy(t), t.updateProxy(), this.broadPhase.addProxy(t.proxy) }, removeShape: function(t) { this.broadPhase.removeProxy(t.proxy), t.proxy = null }, addJoint: function(t) { t.parent && s("World", "It is not possible to be added to more than one world one of the joint"), null != this.joints && ((this.joints.prev = t).next = this.joints), this.joints = t, t.setParent(this), this.numJoints++ , t.awake(), t.attach() }, removeJoint: function(t) { var i = t, s = i.prev, h = i.next; null !== s && (s.next = h), null !== h && (h.prev = s), this.joints == i && (this.joints = h), i.prev = null, i.next = null, this.numJoints-- , i.awake(), i.detach(), i.parent = null }, addContact: function(t, i) { var s; null !== this.unusedContacts ? (s = this.unusedContacts, this.unusedContacts = this.unusedContacts.next) : s = new F, s.attach(t, i), s.detector = this.detectors[t.type][i.type], this.contacts && ((this.contacts.prev = s).next = this.contacts), this.contacts = s, this.numContacts++ }, removeContact: function(t) { var i = t.prev, s = t.next; s && (s.prev = i), i && (i.next = s), this.contacts == t && (this.contacts = s), t.prev = null, t.next = null, t.detach(), t.next = this.unusedContacts, this.unusedContacts = t, this.numContacts-- }, getContact: function(t, i) { t = t.constructor === q ? t.name : t, i = i.constructor === q ? i.name : i; for (var s, h, e = this.contacts; null !== e;) { if (s = e.body1.name, h = e.body2.name, s === t && h === i || h === t && s === i) return e.touching ? e : null; e = e.next } return null }, checkContact: function(t, i) { for (var s, h, e = this.contacts; null !== e;) { if (s = e.body1.name || " ", h = e.body2.name || " ", s == t && h == i || h == t && s == i) return !!e.touching; e = e.next } }, callSleep: function(t) { return !!t.allowSleep && (!(t.linearVelocity.lengthSq() > .04) && !(t.angularVelocity.lengthSq() > .25)) }, step: function() { var t = this.isStat; t && this.performance.setTime(0); for (var i = this.rigidBodies; null !== i;)i.addedToIsland = !1, i.sleeping && i.testWakeUp(), i = i.next; t && this.performance.setTime(1), this.broadPhase.detectPairs(); for (var s = this.broadPhase.pairs, h = this.broadPhase.numPairs; h--;) { var a, o, n = s[h]; n.shape1.id < n.shape2.id ? (a = n.shape1, o = n.shape2) : (a = n.shape2, o = n.shape1); var r; r = a.numContacts < o.numContacts ? a.contactLink : o.contactLink; for (var l = !1; r;) { if ((N = r.contact).shape1 == a && N.shape2 == o) { N.persisting = !0, l = !0; break } r = r.next } l || this.addContact(a, o) } for (t && this.performance.calcBroadPhase(), this.numContactPoints = 0, N = this.contacts; null !== N;)if (N.persisting || !N.shape1.aabb.intersectTest(N.shape2.aabb)) { var c = N.body1, m = N.body2; (c.isDynamic && !c.sleeping || m.isDynamic && !m.sleeping) && N.updateManifold(), this.numContactPoints += N.manifold.numPoints, N.persisting = !1, N.constraint.addedToIsland = !1, N = N.next } else { var p = N.next; this.removeContact(N), N = p } t && this.performance.calcNarrowPhase(); var u, y, x = 1 / this.timeStep; for (u = this.joints; null !== u; u = u.next)u.addedToIsland = !1; this.islandRigidBodies = [], this.islandConstraints = [], this.islandStack = [], t && this.performance.setTime(1), this.numIslands = 0; for (var d = this.rigidBodies; null !== d; d = d.next)if (!(d.addedToIsland || d.isStatic || d.sleeping)) if (d.isLonely()) d.isDynamic && d.linearVelocity.addScaledVector(this.gravity, this.timeStep), this.callSleep(d) ? (d.sleepTime += this.timeStep, d.sleepTime > .5 ? d.sleep() : d.updatePosition(this.timeStep)) : (d.sleepTime = 0, d.updatePosition(this.timeStep)), this.numIslands++; else { var f = 0, b = 0, v = 1; this.islandStack[0] = d, d.addedToIsland = !0; do { if (i = this.islandStack[--v], this.islandStack[v] = null, i.sleeping = !1, this.islandRigidBodies[f++] = i, !i.isStatic) { for (var z = i.contactLink; null !== z; z = z.next) { var N = z.contact; !(y = N.constraint).addedToIsland && N.touching && (this.islandConstraints[b++] = y, y.addedToIsland = !0, (p = z.body).addedToIsland || (this.islandStack[v++] = p, p.addedToIsland = !0)) } for (var k = i.jointLink; null !== k; k = k.next)(y = k.joint).addedToIsland || (this.islandConstraints[b++] = y, y.addedToIsland = !0, !(p = k.body).addedToIsland && p.isDynamic && (this.islandStack[v++] = p, p.addedToIsland = !0)) } } while (0 != v); for (var w = (new e).addScaledVector(this.gravity, this.timeStep), M = f; M--;)(i = this.islandRigidBodies[M]).isDynamic && i.linearVelocity.addEqual(w); if (this.enableRandomizer) for (M = b; M--;)if (0 !== M) { var g = (this.randX = this.randX * this.randA + this.randB & 2147483647) / 2147483648 * M | 0; y = this.islandConstraints[M], this.islandConstraints[M] = this.islandConstraints[g], this.islandConstraints[g] = y } for (M = b; M--;)this.islandConstraints[M].preSolve(this.timeStep, x); for (var I = this.numIterations; I--;)for (M = b; M--;)this.islandConstraints[M].solve(); for (M = b; M--;)this.islandConstraints[M].postSolve(), this.islandConstraints[M] = null; var V = 10; for (M = f; M--;)i = this.islandRigidBodies[M], this.callSleep(i) ? (i.sleepTime += this.timeStep, i.sleepTime < V && (V = i.sleepTime)) : (i.sleepTime = 0, V = 0); if (V > .5) for (M = f; M--;)this.islandRigidBodies[M].sleep(), this.islandRigidBodies[M] = null; else for (M = f; M--;)this.islandRigidBodies[M].updatePosition(this.timeStep), this.islandRigidBodies[M] = null; this.numIslands++ } t && this.performance.calcEnd(), null !== this.postLoop && this.postLoop() }, remove: function(t) { }, add: function(t) { var i = (t = t || {}).type || "box"; return i.constructor === String && (i = [i]), "joint" === i[0].substring(0, 5) ? this.initJoint(i[0], t) : this.initBody(i, t) }, initBody: function(t, i) { var s = this.invScale, h = i.move || !1, o = i.kinematic || !1, n = i.pos || [0, 0, 0]; n = n.map(function(t) { return t * s }); var r = i.posShape || [0, 0, 0]; r = r.map(function(t) { return t * s }); var l = i.rot || [0, 0, 0]; l = l.map(function(t) { return t * Pt.degtorad }); var y = i.rotShape || [0, 0, 0]; y = l.map(function(t) { return t * Pt.degtorad }); var d = void 0 === i.size ? [1, 1, 1] : i.size; 1 === d.length && (d[1] = d[0]), 2 === d.length && (d[2] = d[0]), d = d.map(function(t) { return t * s }); var f = new x; void 0 !== i.density && (f.density = i.density), void 0 !== i.friction && (f.friction = i.friction), void 0 !== i.restitution && (f.restitution = i.restitution), void 0 !== i.belongsTo && (f.belongsTo = i.belongsTo), void 0 !== i.collidesWith && (f.collidesWith = i.collidesWith), void 0 !== i.config && (void 0 !== i.config[0] && (f.density = i.config[0]), void 0 !== i.config[1] && (f.friction = i.config[1]), void 0 !== i.config[2] && (f.restitution = i.config[2]), void 0 !== i.config[3] && (f.belongsTo = i.config[3]), void 0 !== i.config[4] && (f.collidesWith = i.config[4])); for (var b, v, z = new q(new e(n[0], n[1], n[2]), (new a).setFromEuler(l[0], l[1], l[2])), N = 0; N < t.length; N++) { switch (v = 3 * N, void 0 !== r[v] && f.relativePosition.set(r[v], r[v + 1], r[v + 2]), void 0 !== y[v] && f.relativeRotation.setQuat((new a).setFromEuler(y[v], y[v + 1], y[v + 2])), t[N]) { case "sphere": b = new m(f, d[v]); break; case "cylinder": b = new p(f, d[v], d[v + 1]); break; case "box": b = new c(f, d[v], d[v + 1], d[v + 2]); break; case "plane": b = new u(f) }z.addShape(b) } return i.neverSleep || o ? z.allowSleep = !1 : z.allowSleep = !0, z.isKinematic = o, h ? i.massPos || i.massRot ? z.setupMass(1, !1) : z.setupMass(1, !0) : z.setupMass(2), void 0 !== i.name && (z.name = i.name), this.addRigidBody(z), h && (i.sleep ? z.sleep() : z.awake()), z }, initJoint: function(t, i) { var h = this.invScale, e = i.axe1 || [1, 0, 0], a = i.axe2 || [1, 0, 0], o = i.pos1 || [0, 0, 0], n = i.pos2 || [0, 0, 0]; o = o.map(function(t) { return t * h }), n = n.map(function(t) { return t * h }); var r, l; "jointDistance" === t ? (r = i.min || 0, l = i.max || 10, r *= h, l *= h) : (r = i.min || 57.29578, l = i.max || 0, r *= Pt.degtorad, l *= Pt.degtorad); var c = i.limit || null, m = i.spring || null, p = i.motor || null, u = new T; u.scale = this.scale, u.invScale = this.invScale, u.allowCollision = i.collision || !1, u.localAxis1.set(e[0], e[1], e[2]), u.localAxis2.set(a[0], a[1], a[2]), u.localAnchorPoint1.set(o[0], o[1], o[2]), u.localAnchorPoint2.set(n[0], n[1], n[2]); var y = null, x = null; if (void 0 === i.body1 || void 0 === i.body2) return s("World", "Can't add joint if attach rigidbodys not define !"); if (i.body1.constructor === String ? y = this.getByName(i.body1) : i.body1.constructor === Number ? y = this.getByName(i.body1) : i.body1.constructor === q && (y = i.body1), i.body2.constructor === String ? x = this.getByName(i.body2) : i.body2.constructor === Number ? x = this.getByName(i.body2) : i.body2.constructor === q && (x = i.body2), null === y || null === x) return s("World", "Can't add joint attach rigidbodys not find !"); u.body1 = y, u.body2 = x; var d; switch (t) { case "jointDistance": d = new g(u, r, l), null !== m && d.limitMotor.setSpring(m[0], m[1]), null !== p && d.limitMotor.setMotor(p[0], p[1]); break; case "jointHinge": case "joint": d = new k(u, r, l), null !== m && d.limitMotor.setSpring(m[0], m[1]), null !== p && d.limitMotor.setMotor(p[0], p[1]); break; case "jointPrisme": d = new L(u, r, l); break; case "jointSlide": d = new S(u, r, l); break; case "jointBall": d = new w(u); break; case "jointWheel": d = new P(u), null !== c && d.rotationalLimitMotor1.setLimit(c[0], c[1]), null !== m && d.rotationalLimitMotor1.setSpring(m[0], m[1]), null !== p && d.rotationalLimitMotor1.setMotor(p[0], p[1]) }return d.name = i.name || "", this.addJoint(d), d } }), t.Math = Pt, t.Vec3 = e, t.Quat = a, t.Mat33 = o, t.Shape = l, t.Box = c, t.Sphere = m, t.Cylinder = p, t.Plane = u, t.Particle = y, t.ShapeConfig = x, t.LimitMotor = d, t.HingeJoint = k, t.BallAndSocketJoint = w, t.DistanceJoint = g, t.PrismaticJoint = L, t.SliderJoint = S, t.WheelJoint = P, t.JointConfig = T, t.RigidBody = q, t.World = ct, t.REVISION = mt, t.BR_NULL = pt, t.BR_BRUTE_FORCE = ut, t.BR_SWEEP_AND_PRUNE = yt, t.BR_BOUNDING_VOLUME_TREE = xt, t.BODY_NULL = dt, t.BODY_DYNAMIC = 1, t.BODY_STATIC = 2, t.BODY_KINEMATIC = 3, t.BODY_GHOST = 4, t.SHAPE_NULL = ft, t.SHAPE_SPHERE = bt, t.SHAPE_BOX = vt, t.SHAPE_CYLINDER = zt, t.SHAPE_PLANE = Nt, t.SHAPE_PARTICLE = kt, t.SHAPE_TETRA = 6, t.JOINT_NULL = wt, t.JOINT_DISTANCE = Mt, t.JOINT_BALL_AND_SOCKET = gt, t.JOINT_HINGE = It, t.JOINT_WHEEL = Vt, t.JOINT_SLIDER = Lt, t.JOINT_PRISMATIC = St, t.AABB_PROX = .005, t.printError = s, t.InfoDisplay = h, Object.defineProperty(t, "__esModule", { value: !0 }) });