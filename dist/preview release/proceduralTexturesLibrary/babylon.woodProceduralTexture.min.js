var BABYLON,__extends=this&&this.__extends||(function(){var r=function(e,o){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,o){e.__proto__=o}||function(e,o){for(var t in o)o.hasOwnProperty(t)&&(e[t]=o[t])})(e,o)};return function(e,o){function t(){this.constructor=e}r(e,o),e.prototype=null===o?Object.create(o):(t.prototype=o.prototype,new t)}})(),__decorate=this&&this.__decorate||function(e,o,t,r){var n,a=arguments.length,i=a<3?o:null===r?r=Object.getOwnPropertyDescriptor(o,t):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(e,o,t,r);else for(var c=e.length-1;0<=c;c--)(n=e[c])&&(i=(a<3?n(i):3<a?n(o,t,i):n(o,t))||i);return 3<a&&i&&Object.defineProperty(o,t,i),i};!(function(c){var e=(function(i){function r(e,o,t,r,n){var a=i.call(this,e,o,"woodProceduralTexture",t,r,n)||this;return a._ampScale=100,a._woodColor=new c.Color3(.32,.17,.09),a.updateShaderUniforms(),a}return __extends(r,i),r.prototype.updateShaderUniforms=function(){this.setFloat("ampScale",this._ampScale),this.setColor3("woodColor",this._woodColor)},Object.defineProperty(r.prototype,"ampScale",{get:function(){return this._ampScale},set:function(e){this._ampScale=e,this.updateShaderUniforms()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"woodColor",{get:function(){return this._woodColor},set:function(e){this._woodColor=e,this.updateShaderUniforms()},enumerable:!0,configurable:!0}),r.prototype.serialize=function(){var e=c.SerializationHelper.Serialize(this,i.prototype.serialize.call(this));return e.customType="BABYLON.WoodProceduralTexture",e},r.Parse=function(e,o,t){return c.SerializationHelper.Parse((function(){return new r(e.name,e._size,o,void 0,e._generateMipMaps)}),e,o,t)},__decorate([c.serialize()],r.prototype,"ampScale",null),__decorate([c.serializeAsColor3()],r.prototype,"woodColor",null),r})(c.ProceduralTexture);c.WoodProceduralTexture=e})(BABYLON||(BABYLON={})),BABYLON.Effect.ShadersStore.woodProceduralTexturePixelShader="precision highp float;\nvarying vec2 vPosition;\nvarying vec2 vUV;\nuniform float ampScale;\nuniform vec3 woodColor;\nfloat rand(vec2 n) {\nreturn fract(cos(dot(n,vec2(12.9898,4.1414)))*43758.5453);\n}\nfloat noise(vec2 n) {\nconst vec2 d=vec2(0.0,1.0);\nvec2 b=floor(n),f=smoothstep(vec2(0.0),vec2(1.0),fract(n));\nreturn mix(mix(rand(b),rand(b+d.yx),f.x),mix(rand(b+d.xy),rand(b+d.yy),f.x),f.y);\n}\nfloat fbm(vec2 n) {\nfloat total=0.0,amplitude=1.0;\nfor (int i=0; i<4; i++) {\ntotal+=noise(n)*amplitude;\nn+=n;\namplitude*=0.5;\n}\nreturn total;\n}\nvoid main(void) {\nfloat ratioy=mod(vUV.x*ampScale,2.0+fbm(vUV*0.8));\nvec3 wood=woodColor*ratioy;\ngl_FragColor=vec4(wood,1.0);\n}";