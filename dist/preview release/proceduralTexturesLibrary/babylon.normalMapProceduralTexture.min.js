var __extends=this&&this.__extends||(function(){var e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])};return function(t,r){function o(){this.constructor=t}e(t,r),t.prototype=null===r?Object.create(r):(o.prototype=r.prototype,new o)}})(),BABYLON;!(function(e){var t=(function(e){function t(t,r,o,n,a){var u=e.call(this,t,r,"normalMapProceduralTexture",o,n,a)||this;return u.updateShaderUniforms(),u}return __extends(t,e),t.prototype.updateShaderUniforms=function(){this.setTexture("baseSampler",this._baseTexture),this.setFloat("size",this.getRenderSize())},t.prototype.render=function(t){e.prototype.render.call(this,t)},t.prototype.resize=function(t,r){e.prototype.resize.call(this,t,r),this.updateShaderUniforms()},Object.defineProperty(t.prototype,"baseTexture",{get:function(){return this._baseTexture},set:function(e){this._baseTexture=e,this.updateShaderUniforms()},enumerable:!0,configurable:!0}),t})(e.ProceduralTexture);e.NormalMapProceduralTexture=t})(BABYLON||(BABYLON={})),BABYLON.Effect.ShadersStore.normalMapProceduralTexturePixelShader="precision highp float;\n\nuniform sampler2D baseSampler;\nuniform float size;\n\nvarying vec2 vUV;\n\nconst vec3 LUMA_COEFFICIENT=vec3(0.2126,0.7152,0.0722);\nfloat lumaAtCoord(vec2 coord)\n{\nvec3 pixel=texture2D(baseSampler,coord).rgb;\nfloat luma=dot(pixel,LUMA_COEFFICIENT);\nreturn luma;\n}\nvoid main()\n{\nfloat lumaU0=lumaAtCoord(vUV+vec2(-1.0,0.0)/size);\nfloat lumaU1=lumaAtCoord(vUV+vec2( 1.0,0.0)/size);\nfloat lumaV0=lumaAtCoord(vUV+vec2( 0.0,-1.0)/size);\nfloat lumaV1=lumaAtCoord(vUV+vec2( 0.0,1.0)/size);\nvec2 slope=(vec2(lumaU0-lumaU1,lumaV0-lumaV1)+1.0)*0.5;\ngl_FragColor=vec4(slope,1.0,1.0);\n}\n";