{"version":3,"sources":["webpack://BABYLONJS/serializers/src/webpack/universalModuleDefinition","webpack://BABYLONJS/serializers/src/webpack/bootstrap","webpack://BABYLONJS/node_modules/tslib/tslib.es6.js","webpack://BABYLONJS/serializers/src/(webpack)/buildin/global.js","webpack://BABYLONJS/serializers/src/OBJ/index.ts","webpack://BABYLONJS/serializers/src/OBJ/objSerializer.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/Extensions/KHR_lights_punctual.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/Extensions/KHR_materials_sheen.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/Extensions/KHR_materials_unlit.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/Extensions/KHR_texture_transform.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/Extensions/index.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/glTFAnimation.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/glTFData.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/glTFExporter.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/glTFExporterExtension.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/glTFMaterialExporter.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/glTFSerializer.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/glTFUtilities.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/index.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/shaders/textureTransform.fragment.ts","webpack://BABYLONJS/serializers/src/glTF/glTFFileExporter.ts","webpack://BABYLONJS/serializers/src/glTF/index.ts","webpack://BABYLONJS/serializers/src/index.ts","webpack://BABYLONJS/serializers/src/legacy/legacy-glTF2Serializer.ts","webpack://BABYLONJS/serializers/src/legacy/legacy-objSerializer.ts","webpack://BABYLONJS/serializers/src/legacy/legacy-stlSerializer.ts","webpack://BABYLONJS/serializers/src/legacy/legacy.ts","webpack://BABYLONJS/serializers/src/stl/index.ts","webpack://BABYLONJS/serializers/src/stl/stlSerializer.ts","webpack://BABYLONJS/serializers/src/external {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}"],"names":[],"mappings":"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","file":"babylonjs.serializers.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-serializers\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-serializers\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"SERIALIZERS\"] = factory(root[\"BABYLON\"]);\n})((typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : this), function(__WEBPACK_EXTERNAL_MODULE_babylonjs_Maths_math_vector__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./legacy/legacy.ts\");\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","export * from \"./objSerializer\";","\nimport { Nullable } from \"babylonjs/types\";\nimport { Matrix } from \"babylonjs/Maths/math.vector\";\nimport { Tools } from \"babylonjs/Misc/tools\";\nimport { StandardMaterial } from \"babylonjs/Materials/standardMaterial\";\nimport { Geometry } from \"babylonjs/Meshes/geometry\";\nimport { Mesh } from \"babylonjs/Meshes/mesh\";\n\n/**\n * Class for generating OBJ data from a Babylon scene.\n */\nexport class OBJExport {\n    /**\n     * Exports the geometry of a Mesh array in .OBJ file format (text)\n     * @param mesh defines the list of meshes to serialize\n     * @param materials defines if materials should be exported\n     * @param matlibname defines the name of the associated mtl file\n     * @param globalposition defines if the exported positions are globals or local to the exported mesh\n     * @returns the OBJ content\n     */\n    public static OBJ(mesh: Mesh[], materials?: boolean, matlibname?: string, globalposition?: boolean): string {\n        const output: string[] = [];\n        let v = 1;\n        if (materials) {\n            if (!matlibname) {\n                matlibname = 'mat';\n            }\n            output.push(\"mtllib \" + matlibname + \".mtl\");\n        }\n        for (let j = 0; j < mesh.length; j++) {\n            output.push(\"g object\" + j);\n            output.push(\"o object_\" + j);\n\n            //Uses the position of the item in the scene, to the file (this back to normal in the end)\n            let lastMatrix: Nullable<Matrix> = null;\n            if (globalposition) {\n                var newMatrix = Matrix.Translation(mesh[j].position.x, mesh[j].position.y, mesh[j].position.z);\n                lastMatrix = Matrix.Translation(-(mesh[j].position.x), -(mesh[j].position.y), -(mesh[j].position.z));\n                mesh[j].bakeTransformIntoVertices(newMatrix);\n            }\n\n            //TODO: submeshes (groups)\n            //TODO: smoothing groups (s 1, s off);\n            if (materials) {\n                let mat = mesh[j].material;\n\n                if (mat) {\n                    output.push(\"usemtl \" + mat.id);\n                }\n            }\n            const g: Nullable<Geometry> = mesh[j].geometry;\n\n            if (!g) {\n                Tools.Warn(\"No geometry is present on the mesh\");\n                continue;\n            }\n\n            const trunkVerts = g.getVerticesData('position');\n            const trunkNormals = g.getVerticesData('normal');\n            const trunkUV = g.getVerticesData('uv');\n            const trunkFaces = g.getIndices();\n            var curV = 0;\n\n            if (!trunkVerts || !trunkFaces) {\n                Tools.Warn(\"There are no position vertices or indices on the mesh!\");\n                continue;\n            }\n\n            for (var i = 0; i < trunkVerts.length; i += 3) {\n                // Babylon.js default is left handed, while OBJ default is right handed\n                // Need to invert Z vertices unless Babylon is set to use a right handed system\n                if (mesh[0].getScene().useRightHandedSystem) {\n                    output.push(\"v \" + trunkVerts[i] + \" \" + trunkVerts[i + 1] + \" \" + trunkVerts[i + 2]);\n                } else {\n                    output.push(\"v \" + trunkVerts[i] + \" \" + trunkVerts[i + 1] + \" \" + -trunkVerts[i + 2]);\n                }\n                curV++;\n            }\n\n            if (trunkNormals != null) {\n                for (i = 0; i < trunkNormals.length; i += 3) {\n                    output.push(\"vn \" + trunkNormals[i] + \" \" + trunkNormals[i + 1] + \" \" + trunkNormals[i + 2]);\n                }\n            }\n            if (trunkUV != null) {\n\n                for (i = 0; i < trunkUV.length; i += 2) {\n                    output.push(\"vt \" + trunkUV[i] + \" \" + trunkUV[i + 1]);\n                }\n            }\n\n            for (i = 0; i < trunkFaces.length; i += 3) {\n                const indices = [String(trunkFaces[i + 2] + v), String(trunkFaces[i + 1] + v), String(trunkFaces[i] + v)];\n                const blanks: string[] = [\"\", \"\", \"\"];\n\n                const facePositions = indices;\n                const faceUVs = trunkUV != null ? indices : blanks;\n                const faceNormals = trunkNormals != null ? indices : blanks;\n\n                output.push(\n                    \"f \" + facePositions[0] + \"/\" + faceUVs[0] + \"/\" + faceNormals[0] +\n                    \" \" + facePositions[1] + \"/\" + faceUVs[1] + \"/\" + faceNormals[1] +\n                    \" \" + facePositions[2] + \"/\" + faceUVs[2] + \"/\" + faceNormals[2]\n                );\n            }\n            //back de previous matrix, to not change the original mesh in the scene\n            if (globalposition && lastMatrix) {\n                mesh[j].bakeTransformIntoVertices(lastMatrix);\n            }\n            v += curV;\n        }\n        const text: string = output.join(\"\\n\");\n        return (text);\n    }\n\n    /**\n     * Exports the material(s) of a mesh in .MTL file format (text)\n     * @param mesh defines the mesh to extract the material from\n     * @returns the mtl content\n     */\n    //TODO: Export the materials of mesh array\n    public static MTL(mesh: Mesh): string {\n        var output = [];\n        var m = <StandardMaterial>mesh.material;\n        output.push(\"newmtl mat1\");\n        output.push(\"  Ns \" + m.specularPower.toFixed(4));\n        output.push(\"  Ni 1.5000\");\n        output.push(\"  d \" + m.alpha.toFixed(4));\n        output.push(\"  Tr 0.0000\");\n        output.push(\"  Tf 1.0000 1.0000 1.0000\");\n        output.push(\"  illum 2\");\n        output.push(\"  Ka \" + m.ambientColor.r.toFixed(4) + \" \" + m.ambientColor.g.toFixed(4) + \" \" + m.ambientColor.b.toFixed(4));\n        output.push(\"  Kd \" + m.diffuseColor.r.toFixed(4) + \" \" + m.diffuseColor.g.toFixed(4) + \" \" + m.diffuseColor.b.toFixed(4));\n        output.push(\"  Ks \" + m.specularColor.r.toFixed(4) + \" \" + m.specularColor.g.toFixed(4) + \" \" + m.specularColor.b.toFixed(4));\n        output.push(\"  Ke \" + m.emissiveColor.r.toFixed(4) + \" \" + m.emissiveColor.g.toFixed(4) + \" \" + m.emissiveColor.b.toFixed(4));\n\n        //TODO: uv scale, offset, wrap\n        //TODO: UV mirrored in Blender? second UV channel? lightMap? reflection textures?\n        var uvscale = \"\";\n\n        if (m.ambientTexture) {\n            output.push(\"  map_Ka \" + uvscale + m.ambientTexture.name);\n        }\n\n        if (m.diffuseTexture) {\n            output.push(\"  map_Kd \" + uvscale + m.diffuseTexture.name);\n            //TODO: alpha testing, opacity in diffuse texture alpha channel (diffuseTexture.hasAlpha -> map_d)\n        }\n\n        if (m.specularTexture) {\n            output.push(\"  map_Ks \" + uvscale + m.specularTexture.name);\n            /* TODO: glossiness = specular highlight component is in alpha channel of specularTexture. (???)\n            if (m.useGlossinessFromSpecularMapAlpha)  {\n                output.push(\"  map_Ns \"+uvscale + m.specularTexture.name);\n            }\n            */\n        }\n\n        /* TODO: emissive texture not in .MAT format (???)\n        if (m.emissiveTexture) {\n            output.push(\"  map_d \"+uvscale+m.emissiveTexture.name);\n        }\n        */\n\n        if (m.bumpTexture) {\n            output.push(\"  map_bump -imfchan z \" + uvscale + m.bumpTexture.name);\n        }\n\n        if (m.opacityTexture) {\n            output.push(\"  map_d \" + uvscale + m.opacityTexture.name);\n        }\n\n        var text = output.join(\"\\n\");\n        return (text);\n    }\n}\n","import { SpotLight } from \"babylonjs/Lights/spotLight\";\nimport { Nullable } from \"babylonjs/types\";\nimport { Vector3, Quaternion, TmpVectors, Matrix } from \"babylonjs/Maths/math.vector\";\nimport { Color3 } from \"babylonjs/Maths/math.color\";\nimport { Light } from \"babylonjs/Lights/light\";\nimport { DirectionalLight } from \"babylonjs/Lights/directionalLight\";\nimport { Node } from \"babylonjs/node\";\nimport { ShadowLight } from \"babylonjs/Lights/shadowLight\";\nimport { IChildRootProperty } from \"babylonjs-gltf2interface\";\nimport { INode } from \"babylonjs-gltf2interface\";\nimport { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\nimport { _Exporter } from \"../glTFExporter\";\nimport { Logger } from \"babylonjs/Misc/logger\";\nimport { _GLTFUtilities } from \"../glTFUtilities\";\n\nconst NAME = \"KHR_lights_punctual\";\n\nenum LightType {\n    DIRECTIONAL = \"directional\",\n    POINT = \"point\",\n    SPOT = \"spot\"\n}\n\ninterface ILightReference {\n    light: number;\n}\n\ninterface ILight extends IChildRootProperty {\n    type: LightType;\n    color?: number[];\n    intensity?: number;\n    range?: number;\n    spot?: {\n        innerConeAngle?: number;\n        outerConeAngle?: number;\n    };\n}\n\ninterface ILights {\n    lights: ILight[];\n}\n\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md)\n */\nexport class KHR_lights_punctual implements IGLTFExporterExtensionV2 {\n    /** The name of this extension. */\n    public readonly name = NAME;\n\n    /** Defines whether this extension is enabled. */\n    public enabled = true;\n\n    /** Defines whether this extension is required */\n    public required = false;\n\n    /** Reference to the glTF exporter */\n    private _exporter: _Exporter;\n\n    private _lights: ILights;\n\n    /** @hidden */\n    constructor(exporter: _Exporter) {\n        this._exporter = exporter;\n    }\n\n    /** @hidden */\n    public dispose() {\n        delete this._lights;\n    }\n\n    /** @hidden */\n    public get wasUsed() {\n        return !!this._lights;\n    }\n\n    /** @hidden */\n    public onExporting(): void {\n        this._exporter!._glTF.extensions![NAME] = this._lights;\n    }\n    /**\n     * Define this method to modify the default behavior when exporting a node\n     * @param context The context when exporting the node\n     * @param node glTF node\n     * @param babylonNode BabylonJS node\n     * @param nodeMap Node mapping of unique id to glTF node index\n     * @returns nullable INode promise\n     */\n    public postExportNodeAsync(context: string, node: Nullable<INode>, babylonNode: Node, nodeMap?: {[key: number]: number}): Promise<Nullable<INode>> {\n        return new Promise((resolve, reject) => {\n            if (node && babylonNode instanceof ShadowLight) {\n                const babylonLight: ShadowLight = babylonNode;\n                let light: ILight;\n\n                const lightType = (\n                    babylonLight.getTypeID() == Light.LIGHTTYPEID_POINTLIGHT ? LightType.POINT : (\n                        babylonLight.getTypeID() == Light.LIGHTTYPEID_DIRECTIONALLIGHT ? LightType.DIRECTIONAL : (\n                            babylonLight.getTypeID() == Light.LIGHTTYPEID_SPOTLIGHT ? LightType.SPOT : null\n                        )));\n                if (lightType == null) {\n                    Logger.Warn(`${context}: Light ${babylonLight.name} is not supported in ${NAME}`);\n                }\n                else {\n                    const lightPosition = babylonLight.position.clone();\n                    let convertToRightHandedSystem = this._exporter._convertToRightHandedSystemMap[babylonNode.uniqueId];\n                    if (!lightPosition.equals(Vector3.Zero())) {\n                        if (convertToRightHandedSystem) {\n                            _GLTFUtilities._GetRightHandedPositionVector3FromRef(lightPosition);\n                        }\n                        node.translation = lightPosition.asArray();\n                    }\n                    if (lightType !== LightType.POINT) {\n                        const localAxis = babylonLight.direction;\n                        const yaw = -Math.atan2(localAxis.z * (this._exporter._babylonScene.useRightHandedSystem ? -1 : 1), localAxis.x) + Math.PI / 2;\n                        const len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);\n                        const pitch = -Math.atan2(localAxis.y, len);\n                        const lightRotationQuaternion = Quaternion.RotationYawPitchRoll(yaw, pitch, 0);\n                        if (convertToRightHandedSystem) {\n                            _GLTFUtilities._GetRightHandedQuaternionFromRef(lightRotationQuaternion);\n                        }\n                        if (!lightRotationQuaternion.equals(Quaternion.Identity())) {\n                            node.rotation = lightRotationQuaternion.asArray();\n                        }\n                    }\n\n                    if (babylonLight.falloffType !== Light.FALLOFF_GLTF) {\n                        Logger.Warn(`${context}: Light falloff for ${babylonLight.name} does not match the ${NAME} specification!`);\n                    }\n                    light = {\n                        type: lightType\n                    };\n                    if (!babylonLight.diffuse.equals(Color3.White())) {\n                        light.color = babylonLight.diffuse.asArray();\n                    }\n                    if (babylonLight.intensity !== 1.0) {\n                        light.intensity = babylonLight.intensity;\n                    }\n                    if (babylonLight.range !== Number.MAX_VALUE) {\n                        light.range = babylonLight.range;\n                    }\n\n                    if (lightType === LightType.SPOT) {\n                        const babylonSpotLight = babylonLight as SpotLight;\n                        if (babylonSpotLight.angle !== Math.PI / 2.0) {\n                            if (light.spot == null) {\n                                light.spot = {};\n                            }\n                            light.spot.outerConeAngle = babylonSpotLight.angle / 2.0;\n                        }\n                        if (babylonSpotLight.innerAngle !== 0) {\n                            if (light.spot == null) {\n                                light.spot = {};\n                            }\n                            light.spot.innerConeAngle = babylonSpotLight.innerAngle / 2.0;\n                        }\n                    }\n\n                    if (this._lights == null) {\n                        this._lights = {\n                            lights: []\n                        };\n                    }\n\n                    this._lights.lights.push(light);\n\n                    const lightReference: ILightReference = {\n                        light: this._lights.lights.length - 1\n                    };\n\n                    // Avoid duplicating the Light's parent node if possible.\n                    let parentBabylonNode = babylonNode.parent;\n                    if (parentBabylonNode && parentBabylonNode.getChildren().length == 1) {\n                        let parentNode = this._exporter._nodes[nodeMap![parentBabylonNode.uniqueId]];\n                        if (parentNode) {\n                            let parentNodeLocalMatrix = TmpVectors.Matrix[0];\n                            let parentInvertNodeLocalMatrix = TmpVectors.Matrix[1];\n                            let parentNodeLocalTranslation = parentNode.translation ? new Vector3(parentNode.translation[0], parentNode.translation[1], parentNode.translation[2]) : Vector3.Zero();\n                            let parentNodeLocalRotation = parentNode.rotation ? new Quaternion(parentNode.rotation[0], parentNode.rotation[1], parentNode.rotation[2], parentNode.rotation[3]) : Quaternion.Identity();\n                            let parentNodeLocalScale = parentNode.scale ? new Vector3(parentNode.scale[0], parentNode.scale[1], parentNode.scale[2]) : Vector3.One();\n\n                            Matrix.ComposeToRef(parentNodeLocalScale, parentNodeLocalRotation, parentNodeLocalTranslation, parentNodeLocalMatrix);\n                            parentNodeLocalMatrix.invertToRef(parentInvertNodeLocalMatrix);\n\n                            // Convert light local matrix to local matrix relative to grandparent, facing -Z\n                            let lightLocalMatrix = TmpVectors.Matrix[2];\n                            let nodeLocalTranslation = node.translation ? new Vector3(node.translation[0], node.translation[1], node.translation[2]) : Vector3.Zero();\n\n                            // Undo directional light positional offset\n                            if (babylonLight instanceof DirectionalLight) {\n                                nodeLocalTranslation.subtractInPlace(this._exporter._babylonScene.useRightHandedSystem ? babylonLight.direction : _GLTFUtilities._GetRightHandedPositionVector3(babylonLight.direction));\n                            }\n                            let nodeLocalRotation = this._exporter._babylonScene.useRightHandedSystem ? Quaternion.Identity() : new Quaternion(0, 1, 0, 0);\n                            if (node.rotation) {\n                                nodeLocalRotation.multiplyInPlace(new Quaternion(node.rotation[0], node.rotation[1], node.rotation[2], node.rotation[3]));\n                            }\n                            let nodeLocalScale = node.scale ? new Vector3(node.scale[0], node.scale[1], node.scale[2]) : Vector3.One();\n\n                            Matrix.ComposeToRef(nodeLocalScale, nodeLocalRotation, nodeLocalTranslation, lightLocalMatrix);\n                            lightLocalMatrix.multiplyToRef(parentInvertNodeLocalMatrix, lightLocalMatrix);\n                            let parentNewScale = TmpVectors.Vector3[0];\n                            let parentNewRotationQuaternion = TmpVectors.Quaternion[0];\n                            let parentNewTranslation = TmpVectors.Vector3[1];\n\n                            lightLocalMatrix.decompose(parentNewScale, parentNewRotationQuaternion, parentNewTranslation);\n                            parentNode.scale = parentNewScale.asArray();\n                            parentNode.rotation = parentNewRotationQuaternion.asArray();\n                            parentNode.translation = parentNewTranslation.asArray();\n\n                            if (parentNode.extensions == null) {\n                                parentNode.extensions = {};\n                            }\n                            parentNode.extensions[NAME] = lightReference;\n\n                            // Do not export the original node\n                            resolve(undefined);\n                            return;\n                        }\n                    }\n\n                    if (node.extensions == null) {\n                        node.extensions = {};\n                    }\n\n                    node.extensions[NAME] = lightReference;\n                }\n            }\n            resolve(node);\n        });\n    }\n}\n\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_lights_punctual(exporter));","import { ITextureInfo, IMaterial } from \"babylonjs-gltf2interface\";\r\nimport { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\nimport { Material } from 'babylonjs/Materials/material';\r\nimport { PBRMaterial } from 'babylonjs/Materials/PBR/pbrMaterial';\r\nimport { Texture } from 'babylonjs/Materials/Textures/texture';\r\nimport { BaseTexture } from 'babylonjs/Materials/Textures/baseTexture';\r\nimport { Nullable } from 'babylonjs/types';\r\n\r\nconst NAME = \"KHR_materials_sheen\";\r\n\r\ninterface IKHR_materials_sheen {\r\n    intensityFactor: number;\r\n    colorFactor: number[];\r\n    colorIntensityTexture?: ITextureInfo;\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class KHR_materials_sheen implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /** Reference to the glTF exporter */\r\n    private _textureInfos: ITextureInfo[] = [];\r\n    private _exportedTextures: Nullable<BaseTexture>[] = [];\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: _Exporter) {\r\n    }\r\n\r\n    public dispose() {\r\n       this._textureInfos = [];\r\n       this._exportedTextures = [];\r\n    }\r\n\r\n    /** @hidden */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    private _getTextureIndex(babylonTexture: BaseTexture) {\r\n        let textureIndex = this._exportedTextures.indexOf(babylonTexture);\r\n\r\n        if (textureIndex === -1 && babylonTexture.reservedDataStore) {\r\n            textureIndex = this._exportedTextures.indexOf(babylonTexture.reservedDataStore.source);\r\n        }\r\n\r\n        return textureIndex;\r\n    }\r\n\r\n    public postExportTexture?(context: string, textureInfo: ITextureInfo, babylonTexture: Texture): void {\r\n        let textureIndex = this._getTextureIndex(babylonTexture);\r\n\r\n        if (textureIndex > -1) {\r\n            this._textureInfos[textureIndex] = textureInfo;\r\n        }\r\n    }\r\n\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        if (babylonMaterial instanceof PBRMaterial) {\r\n            if (babylonMaterial.sheen.isEnabled && babylonMaterial.sheen.texture) {\r\n                this._exportedTextures.push(babylonMaterial.sheen.texture);\r\n                return [babylonMaterial.sheen.texture];\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            if (babylonMaterial instanceof PBRMaterial) {\r\n                if (!babylonMaterial.sheen.isEnabled) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                if (node.extensions == null) {\r\n                    node.extensions = {};\r\n                }\r\n                const sheenInfo: IKHR_materials_sheen = {\r\n                    colorFactor: babylonMaterial.sheen.color.asArray(),\r\n                    intensityFactor: babylonMaterial.sheen.intensity\r\n                };\r\n\r\n                if (babylonMaterial.sheen.texture) {\r\n                    let textureIndex = this._getTextureIndex(babylonMaterial.sheen.texture);\r\n\r\n                    if (textureIndex > -1) {\r\n                        sheenInfo.colorIntensityTexture = this._textureInfos[textureIndex] ;\r\n                    }\r\n                }\r\n\r\n                node.extensions[NAME] = sheenInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_materials_sheen(exporter));","import { IMaterial } from \"babylonjs-gltf2interface\";\r\nimport { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\nimport { Material } from 'babylonjs/Materials/material';\r\nimport { PBRMaterial } from 'babylonjs/Materials/PBR/pbrMaterial';\r\nimport { StandardMaterial } from 'babylonjs/Materials/standardMaterial';\r\n\r\nconst NAME = \"KHR_materials_unlit\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class KHR_materials_unlit implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: _Exporter) {\r\n    }\r\n\r\n    /** @hidden */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public dispose() {\r\n    }\r\n\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            let unlitMaterial = false;\r\n\r\n            if (babylonMaterial instanceof PBRMaterial) {\r\n                unlitMaterial = babylonMaterial.unlit;\r\n            } else if (babylonMaterial instanceof StandardMaterial) {\r\n                unlitMaterial = babylonMaterial.disableLighting;\r\n            }\r\n\r\n            if (unlitMaterial) {\r\n                this._wasUsed = true;\r\n\r\n                if (node.extensions == null) {\r\n                    node.extensions = {};\r\n                }\r\n\r\n                node.extensions[NAME] = {};\r\n            }\r\n\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_materials_unlit(exporter));","import { ImageMimeType, ITextureInfo } from \"babylonjs-gltf2interface\";\r\nimport { Tools } from \"babylonjs/Misc/tools\";\r\nimport { Texture } from \"babylonjs/Materials/Textures/texture\";\r\nimport { ProceduralTexture } from \"babylonjs/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport { Scene } from \"babylonjs/scene\";\r\n\r\nimport { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\n\r\nconst NAME = \"KHR_texture_transform\";\r\n\r\nimport \"../shaders/textureTransform.fragment\";\r\n\r\n/**\r\n * Interface for handling KHR texture transform\r\n * @hidden\r\n */\r\ninterface IKHRTextureTransform {\r\n    offset?: number[];\r\n    rotation?: number;\r\n    scale?: number[];\r\n    texCoord?: number;\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class KHR_texture_transform implements IGLTFExporterExtensionV2 {\r\n    private _recordedTextures: ProceduralTexture[] = [];\r\n\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /** Reference to the glTF exporter */\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: _Exporter) {\r\n    }\r\n\r\n    public dispose() {\r\n        for (var texture of this._recordedTextures) {\r\n            texture.dispose();\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportTexture?(context: string, textureInfo: ITextureInfo, babylonTexture: Texture): void {\r\n        if (babylonTexture && babylonTexture.uRotationCenter === 0 && babylonTexture.vRotationCenter === 0) {\r\n            let textureTransform: IKHRTextureTransform = {};\r\n            let transformIsRequired = false;\r\n\r\n            if (babylonTexture.uOffset !== 0 || babylonTexture.vOffset !== 0) {\r\n                textureTransform.offset = [babylonTexture.uOffset, babylonTexture.vOffset];\r\n                transformIsRequired = true;\r\n            }\r\n\r\n            if (babylonTexture.uScale !== 1 || babylonTexture.vScale !== 1) {\r\n                textureTransform.scale = [babylonTexture.uScale, babylonTexture.vScale];\r\n                transformIsRequired = true;\r\n            }\r\n\r\n            if (babylonTexture.wAng !== 0) {\r\n                textureTransform.rotation = babylonTexture.wAng;\r\n                transformIsRequired = true;\r\n            }\r\n\r\n            if (babylonTexture.coordinatesIndex !== 0) {\r\n                textureTransform.texCoord = babylonTexture.coordinatesIndex;\r\n                transformIsRequired = true;\r\n            }\r\n\r\n            if (!transformIsRequired) {\r\n                return;\r\n            }\r\n\r\n            this._wasUsed = true;\r\n            if (!textureInfo.extensions) {\r\n                textureInfo.extensions = {};\r\n            }\r\n            textureInfo.extensions[NAME] = textureTransform;\r\n        }\r\n    }\r\n\r\n    public preExportTextureAsync(context: string, babylonTexture: Texture, mimeType: ImageMimeType): Promise<Texture> {\r\n        return new Promise((resolve, reject) => {\r\n            const scene = babylonTexture.getScene();\r\n            if (!scene) {\r\n                reject(`${context}: \"scene\" is not defined for Babylon texture ${babylonTexture.name}!`);\r\n                return;\r\n            }\r\n\r\n            let bakeTextureTransform = false;\r\n\r\n            /*\r\n            * The KHR_texture_transform schema only supports rotation around the origin.\r\n            * the texture must be baked to preserve appearance.\r\n            * see: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform#gltf-schema-updates\r\n            */\r\n            if ((babylonTexture.uAng !== 0 || babylonTexture.wAng !== 0 || babylonTexture.vAng !== 0) && (babylonTexture.uRotationCenter !== 0 || babylonTexture.vRotationCenter !== 0)) {\r\n                bakeTextureTransform = true;\r\n            }\r\n\r\n            if (!bakeTextureTransform) {\r\n                resolve(babylonTexture);\r\n                return;\r\n            }\r\n\r\n            return this._textureTransformTextureAsync(babylonTexture, scene)\r\n                .then((proceduralTexture) => {\r\n                    resolve(proceduralTexture);\r\n                })\r\n                .catch((e) => {\r\n                    reject(e);\r\n                });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Transform the babylon texture by the offset, rotation and scale parameters using a procedural texture\r\n     * @param babylonTexture\r\n     * @param offset\r\n     * @param rotation\r\n     * @param scale\r\n     * @param scene\r\n     */\r\n    private _textureTransformTextureAsync(babylonTexture: Texture, scene: Scene): Promise<Texture> {\r\n        return new Promise((resolve) => {\r\n            const proceduralTexture = new ProceduralTexture(`${babylonTexture.name}`, babylonTexture.getSize(), \"textureTransform\", scene);\r\n            if (!proceduralTexture) {\r\n                Tools.Log(`Cannot create procedural texture for ${babylonTexture.name}!`);\r\n                resolve(babylonTexture);\r\n            }\r\n\r\n            proceduralTexture.reservedDataStore = {\r\n                hidden: true,\r\n                source: babylonTexture\r\n            };\r\n\r\n            this._recordedTextures.push(proceduralTexture);\r\n\r\n            proceduralTexture.coordinatesIndex = babylonTexture.coordinatesIndex;\r\n            proceduralTexture.setTexture(\"textureSampler\", babylonTexture);\r\n            proceduralTexture.setMatrix(\"textureTransformMat\", babylonTexture.getTextureMatrix());\r\n\r\n            // isReady trigger creation of effect if it doesnt exist yet\r\n            if (proceduralTexture.isReady()) {\r\n                proceduralTexture.render();\r\n                resolve(proceduralTexture);\r\n            } else {\r\n                proceduralTexture.getEffect().executeWhenCompiled(() => {\r\n                    proceduralTexture.render();\r\n                    resolve(proceduralTexture);\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_texture_transform(exporter));","export * from \"./KHR_texture_transform\";\r\nexport * from \"./KHR_lights_punctual\";\r\nexport * from \"./KHR_materials_sheen\";\r\nexport * from \"./KHR_materials_unlit\";","import { AnimationSamplerInterpolation, AnimationChannelTargetPath, AccessorType, IAnimation, INode, IBufferView, IAccessor, IAnimationSampler, IAnimationChannel, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\nimport { Node } from \"babylonjs/node\";\r\nimport { Nullable } from \"babylonjs/types\";\r\nimport { Vector3, Quaternion } from \"babylonjs/Maths/math.vector\";\r\nimport { Tools } from \"babylonjs/Misc/tools\";\r\nimport { Animation } from \"babylonjs/Animations/animation\";\r\nimport { TransformNode } from \"babylonjs/Meshes/transformNode\";\r\nimport { Scene } from \"babylonjs/scene\";\r\n\r\nimport { _BinaryWriter } from \"./glTFExporter\";\r\nimport { _GLTFUtilities } from \"./glTFUtilities\";\r\nimport { IAnimationKey, AnimationKeyInterpolation } from 'babylonjs/Animations/animationKey';\r\n\r\n/**\r\n * @hidden\r\n * Interface to store animation data.\r\n */\r\nexport interface _IAnimationData {\r\n    /**\r\n     * Keyframe data.\r\n     */\r\n    inputs: number[];\r\n    /**\r\n     * Value data.\r\n     */\r\n    outputs: number[][];\r\n    /**\r\n     * Animation interpolation data.\r\n     */\r\n    samplerInterpolation: AnimationSamplerInterpolation;\r\n    /**\r\n     * Minimum keyframe value.\r\n     */\r\n    inputsMin: number;\r\n    /**\r\n     * Maximum keyframe value.\r\n     */\r\n    inputsMax: number;\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport interface _IAnimationInfo {\r\n    /**\r\n     * The target channel for the animation\r\n     */\r\n    animationChannelTargetPath: AnimationChannelTargetPath;\r\n    /**\r\n     * The glTF accessor type for the data.\r\n     */\r\n    dataAccessorType: AccessorType.VEC3 | AccessorType.VEC4;\r\n    /**\r\n     * Specifies if quaternions should be used.\r\n     */\r\n    useQuaternion: boolean;\r\n}\r\n\r\n/**\r\n * @hidden\r\n * Enum for handling in tangent and out tangent.\r\n */\r\nenum _TangentType {\r\n    /**\r\n     * Specifies that input tangents are used.\r\n     */\r\n    INTANGENT,\r\n    /**\r\n     * Specifies that output tangents are used.\r\n     */\r\n    OUTTANGENT\r\n}\r\n/**\r\n * @hidden\r\n * Utility class for generating glTF animation data from BabylonJS.\r\n */\r\nexport class _GLTFAnimation {\r\n    /**\r\n     * @ignore\r\n     *\r\n     * Creates glTF channel animation from BabylonJS animation.\r\n     * @param babylonTransformNode - BabylonJS mesh.\r\n     * @param animation - animation.\r\n     * @param animationChannelTargetPath - The target animation channel.\r\n     * @param convertToRightHandedSystem - Specifies if the values should be converted to right-handed.\r\n     * @param useQuaternion - Specifies if quaternions are used.\r\n     * @returns nullable IAnimationData\r\n     */\r\n    public static _CreateNodeAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, convertToRightHandedSystem: boolean, useQuaternion: boolean, animationSampleRate: number): Nullable<_IAnimationData> {\r\n        const inputs: number[] = [];\r\n        const outputs: number[][] = [];\r\n        const keyFrames = animation.getKeys();\r\n        const minMaxKeyFrames = _GLTFAnimation.calculateMinMaxKeyFrames(keyFrames);\r\n        const interpolationOrBake = _GLTFAnimation._DeduceInterpolation(keyFrames, animationChannelTargetPath, useQuaternion);\r\n        const frameDelta = minMaxKeyFrames.max - minMaxKeyFrames.min;\r\n\r\n        const interpolation = interpolationOrBake.interpolationType;\r\n        const shouldBakeAnimation = interpolationOrBake.shouldBakeAnimation;\r\n\r\n        if (shouldBakeAnimation) {\r\n            _GLTFAnimation._CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minMaxKeyFrames.min, minMaxKeyFrames.max, animation.framePerSecond, animationSampleRate, inputs, outputs, minMaxKeyFrames, convertToRightHandedSystem, useQuaternion);\r\n        }\r\n        else {\r\n            if (interpolation === AnimationSamplerInterpolation.LINEAR || interpolation === AnimationSamplerInterpolation.STEP) {\r\n                _GLTFAnimation._CreateLinearOrStepAnimation(babylonTransformNode, animation, animationChannelTargetPath, frameDelta, inputs, outputs, convertToRightHandedSystem, useQuaternion);\r\n\r\n            }\r\n            else if (interpolation === AnimationSamplerInterpolation.CUBICSPLINE) {\r\n                _GLTFAnimation._CreateCubicSplineAnimation(babylonTransformNode, animation, animationChannelTargetPath, frameDelta, inputs, outputs, convertToRightHandedSystem, useQuaternion);\r\n            }\r\n            else {\r\n                _GLTFAnimation._CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minMaxKeyFrames.min, minMaxKeyFrames.max, animation.framePerSecond, animationSampleRate, inputs, outputs, minMaxKeyFrames, convertToRightHandedSystem, useQuaternion);\r\n            }\r\n        }\r\n\r\n        if (inputs.length && outputs.length) {\r\n            const result: _IAnimationData = {\r\n                inputs: inputs,\r\n                outputs: outputs,\r\n                samplerInterpolation: interpolation,\r\n                inputsMin: shouldBakeAnimation ? minMaxKeyFrames.min : Tools.FloatRound(minMaxKeyFrames.min / animation.framePerSecond),\r\n                inputsMax: shouldBakeAnimation ? minMaxKeyFrames.max : Tools.FloatRound(minMaxKeyFrames.max / animation.framePerSecond)\r\n            };\r\n\r\n            return result;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private static _DeduceAnimationInfo(animation: Animation): Nullable<_IAnimationInfo> {\r\n        let animationChannelTargetPath: Nullable<AnimationChannelTargetPath> = null;\r\n        let dataAccessorType = AccessorType.VEC3;\r\n        let useQuaternion: boolean = false;\r\n        let property = animation.targetProperty.split('.');\r\n        switch (property[0]) {\r\n            case 'scaling': {\r\n                animationChannelTargetPath = AnimationChannelTargetPath.SCALE;\r\n                break;\r\n            }\r\n            case 'position': {\r\n                animationChannelTargetPath = AnimationChannelTargetPath.TRANSLATION;\r\n                break;\r\n            }\r\n            case 'rotation': {\r\n                dataAccessorType = AccessorType.VEC4;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.ROTATION;\r\n                break;\r\n            }\r\n            case 'rotationQuaternion': {\r\n                dataAccessorType = AccessorType.VEC4;\r\n                useQuaternion = true;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.ROTATION;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported animatable property ${property[0]}`);\r\n            }\r\n        }\r\n        if (animationChannelTargetPath) {\r\n            return { animationChannelTargetPath: animationChannelTargetPath, dataAccessorType: dataAccessorType, useQuaternion: useQuaternion };\r\n        }\r\n        else {\r\n            Tools.Error('animation channel target path and data accessor type could be deduced');\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create node animations from the transform node animations\r\n     * @param babylonNode\r\n     * @param runtimeGLTFAnimation\r\n     * @param idleGLTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param binaryWriter\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param convertToRightHandedSystem\r\n     * @param animationSampleRate\r\n     */\r\n    public static _CreateNodeAnimationFromNodeAnimations(babylonNode: Node, runtimeGLTFAnimation: IAnimation, idleGLTFAnimations: IAnimation[], nodeMap: { [key: number]: number }, nodes: INode[], binaryWriter: _BinaryWriter, bufferViews: IBufferView[], accessors: IAccessor[], convertToRightHandedSystem: boolean, animationSampleRate: number) {\r\n        let glTFAnimation: IAnimation;\r\n        if (babylonNode instanceof TransformNode) {\r\n            if (babylonNode.animations) {\r\n                for (let animation of babylonNode.animations) {\r\n                    let animationInfo = _GLTFAnimation._DeduceAnimationInfo(animation);\r\n                    if (animationInfo) {\r\n                        glTFAnimation = {\r\n                            name: animation.name,\r\n                            samplers: [],\r\n                            channels: []\r\n                        };\r\n                        _GLTFAnimation.AddAnimation(`${animation.name}`,\r\n                            animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation,\r\n                            babylonNode,\r\n                            animation,\r\n                            animationInfo.dataAccessorType,\r\n                            animationInfo.animationChannelTargetPath,\r\n                            nodeMap,\r\n                            binaryWriter,\r\n                            bufferViews,\r\n                            accessors,\r\n                            convertToRightHandedSystem,\r\n                            animationInfo.useQuaternion,\r\n                            animationSampleRate\r\n                        );\r\n                        if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {\r\n                            idleGLTFAnimations.push(glTFAnimation);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create node animations from the animation groups\r\n     * @param babylonScene\r\n     * @param glTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param binaryWriter\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param convertToRightHandedSystemMap\r\n     * @param animationSampleRate\r\n     */\r\n    public static _CreateNodeAnimationFromAnimationGroups(babylonScene: Scene, glTFAnimations: IAnimation[], nodeMap: { [key: number]: number }, nodes: INode[], binaryWriter: _BinaryWriter, bufferViews: IBufferView[], accessors: IAccessor[], convertToRightHandedSystemMap: { [nodeId: number]: boolean }, animationSampleRate: number) {\r\n        let glTFAnimation: IAnimation;\r\n        if (babylonScene.animationGroups) {\r\n            let animationGroups = babylonScene.animationGroups;\r\n\r\n            for (let animationGroup of animationGroups) {\r\n                glTFAnimation = {\r\n                    name: animationGroup.name,\r\n                    channels: [],\r\n                    samplers: []\r\n                };\r\n                for (let targetAnimation of animationGroup.targetedAnimations) {\r\n                    let target = targetAnimation.target;\r\n                    let animation = targetAnimation.animation;\r\n                    if (target instanceof TransformNode || target.length === 1 && target[0] instanceof TransformNode) {\r\n                        let animationInfo = _GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);\r\n                        if (animationInfo) {\r\n                            let babylonTransformNode = target instanceof TransformNode ? target as TransformNode : target[0] as TransformNode;\r\n                            let convertToRightHandedSystem = convertToRightHandedSystemMap[babylonTransformNode.uniqueId];\r\n                            _GLTFAnimation.AddAnimation(`${animation.name}`,\r\n                                glTFAnimation,\r\n                                babylonTransformNode,\r\n                                animation,\r\n                                animationInfo.dataAccessorType,\r\n                                animationInfo.animationChannelTargetPath,\r\n                                nodeMap,\r\n                                binaryWriter,\r\n                                bufferViews,\r\n                                accessors,\r\n                                convertToRightHandedSystem,\r\n                                animationInfo.useQuaternion,\r\n                                animationSampleRate\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n                if (glTFAnimation.channels.length && glTFAnimation.samplers.length) {\r\n                    glTFAnimations.push(glTFAnimation);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static AddAnimation(name: string, glTFAnimation: IAnimation, babylonTransformNode: TransformNode, animation: Animation, dataAccessorType: AccessorType, animationChannelTargetPath: AnimationChannelTargetPath, nodeMap: { [key: number]: number }, binaryWriter: _BinaryWriter, bufferViews: IBufferView[], accessors: IAccessor[], convertToRightHandedSystem: boolean, useQuaternion: boolean, animationSampleRate: number) {\r\n        let animationData = _GLTFAnimation._CreateNodeAnimation(babylonTransformNode, animation, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion, animationSampleRate);\r\n        let bufferView: IBufferView;\r\n        let accessor: IAccessor;\r\n        let keyframeAccessorIndex: number;\r\n        let dataAccessorIndex: number;\r\n        let outputLength: number;\r\n        let animationSampler: IAnimationSampler;\r\n        let animationChannel: IAnimationChannel;\r\n\r\n        if (animationData) {\r\n            let nodeIndex = nodeMap[babylonTransformNode.uniqueId];\r\n\r\n            // Creates buffer view and accessor for key frames.\r\n            let byteLength = animationData.inputs.length * 4;\r\n            bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, `${name}  keyframe data view`);\r\n            bufferViews.push(bufferView);\r\n            animationData.inputs.forEach(function(input) {\r\n                binaryWriter.setFloat32(input);\r\n            });\r\n\r\n            accessor = _GLTFUtilities._CreateAccessor(bufferViews.length - 1, `${name}  keyframes`, AccessorType.SCALAR, AccessorComponentType.FLOAT, animationData.inputs.length, null, [animationData.inputsMin], [animationData.inputsMax]);\r\n            accessors.push(accessor);\r\n            keyframeAccessorIndex = accessors.length - 1;\r\n\r\n            // create bufferview and accessor for keyed values.\r\n            outputLength = animationData.outputs.length;\r\n            byteLength = dataAccessorType === AccessorType.VEC3 ? animationData.outputs.length * 12 : animationData.outputs.length * 16;\r\n\r\n            // check for in and out tangents\r\n            bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, `${name}  data view`);\r\n            bufferViews.push(bufferView);\r\n\r\n            animationData.outputs.forEach(function(output) {\r\n                output.forEach(function(entry) {\r\n                    binaryWriter.setFloat32(entry);\r\n                });\r\n            });\r\n\r\n            accessor = _GLTFUtilities._CreateAccessor(bufferViews.length - 1, `${name}  data`, dataAccessorType, AccessorComponentType.FLOAT, outputLength, null, null, null);\r\n            accessors.push(accessor);\r\n            dataAccessorIndex = accessors.length - 1;\r\n\r\n            // create sampler\r\n            animationSampler = {\r\n                interpolation: animationData.samplerInterpolation,\r\n                input: keyframeAccessorIndex,\r\n                output: dataAccessorIndex\r\n            };\r\n            glTFAnimation.samplers.push(animationSampler);\r\n\r\n            // create channel\r\n            animationChannel = {\r\n                sampler: glTFAnimation.samplers.length - 1,\r\n                target: {\r\n                    node: nodeIndex,\r\n                    path: animationChannelTargetPath\r\n                }\r\n            };\r\n            glTFAnimation.channels.push(animationChannel);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a baked animation\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation corresponding to the BabylonJS mesh\r\n     * @param animationChannelTargetPath animation target channel\r\n     * @param minFrame minimum animation frame\r\n     * @param maxFrame maximum animation frame\r\n     * @param fps frames per second of the animation\r\n     * @param inputs input key frames of the animation\r\n     * @param outputs output key frame data of the animation\r\n     * @param convertToRightHandedSystem converts the values to right-handed\r\n     * @param useQuaternion specifies if quaternions should be used\r\n     */\r\n    private static _CreateBakedAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, minFrame: number, maxFrame: number, fps: number, sampleRate: number, inputs: number[], outputs: number[][], minMaxFrames: { min: number, max: number }, convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        let value: number | Vector3 | Quaternion;\r\n        let quaternionCache: Quaternion = Quaternion.Identity();\r\n        let previousTime: Nullable<number> = null;\r\n        let time: number;\r\n        let maxUsedFrame: Nullable<number> = null;\r\n        let currKeyFrame: Nullable<IAnimationKey> = null;\r\n        let nextKeyFrame: Nullable<IAnimationKey> = null;\r\n        let prevKeyFrame: Nullable<IAnimationKey> = null;\r\n        let endFrame: Nullable<number> = null;\r\n        minMaxFrames.min = Tools.FloatRound(minFrame / fps);\r\n\r\n        let keyFrames = animation.getKeys();\r\n\r\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\r\n            endFrame = null;\r\n            currKeyFrame = keyFrames[i];\r\n\r\n            if (i + 1 < length) {\r\n                nextKeyFrame = keyFrames[i + 1];\r\n                if (currKeyFrame.value.equals && currKeyFrame.value.equals(nextKeyFrame.value) || currKeyFrame.value === nextKeyFrame.value) {\r\n                    if (i === 0) { // set the first frame to itself\r\n                        endFrame = currKeyFrame.frame;\r\n                    }\r\n                    else {\r\n                        continue;\r\n                    }\r\n                }\r\n                else {\r\n                    endFrame = nextKeyFrame.frame;\r\n                }\r\n            }\r\n            else {\r\n                // at the last key frame\r\n                prevKeyFrame = keyFrames[i - 1];\r\n                if (currKeyFrame.value.equals && currKeyFrame.value.equals(prevKeyFrame.value) || currKeyFrame.value === prevKeyFrame.value) {\r\n                    continue;\r\n                }\r\n                else {\r\n                    endFrame = maxFrame;\r\n                }\r\n            }\r\n            if (endFrame) {\r\n                for (let f = currKeyFrame.frame; f <= endFrame; f += sampleRate) {\r\n                    time = Tools.FloatRound(f / fps);\r\n                    if (time === previousTime) {\r\n                        continue;\r\n                    }\r\n                    previousTime = time;\r\n                    maxUsedFrame = time;\r\n                    let state = {\r\n                        key: 0,\r\n                        repeatCount: 0,\r\n                        loopMode: animation.loopMode\r\n                    };\r\n                    value = animation._interpolate(f, state);\r\n\r\n                    _GLTFAnimation._SetInterpolatedValue(babylonTransformNode, value, time, animation, animationChannelTargetPath, quaternionCache, inputs, outputs, convertToRightHandedSystem, useQuaternion);\r\n                }\r\n            }\r\n        }\r\n        if (maxUsedFrame) {\r\n            minMaxFrames.max = maxUsedFrame;\r\n        }\r\n    }\r\n\r\n    private static _ConvertFactorToVector3OrQuaternion(factor: number, babylonTransformNode: TransformNode, animation: Animation, animationType: number, animationChannelTargetPath: AnimationChannelTargetPath, convertToRightHandedSystem: boolean, useQuaternion: boolean): Nullable<Vector3 | Quaternion> {\r\n        let property: string[];\r\n        let componentName: string;\r\n        let value: Nullable<Quaternion | Vector3> = null;\r\n        const basePositionRotationOrScale = _GLTFAnimation._GetBasePositionRotationOrScale(babylonTransformNode, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);\r\n        if (animationType === Animation.ANIMATIONTYPE_FLOAT) { // handles single component x, y, z or w component animation by using a base property and animating over a component.\r\n            property = animation.targetProperty.split('.');\r\n            componentName = property ? property[1] : ''; // x, y, or z component\r\n            value = useQuaternion ? Quaternion.FromArray(basePositionRotationOrScale).normalize() : Vector3.FromArray(basePositionRotationOrScale);\r\n\r\n            switch (componentName) {\r\n                case 'x': {\r\n                    value[componentName] = (convertToRightHandedSystem && useQuaternion && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) ? -factor : factor;\r\n                    break;\r\n                }\r\n                case 'y': {\r\n                    value[componentName] = (convertToRightHandedSystem && useQuaternion && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) ? -factor : factor;\r\n                    break;\r\n                }\r\n                case 'z': {\r\n                    value[componentName] = (convertToRightHandedSystem && !useQuaternion && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) ? -factor : factor;\r\n                    break;\r\n                }\r\n                case 'w': {\r\n                    (value as Quaternion).w = factor;\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`glTFAnimation: Unsupported component type \"${componentName}\" for scale animation!`);\r\n                }\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    private static _SetInterpolatedValue(babylonTransformNode: TransformNode, value: Nullable<number | Vector3 | Quaternion>, time: number, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, quaternionCache: Quaternion, inputs: number[], outputs: number[][], convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        const animationType = animation.dataType;\r\n        let cacheValue: Vector3 | Quaternion;\r\n        inputs.push(time);\r\n        if (typeof value === \"number\") {\r\n            value = this._ConvertFactorToVector3OrQuaternion(value as number, babylonTransformNode, animation, animationType, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);\r\n        }\r\n        if (value) {\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                if (useQuaternion) {\r\n                    quaternionCache = value as Quaternion;\r\n                }\r\n                else {\r\n                    cacheValue = value as Vector3;\r\n                    Quaternion.RotationYawPitchRollToRef(cacheValue.y, cacheValue.x, cacheValue.z, quaternionCache);\r\n                }\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedQuaternionFromRef(quaternionCache);\r\n\r\n                    if (!babylonTransformNode.parent) {\r\n                        quaternionCache = Quaternion.FromArray([0, 1, 0, 0]).multiply(quaternionCache);\r\n                    }\r\n                }\r\n                outputs.push(quaternionCache.asArray());\r\n            }\r\n            else {\r\n                cacheValue = value as Vector3;\r\n                if (convertToRightHandedSystem && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) {\r\n                    _GLTFUtilities._GetRightHandedPositionVector3FromRef(cacheValue);\r\n                    if (!babylonTransformNode.parent) {\r\n                        cacheValue.x *= -1;\r\n                        cacheValue.z *= -1;\r\n                    }\r\n                }\r\n\r\n                outputs.push(cacheValue.asArray());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates linear animation from the animation key frames\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param frameDelta The difference between the last and first frame of the animation\r\n     * @param inputs Array to store the key frame times\r\n     * @param outputs Array to store the key frame data\r\n     * @param convertToRightHandedSystem Specifies if the position data should be converted to right handed\r\n     * @param useQuaternion Specifies if quaternions are used in the animation\r\n     */\r\n    private static _CreateLinearOrStepAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, frameDelta: number, inputs: number[], outputs: number[][], convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        for (let keyFrame of animation.getKeys()) {\r\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\r\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, convertToRightHandedSystem, useQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates cubic spline animation from the animation key frames\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param frameDelta The difference between the last and first frame of the animation\r\n     * @param inputs Array to store the key frame times\r\n     * @param outputs Array to store the key frame data\r\n     * @param convertToRightHandedSystem Specifies if the position data should be converted to right handed\r\n     * @param useQuaternion Specifies if quaternions are used in the animation\r\n     */\r\n    private static _CreateCubicSplineAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, frameDelta: number, inputs: number[], outputs: number[][], convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        animation.getKeys().forEach(function(keyFrame) {\r\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\r\n            _GLTFAnimation.AddSplineTangent(\r\n                babylonTransformNode,\r\n                _TangentType.INTANGENT,\r\n                outputs,\r\n                animationChannelTargetPath,\r\n                AnimationSamplerInterpolation.CUBICSPLINE,\r\n                keyFrame,\r\n                frameDelta,\r\n                useQuaternion,\r\n                convertToRightHandedSystem\r\n            );\r\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, convertToRightHandedSystem, useQuaternion);\r\n\r\n            _GLTFAnimation.AddSplineTangent(\r\n                babylonTransformNode,\r\n                _TangentType.OUTTANGENT,\r\n                outputs,\r\n                animationChannelTargetPath,\r\n                AnimationSamplerInterpolation.CUBICSPLINE,\r\n                keyFrame,\r\n                frameDelta,\r\n                useQuaternion,\r\n                convertToRightHandedSystem\r\n            );\r\n        });\r\n    }\r\n\r\n    private static _GetBasePositionRotationOrScale(babylonTransformNode: TransformNode, animationChannelTargetPath: AnimationChannelTargetPath, convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        let basePositionRotationOrScale: number[];\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n            if (useQuaternion) {\r\n                if (babylonTransformNode.rotationQuaternion) {\r\n                    basePositionRotationOrScale = babylonTransformNode.rotationQuaternion.asArray();\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedQuaternionArrayFromRef(basePositionRotationOrScale);\r\n                        if (!babylonTransformNode.parent) {\r\n                            basePositionRotationOrScale = Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(basePositionRotationOrScale)).asArray();\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    basePositionRotationOrScale = Quaternion.Identity().asArray();\r\n                }\r\n            }\r\n            else {\r\n                basePositionRotationOrScale = babylonTransformNode.rotation.asArray();\r\n                _GLTFUtilities._GetRightHandedNormalArray3FromRef(basePositionRotationOrScale);\r\n            }\r\n        }\r\n        else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n            basePositionRotationOrScale = babylonTransformNode.position.asArray();\r\n            if (convertToRightHandedSystem) {\r\n                _GLTFUtilities._GetRightHandedPositionArray3FromRef(basePositionRotationOrScale);\r\n            }\r\n        }\r\n        else { // scale\r\n            basePositionRotationOrScale = babylonTransformNode.scaling.asArray();\r\n        }\r\n        return basePositionRotationOrScale;\r\n    }\r\n\r\n    /**\r\n     * Adds a key frame value\r\n     * @param keyFrame\r\n     * @param animation\r\n     * @param outputs\r\n     * @param animationChannelTargetPath\r\n     * @param basePositionRotationOrScale\r\n     * @param convertToRightHandedSystem\r\n     * @param useQuaternion\r\n     */\r\n    private static _AddKeyframeValue(keyFrame: IAnimationKey, animation: Animation, outputs: number[][], animationChannelTargetPath: AnimationChannelTargetPath, babylonTransformNode: TransformNode, convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        let value: number[];\r\n        let newPositionRotationOrScale: Nullable<Vector3 | Quaternion>;\r\n        const animationType = animation.dataType;\r\n        if (animationType === Animation.ANIMATIONTYPE_VECTOR3) {\r\n            value = keyFrame.value.asArray();\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                const array = Vector3.FromArray(value);\r\n                let rotationQuaternion = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z);\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedQuaternionFromRef(rotationQuaternion);\r\n\r\n                    if (!babylonTransformNode.parent) {\r\n                        rotationQuaternion = Quaternion.FromArray([0, 1, 0, 0]).multiply(rotationQuaternion);\r\n                    }\r\n                }\r\n                value = rotationQuaternion.asArray();\r\n            }\r\n            else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedNormalArray3FromRef(value);\r\n                    if (!babylonTransformNode.parent) {\r\n                        value[0] *= -1;\r\n                        value[2] *= -1;\r\n                    }\r\n                }\r\n            }\r\n            outputs.push(value); // scale  vector.\r\n\r\n        }\r\n        else if (animationType === Animation.ANIMATIONTYPE_FLOAT) { // handles single component x, y, z or w component animation by using a base property and animating over a component.\r\n            newPositionRotationOrScale = this._ConvertFactorToVector3OrQuaternion(keyFrame.value as number, babylonTransformNode, animation, animationType, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);\r\n            if (newPositionRotationOrScale) {\r\n                if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                    let posRotScale = useQuaternion ? newPositionRotationOrScale as Quaternion : Quaternion.RotationYawPitchRoll(newPositionRotationOrScale.y, newPositionRotationOrScale.x, newPositionRotationOrScale.z).normalize();\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedQuaternionFromRef(posRotScale);\r\n\r\n                        if (!babylonTransformNode.parent) {\r\n                            posRotScale = Quaternion.FromArray([0, 1, 0, 0]).multiply(posRotScale);\r\n                        }\r\n                    }\r\n                    outputs.push(posRotScale.asArray());\r\n                }\r\n                else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(newPositionRotationOrScale as Vector3);\r\n\r\n                        if (!babylonTransformNode.parent) {\r\n                            newPositionRotationOrScale.x *= -1;\r\n                            newPositionRotationOrScale.z *= -1;\r\n                        }\r\n                    }\r\n                }\r\n                outputs.push(newPositionRotationOrScale.asArray());\r\n            }\r\n        }\r\n        else if (animationType === Animation.ANIMATIONTYPE_QUATERNION) {\r\n            value = (keyFrame.value as Quaternion).normalize().asArray();\r\n\r\n            if (convertToRightHandedSystem) {\r\n                _GLTFUtilities._GetRightHandedQuaternionArrayFromRef(value);\r\n\r\n                if (!babylonTransformNode.parent) {\r\n                    value = Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(value)).asArray();\r\n                }\r\n            }\r\n\r\n            outputs.push(value);\r\n        }\r\n        else {\r\n            Tools.Error('glTFAnimation: Unsupported key frame values for animation!');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine the interpolation based on the key frames\r\n     * @param keyFrames\r\n     * @param animationChannelTargetPath\r\n     * @param useQuaternion\r\n     */\r\n    private static _DeduceInterpolation(keyFrames: IAnimationKey[], animationChannelTargetPath: AnimationChannelTargetPath, useQuaternion: boolean): { interpolationType: AnimationSamplerInterpolation, shouldBakeAnimation: boolean } {\r\n        let interpolationType: AnimationSamplerInterpolation | undefined;\r\n        let shouldBakeAnimation = false;\r\n        let key: IAnimationKey;\r\n\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION && !useQuaternion) {\r\n            return { interpolationType: AnimationSamplerInterpolation.LINEAR, shouldBakeAnimation: true };\r\n        }\r\n\r\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\r\n            key = keyFrames[i];\r\n            if (key.inTangent || key.outTangent) {\r\n                if (interpolationType) {\r\n                    if (interpolationType !== AnimationSamplerInterpolation.CUBICSPLINE) {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                        shouldBakeAnimation = true;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    interpolationType = AnimationSamplerInterpolation.CUBICSPLINE;\r\n                }\r\n            }\r\n            else {\r\n                if (interpolationType) {\r\n                    if (interpolationType === AnimationSamplerInterpolation.CUBICSPLINE ||\r\n                        (key.interpolation && (key.interpolation === AnimationKeyInterpolation.STEP) && interpolationType !== AnimationSamplerInterpolation.STEP)) {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                        shouldBakeAnimation = true;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (key.interpolation && (key.interpolation === AnimationKeyInterpolation.STEP)) {\r\n                        interpolationType = AnimationSamplerInterpolation.STEP;\r\n                    }\r\n                    else {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!interpolationType) {\r\n            interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n        }\r\n\r\n        return { interpolationType: interpolationType, shouldBakeAnimation: shouldBakeAnimation };\r\n    }\r\n\r\n    /**\r\n     * Adds an input tangent or output tangent to the output data\r\n     * If an input tangent or output tangent is missing, it uses the zero vector or zero quaternion\r\n     * @param tangentType Specifies which type of tangent to handle (inTangent or outTangent)\r\n     * @param outputs The animation data by keyframe\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param interpolation The interpolation type\r\n     * @param keyFrame The key frame with the animation data\r\n     * @param frameDelta Time difference between two frames used to scale the tangent by the frame delta\r\n     * @param useQuaternion Specifies if quaternions are used\r\n     * @param convertToRightHandedSystem Specifies if the values should be converted to right-handed\r\n     */\r\n    private static AddSplineTangent(babylonTransformNode: TransformNode, tangentType: _TangentType, outputs: number[][], animationChannelTargetPath: AnimationChannelTargetPath, interpolation: AnimationSamplerInterpolation, keyFrame: IAnimationKey, frameDelta: number, useQuaternion: boolean, convertToRightHandedSystem: boolean) {\r\n        let tangent: number[];\r\n        let tangentValue: Vector3 | Quaternion = tangentType === _TangentType.INTANGENT ? keyFrame.inTangent : keyFrame.outTangent;\r\n        if (interpolation === AnimationSamplerInterpolation.CUBICSPLINE) {\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                if (tangentValue) {\r\n                    if (useQuaternion) {\r\n                        tangent = (tangentValue as Quaternion).scale(frameDelta).asArray();\r\n                    }\r\n                    else {\r\n                        const array = (tangentValue as Vector3).scale(frameDelta);\r\n                        tangent = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z).asArray();\r\n                    }\r\n\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedQuaternionArrayFromRef(tangent);\r\n                        if (!babylonTransformNode.parent) {\r\n                            tangent = Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(tangent)).asArray();\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    tangent = [0, 0, 0, 0];\r\n                }\r\n            }\r\n            else {\r\n                if (tangentValue) {\r\n                    tangent = (tangentValue as Vector3).scale(frameDelta).asArray();\r\n                    if (convertToRightHandedSystem) {\r\n                        if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n                            _GLTFUtilities._GetRightHandedPositionArray3FromRef(tangent);\r\n                            if (!babylonTransformNode.parent) {\r\n                                tangent[0] *= -1; // x\r\n                                tangent[2] *= -1; // z\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    tangent = [0, 0, 0];\r\n                }\r\n            }\r\n\r\n            outputs.push(tangent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the minimum and maximum key frames' frame values\r\n     * @param keyFrames animation key frames\r\n     * @returns the minimum and maximum key frame value\r\n     */\r\n    private static calculateMinMaxKeyFrames(keyFrames: IAnimationKey[]): { min: number, max: number } {\r\n        let min: number = Infinity;\r\n        let max: number = -Infinity;\r\n        keyFrames.forEach(function(keyFrame) {\r\n            min = Math.min(min, keyFrame.frame);\r\n            max = Math.max(max, keyFrame.frame);\r\n        });\r\n\r\n        return { min: min, max: max };\r\n\r\n    }\r\n}","import { ImageMimeType } from \"babylonjs-gltf2interface\";\r\n\r\n/**\r\n * Class for holding and downloading glTF file data\r\n */\r\nexport class GLTFData {\r\n    /**\r\n     * Object which contains the file name as the key and its data as the value\r\n     */\r\n    glTFFiles: { [fileName: string]: string | Blob };\r\n\r\n    /**\r\n     * Initializes the glTF file object\r\n     */\r\n    public constructor() {\r\n        this.glTFFiles = {};\r\n    }\r\n\r\n    /**\r\n     * Downloads the glTF data as files based on their names and data\r\n     */\r\n    public downloadFiles(): void {\r\n        /**\r\n        * Checks for a matching suffix at the end of a string (for ES5 and lower)\r\n        * @param str Source string\r\n        * @param suffix Suffix to search for in the source string\r\n        * @returns Boolean indicating whether the suffix was found (true) or not (false)\r\n        */\r\n        function endsWith(str: string, suffix: string): boolean {\r\n            return str.indexOf(suffix, str.length - suffix.length) !== -1;\r\n        }\r\n\r\n        for (let key in this.glTFFiles) {\r\n            let link = document.createElement('a');\r\n            document.body.appendChild(link);\r\n            link.setAttribute(\"type\", \"hidden\");\r\n            link.download = key;\r\n            let blob = this.glTFFiles[key];\r\n            let mimeType;\r\n\r\n            if (endsWith(key, \".glb\")) {\r\n                mimeType = { type: \"model/gltf-binary\" };\r\n            }\r\n            else if (endsWith(key, \".bin\")) {\r\n                mimeType = { type: \"application/octet-stream\" };\r\n            }\r\n            else if (endsWith(key, \".gltf\")) {\r\n                mimeType = { type: \"model/gltf+json\" };\r\n            }\r\n            else if (endsWith(key, \".jpeg\" || \".jpg\")) {\r\n                mimeType = { type: ImageMimeType.JPEG };\r\n            }\r\n            else if (endsWith(key, \".png\")) {\r\n                mimeType = { type: ImageMimeType.PNG };\r\n            }\r\n\r\n            link.href = window.URL.createObjectURL(new Blob([blob], mimeType));\r\n            link.click();\r\n        }\r\n    }\r\n}\r\n","import { AccessorType, IBufferView, IAccessor, INode, IScene, IMesh, IMaterial, ITexture, IImage, ISampler, IAnimation, ImageMimeType, IMeshPrimitive, IBuffer, IGLTF, MeshPrimitiveMode, AccessorComponentType, ITextureInfo } from \"babylonjs-gltf2interface\";\r\n\r\nimport { FloatArray, Nullable, IndicesArray } from \"babylonjs/types\";\r\nimport { Vector2, Vector3, Vector4, Quaternion, Matrix } from \"babylonjs/Maths/math.vector\";\r\nimport { Color3 } from \"babylonjs/Maths/math.color\";\r\nimport { Tools } from \"babylonjs/Misc/tools\";\r\nimport { VertexBuffer } from \"babylonjs/Meshes/buffer\";\r\nimport { Node } from \"babylonjs/node\";\r\nimport { TransformNode } from \"babylonjs/Meshes/transformNode\";\r\nimport { AbstractMesh } from \"babylonjs/Meshes/abstractMesh\";\r\nimport { SubMesh } from \"babylonjs/Meshes/subMesh\";\r\nimport { Mesh } from \"babylonjs/Meshes/mesh\";\r\nimport { LinesMesh } from \"babylonjs/Meshes/linesMesh\";\r\nimport { InstancedMesh } from \"babylonjs/Meshes/instancedMesh\";\r\nimport { BaseTexture } from \"babylonjs/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"babylonjs/Materials/Textures/texture\";\r\nimport { Material } from \"babylonjs/Materials/material\";\r\nimport { MultiMaterial } from \"babylonjs/Materials/multiMaterial\";\r\nimport { Engine } from \"babylonjs/Engines/engine\";\r\nimport { Scene } from \"babylonjs/scene\";\r\n\r\nimport { IGLTFExporterExtensionV2 } from \"./glTFExporterExtension\";\r\nimport { _GLTFMaterialExporter } from \"./glTFMaterialExporter\";\r\nimport { IExportOptions } from \"./glTFSerializer\";\r\nimport { _GLTFUtilities } from \"./glTFUtilities\";\r\nimport { GLTFData } from \"./glTFData\";\r\nimport { _GLTFAnimation } from \"./glTFAnimation\";\r\nimport { Viewport } from 'babylonjs/Maths/math.viewport';\r\nimport { Epsilon } from 'babylonjs/Maths/math.constants';\r\n\r\n/**\r\n * Utility interface for storing vertex attribute data\r\n * @hidden\r\n */\r\ninterface _IVertexAttributeData {\r\n    /**\r\n     * Specifies the Babylon Vertex Buffer Type (Position, Normal, Color, etc.)\r\n    */\r\n    kind: string;\r\n\r\n    /**\r\n     * Specifies the glTF Accessor Type (VEC2, VEC3, etc.)\r\n    */\r\n    accessorType: AccessorType;\r\n\r\n    /**\r\n     * Specifies the BufferView index for the vertex attribute data\r\n    */\r\n    bufferViewIndex?: number;\r\n\r\n    byteStride?: number;\r\n}\r\n/**\r\n * Converts Babylon Scene into glTF 2.0.\r\n * @hidden\r\n */\r\nexport class _Exporter {\r\n    /**\r\n     * Stores the glTF to export\r\n     */\r\n    public _glTF: IGLTF;\r\n    /**\r\n     * Stores all generated buffer views, which represents views into the main glTF buffer data\r\n     */\r\n    public _bufferViews: IBufferView[];\r\n    /**\r\n     * Stores all the generated accessors, which is used for accessing the data within the buffer views in glTF\r\n     */\r\n    public _accessors: IAccessor[];\r\n    /**\r\n     * Stores all the generated nodes, which contains transform and/or mesh information per node\r\n     */\r\n    public _nodes: INode[];\r\n    /**\r\n     * Stores all the generated glTF scenes, which stores multiple node hierarchies\r\n     */\r\n    private _scenes: IScene[];\r\n    /**\r\n     * Stores all the generated mesh information, each containing a set of primitives to render in glTF\r\n     */\r\n    private _meshes: IMesh[];\r\n    /**\r\n     * Stores all the generated material information, which represents the appearance of each primitive\r\n     */\r\n    public _materials: IMaterial[];\r\n\r\n    public _materialMap: { [materialID: number]: number };\r\n    /**\r\n     * Stores all the generated texture information, which is referenced by glTF materials\r\n     */\r\n    public _textures: ITexture[];\r\n    /**\r\n     * Stores all the generated image information, which is referenced by glTF textures\r\n     */\r\n    public _images: IImage[];\r\n\r\n    /**\r\n     * Stores all the texture samplers\r\n     */\r\n    public _samplers: ISampler[];\r\n    /**\r\n     * Stores all the generated animation samplers, which is referenced by glTF animations\r\n     */\r\n    /**\r\n     * Stores the animations for glTF models\r\n     */\r\n    private _animations: IAnimation[];\r\n    /**\r\n     * Stores the total amount of bytes stored in the glTF buffer\r\n     */\r\n    private _totalByteLength: number;\r\n    /**\r\n     * Stores a reference to the Babylon scene containing the source geometry and material information\r\n     */\r\n    public _babylonScene: Scene;\r\n    /**\r\n     * Stores a map of the image data, where the key is the file name and the value\r\n     * is the image data\r\n     */\r\n    public _imageData: { [fileName: string]: { data: Uint8Array, mimeType: ImageMimeType } };\r\n\r\n    /**\r\n     * Stores a map of the unique id of a node to its index in the node array\r\n     */\r\n    public _nodeMap: { [key: number]: number };\r\n\r\n    /**\r\n     * Specifies if the source Babylon scene was left handed, and needed conversion.\r\n     */\r\n    public _convertToRightHandedSystem: boolean;\r\n\r\n    /**\r\n     * Specifies if a Babylon node should be converted to right-handed on export\r\n     */\r\n    public _convertToRightHandedSystemMap: { [nodeId: number]: boolean };\r\n\r\n    /*\r\n    * Specifies if root Babylon empty nodes that act as a coordinate space transform should be included in export\r\n    */\r\n    public _includeCoordinateSystemConversionNodes: boolean = false;\r\n\r\n    /**\r\n     * Baked animation sample rate\r\n     */\r\n    private _animationSampleRate: number;\r\n\r\n    private _options: IExportOptions;\r\n\r\n    private _localEngine: Engine;\r\n\r\n    public _glTFMaterialExporter: _GLTFMaterialExporter;\r\n\r\n    private _extensions: { [name: string]: IGLTFExporterExtensionV2 } = {};\r\n\r\n    private static _ExtensionNames = new Array<string>();\r\n    private static _ExtensionFactories: { [name: string]: (exporter: _Exporter) => IGLTFExporterExtensionV2 } = {};\r\n\r\n    private _applyExtension<T>(node: Nullable<T>, extensions: IGLTFExporterExtensionV2[], index: number, actionAsync: (extension: IGLTFExporterExtensionV2, node: Nullable<T>) => Promise<Nullable<T>> | undefined): Promise<Nullable<T>> {\r\n        if (index >= extensions.length) {\r\n            return Promise.resolve(node);\r\n        }\r\n\r\n        let currentPromise = actionAsync(extensions[index], node);\r\n\r\n        if (!currentPromise) {\r\n            return this._applyExtension(node, extensions, index + 1, actionAsync);\r\n        }\r\n\r\n        return currentPromise.then((newNode) => this._applyExtension(newNode, extensions, index + 1, actionAsync));\r\n    }\r\n\r\n    private _applyExtensions<T>(node: Nullable<T>, actionAsync: (extension: IGLTFExporterExtensionV2, node: Nullable<T>) => Promise<Nullable<T>> | undefined): Promise<Nullable<T>> {\r\n        var extensions: IGLTFExporterExtensionV2[] = [];\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            extensions.push(this._extensions[name]);\r\n        }\r\n\r\n        return this._applyExtension(node, extensions, 0, actionAsync);\r\n    }\r\n\r\n    public _extensionsPreExportTextureAsync(context: string, babylonTexture: Nullable<Texture>, mimeType: ImageMimeType): Promise<Nullable<BaseTexture>> {\r\n        return this._applyExtensions(babylonTexture, (extension, node) => extension.preExportTextureAsync && extension.preExportTextureAsync(context, node, mimeType));\r\n    }\r\n\r\n    public _extensionsPostExportMeshPrimitiveAsync(context: string, meshPrimitive: IMeshPrimitive, babylonSubMesh: SubMesh, binaryWriter: _BinaryWriter): Promise<Nullable<IMeshPrimitive>> {\r\n        return this._applyExtensions(meshPrimitive, (extension, node) => extension.postExportMeshPrimitiveAsync && extension.postExportMeshPrimitiveAsync(context, node, babylonSubMesh, binaryWriter));\r\n    }\r\n\r\n    public _extensionsPostExportNodeAsync(context: string, node: Nullable<INode>, babylonNode: Node, nodeMap?: {[key: number]: number}): Promise<Nullable<INode>> {\r\n        return this._applyExtensions(node, (extension, node) => extension.postExportNodeAsync && extension.postExportNodeAsync(context, node, babylonNode, nodeMap));\r\n    }\r\n\r\n    public _extensionsPostExportMaterialAsync(context: string, material: Nullable<IMaterial>, babylonMaterial: Material): Promise<Nullable<IMaterial>> {\r\n        return this._applyExtensions(material, (extension, node) => extension.postExportMaterialAsync && extension.postExportMaterialAsync(context, node, babylonMaterial));\r\n    }\r\n\r\n    public _extensionsPostExportMaterialAdditionalTextures(context: string, material: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        let output: BaseTexture[] = [];\r\n\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            var extension = this._extensions[name];\r\n\r\n            if (extension.postExportMaterialAdditionalTextures) {\r\n                output.push(...extension.postExportMaterialAdditionalTextures(context, material, babylonMaterial));\r\n            }\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n    public _extensionsPostExportTextures(context: string, textureInfo: ITextureInfo, babylonTexture: BaseTexture): void {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            var extension = this._extensions[name];\r\n\r\n            if (extension.postExportTexture) {\r\n                extension.postExportTexture(context, textureInfo, babylonTexture);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _forEachExtensions(action: (extension: IGLTFExporterExtensionV2) => void): void {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n            if (extension.enabled) {\r\n                action(extension);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _extensionsOnExporting(): void {\r\n        this._forEachExtensions((extension) => {\r\n            if (extension.wasUsed) {\r\n                if (this._glTF.extensionsUsed == null) {\r\n                    this._glTF.extensionsUsed = [];\r\n                }\r\n\r\n                if (this._glTF.extensionsUsed.indexOf(extension.name) === -1) {\r\n                    this._glTF.extensionsUsed.push(extension.name);\r\n                }\r\n\r\n                if (extension.required) {\r\n                    if (this._glTF.extensionsRequired == null) {\r\n                        this._glTF.extensionsRequired = [];\r\n                    }\r\n                    if (this._glTF.extensionsRequired.indexOf(extension.name) === -1) {\r\n                        this._glTF.extensionsRequired.push(extension.name);\r\n                    }\r\n                }\r\n\r\n                if (this._glTF.extensions == null) {\r\n                    this._glTF.extensions = {};\r\n                }\r\n\r\n                if (extension.onExporting) {\r\n                    extension.onExporting();\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load glTF serializer extensions\r\n     */\r\n    private _loadExtensions(): void {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = _Exporter._ExtensionFactories[name](this);\r\n            this._extensions[name] = extension;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF Exporter instance, which can accept optional exporter options\r\n     * @param babylonScene Babylon scene object\r\n     * @param options Options to modify the behavior of the exporter\r\n     */\r\n    public constructor(babylonScene: Scene, options?: IExportOptions) {\r\n        this._glTF = {\r\n            asset: { generator: \"BabylonJS\", version: \"2.0\" }\r\n        };\r\n        this._babylonScene = babylonScene;\r\n        this._bufferViews = [];\r\n        this._accessors = [];\r\n        this._meshes = [];\r\n        this._scenes = [];\r\n        this._nodes = [];\r\n        this._images = [];\r\n        this._materials = [];\r\n        this._materialMap = [];\r\n        this._textures = [];\r\n        this._samplers = [];\r\n        this._animations = [];\r\n        this._imageData = {};\r\n        this._options = options || {};\r\n        this._animationSampleRate = options && options.animationSampleRate ? options.animationSampleRate : 1 / 60;\r\n        this._includeCoordinateSystemConversionNodes = options && options.includeCoordinateSystemConversionNodes ? true : false;\r\n\r\n        this._glTFMaterialExporter = new _GLTFMaterialExporter(this);\r\n        this._loadExtensions();\r\n    }\r\n\r\n    public dispose() {\r\n        for (var extensionKey in this._extensions) {\r\n            const extension = this._extensions[extensionKey];\r\n\r\n            extension.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Registers a glTF exporter extension\r\n     * @param name Name of the extension to export\r\n     * @param factory The factory function that creates the exporter extension\r\n     */\r\n    public static RegisterExtension(name: string, factory: (exporter: _Exporter) => IGLTFExporterExtensionV2): void {\r\n        if (_Exporter.UnregisterExtension(name)) {\r\n            Tools.Warn(`Extension with the name ${name} already exists`);\r\n        }\r\n\r\n        _Exporter._ExtensionFactories[name] = factory;\r\n        _Exporter._ExtensionNames.push(name);\r\n    }\r\n\r\n    /**\r\n     * Un-registers an exporter extension\r\n     * @param name The name fo the exporter extension\r\n     * @returns A boolean indicating whether the extension has been un-registered\r\n     */\r\n    public static UnregisterExtension(name: string): boolean {\r\n        if (!_Exporter._ExtensionFactories[name]) {\r\n            return false;\r\n        }\r\n        delete _Exporter._ExtensionFactories[name];\r\n\r\n        const index = _Exporter._ExtensionNames.indexOf(name);\r\n        if (index !== -1) {\r\n            _Exporter._ExtensionNames.splice(index, 1);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Lazy load a local engine\r\n     */\r\n    public _getLocalEngine(): Engine {\r\n        if (!this._localEngine) {\r\n            const localCanvas = document.createElement('canvas');\r\n            localCanvas.id = \"WriteCanvas\";\r\n            localCanvas.width = 2048;\r\n            localCanvas.height = 2048;\r\n            this._localEngine = new Engine(localCanvas, true, { premultipliedAlpha: Tools.IsSafari(), preserveDrawingBuffer: true });\r\n            this._localEngine.setViewport(new Viewport(0, 0, 1, 1));\r\n        }\r\n\r\n        return this._localEngine;\r\n    }\r\n\r\n    private reorderIndicesBasedOnPrimitiveMode(submesh: SubMesh, primitiveMode: number, babylonIndices: IndicesArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        switch (primitiveMode) {\r\n            case Material.TriangleFillMode: {\r\n                if (!byteOffset) { byteOffset = 0; }\r\n                for (let i = submesh.indexStart, length = submesh.indexStart + submesh.indexCount; i < length; i = i + 3) {\r\n                    const index = byteOffset + i * 4;\r\n                    // swap the second and third indices\r\n                    const secondIndex = binaryWriter.getUInt32(index + 4);\r\n                    const thirdIndex = binaryWriter.getUInt32(index + 8);\r\n                    binaryWriter.setUInt32(thirdIndex, index + 4);\r\n                    binaryWriter.setUInt32(secondIndex, index + 8);\r\n                }\r\n                break;\r\n            }\r\n            case Material.TriangleFanDrawMode: {\r\n                for (let i = submesh.indexStart + submesh.indexCount - 1, start = submesh.indexStart; i >= start; --i) {\r\n                    binaryWriter.setUInt32(babylonIndices[i], byteOffset);\r\n                    byteOffset += 4;\r\n                }\r\n                break;\r\n            }\r\n            case Material.TriangleStripDrawMode: {\r\n                if (submesh.indexCount >= 3) {\r\n                    binaryWriter.setUInt32(babylonIndices[submesh.indexStart + 2], byteOffset + 4);\r\n                    binaryWriter.setUInt32(babylonIndices[submesh.indexStart + 1], byteOffset + 8);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attribute data based on the primitive mode.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private reorderVertexAttributeDataBasedOnPrimitiveMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter, convertToRightHandedSystem: boolean): void {\r\n        if (convertToRightHandedSystem && sideOrientation === Material.ClockWiseSideOrientation) {\r\n            switch (primitiveMode) {\r\n                case Material.TriangleFillMode: {\r\n                    this.reorderTriangleFillMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter, convertToRightHandedSystem);\r\n                    break;\r\n                }\r\n                case Material.TriangleStripDrawMode: {\r\n                    this.reorderTriangleStripDrawMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter, convertToRightHandedSystem);\r\n                    break;\r\n                }\r\n                case Material.TriangleFanDrawMode: {\r\n                    this.reorderTriangleFanMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter, convertToRightHandedSystem);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle mode order .  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private reorderTriangleFillMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter, convertToRightHandedSystem: boolean) {\r\n        const vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            let stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n            if (submesh.verticesCount % 3 !== 0) {\r\n                Tools.Error('The submesh vertices for the triangle fill mode is not divisible by 3!');\r\n            }\r\n            else {\r\n                let vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n                let index = 0;\r\n                switch (vertexBufferKind) {\r\n                    case VertexBuffer.PositionKind:\r\n                    case VertexBuffer.NormalKind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.TangentKind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.ColorKind: {\r\n                        const size = vertexBuffer.getSize();\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + size) {\r\n                            index = x * stride;\r\n                            if (size === 4) {\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + 2 * stride));\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + stride));\r\n                            }\r\n                            else {\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.UVKind:\r\n                    case VertexBuffer.UV2Kind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                    }\r\n                }\r\n                this.writeVertexAttributeData(vertexData, byteOffset, vertexBufferKind, meshAttributeArray, binaryWriter, convertToRightHandedSystem);\r\n            }\r\n        }\r\n        else {\r\n            Tools.Warn(`reorderTriangleFillMode: Vertex Buffer Kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle strip order.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private reorderTriangleStripDrawMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter, convertToRightHandedSystem: boolean) {\r\n        const vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            const stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n\r\n            let vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n            let index = 0;\r\n            switch (vertexBufferKind) {\r\n                case VertexBuffer.PositionKind:\r\n                case VertexBuffer.NormalKind: {\r\n                    index = submesh.verticesStart;\r\n                    (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                    (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                    break;\r\n                }\r\n                case VertexBuffer.TangentKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.ColorKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        vertexBuffer.getSize() === 4 ? (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index)) : (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.UVKind:\r\n                case VertexBuffer.UV2Kind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                }\r\n            }\r\n            this.writeVertexAttributeData(vertexData, byteOffset + 12, vertexBufferKind, meshAttributeArray, binaryWriter, convertToRightHandedSystem);\r\n        }\r\n        else {\r\n            Tools.Warn(`reorderTriangleStripDrawMode: Vertex buffer kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle fan order.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private reorderTriangleFanMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter, convertToRightHandedSystem: boolean) {\r\n        const vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            let stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n\r\n            let vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n            let index = 0;\r\n            switch (vertexBufferKind) {\r\n                case VertexBuffer.PositionKind:\r\n                case VertexBuffer.NormalKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.TangentKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n\r\n                }\r\n                case VertexBuffer.ColorKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                        vertexBuffer.getSize() === 4 ? (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index)) : (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.UVKind:\r\n                case VertexBuffer.UV2Kind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                }\r\n            }\r\n            this.writeVertexAttributeData(vertexData, byteOffset, vertexBufferKind, meshAttributeArray, binaryWriter, convertToRightHandedSystem);\r\n        }\r\n        else {\r\n            Tools.Warn(`reorderTriangleFanMode: Vertex buffer kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes the vertex attribute data to binary\r\n     * @param vertices The vertices to write to the binary writer\r\n     * @param byteOffset The offset into the binary writer to overwrite binary data\r\n     * @param vertexAttributeKind The vertex attribute type\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param binaryWriter The writer containing the binary data\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private writeVertexAttributeData(vertices: Vector2[] | Vector3[] | Vector4[], byteOffset: number, vertexAttributeKind: string, meshAttributeArray: FloatArray, binaryWriter: _BinaryWriter, convertToRightHandedSystem: boolean) {\r\n        for (let vertex of vertices) {\r\n            if (convertToRightHandedSystem && !(vertexAttributeKind === VertexBuffer.ColorKind) && !(vertex instanceof Vector2)) {\r\n                if (vertex instanceof Vector3) {\r\n                    if (vertexAttributeKind === VertexBuffer.NormalKind) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(vertex);\r\n                    }\r\n                    else if (vertexAttributeKind === VertexBuffer.PositionKind) {\r\n                        _GLTFUtilities._GetRightHandedPositionVector3FromRef(vertex);\r\n                    }\r\n                    else {\r\n                        Tools.Error('Unsupported vertex attribute kind!');\r\n                    }\r\n                }\r\n                else {\r\n                    _GLTFUtilities._GetRightHandedVector4FromRef(vertex);\r\n                }\r\n            }\r\n            if (vertexAttributeKind === VertexBuffer.NormalKind) {\r\n                vertex.normalize();\r\n            }\r\n            else if (vertexAttributeKind === VertexBuffer.TangentKind && vertex instanceof Vector4) {\r\n                _GLTFUtilities._NormalizeTangentFromRef(vertex);\r\n            }\r\n\r\n            for (let component of vertex.asArray()) {\r\n                binaryWriter.setFloat32(component, byteOffset);\r\n                byteOffset += 4;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes mesh attribute data to a data buffer\r\n     * Returns the bytelength of the data\r\n     * @param vertexBufferKind Indicates what kind of vertex data is being passed in\r\n     * @param meshAttributeArray Array containing the attribute data\r\n     * @param binaryWriter The buffer to write the binary data to\r\n     * @param indices Used to specify the order of the vertex data\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    public writeAttributeData(vertexBufferKind: string, meshAttributeArray: FloatArray, byteStride: number, binaryWriter: _BinaryWriter, convertToRightHandedSystem: boolean) {\r\n        const stride = byteStride / 4;\r\n        let vertexAttributes: number[][] = [];\r\n        let index: number;\r\n\r\n        switch (vertexBufferKind) {\r\n            case VertexBuffer.PositionKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector3.FromArray(meshAttributeArray, index);\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedPositionVector3FromRef(vertexData);\r\n                    }\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.NormalKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector3.FromArray(meshAttributeArray, index);\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(vertexData);\r\n                    }\r\n                    vertexData.normalize();\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.TangentKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector4.FromArray(meshAttributeArray, index);\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedVector4FromRef(vertexData);\r\n                    }\r\n                    _GLTFUtilities._NormalizeTangentFromRef(vertexData);\r\n\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.ColorKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = stride === 3 ? Vector3.FromArray(meshAttributeArray, index) : Vector4.FromArray(meshAttributeArray, index);\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.UVKind:\r\n            case VertexBuffer.UV2Kind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    vertexAttributes.push(convertToRightHandedSystem ? [meshAttributeArray[index], meshAttributeArray[index + 1]] : [meshAttributeArray[index], meshAttributeArray[index + 1]]);\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Vertex Buffer Type: \" + vertexBufferKind);\r\n                vertexAttributes = [];\r\n            }\r\n        }\r\n        for (let vertexAttribute of vertexAttributes) {\r\n            for (let component of vertexAttribute) {\r\n                binaryWriter.setFloat32(component);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates glTF json data\r\n     * @param shouldUseGlb Indicates whether the json should be written for a glb file\r\n     * @param glTFPrefix Text to use when prefixing a glTF file\r\n     * @param prettyPrint Indicates whether the json file should be pretty printed (true) or not (false)\r\n     * @returns json data as string\r\n     */\r\n    private generateJSON(shouldUseGlb: boolean, glTFPrefix?: string, prettyPrint?: boolean): string {\r\n        let buffer: IBuffer = { byteLength: this._totalByteLength };\r\n        let imageName: string;\r\n        let imageData: { data: Uint8Array, mimeType: ImageMimeType };\r\n        let bufferView: IBufferView;\r\n        let byteOffset: number = this._totalByteLength;\r\n\r\n        if (buffer.byteLength) {\r\n            this._glTF.buffers = [buffer];\r\n        }\r\n        if (this._nodes && this._nodes.length) {\r\n            this._glTF.nodes = this._nodes;\r\n        }\r\n        if (this._meshes && this._meshes.length) {\r\n            this._glTF.meshes = this._meshes;\r\n        }\r\n        if (this._scenes && this._scenes.length) {\r\n            this._glTF.scenes = this._scenes;\r\n            this._glTF.scene = 0;\r\n        }\r\n        if (this._bufferViews && this._bufferViews.length) {\r\n            this._glTF.bufferViews = this._bufferViews;\r\n        }\r\n        if (this._accessors && this._accessors.length) {\r\n            this._glTF.accessors = this._accessors;\r\n        }\r\n        if (this._animations && this._animations.length) {\r\n            this._glTF.animations = this._animations;\r\n        }\r\n        if (this._materials && this._materials.length) {\r\n            this._glTF.materials = this._materials;\r\n        }\r\n        if (this._textures && this._textures.length) {\r\n            this._glTF.textures = this._textures;\r\n        }\r\n        if (this._samplers && this._samplers.length) {\r\n            this._glTF.samplers = this._samplers;\r\n        }\r\n        if (this._images && this._images.length) {\r\n            if (!shouldUseGlb) {\r\n                this._glTF.images = this._images;\r\n            }\r\n            else {\r\n                this._glTF.images = [];\r\n\r\n                this._images.forEach((image) => {\r\n                    if (image.uri) {\r\n                        imageData = this._imageData[image.uri];\r\n                        imageName = image.uri.split('.')[0] + \" image\";\r\n                        bufferView = _GLTFUtilities._CreateBufferView(0, byteOffset, imageData.data.length, undefined, imageName);\r\n                        byteOffset += imageData.data.buffer.byteLength;\r\n                        this._bufferViews.push(bufferView);\r\n                        image.bufferView = this._bufferViews.length - 1;\r\n                        image.name = imageName;\r\n                        image.mimeType = imageData.mimeType;\r\n                        image.uri = undefined;\r\n                        if (!this._glTF.images) {\r\n                            this._glTF.images = [];\r\n                        }\r\n                        this._glTF.images.push(image);\r\n                    }\r\n                });\r\n                // Replace uri with bufferview and mime type for glb\r\n                buffer.byteLength = byteOffset;\r\n            }\r\n        }\r\n\r\n        if (!shouldUseGlb) {\r\n            buffer.uri = glTFPrefix + \".bin\";\r\n        }\r\n\r\n        const jsonText = prettyPrint ? JSON.stringify(this._glTF, null, 2) : JSON.stringify(this._glTF);\r\n\r\n        return jsonText;\r\n    }\r\n\r\n    /**\r\n     * Generates data for .gltf and .bin files based on the glTF prefix string\r\n     * @param glTFPrefix Text to use when prefixing a glTF file\r\n     * @param dispose Dispose the exporter\r\n     * @returns GLTFData with glTF file data\r\n     */\r\n    public _generateGLTFAsync(glTFPrefix: string, dispose = true): Promise<GLTFData> {\r\n        return this._generateBinaryAsync().then((binaryBuffer) => {\r\n            this._extensionsOnExporting();\r\n            const jsonText = this.generateJSON(false, glTFPrefix, true);\r\n            const bin = new Blob([binaryBuffer], { type: 'application/octet-stream' });\r\n\r\n            const glTFFileName = glTFPrefix + '.gltf';\r\n            const glTFBinFile = glTFPrefix + '.bin';\r\n\r\n            const container = new GLTFData();\r\n\r\n            container.glTFFiles[glTFFileName] = jsonText;\r\n            container.glTFFiles[glTFBinFile] = bin;\r\n\r\n            if (this._imageData) {\r\n                for (let image in this._imageData) {\r\n                    container.glTFFiles[image] = new Blob([this._imageData[image].data], { type: this._imageData[image].mimeType });\r\n                }\r\n            }\r\n\r\n            if (dispose) {\r\n                this.dispose();\r\n            }\r\n\r\n            return container;\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Creates a binary buffer for glTF\r\n     * @returns array buffer for binary data\r\n     */\r\n    private _generateBinaryAsync(): Promise<ArrayBuffer> {\r\n        let binaryWriter = new _BinaryWriter(4);\r\n        return this.createSceneAsync(this._babylonScene, binaryWriter).then(() => {\r\n            if (this._localEngine) {\r\n                this._localEngine.dispose();\r\n            }\r\n            return binaryWriter.getArrayBuffer();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Pads the number to a multiple of 4\r\n     * @param num number to pad\r\n     * @returns padded number\r\n     */\r\n    private _getPadding(num: number): number {\r\n        let remainder = num % 4;\r\n        let padding = remainder === 0 ? remainder : 4 - remainder;\r\n\r\n        return padding;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _generateGLBAsync(glTFPrefix: string, dispose = true): Promise<GLTFData> {\r\n        return this._generateBinaryAsync().then((binaryBuffer) => {\r\n            this._extensionsOnExporting();\r\n            const jsonText = this.generateJSON(true);\r\n            const glbFileName = glTFPrefix + '.glb';\r\n            const headerLength = 12;\r\n            const chunkLengthPrefix = 8;\r\n            const jsonLength = jsonText.length;\r\n            let imageByteLength = 0;\r\n\r\n            for (let key in this._imageData) {\r\n                imageByteLength += this._imageData[key].data.byteLength;\r\n            }\r\n            const jsonPadding = this._getPadding(jsonLength);\r\n            const binPadding = this._getPadding(binaryBuffer.byteLength);\r\n            const imagePadding = this._getPadding(imageByteLength);\r\n\r\n            const byteLength = headerLength + (2 * chunkLengthPrefix) + jsonLength + jsonPadding + binaryBuffer.byteLength + binPadding + imageByteLength + imagePadding;\r\n\r\n            //header\r\n            const headerBuffer = new ArrayBuffer(headerLength);\r\n            const headerBufferView = new DataView(headerBuffer);\r\n            headerBufferView.setUint32(0, 0x46546C67, true); //glTF\r\n            headerBufferView.setUint32(4, 2, true); // version\r\n            headerBufferView.setUint32(8, byteLength, true); // total bytes in file\r\n\r\n            //json chunk\r\n            const jsonChunkBuffer = new ArrayBuffer(chunkLengthPrefix + jsonLength + jsonPadding);\r\n            const jsonChunkBufferView = new DataView(jsonChunkBuffer);\r\n            jsonChunkBufferView.setUint32(0, jsonLength + jsonPadding, true);\r\n            jsonChunkBufferView.setUint32(4, 0x4E4F534A, true);\r\n\r\n            //json chunk bytes\r\n            const jsonData = new Uint8Array(jsonChunkBuffer, chunkLengthPrefix);\r\n            for (let i = 0; i < jsonLength; ++i) {\r\n                jsonData[i] = jsonText.charCodeAt(i);\r\n            }\r\n\r\n            //json padding\r\n            const jsonPaddingView = new Uint8Array(jsonChunkBuffer, chunkLengthPrefix + jsonLength);\r\n            for (let i = 0; i < jsonPadding; ++i) {\r\n                jsonPaddingView[i] = 0x20;\r\n            }\r\n\r\n            //binary chunk\r\n            const binaryChunkBuffer = new ArrayBuffer(chunkLengthPrefix);\r\n            const binaryChunkBufferView = new DataView(binaryChunkBuffer);\r\n            binaryChunkBufferView.setUint32(0, binaryBuffer.byteLength + imageByteLength + imagePadding, true);\r\n            binaryChunkBufferView.setUint32(4, 0x004E4942, true);\r\n\r\n            // binary padding\r\n            const binPaddingBuffer = new ArrayBuffer(binPadding);\r\n            const binPaddingView = new Uint8Array(binPaddingBuffer);\r\n            for (let i = 0; i < binPadding; ++i) {\r\n                binPaddingView[i] = 0;\r\n            }\r\n\r\n            const imagePaddingBuffer = new ArrayBuffer(imagePadding);\r\n            const imagePaddingView = new Uint8Array(imagePaddingBuffer);\r\n            for (let i = 0; i < imagePadding; ++i) {\r\n                imagePaddingView[i] = 0;\r\n            }\r\n\r\n            const glbData = [headerBuffer, jsonChunkBuffer, binaryChunkBuffer, binaryBuffer];\r\n\r\n            // binary data\r\n            for (let key in this._imageData) {\r\n                glbData.push(this._imageData[key].data.buffer);\r\n            }\r\n            glbData.push(binPaddingBuffer);\r\n\r\n            glbData.push(imagePaddingBuffer);\r\n\r\n            const glbFile = new Blob(glbData, { type: 'application/octet-stream' });\r\n\r\n            const container = new GLTFData();\r\n            container.glTFFiles[glbFileName] = glbFile;\r\n\r\n            if (this._localEngine != null) {\r\n                this._localEngine.dispose();\r\n            }\r\n\r\n            if (dispose) {\r\n                this.dispose();\r\n            }\r\n\r\n            return container;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the TRS for each node\r\n     * @param node glTF Node for storing the transformation data\r\n     * @param babylonTransformNode Babylon mesh used as the source for the transformation data\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private setNodeTransformation(node: INode, babylonTransformNode: TransformNode, convertToRightHandedSystem: boolean): void {\r\n        if (!babylonTransformNode.getPivotPoint().equalsToFloats(0, 0, 0)) {\r\n            Tools.Warn(\"Pivot points are not supported in the glTF serializer\");\r\n        }\r\n        if (!babylonTransformNode.position.equalsToFloats(0, 0, 0)) {\r\n            node.translation = convertToRightHandedSystem ? _GLTFUtilities._GetRightHandedPositionVector3(babylonTransformNode.position).asArray() : babylonTransformNode.position.asArray();\r\n        }\r\n\r\n        if (!babylonTransformNode.scaling.equalsToFloats(1, 1, 1)) {\r\n            node.scale = babylonTransformNode.scaling.asArray();\r\n        }\r\n\r\n        let rotationQuaternion = Quaternion.RotationYawPitchRoll(babylonTransformNode.rotation.y, babylonTransformNode.rotation.x, babylonTransformNode.rotation.z);\r\n        if (babylonTransformNode.rotationQuaternion) {\r\n            rotationQuaternion.multiplyInPlace(babylonTransformNode.rotationQuaternion);\r\n        }\r\n        if (!(rotationQuaternion.x === 0 && rotationQuaternion.y === 0 && rotationQuaternion.z === 0 && rotationQuaternion.w === 1)) {\r\n            if (convertToRightHandedSystem) {\r\n                _GLTFUtilities._GetRightHandedQuaternionFromRef(rotationQuaternion);\r\n\r\n            }\r\n            node.rotation = rotationQuaternion.normalize().asArray();\r\n        }\r\n    }\r\n\r\n    private getVertexBufferFromMesh(attributeKind: string, bufferMesh: Mesh): Nullable<VertexBuffer> {\r\n        if (bufferMesh.isVerticesDataPresent(attributeKind)) {\r\n            const vertexBuffer = bufferMesh.getVertexBuffer(attributeKind);\r\n            if (vertexBuffer) {\r\n                return vertexBuffer;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a bufferview based on the vertices type for the Babylon mesh\r\n     * @param kind Indicates the type of vertices data\r\n     * @param babylonTransformNode The Babylon mesh to get the vertices data from\r\n     * @param binaryWriter The buffer to write the bufferview data to\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private createBufferViewKind(kind: string, babylonTransformNode: TransformNode, binaryWriter: _BinaryWriter, byteStride: number, convertToRightHandedSystem: boolean) {\r\n        const bufferMesh = babylonTransformNode instanceof Mesh ?\r\n            babylonTransformNode as Mesh : babylonTransformNode instanceof InstancedMesh ?\r\n                (babylonTransformNode as InstancedMesh).sourceMesh : null;\r\n\r\n        if (bufferMesh) {\r\n            const vertexData = bufferMesh.getVerticesData(kind);\r\n\r\n            if (vertexData) {\r\n                const byteLength = vertexData.length * 4;\r\n                const bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, byteStride, kind + \" - \" + bufferMesh.name);\r\n                this._bufferViews.push(bufferView);\r\n\r\n                this.writeAttributeData(\r\n                    kind,\r\n                    vertexData,\r\n                    byteStride,\r\n                    binaryWriter,\r\n                    convertToRightHandedSystem\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The primitive mode of the Babylon mesh\r\n     * @param babylonMesh The BabylonJS mesh\r\n     */\r\n    private getMeshPrimitiveMode(babylonMesh: AbstractMesh): number {\r\n        if (babylonMesh instanceof LinesMesh) {\r\n            return Material.LineListDrawMode;\r\n        }\r\n        return babylonMesh.material ? babylonMesh.material.fillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the primitive mode of the glTF mesh primitive\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param primitiveMode The primitive mode\r\n     */\r\n    private setPrimitiveMode(meshPrimitive: IMeshPrimitive, primitiveMode: number) {\r\n        switch (primitiveMode) {\r\n            case Material.TriangleFillMode: {\r\n                // glTF defaults to using Triangle Mode\r\n                break;\r\n            }\r\n            case Material.TriangleStripDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.TRIANGLE_STRIP;\r\n                break;\r\n            }\r\n            case Material.TriangleFanDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.TRIANGLE_FAN;\r\n                break;\r\n            }\r\n            case Material.PointListDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.POINTS;\r\n            }\r\n            case Material.PointFillMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.POINTS;\r\n                break;\r\n            }\r\n            case Material.LineLoopDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINE_LOOP;\r\n                break;\r\n            }\r\n            case Material.LineListDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINES;\r\n                break;\r\n            }\r\n            case Material.LineStripDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINE_STRIP;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex attribute accessor based of the glTF mesh primitive\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param attributeKind vertex attribute\r\n     * @returns boolean specifying if uv coordinates are present\r\n     */\r\n    private setAttributeKind(meshPrimitive: IMeshPrimitive, attributeKind: string): void {\r\n        switch (attributeKind) {\r\n            case VertexBuffer.PositionKind: {\r\n                meshPrimitive.attributes.POSITION = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.NormalKind: {\r\n                meshPrimitive.attributes.NORMAL = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.ColorKind: {\r\n                meshPrimitive.attributes.COLOR_0 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.TangentKind: {\r\n                meshPrimitive.attributes.TANGENT = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.UVKind: {\r\n                meshPrimitive.attributes.TEXCOORD_0 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.UV2Kind: {\r\n                meshPrimitive.attributes.TEXCOORD_1 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Vertex Buffer Type: \" + attributeKind);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets data for the primitive attributes of each submesh\r\n     * @param mesh glTF Mesh object to store the primitive attribute information\r\n     * @param babylonTransformNode Babylon mesh to get the primitive attribute data from\r\n     * @param binaryWriter Buffer to write the attribute data to\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private setPrimitiveAttributesAsync(mesh: IMesh, babylonTransformNode: TransformNode, binaryWriter: _BinaryWriter, convertToRightHandedSystem: boolean): Promise<void> {\r\n        let promises: Promise<IMeshPrimitive>[] = [];\r\n        let bufferMesh: Nullable<Mesh> = null;\r\n        let bufferView: IBufferView;\r\n        let minMax: { min: Nullable<number[]>, max: Nullable<number[]> };\r\n\r\n        if (babylonTransformNode instanceof Mesh) {\r\n            bufferMesh = (babylonTransformNode as Mesh);\r\n        }\r\n        else if (babylonTransformNode instanceof InstancedMesh) {\r\n            bufferMesh = (babylonTransformNode as InstancedMesh).sourceMesh;\r\n        }\r\n        const attributeData: _IVertexAttributeData[] = [\r\n            { kind: VertexBuffer.PositionKind, accessorType: AccessorType.VEC3, byteStride: 12 },\r\n            { kind: VertexBuffer.NormalKind, accessorType: AccessorType.VEC3, byteStride: 12 },\r\n            { kind: VertexBuffer.ColorKind, accessorType: AccessorType.VEC4, byteStride: 16 },\r\n            { kind: VertexBuffer.TangentKind, accessorType: AccessorType.VEC4, byteStride: 16 },\r\n            { kind: VertexBuffer.UVKind, accessorType: AccessorType.VEC2, byteStride: 8 },\r\n            { kind: VertexBuffer.UV2Kind, accessorType: AccessorType.VEC2, byteStride: 8 },\r\n        ];\r\n\r\n        if (bufferMesh) {\r\n            let indexBufferViewIndex: Nullable<number> = null;\r\n            const primitiveMode = this.getMeshPrimitiveMode(bufferMesh);\r\n            let vertexAttributeBufferViews: { [attributeKind: string]: number } = {};\r\n\r\n            // For each BabylonMesh, create bufferviews for each 'kind'\r\n            for (const attribute of attributeData) {\r\n                const attributeKind = attribute.kind;\r\n                if (bufferMesh.isVerticesDataPresent(attributeKind)) {\r\n                    const vertexBuffer = this.getVertexBufferFromMesh(attributeKind, bufferMesh);\r\n                    attribute.byteStride = vertexBuffer ? vertexBuffer.getSize() * 4 : VertexBuffer.DeduceStride(attributeKind) * 4;\r\n                    if (attribute.byteStride === 12) {\r\n                        attribute.accessorType = AccessorType.VEC3;\r\n                    }\r\n\r\n                    this.createBufferViewKind(attributeKind, babylonTransformNode, binaryWriter, attribute.byteStride, convertToRightHandedSystem);\r\n                    attribute.bufferViewIndex = this._bufferViews.length - 1;\r\n                    vertexAttributeBufferViews[attributeKind] = attribute.bufferViewIndex;\r\n                }\r\n            }\r\n\r\n            if (bufferMesh.getTotalIndices()) {\r\n                const indices = bufferMesh.getIndices();\r\n                if (indices) {\r\n                    const byteLength = indices.length * 4;\r\n                    bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, \"Indices - \" + bufferMesh.name);\r\n                    this._bufferViews.push(bufferView);\r\n                    indexBufferViewIndex = this._bufferViews.length - 1;\r\n\r\n                    for (let k = 0, length = indices.length; k < length; ++k) {\r\n                        binaryWriter.setUInt32(indices[k]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (bufferMesh.subMeshes) {\r\n                // go through all mesh primitives (submeshes)\r\n                for (const submesh of bufferMesh.subMeshes) {\r\n                    let babylonMaterial = submesh.getMaterial() || bufferMesh.getScene().defaultMaterial;\r\n\r\n                    let materialIndex: Nullable<number> = null;\r\n                    if (babylonMaterial) {\r\n                        if (bufferMesh instanceof LinesMesh) {\r\n                            // get the color from the lines mesh and set it in the material\r\n                            const material: IMaterial = {\r\n                                name: bufferMesh.name + ' material'\r\n                            };\r\n                            if (!bufferMesh.color.equals(Color3.White()) || bufferMesh.alpha < 1) {\r\n                                material.pbrMetallicRoughness = {\r\n                                    baseColorFactor: bufferMesh.color.asArray().concat([bufferMesh.alpha])\r\n                                };\r\n                            }\r\n                            this._materials.push(material);\r\n                            materialIndex = this._materials.length - 1;\r\n                        }\r\n                        else if (babylonMaterial instanceof MultiMaterial) {\r\n                            const subMaterial = babylonMaterial.subMaterials[submesh.materialIndex];\r\n                            if (subMaterial) {\r\n                                babylonMaterial = subMaterial;\r\n                                materialIndex = this._materialMap[babylonMaterial.uniqueId];\r\n                            }\r\n                        }\r\n                        else {\r\n                            materialIndex = this._materialMap[babylonMaterial.uniqueId];\r\n                        }\r\n                    }\r\n\r\n                    let glTFMaterial: Nullable<IMaterial> = materialIndex != null ? this._materials[materialIndex] : null;\r\n\r\n                    const meshPrimitive: IMeshPrimitive = { attributes: {} };\r\n                    this.setPrimitiveMode(meshPrimitive, primitiveMode);\r\n\r\n                    for (const attribute of attributeData) {\r\n                        const attributeKind = attribute.kind;\r\n                        if (attributeKind === VertexBuffer.UVKind || attributeKind === VertexBuffer.UV2Kind) {\r\n                            if (glTFMaterial && !this._glTFMaterialExporter._hasTexturesPresent(glTFMaterial)) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        let vertexData = bufferMesh.getVerticesData(attributeKind);\r\n                        if (vertexData) {\r\n                            const vertexBuffer = this.getVertexBufferFromMesh(attributeKind, bufferMesh);\r\n                            if (vertexBuffer) {\r\n                                const stride = vertexBuffer.getSize();\r\n                                const bufferViewIndex = attribute.bufferViewIndex;\r\n                                if (bufferViewIndex != undefined) { // check to see if bufferviewindex has a numeric value assigned.\r\n                                    minMax = { min: null, max: null };\r\n                                    if (attributeKind == VertexBuffer.PositionKind) {\r\n                                        minMax = _GLTFUtilities._CalculateMinMaxPositions(vertexData, 0, vertexData.length / stride, convertToRightHandedSystem);\r\n                                    }\r\n                                    const accessor = _GLTFUtilities._CreateAccessor(bufferViewIndex, attributeKind + \" - \" + babylonTransformNode.name, attribute.accessorType, AccessorComponentType.FLOAT, vertexData.length / stride, 0, minMax.min, minMax.max);\r\n                                    this._accessors.push(accessor);\r\n                                    this.setAttributeKind(meshPrimitive, attributeKind);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if (indexBufferViewIndex) {\r\n                        // Create accessor\r\n                        const accessor = _GLTFUtilities._CreateAccessor(indexBufferViewIndex, \"indices - \" + babylonTransformNode.name, AccessorType.SCALAR, AccessorComponentType.UNSIGNED_INT, submesh.indexCount, submesh.indexStart * 4, null, null);\r\n                        this._accessors.push(accessor);\r\n                        meshPrimitive.indices = this._accessors.length - 1;\r\n                    }\r\n                    if (materialIndex != null && Object.keys(meshPrimitive.attributes).length > 0) {\r\n                        let sideOrientation = bufferMesh.overrideMaterialSideOrientation !== null ? bufferMesh.overrideMaterialSideOrientation : babylonMaterial.sideOrientation;\r\n\r\n                        if ((sideOrientation == Material.ClockWiseSideOrientation && this._babylonScene.useRightHandedSystem)\r\n                            || (sideOrientation == Material.ClockWiseSideOrientation && convertToRightHandedSystem && bufferMesh.overrideMaterialSideOrientation !== bufferMesh.material?.sideOrientation)) {\r\n                            let byteOffset = indexBufferViewIndex != null ? this._bufferViews[indexBufferViewIndex].byteOffset : null;\r\n                            if (byteOffset == null) { byteOffset = 0; }\r\n                            let babylonIndices: Nullable<IndicesArray> = null;\r\n                            if (indexBufferViewIndex != null) {\r\n                                babylonIndices = bufferMesh.getIndices();\r\n                            }\r\n                            if (babylonIndices) {\r\n                                this.reorderIndicesBasedOnPrimitiveMode(submesh, primitiveMode, babylonIndices, byteOffset, binaryWriter);\r\n                            }\r\n                            else {\r\n                                for (let attribute of attributeData) {\r\n                                    let vertexData = bufferMesh.getVerticesData(attribute.kind);\r\n                                    if (vertexData) {\r\n                                        let byteOffset = this._bufferViews[vertexAttributeBufferViews[attribute.kind]].byteOffset;\r\n                                        if (!byteOffset) {\r\n                                            byteOffset = 0;\r\n                                        }\r\n                                        this.reorderVertexAttributeDataBasedOnPrimitiveMode(submesh, primitiveMode, sideOrientation, attribute.kind, vertexData, byteOffset, binaryWriter, convertToRightHandedSystem);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        meshPrimitive.material = materialIndex;\r\n\r\n                    }\r\n                    mesh.primitives.push(meshPrimitive);\r\n\r\n                    const promise = this._extensionsPostExportMeshPrimitiveAsync(\"postExport\", meshPrimitive, submesh, binaryWriter);\r\n                    if (promise) {\r\n                        promises.push();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return Promise.all(promises).then(() => {\r\n            /* do nothing */\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if the node is used to convert its descendants from a right handed coordinate system to the Babylon scene's coordinate system.\r\n     * @param node The node to check\r\n     * @returns True if the node is used to convert its descendants from right-handed to left-handed. False otherwise\r\n     */\r\n    private isBabylonCoordinateSystemConvertingNode(node: Node): boolean {\r\n        if (node instanceof TransformNode)\r\n        {\r\n            if (node.name !== \"__root__\") {\r\n                return false;\r\n            }\r\n            // Transform\r\n            let matrix = node.getWorldMatrix();\r\n            let matrixToLeftHanded = Matrix.Compose(this._convertToRightHandedSystem ? new Vector3(-1, 1, 1) : Vector3.One(), Quaternion.Identity(), Vector3.Zero());\r\n            let matrixProduct = matrix.multiply(matrixToLeftHanded);\r\n            let matrixIdentity = Matrix.IdentityReadOnly;\r\n\r\n            for (let i = 0; i < 16; i++) {\r\n                if (Math.abs(matrixProduct.m[i] - matrixIdentity.m[i]) > Epsilon) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            // Geometry\r\n            if ((node instanceof Mesh && node.geometry !== null) ||\r\n                (node instanceof InstancedMesh && node.sourceMesh.geometry !== null)) {\r\n                return false;\r\n            }\r\n\r\n            if (this._includeCoordinateSystemConversionNodes) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF scene based on the array of meshes\r\n     * Returns the the total byte offset\r\n     * @param babylonScene Babylon scene to get the mesh data from\r\n     * @param binaryWriter Buffer to write binary data to\r\n     */\r\n    private createSceneAsync(babylonScene: Scene, binaryWriter: _BinaryWriter): Promise<void> {\r\n        const scene: IScene = { nodes: [] };\r\n        let glTFNodeIndex: number;\r\n        let glTFNode: INode;\r\n        let directDescendents: Node[];\r\n        const nodes: Node[] = [...babylonScene.transformNodes, ...babylonScene.meshes, ...babylonScene.lights];\r\n        let rootNodesToLeftHanded: Node[] = [];\r\n\r\n        this._convertToRightHandedSystem = !babylonScene.useRightHandedSystem;\r\n        this._convertToRightHandedSystemMap = {};\r\n\r\n        // Set default values for all nodes\r\n        babylonScene.rootNodes.forEach((rootNode) => {\r\n            this._convertToRightHandedSystemMap[rootNode.uniqueId] = this._convertToRightHandedSystem;\r\n            rootNode.getDescendants(false).forEach((descendant) => {\r\n                this._convertToRightHandedSystemMap[descendant.uniqueId] = this._convertToRightHandedSystem;\r\n            });\r\n        });\r\n\r\n        // Check if root nodes converting to left-handed are present\r\n        babylonScene.rootNodes.forEach((rootNode) => {\r\n            if (this.isBabylonCoordinateSystemConvertingNode(rootNode)) {\r\n                rootNodesToLeftHanded.push(rootNode);\r\n\r\n                // Exclude the node from list of nodes to export\r\n                const indexRootNode = nodes.indexOf(rootNode);\r\n                if (indexRootNode !== -1) { // should always be true\r\n                    nodes.splice(indexRootNode, 1);\r\n                }\r\n\r\n                // Cancel conversion to right handed system\r\n                rootNode.getDescendants(false).forEach((descendant) => {\r\n                    this._convertToRightHandedSystemMap[descendant.uniqueId] = false;\r\n                });\r\n            }\r\n        });\r\n\r\n        return this._glTFMaterialExporter._convertMaterialsToGLTFAsync(babylonScene.materials, ImageMimeType.PNG, true).then(() => {\r\n            return this.createNodeMapAndAnimationsAsync(babylonScene, nodes, binaryWriter).then((nodeMap) => {\r\n                this._nodeMap = nodeMap;\r\n\r\n                this._totalByteLength = binaryWriter.getByteOffset();\r\n                if (this._totalByteLength == undefined) {\r\n                    throw new Error(\"undefined byte length!\");\r\n                }\r\n\r\n                // Build Hierarchy with the node map.\r\n                for (let babylonNode of nodes) {\r\n                    glTFNodeIndex = this._nodeMap[babylonNode.uniqueId];\r\n                    if (glTFNodeIndex !== undefined) {\r\n                        glTFNode = this._nodes[glTFNodeIndex];\r\n\r\n                        if (babylonNode.metadata) {\r\n                            if (this._options.metadataSelector) {\r\n                                glTFNode.extras = this._options.metadataSelector(babylonNode.metadata);\r\n                            } else if (babylonNode.metadata.gltf) {\r\n                                glTFNode.extras = babylonNode.metadata.gltf.extras;\r\n                            }\r\n                        }\r\n\r\n                        if (!babylonNode.parent || rootNodesToLeftHanded.indexOf(babylonNode.parent) !== -1) {\r\n                            if (this._options.shouldExportNode && !this._options.shouldExportNode(babylonNode)) {\r\n                                Tools.Log(\"Omitting \" + babylonNode.name + \" from scene.\");\r\n                            }\r\n                            else {\r\n                                let convertToRightHandedSystem = this._convertToRightHandedSystemMap[babylonNode.uniqueId];\r\n                                if (convertToRightHandedSystem) {\r\n                                    if (glTFNode.translation) {\r\n                                        glTFNode.translation[2] *= -1;\r\n                                        glTFNode.translation[0] *= -1;\r\n                                    }\r\n                                    glTFNode.rotation = glTFNode.rotation ? Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(glTFNode.rotation)).asArray() : (Quaternion.FromArray([0, 1, 0, 0])).asArray();\r\n                                }\r\n\r\n                                scene.nodes.push(glTFNodeIndex);\r\n                            }\r\n                        }\r\n\r\n                        directDescendents = babylonNode.getDescendants(true);\r\n                        if (!glTFNode.children && directDescendents && directDescendents.length) {\r\n                            const children: number[] = [];\r\n                            for (let descendent of directDescendents) {\r\n                                if (this._nodeMap[descendent.uniqueId] != null) {\r\n                                    children.push(this._nodeMap[descendent.uniqueId]);\r\n                                }\r\n                            }\r\n                            if (children.length) {\r\n                                glTFNode.children = children;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (scene.nodes.length) {\r\n                    this._scenes.push(scene);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a mapping of Node unique id to node index and handles animations\r\n     * @param babylonScene Babylon Scene\r\n     * @param nodes Babylon transform nodes\r\n     * @param binaryWriter Buffer to write binary data to\r\n     * @returns Node mapping of unique id to index\r\n     */\r\n    private createNodeMapAndAnimationsAsync(babylonScene: Scene, nodes: Node[], binaryWriter: _BinaryWriter): Promise<{ [key: number]: number }> {\r\n        let promiseChain = Promise.resolve();\r\n        const nodeMap: { [key: number]: number } = {};\r\n        let nodeIndex: number;\r\n        let runtimeGLTFAnimation: IAnimation = {\r\n            name: 'runtime animations',\r\n            channels: [],\r\n            samplers: []\r\n        };\r\n        let idleGLTFAnimations: IAnimation[] = [];\r\n\r\n        for (let babylonNode of nodes) {\r\n            if (!this._options.shouldExportNode || this._options.shouldExportNode(babylonNode)) {\r\n                promiseChain = promiseChain.then(() => {\r\n                    let convertToRightHandedSystem = this._convertToRightHandedSystemMap[babylonNode.uniqueId];\r\n                    return this.createNodeAsync(babylonNode, binaryWriter, convertToRightHandedSystem, nodeMap).then((node) => {\r\n                        const promise = this._extensionsPostExportNodeAsync(\"createNodeAsync\", node, babylonNode, nodeMap);\r\n                        if (promise == null) {\r\n                            Tools.Warn(`Not exporting node ${babylonNode.name}`);\r\n                            return Promise.resolve();\r\n                        }\r\n                        else {\r\n                            return promise.then((node) => {\r\n                                if (!node) {\r\n                                    return;\r\n                                }\r\n                                this._nodes.push(node);\r\n                                nodeIndex = this._nodes.length - 1;\r\n                                nodeMap[babylonNode.uniqueId] = nodeIndex;\r\n\r\n                                if (!babylonScene.animationGroups.length && babylonNode.animations.length) {\r\n                                    _GLTFAnimation._CreateNodeAnimationFromNodeAnimations(babylonNode, runtimeGLTFAnimation, idleGLTFAnimations, nodeMap, this._nodes, binaryWriter, this._bufferViews, this._accessors, convertToRightHandedSystem, this._animationSampleRate);\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n            else {\r\n                `Excluding node ${babylonNode.name}`;\r\n            }\r\n        }\r\n\r\n        return promiseChain.then(() => {\r\n            if (runtimeGLTFAnimation.channels.length && runtimeGLTFAnimation.samplers.length) {\r\n                this._animations.push(runtimeGLTFAnimation);\r\n            }\r\n            idleGLTFAnimations.forEach((idleGLTFAnimation) => {\r\n                if (idleGLTFAnimation.channels.length && idleGLTFAnimation.samplers.length) {\r\n                    this._animations.push(idleGLTFAnimation);\r\n                }\r\n            });\r\n\r\n            if (babylonScene.animationGroups.length) {\r\n                _GLTFAnimation._CreateNodeAnimationFromAnimationGroups(babylonScene, this._animations, nodeMap, this._nodes, binaryWriter, this._bufferViews, this._accessors, this._convertToRightHandedSystemMap, this._animationSampleRate);\r\n            }\r\n\r\n            return nodeMap;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF node from a Babylon mesh\r\n     * @param babylonMesh Source Babylon mesh\r\n     * @param binaryWriter Buffer for storing geometry data\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     * @param nodeMap Node mapping of unique id to glTF node index\r\n     * @returns glTF node\r\n     */\r\n    private createNodeAsync(babylonNode: Node, binaryWriter: _BinaryWriter, convertToRightHandedSystem: boolean, nodeMap?: {[key: number]: number}): Promise<INode> {\r\n        return Promise.resolve().then(() => {\r\n            // create node to hold translation/rotation/scale and the mesh\r\n            const node: INode = {};\r\n            // create mesh\r\n            const mesh: IMesh = { primitives: [] };\r\n\r\n            if (babylonNode.name) {\r\n                node.name = babylonNode.name;\r\n            }\r\n\r\n            if (babylonNode instanceof TransformNode) {\r\n                // Set transformation\r\n                this.setNodeTransformation(node, babylonNode, convertToRightHandedSystem);\r\n\r\n                return this.setPrimitiveAttributesAsync(mesh, babylonNode, binaryWriter, convertToRightHandedSystem).then(() => {\r\n                    if (mesh.primitives.length) {\r\n                        this._meshes.push(mesh);\r\n                        node.mesh = this._meshes.length - 1;\r\n                    }\r\n                    return node;\r\n                });\r\n            }\r\n            else {\r\n                return node;\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * @hidden\r\n *\r\n * Stores glTF binary data.  If the array buffer byte length is exceeded, it doubles in size dynamically\r\n */\r\nexport class _BinaryWriter {\r\n    /**\r\n     * Array buffer which stores all binary data\r\n     */\r\n    private _arrayBuffer: ArrayBuffer;\r\n    /**\r\n     * View of the array buffer\r\n     */\r\n    private _dataView: DataView;\r\n    /**\r\n     * byte offset of data in array buffer\r\n     */\r\n    private _byteOffset: number;\r\n    /**\r\n     * Initialize binary writer with an initial byte length\r\n     * @param byteLength Initial byte length of the array buffer\r\n     */\r\n    constructor(byteLength: number) {\r\n        this._arrayBuffer = new ArrayBuffer(byteLength);\r\n        this._dataView = new DataView(this._arrayBuffer);\r\n        this._byteOffset = 0;\r\n    }\r\n    /**\r\n     * Resize the array buffer to the specified byte length\r\n     * @param byteLength\r\n     */\r\n    private resizeBuffer(byteLength: number): ArrayBuffer {\r\n        let newBuffer = new ArrayBuffer(byteLength);\r\n        let oldUint8Array = new Uint8Array(this._arrayBuffer);\r\n        let newUint8Array = new Uint8Array(newBuffer);\r\n        for (let i = 0, length = newUint8Array.byteLength; i < length; ++i) {\r\n            newUint8Array[i] = oldUint8Array[i];\r\n        }\r\n        this._arrayBuffer = newBuffer;\r\n        this._dataView = new DataView(this._arrayBuffer);\r\n\r\n        return newBuffer;\r\n    }\r\n    /**\r\n     * Get an array buffer with the length of the byte offset\r\n     * @returns ArrayBuffer resized to the byte offset\r\n     */\r\n    public getArrayBuffer(): ArrayBuffer {\r\n        return this.resizeBuffer(this.getByteOffset());\r\n    }\r\n    /**\r\n     * Get the byte offset of the array buffer\r\n     * @returns byte offset\r\n     */\r\n    public getByteOffset(): number {\r\n        if (this._byteOffset == undefined) {\r\n            throw new Error(\"Byte offset is undefined!\");\r\n        }\r\n        return this._byteOffset;\r\n    }\r\n    /**\r\n     * Stores an UInt8 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setUInt8(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setUint8(byteOffset, entry);\r\n            }\r\n            else {\r\n                Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n            }\r\n        }\r\n        else {\r\n            if (this._byteOffset + 1 > this._arrayBuffer.byteLength) {\r\n                this.resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setUint8(this._byteOffset++, entry);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets an UInt32 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public getUInt32(byteOffset: number): number {\r\n        if (byteOffset < this._byteOffset) {\r\n            return this._dataView.getUint32(byteOffset, true);\r\n        }\r\n        else {\r\n            Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n            throw new Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n        }\r\n    }\r\n\r\n    public getVector3Float32FromRef(vector3: Vector3, byteOffset: number): void {\r\n        if (byteOffset + 8 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            vector3.x = this._dataView.getFloat32(byteOffset, true);\r\n            vector3.y = this._dataView.getFloat32(byteOffset + 4, true);\r\n            vector3.z = this._dataView.getFloat32(byteOffset + 8, true);\r\n        }\r\n    }\r\n\r\n    public setVector3Float32FromRef(vector3: Vector3, byteOffset: number): void {\r\n        if (byteOffset + 8 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            this._dataView.setFloat32(byteOffset, vector3.x, true);\r\n            this._dataView.setFloat32(byteOffset + 4, vector3.y, true);\r\n            this._dataView.setFloat32(byteOffset + 8, vector3.z, true);\r\n        }\r\n    }\r\n\r\n    public getVector4Float32FromRef(vector4: Vector4, byteOffset: number): void {\r\n        if (byteOffset + 12 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            vector4.x = this._dataView.getFloat32(byteOffset, true);\r\n            vector4.y = this._dataView.getFloat32(byteOffset + 4, true);\r\n            vector4.z = this._dataView.getFloat32(byteOffset + 8, true);\r\n            vector4.w = this._dataView.getFloat32(byteOffset + 12, true);\r\n        }\r\n    }\r\n\r\n    public setVector4Float32FromRef(vector4: Vector4, byteOffset: number): void {\r\n        if (byteOffset + 12 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            this._dataView.setFloat32(byteOffset, vector4.x, true);\r\n            this._dataView.setFloat32(byteOffset + 4, vector4.y, true);\r\n            this._dataView.setFloat32(byteOffset + 8, vector4.z, true);\r\n            this._dataView.setFloat32(byteOffset + 12, vector4.w, true);\r\n        }\r\n    }\r\n    /**\r\n     * Stores a Float32 in the array buffer\r\n     * @param entry\r\n     */\r\n    public setFloat32(entry: number, byteOffset?: number) {\r\n        if (isNaN(entry)) {\r\n            Tools.Error('Invalid data being written!');\r\n        }\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setFloat32(byteOffset, entry, true);\r\n            }\r\n            else {\r\n                Tools.Error('BinaryWriter: byteoffset is greater than the current binary length!');\r\n            }\r\n        }\r\n        if (this._byteOffset + 4 > this._arrayBuffer.byteLength) {\r\n            this.resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n        }\r\n        this._dataView.setFloat32(this._byteOffset, entry, true);\r\n        this._byteOffset += 4;\r\n    }\r\n    /**\r\n     * Stores an UInt32 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setUInt32(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setUint32(byteOffset, entry, true);\r\n            }\r\n            else {\r\n                Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n            }\r\n        }\r\n        else {\r\n            if (this._byteOffset + 4 > this._arrayBuffer.byteLength) {\r\n                this.resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setUint32(this._byteOffset, entry, true);\r\n            this._byteOffset += 4;\r\n        }\r\n    }\r\n}","import { ImageMimeType, IMeshPrimitive, INode, IMaterial, ITextureInfo } from \"babylonjs-gltf2interface\";\r\nimport { Node } from \"babylonjs/node\";\r\nimport { Nullable } from \"babylonjs/types\";\r\n\r\nimport { Texture } from \"babylonjs/Materials/Textures/texture\";\r\nimport { SubMesh } from \"babylonjs/Meshes/subMesh\";\r\nimport { IDisposable } from \"babylonjs/scene\";\r\n\r\nimport { _BinaryWriter } from \"./glTFExporter\";\r\nimport { IGLTFExporterExtension } from \"../glTFFileExporter\";\r\nimport { Material } from 'babylonjs/Materials/material';\r\nimport { BaseTexture } from 'babylonjs/Materials/Textures/baseTexture';\r\n\r\n/** @hidden */\r\nexport var __IGLTFExporterExtensionV2 = 0; // I am here to allow dts to be created\r\n\r\n/**\r\n * Interface for a glTF exporter extension\r\n * @hidden\r\n */\r\nexport interface IGLTFExporterExtensionV2 extends IGLTFExporterExtension, IDisposable {\r\n    /**\r\n     * Define this method to modify the default behavior before exporting a texture\r\n     * @param context The context when loading the asset\r\n     * @param babylonTexture The Babylon.js texture\r\n     * @param mimeType The mime-type of the generated image\r\n     * @returns A promise that resolves with the exported texture\r\n     */\r\n    preExportTextureAsync?(context: string, babylonTexture: Nullable<Texture>, mimeType: ImageMimeType): Promise<Texture>;\r\n\r\n    /**\r\n     * Define this method to get notified when a texture info is created\r\n     * @param context The context when loading the asset\r\n     * @param textureInfo The glTF texture info\r\n     * @param babylonTexture The Babylon.js texture\r\n     */\r\n    postExportTexture?(context: string, textureInfo: ITextureInfo, babylonTexture: BaseTexture): void;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when exporting texture info\r\n     * @param context The context when loading the asset\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param babylonSubMesh Babylon submesh\r\n     * @param binaryWriter glTF serializer binary writer instance\r\n     * @returns nullable IMeshPrimitive promise\r\n     */\r\n    postExportMeshPrimitiveAsync?(context: string, meshPrimitive: Nullable<IMeshPrimitive>, babylonSubMesh: SubMesh, binaryWriter: _BinaryWriter): Promise<IMeshPrimitive>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when exporting a node\r\n     * @param context The context when exporting the node\r\n     * @param node glTF node\r\n     * @param babylonNode BabylonJS node\r\n     * @returns nullable INode promise\r\n     */\r\n    postExportNodeAsync?(context: string, node: Nullable<INode>, babylonNode: Node, nodeMap?: {[key: number]: number}): Promise<Nullable<INode>>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when exporting a material\r\n     * @param material glTF material\r\n     * @param babylonMaterial BabylonJS material\r\n     * @returns nullable IMaterial promise\r\n     */\r\n    postExportMaterialAsync?(context: string, node: Nullable<IMaterial>, babylonMaterial: Material): Promise<IMaterial>;\r\n\r\n    /**\r\n     * Define this method to return additional textures to export from a material\r\n     * @param material glTF material\r\n     * @param babylonMaterial BabylonJS material\r\n     * @returns List of textures\r\n     */\r\n    postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[];\r\n\r\n    /** Gets a boolean indicating that this extension was used */\r\n    wasUsed: boolean;\r\n\r\n    /** Gets a boolean indicating that this extension is required for the file to work */\r\n    required: boolean;\r\n\r\n    /**\r\n     * Called after the exporter state changes to EXPORTING\r\n     */\r\n    onExporting?(): void;\r\n}","import { ITextureInfo, ImageMimeType, IMaterial, IMaterialPbrMetallicRoughness, MaterialAlphaMode, IMaterialOcclusionTextureInfo, ISampler, TextureMagFilter, TextureMinFilter, TextureWrapMode, ITexture, IImage } from \"babylonjs-gltf2interface\";\r\n\r\nimport { Nullable } from \"babylonjs/types\";\r\nimport { Vector2 } from \"babylonjs/Maths/math.vector\";\r\nimport { Color3 } from \"babylonjs/Maths/math.color\";\r\nimport { Scalar } from \"babylonjs/Maths/math.scalar\";\r\nimport { Tools } from \"babylonjs/Misc/tools\";\r\nimport { TextureTools } from \"babylonjs/Misc/textureTools\";\r\nimport { BaseTexture } from \"babylonjs/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"babylonjs/Materials/Textures/texture\";\r\nimport { RawTexture } from \"babylonjs/Materials/Textures/rawTexture\";\r\nimport { Material } from \"babylonjs/Materials/material\";\r\nimport { StandardMaterial } from \"babylonjs/Materials/standardMaterial\";\r\nimport { PBRMaterial } from \"babylonjs/Materials/PBR/pbrMaterial\";\r\nimport { PBRMetallicRoughnessMaterial } from \"babylonjs/Materials/PBR/pbrMetallicRoughnessMaterial\";\r\nimport { PostProcess } from \"babylonjs/PostProcesses/postProcess\";\r\nimport { Scene } from \"babylonjs/scene\";\r\n\r\nimport { _Exporter } from \"./glTFExporter\";\r\nimport { Constants } from 'babylonjs/Engines/constants';\r\n\r\n/**\r\n * Interface for storing specular glossiness factors\r\n * @hidden\r\n */\r\ninterface _IPBRSpecularGlossiness {\r\n    /**\r\n     * Represents the linear diffuse factors of the material\r\n    */\r\n    diffuseColor: Color3;\r\n    /**\r\n     * Represents the linear specular factors of the material\r\n    */\r\n    specularColor: Color3;\r\n    /**\r\n     * Represents the smoothness of the material\r\n    */\r\n    glossiness: number;\r\n}\r\n\r\n/**\r\n * Interface for storing metallic roughness factors\r\n * @hidden\r\n */\r\ninterface _IPBRMetallicRoughness {\r\n    /**\r\n     * Represents the albedo color of the material\r\n    */\r\n    baseColor: Color3;\r\n    /**\r\n     * Represents the metallness of the material\r\n    */\r\n    metallic: Nullable<number>;\r\n    /**\r\n     * Represents the roughness of the material\r\n    */\r\n    roughness: Nullable<number>;\r\n    /**\r\n     * The metallic roughness texture as a base64 string\r\n    */\r\n    metallicRoughnessTextureBase64?: Nullable<string>;\r\n    /**\r\n     * The base color texture as a base64 string\r\n    */\r\n    baseColorTextureBase64?: Nullable<string>;\r\n}\r\n\r\n/**\r\n * Utility methods for working with glTF material conversion properties.  This class should only be used internally\r\n * @hidden\r\n */\r\nexport class _GLTFMaterialExporter {\r\n    /**\r\n     * Represents the dielectric specular values for R, G and B\r\n     */\r\n    private static readonly _DielectricSpecular: Color3 = new Color3(0.04, 0.04, 0.04);\r\n\r\n    /**\r\n     * Allows the maximum specular power to be defined for material calculations\r\n     */\r\n    private static readonly _MaxSpecularPower = 1024;\r\n\r\n    /**\r\n     * Mapping to store textures\r\n     */\r\n    private _textureMap: { [textureId: string]: ITextureInfo } = {};\r\n\r\n    /**\r\n     * Numeric tolerance value\r\n     */\r\n    private static readonly _Epsilon = 1e-6;\r\n\r\n    /**\r\n     * Reference to the glTF Exporter\r\n     */\r\n    private _exporter: _Exporter;\r\n\r\n    constructor(exporter: _Exporter) {\r\n        this._textureMap = {};\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /**\r\n     * Specifies if two colors are approximately equal in value\r\n     * @param color1 first color to compare to\r\n     * @param color2 second color to compare to\r\n     * @param epsilon threshold value\r\n     */\r\n    private static FuzzyEquals(color1: Color3, color2: Color3, epsilon: number): boolean {\r\n        return Scalar.WithinEpsilon(color1.r, color2.r, epsilon) &&\r\n            Scalar.WithinEpsilon(color1.g, color2.g, epsilon) &&\r\n            Scalar.WithinEpsilon(color1.b, color2.b, epsilon);\r\n    }\r\n\r\n    /**\r\n     * Gets the materials from a Babylon scene and converts them to glTF materials\r\n     * @param scene babylonjs scene\r\n     * @param mimeType texture mime type\r\n     * @param images array of images\r\n     * @param textures array of textures\r\n     * @param materials array of materials\r\n     * @param imageData mapping of texture names to base64 textures\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the material\r\n     */\r\n    public _convertMaterialsToGLTFAsync(babylonMaterials: Material[], mimeType: ImageMimeType, hasTextureCoords: boolean) {\r\n        let promises: Promise<IMaterial>[] = [];\r\n        for (let babylonMaterial of babylonMaterials) {\r\n            if (babylonMaterial instanceof StandardMaterial) {\r\n                promises.push(this._convertStandardMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));\r\n            }\r\n            else if (babylonMaterial instanceof PBRMetallicRoughnessMaterial) {\r\n                promises.push(this._convertPBRMetallicRoughnessMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));\r\n            }\r\n            else if (babylonMaterial instanceof PBRMaterial) {\r\n                promises.push(this._convertPBRMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));\r\n            }\r\n            else {\r\n                Tools.Warn(`Unsupported material type: ${babylonMaterial.name}`);\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => { /* do nothing */ });\r\n    }\r\n\r\n    /**\r\n     * Makes a copy of the glTF material without the texture parameters\r\n     * @param originalMaterial original glTF material\r\n     * @returns glTF material without texture parameters\r\n     */\r\n    public _stripTexturesFromMaterial(originalMaterial: IMaterial): IMaterial {\r\n        let newMaterial: IMaterial = {};\r\n        if (originalMaterial) {\r\n            newMaterial.name = originalMaterial.name;\r\n            newMaterial.doubleSided = originalMaterial.doubleSided;\r\n            newMaterial.alphaMode = originalMaterial.alphaMode;\r\n            newMaterial.alphaCutoff = originalMaterial.alphaCutoff;\r\n            newMaterial.emissiveFactor = originalMaterial.emissiveFactor;\r\n            const originalPBRMetallicRoughness = originalMaterial.pbrMetallicRoughness;\r\n            if (originalPBRMetallicRoughness) {\r\n                newMaterial.pbrMetallicRoughness = {};\r\n                newMaterial.pbrMetallicRoughness.baseColorFactor = originalPBRMetallicRoughness.baseColorFactor;\r\n                newMaterial.pbrMetallicRoughness.metallicFactor = originalPBRMetallicRoughness.metallicFactor;\r\n                newMaterial.pbrMetallicRoughness.roughnessFactor = originalPBRMetallicRoughness.roughnessFactor;\r\n            }\r\n        }\r\n        return newMaterial;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material has any texture parameters present\r\n     * @param material glTF Material\r\n     * @returns boolean specifying if texture parameters are present\r\n     */\r\n    public _hasTexturesPresent(material: IMaterial): boolean {\r\n        if (material.emissiveTexture || material.normalTexture || material.occlusionTexture) {\r\n            return true;\r\n        }\r\n        const pbrMat = material.pbrMetallicRoughness;\r\n        if (pbrMat) {\r\n            if (pbrMat.baseColorTexture || pbrMat.metallicRoughnessTexture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon StandardMaterial to a glTF Metallic Roughness Material\r\n     * @param babylonStandardMaterial\r\n     * @returns glTF Metallic Roughness Material representation\r\n     */\r\n    public _convertToGLTFPBRMetallicRoughness(babylonStandardMaterial: StandardMaterial): IMaterialPbrMetallicRoughness {\r\n        const P0 = new Vector2(0, 1);\r\n        const P1 = new Vector2(0, 0.1);\r\n        const P2 = new Vector2(0, 0.1);\r\n        const P3 = new Vector2(1300, 0.1);\r\n\r\n        /**\r\n         * Given the control points, solve for x based on a given t for a cubic bezier curve\r\n         * @param t a value between 0 and 1\r\n         * @param p0 first control point\r\n         * @param p1 second control point\r\n         * @param p2 third control point\r\n         * @param p3 fourth control point\r\n         * @returns number result of cubic bezier curve at the specified t\r\n         */\r\n        function _cubicBezierCurve(t: number, p0: number, p1: number, p2: number, p3: number): number {\r\n            return (\r\n                (1 - t) * (1 - t) * (1 - t) * p0 +\r\n                3 * (1 - t) * (1 - t) * t * p1 +\r\n                3 * (1 - t) * t * t * p2 +\r\n                t * t * t * p3\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Evaluates a specified specular power value to determine the appropriate roughness value,\r\n         * based on a pre-defined cubic bezier curve with specular on the abscissa axis (x-axis)\r\n         * and roughness on the ordinant axis (y-axis)\r\n         * @param specularPower specular power of standard material\r\n         * @returns Number representing the roughness value\r\n         */\r\n        function _solveForRoughness(specularPower: number): number {\r\n            var t = Math.pow(specularPower / P3.x, 0.333333);\r\n            return _cubicBezierCurve(t, P0.y, P1.y, P2.y, P3.y);\r\n        }\r\n\r\n        let diffuse = babylonStandardMaterial.diffuseColor.toLinearSpace().scale(0.5);\r\n        let opacity = babylonStandardMaterial.alpha;\r\n        let specularPower = Scalar.Clamp(babylonStandardMaterial.specularPower, 0, _GLTFMaterialExporter._MaxSpecularPower);\r\n\r\n        const roughness = _solveForRoughness(specularPower);\r\n\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {\r\n            baseColorFactor: [\r\n                diffuse.r,\r\n                diffuse.g,\r\n                diffuse.b,\r\n                opacity\r\n            ],\r\n            metallicFactor: 0,\r\n            roughnessFactor: roughness,\r\n        };\r\n\r\n        return glTFPbrMetallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Computes the metallic factor\r\n     * @param diffuse diffused value\r\n     * @param specular specular value\r\n     * @param oneMinusSpecularStrength one minus the specular strength\r\n     * @returns metallic value\r\n     */\r\n    public static _SolveMetallic(diffuse: number, specular: number, oneMinusSpecularStrength: number): number {\r\n        if (specular < this._DielectricSpecular.r) {\r\n            this._DielectricSpecular;\r\n            return 0;\r\n        }\r\n\r\n        const a = this._DielectricSpecular.r;\r\n        const b = diffuse * oneMinusSpecularStrength / (1.0 - this._DielectricSpecular.r) + specular - 2.0 * this._DielectricSpecular.r;\r\n        const c = this._DielectricSpecular.r - specular;\r\n        const D = b * b - 4.0 * a * c;\r\n        return Scalar.Clamp((-b + Math.sqrt(D)) / (2.0 * a), 0, 1);\r\n    }\r\n\r\n    /**\r\n     * Sets the glTF alpha mode to a glTF material from the Babylon Material\r\n     * @param glTFMaterial glTF material\r\n     * @param babylonMaterial Babylon material\r\n     */\r\n    private static _SetAlphaMode(glTFMaterial: IMaterial, babylonMaterial: Material & { alphaCutOff: number }): void {\r\n        if (babylonMaterial.needAlphaBlending()) {\r\n            glTFMaterial.alphaMode = MaterialAlphaMode.BLEND;\r\n        }\r\n        else if (babylonMaterial.needAlphaTesting()) {\r\n            glTFMaterial.alphaMode = MaterialAlphaMode.MASK;\r\n            glTFMaterial.alphaCutoff = babylonMaterial.alphaCutOff;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon Standard Material to a glTF Material\r\n     * @param babylonStandardMaterial BJS Standard Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param materials array of glTF material interfaces\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertStandardMaterialAsync(babylonStandardMaterial: StandardMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<IMaterial> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        const promises = [];\r\n        const glTFPbrMetallicRoughness = this._convertToGLTFPBRMetallicRoughness(babylonStandardMaterial);\r\n\r\n        const glTFMaterial: IMaterial = { name: babylonStandardMaterial.name };\r\n        if (babylonStandardMaterial.backFaceCulling != null && !babylonStandardMaterial.backFaceCulling) {\r\n            if (!babylonStandardMaterial.twoSidedLighting) {\r\n                Tools.Warn(babylonStandardMaterial.name + \": Back-face culling enabled and two-sided lighting disabled is not supported in glTF.\");\r\n            }\r\n            glTFMaterial.doubleSided = true;\r\n        }\r\n        if (hasTextureCoords) {\r\n            if (babylonStandardMaterial.diffuseTexture) {\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.diffuseTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonStandardMaterial.bumpTexture) {\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.bumpTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.normalTexture = glTFTexture;\r\n                        if (babylonStandardMaterial.bumpTexture != null && babylonStandardMaterial.bumpTexture.level !== 1) {\r\n                            glTFMaterial.normalTexture.scale = babylonStandardMaterial.bumpTexture.level;\r\n                        }\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonStandardMaterial.emissiveTexture) {\r\n                glTFMaterial.emissiveFactor = [1.0, 1.0, 1.0];\r\n\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.emissiveTexture, mimeType).then((glTFEmissiveTexture) => {\r\n                    if (glTFEmissiveTexture) {\r\n                        glTFMaterial.emissiveTexture = glTFEmissiveTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonStandardMaterial.ambientTexture) {\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.ambientTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        const occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                            index: glTFTexture.index\r\n                        };\r\n                        glTFMaterial.occlusionTexture = occlusionTexture;\r\n                        occlusionTexture.strength = 1.0;\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n\r\n        if (babylonStandardMaterial.alpha < 1.0 || babylonStandardMaterial.opacityTexture) {\r\n            if (babylonStandardMaterial.alphaMode === Constants.ALPHA_COMBINE) {\r\n                glTFMaterial.alphaMode = MaterialAlphaMode.BLEND;\r\n            }\r\n            else {\r\n                Tools.Warn(babylonStandardMaterial.name + \": glTF 2.0 does not support alpha mode: \" + babylonStandardMaterial.alphaMode.toString());\r\n            }\r\n        }\r\n        if (babylonStandardMaterial.emissiveColor && !_GLTFMaterialExporter.FuzzyEquals(babylonStandardMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n            glTFMaterial.emissiveFactor = babylonStandardMaterial.emissiveColor.asArray();\r\n        }\r\n\r\n        glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n        _GLTFMaterialExporter._SetAlphaMode(glTFMaterial, babylonStandardMaterial);\r\n\r\n        materials.push(glTFMaterial);\r\n        materialMap[babylonStandardMaterial.uniqueId] = materials.length - 1;\r\n\r\n        return this._finishMaterial(promises, glTFMaterial, babylonStandardMaterial, mimeType);\r\n    }\r\n\r\n    private _finishMaterial<T>(promises: Promise<T>[], glTFMaterial: IMaterial, babylonMaterial: Material, mimeType: ImageMimeType) {\r\n        return Promise.all(promises).then(() => {\r\n\r\n            const textures = this._exporter._extensionsPostExportMaterialAdditionalTextures(\"exportMaterial\", glTFMaterial, babylonMaterial);\r\n            let tasks: Nullable<Promise<Nullable<ITextureInfo>>[]> = null;\r\n\r\n            for (var texture of textures) {\r\n                if (!tasks) {\r\n                    tasks = [];\r\n                }\r\n                tasks.push(this._exportTextureAsync(texture, mimeType));\r\n            }\r\n\r\n            if (!tasks) {\r\n                tasks = [Promise.resolve(null)];\r\n            }\r\n\r\n            return Promise.all(tasks).then(() => {\r\n                let extensionWork = this._exporter._extensionsPostExportMaterialAsync(\"exportMaterial\", glTFMaterial, babylonMaterial);\r\n                if (!extensionWork) {\r\n                    return glTFMaterial;\r\n                }\r\n                return extensionWork.then(() => glTFMaterial);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon PBR Metallic Roughness Material to a glTF Material\r\n     * @param babylonPBRMetalRoughMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param materials array of glTF material interfaces\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertPBRMetallicRoughnessMaterialAsync(babylonPBRMetalRoughMaterial: PBRMetallicRoughnessMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<IMaterial> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        let promises: Promise<void>[] = [];\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {};\r\n\r\n        if (babylonPBRMetalRoughMaterial.baseColor) {\r\n            glTFPbrMetallicRoughness.baseColorFactor = [\r\n                babylonPBRMetalRoughMaterial.baseColor.r,\r\n                babylonPBRMetalRoughMaterial.baseColor.g,\r\n                babylonPBRMetalRoughMaterial.baseColor.b,\r\n                babylonPBRMetalRoughMaterial.alpha\r\n            ];\r\n        }\r\n\r\n        if (babylonPBRMetalRoughMaterial.metallic != null && babylonPBRMetalRoughMaterial.metallic !== 1) {\r\n            glTFPbrMetallicRoughness.metallicFactor = babylonPBRMetalRoughMaterial.metallic;\r\n        }\r\n        if (babylonPBRMetalRoughMaterial.roughness != null && babylonPBRMetalRoughMaterial.roughness !== 1) {\r\n            glTFPbrMetallicRoughness.roughnessFactor = babylonPBRMetalRoughMaterial.roughness;\r\n        }\r\n\r\n        const glTFMaterial: IMaterial = {\r\n            name: babylonPBRMetalRoughMaterial.name\r\n        };\r\n        if (babylonPBRMetalRoughMaterial.doubleSided) {\r\n            glTFMaterial.doubleSided = babylonPBRMetalRoughMaterial.doubleSided;\r\n        }\r\n        _GLTFMaterialExporter._SetAlphaMode(glTFMaterial, babylonPBRMetalRoughMaterial);\r\n        if (hasTextureCoords) {\r\n            if (babylonPBRMetalRoughMaterial.baseTexture != null) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.baseTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonPBRMetalRoughMaterial.normalTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.normalTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.normalTexture = glTFTexture;\r\n                        if (babylonPBRMetalRoughMaterial.normalTexture.level !== 1) {\r\n                            glTFMaterial.normalTexture.scale = babylonPBRMetalRoughMaterial.normalTexture.level;\r\n                        }\r\n                    }\r\n                }));\r\n\r\n            }\r\n            if (babylonPBRMetalRoughMaterial.occlusionTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.occlusionTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.occlusionTexture = glTFTexture;\r\n                        if (babylonPBRMetalRoughMaterial.occlusionStrength != null) {\r\n                            glTFMaterial.occlusionTexture.strength = babylonPBRMetalRoughMaterial.occlusionStrength;\r\n                        }\r\n                    }\r\n                }));\r\n\r\n            }\r\n            if (babylonPBRMetalRoughMaterial.emissiveTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.emissiveTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.emissiveTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n\r\n        }\r\n\r\n        if (_GLTFMaterialExporter.FuzzyEquals(babylonPBRMetalRoughMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n            glTFMaterial.emissiveFactor = babylonPBRMetalRoughMaterial.emissiveColor.asArray();\r\n        }\r\n\r\n        glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n\r\n        materials.push(glTFMaterial);\r\n        materialMap[babylonPBRMetalRoughMaterial.uniqueId] = materials.length - 1;\r\n\r\n        return this._finishMaterial(promises, glTFMaterial, babylonPBRMetalRoughMaterial, mimeType);\r\n    }\r\n\r\n    /**\r\n     * Converts an image typed array buffer to a base64 image\r\n     * @param buffer typed array buffer\r\n     * @param width width of the image\r\n     * @param height height of the image\r\n     * @param mimeType mimetype of the image\r\n     * @returns base64 image string\r\n     */\r\n    private _createBase64FromCanvasAsync(buffer: Uint8Array | Float32Array, width: number, height: number, mimeType: ImageMimeType): Promise<string> {\r\n        return new Promise<string>((resolve, reject) => {\r\n            let hostingScene: Scene;\r\n\r\n            const textureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            const engine = this._exporter._getLocalEngine();\r\n\r\n            hostingScene = new Scene(engine);\r\n\r\n            // Create a temporary texture with the texture buffer data\r\n            const tempTexture = engine.createRawTexture(buffer, width, height, Constants.TEXTUREFORMAT_RGBA, false, true, Texture.NEAREST_SAMPLINGMODE, null, textureType);\r\n            const postProcess = new PostProcess(\"pass\", \"pass\", null, null, 1, null, Texture.NEAREST_SAMPLINGMODE, engine, false, undefined, Constants.TEXTURETYPE_UNSIGNED_INT, undefined, null, false);\r\n            postProcess.getEffect().executeWhenCompiled(() => {\r\n                postProcess.onApply = (effect) => {\r\n                    effect._bindTexture(\"textureSampler\", tempTexture);\r\n                };\r\n\r\n                // Set the size of the texture\r\n                engine.setSize(width, height);\r\n                hostingScene.postProcessManager.directRender([postProcess], null);\r\n                postProcess.dispose();\r\n                tempTexture.dispose();\r\n\r\n                // Read data from WebGL\r\n                const canvas = engine.getRenderingCanvas();\r\n\r\n                if (canvas) {\r\n                    if (!canvas.toBlob) { // fallback for browsers without \"canvas.toBlob\"\r\n                        const dataURL = canvas.toDataURL();\r\n                        resolve(dataURL);\r\n                    }\r\n                    else {\r\n                        Tools.ToBlob(canvas, (blob) => {\r\n                            if (blob) {\r\n                                let fileReader = new FileReader();\r\n                                fileReader.onload = (event: any) => {\r\n                                    let base64String = event.target.result as string;\r\n                                    hostingScene.dispose();\r\n                                    resolve(base64String);\r\n                                };\r\n                                fileReader.readAsDataURL(blob);\r\n                            }\r\n                            else {\r\n                                reject(\"gltfMaterialExporter: Failed to get blob from image canvas!\");\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    reject(\"Engine is missing a canvas!\");\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generates a white texture based on the specified width and height\r\n     * @param width width of the texture in pixels\r\n     * @param height height of the texture in pixels\r\n     * @param scene babylonjs scene\r\n     * @returns white texture\r\n     */\r\n    private _createWhiteTexture(width: number, height: number, scene: Scene): Texture {\r\n        const data = new Uint8Array(width * height * 4);\r\n\r\n        for (let i = 0; i < data.length; i = i + 4) {\r\n            data[i] = data[i + 1] = data[i + 2] = data[i + 3] = 0xFF;\r\n        }\r\n\r\n        const rawTexture = RawTexture.CreateRGBATexture(data, width, height, scene);\r\n\r\n        return rawTexture;\r\n    }\r\n\r\n    /**\r\n     * Resizes the two source textures to the same dimensions.  If a texture is null, a default white texture is generated.  If both textures are null, returns null\r\n     * @param texture1 first texture to resize\r\n     * @param texture2 second texture to resize\r\n     * @param scene babylonjs scene\r\n     * @returns resized textures or null\r\n     */\r\n    private _resizeTexturesToSameDimensions(texture1: BaseTexture, texture2: BaseTexture, scene: Scene): { \"texture1\": BaseTexture, \"texture2\": BaseTexture } {\r\n        let texture1Size = texture1 ? texture1.getSize() : { width: 0, height: 0 };\r\n        let texture2Size = texture2 ? texture2.getSize() : { width: 0, height: 0 };\r\n        let resizedTexture1;\r\n        let resizedTexture2;\r\n\r\n        if (texture1Size.width < texture2Size.width) {\r\n            if (texture1 && texture1 instanceof Texture) {\r\n                resizedTexture1 = TextureTools.CreateResizedCopy(texture1, texture2Size.width, texture2Size.height, true);\r\n            }\r\n            else {\r\n                resizedTexture1 = this._createWhiteTexture(texture2Size.width, texture2Size.height, scene);\r\n            }\r\n            resizedTexture2 = texture2;\r\n        }\r\n        else if (texture1Size.width > texture2Size.width) {\r\n            if (texture2 && texture2 instanceof Texture) {\r\n                resizedTexture2 = TextureTools.CreateResizedCopy(texture2, texture1Size.width, texture1Size.height, true);\r\n            }\r\n            else {\r\n                resizedTexture2 = this._createWhiteTexture(texture1Size.width, texture1Size.height, scene);\r\n            }\r\n            resizedTexture1 = texture1;\r\n        }\r\n        else {\r\n            resizedTexture1 = texture1;\r\n            resizedTexture2 = texture2;\r\n        }\r\n\r\n        return {\r\n            \"texture1\": resizedTexture1,\r\n            \"texture2\": resizedTexture2\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Converts an array of pixels to a Float32Array\r\n     * Throws an error if the pixel format is not supported\r\n     * @param pixels - array buffer containing pixel values\r\n     * @returns Float32 of pixels\r\n     */\r\n    private _convertPixelArrayToFloat32(pixels: ArrayBufferView): Float32Array {\r\n        if (pixels instanceof Uint8Array) {\r\n            const length = pixels.length;\r\n            const buffer = new Float32Array(pixels.length);\r\n            for (let i = 0; i < length; ++i) {\r\n                buffer[i] = pixels[i] / 255;\r\n            }\r\n            return buffer;\r\n        }\r\n        else if (pixels instanceof Float32Array) {\r\n            return pixels;\r\n        }\r\n        else {\r\n            throw new Error('Unsupported pixel format!');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert Specular Glossiness Textures to Metallic Roughness\r\n     * See link below for info on the material conversions from PBR Metallic/Roughness and Specular/Glossiness\r\n     * @link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows-bjs/js/babylon.pbrUtilities.js\r\n     * @param diffuseTexture texture used to store diffuse information\r\n     * @param specularGlossinessTexture texture used to store specular and glossiness information\r\n     * @param factors specular glossiness material factors\r\n     * @param mimeType the mime type to use for the texture\r\n     * @returns pbr metallic roughness interface or null\r\n     */\r\n    private _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(diffuseTexture: BaseTexture, specularGlossinessTexture: BaseTexture, factors: _IPBRSpecularGlossiness, mimeType: ImageMimeType): Promise<_IPBRMetallicRoughness> {\r\n        let promises = [];\r\n        if (!(diffuseTexture || specularGlossinessTexture)) {\r\n            return Promise.reject('_ConvertSpecularGlosinessTexturesToMetallicRoughness: diffuse and specular glossiness textures are not defined!');\r\n        }\r\n\r\n        const scene: Nullable<Scene> = diffuseTexture ? diffuseTexture.getScene() : specularGlossinessTexture ? specularGlossinessTexture.getScene() : null;\r\n        if (scene) {\r\n            const resizedTextures = this._resizeTexturesToSameDimensions(diffuseTexture, specularGlossinessTexture, scene);\r\n\r\n            let diffuseSize = resizedTextures.texture1.getSize();\r\n\r\n            let diffuseBuffer: Float32Array;\r\n            let specularGlossinessBuffer: Float32Array;\r\n\r\n            const width = diffuseSize.width;\r\n            const height = diffuseSize.height;\r\n\r\n            let diffusePixels = resizedTextures.texture1.readPixels();\r\n            let specularPixels = resizedTextures.texture2.readPixels();\r\n\r\n            if (diffusePixels) {\r\n                diffuseBuffer = this._convertPixelArrayToFloat32(diffusePixels);\r\n            }\r\n            else {\r\n                return Promise.reject(\"Failed to retrieve pixels from diffuse texture!\");\r\n            }\r\n            if (specularPixels) {\r\n                specularGlossinessBuffer = this._convertPixelArrayToFloat32(specularPixels);\r\n            }\r\n            else {\r\n                return Promise.reject(\"Failed to retrieve pixels from specular glossiness texture!\");\r\n            }\r\n\r\n            const byteLength = specularGlossinessBuffer.byteLength;\r\n\r\n            const metallicRoughnessBuffer = new Uint8Array(byteLength);\r\n            const baseColorBuffer = new Uint8Array(byteLength);\r\n\r\n            const strideSize = 4;\r\n            const maxBaseColor = Color3.Black();\r\n            let maxMetallic = 0;\r\n            let maxRoughness = 0;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const offset = (width * h + w) * strideSize;\r\n\r\n                    const diffuseColor = new Color3(diffuseBuffer[offset], diffuseBuffer[offset + 1], diffuseBuffer[offset + 2]).toLinearSpace().multiply(factors.diffuseColor);\r\n                    const specularColor = new Color3(specularGlossinessBuffer[offset], specularGlossinessBuffer[offset + 1], specularGlossinessBuffer[offset + 2]).toLinearSpace().multiply(factors.specularColor);\r\n                    const glossiness = (specularGlossinessBuffer[offset + 3]) * factors.glossiness;\r\n\r\n                    const specularGlossiness: _IPBRSpecularGlossiness = {\r\n                        diffuseColor: diffuseColor,\r\n                        specularColor: specularColor,\r\n                        glossiness: glossiness\r\n                    };\r\n\r\n                    const metallicRoughness = this._convertSpecularGlossinessToMetallicRoughness(specularGlossiness);\r\n                    maxBaseColor.r = Math.max(maxBaseColor.r, metallicRoughness.baseColor.r);\r\n                    maxBaseColor.g = Math.max(maxBaseColor.g, metallicRoughness.baseColor.g);\r\n                    maxBaseColor.b = Math.max(maxBaseColor.b, metallicRoughness.baseColor.b);\r\n                    maxMetallic = Math.max(maxMetallic, metallicRoughness.metallic!);\r\n                    maxRoughness = Math.max(maxRoughness, metallicRoughness.roughness!);\r\n\r\n                    baseColorBuffer[offset] = metallicRoughness.baseColor.r * 255;\r\n                    baseColorBuffer[offset + 1] = metallicRoughness.baseColor.g * 255;\r\n                    baseColorBuffer[offset + 2] = metallicRoughness.baseColor.b * 255;\r\n                    baseColorBuffer[offset + 3] = resizedTextures.texture1.hasAlpha ? diffuseBuffer[offset + 3] * 255 : 255;\r\n\r\n                    metallicRoughnessBuffer[offset] = 0;\r\n                    metallicRoughnessBuffer[offset + 1] = metallicRoughness.roughness! * 255;\r\n                    metallicRoughnessBuffer[offset + 2] = metallicRoughness.metallic! * 255;\r\n                    metallicRoughnessBuffer[offset + 3] = 255;\r\n                }\r\n            }\r\n\r\n            // Retrieves the metallic roughness factors from the maximum texture values.\r\n            const metallicRoughnessFactors: _IPBRMetallicRoughness = {\r\n                baseColor: maxBaseColor,\r\n                metallic: maxMetallic,\r\n                roughness: maxRoughness\r\n            };\r\n\r\n            let writeOutMetallicRoughnessTexture = false;\r\n            let writeOutBaseColorTexture = false;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const destinationOffset = (width * h + w) * strideSize;\r\n\r\n                    baseColorBuffer[destinationOffset] /= metallicRoughnessFactors.baseColor.r > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.r : 1;\r\n                    baseColorBuffer[destinationOffset + 1] /= metallicRoughnessFactors.baseColor.g > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.g : 1;\r\n                    baseColorBuffer[destinationOffset + 2] /= metallicRoughnessFactors.baseColor.b > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.b : 1;\r\n\r\n                    const linearBaseColorPixel = Color3.FromInts(baseColorBuffer[destinationOffset], baseColorBuffer[destinationOffset + 1], baseColorBuffer[destinationOffset + 2]);\r\n                    const sRGBBaseColorPixel = linearBaseColorPixel.toGammaSpace();\r\n                    baseColorBuffer[destinationOffset] = sRGBBaseColorPixel.r * 255;\r\n                    baseColorBuffer[destinationOffset + 1] = sRGBBaseColorPixel.g * 255;\r\n                    baseColorBuffer[destinationOffset + 2] = sRGBBaseColorPixel.b * 255;\r\n\r\n                    if (!_GLTFMaterialExporter.FuzzyEquals(sRGBBaseColorPixel, Color3.White(), _GLTFMaterialExporter._Epsilon)) {\r\n                        writeOutBaseColorTexture = true;\r\n                    }\r\n\r\n                    metallicRoughnessBuffer[destinationOffset + 1] /= metallicRoughnessFactors.roughness! > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.roughness! : 1;\r\n                    metallicRoughnessBuffer[destinationOffset + 2] /= metallicRoughnessFactors.metallic! > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.metallic! : 1;\r\n\r\n                    const metallicRoughnessPixel = Color3.FromInts(255, metallicRoughnessBuffer[destinationOffset + 1], metallicRoughnessBuffer[destinationOffset + 2]);\r\n\r\n                    if (!_GLTFMaterialExporter.FuzzyEquals(metallicRoughnessPixel, Color3.White(), _GLTFMaterialExporter._Epsilon)) {\r\n                        writeOutMetallicRoughnessTexture = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (writeOutMetallicRoughnessTexture) {\r\n                let promise = this._createBase64FromCanvasAsync(metallicRoughnessBuffer, width, height, mimeType).then((metallicRoughnessBase64) => {\r\n                    metallicRoughnessFactors.metallicRoughnessTextureBase64 = metallicRoughnessBase64;\r\n                });\r\n                promises.push(promise);\r\n            }\r\n            if (writeOutBaseColorTexture) {\r\n                let promise = this._createBase64FromCanvasAsync(baseColorBuffer, width, height, mimeType).then((baseColorBase64) => {\r\n                    metallicRoughnessFactors.baseColorTextureBase64 = baseColorBase64;\r\n                });\r\n                promises.push(promise);\r\n            }\r\n\r\n            return Promise.all(promises).then(() => {\r\n                return metallicRoughnessFactors;\r\n            });\r\n        }\r\n        else {\r\n            return Promise.reject(\"_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts specular glossiness material properties to metallic roughness\r\n     * @param specularGlossiness interface with specular glossiness material properties\r\n     * @returns interface with metallic roughness material properties\r\n     */\r\n    private _convertSpecularGlossinessToMetallicRoughness(specularGlossiness: _IPBRSpecularGlossiness): _IPBRMetallicRoughness {\r\n        const diffusePerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.diffuseColor);\r\n        const specularPerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.specularColor);\r\n        const oneMinusSpecularStrength = 1 - this._getMaxComponent(specularGlossiness.specularColor);\r\n        const metallic = _GLTFMaterialExporter._SolveMetallic(diffusePerceivedBrightness, specularPerceivedBrightness, oneMinusSpecularStrength);\r\n        const baseColorFromDiffuse = specularGlossiness.diffuseColor.scale(oneMinusSpecularStrength / (1.0 - _GLTFMaterialExporter._DielectricSpecular.r) / Math.max(1 - metallic, _GLTFMaterialExporter._Epsilon));\r\n        const baseColorFromSpecular = specularGlossiness.specularColor.subtract(_GLTFMaterialExporter._DielectricSpecular.scale(1 - metallic)).scale(1 / Math.max(metallic, _GLTFMaterialExporter._Epsilon));\r\n        let baseColor = Color3.Lerp(baseColorFromDiffuse, baseColorFromSpecular, metallic * metallic);\r\n        baseColor = baseColor.clampToRef(0, 1, baseColor);\r\n\r\n        const metallicRoughness: _IPBRMetallicRoughness = {\r\n            baseColor: baseColor,\r\n            metallic: metallic,\r\n            roughness: 1 - specularGlossiness.glossiness\r\n        };\r\n\r\n        return metallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Calculates the surface reflectance, independent of lighting conditions\r\n     * @param color Color source to calculate brightness from\r\n     * @returns number representing the perceived brightness, or zero if color is undefined\r\n     */\r\n    private _getPerceivedBrightness(color: Color3): number {\r\n        if (color) {\r\n            return Math.sqrt(0.299 * color.r * color.r + 0.587 * color.g * color.g + 0.114 * color.b * color.b);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum color component value\r\n     * @param color\r\n     * @returns maximum color component value, or zero if color is null or undefined\r\n     */\r\n    private _getMaxComponent(color: Color3): number {\r\n        if (color) {\r\n            return Math.max(color.r, Math.max(color.g, color.b));\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Metallic/Roughness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private _convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial: PBRMaterial, mimeType: ImageMimeType, glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness, hasTextureCoords: boolean): Promise<_IPBRMetallicRoughness> {\r\n        const promises = [];\r\n        const metallicRoughness: _IPBRMetallicRoughness = {\r\n            baseColor: babylonPBRMaterial.albedoColor,\r\n            metallic: babylonPBRMaterial.metallic,\r\n            roughness: babylonPBRMaterial.roughness\r\n        };\r\n\r\n        if (hasTextureCoords) {\r\n            if (babylonPBRMaterial.albedoTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMaterial.albedoTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonPBRMaterial.metallicTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMaterial.metallicTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n        return Promise.all(promises).then(() => {\r\n            return metallicRoughness;\r\n        });\r\n    }\r\n\r\n    private _getGLTFTextureSampler(texture: BaseTexture): ISampler {\r\n        const sampler = this._getGLTFTextureWrapModesSampler(texture);\r\n\r\n        let samplingMode = texture instanceof Texture ? texture.samplingMode : null;\r\n        if (samplingMode != null) {\r\n            switch (samplingMode) {\r\n                case Texture.LINEAR_LINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_LINEAR_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_LINEAR_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return sampler;\r\n    }\r\n\r\n    private _getGLTFTextureWrapMode(wrapMode: number): TextureWrapMode {\r\n        switch (wrapMode) {\r\n            case Texture.WRAP_ADDRESSMODE: {\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n            case Texture.CLAMP_ADDRESSMODE: {\r\n                return TextureWrapMode.CLAMP_TO_EDGE;\r\n            }\r\n            case Texture.MIRROR_ADDRESSMODE: {\r\n                return TextureWrapMode.MIRRORED_REPEAT;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported Texture Wrap Mode ${wrapMode}!`);\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getGLTFTextureWrapModesSampler(texture: BaseTexture): ISampler {\r\n        let wrapS = this._getGLTFTextureWrapMode(texture instanceof Texture ? texture.wrapU : Texture.WRAP_ADDRESSMODE);\r\n        let wrapT = this._getGLTFTextureWrapMode(texture instanceof Texture ? texture.wrapV : Texture.WRAP_ADDRESSMODE);\r\n\r\n        if (wrapS === TextureWrapMode.REPEAT && wrapT === TextureWrapMode.REPEAT) { // default wrapping mode in glTF, so omitting\r\n            return {};\r\n        }\r\n\r\n        return { wrapS: wrapS, wrapT: wrapT };\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Specular/Glossiness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private _convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial: PBRMaterial, mimeType: ImageMimeType, glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness, hasTextureCoords: boolean): Promise<_IPBRMetallicRoughness> {\r\n        return Promise.resolve().then(() => {\r\n            const samplers = this._exporter._samplers;\r\n            const textures = this._exporter._textures;\r\n            const specGloss: _IPBRSpecularGlossiness = {\r\n                diffuseColor: babylonPBRMaterial.albedoColor || Color3.White(),\r\n                specularColor: babylonPBRMaterial.reflectivityColor || Color3.White(),\r\n                glossiness: babylonPBRMaterial.microSurface || 1,\r\n            };\r\n            let samplerIndex: Nullable<number> = null;\r\n            const sampler = this._getGLTFTextureSampler(babylonPBRMaterial.albedoTexture);\r\n            if (sampler.magFilter != null && sampler.minFilter != null && sampler.wrapS != null && sampler.wrapT != null) {\r\n                samplers.push(sampler);\r\n                samplerIndex = samplers.length - 1;\r\n            }\r\n            if (babylonPBRMaterial.reflectivityTexture && !babylonPBRMaterial.useMicroSurfaceFromReflectivityMapAlpha) {\r\n                return Promise.reject(\"_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported\");\r\n            }\r\n            if ((babylonPBRMaterial.albedoTexture || babylonPBRMaterial.reflectivityTexture) && hasTextureCoords) {\r\n                return this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(babylonPBRMaterial.albedoTexture, babylonPBRMaterial.reflectivityTexture, specGloss, mimeType).then((metallicRoughnessFactors) => {\r\n                    if (metallicRoughnessFactors.baseColorTextureBase64) {\r\n                        const glTFBaseColorTexture = this._getTextureInfoFromBase64(metallicRoughnessFactors.baseColorTextureBase64, \"bjsBaseColorTexture_\" + (textures.length) + \".png\", mimeType, babylonPBRMaterial.albedoTexture ? babylonPBRMaterial.albedoTexture.coordinatesIndex : null, samplerIndex);\r\n                        if (glTFBaseColorTexture) {\r\n                            glTFPbrMetallicRoughness.baseColorTexture = glTFBaseColorTexture;\r\n                        }\r\n                    }\r\n                    if (metallicRoughnessFactors.metallicRoughnessTextureBase64) {\r\n                        const glTFMRColorTexture = this._getTextureInfoFromBase64(metallicRoughnessFactors.metallicRoughnessTextureBase64, \"bjsMetallicRoughnessTexture_\" + (textures.length) + \".png\", mimeType, babylonPBRMaterial.reflectivityTexture ? babylonPBRMaterial.reflectivityTexture.coordinatesIndex : null, samplerIndex);\r\n                        if (glTFMRColorTexture) {\r\n                            glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFMRColorTexture;\r\n                        }\r\n                    }\r\n\r\n                    return metallicRoughnessFactors;\r\n                });\r\n            }\r\n            else {\r\n                return this._convertSpecularGlossinessToMetallicRoughness(specGloss);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon PBR Metallic Roughness Material to a glTF Material\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param materials array of glTF material interfaces\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertPBRMaterialAsync(babylonPBRMaterial: PBRMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<IMaterial> {\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {};\r\n        const glTFMaterial: IMaterial = {\r\n            name: babylonPBRMaterial.name\r\n        };\r\n        const useMetallicRoughness = babylonPBRMaterial.isMetallicWorkflow();\r\n\r\n        if (useMetallicRoughness) {\r\n            if (babylonPBRMaterial.albedoColor) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [\r\n                    babylonPBRMaterial.albedoColor.r,\r\n                    babylonPBRMaterial.albedoColor.g,\r\n                    babylonPBRMaterial.albedoColor.b,\r\n                    babylonPBRMaterial.alpha\r\n                ];\r\n            }\r\n            return this._convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords).then((metallicRoughness) => {\r\n                return this.setMetallicRoughnessPbrMaterial(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords);\r\n            });\r\n        }\r\n        else {\r\n            return this._convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords).then((metallicRoughness) => {\r\n                return this.setMetallicRoughnessPbrMaterial(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords);\r\n            });\r\n        }\r\n    }\r\n\r\n    private setMetallicRoughnessPbrMaterial(metallicRoughness: Nullable<_IPBRMetallicRoughness>, babylonPBRMaterial: PBRMaterial, glTFMaterial: IMaterial, glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<IMaterial> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        let promises = [];\r\n        if (metallicRoughness) {\r\n            _GLTFMaterialExporter._SetAlphaMode(glTFMaterial, babylonPBRMaterial);\r\n            if (!(_GLTFMaterialExporter.FuzzyEquals(metallicRoughness.baseColor, Color3.White(), _GLTFMaterialExporter._Epsilon) && babylonPBRMaterial.alpha >= _GLTFMaterialExporter._Epsilon)) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [\r\n                    metallicRoughness.baseColor.r,\r\n                    metallicRoughness.baseColor.g,\r\n                    metallicRoughness.baseColor.b,\r\n                    babylonPBRMaterial.alpha\r\n                ];\r\n            }\r\n\r\n            if (metallicRoughness.metallic != null && metallicRoughness.metallic !== 1) {\r\n                glTFPbrMetallicRoughness.metallicFactor = metallicRoughness.metallic;\r\n            }\r\n            if (metallicRoughness.roughness != null && metallicRoughness.roughness !== 1) {\r\n                glTFPbrMetallicRoughness.roughnessFactor = metallicRoughness.roughness;\r\n            }\r\n\r\n            if (babylonPBRMaterial.backFaceCulling != null && !babylonPBRMaterial.backFaceCulling) {\r\n                if (!babylonPBRMaterial.twoSidedLighting) {\r\n                    Tools.Warn(babylonPBRMaterial.name + \": Back-face culling enabled and two-sided lighting disabled is not supported in glTF.\");\r\n                }\r\n                glTFMaterial.doubleSided = true;\r\n            }\r\n\r\n            if (hasTextureCoords) {\r\n                if (babylonPBRMaterial.bumpTexture) {\r\n                    let promise = this._exportTextureAsync(babylonPBRMaterial.bumpTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.normalTexture = glTFTexture;\r\n                            if (babylonPBRMaterial.bumpTexture.level !== 1) {\r\n                                glTFMaterial.normalTexture.scale = babylonPBRMaterial.bumpTexture.level;\r\n                            }\r\n                        }\r\n                    }\r\n                    );\r\n                    promises.push(promise);\r\n\r\n                }\r\n                if (babylonPBRMaterial.ambientTexture) {\r\n                    let promise = this._exportTextureAsync(babylonPBRMaterial.ambientTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            let occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                                index: glTFTexture.index,\r\n                                texCoord: glTFTexture.texCoord\r\n                            };\r\n\r\n                            glTFMaterial.occlusionTexture = occlusionTexture;\r\n\r\n                            if (babylonPBRMaterial.ambientTextureStrength) {\r\n                                occlusionTexture.strength = babylonPBRMaterial.ambientTextureStrength;\r\n                            }\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n\r\n                }\r\n                if (babylonPBRMaterial.emissiveTexture) {\r\n                    let promise = this._exportTextureAsync(babylonPBRMaterial.emissiveTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.emissiveTexture = glTFTexture;\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n                }\r\n            }\r\n            if (!_GLTFMaterialExporter.FuzzyEquals(babylonPBRMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n                glTFMaterial.emissiveFactor = babylonPBRMaterial.emissiveColor.asArray();\r\n            }\r\n\r\n            glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n            materials.push(glTFMaterial);\r\n            materialMap[babylonPBRMaterial.uniqueId] = materials.length - 1;\r\n        }\r\n\r\n        return this._finishMaterial(promises, glTFMaterial, babylonPBRMaterial, mimeType);\r\n    }\r\n\r\n    private getPixelsFromTexture(babylonTexture: BaseTexture): Nullable<Uint8Array | Float32Array> {\r\n        const pixels = babylonTexture.textureType === Constants.TEXTURETYPE_UNSIGNED_INT ? babylonTexture.readPixels() as Uint8Array : babylonTexture.readPixels() as Float32Array;\r\n        return pixels;\r\n    }\r\n\r\n    /**\r\n     * Extracts a texture from a Babylon texture into file data and glTF data\r\n     * @param babylonTexture Babylon texture to extract\r\n     * @param mimeType Mime Type of the babylonTexture\r\n     * @return glTF texture info, or null if the texture format is not supported\r\n     */\r\n    public _exportTextureAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        const extensionPromise = this._exporter._extensionsPreExportTextureAsync(\"exporter\", babylonTexture as Texture, mimeType);\r\n        if (!extensionPromise) {\r\n            return this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n        }\r\n\r\n        return extensionPromise.then((texture) => {\r\n            if (!texture) {\r\n                return this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n            }\r\n            return this._exportTextureInfoAsync(texture, mimeType);\r\n        });\r\n    }\r\n\r\n    public _exportTextureInfoAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        return Promise.resolve().then(() => {\r\n            const textureUid = babylonTexture.uid;\r\n            if (textureUid in this._textureMap) {\r\n                return this._textureMap[textureUid];\r\n            }\r\n            else {\r\n                const pixels = this.getPixelsFromTexture(babylonTexture);\r\n                if (!pixels) {\r\n                    return null;\r\n                }\r\n\r\n                const samplers = this._exporter._samplers;\r\n                const sampler = this._getGLTFTextureSampler(babylonTexture);\r\n                let samplerIndex: Nullable<number> = null;\r\n\r\n                //  if a pre-existing sampler with identical parameters exists, then reuse the previous sampler\r\n                let foundSamplerIndex: Nullable<number> = null;\r\n                for (let i = 0; i < samplers.length; ++i) {\r\n                    let s = samplers[i];\r\n                    if (s.minFilter === sampler.minFilter && s.magFilter === sampler.magFilter &&\r\n                        s.wrapS === sampler.wrapS && s.wrapT === sampler.wrapT) {\r\n                        foundSamplerIndex = i;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (foundSamplerIndex == null) {\r\n                    samplers.push(sampler);\r\n                    samplerIndex = samplers.length - 1;\r\n                }\r\n                else {\r\n                    samplerIndex = foundSamplerIndex;\r\n                }\r\n                const size = babylonTexture.getSize();\r\n\r\n                return this._createBase64FromCanvasAsync(pixels, size.width, size.height, mimeType).then((base64Data) => {\r\n                    const textureInfo = this._getTextureInfoFromBase64(base64Data, babylonTexture.name.replace(/\\.\\/|\\/|\\.\\\\|\\\\/g, \"_\"), mimeType, babylonTexture.coordinatesIndex, samplerIndex);\r\n                    if (textureInfo) {\r\n                        this._textureMap[textureUid] = textureInfo;\r\n                        this._exporter._extensionsPostExportTextures(\"linkTextureInfo\", textureInfo, babylonTexture);\r\n                    }\r\n\r\n                    return textureInfo;\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Builds a texture from base64 string\r\n     * @param base64Texture base64 texture string\r\n     * @param baseTextureName Name to use for the texture\r\n     * @param mimeType image mime type for the texture\r\n     * @param images array of images\r\n     * @param textures array of textures\r\n     * @param imageData map of image data\r\n     * @returns glTF texture info, or null if the texture format is not supported\r\n     */\r\n    private _getTextureInfoFromBase64(base64Texture: string, baseTextureName: string, mimeType: ImageMimeType, texCoordIndex: Nullable<number>, samplerIndex: Nullable<number>): Nullable<ITextureInfo> {\r\n        const textures = this._exporter._textures;\r\n        const images = this._exporter._images;\r\n        const imageData = this._exporter._imageData;\r\n        let textureInfo: Nullable<ITextureInfo> = null;\r\n\r\n        const glTFTexture: ITexture = {\r\n            source: images.length,\r\n            name: baseTextureName\r\n        };\r\n        if (samplerIndex != null) {\r\n            glTFTexture.sampler = samplerIndex;\r\n        }\r\n\r\n        const binStr = atob(base64Texture.split(',')[1]);\r\n        let arrBuff = new ArrayBuffer(binStr.length);\r\n        const arr = new Uint8Array(arrBuff);\r\n        for (let i = 0, length = binStr.length; i < length; ++i) {\r\n            arr[i] = binStr.charCodeAt(i);\r\n        }\r\n        const imageValues = { data: arr, mimeType: mimeType };\r\n\r\n        let extension = mimeType === ImageMimeType.JPEG ? '.jpeg' : '.png';\r\n        let textureName = baseTextureName + extension;\r\n        let originalTextureName = textureName;\r\n        if (textureName in imageData) {\r\n            textureName = `${baseTextureName}_${Tools.RandomId()}${extension}`;\r\n        }\r\n\r\n        imageData[textureName] = imageValues;\r\n        if (mimeType === ImageMimeType.JPEG || mimeType === ImageMimeType.PNG) {\r\n            const glTFImage: IImage = {\r\n                name: baseTextureName,\r\n                uri: textureName\r\n            };\r\n            let foundIndex: Nullable<number> = null;\r\n            for (let i = 0; i < images.length; ++i) {\r\n                if (images[i].uri === originalTextureName) {\r\n                    foundIndex = i;\r\n                    break;\r\n                }\r\n            }\r\n            if (foundIndex == null) {\r\n                images.push(glTFImage);\r\n                glTFTexture.source = images.length - 1;\r\n            }\r\n            else {\r\n                glTFTexture.source = foundIndex;\r\n\r\n            }\r\n            textures.push(glTFTexture);\r\n            textureInfo = {\r\n                index: textures.length - 1\r\n            };\r\n            if (texCoordIndex != null) {\r\n                textureInfo.texCoord = texCoordIndex;\r\n            }\r\n        }\r\n        else {\r\n            Tools.Error(`Unsupported texture mime type ${mimeType}`);\r\n        }\r\n\r\n        return textureInfo;\r\n    }\r\n}","import { Node } from \"babylonjs/node\";\r\nimport { Scene } from \"babylonjs/scene\";\r\nimport { GLTFData } from \"./glTFData\";\r\nimport { _Exporter } from \"./glTFExporter\";\r\n\r\n/**\r\n * Holds a collection of exporter options and parameters\r\n */\r\nexport interface IExportOptions {\r\n    /**\r\n     * Function which indicates whether a babylon node should be exported or not\r\n     * @param node source Babylon node. It is used to check whether it should be exported to glTF or not\r\n     * @returns boolean, which indicates whether the node should be exported (true) or not (false)\r\n     */\r\n    shouldExportNode?(node: Node): boolean;\r\n\r\n    /**\r\n     * Function used to extract the part of node's metadata that will be exported into glTF node extras\r\n     * @param metadata source metadata to read from\r\n     * @returns the data to store to glTF node extras\r\n     */\r\n    metadataSelector?(metadata: any): any;\r\n\r\n    /**\r\n     * The sample rate to bake animation curves\r\n     */\r\n    animationSampleRate?: number;\r\n\r\n    /**\r\n     * Begin serialization without waiting for the scene to be ready\r\n     */\r\n    exportWithoutWaitingForScene?: boolean;\r\n\r\n    /**\r\n     * Indicates if coordinate system swapping root nodes should be included in export\r\n     */\r\n    includeCoordinateSystemConversionNodes?: boolean;\r\n}\r\n\r\n/**\r\n * Class for generating glTF data from a Babylon scene.\r\n */\r\nexport class GLTF2Export {\r\n    /**\r\n     * Exports the geometry of the scene to .gltf file format asynchronously\r\n     * @param scene Babylon scene with scene hierarchy information\r\n     * @param filePrefix File prefix to use when generating the glTF file\r\n     * @param options Exporter options\r\n     * @returns Returns an object with a .gltf file and associates texture names\r\n     * as keys and their data and paths as values\r\n     */\r\n    public static GLTFAsync(scene: Scene, filePrefix: string, options?: IExportOptions): Promise<GLTFData> {\r\n        return scene.whenReadyAsync().then(() => {\r\n            const glTFPrefix = filePrefix.replace(/\\.[^/.]+$/, \"\");\r\n            const gltfGenerator = new _Exporter(scene, options);\r\n            return gltfGenerator._generateGLTFAsync(glTFPrefix);\r\n        });\r\n    }\r\n\r\n    private static _PreExportAsync(scene: Scene, options?: IExportOptions): Promise<void> {\r\n        return Promise.resolve().then(() => {\r\n            if (options && options.exportWithoutWaitingForScene) {\r\n                return Promise.resolve();\r\n            }\r\n            else {\r\n                return scene.whenReadyAsync();\r\n            }\r\n        });\r\n    }\r\n\r\n    private static _PostExportAsync(scene: Scene, glTFData: GLTFData, options?: IExportOptions): Promise<GLTFData> {\r\n        return Promise.resolve().then(() => {\r\n            if (options && options.exportWithoutWaitingForScene) {\r\n                return glTFData;\r\n            }\r\n            else {\r\n                return glTFData;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Exports the geometry of the scene to .glb file format asychronously\r\n     * @param scene Babylon scene with scene hierarchy information\r\n     * @param filePrefix File prefix to use when generating glb file\r\n     * @param options Exporter options\r\n     * @returns Returns an object with a .glb filename as key and data as value\r\n     */\r\n    public static GLBAsync(scene: Scene, filePrefix: string, options?: IExportOptions): Promise<GLTFData> {\r\n        return this._PreExportAsync(scene, options).then(() => {\r\n            const glTFPrefix = filePrefix.replace(/\\.[^/.]+$/, \"\");\r\n            const gltfGenerator = new _Exporter(scene, options);\r\n            return gltfGenerator._generateGLBAsync(glTFPrefix).then((glTFData) => {\r\n                return this._PostExportAsync(scene, glTFData, options);\r\n            });\r\n        });\r\n    }\r\n}\r\n","import { IBufferView, AccessorType, AccessorComponentType, IAccessor } from \"babylonjs-gltf2interface\";\r\n\r\nimport { FloatArray, Nullable } from \"babylonjs/types\";\r\nimport { Vector3, Vector4, Quaternion } from \"babylonjs/Maths/math.vector\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class _GLTFUtilities {\r\n    /**\r\n     * Creates a buffer view based on the supplied arguments\r\n     * @param bufferIndex index value of the specified buffer\r\n     * @param byteOffset byte offset value\r\n     * @param byteLength byte length of the bufferView\r\n     * @param byteStride byte distance between conequential elements\r\n     * @param name name of the buffer view\r\n     * @returns bufferView for glTF\r\n     */\r\n    public static _CreateBufferView(bufferIndex: number, byteOffset: number, byteLength: number, byteStride?: number, name?: string): IBufferView {\r\n        let bufferview: IBufferView = { buffer: bufferIndex, byteLength: byteLength };\r\n        if (byteOffset) {\r\n            bufferview.byteOffset = byteOffset;\r\n        }\r\n        if (name) {\r\n            bufferview.name = name;\r\n        }\r\n        if (byteStride) {\r\n            bufferview.byteStride = byteStride;\r\n        }\r\n\r\n        return bufferview;\r\n    }\r\n\r\n    /**\r\n     * Creates an accessor based on the supplied arguments\r\n     * @param bufferviewIndex The index of the bufferview referenced by this accessor\r\n     * @param name The name of the accessor\r\n     * @param type The type of the accessor\r\n     * @param componentType The datatype of components in the attribute\r\n     * @param count The number of attributes referenced by this accessor\r\n     * @param byteOffset The offset relative to the start of the bufferView in bytes\r\n     * @param min Minimum value of each component in this attribute\r\n     * @param max Maximum value of each component in this attribute\r\n     * @returns accessor for glTF\r\n     */\r\n    public static _CreateAccessor(bufferviewIndex: number, name: string, type: AccessorType, componentType: AccessorComponentType, count: number, byteOffset: Nullable<number>, min: Nullable<number[]>, max: Nullable<number[]>): IAccessor {\r\n        let accessor: IAccessor = { name: name, bufferView: bufferviewIndex, componentType: componentType, count: count, type: type };\r\n\r\n        if (min != null) {\r\n            accessor.min = min;\r\n        }\r\n        if (max != null) {\r\n            accessor.max = max;\r\n        }\r\n        if (byteOffset != null) {\r\n            accessor.byteOffset = byteOffset;\r\n        }\r\n\r\n        return accessor;\r\n    }\r\n\r\n    /**\r\n     * Calculates the minimum and maximum values of an array of position floats\r\n     * @param positions Positions array of a mesh\r\n     * @param vertexStart Starting vertex offset to calculate min and max values\r\n     * @param vertexCount Number of vertices to check for min and max values\r\n     * @returns min number array and max number array\r\n     */\r\n    public static _CalculateMinMaxPositions(positions: FloatArray, vertexStart: number, vertexCount: number, convertToRightHandedSystem: boolean): { min: number[], max: number[] } {\r\n        const min = [Infinity, Infinity, Infinity];\r\n        const max = [-Infinity, -Infinity, -Infinity];\r\n        const positionStrideSize = 3;\r\n        let indexOffset: number;\r\n        let position: Vector3;\r\n        let vector: number[];\r\n\r\n        if (vertexCount) {\r\n            for (let i = vertexStart, length = vertexStart + vertexCount; i < length; ++i) {\r\n                indexOffset = positionStrideSize * i;\r\n\r\n                position = Vector3.FromArray(positions, indexOffset);\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedPositionVector3FromRef(position);\r\n                }\r\n                vector = position.asArray();\r\n\r\n                for (let j = 0; j < positionStrideSize; ++j) {\r\n                    let num = vector[j];\r\n                    if (num < min[j]) {\r\n                        min[j] = num;\r\n                    }\r\n                    if (num > max[j]) {\r\n                        max[j] = num;\r\n                    }\r\n                    ++indexOffset;\r\n                }\r\n            }\r\n        }\r\n        return { min, max };\r\n    }\r\n\r\n    /**\r\n     * Converts a new right-handed Vector3\r\n     * @param vector vector3 array\r\n     * @returns right-handed Vector3\r\n     */\r\n    public static _GetRightHandedPositionVector3(vector: Vector3): Vector3 {\r\n        return new Vector3(vector.x, vector.y, -vector.z);\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector3 to right-handed\r\n     * @param vector Vector3 to convert to right-handed\r\n     */\r\n    public static _GetRightHandedPositionVector3FromRef(vector: Vector3) {\r\n        vector.z *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a three element number array to right-handed\r\n     * @param vector number array to convert to right-handed\r\n     */\r\n    public static _GetRightHandedPositionArray3FromRef(vector: number[]) {\r\n        vector[2] *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a new right-handed Vector3\r\n     * @param vector vector3 array\r\n     * @returns right-handed Vector3\r\n     */\r\n    public static _GetRightHandedNormalVector3(vector: Vector3): Vector3 {\r\n        return new Vector3(vector.x, vector.y, -vector.z);\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector3 to right-handed\r\n     * @param vector Vector3 to convert to right-handed\r\n     */\r\n    public static _GetRightHandedNormalVector3FromRef(vector: Vector3) {\r\n        vector.z *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a three element number array to right-handed\r\n     * @param vector number array to convert to right-handed\r\n     */\r\n    public static _GetRightHandedNormalArray3FromRef(vector: number[]) {\r\n        vector[2] *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector4 to right-handed\r\n     * @param vector Vector4 to convert to right-handed\r\n     */\r\n    public static _GetRightHandedVector4FromRef(vector: Vector4) {\r\n        vector.z *= -1;\r\n        vector.w *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector4 to right-handed\r\n     * @param vector Vector4 to convert to right-handed\r\n     */\r\n    public static _GetRightHandedArray4FromRef(vector: number[]) {\r\n        vector[2] *= -1;\r\n        vector[3] *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a Quaternion to right-handed\r\n     * @param quaternion Source quaternion to convert to right-handed\r\n     */\r\n    public static _GetRightHandedQuaternionFromRef(quaternion: Quaternion) {\r\n        quaternion.x *= -1;\r\n        quaternion.y *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a Quaternion to right-handed\r\n     * @param quaternion Source quaternion to convert to right-handed\r\n     */\r\n    public static _GetRightHandedQuaternionArrayFromRef(quaternion: number[]) {\r\n        quaternion[0] *= -1;\r\n        quaternion[1] *= -1;\r\n    }\r\n\r\n    public static _NormalizeTangentFromRef(tangent: Vector4) {\r\n        const length = Math.sqrt(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z);\r\n        if (length > 0) {\r\n            tangent.x /= length;\r\n            tangent.y /= length;\r\n            tangent.z /= length;\r\n        }\r\n    }\r\n}","export * from \"./glTFAnimation\";\r\nexport * from \"./glTFData\";\r\nexport * from \"./glTFExporter\";\r\nexport * from \"./glTFExporterExtension\";\r\nexport * from \"./glTFMaterialExporter\";\r\nexport * from \"./glTFSerializer\";\r\nexport * from \"./glTFUtilities\";\r\nexport * from \"./Extensions\";","import { Effect } from \"babylonjs/Materials/effect\";\n\nlet name = 'textureTransformPixelShader';\nlet shader = `precision highp float;\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform mat4 textureTransformMat;\nvoid main(void) {\nvec2 uvTransformed=(textureTransformMat*vec4(vUV.xy,1,1)).xy;\ngl_FragColor=texture2D(textureSampler,uvTransformed);\n}`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var textureTransformPixelShader = { name, shader };\n","/** @hidden */\r\nexport var __IGLTFExporterExtension = 0; // I am here to allow dts to be created\r\n\r\n/**\r\n * Interface for extending the exporter\r\n * @hidden\r\n */\r\nexport interface IGLTFExporterExtension {\r\n    /**\r\n     * The name of this extension\r\n     */\r\n    readonly name: string;\r\n    /**\r\n     * Defines whether this extension is enabled\r\n     */\r\n    enabled: boolean;\r\n\r\n    /**\r\n     * Defines whether this extension is required\r\n     */\r\n    required: boolean;\r\n}","export * from \"./glTFFileExporter\";\r\nexport * from \"./2.0\";","export * from \"./OBJ\";\r\nexport * from \"./glTF\";\r\nexport * from \"./stl\";","import * as Exporters from \"../glTF/glTFFileExporter\";\r\nimport * as Datas from \"../glTF/2.0/glTFData\";\r\nimport * as Serializers from \"../glTF/2.0/glTFSerializer\";\r\nimport * as Extensions from \"../glTF/2.0/Extensions\";\r\nimport * as GLTF2 from \"../glTF/2.0\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nvar globalObject = (typeof global !== 'undefined') ? global : ((typeof window !== 'undefined') ? window : undefined);\r\nif (typeof globalObject !== \"undefined\") {\r\n    (<any>globalObject).BABYLON = (<any>globalObject).BABYLON || {};\r\n    var BABYLON = (<any>globalObject).BABYLON;\r\n    BABYLON.GLTF2 = BABYLON.GLTF2 || {};\r\n    BABYLON.GLTF2.Exporter = BABYLON.GLTF2.Exporter || {};\r\n    BABYLON.GLTF2.Exporter.Extensions = BABYLON.GLTF2.Exporter.Extensions || {};\r\n\r\n    const keys = [];\r\n    for (var key in Exporters) {\r\n        BABYLON[key] = (<any>Exporters)[key];\r\n        keys.push(key);\r\n    }\r\n    for (var key in Datas) {\r\n        BABYLON[key] = (<any>Datas)[key];\r\n        keys.push(key);\r\n    }\r\n    for (var key in Serializers) {\r\n        BABYLON[key] = (<any>Serializers)[key];\r\n        keys.push(key);\r\n    }\r\n\r\n    for (var key in Extensions) {\r\n        BABYLON.GLTF2.Exporter.Extensions[key] = (<any>Extensions)[key];\r\n        keys.push(key);\r\n    }\r\n\r\n    for (var key in GLTF2) {\r\n        // Prevent Reassignment.\r\n        if (keys.indexOf(key) > -1) {\r\n            continue;\r\n        }\r\n\r\n        BABYLON.GLTF2.Exporter[key] = (<any>GLTF2)[key];\r\n    }\r\n}\r\n\r\nexport * from \"../glTF/glTFFileExporter\";\r\nexport * from \"../glTF/2.0\";","import * as Serializers from \"../OBJ\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nvar globalObject = (typeof global !== 'undefined') ? global : ((typeof window !== 'undefined') ? window : undefined);\r\nif (typeof globalObject !== \"undefined\") {\r\n    for (var serializer in Serializers) {\r\n        (<any>globalObject).BABYLON[serializer] = (<any>Serializers)[serializer];\r\n    }\r\n}\r\n\r\nexport * from \"../OBJ\";","import * as Serializers from \"../stl\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nvar globalObject = (typeof global !== 'undefined') ? global : ((typeof window !== 'undefined') ? window : undefined);\r\nif (typeof globalObject !== \"undefined\") {\r\n    for (var serializer in Serializers) {\r\n        (<any>globalObject).BABYLON[serializer] = (<any>Serializers)[serializer];\r\n    }\r\n}\r\n\r\nexport * from \"../stl\";","import \"../index\";\r\nexport * from \"./legacy-glTF2Serializer\";\r\nexport * from \"./legacy-objSerializer\";\r\nexport * from \"./legacy-stlSerializer\";","export * from \"./stlSerializer\";","import { Mesh } from \"babylonjs/Meshes/mesh\";\nimport { VertexBuffer } from \"babylonjs/Meshes/buffer\";\nimport { Vector3 } from \"babylonjs/Maths/math.vector\";\n\n/**\n* Class for generating STL data from a Babylon scene.\n*/\nexport class STLExport {\n    /**\n    * Exports the geometry of a Mesh array in .STL file format (ASCII)\n    * @param meshes list defines the mesh to serialize\n    * @param download triggers the automatic download of the file.\n    * @param fileName changes the downloads fileName.\n    * @param binary changes the STL to a binary type.\n\t* @param isLittleEndian toggle for binary type exporter.\n    * @returns the STL as UTF8 string\n    */\n    public static CreateSTL(meshes: Mesh[], download: boolean= true, fileName: string= 'STL_Mesh', binary: boolean= false, isLittleEndian: boolean = true): any {\n\n        //Binary support adapted from https://gist.github.com/paulkaplan/6d5f0ab2c7e8fdc68a61\n\n        let getFaceData = function(indices: any, vertices: any, i: number) {\n            let id = [indices[i] * 3, indices[i + 1] * 3, indices[i + 2] * 3];\n            let v = [\n                new Vector3(vertices[id[0]], vertices[id[0] + 1], vertices[id[0] + 2]),\n                new Vector3(vertices[id[1]], vertices[id[1] + 1], vertices[id[1] + 2]),\n                new Vector3(vertices[id[2]], vertices[id[2] + 1], vertices[id[2] + 2])\n            ];\n            let p1p2 = v[0].subtract(v[1]);\n            let p3p2 = v[2].subtract(v[1]);\n            let n = (Vector3.Cross(p1p2, p3p2)).normalize();\n\n            return {v, n};\n        };\n\n        let writeVector = function(dataview: any, offset: number, vector: Vector3, isLittleEndian: boolean) {\n                offset = writeFloat(dataview, offset, vector.x, isLittleEndian);\n                offset = writeFloat(dataview, offset, vector.y, isLittleEndian);\n                return writeFloat(dataview, offset, vector.z, isLittleEndian);\n        };\n\n        let writeFloat = function(dataview: any, offset: number, value: number, isLittleEndian: boolean) {\n            dataview.setFloat32(offset, value, isLittleEndian);\n            return offset + 4;\n        };\n\n        let data;\n\n        let faceCount = 0;\n        let offset = 0;\n\n        if (binary) {\n            for (let i = 0; i < meshes.length; i++) {\n                let mesh = meshes[i];\n                let indices = mesh.getIndices();\n                faceCount += indices ? indices.length : 0;\n            }\n\n            let bufferSize = 84 + (50 * faceCount);\n            let buffer = new ArrayBuffer(bufferSize);\n            data = new DataView(buffer);\n\n            offset += 80;\n            data.setUint32(offset, faceCount, isLittleEndian);\n            offset += 4;\n\n        }else {\n            data = 'solid exportedMesh\\r\\n';\n        }\n\n        for (let i = 0; i < meshes.length; i++) {\n            let mesh = meshes[i];\n            mesh.bakeCurrentTransformIntoVertices();\n            let vertices = mesh.getVerticesData(VertexBuffer.PositionKind) || [];\n            let indices = mesh.getIndices() || [];\n\n            for (let i = 0; i < indices.length; i += 3) {\n                let fd = getFaceData(indices, vertices, i);\n\n                if (binary) {\n                    offset = writeVector(data, offset, fd.n, isLittleEndian);\n                    offset = writeVector(data, offset, fd.v[0], isLittleEndian);\n                    offset = writeVector(data, offset, fd.v[1], isLittleEndian);\n                    offset = writeVector(data, offset, fd.v[2], isLittleEndian);\n                    offset += 2;\n                }else {\n                    data += 'facet normal ' + fd.n.x + ' ' + fd.n.y + ' ' + fd.n.z + '\\r\\n';\n                    data += '\\touter loop\\r\\n';\n                    data += '\\t\\tvertex ' + fd.v[0].x + ' ' + fd.v[0].y + ' ' + fd.v[0].z + '\\r\\n';\n                    data += '\\t\\tvertex ' + fd.v[1].x + ' ' + fd.v[1].y + ' ' + fd.v[1].z + '\\r\\n';\n                    data += '\\t\\tvertex ' + fd.v[2].x + ' ' + fd.v[2].y + ' ' + fd.v[2].z + '\\r\\n';\n                    data += '\\tendloop\\r\\n';\n                    data += 'endfacet\\r\\n';\n                }\n\n            }\n        }\n\n        if (!binary) {\n            data += 'endsolid exportedMesh';\n        }\n\n        if (download) {\n            let a = document.createElement('a');\n            let blob = new Blob([data], {'type': 'application/octet-stream'});\n            a.href = window.URL.createObjectURL(blob);\n\n            if (!fileName) {\n                fileName = \"STL_Mesh\";\n            }\n            a.download = fileName + \".stl\";\n            a.click();\n        }\n\n    return data;\n    }\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE_babylonjs_Maths_math_vector__;"],"sourceRoot":""}