{"version":3,"sources":["webpack://LOADERS/webpack/universalModuleDefinition","webpack://LOADERS/webpack/bootstrap","webpack://LOADERS/external {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/2.0/glTFLoader.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/1.0/glTFLoaderV1.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/glTFFileLoader.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/1.0/glTFLoaderExtension.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/1.0/glTFLoaderInterfaces.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/1.0/glTFLoaderUtils.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/index.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/1.0/index.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/legacy.ts","webpack://LOADERS/../node_modules/webpack/buildin/global.js","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/index.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/1.0/glTFBinaryExtension.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/1.0/glTFMaterialsCommonExtension.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/2.0/index.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/2.0/glTFLoaderExtension.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/2.0/Extensions/index.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/2.0/Extensions/EXT_lights_image_based.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/2.0/Extensions/KHR_draco_mesh_compression.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/2.0/Extensions/KHR_lights_punctual.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/2.0/Extensions/KHR_materials_unlit.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/2.0/Extensions/KHR_texture_transform.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/2.0/Extensions/MSFT_audio_emitter.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/2.0/Extensions/MSFT_lod.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/2.0/Extensions/MSFT_minecraftMesh.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/glTF/2.0/Extensions/MSFT_sRGBFactors.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/OBJ/index.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/OBJ/objFileLoader.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/STL/index.ts","webpack://LOADERS/../Tools/Gulp/../../loaders/src/STL/stlFileLoader.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","babylonjs_1","glTFFileLoader_1","ArrayItem","Get","context","array","index","undefined","Error","Assign","length","GLTFLoaderV2","parent","this","_completePromises","Array","_disposed","_state","_extensions","_defaultBabylonMaterialData","_requests","_parent","RegisterExtension","UnregisterExtension","Tools","Warn","_ExtensionFactories","_ExtensionNames","push","indexOf","splice","dispose","_i","_a","abort","name_1","gltf","babylonScene","_rootBabylonMesh","_progressCallback","_clear","importMeshAsync","meshesNames","scene","data","rootUrl","onProgress","fileName","_this","Promise","resolve","then","_rootUrl","_fileName","_loadData","nodes","nodeMap_1","node","map","_loadAsync","meshes","_getMeshes","particleSystems","skeletons","_getSkeletons","animationGroups","_getAnimationGroups","loadAsync","resultFunc","_uniqueRootUrl","Date","now","_loadExtensions","_checkExtensions","loadingToReadyCounterName","GLTFLoaderState","LOADING","READY","loadingToCompleteCounterName","COMPLETE","_startPerformanceCounter","_setState","_extensionsOnLoading","promises","loadSceneAsync","scenes","compileMaterials","_compileMaterialsAsync","compileShadowGenerators","_compileShadowGeneratorsAsync","resultPromise","all","_extensionsOnReady","_startAnimations","_endPerformanceCounter","SetImmediate","onCompleteObservable","notifyObservers","clear","error","onErrorObservable","json","_setupData","bin","buffers","uri","binaryBuffer","byteLength","_data","accessors","animations","bufferViews","cameras","images","materials","samplers","skins","textures","nodeParents","children","_b","_c","rootNode","_createRootNode","_d","_e","parentIndex","name_2","extension","onExtensionLoadedObservable","extensionsRequired","name_3","enabled","state","log","Mesh","_babylonMesh","coordinateSystemMode","GLTFLoaderCoordinateSystemMode","AUTO","useRightHandedSystem","rotation","scale","_LoadTransform","FORCE_RIGHT_HANDED","onMeshLoadedObservable","extensionPromise","_extensionsLoadSceneAsync","logOpen","loadNodeAsync","babylonMesh","_loadAnimationsAsync","logClose","_forEachPrimitive","callback","_primitiveBabylonMeshes","nodes_1","skins_1","skin","_babylonSkeleton","animations_1","animation","_babylonAnimationGroup","animationStartMode","GLTFLoaderAnimationStartMode","NONE","FIRST","babylonAnimationGroups","start","ALL","babylonAnimationGroups_1","assign","_extensionsLoadNodeAsync","setEnabled","mesh","_loadMeshAsync","camera","loadCameraAsync","babylonCamera","childNode","this_1","childBabylonMesh","primitives","primitive","_loadMeshPrimitiveAsync","primitives_1","primitiveBabylonMesh","_loadSkinAsync","_refreshBoundingInfo","_createMorphTargets","_loadVertexDataAsync","babylonGeometry","_loadMorphTargetsAsync","applyToMesh","babylonDrawMode","_GetDrawMode","material","babylonMaterial","_createDefaultMaterial","onMaterialLoadedObservable","_loadMaterialAsync","_extensionsLoadVertexDataAsync","attributes","Geometry","indices","isUnIndexed","accessor","_loadIndicesAccessorAsync","setIndices","loadAttribute","attribute","kind","_delayInfo","_loadVertexAccessorAsync","babylonVertexBuffer","setVerticesBuffer","count","VertexBuffer","PositionKind","NormalKind","TangentKind","UVKind","UV2Kind","MatricesIndicesKind","MatricesWeightsKind","ColorKind","type","hasVertexAlpha","targets","_numMorphTargets","morphTargetManager","MorphTargetManager","weight","weights","addTarget","MorphTarget","numTargets","babylonMorphTarget","getTarget","_loadMorphTargetVertexDataAsync","setData","getVertexBuffer","_loadFloatAccessorAsync","forEach","setPositions","setNormals","dataIndex","setTangents","babylonNode","position","Vector3","Zero","Quaternion","Identity","scaling","One","matrix","Matrix","FromArray","decompose","translation","rotationQuaternion","assignSkeleton","skeleton","_promise","skeletonId","babylonSkeleton","Skeleton","_loadBones","_loadSkinInverseBindMatricesDataAsync","inverseBindMatricesData","_updateBoneMatrices","babylonBones","joints","_loadBone","babylonBone","babylonParentBone","boneIndex","Bone","_getNodeMatrix","_babylonBones","inverseBindMatrices","bones","baseMatrix","_index","FromArrayToRef","invertToRef","getParent","multiplyToRef","getInvertedAbsoluteTransform","updateMatrix","_updateDifferenceMatrix","Compose","_extensionsLoadCameraAsync","FreeCamera","Math","PI","perspective","fov","yfov","minZ","znear","maxZ","zfar","Number","MAX_VALUE","orthographic","Camera","ORTHOGRAPHIC_CAMERA","orthoLeft","xmag","orthoRight","orthoBottom","ymag","orthoTop","onCameraLoadedObservable","loadAnimationAsync","promise","_extensionsLoadAnimationAsync","babylonAnimationGroup","AnimationGroup","channels","channel","_loadAnimationChannelAsync","normalize","animationContext","targetNode","target","path","sampler","_loadAnimationSamplerAsync","targetPath","animationType","Animation","ANIMATIONTYPE_VECTOR3","ANIMATIONTYPE_QUATERNION","ANIMATIONTYPE_FLOAT","getNextOutputValue","getNextKey","outputBufferOffset","output","interpolation","frameIndex","frame","input","AnimationKeyInterpolation","STEP","inTangent","outTangent","keys","targetIndex","animationName","targetedAnimations","babylonAnimation","setKeys","morphTarget","babylonAnimationClone","clone","addTargetedAnimation","babylonAnimationTargets","concat","babylonAnimationTargets_1","inputAccessor","outputAccessor","inputData","outputData","_loadBufferAsync","buffer","loadUriAsync","loadBufferViewAsync","bufferView","Uint8Array","byteOffset","e","message","componentType","_GetTypedArray","numComponents","_GetNumComponents","Float32Array","sparse","sparse_1","indicesBufferView","valuesBufferView","values","indicesData","valuesData","valuesIndex","indicesIndex","componentIndex","_loadVertexBufferViewAsync","_babylonBuffer","Buffer","getEngine","_babylonVertexBuffer","GetTypeByteLength","bufferView_1","babylonBuffer","size","byteStride","normalized","_loadMaterialMetallicRoughnessPropertiesAsync","properties","PBRMaterial","baseColorFactor","albedoColor","Color3","alpha","White","metallic","metallicFactor","roughness","roughnessFactor","baseColorTexture","loadTextureInfoAsync","texture","albedoTexture","metallicRoughnessTexture","metallicTexture","useMetallnessFromMetallicTextureBlue","useRoughnessFromMetallicTextureGreen","useRoughnessFromMetallicTextureAlpha","_extensionsLoadMaterialAsync","_babylonData","babylonData","createMaterial","loadMaterialPropertiesAsync","onDisposeObservable","addOnce","sideOrientation","Material","CounterClockWiseSideOrientation","ClockWiseSideOrientation","fillMode","enableSpecularAntiAliasing","useRadianceOverAlpha","transparencyAsCoverage","useSpecularOverAlpha","transparencyMode","PBRMATERIAL_OPAQUE","_extensionsCreateMaterial","_extensionsLoadMaterialPropertiesAsync","loadMaterialBasePropertiesAsync","pbrMetallicRoughness","loadMaterialAlphaProperties","emissiveColor","emissiveFactor","doubleSided","backFaceCulling","twoSidedLighting","normalTexture","bumpTexture","invertNormalMapX","invertNormalMapY","level","occlusionTexture","ambientTexture","useAmbientInGrayScale","strength","ambientTextureStrength","emissiveTexture","alphaMode","PBRMATERIAL_ALPHATEST","alphaCutOff","alphaCutoff","hasAlpha","PBRMATERIAL_ALPHABLEND","useAlphaFromAlbedoTexture","textureInfo","_extensionsLoadTextureInfoAsync","_loadTextureAsync","babylonTexture","coordinatesIndex","texCoord","_DefaultSampler","samplerData","_loadSampler","deferred","Deferred","Texture","noMipMaps","samplingMode","exception","reject","wrapU","wrapV","image","source","loadImageAsync","dataUrl","updateURL","Blob","mimeType","onTextureLoadedObservable","minFilter","_GetTextureSamplingMode","_GetTextureWrapMode","wrapS","wrapT","_extensionsLoadUriAsync","_ValidateUri","IsBase64","DecodeBase64","substr","preprocessUrlAsync","url","request_1","LoadFile","fileData","event","_lengthComputable","lengthComputable","_loaded","loaded","_total","total","_onProgress","offlineProvider","request","LoadFileError","status","statusText","SceneLoaderProgressEvent","CLAMP_ADDRESSMODE","MIRROR_ADDRESSMODE","WRAP_ADDRESSMODE","magFilter","LINEAR_NEAREST","LINEAR_LINEAR","LINEAR_NEAREST_MIPNEAREST","LINEAR_LINEAR_MIPNEAREST","LINEAR_NEAREST_MIPLINEAR","LINEAR_LINEAR_MIPLINEAR","NEAREST_NEAREST","NEAREST_LINEAR","NEAREST_NEAREST_MIPNEAREST","NEAREST_LINEAR_MIPNEAREST","NEAREST_NEAREST_MIPLINEAR","NEAREST_LINEAR_MIPLINEAR","Int8Array","Int16Array","Uint16Array","Uint32Array","PointListDrawMode","LineListDrawMode","LineLoopDrawMode","LineStripDrawMode","TriangleFillMode","TriangleStripDrawMode","TriangleFanDrawMode","computeWorldMatrix","forceCompilationAsync","useClipPlane","clipPlane","lights_1","lights","generator","getShadowGenerator","_forEachExtensions","action","name_4","_applyExtensions","actionAsync","name_5","loaderProperty","_activeLoaderExtensions","activeLoaderExtensions","result","onLoading","onReady","_loadUriAsync","LoadExtensionAsync","extensionName","extensions","LoadExtraAsync","extras","extra","_logOpen","_logClose","_log","startPerformanceCounter","counterName","endPerformanceCounter","GLTFFileLoader","_CreateGLTFLoaderV2","ETokenType","glTFLoaderInterfaces_1","glTFLoaderUtils_1","glTFLoaderExtension_1","Tokenizer","toParse","_pos","currentToken","UNKNOWN","currentIdentifier","currentString","isLetterOrDigitPattern","_toParse","_maxPos","getNextToken","isEnd","END_OF_INPUT","read","test","IDENTIFIER","peek","forward","glTFTransforms","babylonTransforms","glTFAnimationPaths","babylonAnimationPaths","parseObject","parsedObjects","runtimeProperty","gltfRuntime","parsedObject","normalizeUVs","getAttribute","attributeParameter","semantic","split","configureBoneTransformation","mat","getParentBone","jointName","newSkeleton","nde","child","bone","id","getNodeToRoot","nodesToRoot","nodeToRoot","j","getJointNode","nodeIsInJoints","jointNames","importSkeleton","nodesToRootToAdd","k","getNodesToRoot","jointNode","existingBone","getBoneByID","foundBone","parentBone","jointNode_1","joint","prepare","importMesh","newMesh","subMaterials","vertexData","verticesStarts","verticesCounts","indexStarts","indexCounts","meshIndex","meshID","tempVertexData","VertexData","GLTFUtils","GetBufferFromAccessor","normals","set","HomogeneousCoordinates","positions","uvKind","uvs","matricesIndices","matricesWeights","colors","Int32Array","merge","material_1","getMaterialByID","GetDefaultMaterial","MultiMaterial","StandardMaterial","subMeshes","SubMesh","AddToMesh","configureNode","newNode","importNode","lastNode","importOnlyMeshes","importMeshesNames","getLastSkeletonByID","light","orthoCamera","attachControl","getRenderingCanvas","perspectiveCamera","persCamera","aspectRatio","getRenderWidth","getRenderHeight","ambienLight","hemiLight","HemisphericLight","color","diffuse","directionalLight","dirLight","DirectionalLight","pointLight","ptLight","PointLight","spotLight","spLight","SpotLight","fallOfAngle","angle","fallOffExponent","exponent","dummy","configureNodeFromMatrix","updateCache","traverseNodes","meshIncluded","postLoad","currentScene","thing","anim","lastAnimation","parameters","bufferInput","bufferOutput","targetID","getNodeByID","getNodeByName","isBone","targetPathIndex","ANIMATIONTYPE_MATRIX","arrayOffset","modifyKey","getKeys","ANIMATIONLOOPMODE_CYCLE","getBaseMatrix","stopAnimation","beginAnimation","loadAnimations","onShaderCompileSuccess","shaderMaterial","technique","unTreatedUniforms","onSuccess","_","materialValues","techniqueUniforms","uniforms","unif","uniform","onLoadTexture","uniformName","setTexture","EParameterType","SAMPLER_2D","GLTFLoaderExtension","LoadTextureAsync","SetUniform","prepareShaderMaterialUniforms","onBind","FLOAT_MAT2","FLOAT_MAT3","FLOAT_MAT4","SetMatrix","getEffect","onBindShaderMaterial","parseShaderUniforms","tokenizer","uniformParameter","transformIndex","importMaterials","LoadMaterialAsync","GLTFLoaderBase","CreateRuntime","parsedData","shaders","programs","techniques","extensionsUsed","buffersCount","shaderscount","loadedBufferCount","loadedBufferViews","loadedShaderCount","dummyNodes","parsedBuffers","buf","parsedBuffer","parseBuffers","parsedShaders","sha","parsedShader","parseShaders","LoadBufferAsync","onError","setTimeout","LoadTextureBufferAsync","CreateTextureAsync","createMipMaps","ETextureFilterType","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","BILINEAR_SAMPLINGMODE","blob","blobURL","URL","createObjectURL","revokeBlobURL","revokeObjectURL","newTexture","GetWrapMode","LoadShaderStringAsync","shader","shaderString","atob","defaultMaterial","diffuseColor","program","states","vertexShader","Effect","ShadersStore","pixelShader","fragmentShader","newVertexShader","newPixelShader","vertexTokenizer","pixelTokenizer","attr","foundAttribute","shaderPath","vertex","fragment","options","needAlphaBlending","enable","ShaderMaterial","effect","onShaderCompileError","onCompiled","functions","cullFace","ECullingType","BACK","blendFunc","blendFuncSeparate","EBlendingFunction","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","ONE","Engine","ALPHA_COMBINE","ZERO","ALPHA_ONEONE","ALPHA_ADD","ONE_MINUS_SRC_COLOR","ALPHA_SUBTRACT","DST_COLOR","ALPHA_MULTIPLY","ALPHA_MAXIMIZED","GLTFLoaderV1","Extensions","_importMeshAsync","LoadRuntimeAsync","_createNodes","AbstractMesh","skl","_loadBuffersAsync","_loadShadersAsync","IncrementalLoading","LoadRuntimeExtensionsAsync","onload","hasShaders","processShader","ArrayBuffer","EShaderType","VERTEX","onLoad","hasBuffers","processBuffer","_CreateGLTFLoaderV1","onParsedObservable","Observable","validate","onValidatedObservable","_loader",".gltf","isBinary",".glb","_logIndentLevel","_loggingEnabled","_logDisabled","_capturePerformanceCounters","_startPerformanceCounterDisabled","_endPerformanceCounterDisabled","_onParsedObserver","remove","add","_onMeshLoadedObserver","_onTextureLoadedObserver","_onMaterialLoadedObserver","_onCameraLoadedObserver","_onCompleteObserver","_onErrorObserver","_onDisposeObserver","_onExtensionLoadedObserver","_logEnabled","_startPerformanceCounterEnabled","_endPerformanceCounterEnabled","_onValidatedObserver","_parseAsync","loaderData","_getLoader","loadAssetContainerAsync","container","AssetContainer","apply","removeAllFromScene","canDirectLoad","createPlugin","whenCompleteAsync","reason","unpacked","_unpackBinary","_validateAsync","JSON","parse","GLTFValidator","externalResourceFunction","_loadFileAsync","validateString","asset","version","minVersion","_parseVersion","_compareVersion","major","minor","createLoader","1","2","binaryReader","BinaryReader","magic","readUint32","loggingEnabled","_unpackBinaryV1","_unpackBinaryV2","getLength","content","contentLength","contentFormat","_decodeBufferToText","readUint8Array","bytesRemaining","getPosition","ChunkFormat","chunkLength","chunkLength_1","skipBytes","match","parseInt","a","b","String","fromCharCode","spaces","_logSpaces","Log","StartPerformanceCounter","EndPerformanceCounter","arrayBuffer","_arrayBuffer","_dataView","DataView","_byteOffset","getUint32","SceneLoader","RegisterPlugin","glTFLoaderV1_1","_name","loadRuntimeAsync","loadRuntimeExtensionsAsync","loadBufferAsync","loadTextureBufferAsync","createTextureAsync","loadShaderStringAsync","loadMaterialAsync","ApplyExtensions","loaderExtension","func","defaultFunc","EComponentType","ETextureWrapMode","ETextureFormat","parameter","getWorldMatrix","getProjectionMatrix","getViewMatrix","Transpose","multiply","invert","getTransformMatrix","setMatrix2x2","GetAsMatrix2x2","setMatrix3x3","GetAsMatrix3x3","setMatrix","FLOAT","setFloat","FLOAT_VEC2","setVector2","Vector2","FLOAT_VEC3","setVector3","FLOAT_VEC4","setVector4","Vector4","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","GetByteStrideFromType","GetTextureFilterMode","LINEAR","TRILINEAR_SAMPLINGMODE","NEAREST","NEAREST_SAMPLINGMODE","GetBufferFromBufferView","loadedBufferView","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","DecodeBufferToText","view","_DefaultMaterial","join","setColor4","Color4","__export","MatLib","globalObject","global","BABYLON","g","Function","eval","glTFLoaderV1_2","GLTFBinaryExtension","_super","__extends","_bin","sourceExt","binaryExtensionShader","shaderBytes","_1","GLTFMaterialsCommonExtension","ambientLight","ambient","point","directional","spot","fallOffAngle","standardMaterial","disableLighting","transparency","specularPower","shininess","_loadTexture","ambientColor","emission","specular","specularColor","propertyPath","tata","glTFLoader_1","NAME","EXT_lights_image_based","loader","_lights","extensionContext","_loadLightAsync","environmentTexture","imageData_1","specularImages","mipmap","faces","face","specularImageContext","RawCubeTexture","specularImageSize","_babylonTexture","intensity","Inverse","FromQuaternionToRef","getReflectionTextureMatrix","sphericalHarmonics","SphericalHarmonics","irradianceCoefficients","convertIrradianceToLambertianRadiance","sphericalPolynomial","SphericalPolynomial","FromHarmonics","lodGenerationScale","Scalar","Log2","updateRGBDAsync","KHR_draco_mesh_compression","DracoCompression","DecoderAvailable","_dracoCompression","uniqueId","_dracoBabylonGeometry","decodeMeshAsync","babylonVertexData","applyToGeometry","catch","LightType","KHR_lights","babylonLight","DIRECTIONAL","Backward","POINT","SPOT","babylonSpotLight","outerConeAngle","innerAngle","innerConeAngle","falloffType","Light","FALLOFF_GLTF","range","KHR_materials_pbrSpecularGlossiness","_loadSpecularGlossinessPropertiesAsync","diffuseFactor","reflectivityColor","specularFactor","microSurface","glossinessFactor","diffuseTexture","specularGlossinessTexture","reflectivityTexture","useMicroSurfaceFromReflectivityMapAlpha","KHR_materials_unlit","_loadUnlitPropertiesAsync","unlit","KHR_texture_transform","offset","uOffset","vOffset","uRotationCenter","vRotationCenter","wAng","uScale","vScale","MSFT_audio_emitter","_clips","_emitters","clips","emitters","emitterIndex","emitter","refDistance","maxDistance","rolloffFactor","distanceModel","outerAngle","_loadEmitterAsync","_babylonSounds","sound","attachToMesh","setLocalDirectionToMesh","Forward","setDirectionalCone","ToDegrees","events","event_1","_loadAnimationEventAsync","_loadClipAsync","clip","_objectURL","clipPromises","options_1","loop","autoplay","volume","clipContext","objectURL","Sound","_positionInEmitterSpace","weightedSound","WeightedSound","directionalConeInnerAngle","directionalConeOuterAngle","_getEventAction","time","startOffset","currentFrame","frameOffset","play","stop","pause","babylonAnimationEvent","AnimationEvent","addEvent","onAnimationGroupEndObservable","onAnimationGroupPauseObservable","MSFT_lod","maxLODsToLoad","onNodeLODsLoadedObservable","onMaterialLODsLoadedObservable","_nodeIndexLOD","_nodeSignalLODs","_nodePromiseLODs","_materialIndexLOD","_materialSignalLODs","_materialPromiseLODs","indexLOD","this_2","firstPromise","nodeLODs","_getLODs","ids","nodeLOD","previousNodeLOD","_disposeUnusedMaterials","materialLODs","materialLOD","previousBabylonDataLOD","previousIndexLOD","materials_1","drawMode","MSFT_minecraftMesh","extraContext","forceDepthWrite","separateCullingPass","MSFT_sRGBFactors","toLinearSpaceToRef","MTLFileLoader","parseMTL","lines","delimiter_pattern","line","trim","charAt","pos","substring","toLowerCase","parseFloat","_getTexture","specularTexture","opacityTexture","lastDelimiter","lastIndexOf","OBJFileLoader","obj","group","mtllib","usemtl","smooth","vertexPattern","normalPattern","uvPattern","facePattern1","facePattern2","facePattern3","facePattern4","facePattern5","_loadMTL","pathOfFile","BaseUrl","console","warn","_parseSolid","handledMesh","meshesFromObj","indicesForBabylon","wrappedPositionForBabylon","wrappedUvsForBabylon","wrappedNormalsForBabylon","tuplePosNorm","curPositionInIndices","hasMeshes","unwrappedPositionsForBabylon","unwrappedNormalsForBabylon","unwrappedUVForBabylon","triangles","materialNameFromObj","fileToLoad","materialsFromMTLFile","increment","isFirstMaterial","indicePositionFromObj","indiceUvsFromObj","indiceNormalFromObj","positionVectorFromOBJ","textureVectorFromOBJ","normalsVectorFromOBJ","OPTIMIZE_WITH_UV","arr","idx","uv","isInArrayUV","isInArray","unwrapData","x","y","z","getTriangles","v","setDataForCurrentFaceWithPattern1","Up","setDataForCurrentFaceWithPattern2","setDataForCurrentFaceWithPattern3","setDataForCurrentFaceWithPattern4","setDataForCurrentFaceWithPattern5","addPreviousObjMesh","reverse","slice","exec","objMesh","materialName","toString","RandomId","babylonMeshesArray","materialToUse","INVERT_Y","mtlPromises","dataLoaded","startIndex","_indices","STLFileLoader","solidPattern","facetsPattern",".stl","matches","parseBinary","array_buffer","str","meshName","parseASCII","load","createDefaultCameraOrLight","loadAssetContainer","reader","fileLength","getUint8","indicesCount","normalX","getFloat32","normalY","normalZ","vertexstart","setVerticesData","solidData","facet","normalMatches","lastIndex","vertexMatch","normal"],"mappings":"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","file":"babylonjs.loaders.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-loaders\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-loaders\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"LOADERS\"] = factory(root[\"BABYLON\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import { IFileRequest, Buffer, Animation, Scene, Nullable, Mesh, Material, SceneLoaderProgressEvent, Tools, AbstractMesh, IParticleSystem, Skeleton, AnimationGroup, Geometry, VertexBuffer, MorphTargetManager, MorphTarget, TransformNode, Vector3, Quaternion, Matrix, Bone, Camera, FreeCamera, IAnimationKey, AnimationKeyInterpolation, IndicesArray, PBRMaterial, Color3, BaseTexture, Deferred, Texture, LoadFileError } from \"babylonjs\";\r\nimport { IProperty, AccessorType, CameraType, AnimationChannelTargetPath, AnimationSamplerInterpolation, AccessorComponentType, MaterialAlphaMode, TextureMinFilter, TextureWrapMode, TextureMagFilter, MeshPrimitiveMode } from \"babylonjs-gltf2interface\";\r\nimport { _IAnimationSamplerDataV2, IGLTFV2, ISamplerV2, INodeV2, ISceneV2, IMeshV2,  IAccessorV2, ISkinV2, ICameraV2, IAnimationV2, IAnimationChannelV2, IAnimationSamplerV2, IBufferV2, IBufferViewV2, IMaterialPbrMetallicRoughnessV2, IMaterialV2, ITextureInfoV2, ITextureV2, IImageV2, IMeshPrimitiveV2, IArrayItemV2, _ISamplerDataV2 } from \"./glTFLoaderInterfaces\";\r\nimport { IGLTFLoaderExtensionV2 } from \"./glTFLoaderExtension\";\r\nimport { IGLTFLoader, GLTFFileLoader, GLTFLoaderState, IGLTFLoaderData, GLTFLoaderCoordinateSystemMode, GLTFLoaderAnimationStartMode } from \"../glTFFileLoader\";\r\n\r\ninterface IFileRequestInfo extends IFileRequest {\r\n    _lengthComputable?: boolean;\r\n    _loaded?: number;\r\n    _total?: number;\r\n}\r\n\r\ninterface ILoaderProperty extends IProperty {\r\n    _activeLoaderExtensions: any;\r\n}\r\n\r\n/**\r\n * Helper class for working with arrays when loading the glTF asset\r\n */\r\nexport class ArrayItem {\r\n    /**\r\n     * Gets an item from the given array.\r\n     * @param context The context when loading the asset\r\n     * @param array The array to get the item from\r\n     * @param index The index to the array\r\n     * @returns The array item\r\n     */\r\n    public static Get<T>(context: string, array: ArrayLike<T> | undefined, index: number | undefined): T {\r\n        if (!array || index == undefined || !array[index]) {\r\n            throw new Error(`${context}: Failed to find index (${index})`);\r\n        }\r\n\r\n        return array[index];\r\n    }\r\n\r\n    /**\r\n     * Assign an `index` field to each item of the given array.\r\n     * @param array The array of items\r\n     */\r\n    public static Assign(array?: IArrayItemV2[]): void {\r\n        if (array) {\r\n            for (let index = 0; index < array.length; index++) {\r\n                array[index].index = index;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The glTF 2.0 loader\r\n */\r\nexport class GLTFLoaderV2 implements IGLTFLoader {\r\n    /** The glTF object parsed from the JSON. */\r\n    public gltf: IGLTFV2;\r\n\r\n    /** The Babylon scene when loading the asset. */\r\n    public babylonScene: Scene;\r\n\r\n    /** @hidden */\r\n    public _completePromises = new Array<Promise<any>>();\r\n\r\n    private _disposed = false;\r\n    private _parent: GLTFFileLoader;\r\n    private _state: Nullable<GLTFLoaderState> = null;\r\n    private _extensions: { [name: string]: IGLTFLoaderExtensionV2 } = {};\r\n    private _rootUrl: string;\r\n    private _fileName: string;\r\n    private _uniqueRootUrl: string;\r\n    private _rootBabylonMesh: Mesh;\r\n    private _defaultBabylonMaterialData: { [drawMode: number]: Material } = {};\r\n    private _progressCallback?: (event: SceneLoaderProgressEvent) => void;\r\n    private _requests = new Array<IFileRequestInfo>();\r\n\r\n    private static readonly _DefaultSampler: ISamplerV2 = { index: -1 };\r\n\r\n    private static _ExtensionNames = new Array<string>();\r\n    private static _ExtensionFactories: { [name: string]: (loader: GLTFLoaderV2) => IGLTFLoaderExtensionV2 } = {};\r\n\r\n    /**\r\n     * Registers a loader extension.\r\n     * @param name The name of the loader extension.\r\n     * @param factory The factory function that creates the loader extension.\r\n     */\r\n    public static RegisterExtension(name: string, factory: (loader: GLTFLoaderV2) => IGLTFLoaderExtensionV2): void {\r\n        if (GLTFLoaderV2.UnregisterExtension(name)) {\r\n            Tools.Warn(`Extension with the name '${name}' already exists`);\r\n        }\r\n\r\n        GLTFLoaderV2._ExtensionFactories[name] = factory;\r\n\r\n        // Keep the order of registration so that extensions registered first are called first.\r\n        GLTFLoaderV2._ExtensionNames.push(name);\r\n    }\r\n\r\n    /**\r\n     * Unregisters a loader extension.\r\n     * @param name The name of the loader extenion.\r\n     * @returns A boolean indicating whether the extension has been unregistered\r\n     */\r\n    public static UnregisterExtension(name: string): boolean {\r\n        if (!GLTFLoaderV2._ExtensionFactories[name]) {\r\n            return false;\r\n        }\r\n\r\n        delete GLTFLoaderV2._ExtensionFactories[name];\r\n\r\n        const index = GLTFLoaderV2._ExtensionNames.indexOf(name);\r\n        if (index !== -1) {\r\n            GLTFLoaderV2._ExtensionNames.splice(index, 1);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the loader state.\r\n     */\r\n    public get state(): Nullable<GLTFLoaderState> {\r\n        return this._state;\r\n    }\r\n\r\n    /** @hidden */\r\n    constructor(parent: GLTFFileLoader) {\r\n        this._parent = parent;\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose(): void {\r\n        if (this._disposed) {\r\n            return;\r\n        }\r\n\r\n        this._disposed = true;\r\n\r\n        for (const request of this._requests) {\r\n            request.abort();\r\n        }\r\n\r\n        this._requests.length = 0;\r\n\r\n        delete this.gltf;\r\n        delete this.babylonScene;\r\n        this._completePromises.length = 0;\r\n\r\n        for (const name in this._extensions) {\r\n            const extension = this._extensions[name];\r\n            if (extension.dispose) {\r\n                this._extensions[name].dispose();\r\n            }\r\n        }\r\n\r\n        this._extensions = {};\r\n\r\n        delete this._rootBabylonMesh;\r\n        delete this._progressCallback;\r\n\r\n        this._parent._clear();\r\n    }\r\n\r\n    /** @hidden */\r\n    public importMeshAsync(meshesNames: any, scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<{ meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], animationGroups: AnimationGroup[] }> {\r\n        return Promise.resolve().then(() => {\r\n            this.babylonScene = scene;\r\n            this._rootUrl = rootUrl;\r\n            this._fileName = fileName || \"scene\";\r\n            this._progressCallback = onProgress;\r\n            this._loadData(data);\r\n\r\n            let nodes: Nullable<Array<number>> = null;\r\n\r\n            if (meshesNames) {\r\n                const nodeMap: { [name: string]: number } = {};\r\n                if (this.gltf.nodes) {\r\n                    for (const node of this.gltf.nodes) {\r\n                        if (node.name) {\r\n                            nodeMap[node.name] = node.index;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                const names = (meshesNames instanceof Array) ? meshesNames : [meshesNames];\r\n                nodes = names.map((name) => {\r\n                    const node = nodeMap[name];\r\n                    if (node === undefined) {\r\n                        throw new Error(`Failed to find node '${name}'`);\r\n                    }\r\n\r\n                    return node;\r\n                });\r\n            }\r\n\r\n            return this._loadAsync(nodes, () => {\r\n                return {\r\n                    meshes: this._getMeshes(),\r\n                    particleSystems: [],\r\n                    skeletons: this._getSkeletons(),\r\n                    animationGroups: this._getAnimationGroups()\r\n                };\r\n            });\r\n        });\r\n    }\r\n\r\n    /** @hidden */\r\n    public loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<void> {\r\n        return Promise.resolve().then(() => {\r\n            this.babylonScene = scene;\r\n            this._rootUrl = rootUrl;\r\n            this._fileName = fileName || \"scene\";\r\n            this._progressCallback = onProgress;\r\n            this._loadData(data);\r\n            return this._loadAsync(null, () => undefined);\r\n        });\r\n    }\r\n\r\n    private _loadAsync<T>(nodes: Nullable<Array<number>>, resultFunc: () => T): Promise<T> {\r\n        return Promise.resolve().then(() => {\r\n            this._uniqueRootUrl = (this._rootUrl.indexOf(\"file:\") === -1 && this._fileName) ? this._rootUrl : `${this._rootUrl}${Date.now()}/`;\r\n\r\n            this._loadExtensions();\r\n            this._checkExtensions();\r\n\r\n            const loadingToReadyCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.READY]}`;\r\n            const loadingToCompleteCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.COMPLETE]}`;\r\n\r\n            this._parent._startPerformanceCounter(loadingToReadyCounterName);\r\n            this._parent._startPerformanceCounter(loadingToCompleteCounterName);\r\n\r\n            this._setState(GLTFLoaderState.LOADING);\r\n            this._extensionsOnLoading();\r\n\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            if (nodes) {\r\n                promises.push(this.loadSceneAsync(\"#/nodes\", { nodes: nodes, index: -1 }));\r\n            }\r\n            else {\r\n                const scene = ArrayItem.Get(`#/scene`, this.gltf.scenes, this.gltf.scene || 0);\r\n                promises.push(this.loadSceneAsync(`#/scenes/${scene.index}`, scene));\r\n            }\r\n\r\n            if (this._parent.compileMaterials) {\r\n                promises.push(this._compileMaterialsAsync());\r\n            }\r\n\r\n            if (this._parent.compileShadowGenerators) {\r\n                promises.push(this._compileShadowGeneratorsAsync());\r\n            }\r\n\r\n            const resultPromise = Promise.all(promises).then(() => {\r\n                this._setState(GLTFLoaderState.READY);\r\n                this._extensionsOnReady();\r\n\r\n                this._startAnimations();\r\n\r\n                return resultFunc();\r\n            });\r\n\r\n            resultPromise.then(() => {\r\n                this._parent._endPerformanceCounter(loadingToReadyCounterName);\r\n\r\n                Tools.SetImmediate(() => {\r\n                    if (!this._disposed) {\r\n                        Promise.all(this._completePromises).then(() => {\r\n                            this._parent._endPerformanceCounter(loadingToCompleteCounterName);\r\n\r\n                            this._setState(GLTFLoaderState.COMPLETE);\r\n\r\n                            this._parent.onCompleteObservable.notifyObservers(undefined);\r\n                            this._parent.onCompleteObservable.clear();\r\n\r\n                            this.dispose();\r\n                        }, (error) => {\r\n                            this._parent.onErrorObservable.notifyObservers(error);\r\n                            this._parent.onErrorObservable.clear();\r\n\r\n                            this.dispose();\r\n                        });\r\n                    }\r\n                });\r\n            });\r\n\r\n            return resultPromise;\r\n        }, (error) => {\r\n            if (!this._disposed) {\r\n                this._parent.onErrorObservable.notifyObservers(error);\r\n                this._parent.onErrorObservable.clear();\r\n\r\n                this.dispose();\r\n            }\r\n\r\n            throw error;\r\n        });\r\n    }\r\n\r\n    private _loadData(data: IGLTFLoaderData): void {\r\n        this.gltf = data.json as IGLTFV2;\r\n        this._setupData();\r\n\r\n        if (data.bin) {\r\n            const buffers = this.gltf.buffers;\r\n            if (buffers && buffers[0] && !buffers[0].uri) {\r\n                const binaryBuffer = buffers[0];\r\n                if (binaryBuffer.byteLength < data.bin.byteLength - 3 || binaryBuffer.byteLength > data.bin.byteLength) {\r\n                    Tools.Warn(`Binary buffer length (${binaryBuffer.byteLength}) from JSON does not match chunk length (${data.bin.byteLength})`);\r\n                }\r\n\r\n                binaryBuffer._data = Promise.resolve(data.bin);\r\n            }\r\n            else {\r\n                Tools.Warn(\"Unexpected BIN chunk\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setupData(): void {\r\n        ArrayItem.Assign(this.gltf.accessors);\r\n        ArrayItem.Assign(this.gltf.animations);\r\n        ArrayItem.Assign(this.gltf.buffers);\r\n        ArrayItem.Assign(this.gltf.bufferViews);\r\n        ArrayItem.Assign(this.gltf.cameras);\r\n        ArrayItem.Assign(this.gltf.images);\r\n        ArrayItem.Assign(this.gltf.materials);\r\n        ArrayItem.Assign(this.gltf.meshes);\r\n        ArrayItem.Assign(this.gltf.nodes);\r\n        ArrayItem.Assign(this.gltf.samplers);\r\n        ArrayItem.Assign(this.gltf.scenes);\r\n        ArrayItem.Assign(this.gltf.skins);\r\n        ArrayItem.Assign(this.gltf.textures);\r\n\r\n        if (this.gltf.nodes) {\r\n            const nodeParents: { [index: number]: number } = {};\r\n            for (const node of this.gltf.nodes) {\r\n                if (node.children) {\r\n                    for (const index of node.children) {\r\n                        nodeParents[index] = node.index;\r\n                    }\r\n                }\r\n            }\r\n\r\n            const rootNode = this._createRootNode();\r\n            for (const node of this.gltf.nodes) {\r\n                const parentIndex = nodeParents[node.index];\r\n                node.parent = parentIndex === undefined ? rootNode : this.gltf.nodes[parentIndex];\r\n            }\r\n        }\r\n    }\r\n\r\n    private _loadExtensions(): void {\r\n        for (const name of GLTFLoaderV2._ExtensionNames) {\r\n            const extension = GLTFLoaderV2._ExtensionFactories[name](this);\r\n            this._extensions[name] = extension;\r\n\r\n            this._parent.onExtensionLoadedObservable.notifyObservers(extension);\r\n        }\r\n\r\n        this._parent.onExtensionLoadedObservable.clear();\r\n    }\r\n\r\n    private _checkExtensions(): void {\r\n        if (this.gltf.extensionsRequired) {\r\n            for (const name of this.gltf.extensionsRequired) {\r\n                const extension = this._extensions[name];\r\n                if (!extension || !extension.enabled) {\r\n                    throw new Error(`Require extension ${name} is not available`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setState(state: GLTFLoaderState): void {\r\n        this._state = state;\r\n        this.log(GLTFLoaderState[this._state]);\r\n    }\r\n\r\n    private _createRootNode(): INodeV2 {\r\n        this._rootBabylonMesh = new Mesh(\"__root__\", this.babylonScene);\r\n\r\n        const rootNode: INodeV2 = {\r\n            _babylonMesh: this._rootBabylonMesh,\r\n            index: -1\r\n        };\r\n\r\n        switch (this._parent.coordinateSystemMode) {\r\n            case GLTFLoaderCoordinateSystemMode.AUTO: {\r\n                if (!this.babylonScene.useRightHandedSystem) {\r\n                    rootNode.rotation = [0, 1, 0, 0];\r\n                    rootNode.scale = [1, 1, -1];\r\n                    GLTFLoaderV2._LoadTransform(rootNode, this._rootBabylonMesh);\r\n                }\r\n                break;\r\n            }\r\n            case GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED: {\r\n                this.babylonScene.useRightHandedSystem = true;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`Invalid coordinate system mode (${this._parent.coordinateSystemMode})`);\r\n            }\r\n        }\r\n\r\n        this._parent.onMeshLoadedObservable.notifyObservers(this._rootBabylonMesh);\r\n        return rootNode;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF scene.\r\n     * @param context The context when loading the asset\r\n     * @param scene The glTF scene property\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadSceneAsync(context: string, scene: ISceneV2): Promise<void> {\r\n        const extensionPromise = this._extensionsLoadSceneAsync(context, scene);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${scene.name || \"\"}`);\r\n\r\n        if (scene.nodes) {\r\n            for (let index of scene.nodes) {\r\n                const node = ArrayItem.Get(`${context}/nodes/${index}`, this.gltf.nodes, index);\r\n                promises.push(this.loadNodeAsync(`#/nodes/${node.index}`, node, (babylonMesh) => {\r\n                    babylonMesh.parent = this._rootBabylonMesh;\r\n                }));\r\n            }\r\n        }\r\n\r\n        promises.push(this._loadAnimationsAsync());\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => { });\r\n    }\r\n\r\n    private _forEachPrimitive(node: INodeV2, callback: (babylonMesh: Mesh) => void): void {\r\n        if (node._primitiveBabylonMeshes) {\r\n            for (const babylonMesh of node._primitiveBabylonMeshes) {\r\n                callback(babylonMesh);\r\n            }\r\n        }\r\n        else {\r\n            callback(node._babylonMesh!);\r\n        }\r\n    }\r\n\r\n    private _getMeshes(): Mesh[] {\r\n        const meshes = new Array<Mesh>();\r\n\r\n        // Root mesh is always first.\r\n        meshes.push(this._rootBabylonMesh);\r\n\r\n        const nodes = this.gltf.nodes;\r\n        if (nodes) {\r\n            for (const node of nodes) {\r\n                if (node._babylonMesh) {\r\n                    meshes.push(node._babylonMesh);\r\n                }\r\n\r\n                if (node._primitiveBabylonMeshes) {\r\n                    for (const babylonMesh of node._primitiveBabylonMeshes) {\r\n                        meshes.push(babylonMesh);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return meshes;\r\n    }\r\n\r\n    private _getSkeletons(): Skeleton[] {\r\n        const skeletons = new Array<Skeleton>();\r\n\r\n        const skins = this.gltf.skins;\r\n        if (skins) {\r\n            for (const skin of skins) {\r\n                if (skin._babylonSkeleton) {\r\n                    skeletons.push(skin._babylonSkeleton);\r\n                }\r\n            }\r\n        }\r\n\r\n        return skeletons;\r\n    }\r\n\r\n    private _getAnimationGroups(): AnimationGroup[] {\r\n        const animationGroups = new Array<AnimationGroup>();\r\n\r\n        const animations = this.gltf.animations;\r\n        if (animations) {\r\n            for (const animation of animations) {\r\n                if (animation._babylonAnimationGroup) {\r\n                    animationGroups.push(animation._babylonAnimationGroup);\r\n                }\r\n            }\r\n        }\r\n\r\n        return animationGroups;\r\n    }\r\n\r\n    private _startAnimations(): void {\r\n        switch (this._parent.animationStartMode) {\r\n            case GLTFLoaderAnimationStartMode.NONE: {\r\n                // do nothing\r\n                break;\r\n            }\r\n            case GLTFLoaderAnimationStartMode.FIRST: {\r\n                const babylonAnimationGroups = this._getAnimationGroups();\r\n                if (babylonAnimationGroups.length !== 0) {\r\n                    babylonAnimationGroups[0].start(true);\r\n                }\r\n                break;\r\n            }\r\n            case GLTFLoaderAnimationStartMode.ALL: {\r\n                const babylonAnimationGroups = this._getAnimationGroups();\r\n                for (const babylonAnimationGroup of babylonAnimationGroups) {\r\n                    babylonAnimationGroup.start(true);\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Error(`Invalid animation start mode (${this._parent.animationStartMode})`);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF node.\r\n     * @param context The context when loading the asset\r\n     * @param node The glTF node property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon mesh when the load is complete\r\n     */\r\n    public loadNodeAsync(context: string, node: INodeV2, assign: (babylonMesh: Mesh) => void = () => { }): Promise<Mesh> {\r\n        const extensionPromise = this._extensionsLoadNodeAsync(context, node, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (node._babylonMesh) {\r\n            throw new Error(`${context}: Invalid recursive node hierarchy`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${node.name || \"\"}`);\r\n\r\n        const babylonMesh = new Mesh(node.name || `node${node.index}`, this.babylonScene);\r\n        node._babylonMesh = babylonMesh;\r\n\r\n        babylonMesh.setEnabled(false);\r\n        GLTFLoaderV2._LoadTransform(node, babylonMesh);\r\n\r\n        if (node.mesh != undefined) {\r\n            const mesh = ArrayItem.Get(`${context}/mesh`, this.gltf.meshes, node.mesh);\r\n            promises.push(this._loadMeshAsync(`#/meshes/${mesh.index}`, node, mesh, babylonMesh));\r\n        }\r\n\r\n        if (node.camera != undefined) {\r\n            const camera = ArrayItem.Get(`${context}/camera`, this.gltf.cameras, node.camera);\r\n            promises.push(this.loadCameraAsync(`#/cameras/${camera.index}`, camera, (babylonCamera) => {\r\n                babylonCamera.parent = babylonMesh;\r\n            }));\r\n        }\r\n\r\n        if (node.children) {\r\n            for (const index of node.children) {\r\n                const childNode = ArrayItem.Get(`${context}/children/${index}`, this.gltf.nodes, index);\r\n                promises.push(this.loadNodeAsync(`#/nodes/${node.index}`, childNode, (childBabylonMesh) => {\r\n                    // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\r\n                    if (childNode.skin != undefined) {\r\n                        childBabylonMesh.parent = this._rootBabylonMesh;\r\n                        return;\r\n                    }\r\n\r\n                    childBabylonMesh.parent = babylonMesh;\r\n                }));\r\n            }\r\n        }\r\n\r\n        assign(babylonMesh);\r\n        this._parent.onMeshLoadedObservable.notifyObservers(babylonMesh);\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            babylonMesh.setEnabled(true);\r\n            return babylonMesh;\r\n        });\r\n    }\r\n\r\n    private _loadMeshAsync(context: string, node: INodeV2, mesh: IMeshV2, babylonMesh: Mesh): Promise<void> {\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${mesh.name || \"\"}`);\r\n\r\n        const primitives = mesh.primitives;\r\n        if (!primitives || primitives.length === 0) {\r\n            throw new Error(`${context}: Primitives are missing`);\r\n        }\r\n\r\n        ArrayItem.Assign(primitives);\r\n        if (primitives.length === 1) {\r\n            const primitive = primitives[0];\r\n            promises.push(this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, node, mesh, primitive, babylonMesh));\r\n        }\r\n        else {\r\n            node._primitiveBabylonMeshes = [];\r\n            for (const primitive of primitives) {\r\n                const primitiveBabylonMesh = new Mesh(`${mesh.name || babylonMesh.name}_${primitive.index}`, this.babylonScene, babylonMesh);\r\n                node._primitiveBabylonMeshes.push(primitiveBabylonMesh);\r\n                promises.push(this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, node, mesh, primitive, primitiveBabylonMesh));\r\n                this._parent.onMeshLoadedObservable.notifyObservers(babylonMesh);\r\n            }\r\n        }\r\n\r\n        if (node.skin != undefined) {\r\n            const skin = ArrayItem.Get(`${context}/skin`, this.gltf.skins, node.skin);\r\n            promises.push(this._loadSkinAsync(`#/skins/${skin.index}`, node, skin));\r\n        }\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._forEachPrimitive(node, (babylonMesh) => {\r\n                babylonMesh._refreshBoundingInfo(true);\r\n            });\r\n        });\r\n    }\r\n\r\n    private _loadMeshPrimitiveAsync(context: string, node: INodeV2, mesh: IMeshV2, primitive: IMeshPrimitiveV2, babylonMesh: Mesh): Promise<void> {\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context}`);\r\n\r\n        this._createMorphTargets(context, node, mesh, primitive, babylonMesh);\r\n        promises.push(this._loadVertexDataAsync(context, primitive, babylonMesh).then((babylonGeometry) => {\r\n            return this._loadMorphTargetsAsync(context, primitive, babylonMesh, babylonGeometry).then(() => {\r\n                babylonGeometry.applyToMesh(babylonMesh);\r\n            });\r\n        }));\r\n\r\n        const babylonDrawMode = GLTFLoaderV2._GetDrawMode(context, primitive.mode);\r\n        if (primitive.material == undefined) {\r\n            let babylonMaterial = this._defaultBabylonMaterialData[babylonDrawMode];\r\n            if (!babylonMaterial) {\r\n                babylonMaterial = this._createDefaultMaterial(\"__gltf_default\", babylonDrawMode);\r\n                this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\r\n                this._defaultBabylonMaterialData[babylonDrawMode] = babylonMaterial;\r\n            }\r\n            babylonMesh.material = babylonMaterial;\r\n        }\r\n        else {\r\n            const material = ArrayItem.Get(`${context}/material`, this.gltf.materials, primitive.material);\r\n            promises.push(this._loadMaterialAsync(`#/materials/${material.index}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                babylonMesh.material = babylonMaterial;\r\n            }));\r\n        }\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => { });\r\n    }\r\n\r\n    private _loadVertexDataAsync(context: string, primitive: IMeshPrimitiveV2, babylonMesh: Mesh): Promise<Geometry> {\r\n        const extensionPromise = this._extensionsLoadVertexDataAsync(context, primitive, babylonMesh);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const attributes = primitive.attributes;\r\n        if (!attributes) {\r\n            throw new Error(`${context}: Attributes are missing`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const babylonGeometry = new Geometry(babylonMesh.name, this.babylonScene);\r\n\r\n        if (primitive.indices == undefined) {\r\n            babylonMesh.isUnIndexed = true;\r\n        }\r\n        else {\r\n            const accessor = ArrayItem.Get(`${context}/indices`, this.gltf.accessors, primitive.indices);\r\n            promises.push(this._loadIndicesAccessorAsync(`#/accessors/${accessor.index}`, accessor).then((data) => {\r\n                babylonGeometry.setIndices(data);\r\n            }));\r\n        }\r\n\r\n        const loadAttribute = (attribute: string, kind: string, callback?: (accessor: IAccessorV2) => void) => {\r\n            if (attributes[attribute] == undefined) {\r\n                return;\r\n            }\r\n\r\n            babylonMesh._delayInfo = babylonMesh._delayInfo || [];\r\n            if (babylonMesh._delayInfo.indexOf(kind) === -1) {\r\n                babylonMesh._delayInfo.push(kind);\r\n            }\r\n\r\n            const accessor = ArrayItem.Get(`${context}/attributes/${attribute}`, this.gltf.accessors, attributes[attribute]);\r\n            promises.push(this._loadVertexAccessorAsync(`#/accessors/${accessor.index}`, accessor, kind).then((babylonVertexBuffer) => {\r\n                babylonGeometry.setVerticesBuffer(babylonVertexBuffer, accessor.count);\r\n            }));\r\n\r\n            if (callback) {\r\n                callback(accessor);\r\n            }\r\n        };\r\n\r\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\r\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\r\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\r\n        loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\r\n        loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\r\n        loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\r\n        loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\r\n        loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind, (accessor) => {\r\n            if (accessor.type === AccessorType.VEC4) {\r\n                babylonMesh.hasVertexAlpha = true;\r\n            }\r\n        });\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonGeometry;\r\n        });\r\n    }\r\n\r\n    private _createMorphTargets(context: string, node: INodeV2, mesh: IMeshV2, primitive: IMeshPrimitiveV2, babylonMesh: Mesh): void {\r\n        if (!primitive.targets) {\r\n            return;\r\n        }\r\n\r\n        if (node._numMorphTargets == undefined) {\r\n            node._numMorphTargets = primitive.targets.length;\r\n        }\r\n        else if (primitive.targets.length !== node._numMorphTargets) {\r\n            throw new Error(`${context}: Primitives do not have the same number of targets`);\r\n        }\r\n\r\n        babylonMesh.morphTargetManager = new MorphTargetManager();\r\n        for (let index = 0; index < primitive.targets.length; index++) {\r\n            const weight = node.weights ? node.weights[index] : mesh.weights ? mesh.weights[index] : 0;\r\n            babylonMesh.morphTargetManager.addTarget(new MorphTarget(`morphTarget${index}`, weight));\r\n            // TODO: tell the target whether it has positions, normals, tangents\r\n        }\r\n    }\r\n\r\n    private _loadMorphTargetsAsync(context: string, primitive: IMeshPrimitiveV2, babylonMesh: Mesh, babylonGeometry: Geometry): Promise<void> {\r\n        if (!primitive.targets) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const morphTargetManager = babylonMesh.morphTargetManager!;\r\n        for (let index = 0; index < morphTargetManager.numTargets; index++) {\r\n            const babylonMorphTarget = morphTargetManager.getTarget(index);\r\n            promises.push(this._loadMorphTargetVertexDataAsync(`${context}/targets/${index}`, babylonGeometry, primitive.targets[index], babylonMorphTarget));\r\n        }\r\n\r\n        return Promise.all(promises).then(() => { });\r\n    }\r\n\r\n    private _loadMorphTargetVertexDataAsync(context: string, babylonGeometry: Geometry, attributes: { [name: string]: number }, babylonMorphTarget: MorphTarget): Promise<void> {\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const loadAttribute = (attribute: string, kind: string, setData: (babylonVertexBuffer: VertexBuffer, data: Float32Array) => void) => {\r\n            if (attributes[attribute] == undefined) {\r\n                return;\r\n            }\r\n\r\n            const babylonVertexBuffer = babylonGeometry.getVertexBuffer(kind);\r\n            if (!babylonVertexBuffer) {\r\n                return;\r\n            }\r\n\r\n            const accessor = ArrayItem.Get(`${context}/${attribute}`, this.gltf.accessors, attributes[attribute]);\r\n            promises.push(this._loadFloatAccessorAsync(`#/accessors/${accessor.index}`, accessor).then((data) => {\r\n                setData(babylonVertexBuffer, data);\r\n            }));\r\n        };\r\n\r\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind, (babylonVertexBuffer, data) => {\r\n            babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                data[index] += value;\r\n            });\r\n\r\n            babylonMorphTarget.setPositions(data);\r\n        });\r\n\r\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind, (babylonVertexBuffer, data) => {\r\n            babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                data[index] += value;\r\n            });\r\n\r\n            babylonMorphTarget.setNormals(data);\r\n        });\r\n\r\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind, (babylonVertexBuffer, data) => {\r\n            let dataIndex = 0;\r\n            babylonVertexBuffer.forEach(data.length / 3 * 4, (value, index) => {\r\n                // Tangent data for morph targets is stored as xyz delta.\r\n                // The vertexData.tangent is stored as xyzw.\r\n                // So we need to skip every fourth vertexData.tangent.\r\n                if (((index + 1) % 4) !== 0) {\r\n                    data[dataIndex++] += value;\r\n                }\r\n            });\r\n            babylonMorphTarget.setTangents(data);\r\n        });\r\n\r\n        return Promise.all(promises).then(() => { });\r\n    }\r\n\r\n    private static _LoadTransform(node: INodeV2, babylonNode: TransformNode): void {\r\n        let position = Vector3.Zero();\r\n        let rotation = Quaternion.Identity();\r\n        let scaling = Vector3.One();\r\n\r\n        if (node.matrix) {\r\n            const matrix = Matrix.FromArray(node.matrix);\r\n            matrix.decompose(scaling, rotation, position);\r\n        }\r\n        else {\r\n            if (node.translation) { position = Vector3.FromArray(node.translation); }\r\n            if (node.rotation) { rotation = Quaternion.FromArray(node.rotation); }\r\n            if (node.scale) { scaling = Vector3.FromArray(node.scale); }\r\n        }\r\n\r\n        babylonNode.position = position;\r\n        babylonNode.rotationQuaternion = rotation;\r\n        babylonNode.scaling = scaling;\r\n    }\r\n\r\n    private _loadSkinAsync(context: string, node: INodeV2, skin: ISkinV2): Promise<void> {\r\n        const assignSkeleton = (skeleton: Skeleton) => {\r\n            this._forEachPrimitive(node, (babylonMesh) => {\r\n                babylonMesh.skeleton = skeleton;\r\n            });\r\n\r\n            // Ignore the TRS of skinned nodes.\r\n            // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\r\n            node._babylonMesh!.position = Vector3.Zero();\r\n            node._babylonMesh!.rotationQuaternion = Quaternion.Identity();\r\n            node._babylonMesh!.scaling = Vector3.One();\r\n        };\r\n\r\n        if (skin._promise) {\r\n            return skin._promise.then(() => {\r\n                assignSkeleton(skin._babylonSkeleton!);\r\n            });\r\n        }\r\n\r\n        const skeletonId = `skeleton${skin.index}`;\r\n        const babylonSkeleton = new Skeleton(skin.name || skeletonId, skeletonId, this.babylonScene);\r\n        skin._babylonSkeleton = babylonSkeleton;\r\n        this._loadBones(context, skin);\r\n        assignSkeleton(babylonSkeleton);\r\n\r\n        return (skin._promise = this._loadSkinInverseBindMatricesDataAsync(context, skin).then((inverseBindMatricesData) => {\r\n            this._updateBoneMatrices(babylonSkeleton, inverseBindMatricesData);\r\n        }));\r\n    }\r\n\r\n    private _loadBones(context: string, skin: ISkinV2): void {\r\n        const babylonBones: { [index: number]: Bone } = {};\r\n        for (const index of skin.joints) {\r\n            const node = ArrayItem.Get(`${context}/joints/${index}`, this.gltf.nodes, index);\r\n            this._loadBone(node, skin, babylonBones);\r\n        }\r\n    }\r\n\r\n    private _loadBone(node: INodeV2, skin: ISkinV2, babylonBones: { [index: number]: Bone }): Bone {\r\n        let babylonBone = babylonBones[node.index];\r\n        if (babylonBone) {\r\n            return babylonBone;\r\n        }\r\n\r\n        let babylonParentBone: Nullable<Bone> = null;\r\n        if (node.parent && node.parent._babylonMesh !== this._rootBabylonMesh) {\r\n            babylonParentBone = this._loadBone(node.parent, skin, babylonBones);\r\n        }\r\n\r\n        const boneIndex = skin.joints.indexOf(node.index);\r\n\r\n        babylonBone = new Bone(node.name || `joint${node.index}`, skin._babylonSkeleton!, babylonParentBone, this._getNodeMatrix(node), null, null, boneIndex);\r\n        babylonBones[node.index] = babylonBone;\r\n\r\n        node._babylonBones = node._babylonBones || [];\r\n        node._babylonBones.push(babylonBone);\r\n\r\n        return babylonBone;\r\n    }\r\n\r\n    private _loadSkinInverseBindMatricesDataAsync(context: string, skin: ISkinV2): Promise<Nullable<Float32Array>> {\r\n        if (skin.inverseBindMatrices == undefined) {\r\n            return Promise.resolve(null);\r\n        }\r\n\r\n        const accessor = ArrayItem.Get(`${context}/inverseBindMatrices`, this.gltf.accessors, skin.inverseBindMatrices);\r\n        return this._loadFloatAccessorAsync(`#/accessors/${accessor.index}`, accessor);\r\n    }\r\n\r\n    private _updateBoneMatrices(babylonSkeleton: Skeleton, inverseBindMatricesData: Nullable<Float32Array>): void {\r\n        for (const babylonBone of babylonSkeleton.bones) {\r\n            let baseMatrix = Matrix.Identity();\r\n            const boneIndex = babylonBone._index!;\r\n            if (inverseBindMatricesData && boneIndex !== -1) {\r\n                Matrix.FromArrayToRef(inverseBindMatricesData, boneIndex * 16, baseMatrix);\r\n                baseMatrix.invertToRef(baseMatrix);\r\n            }\r\n\r\n            const babylonParentBone = babylonBone.getParent();\r\n            if (babylonParentBone) {\r\n                baseMatrix.multiplyToRef(babylonParentBone.getInvertedAbsoluteTransform(), baseMatrix);\r\n            }\r\n\r\n            babylonBone.updateMatrix(baseMatrix, false, false);\r\n            babylonBone._updateDifferenceMatrix(undefined, false);\r\n        }\r\n    }\r\n\r\n    private _getNodeMatrix(node: INodeV2): Matrix {\r\n        return node.matrix ?\r\n            Matrix.FromArray(node.matrix) :\r\n            Matrix.Compose(\r\n                node.scale ? Vector3.FromArray(node.scale) : Vector3.One(),\r\n                node.rotation ? Quaternion.FromArray(node.rotation) : Quaternion.Identity(),\r\n                node.translation ? Vector3.FromArray(node.translation) : Vector3.Zero());\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF camera.\r\n     * @param context The context when loading the asset\r\n     * @param camera The glTF camera property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon camera when the load is complete\r\n     */\r\n    public loadCameraAsync(context: string, camera: ICameraV2, assign: (babylonCamera: Camera) => void = () => { }): Promise<Camera> {\r\n        const extensionPromise = this._extensionsLoadCameraAsync(context, camera, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${camera.name || \"\"}`);\r\n\r\n        const babylonCamera = new FreeCamera(camera.name || `camera${camera.index}`, Vector3.Zero(), this.babylonScene, false);\r\n        babylonCamera.rotation = new Vector3(0, Math.PI, 0);\r\n\r\n        switch (camera.type) {\r\n            case CameraType.PERSPECTIVE: {\r\n                const perspective = camera.perspective;\r\n                if (!perspective) {\r\n                    throw new Error(`${context}: Camera perspective properties are missing`);\r\n                }\r\n\r\n                babylonCamera.fov = perspective.yfov;\r\n                babylonCamera.minZ = perspective.znear;\r\n                babylonCamera.maxZ = perspective.zfar || Number.MAX_VALUE;\r\n                break;\r\n            }\r\n            case CameraType.ORTHOGRAPHIC: {\r\n                if (!camera.orthographic) {\r\n                    throw new Error(`${context}: Camera orthographic properties are missing`);\r\n                }\r\n\r\n                babylonCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\r\n                babylonCamera.orthoLeft = -camera.orthographic.xmag;\r\n                babylonCamera.orthoRight = camera.orthographic.xmag;\r\n                babylonCamera.orthoBottom = -camera.orthographic.ymag;\r\n                babylonCamera.orthoTop = camera.orthographic.ymag;\r\n                babylonCamera.minZ = camera.orthographic.znear;\r\n                babylonCamera.maxZ = camera.orthographic.zfar;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}: Invalid camera type (${camera.type})`);\r\n            }\r\n        }\r\n\r\n        assign(babylonCamera);\r\n        this._parent.onCameraLoadedObservable.notifyObservers(babylonCamera);\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonCamera;\r\n        });\r\n    }\r\n\r\n    private _loadAnimationsAsync(): Promise<void> {\r\n        const animations = this.gltf.animations;\r\n        if (!animations) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        for (let index = 0; index < animations.length; index++) {\r\n            const animation = animations[index];\r\n            promises.push(this.loadAnimationAsync(`#/animations/${animation.index}`, animation));\r\n        }\r\n\r\n        return Promise.all(promises).then(() => { });\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF animation.\r\n     * @param context The context when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @returns A promise that resolves with the loaded Babylon animation group when the load is complete\r\n     */\r\n    public loadAnimationAsync(context: string, animation: IAnimationV2): Promise<AnimationGroup> {\r\n        const promise = this._extensionsLoadAnimationAsync(context, animation);\r\n        if (promise) {\r\n            return promise;\r\n        }\r\n\r\n        const babylonAnimationGroup = new AnimationGroup(animation.name || `animation${animation.index}`, this.babylonScene);\r\n        animation._babylonAnimationGroup = babylonAnimationGroup;\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        ArrayItem.Assign(animation.channels);\r\n        ArrayItem.Assign(animation.samplers);\r\n\r\n        for (const channel of animation.channels) {\r\n            promises.push(this._loadAnimationChannelAsync(`${context}/channels/${channel.index}`, context, animation, channel, babylonAnimationGroup));\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            babylonAnimationGroup.normalize(0);\r\n            return babylonAnimationGroup;\r\n        });\r\n    }\r\n\r\n    private _loadAnimationChannelAsync(context: string, animationContext: string, animation: IAnimationV2, channel: IAnimationChannelV2, babylonAnimationGroup: AnimationGroup): Promise<void> {\r\n        const targetNode = ArrayItem.Get(`${context}/target/node`, this.gltf.nodes, channel.target.node);\r\n\r\n        // Ignore animations that have no animation targets.\r\n        if ((channel.target.path === AnimationChannelTargetPath.WEIGHTS && !targetNode._numMorphTargets) ||\r\n            (channel.target.path !== AnimationChannelTargetPath.WEIGHTS && !targetNode._babylonMesh)) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        // Ignore animations targeting TRS of skinned nodes.\r\n        // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\r\n        if (targetNode.skin != undefined && channel.target.path !== AnimationChannelTargetPath.WEIGHTS) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const sampler = ArrayItem.Get(`${context}/sampler`, animation.samplers, channel.sampler);\r\n        return this._loadAnimationSamplerAsync(`${animationContext}/samplers/${channel.sampler}`, sampler).then((data) => {\r\n            let targetPath: string;\r\n            let animationType: number;\r\n            switch (channel.target.path) {\r\n                case AnimationChannelTargetPath.TRANSLATION: {\r\n                    targetPath = \"position\";\r\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\r\n                    break;\r\n                }\r\n                case AnimationChannelTargetPath.ROTATION: {\r\n                    targetPath = \"rotationQuaternion\";\r\n                    animationType = Animation.ANIMATIONTYPE_QUATERNION;\r\n                    break;\r\n                }\r\n                case AnimationChannelTargetPath.SCALE: {\r\n                    targetPath = \"scaling\";\r\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\r\n                    break;\r\n                }\r\n                case AnimationChannelTargetPath.WEIGHTS: {\r\n                    targetPath = \"influence\";\r\n                    animationType = Animation.ANIMATIONTYPE_FLOAT;\r\n                    break;\r\n                }\r\n                default: {\r\n                    throw new Error(`${context}/target/path: Invalid value (${channel.target.path})`);\r\n                }\r\n            }\r\n\r\n            let outputBufferOffset = 0;\r\n            let getNextOutputValue: () => Vector3 | Quaternion | Array<number>;\r\n            switch (targetPath) {\r\n                case \"position\": {\r\n                    getNextOutputValue = () => {\r\n                        const value = Vector3.FromArray(data.output, outputBufferOffset);\r\n                        outputBufferOffset += 3;\r\n                        return value;\r\n                    };\r\n                    break;\r\n                }\r\n                case \"rotationQuaternion\": {\r\n                    getNextOutputValue = () => {\r\n                        const value = Quaternion.FromArray(data.output, outputBufferOffset);\r\n                        outputBufferOffset += 4;\r\n                        return value;\r\n                    };\r\n                    break;\r\n                }\r\n                case \"scaling\": {\r\n                    getNextOutputValue = () => {\r\n                        const value = Vector3.FromArray(data.output, outputBufferOffset);\r\n                        outputBufferOffset += 3;\r\n                        return value;\r\n                    };\r\n                    break;\r\n                }\r\n                case \"influence\": {\r\n                    getNextOutputValue = () => {\r\n                        const value = new Array<number>(targetNode._numMorphTargets!);\r\n                        for (let i = 0; i < targetNode._numMorphTargets!; i++) {\r\n                            value[i] = data.output[outputBufferOffset++];\r\n                        }\r\n                        return value;\r\n                    };\r\n                    break;\r\n                }\r\n            }\r\n\r\n            let getNextKey: (frameIndex: number) => IAnimationKey;\r\n            switch (data.interpolation) {\r\n                case AnimationSamplerInterpolation.STEP: {\r\n                    getNextKey = (frameIndex) => ({\r\n                        frame: data.input[frameIndex],\r\n                        value: getNextOutputValue(),\r\n                        interpolation: AnimationKeyInterpolation.STEP\r\n                    });\r\n                    break;\r\n                }\r\n                case AnimationSamplerInterpolation.LINEAR: {\r\n                    getNextKey = (frameIndex) => ({\r\n                        frame: data.input[frameIndex],\r\n                        value: getNextOutputValue()\r\n                    });\r\n                    break;\r\n                }\r\n                case AnimationSamplerInterpolation.CUBICSPLINE: {\r\n                    getNextKey = (frameIndex) => ({\r\n                        frame: data.input[frameIndex],\r\n                        inTangent: getNextOutputValue(),\r\n                        value: getNextOutputValue(),\r\n                        outTangent: getNextOutputValue()\r\n                    });\r\n                    break;\r\n                }\r\n            }\r\n\r\n            const keys = new Array(data.input.length);\r\n            for (let frameIndex = 0; frameIndex < data.input.length; frameIndex++) {\r\n                keys[frameIndex] = getNextKey!(frameIndex);\r\n            }\r\n\r\n            if (targetPath === \"influence\") {\r\n                for (let targetIndex = 0; targetIndex < targetNode._numMorphTargets!; targetIndex++) {\r\n                    const animationName = `${babylonAnimationGroup.name}_channel${babylonAnimationGroup.targetedAnimations.length}`;\r\n                    const babylonAnimation = new Animation(animationName, targetPath, 1, animationType);\r\n                    babylonAnimation.setKeys(keys.map((key) => ({\r\n                        frame: key.frame,\r\n                        inTangent: key.inTangent ? key.inTangent[targetIndex] : undefined,\r\n                        value: key.value[targetIndex],\r\n                        outTangent: key.outTangent ? key.outTangent[targetIndex] : undefined\r\n                    })));\r\n\r\n                    this._forEachPrimitive(targetNode, (babylonMesh) => {\r\n                        const morphTarget = babylonMesh.morphTargetManager!.getTarget(targetIndex);\r\n                        const babylonAnimationClone = babylonAnimation.clone();\r\n                        morphTarget.animations.push(babylonAnimationClone);\r\n                        babylonAnimationGroup.addTargetedAnimation(babylonAnimationClone, morphTarget);\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                const animationName = `${babylonAnimationGroup.name}_channel${babylonAnimationGroup.targetedAnimations.length}`;\r\n                const babylonAnimation = new Animation(animationName, targetPath, 1, animationType);\r\n                babylonAnimation.setKeys(keys);\r\n\r\n                if (targetNode._babylonBones) {\r\n                    const babylonAnimationTargets = [targetNode._babylonMesh!, ...targetNode._babylonBones];\r\n                    for (const babylonAnimationTarget of babylonAnimationTargets) {\r\n                        babylonAnimationTarget.animations.push(babylonAnimation);\r\n                    }\r\n                    babylonAnimationGroup.addTargetedAnimation(babylonAnimation, babylonAnimationTargets);\r\n                }\r\n                else {\r\n                    targetNode._babylonMesh!.animations.push(babylonAnimation);\r\n                    babylonAnimationGroup.addTargetedAnimation(babylonAnimation, targetNode._babylonMesh);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _loadAnimationSamplerAsync(context: string, sampler: IAnimationSamplerV2): Promise<_IAnimationSamplerDataV2> {\r\n        if (sampler._data) {\r\n            return sampler._data;\r\n        }\r\n\r\n        const interpolation = sampler.interpolation || AnimationSamplerInterpolation.LINEAR;\r\n        switch (interpolation) {\r\n            case AnimationSamplerInterpolation.STEP:\r\n            case AnimationSamplerInterpolation.LINEAR:\r\n            case AnimationSamplerInterpolation.CUBICSPLINE: {\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}/interpolation: Invalid value (${sampler.interpolation})`);\r\n            }\r\n        }\r\n\r\n        const inputAccessor = ArrayItem.Get(`${context}/input`, this.gltf.accessors, sampler.input);\r\n        const outputAccessor = ArrayItem.Get(`${context}/output`, this.gltf.accessors, sampler.output);\r\n        sampler._data = Promise.all([\r\n            this._loadFloatAccessorAsync(`#/accessors/${inputAccessor.index}`, inputAccessor),\r\n            this._loadFloatAccessorAsync(`#/accessors/${outputAccessor.index}`, outputAccessor)\r\n        ]).then(([inputData, outputData]) => {\r\n            return {\r\n                input: inputData,\r\n                interpolation: interpolation,\r\n                output: outputData,\r\n            };\r\n        });\r\n\r\n        return sampler._data;\r\n    }\r\n\r\n    private _loadBufferAsync(context: string, buffer: IBufferV2): Promise<ArrayBufferView> {\r\n        if (buffer._data) {\r\n            return buffer._data;\r\n        }\r\n\r\n        if (!buffer.uri) {\r\n            throw new Error(`${context}/uri: Value is missing`);\r\n        }\r\n\r\n        buffer._data = this.loadUriAsync(`${context}/uri`, buffer.uri);\r\n\r\n        return buffer._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF buffer view.\r\n     * @param context The context when loading the asset\r\n     * @param bufferView The glTF buffer view property\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadBufferViewAsync(context: string, bufferView: IBufferViewV2): Promise<ArrayBufferView> {\r\n        if (bufferView._data) {\r\n            return bufferView._data;\r\n        }\r\n\r\n        const buffer = ArrayItem.Get(`${context}/buffer`, this.gltf.buffers, bufferView.buffer);\r\n        bufferView._data = this._loadBufferAsync(`#/buffers/${buffer.index}`, buffer).then((data) => {\r\n            try {\r\n                return new Uint8Array(data.buffer, data.byteOffset + (bufferView.byteOffset || 0), bufferView.byteLength);\r\n            }\r\n            catch (e) {\r\n                throw new Error(`${context}: ${e.message}`);\r\n            }\r\n        });\r\n\r\n        return bufferView._data;\r\n    }\r\n\r\n    private _loadIndicesAccessorAsync(context: string, accessor: IAccessorV2): Promise<IndicesArray> {\r\n        if (accessor.type !== AccessorType.SCALAR) {\r\n            throw new Error(`${context}/type: Invalid value ${accessor.type}`);\r\n        }\r\n\r\n        if (accessor.componentType !== AccessorComponentType.UNSIGNED_BYTE &&\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_SHORT &&\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_INT) {\r\n            throw new Error(`${context}/componentType: Invalid value ${accessor.componentType}`);\r\n        }\r\n\r\n        if (accessor._data) {\r\n            return accessor._data as Promise<IndicesArray>;\r\n        }\r\n\r\n        const bufferView = ArrayItem.Get(`${context}/bufferView`, this.gltf.bufferViews, accessor.bufferView);\r\n        accessor._data = this.loadBufferViewAsync(`#/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n            return GLTFLoaderV2._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, accessor.count);\r\n        });\r\n\r\n        return accessor._data as Promise<IndicesArray>;\r\n    }\r\n\r\n    private _loadFloatAccessorAsync(context: string, accessor: IAccessorV2): Promise<Float32Array> {\r\n        // TODO: support normalized and stride\r\n\r\n        if (accessor.componentType !== AccessorComponentType.FLOAT) {\r\n            throw new Error(`Invalid component type ${accessor.componentType}`);\r\n        }\r\n\r\n        if (accessor._data) {\r\n            return accessor._data as Promise<Float32Array>;\r\n        }\r\n\r\n        const numComponents = GLTFLoaderV2._GetNumComponents(context, accessor.type);\r\n        const length = numComponents * accessor.count;\r\n\r\n        if (accessor.bufferView == undefined) {\r\n            accessor._data = Promise.resolve(new Float32Array(length));\r\n        }\r\n        else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this.gltf.bufferViews, accessor.bufferView);\r\n            accessor._data = this.loadBufferViewAsync(`#/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n                return GLTFLoaderV2._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, length);\r\n            });\r\n        }\r\n\r\n        if (accessor.sparse) {\r\n            const sparse = accessor.sparse;\r\n            accessor._data = accessor._data.then((data: Float32Array) => {\r\n                const indicesBufferView = ArrayItem.Get(`${context}/sparse/indices/bufferView`, this.gltf.bufferViews, sparse.indices.bufferView);\r\n                const valuesBufferView = ArrayItem.Get(`${context}/sparse/values/bufferView`, this.gltf.bufferViews, sparse.values.bufferView);\r\n                return Promise.all([\r\n                    this.loadBufferViewAsync(`#/bufferViews/${indicesBufferView.index}`, indicesBufferView),\r\n                    this.loadBufferViewAsync(`#/bufferViews/${valuesBufferView.index}`, valuesBufferView)\r\n                ]).then(([indicesData, valuesData]) => {\r\n                    const indices = GLTFLoaderV2._GetTypedArray(`${context}/sparse/indices`, sparse.indices.componentType, indicesData, sparse.indices.byteOffset, sparse.count) as IndicesArray;\r\n                    const values = GLTFLoaderV2._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, numComponents * sparse.count) as Float32Array;\r\n\r\n                    let valuesIndex = 0;\r\n                    for (let indicesIndex = 0; indicesIndex < indices.length; indicesIndex++) {\r\n                        let dataIndex = indices[indicesIndex] * numComponents;\r\n                        for (let componentIndex = 0; componentIndex < numComponents; componentIndex++) {\r\n                            data[dataIndex++] = values[valuesIndex++];\r\n                        }\r\n                    }\r\n\r\n                    return data;\r\n                });\r\n            });\r\n        }\r\n\r\n        return accessor._data as Promise<Float32Array>;\r\n    }\r\n\r\n    private _loadVertexBufferViewAsync(bufferView: IBufferViewV2, kind: string): Promise<Buffer> {\r\n        if (bufferView._babylonBuffer) {\r\n            return bufferView._babylonBuffer;\r\n        }\r\n\r\n        bufferView._babylonBuffer = this.loadBufferViewAsync(`#/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n            return new Buffer(this.babylonScene.getEngine(), data, false);\r\n        });\r\n\r\n        return bufferView._babylonBuffer;\r\n    }\r\n\r\n    private _loadVertexAccessorAsync(context: string, accessor: IAccessorV2, kind: string): Promise<VertexBuffer> {\r\n        if (accessor._babylonVertexBuffer) {\r\n            return accessor._babylonVertexBuffer;\r\n        }\r\n\r\n        if (accessor.sparse) {\r\n            accessor._babylonVertexBuffer = this._loadFloatAccessorAsync(`#/accessors/${accessor.index}`, accessor).then((data) => {\r\n                return new VertexBuffer(this.babylonScene.getEngine(), data, kind, false);\r\n            });\r\n        }\r\n        // HACK: If byte offset is not a multiple of component type byte length then load as a float array instead of using Babylon buffers.\r\n        else if (accessor.byteOffset && accessor.byteOffset % VertexBuffer.GetTypeByteLength(accessor.componentType) !== 0) {\r\n            Tools.Warn(\"Accessor byte offset is not a multiple of component type byte length\");\r\n            accessor._babylonVertexBuffer = this._loadFloatAccessorAsync(`#/accessors/${accessor.index}`, accessor).then((data) => {\r\n                return new VertexBuffer(this.babylonScene.getEngine(), data, kind, false);\r\n            });\r\n        }\r\n        else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this.gltf.bufferViews, accessor.bufferView);\r\n            accessor._babylonVertexBuffer = this._loadVertexBufferViewAsync(bufferView, kind).then((babylonBuffer) => {\r\n                const size = GLTFLoaderV2._GetNumComponents(context, accessor.type);\r\n                return new VertexBuffer(this.babylonScene.getEngine(), babylonBuffer, kind, false, false, bufferView.byteStride,\r\n                    false, accessor.byteOffset, size, accessor.componentType, accessor.normalized, true);\r\n            });\r\n        }\r\n\r\n        return accessor._babylonVertexBuffer;\r\n    }\r\n\r\n    private _loadMaterialMetallicRoughnessPropertiesAsync(context: string, properties: IMaterialPbrMetallicRoughnessV2, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        if (properties) {\r\n            if (properties.baseColorFactor) {\r\n                babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);\r\n                babylonMaterial.alpha = properties.baseColorFactor[3];\r\n            }\r\n            else {\r\n                babylonMaterial.albedoColor = Color3.White();\r\n            }\r\n\r\n            babylonMaterial.metallic = properties.metallicFactor == undefined ? 1 : properties.metallicFactor;\r\n            babylonMaterial.roughness = properties.roughnessFactor == undefined ? 1 : properties.roughnessFactor;\r\n\r\n            if (properties.baseColorTexture) {\r\n                promises.push(this.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {\r\n                    babylonMaterial.albedoTexture = texture;\r\n                }));\r\n            }\r\n\r\n            if (properties.metallicRoughnessTexture) {\r\n                promises.push(this.loadTextureInfoAsync(`${context}/metallicRoughnessTexture`, properties.metallicRoughnessTexture, (texture) => {\r\n                    babylonMaterial.metallicTexture = texture;\r\n                }));\r\n\r\n                babylonMaterial.useMetallnessFromMetallicTextureBlue = true;\r\n                babylonMaterial.useRoughnessFromMetallicTextureGreen = true;\r\n                babylonMaterial.useRoughnessFromMetallicTextureAlpha = false;\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => { });\r\n    }\r\n\r\n    /** @hidden */\r\n    public _loadMaterialAsync(context: string, material: IMaterialV2, babylonMesh: Mesh, babylonDrawMode: number, assign: (babylonMaterial: Material) => void = () => { }): Promise<Material> {\r\n        const extensionPromise = this._extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        material._babylonData = material._babylonData || {};\r\n        let babylonData = material._babylonData[babylonDrawMode];\r\n        if (!babylonData) {\r\n            this.logOpen(`${context} ${material.name || \"\"}`);\r\n\r\n            const babylonMaterial = this.createMaterial(context, material, babylonDrawMode);\r\n\r\n            babylonData = {\r\n                material: babylonMaterial,\r\n                meshes: [],\r\n                promise: this.loadMaterialPropertiesAsync(context, material, babylonMaterial)\r\n            };\r\n\r\n            material._babylonData[babylonDrawMode] = babylonData;\r\n\r\n            this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\r\n\r\n            this.logClose();\r\n        }\r\n\r\n        babylonData.meshes.push(babylonMesh);\r\n\r\n        babylonMesh.onDisposeObservable.addOnce(() => {\r\n            const index = babylonData.meshes.indexOf(babylonMesh);\r\n            if (index !== -1) {\r\n                babylonData.meshes.splice(index, 1);\r\n            }\r\n        });\r\n\r\n        assign(babylonData.material);\r\n\r\n        return babylonData.promise.then(() => {\r\n            return babylonData.material;\r\n        });\r\n    }\r\n\r\n    private _createDefaultMaterial(name: string, babylonDrawMode: number): Material {\r\n        const babylonMaterial = new PBRMaterial(name, this.babylonScene);\r\n        babylonMaterial.sideOrientation = this.babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n        babylonMaterial.fillMode = babylonDrawMode;\r\n        babylonMaterial.enableSpecularAntiAliasing = true;\r\n        babylonMaterial.useRadianceOverAlpha = !this._parent.transparencyAsCoverage;\r\n        babylonMaterial.useSpecularOverAlpha = !this._parent.transparencyAsCoverage;\r\n        babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\r\n        babylonMaterial.metallic = 1;\r\n        babylonMaterial.roughness = 1;\r\n        return babylonMaterial;\r\n    }\r\n\r\n    /**\r\n     * Creates a Babylon material from a glTF material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonDrawMode The draw mode for the Babylon material\r\n     * @returns The Babylon material\r\n     */\r\n    public createMaterial(context: string, material: IMaterialV2, babylonDrawMode: number): Material {\r\n        const extensionPromise = this._extensionsCreateMaterial(context, material, babylonDrawMode);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const name = material.name || `material${material.index}`;\r\n        return this._createDefaultMaterial(name, babylonDrawMode);\r\n    }\r\n\r\n    /**\r\n     * Loads properties from a glTF material into a Babylon material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterialV2, babylonMaterial: Material): Promise<void> {\r\n        const extensionPromise = this._extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        promises.push(this.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\r\n\r\n        if (material.pbrMetallicRoughness) {\r\n            promises.push(this._loadMaterialMetallicRoughnessPropertiesAsync(`${context}/pbrMetallicRoughness`, material.pbrMetallicRoughness, babylonMaterial));\r\n        }\r\n\r\n        this.loadMaterialAlphaProperties(context, material, babylonMaterial);\r\n\r\n        return Promise.all(promises).then(() => { });\r\n    }\r\n\r\n    /**\r\n     * Loads the normal, occlusion, and emissive properties from a glTF material into a Babylon material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadMaterialBasePropertiesAsync(context: string, material: IMaterialV2, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        babylonMaterial.emissiveColor = material.emissiveFactor ? Color3.FromArray(material.emissiveFactor) : new Color3(0, 0, 0);\r\n        if (material.doubleSided) {\r\n            babylonMaterial.backFaceCulling = false;\r\n            babylonMaterial.twoSidedLighting = true;\r\n        }\r\n\r\n        if (material.normalTexture) {\r\n            promises.push(this.loadTextureInfoAsync(`${context}/normalTexture`, material.normalTexture, (texture) => {\r\n                babylonMaterial.bumpTexture = texture;\r\n            }));\r\n\r\n            babylonMaterial.invertNormalMapX = !this.babylonScene.useRightHandedSystem;\r\n            babylonMaterial.invertNormalMapY = this.babylonScene.useRightHandedSystem;\r\n            if (material.normalTexture.scale != undefined) {\r\n                babylonMaterial.bumpTexture.level = material.normalTexture.scale;\r\n            }\r\n        }\r\n\r\n        if (material.occlusionTexture) {\r\n            promises.push(this.loadTextureInfoAsync(`${context}/occlusionTexture`, material.occlusionTexture, (texture) => {\r\n                babylonMaterial.ambientTexture = texture;\r\n            }));\r\n\r\n            babylonMaterial.useAmbientInGrayScale = true;\r\n            if (material.occlusionTexture.strength != undefined) {\r\n                babylonMaterial.ambientTextureStrength = material.occlusionTexture.strength;\r\n            }\r\n        }\r\n\r\n        if (material.emissiveTexture) {\r\n            promises.push(this.loadTextureInfoAsync(`${context}/emissiveTexture`, material.emissiveTexture, (texture) => {\r\n                babylonMaterial.emissiveTexture = texture;\r\n            }));\r\n        }\r\n\r\n        return Promise.all(promises).then(() => { });\r\n    }\r\n\r\n    /**\r\n     * Loads the alpha properties from a glTF material into a Babylon material.\r\n     * Must be called after the setting the albedo texture of the Babylon material when the material has an albedo texture.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     */\r\n    public loadMaterialAlphaProperties(context: string, material: IMaterialV2, babylonMaterial: Material): void {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const alphaMode = material.alphaMode || MaterialAlphaMode.OPAQUE;\r\n        switch (alphaMode) {\r\n            case MaterialAlphaMode.OPAQUE: {\r\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\r\n                break;\r\n            }\r\n            case MaterialAlphaMode.MASK: {\r\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHATEST;\r\n                babylonMaterial.alphaCutOff = (material.alphaCutoff == undefined ? 0.5 : material.alphaCutoff);\r\n                if (babylonMaterial.albedoTexture) {\r\n                    babylonMaterial.albedoTexture.hasAlpha = true;\r\n                }\r\n                break;\r\n            }\r\n            case MaterialAlphaMode.BLEND: {\r\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHABLEND;\r\n                if (babylonMaterial.albedoTexture) {\r\n                    babylonMaterial.albedoTexture.hasAlpha = true;\r\n                    babylonMaterial.useAlphaFromAlbedoTexture = true;\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}/alphaMode: Invalid value (${material.alphaMode})`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF texture info.\r\n     * @param context The context when loading the asset\r\n     * @param textureInfo The glTF texture info property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon texture when the load is complete\r\n     */\r\n    public loadTextureInfoAsync(context: string, textureInfo: ITextureInfoV2, assign: (babylonTexture: BaseTexture) => void = () => { }): Promise<BaseTexture> {\r\n        const extensionPromise = this._extensionsLoadTextureInfoAsync(context, textureInfo, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        this.logOpen(`${context}`);\r\n\r\n        const texture = ArrayItem.Get(`${context}/index`, this.gltf.textures, textureInfo.index);\r\n        const promise = this._loadTextureAsync(`#/textures/${textureInfo.index}`, texture, (babylonTexture) => {\r\n            babylonTexture.coordinatesIndex = textureInfo.texCoord || 0;\r\n            assign(babylonTexture);\r\n        });\r\n\r\n        this.logClose();\r\n\r\n        return promise;\r\n    }\r\n\r\n    private _loadTextureAsync(context: string, texture: ITextureV2, assign: (babylonTexture: BaseTexture) => void = () => { }): Promise<BaseTexture> {\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${texture.name || \"\"}`);\r\n\r\n        const sampler = (texture.sampler == undefined ? GLTFLoaderV2._DefaultSampler : ArrayItem.Get(`${context}/sampler`, this.gltf.samplers, texture.sampler));\r\n        const samplerData = this._loadSampler(`#/samplers/${sampler.index}`, sampler);\r\n\r\n        const deferred = new Deferred<void>();\r\n        const babylonTexture = new Texture(null, this.babylonScene, samplerData.noMipMaps, false, samplerData.samplingMode, () => {\r\n            if (!this._disposed) {\r\n                deferred.resolve();\r\n            }\r\n        }, (message, exception) => {\r\n            if (!this._disposed) {\r\n                deferred.reject(new Error(`${context}: ${(exception && exception.message) ? exception.message : message || \"Failed to load texture\"}`));\r\n            }\r\n        });\r\n        promises.push(deferred.promise);\r\n\r\n        babylonTexture.name = texture.name || `texture${texture.index}`;\r\n        babylonTexture.wrapU = samplerData.wrapU;\r\n        babylonTexture.wrapV = samplerData.wrapV;\r\n\r\n        const image = ArrayItem.Get(`${context}/source`, this.gltf.images, texture.source);\r\n        promises.push(this.loadImageAsync(`#/images/${image.index}`, image).then((data) => {\r\n            const name = image.uri || `${this._fileName}#image${image.index}`;\r\n            const dataUrl = `data:${this._uniqueRootUrl}${name}`;\r\n            babylonTexture.updateURL(dataUrl, new Blob([data], { type: image.mimeType }));\r\n        }));\r\n\r\n        assign(babylonTexture);\r\n        this._parent.onTextureLoadedObservable.notifyObservers(babylonTexture);\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonTexture;\r\n        });\r\n    }\r\n\r\n    private _loadSampler(context: string, sampler: ISamplerV2): _ISamplerDataV2 {\r\n        if (!sampler._data) {\r\n            sampler._data = {\r\n                noMipMaps: (sampler.minFilter === TextureMinFilter.NEAREST || sampler.minFilter === TextureMinFilter.LINEAR),\r\n                samplingMode: GLTFLoaderV2._GetTextureSamplingMode(context, sampler),\r\n                wrapU: GLTFLoaderV2._GetTextureWrapMode(`${context}/wrapS`, sampler.wrapS),\r\n                wrapV: GLTFLoaderV2._GetTextureWrapMode(`${context}/wrapT`, sampler.wrapT)\r\n            };\r\n        }\r\n\r\n        return sampler._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF image.\r\n     * @param context The context when loading the asset\r\n     * @param image The glTF image property\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadImageAsync(context: string, image: IImageV2): Promise<ArrayBufferView> {\r\n        if (!image._data) {\r\n            this.logOpen(`${context} ${image.name || \"\"}`);\r\n\r\n            if (image.uri) {\r\n                image._data = this.loadUriAsync(`${context}/uri`, image.uri);\r\n            }\r\n            else {\r\n                const bufferView = ArrayItem.Get(`${context}/bufferView`, this.gltf.bufferViews, image.bufferView);\r\n                image._data = this.loadBufferViewAsync(`#/bufferViews/${bufferView.index}`, bufferView);\r\n            }\r\n\r\n            this.logClose();\r\n        }\r\n\r\n        return image._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF uri.\r\n     * @param context The context when loading the asset\r\n     * @param uri The base64 or relative uri\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadUriAsync(context: string, uri: string): Promise<ArrayBufferView> {\r\n        const extensionPromise = this._extensionsLoadUriAsync(context, uri);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (!GLTFLoaderV2._ValidateUri(uri)) {\r\n            throw new Error(`${context}: '${uri}' is invalid`);\r\n        }\r\n\r\n        if (Tools.IsBase64(uri)) {\r\n            const data = new Uint8Array(Tools.DecodeBase64(uri));\r\n            this.log(`Decoded ${uri.substr(0, 64)}... (${data.length} bytes)`);\r\n            return Promise.resolve(data);\r\n        }\r\n\r\n        this.log(`Loading ${uri}`);\r\n\r\n        return this._parent.preprocessUrlAsync(this._rootUrl + uri).then((url) => {\r\n            return new Promise<ArrayBufferView>((resolve, reject) => {\r\n                if (!this._disposed) {\r\n                    const request = Tools.LoadFile(url, (fileData) => {\r\n                        if (!this._disposed) {\r\n                            const data = new Uint8Array(fileData as ArrayBuffer);\r\n                            this.log(`Loaded ${uri} (${data.length} bytes)`);\r\n                            resolve(data);\r\n                        }\r\n                    }, (event) => {\r\n                        if (!this._disposed) {\r\n                            if (request) {\r\n                                request._lengthComputable = event.lengthComputable;\r\n                                request._loaded = event.loaded;\r\n                                request._total = event.total;\r\n                            }\r\n\r\n                            if (this._state === GLTFLoaderState.LOADING) {\r\n                                try {\r\n                                    this._onProgress();\r\n                                }\r\n                                catch (e) {\r\n                                    reject(e);\r\n                                }\r\n                            }\r\n                        }\r\n                    }, this.babylonScene.offlineProvider, true, (request, exception) => {\r\n                        if (!this._disposed) {\r\n                            reject(new LoadFileError(`${context}: Failed to load '${uri}'${request ? \": \" + request.status + \" \" + request.statusText : \"\"}`, request));\r\n                        }\r\n                    }) as IFileRequestInfo;\r\n\r\n                    this._requests.push(request);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    private _onProgress(): void {\r\n        if (!this._progressCallback) {\r\n            return;\r\n        }\r\n\r\n        let lengthComputable = true;\r\n        let loaded = 0;\r\n        let total = 0;\r\n        for (let request of this._requests) {\r\n            if (request._lengthComputable === undefined || request._loaded === undefined || request._total === undefined) {\r\n                return;\r\n            }\r\n\r\n            lengthComputable = lengthComputable && request._lengthComputable;\r\n            loaded += request._loaded;\r\n            total += request._total;\r\n        }\r\n\r\n        this._progressCallback(new SceneLoaderProgressEvent(lengthComputable, loaded, lengthComputable ? total : 0));\r\n    }\r\n\r\n    private static _GetTextureWrapMode(context: string, mode: TextureWrapMode | undefined): number {\r\n        // Set defaults if undefined\r\n        mode = mode == undefined ? TextureWrapMode.REPEAT : mode;\r\n\r\n        switch (mode) {\r\n            case TextureWrapMode.CLAMP_TO_EDGE: return Texture.CLAMP_ADDRESSMODE;\r\n            case TextureWrapMode.MIRRORED_REPEAT: return Texture.MIRROR_ADDRESSMODE;\r\n            case TextureWrapMode.REPEAT: return Texture.WRAP_ADDRESSMODE;\r\n            default:\r\n                Tools.Warn(`${context}: Invalid value (${mode})`);\r\n                return Texture.WRAP_ADDRESSMODE;\r\n        }\r\n    }\r\n\r\n    private static _GetTextureSamplingMode(context: string, sampler: ISamplerV2): number {\r\n        // Set defaults if undefined\r\n        const magFilter = sampler.magFilter == undefined ? TextureMagFilter.LINEAR : sampler.magFilter;\r\n        const minFilter = sampler.minFilter == undefined ? TextureMinFilter.LINEAR_MIPMAP_LINEAR : sampler.minFilter;\r\n\r\n        if (magFilter === TextureMagFilter.LINEAR) {\r\n            switch (minFilter) {\r\n                case TextureMinFilter.NEAREST: return Texture.LINEAR_NEAREST;\r\n                case TextureMinFilter.LINEAR: return Texture.LINEAR_LINEAR;\r\n                case TextureMinFilter.NEAREST_MIPMAP_NEAREST: return Texture.LINEAR_NEAREST_MIPNEAREST;\r\n                case TextureMinFilter.LINEAR_MIPMAP_NEAREST: return Texture.LINEAR_LINEAR_MIPNEAREST;\r\n                case TextureMinFilter.NEAREST_MIPMAP_LINEAR: return Texture.LINEAR_NEAREST_MIPLINEAR;\r\n                case TextureMinFilter.LINEAR_MIPMAP_LINEAR: return Texture.LINEAR_LINEAR_MIPLINEAR;\r\n                default:\r\n                    Tools.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\r\n                    return Texture.LINEAR_LINEAR_MIPLINEAR;\r\n            }\r\n        }\r\n        else {\r\n            if (magFilter !== TextureMagFilter.NEAREST) {\r\n                Tools.Warn(`${context}/magFilter: Invalid value (${magFilter})`);\r\n            }\r\n\r\n            switch (minFilter) {\r\n                case TextureMinFilter.NEAREST: return Texture.NEAREST_NEAREST;\r\n                case TextureMinFilter.LINEAR: return Texture.NEAREST_LINEAR;\r\n                case TextureMinFilter.NEAREST_MIPMAP_NEAREST: return Texture.NEAREST_NEAREST_MIPNEAREST;\r\n                case TextureMinFilter.LINEAR_MIPMAP_NEAREST: return Texture.NEAREST_LINEAR_MIPNEAREST;\r\n                case TextureMinFilter.NEAREST_MIPMAP_LINEAR: return Texture.NEAREST_NEAREST_MIPLINEAR;\r\n                case TextureMinFilter.LINEAR_MIPMAP_LINEAR: return Texture.NEAREST_LINEAR_MIPLINEAR;\r\n                default:\r\n                    Tools.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\r\n                    return Texture.NEAREST_NEAREST_MIPNEAREST;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _GetTypedArray(context: string, componentType: AccessorComponentType, bufferView: ArrayBufferView, byteOffset: number | undefined, length: number): ArrayBufferView {\r\n        const buffer = bufferView.buffer;\r\n        byteOffset = bufferView.byteOffset + (byteOffset || 0);\r\n\r\n        try {\r\n            switch (componentType) {\r\n                case AccessorComponentType.BYTE: return new Int8Array(buffer, byteOffset, length);\r\n                case AccessorComponentType.UNSIGNED_BYTE: return new Uint8Array(buffer, byteOffset, length);\r\n                case AccessorComponentType.SHORT: return new Int16Array(buffer, byteOffset, length);\r\n                case AccessorComponentType.UNSIGNED_SHORT: return new Uint16Array(buffer, byteOffset, length);\r\n                case AccessorComponentType.UNSIGNED_INT: return new Uint32Array(buffer, byteOffset, length);\r\n                case AccessorComponentType.FLOAT: return new Float32Array(buffer, byteOffset, length);\r\n                default: throw new Error(`Invalid component type ${componentType}`);\r\n            }\r\n        }\r\n        catch (e) {\r\n            throw new Error(`${context}: ${e}`);\r\n        }\r\n    }\r\n\r\n    private static _GetNumComponents(context: string, type: string): number {\r\n        switch (type) {\r\n            case \"SCALAR\": return 1;\r\n            case \"VEC2\": return 2;\r\n            case \"VEC3\": return 3;\r\n            case \"VEC4\": return 4;\r\n            case \"MAT2\": return 4;\r\n            case \"MAT3\": return 9;\r\n            case \"MAT4\": return 16;\r\n        }\r\n\r\n        throw new Error(`${context}: Invalid type (${type})`);\r\n    }\r\n\r\n    private static _ValidateUri(uri: string): boolean {\r\n        return (Tools.IsBase64(uri) || uri.indexOf(\"..\") === -1);\r\n    }\r\n\r\n    private static _GetDrawMode(context: string, mode: number | undefined): number {\r\n        if (mode == undefined) {\r\n            mode = MeshPrimitiveMode.TRIANGLES;\r\n        }\r\n\r\n        switch (mode) {\r\n            case MeshPrimitiveMode.POINTS: return Material.PointListDrawMode;\r\n            case MeshPrimitiveMode.LINES: return Material.LineListDrawMode;\r\n            case MeshPrimitiveMode.LINE_LOOP: return Material.LineLoopDrawMode;\r\n            case MeshPrimitiveMode.LINE_STRIP: return Material.LineStripDrawMode;\r\n            case MeshPrimitiveMode.TRIANGLES: return Material.TriangleFillMode;\r\n            case MeshPrimitiveMode.TRIANGLE_STRIP: return Material.TriangleStripDrawMode;\r\n            case MeshPrimitiveMode.TRIANGLE_FAN: return Material.TriangleFanDrawMode;\r\n        }\r\n\r\n        throw new Error(`${context}: Invalid mesh primitive mode (${mode})`);\r\n    }\r\n\r\n    private _compileMaterialsAsync(): Promise<void> {\r\n        this._parent._startPerformanceCounter(\"Compile materials\");\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        if (this.gltf.materials) {\r\n            for (const material of this.gltf.materials) {\r\n                if (material._babylonData) {\r\n                    for (const babylonDrawMode in material._babylonData) {\r\n                        const babylonData = material._babylonData[babylonDrawMode];\r\n                        for (const babylonMesh of babylonData.meshes) {\r\n                            // Ensure nonUniformScaling is set if necessary.\r\n                            babylonMesh.computeWorldMatrix(true);\r\n\r\n                            const babylonMaterial = babylonData.material;\r\n                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh));\r\n                            if (this._parent.useClipPlane) {\r\n                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true }));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._parent._endPerformanceCounter(\"Compile materials\");\r\n        });\r\n    }\r\n\r\n    private _compileShadowGeneratorsAsync(): Promise<void> {\r\n        this._parent._startPerformanceCounter(\"Compile shadow generators\");\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const lights = this.babylonScene.lights;\r\n        for (let light of lights) {\r\n            let generator = light.getShadowGenerator();\r\n            if (generator) {\r\n                promises.push(generator.forceCompilationAsync());\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._parent._endPerformanceCounter(\"Compile shadow generators\");\r\n        });\r\n    }\r\n\r\n    private _forEachExtensions(action: (extension: IGLTFLoaderExtensionV2) => void): void {\r\n        for (const name of GLTFLoaderV2._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n            if (extension.enabled) {\r\n                action(extension);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _applyExtensions<T>(property: IProperty, actionAsync: (extension: IGLTFLoaderExtensionV2) => Nullable<T> | undefined): Nullable<T> {\r\n        for (const name of GLTFLoaderV2._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n            if (extension.enabled) {\r\n                const loaderProperty = property as ILoaderProperty;\r\n                loaderProperty._activeLoaderExtensions = loaderProperty._activeLoaderExtensions || {};\r\n                const activeLoaderExtensions = loaderProperty._activeLoaderExtensions;\r\n                if (!activeLoaderExtensions[name]) {\r\n                    activeLoaderExtensions[name] = true;\r\n\r\n                    try {\r\n                        const result = actionAsync(extension);\r\n                        if (result) {\r\n                            return result;\r\n                        }\r\n                    }\r\n                    finally {\r\n                        delete activeLoaderExtensions[name];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _extensionsOnLoading(): void {\r\n        this._forEachExtensions((extension) => extension.onLoading && extension.onLoading());\r\n    }\r\n\r\n    private _extensionsOnReady(): void {\r\n        this._forEachExtensions((extension) => extension.onReady && extension.onReady());\r\n    }\r\n\r\n    private _extensionsLoadSceneAsync(context: string, scene: ISceneV2): Nullable<Promise<void>> {\r\n        return this._applyExtensions(scene, (extension) => extension.loadSceneAsync && extension.loadSceneAsync(context, scene));\r\n    }\r\n\r\n    private _extensionsLoadNodeAsync(context: string, node: INodeV2, assign: (babylonMesh: Mesh) => void): Nullable<Promise<Mesh>> {\r\n        return this._applyExtensions(node, (extension) => extension.loadNodeAsync && extension.loadNodeAsync(context, node, assign));\r\n    }\r\n\r\n    private _extensionsLoadCameraAsync(context: string, camera: ICameraV2, assign: (babylonCamera: Camera) => void): Nullable<Promise<Camera>> {\r\n        return this._applyExtensions(camera, (extension) => extension.loadCameraAsync && extension.loadCameraAsync(context, camera, assign));\r\n    }\r\n\r\n    private _extensionsLoadVertexDataAsync(context: string, primitive: IMeshPrimitiveV2, babylonMesh: Mesh): Nullable<Promise<Geometry>> {\r\n        return this._applyExtensions(primitive, (extension) => extension._loadVertexDataAsync && extension._loadVertexDataAsync(context, primitive, babylonMesh));\r\n    }\r\n\r\n    private _extensionsLoadMaterialAsync(context: string, material: IMaterialV2, babylonMesh: Mesh, babylonDrawMode: number, assign: (babylonMaterial: Material) => void): Nullable<Promise<Material>> {\r\n        return this._applyExtensions(material, (extension) => extension._loadMaterialAsync && extension._loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign));\r\n    }\r\n\r\n    private _extensionsCreateMaterial(context: string, material: IMaterialV2, babylonDrawMode: number): Nullable<Material> {\r\n        return this._applyExtensions({}, (extension) => extension.createMaterial && extension.createMaterial(context, material, babylonDrawMode));\r\n    }\r\n\r\n    private _extensionsLoadMaterialPropertiesAsync(context: string, material: IMaterialV2, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return this._applyExtensions(material, (extension) => extension.loadMaterialPropertiesAsync && extension.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n    }\r\n\r\n    private _extensionsLoadTextureInfoAsync(context: string, textureInfo: ITextureInfoV2, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return this._applyExtensions(textureInfo, (extension) => extension.loadTextureInfoAsync && extension.loadTextureInfoAsync(context, textureInfo, assign));\r\n    }\r\n\r\n    private _extensionsLoadAnimationAsync(context: string, animation: IAnimationV2): Nullable<Promise<AnimationGroup>> {\r\n        return this._applyExtensions(animation, (extension) => extension.loadAnimationAsync && extension.loadAnimationAsync(context, animation));\r\n    }\r\n\r\n    private _extensionsLoadUriAsync(context: string, uri: string): Nullable<Promise<ArrayBufferView>> {\r\n        return this._applyExtensions({}, (extension) => extension._loadUriAsync && extension._loadUriAsync(context, uri));\r\n    }\r\n\r\n    /**\r\n     * Helper method called by a loader extension to load an glTF extension.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property to load the extension from\r\n     * @param extensionName The name of the extension to load\r\n     * @param actionAsync The action to run\r\n     * @returns The promise returned by actionAsync or null if the extension does not exist\r\n     */\r\n    public static LoadExtensionAsync<TExtension = any, TResult = void>(context: string, property: IProperty, extensionName: string, actionAsync: (extensionContext: string, extension: TExtension) => Nullable<Promise<TResult>>): Nullable<Promise<TResult>> {\r\n        if (!property.extensions) {\r\n            return null;\r\n        }\r\n\r\n        const extensions = property.extensions;\r\n\r\n        const extension = extensions[extensionName] as TExtension;\r\n        if (!extension) {\r\n            return null;\r\n        }\r\n\r\n        return actionAsync(`${context}/extensions/${extensionName}`, extension);\r\n    }\r\n\r\n    /**\r\n     * Helper method called by a loader extension to load a glTF extra.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property to load the extra from\r\n     * @param extensionName The name of the extension to load\r\n     * @param actionAsync The action to run\r\n     * @returns The promise returned by actionAsync or null if the extra does not exist\r\n     */\r\n    public static LoadExtraAsync<TExtra = any, TResult = void>(context: string, property: IProperty, extensionName: string, actionAsync: (extraContext: string, extra: TExtra) => Nullable<Promise<TResult>>): Nullable<Promise<TResult>> {\r\n        if (!property.extras) {\r\n            return null;\r\n        }\r\n\r\n        const extras = property.extras;\r\n\r\n        const extra = extras[extensionName] as TExtra;\r\n        if (!extra) {\r\n            return null;\r\n        }\r\n\r\n        return actionAsync(`${context}/extras/${extensionName}`, extra);\r\n    }\r\n\r\n    /**\r\n     * Increments the indentation level and logs a message.\r\n     * @param message The message to log\r\n     */\r\n    public logOpen(message: string): void {\r\n        this._parent._logOpen(message);\r\n    }\r\n\r\n    /**\r\n     * Decrements the indentation level.\r\n     */\r\n    public logClose(): void {\r\n        this._parent._logClose();\r\n    }\r\n\r\n    /**\r\n     * Logs a message\r\n     * @param message The message to log\r\n     */\r\n    public log(message: string): void {\r\n        this._parent._log(message);\r\n    }\r\n\r\n    /**\r\n     * Starts a performance counter.\r\n     * @param counterName The name of the performance counter\r\n     */\r\n    public startPerformanceCounter(counterName: string): void {\r\n        this._parent._startPerformanceCounter(counterName);\r\n    }\r\n\r\n    /**\r\n     * Ends a performance counter.\r\n     * @param counterName The name of the performance counter\r\n     */\r\n    public endPerformanceCounter(counterName: string): void {\r\n        this._parent._endPerformanceCounter(counterName);\r\n    }\r\n}\r\n\r\nGLTFFileLoader._CreateGLTFLoaderV2 = (parent) => new GLTFLoaderV2(parent);\r\n","import { IGLTFRuntime, IGLTFTechniqueParameter, IGLTFAnimation, IGLTFAnimationSampler, IGLTFNode, IGLTFSkins, INodeToRoot, IJointNode, IGLTFMesh, IGLTFAccessor, IGLTFLight, IGLTFAmbienLight, IGLTFDirectionalLight, IGLTFPointLight, IGLTFSpotLight, IGLTFCamera, IGLTFCameraPerspective, IGLTFScene, IGLTFTechnique, IGLTFMaterial, EParameterType, IGLTFProgram, IGLTFBuffer, IGLTFTexture, IGLTFImage, IGLTFSampler, ETextureFilterType, IGLTFShader, IGLTFTechniqueStates, ECullingType, EBlendingFunction, EShaderType } from \"./glTFLoaderInterfaces\";\r\nimport { GLTFUtils } from \"./glTFLoaderUtils\";\r\nimport { Nullable, Node, Tools, Bone, Animation, Quaternion, Vector3, Matrix, Skeleton, Mesh, Material, VertexData, VertexBuffer, FloatArray, StandardMaterial, MultiMaterial, Geometry, SubMesh, HemisphericLight, Color3, DirectionalLight, PointLight, SpotLight, FreeCamera, Camera, AbstractMesh, ShaderMaterial, Effect, Texture, Scene, Engine, SceneLoaderProgressEvent, IParticleSystem, AnimationGroup } from \"babylonjs\";\r\nimport { GLTFFileLoader, IGLTFLoader, GLTFLoaderState, IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport { GLTFLoaderExtension } from \"./glTFLoaderExtension\";\r\n\r\n/**\r\n* Tokenizer. Used for shaders compatibility\r\n* Automatically map world, view, projection, worldViewProjection, attributes and so on\r\n*/\r\nenum ETokenType {\r\n    IDENTIFIER = 1,\r\n\r\n    UNKNOWN = 2,\r\n    END_OF_INPUT = 3\r\n}\r\n\r\nclass Tokenizer {\r\n    private _toParse: string;\r\n    private _pos: number = 0;\r\n    private _maxPos: number;\r\n\r\n    public currentToken: ETokenType = ETokenType.UNKNOWN;\r\n    public currentIdentifier: string = \"\";\r\n    public currentString: string = \"\";\r\n    public isLetterOrDigitPattern: RegExp = /^[a-zA-Z0-9]+$/;\r\n\r\n    constructor(toParse: string) {\r\n        this._toParse = toParse;\r\n        this._maxPos = toParse.length;\r\n    }\r\n\r\n    public getNextToken(): ETokenType {\r\n        if (this.isEnd()) { return ETokenType.END_OF_INPUT; }\r\n\r\n        this.currentString = this.read();\r\n        this.currentToken = ETokenType.UNKNOWN;\r\n\r\n        if (this.currentString === \"_\" || this.isLetterOrDigitPattern.test(this.currentString)) {\r\n            this.currentToken = ETokenType.IDENTIFIER;\r\n            this.currentIdentifier = this.currentString;\r\n            while (!this.isEnd() && (this.isLetterOrDigitPattern.test(this.currentString = this.peek()) || this.currentString === \"_\")) {\r\n                this.currentIdentifier += this.currentString;\r\n                this.forward();\r\n            }\r\n        }\r\n\r\n        return this.currentToken;\r\n    }\r\n\r\n    public peek(): string {\r\n        return this._toParse[this._pos];\r\n    }\r\n\r\n    public read(): string {\r\n        return this._toParse[this._pos++];\r\n    }\r\n\r\n    public forward(): void {\r\n        this._pos++;\r\n    }\r\n\r\n    public isEnd(): boolean {\r\n        return this._pos >= this._maxPos;\r\n    }\r\n}\r\n\r\n/**\r\n* Values\r\n*/\r\nvar glTFTransforms = [\"MODEL\", \"VIEW\", \"PROJECTION\", \"MODELVIEW\", \"MODELVIEWPROJECTION\", \"JOINTMATRIX\"];\r\nvar babylonTransforms = [\"world\", \"view\", \"projection\", \"worldView\", \"worldViewProjection\", \"mBones\"];\r\n\r\nvar glTFAnimationPaths = [\"translation\", \"rotation\", \"scale\"];\r\nvar babylonAnimationPaths = [\"position\", \"rotationQuaternion\", \"scaling\"];\r\n\r\n/**\r\n* Parse\r\n*/\r\nvar parseBuffers = (parsedBuffers: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (var buf in parsedBuffers) {\r\n        var parsedBuffer = parsedBuffers[buf];\r\n        gltfRuntime.buffers[buf] = parsedBuffer;\r\n        gltfRuntime.buffersCount++;\r\n    }\r\n};\r\n\r\nvar parseShaders = (parsedShaders: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (var sha in parsedShaders) {\r\n        var parsedShader = parsedShaders[sha];\r\n        gltfRuntime.shaders[sha] = parsedShader;\r\n        gltfRuntime.shaderscount++;\r\n    }\r\n};\r\n\r\nvar parseObject = (parsedObjects: any, runtimeProperty: string, gltfRuntime: IGLTFRuntime) => {\r\n    for (var object in parsedObjects) {\r\n        var parsedObject = parsedObjects[object];\r\n        (<any>gltfRuntime)[runtimeProperty][object] = parsedObject;\r\n    }\r\n};\r\n\r\n/**\r\n* Utils\r\n*/\r\nvar normalizeUVs = (buffer: any) => {\r\n    if (!buffer) {\r\n        return;\r\n    }\r\n\r\n    for (var i = 0; i < buffer.length / 2; i++) {\r\n        buffer[i * 2 + 1] = 1.0 - buffer[i * 2 + 1];\r\n    }\r\n};\r\n\r\nvar getAttribute = (attributeParameter: IGLTFTechniqueParameter): Nullable<string> => {\r\n    if (attributeParameter.semantic === \"NORMAL\") {\r\n        return \"normal\";\r\n    } else if (attributeParameter.semantic === \"POSITION\") {\r\n        return \"position\";\r\n    } else if (attributeParameter.semantic === \"JOINT\") {\r\n        return \"matricesIndices\";\r\n    } else if (attributeParameter.semantic === \"WEIGHT\") {\r\n        return \"matricesWeights\";\r\n    } else if (attributeParameter.semantic === \"COLOR\") {\r\n        return \"color\";\r\n    } else if (attributeParameter.semantic && attributeParameter.semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n        var channel = Number(attributeParameter.semantic.split(\"_\")[1]);\r\n        return \"uv\" + (channel === 0 ? \"\" : channel + 1);\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n* Loads and creates animations\r\n*/\r\nvar loadAnimations = (gltfRuntime: IGLTFRuntime) => {\r\n    for (var anim in gltfRuntime.animations) {\r\n        var animation: IGLTFAnimation = gltfRuntime.animations[anim];\r\n\r\n        if (!animation.channels || !animation.samplers) {\r\n            continue;\r\n        }\r\n\r\n        var lastAnimation: Nullable<Animation> = null;\r\n\r\n        for (var i = 0; i < animation.channels.length; i++) {\r\n            // Get parameters and load buffers\r\n            var channel = animation.channels[i];\r\n            var sampler: IGLTFAnimationSampler = animation.samplers[channel.sampler];\r\n\r\n            if (!sampler) {\r\n                continue;\r\n            }\r\n\r\n            var inputData: Nullable<string> = null;\r\n            var outputData: Nullable<string> = null;\r\n\r\n            if (animation.parameters) {\r\n                inputData = animation.parameters[sampler.input];\r\n                outputData = animation.parameters[sampler.output];\r\n            }\r\n            else {\r\n                inputData = sampler.input;\r\n                outputData = sampler.output;\r\n            }\r\n\r\n            var bufferInput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);\r\n            var bufferOutput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);\r\n\r\n            var targetID = channel.target.id;\r\n            var targetNode: any = gltfRuntime.scene.getNodeByID(targetID);\r\n\r\n            if (targetNode === null) {\r\n                targetNode = gltfRuntime.scene.getNodeByName(targetID);\r\n            }\r\n\r\n            if (targetNode === null) {\r\n                Tools.Warn(\"Creating animation named \" + anim + \". But cannot find node named \" + targetID + \" to attach to\");\r\n                continue;\r\n            }\r\n\r\n            var isBone = targetNode instanceof Bone;\r\n\r\n            // Get target path (position, rotation or scaling)\r\n            var targetPath = channel.target.path;\r\n            var targetPathIndex = glTFAnimationPaths.indexOf(targetPath);\r\n\r\n            if (targetPathIndex !== -1) {\r\n                targetPath = babylonAnimationPaths[targetPathIndex];\r\n            }\r\n\r\n            // Determine animation type\r\n            var animationType = Animation.ANIMATIONTYPE_MATRIX;\r\n\r\n            if (!isBone) {\r\n                if (targetPath === \"rotationQuaternion\") {\r\n                    animationType = Animation.ANIMATIONTYPE_QUATERNION;\r\n                    targetNode.rotationQuaternion = new Quaternion();\r\n                }\r\n                else {\r\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\r\n                }\r\n            }\r\n\r\n            // Create animation and key frames\r\n            var babylonAnimation: Nullable<Animation> = null;\r\n            var keys = [];\r\n            var arrayOffset = 0;\r\n            var modifyKey = false;\r\n\r\n            if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {\r\n                babylonAnimation = lastAnimation;\r\n                modifyKey = true;\r\n            }\r\n\r\n            if (!modifyKey) {\r\n                babylonAnimation = new Animation(anim, isBone ? \"_matrix\" : targetPath, 1, animationType, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n            }\r\n\r\n            // For each frame\r\n            for (var j = 0; j < bufferInput.length; j++) {\r\n                var value: any = null;\r\n\r\n                if (targetPath === \"rotationQuaternion\") { // VEC4\r\n                    value = Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);\r\n                    arrayOffset += 4;\r\n                }\r\n                else { // Position and scaling are VEC3\r\n                    value = Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);\r\n                    arrayOffset += 3;\r\n                }\r\n\r\n                if (isBone) {\r\n                    var bone = <Bone>targetNode;\r\n                    var translation = Vector3.Zero();\r\n                    var rotationQuaternion = new Quaternion();\r\n                    var scaling = Vector3.Zero();\r\n\r\n                    // Warning on decompose\r\n                    var mat = bone.getBaseMatrix();\r\n\r\n                    if (modifyKey && lastAnimation) {\r\n                        mat = lastAnimation.getKeys()[j].value;\r\n                    }\r\n\r\n                    mat.decompose(scaling, rotationQuaternion, translation);\r\n\r\n                    if (targetPath === \"position\") {\r\n                        translation = value;\r\n                    }\r\n                    else if (targetPath === \"rotationQuaternion\") {\r\n                        rotationQuaternion = value;\r\n                    }\r\n                    else {\r\n                        scaling = value;\r\n                    }\r\n\r\n                    value = Matrix.Compose(scaling, rotationQuaternion, translation);\r\n                }\r\n\r\n                if (!modifyKey) {\r\n                    keys.push({\r\n                        frame: bufferInput[j],\r\n                        value: value\r\n                    });\r\n                }\r\n                else if (lastAnimation) {\r\n                    lastAnimation.getKeys()[j].value = value;\r\n                }\r\n            }\r\n\r\n            // Finish\r\n            if (!modifyKey && babylonAnimation) {\r\n                babylonAnimation.setKeys(keys);\r\n                targetNode.animations.push(babylonAnimation);\r\n            }\r\n\r\n            lastAnimation = babylonAnimation;\r\n\r\n            gltfRuntime.scene.stopAnimation(targetNode);\r\n            gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1.0);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n* Returns the bones transformation matrix\r\n*/\r\nvar configureBoneTransformation = (node: IGLTFNode): Matrix => {\r\n    var mat: Nullable<Matrix> = null;\r\n\r\n    if (node.translation || node.rotation || node.scale) {\r\n        var scale = Vector3.FromArray(node.scale || [1, 1, 1]);\r\n        var rotation = Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);\r\n        var position = Vector3.FromArray(node.translation || [0, 0, 0]);\r\n\r\n        mat = Matrix.Compose(scale, rotation, position);\r\n    }\r\n    else {\r\n        mat = Matrix.FromArray(node.matrix);\r\n    }\r\n\r\n    return mat;\r\n};\r\n\r\n/**\r\n* Returns the parent bone\r\n*/\r\nvar getParentBone = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, jointName: string, newSkeleton: Skeleton): Nullable<Bone> => {\r\n    // Try to find\r\n    for (var i = 0; i < newSkeleton.bones.length; i++) {\r\n        if (newSkeleton.bones[i].name === jointName) {\r\n            return newSkeleton.bones[i];\r\n        }\r\n    }\r\n\r\n    // Not found, search in gltf nodes\r\n    var nodes = gltfRuntime.nodes;\r\n    for (var nde in nodes) {\r\n        var node: IGLTFNode = nodes[nde];\r\n\r\n        if (!node.jointName) {\r\n            continue;\r\n        }\r\n\r\n        var children = node.children;\r\n        for (var i = 0; i < children.length; i++) {\r\n            var child: IGLTFNode = gltfRuntime.nodes[children[i]];\r\n            if (!child.jointName) {\r\n                continue;\r\n            }\r\n\r\n            if (child.jointName === jointName) {\r\n                var mat = configureBoneTransformation(node);\r\n                var bone = new Bone(node.name || \"\", newSkeleton, getParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);\r\n                bone.id = nde;\r\n                return bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n* Returns the appropriate root node\r\n*/\r\nvar getNodeToRoot = (nodesToRoot: INodeToRoot[], id: string): Nullable<Bone> => {\r\n    for (var i = 0; i < nodesToRoot.length; i++) {\r\n        var nodeToRoot = nodesToRoot[i];\r\n\r\n        for (var j = 0; j < nodeToRoot.node.children.length; j++) {\r\n            var child = nodeToRoot.node.children[j];\r\n            if (child === id) {\r\n                return nodeToRoot.bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n* Returns the node with the joint name\r\n*/\r\nvar getJointNode = (gltfRuntime: IGLTFRuntime, jointName: string): Nullable<IJointNode> => {\r\n    var nodes = gltfRuntime.nodes;\r\n    var node: IGLTFNode = nodes[jointName];\r\n    if (node) {\r\n        return {\r\n            node: node,\r\n            id: jointName\r\n        };\r\n    }\r\n\r\n    for (var nde in nodes) {\r\n        node = nodes[nde];\r\n        if (node.jointName === jointName) {\r\n            return {\r\n                node: node,\r\n                id: nde\r\n            };\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n* Checks if a nodes is in joints\r\n*/\r\nvar nodeIsInJoints = (skins: IGLTFSkins, id: string): boolean => {\r\n    for (var i = 0; i < skins.jointNames.length; i++) {\r\n        if (skins.jointNames[i] === id) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\n/**\r\n* Fills the nodes to root for bones and builds hierarchy\r\n*/\r\nvar getNodesToRoot = (gltfRuntime: IGLTFRuntime, newSkeleton: Skeleton, skins: IGLTFSkins, nodesToRoot: INodeToRoot[]) => {\r\n    // Creates nodes for root\r\n    for (var nde in gltfRuntime.nodes) {\r\n        var node: IGLTFNode = gltfRuntime.nodes[nde];\r\n        var id = nde;\r\n\r\n        if (!node.jointName || nodeIsInJoints(skins, node.jointName)) {\r\n            continue;\r\n        }\r\n\r\n        // Create node to root bone\r\n        var mat = configureBoneTransformation(node);\r\n        var bone = new Bone(node.name || \"\", newSkeleton, null, mat);\r\n        bone.id = id;\r\n        nodesToRoot.push({ bone: bone, node: node, id: id });\r\n    }\r\n\r\n    // Parenting\r\n    for (var i = 0; i < nodesToRoot.length; i++) {\r\n        var nodeToRoot = nodesToRoot[i];\r\n        var children = nodeToRoot.node.children;\r\n\r\n        for (var j = 0; j < children.length; j++) {\r\n            var child: Nullable<INodeToRoot> = null;\r\n\r\n            for (var k = 0; k < nodesToRoot.length; k++) {\r\n                if (nodesToRoot[k].id === children[j]) {\r\n                    child = nodesToRoot[k];\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (child) {\r\n                (<any>child.bone)._parent = nodeToRoot.bone;\r\n                nodeToRoot.bone.children.push(child.bone);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n* Imports a skeleton\r\n*/\r\nvar importSkeleton = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, mesh: Mesh, newSkeleton: Skeleton | undefined, id: string): Skeleton => {\r\n\r\n    if (!newSkeleton) {\r\n        newSkeleton = new Skeleton(skins.name || \"\", \"\", gltfRuntime.scene);\r\n    }\r\n\r\n    if (!skins.babylonSkeleton) {\r\n        return newSkeleton;\r\n    }\r\n\r\n    // Find the root bones\r\n    var nodesToRoot: INodeToRoot[] = [];\r\n    var nodesToRootToAdd: Bone[] = [];\r\n\r\n    getNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);\r\n    newSkeleton.bones = [];\r\n\r\n    // Joints\r\n    for (var i = 0; i < skins.jointNames.length; i++) {\r\n        var jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        var node = jointNode.node;\r\n\r\n        if (!node) {\r\n            Tools.Warn(\"Joint named \" + skins.jointNames[i] + \" does not exist\");\r\n            continue;\r\n        }\r\n\r\n        var id = jointNode.id;\r\n\r\n        // Optimize, if the bone already exists...\r\n        var existingBone = gltfRuntime.scene.getBoneByID(id);\r\n        if (existingBone) {\r\n            newSkeleton.bones.push(existingBone);\r\n            continue;\r\n        }\r\n\r\n        // Search for parent bone\r\n        var foundBone = false;\r\n        var parentBone: Nullable<Bone> = null;\r\n\r\n        for (var j = 0; j < i; j++) {\r\n            let jointNode = getJointNode(gltfRuntime, skins.jointNames[j]);\r\n\r\n            if (!jointNode) {\r\n                continue;\r\n            }\r\n\r\n            var joint: IGLTFNode = jointNode.node;\r\n\r\n            if (!joint) {\r\n                Tools.Warn(\"Joint named \" + skins.jointNames[j] + \" does not exist when looking for parent\");\r\n                continue;\r\n            }\r\n\r\n            var children = joint.children;\r\n            if (!children) {\r\n                continue;\r\n            }\r\n            foundBone = false;\r\n\r\n            for (var k = 0; k < children.length; k++) {\r\n                if (children[k] === id) {\r\n                    parentBone = getParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);\r\n                    foundBone = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundBone) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Create bone\r\n        var mat = configureBoneTransformation(node);\r\n\r\n        if (!parentBone && nodesToRoot.length > 0) {\r\n            parentBone = getNodeToRoot(nodesToRoot, id);\r\n\r\n            if (parentBone) {\r\n                if (nodesToRootToAdd.indexOf(parentBone) === -1) {\r\n                    nodesToRootToAdd.push(parentBone);\r\n                }\r\n            }\r\n        }\r\n\r\n        var bone = new Bone(node.jointName || \"\", newSkeleton, parentBone, mat);\r\n        bone.id = id;\r\n    }\r\n\r\n    // Polish\r\n    var bones = newSkeleton.bones;\r\n    newSkeleton.bones = [];\r\n\r\n    for (var i = 0; i < skins.jointNames.length; i++) {\r\n        var jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        for (var j = 0; j < bones.length; j++) {\r\n            if (bones[j].id === jointNode.id) {\r\n                newSkeleton.bones.push(bones[j]);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    newSkeleton.prepare();\r\n\r\n    // Finish\r\n    for (var i = 0; i < nodesToRootToAdd.length; i++) {\r\n        newSkeleton.bones.push(nodesToRootToAdd[i]);\r\n    }\r\n\r\n    return newSkeleton;\r\n};\r\n\r\n/**\r\n* Imports a mesh and its geometries\r\n*/\r\nvar importMesh = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, meshes: string[], id: string, newMesh: Mesh): Mesh => {\r\n    if (!newMesh) {\r\n        newMesh = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n        newMesh.id = id;\r\n    }\r\n\r\n    if (!node.babylonNode) {\r\n        return newMesh;\r\n    }\r\n\r\n    const subMaterials: Material[] = [];\r\n\r\n    var vertexData: Nullable<VertexData> = null;\r\n    var verticesStarts = new Array<number>();\r\n    var verticesCounts = new Array<number>();\r\n    var indexStarts = new Array<number>();\r\n    var indexCounts = new Array<number>();\r\n\r\n    for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        var meshID = meshes[meshIndex];\r\n        var mesh: IGLTFMesh = gltfRuntime.meshes[meshID];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        // Positions, normals and UVs\r\n        for (var i = 0; i < mesh.primitives.length; i++) {\r\n            // Temporary vertex data\r\n            var tempVertexData = new VertexData();\r\n\r\n            var primitive = mesh.primitives[i];\r\n            if (primitive.mode !== 4) {\r\n                // continue;\r\n            }\r\n\r\n            var attributes = primitive.attributes;\r\n            var accessor: Nullable<IGLTFAccessor> = null;\r\n            var buffer: any = null;\r\n\r\n            // Set positions, normal and uvs\r\n            for (var semantic in attributes) {\r\n\r\n                // Link accessor and buffer view\r\n                accessor = gltfRuntime.accessors[attributes[semantic]];\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                if (semantic === \"NORMAL\") {\r\n                    tempVertexData.normals = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.normals).set(buffer);\r\n                }\r\n                else if (semantic === \"POSITION\") {\r\n                    if (GLTFFileLoader.HomogeneousCoordinates) {\r\n                        tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);\r\n\r\n                        for (var j = 0; j < buffer.length; j += 4) {\r\n                            tempVertexData.positions[j] = buffer[j];\r\n                            tempVertexData.positions[j + 1] = buffer[j + 1];\r\n                            tempVertexData.positions[j + 2] = buffer[j + 2];\r\n                        }\r\n                    }\r\n                    else {\r\n                        tempVertexData.positions = new Float32Array(buffer.length);\r\n                        (<Float32Array>tempVertexData.positions).set(buffer);\r\n                    }\r\n\r\n                    verticesCounts.push(tempVertexData.positions.length);\r\n                }\r\n                else if (semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n                    var channel = Number(semantic.split(\"_\")[1]);\r\n                    var uvKind = VertexBuffer.UVKind + (channel === 0 ? \"\" : (channel + 1));\r\n                    var uvs = new Float32Array(buffer.length);\r\n                    (<Float32Array>uvs).set(buffer);\r\n                    normalizeUVs(uvs);\r\n                    tempVertexData.set(uvs, uvKind);\r\n                }\r\n                else if (semantic === \"JOINT\") {\r\n                    tempVertexData.matricesIndices = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesIndices).set(buffer);\r\n                }\r\n                else if (semantic === \"WEIGHT\") {\r\n                    tempVertexData.matricesWeights = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesWeights).set(buffer);\r\n                }\r\n                else if (semantic === \"COLOR\") {\r\n                    tempVertexData.colors = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.colors).set(buffer);\r\n                }\r\n            }\r\n\r\n            // Indices\r\n            accessor = gltfRuntime.accessors[primitive.indices];\r\n            if (accessor) {\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                tempVertexData.indices = new Int32Array(buffer.length);\r\n                (<Float32Array>tempVertexData.indices).set(buffer);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            }\r\n            else {\r\n                // Set indices on the fly\r\n                var indices: number[] = [];\r\n                for (var j = 0; j < (<FloatArray>tempVertexData.positions).length / 3; j++) {\r\n                    indices.push(j);\r\n                }\r\n\r\n                tempVertexData.indices = new Int32Array(indices);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            }\r\n\r\n            if (!vertexData) {\r\n                vertexData = tempVertexData;\r\n            }\r\n            else {\r\n                vertexData.merge(tempVertexData);\r\n            }\r\n\r\n            // Sub material\r\n            let material = gltfRuntime.scene.getMaterialByID(primitive.material);\r\n\r\n            subMaterials.push(material === null ? GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material);\r\n\r\n            // Update vertices start and index start\r\n            verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);\r\n            indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);\r\n        }\r\n    }\r\n    let material: StandardMaterial | MultiMaterial;\r\n    if (subMaterials.length > 1) {\r\n        material = new MultiMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n        (material as MultiMaterial).subMaterials = subMaterials;\r\n    }\r\n    else {\r\n        material = new StandardMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n    }\r\n\r\n    if (subMaterials.length === 1) {\r\n        material = (subMaterials[0] as StandardMaterial);\r\n    }\r\n\r\n    if (!newMesh.material) {\r\n        newMesh.material = material;\r\n    }\r\n\r\n    // Apply geometry\r\n    new Geometry(id, gltfRuntime.scene, vertexData!, false, newMesh);\r\n    newMesh.computeWorldMatrix(true);\r\n\r\n    // Apply submeshes\r\n    newMesh.subMeshes = [];\r\n    var index = 0;\r\n    for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        var meshID = meshes[meshIndex];\r\n        var mesh: IGLTFMesh = gltfRuntime.meshes[meshID];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        for (var i = 0; i < mesh.primitives.length; i++) {\r\n            if (mesh.primitives[i].mode !== 4) {\r\n                //continue;\r\n            }\r\n\r\n            SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // Finish\r\n    return newMesh;\r\n};\r\n\r\n/**\r\n* Configure node transformation from position, rotation and scaling\r\n*/\r\nvar configureNode = (newNode: any, position: Vector3, rotation: Quaternion, scaling: Vector3) => {\r\n    if (newNode.position) {\r\n        newNode.position = position;\r\n    }\r\n\r\n    if (newNode.rotationQuaternion || newNode.rotation) {\r\n        newNode.rotationQuaternion = rotation;\r\n    }\r\n\r\n    if (newNode.scaling) {\r\n        newNode.scaling = scaling;\r\n    }\r\n};\r\n\r\n/**\r\n* Configures node from transformation matrix\r\n*/\r\nvar configureNodeFromMatrix = (newNode: Mesh, node: IGLTFNode, parent: Nullable<Node>) => {\r\n    if (node.matrix) {\r\n        var position = new Vector3(0, 0, 0);\r\n        var rotation = new Quaternion();\r\n        var scaling = new Vector3(0, 0, 0);\r\n        var mat = Matrix.FromArray(node.matrix);\r\n        mat.decompose(scaling, rotation, position);\r\n\r\n        configureNode(newNode, position, rotation, scaling);\r\n    }\r\n    else if (node.translation && node.rotation && node.scale) {\r\n        configureNode(newNode, Vector3.FromArray(node.translation), Quaternion.FromArray(node.rotation), Vector3.FromArray(node.scale));\r\n    }\r\n\r\n    newNode.computeWorldMatrix(true);\r\n};\r\n\r\n/**\r\n* Imports a node\r\n*/\r\nvar importNode = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, id: string, parent: Nullable<Node>): Nullable<Node> => {\r\n    var lastNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {\r\n        if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || \"\") === -1) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Meshes\r\n    if (node.skin) {\r\n        if (node.meshes) {\r\n            var skin: IGLTFSkins = gltfRuntime.skins[node.skin];\r\n\r\n            var newMesh = importMesh(gltfRuntime, node, node.meshes, id, <Mesh>node.babylonNode);\r\n            newMesh.skeleton = gltfRuntime.scene.getLastSkeletonByID(node.skin);\r\n\r\n            if (newMesh.skeleton === null) {\r\n                newMesh.skeleton = importSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton, node.skin);\r\n\r\n                if (!skin.babylonSkeleton) {\r\n                    skin.babylonSkeleton = newMesh.skeleton;\r\n                }\r\n            }\r\n\r\n            lastNode = newMesh;\r\n        }\r\n    }\r\n    else if (node.meshes) {\r\n        /**\r\n        * Improve meshes property\r\n        */\r\n        var newMesh = importMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, <Mesh>node.babylonNode);\r\n        lastNode = newMesh;\r\n    }\r\n    // Lights\r\n    else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        var light: IGLTFLight = gltfRuntime.lights[node.light];\r\n\r\n        if (light) {\r\n            if (light.type === \"ambient\") {\r\n                var ambienLight: IGLTFAmbienLight = (<any>light)[light.type];\r\n                var hemiLight = new HemisphericLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                hemiLight.name = node.name || \"\";\r\n\r\n                if (ambienLight.color) {\r\n                    hemiLight.diffuse = Color3.FromArray(ambienLight.color);\r\n                }\r\n\r\n                lastNode = hemiLight;\r\n            }\r\n            else if (light.type === \"directional\") {\r\n                var directionalLight: IGLTFDirectionalLight = (<any>light)[light.type];\r\n                var dirLight = new DirectionalLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                dirLight.name = node.name || \"\";\r\n\r\n                if (directionalLight.color) {\r\n                    dirLight.diffuse = Color3.FromArray(directionalLight.color);\r\n                }\r\n\r\n                lastNode = dirLight;\r\n            }\r\n            else if (light.type === \"point\") {\r\n                var pointLight: IGLTFPointLight = (<any>light)[light.type];\r\n                var ptLight = new PointLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                ptLight.name = node.name || \"\";\r\n\r\n                if (pointLight.color) {\r\n                    ptLight.diffuse = Color3.FromArray(pointLight.color);\r\n                }\r\n\r\n                lastNode = ptLight;\r\n            }\r\n            else if (light.type === \"spot\") {\r\n                var spotLight: IGLTFSpotLight = (<any>light)[light.type];\r\n                var spLight = new SpotLight(node.light, Vector3.Zero(), Vector3.Zero(), 0, 0, gltfRuntime.scene);\r\n                spLight.name = node.name || \"\";\r\n\r\n                if (spotLight.color) {\r\n                    spLight.diffuse = Color3.FromArray(spotLight.color);\r\n                }\r\n\r\n                if (spotLight.fallOfAngle) {\r\n                    spLight.angle = spotLight.fallOfAngle;\r\n                }\r\n\r\n                if (spotLight.fallOffExponent) {\r\n                    spLight.exponent = spotLight.fallOffExponent;\r\n                }\r\n\r\n                lastNode = spLight;\r\n            }\r\n        }\r\n    }\r\n    // Cameras\r\n    else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        var camera: IGLTFCamera = gltfRuntime.cameras[node.camera];\r\n\r\n        if (camera) {\r\n            if (camera.type === \"orthographic\") {\r\n                var orthoCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                orthoCamera.name = node.name || \"\";\r\n                orthoCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\r\n                orthoCamera.attachControl(<HTMLElement>gltfRuntime.scene.getEngine().getRenderingCanvas());\r\n\r\n                lastNode = orthoCamera;\r\n            }\r\n            else if (camera.type === \"perspective\") {\r\n                var perspectiveCamera: IGLTFCameraPerspective = (<any>camera)[camera.type];\r\n                var persCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                persCamera.name = node.name || \"\";\r\n                persCamera.attachControl(<HTMLElement>gltfRuntime.scene.getEngine().getRenderingCanvas());\r\n\r\n                if (!perspectiveCamera.aspectRatio) {\r\n                    perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();\r\n                }\r\n\r\n                if (perspectiveCamera.znear && perspectiveCamera.zfar) {\r\n                    persCamera.maxZ = perspectiveCamera.zfar;\r\n                    persCamera.minZ = perspectiveCamera.znear;\r\n                }\r\n\r\n                lastNode = persCamera;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Empty node\r\n    if (!node.jointName) {\r\n        if (node.babylonNode) {\r\n            return node.babylonNode;\r\n        }\r\n        else if (lastNode === null) {\r\n            var dummy = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n            node.babylonNode = dummy;\r\n            lastNode = dummy;\r\n        }\r\n    }\r\n\r\n    if (lastNode !== null) {\r\n        if (node.matrix && lastNode instanceof Mesh) {\r\n            configureNodeFromMatrix(lastNode, node, parent);\r\n        }\r\n        else {\r\n            var translation = node.translation || [0, 0, 0];\r\n            var rotation = node.rotation || [0, 0, 0, 1];\r\n            var scale = node.scale || [1, 1, 1];\r\n            configureNode(lastNode, Vector3.FromArray(translation), Quaternion.FromArray(rotation), Vector3.FromArray(scale));\r\n        }\r\n\r\n        lastNode.updateCache(true);\r\n        node.babylonNode = lastNode;\r\n    }\r\n\r\n    return lastNode;\r\n};\r\n\r\n/**\r\n* Traverses nodes and creates them\r\n*/\r\nvar traverseNodes = (gltfRuntime: IGLTFRuntime, id: string, parent: Nullable<Node>, meshIncluded: boolean = false) => {\r\n    var node: IGLTFNode = gltfRuntime.nodes[id];\r\n    var newNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {\r\n        if (gltfRuntime.importMeshesNames.indexOf(node.name || \"\") !== -1 || gltfRuntime.importMeshesNames.length === 0) {\r\n            meshIncluded = true;\r\n        }\r\n        else {\r\n            meshIncluded = false;\r\n        }\r\n    }\r\n    else {\r\n        meshIncluded = true;\r\n    }\r\n\r\n    if (!node.jointName && meshIncluded) {\r\n        newNode = importNode(gltfRuntime, node, id, parent);\r\n\r\n        if (newNode !== null) {\r\n            newNode.id = id;\r\n            newNode.parent = parent;\r\n        }\r\n    }\r\n\r\n    if (node.children) {\r\n        for (var i = 0; i < node.children.length; i++) {\r\n            traverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n* do stuff after buffers, shaders are loaded (e.g. hook up materials, load animations, etc.)\r\n*/\r\nvar postLoad = (gltfRuntime: IGLTFRuntime) => {\r\n    // Nodes\r\n    var currentScene: IGLTFScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n    if (currentScene) {\r\n        for (var i = 0; i < currentScene.nodes.length; i++) {\r\n            traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n        }\r\n    }\r\n    else {\r\n        for (var thing in gltfRuntime.scenes) {\r\n            currentScene = <IGLTFScene>gltfRuntime.scenes[thing];\r\n\r\n            for (var i = 0; i < currentScene.nodes.length; i++) {\r\n                traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Set animations\r\n    loadAnimations(gltfRuntime);\r\n\r\n    for (var i = 0; i < gltfRuntime.scene.skeletons.length; i++) {\r\n        var skeleton = gltfRuntime.scene.skeletons[i];\r\n        gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1.0);\r\n    }\r\n};\r\n\r\n/**\r\n* onBind shaderrs callback to set uniforms and matrices\r\n*/\r\nvar onBindShaderMaterial = (mesh: AbstractMesh, gltfRuntime: IGLTFRuntime, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }, shaderMaterial: ShaderMaterial, technique: IGLTFTechnique, material: IGLTFMaterial, onSuccess: (shaderMaterial: ShaderMaterial) => void) => {\r\n    var materialValues = material.values || technique.parameters;\r\n\r\n    for (var unif in unTreatedUniforms) {\r\n        var uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        var type = uniform.type;\r\n\r\n        if (type === EParameterType.FLOAT_MAT2 || type === EParameterType.FLOAT_MAT3 || type === EParameterType.FLOAT_MAT4) {\r\n            if (uniform.semantic && !uniform.source && !uniform.node) {\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, <Effect>shaderMaterial.getEffect());\r\n            }\r\n            else if (uniform.semantic && (uniform.source || uniform.node)) {\r\n                var source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || \"\");\r\n                if (source === null) {\r\n                    source = gltfRuntime.scene.getNodeByID(uniform.source || uniform.node || \"\");\r\n                }\r\n                if (source === null) {\r\n                    continue;\r\n                }\r\n\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, <Effect>shaderMaterial.getEffect());\r\n            }\r\n        }\r\n        else {\r\n            var value = (<any>materialValues)[technique.uniforms[unif]];\r\n            if (!value) {\r\n                continue;\r\n            }\r\n\r\n            if (type === EParameterType.SAMPLER_2D) {\r\n                var texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;\r\n\r\n                if (texture === null || texture === undefined) {\r\n                    continue;\r\n                }\r\n\r\n                (<Effect>shaderMaterial.getEffect()).setTexture(unif, texture);\r\n            }\r\n            else {\r\n                GLTFUtils.SetUniform(<Effect>(shaderMaterial.getEffect()), unif, value, type);\r\n            }\r\n        }\r\n    }\r\n\r\n    onSuccess(shaderMaterial);\r\n};\r\n\r\n/**\r\n* Prepare uniforms to send the only one time\r\n* Loads the appropriate textures\r\n*/\r\nvar prepareShaderMaterialUniforms = (gltfRuntime: IGLTFRuntime, shaderMaterial: ShaderMaterial, technique: IGLTFTechnique, material: IGLTFMaterial, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }) => {\r\n    var materialValues = material.values || technique.parameters;\r\n    var techniqueUniforms = technique.uniforms;\r\n\r\n    /**\r\n    * Prepare values here (not matrices)\r\n    */\r\n    for (var unif in unTreatedUniforms) {\r\n        var uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        var type = uniform.type;\r\n        var value = (<any>materialValues)[techniqueUniforms[unif]];\r\n\r\n        if (value === undefined) {\r\n            // In case the value is the same for all materials\r\n            value = <any>uniform.value;\r\n        }\r\n\r\n        if (!value) {\r\n            continue;\r\n        }\r\n\r\n        var onLoadTexture = (uniformName: Nullable<string>) => {\r\n            return (texture: Texture) => {\r\n                if (uniform.value && uniformName) {\r\n                    // Static uniform\r\n                    shaderMaterial.setTexture(uniformName, texture);\r\n                    delete unTreatedUniforms[uniformName];\r\n                }\r\n            };\r\n        };\r\n\r\n        // Texture (sampler2D)\r\n        if (type === EParameterType.SAMPLER_2D) {\r\n            GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), () => onLoadTexture(null));\r\n        }\r\n        // Others\r\n        else {\r\n            if (uniform.value && GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {\r\n                // Static uniform\r\n                delete unTreatedUniforms[unif];\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n* Shader compilation failed\r\n*/\r\nvar onShaderCompileError = (program: IGLTFProgram, shaderMaterial: ShaderMaterial, onError: (message: string) => void) => {\r\n    return (effect: Effect, error: string) => {\r\n        shaderMaterial.dispose(true);\r\n        onError(\"Cannot compile program named \" + program.name + \". Error: \" + error + \". Default material will be applied\");\r\n    };\r\n};\r\n\r\n/**\r\n* Shader compilation success\r\n*/\r\nvar onShaderCompileSuccess = (gltfRuntime: IGLTFRuntime, shaderMaterial: ShaderMaterial, technique: IGLTFTechnique, material: IGLTFMaterial, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }, onSuccess: (shaderMaterial: ShaderMaterial) => void) => {\r\n    return (_: Effect) => {\r\n        prepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);\r\n\r\n        shaderMaterial.onBind = (mesh: AbstractMesh) => {\r\n            onBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);\r\n        };\r\n    };\r\n};\r\n\r\n/**\r\n* Returns the appropriate uniform if already handled by babylon\r\n*/\r\nvar parseShaderUniforms = (tokenizer: Tokenizer, technique: IGLTFTechnique, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }): string => {\r\n    for (var unif in technique.uniforms) {\r\n        var uniform = technique.uniforms[unif];\r\n        var uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n        if (tokenizer.currentIdentifier === unif) {\r\n            if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {\r\n                var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n\r\n                if (transformIndex !== -1) {\r\n                    delete unTreatedUniforms[unif];\r\n                    return babylonTransforms[transformIndex];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return tokenizer.currentIdentifier;\r\n};\r\n\r\n/**\r\n* All shaders loaded. Create materials one by one\r\n*/\r\nvar importMaterials = (gltfRuntime: IGLTFRuntime) => {\r\n    // Create materials\r\n    for (var mat in gltfRuntime.materials) {\r\n        GLTFLoaderExtension.LoadMaterialAsync(gltfRuntime, mat, (material: Material) => { }, () => { });\r\n    }\r\n};\r\n\r\n/**\r\n* Implementation of the base glTF spec\r\n*/\r\nexport class GLTFLoaderBase {\r\n    public static CreateRuntime(parsedData: any, scene: Scene, rootUrl: string): IGLTFRuntime {\r\n        var gltfRuntime: IGLTFRuntime = {\r\n            extensions: {},\r\n            accessors: {},\r\n            buffers: {},\r\n            bufferViews: {},\r\n            meshes: {},\r\n            lights: {},\r\n            cameras: {},\r\n            nodes: {},\r\n            images: {},\r\n            textures: {},\r\n            shaders: {},\r\n            programs: {},\r\n            samplers: {},\r\n            techniques: {},\r\n            materials: {},\r\n            animations: {},\r\n            skins: {},\r\n            extensionsUsed: [],\r\n\r\n            scenes: {},\r\n\r\n            buffersCount: 0,\r\n            shaderscount: 0,\r\n\r\n            scene: scene,\r\n            rootUrl: rootUrl,\r\n\r\n            loadedBufferCount: 0,\r\n            loadedBufferViews: {},\r\n\r\n            loadedShaderCount: 0,\r\n\r\n            importOnlyMeshes: false,\r\n\r\n            dummyNodes: []\r\n        };\r\n\r\n        // Parse\r\n        if (parsedData.extensions) {\r\n            parseObject(parsedData.extensions, \"extensions\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.extensionsUsed) {\r\n            parseObject(parsedData.extensionsUsed, \"extensionsUsed\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.buffers) {\r\n            parseBuffers(parsedData.buffers, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.bufferViews) {\r\n            parseObject(parsedData.bufferViews, \"bufferViews\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.accessors) {\r\n            parseObject(parsedData.accessors, \"accessors\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.meshes) {\r\n            parseObject(parsedData.meshes, \"meshes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.lights) {\r\n            parseObject(parsedData.lights, \"lights\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.cameras) {\r\n            parseObject(parsedData.cameras, \"cameras\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.nodes) {\r\n            parseObject(parsedData.nodes, \"nodes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.images) {\r\n            parseObject(parsedData.images, \"images\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.textures) {\r\n            parseObject(parsedData.textures, \"textures\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.shaders) {\r\n            parseShaders(parsedData.shaders, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.programs) {\r\n            parseObject(parsedData.programs, \"programs\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.samplers) {\r\n            parseObject(parsedData.samplers, \"samplers\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.techniques) {\r\n            parseObject(parsedData.techniques, \"techniques\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.materials) {\r\n            parseObject(parsedData.materials, \"materials\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.animations) {\r\n            parseObject(parsedData.animations, \"animations\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.skins) {\r\n            parseObject(parsedData.skins, \"skins\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.scenes) {\r\n            gltfRuntime.scenes = parsedData.scenes;\r\n        }\r\n\r\n        if (parsedData.scene && parsedData.scenes) {\r\n            gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];\r\n        }\r\n\r\n        return gltfRuntime;\r\n    }\r\n\r\n    public static LoadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void, onProgress?: () => void): void {\r\n        var buffer: IGLTFBuffer = gltfRuntime.buffers[id];\r\n\r\n        if (Tools.IsBase64(buffer.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(buffer.uri))));\r\n        }\r\n        else {\r\n            Tools.LoadFile(gltfRuntime.rootUrl + buffer.uri, (data) => onSuccess(new Uint8Array(data as ArrayBuffer)), onProgress, undefined, true, (request) => {\r\n                if (request) {\r\n                    onError(request.status + \" \" + request.statusText);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    public static LoadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: Nullable<ArrayBufferView>) => void, onError: (message: string) => void): void {\r\n        var texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (!texture || !texture.source) {\r\n            onError(\"\");\r\n            return;\r\n        }\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(null);\r\n            return;\r\n        }\r\n\r\n        var source: IGLTFImage = gltfRuntime.images[texture.source];\r\n\r\n        if (Tools.IsBase64(source.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(source.uri))));\r\n        }\r\n        else {\r\n            Tools.LoadFile(gltfRuntime.rootUrl + source.uri, (data) => onSuccess(new Uint8Array(data as ArrayBuffer)), undefined, undefined, true, (request) => {\r\n                if (request) {\r\n                    onError(request.status + \" \" + request.statusText);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    public static CreateTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: Nullable<ArrayBufferView>, onSuccess: (texture: Texture) => void, onError: (message: string) => void): void {\r\n        var texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(texture.babylonTexture);\r\n            return;\r\n        }\r\n\r\n        var sampler: IGLTFSampler = gltfRuntime.samplers[texture.sampler];\r\n\r\n        var createMipMaps =\r\n            (sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_NEAREST) ||\r\n            (sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_LINEAR) ||\r\n            (sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_NEAREST) ||\r\n            (sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_LINEAR);\r\n\r\n        var samplingMode = Texture.BILINEAR_SAMPLINGMODE;\r\n\r\n        var blob = buffer == null ? new Blob() : new Blob([buffer]);\r\n        var blobURL = URL.createObjectURL(blob);\r\n        var revokeBlobURL = () => URL.revokeObjectURL(blobURL);\r\n        var newTexture = new Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);\r\n        if (sampler.wrapS !== undefined) {\r\n            newTexture.wrapU = GLTFUtils.GetWrapMode(sampler.wrapS);\r\n        }\r\n        if (sampler.wrapT !== undefined) {\r\n            newTexture.wrapV = GLTFUtils.GetWrapMode(sampler.wrapT);\r\n        }\r\n        newTexture.name = id;\r\n\r\n        texture.babylonTexture = newTexture;\r\n        onSuccess(newTexture);\r\n    }\r\n\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string | ArrayBuffer) => void, onError?: (message: string) => void): void {\r\n        var shader: IGLTFShader = gltfRuntime.shaders[id];\r\n\r\n        if (Tools.IsBase64(shader.uri)) {\r\n            var shaderString = atob(shader.uri.split(\",\")[1]);\r\n            if (onSuccess) {\r\n                onSuccess(shaderString);\r\n            }\r\n        }\r\n        else {\r\n            Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, undefined, undefined, false, (request) => {\r\n                if (request && onError) {\r\n                    onError(request.status + \" \" + request.statusText);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        var material: IGLTFMaterial = gltfRuntime.materials[id];\r\n        if (!material.technique) {\r\n            if (onError) {\r\n                onError(\"No technique found.\");\r\n            }\r\n            return;\r\n        }\r\n\r\n        var technique: IGLTFTechnique = gltfRuntime.techniques[material.technique];\r\n        if (!technique) {\r\n            var defaultMaterial = new StandardMaterial(id, gltfRuntime.scene);\r\n            defaultMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5);\r\n            defaultMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n            onSuccess(defaultMaterial);\r\n            return;\r\n        }\r\n\r\n        var program: IGLTFProgram = gltfRuntime.programs[technique.program];\r\n        var states: IGLTFTechniqueStates = technique.states;\r\n\r\n        var vertexShader: string = Effect.ShadersStore[program.vertexShader + \"VertexShader\"];\r\n        var pixelShader: string = Effect.ShadersStore[program.fragmentShader + \"PixelShader\"];\r\n        var newVertexShader = \"\";\r\n        var newPixelShader = \"\";\r\n\r\n        var vertexTokenizer = new Tokenizer(vertexShader);\r\n        var pixelTokenizer = new Tokenizer(pixelShader);\r\n\r\n        var unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter } = {};\r\n        var uniforms: string[] = [];\r\n        var attributes: string[] = [];\r\n        var samplers: string[] = [];\r\n\r\n        // Fill uniform, sampler2D and attributes\r\n        for (var unif in technique.uniforms) {\r\n            var uniform = technique.uniforms[unif];\r\n            var uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n            unTreatedUniforms[unif] = uniformParameter;\r\n\r\n            if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {\r\n                var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n                if (transformIndex !== -1) {\r\n                    uniforms.push(babylonTransforms[transformIndex]);\r\n                    delete unTreatedUniforms[unif];\r\n                }\r\n                else {\r\n                    uniforms.push(unif);\r\n                }\r\n            }\r\n            else if (uniformParameter.type === EParameterType.SAMPLER_2D) {\r\n                samplers.push(unif);\r\n            }\r\n            else {\r\n                uniforms.push(unif);\r\n            }\r\n        }\r\n\r\n        for (var attr in technique.attributes) {\r\n            var attribute = technique.attributes[attr];\r\n            var attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n            if (attributeParameter.semantic) {\r\n                let name = getAttribute(attributeParameter);\r\n                if (name) {\r\n                    attributes.push(name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Configure vertex shader\r\n        while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {\r\n            var tokenType = vertexTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newVertexShader += vertexTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            var foundAttribute = false;\r\n\r\n            for (var attr in technique.attributes) {\r\n                var attribute = technique.attributes[attr];\r\n                var attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n                if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {\r\n                    newVertexShader += getAttribute(attributeParameter);\r\n                    foundAttribute = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundAttribute) {\r\n                continue;\r\n            }\r\n\r\n            newVertexShader += parseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Configure pixel shader\r\n        while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {\r\n            var tokenType = pixelTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newPixelShader += pixelTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            newPixelShader += parseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Create shader material\r\n        var shaderPath = {\r\n            vertex: program.vertexShader + id,\r\n            fragment: program.fragmentShader + id\r\n        };\r\n\r\n        var options = {\r\n            attributes: attributes,\r\n            uniforms: uniforms,\r\n            samplers: samplers,\r\n            needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1\r\n        };\r\n\r\n        Effect.ShadersStore[program.vertexShader + id + \"VertexShader\"] = newVertexShader;\r\n        Effect.ShadersStore[program.fragmentShader + id + \"PixelShader\"] = newPixelShader;\r\n\r\n        var shaderMaterial = new ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);\r\n        shaderMaterial.onError = onShaderCompileError(program, shaderMaterial, onError);\r\n        shaderMaterial.onCompiled = onShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);\r\n        shaderMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n\r\n        if (states && states.functions) {\r\n            var functions = states.functions;\r\n            if (functions.cullFace && functions.cullFace[0] !== ECullingType.BACK) {\r\n                shaderMaterial.backFaceCulling = false;\r\n            }\r\n\r\n            var blendFunc = functions.blendFuncSeparate;\r\n            if (blendFunc) {\r\n                if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_ALPHA && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Engine.ALPHA_COMBINE;\r\n                }\r\n                else if (blendFunc[0] === EBlendingFunction.ONE && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Engine.ALPHA_ONEONE;\r\n                }\r\n                else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Engine.ALPHA_ADD;\r\n                }\r\n                else if (blendFunc[0] === EBlendingFunction.ZERO && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Engine.ALPHA_SUBTRACT;\r\n                }\r\n                else if (blendFunc[0] === EBlendingFunction.DST_COLOR && blendFunc[1] === EBlendingFunction.ZERO && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Engine.ALPHA_MULTIPLY;\r\n                }\r\n                else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Engine.ALPHA_MAXIMIZED;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n* glTF V1 Loader\r\n*/\r\nexport class GLTFLoaderV1 implements IGLTFLoader {\r\n    public static Extensions: { [name: string]: GLTFLoaderExtension } = {};\r\n\r\n    public static RegisterExtension(extension: GLTFLoaderExtension): void {\r\n        if (GLTFLoaderV1.Extensions[extension.name]) {\r\n            Tools.Error(\"Tool with the same name \\\"\" + extension.name + \"\\\" already exists\");\r\n            return;\r\n        }\r\n\r\n        GLTFLoaderV1.Extensions[extension.name] = extension;\r\n    }\r\n\r\n    public state: Nullable<GLTFLoaderState> = null;\r\n\r\n    public dispose(): void {\r\n        // do nothing\r\n    }\r\n\r\n    private _importMeshAsync(meshesNames: any, scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess: (meshes: AbstractMesh[], skeletons: Skeleton[]) => void, onProgress?: (event: SceneLoaderProgressEvent) => void, onError?: (message: string) => void): boolean {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, (gltfRuntime) => {\r\n            gltfRuntime.importOnlyMeshes = true;\r\n\r\n            if (meshesNames === \"\") {\r\n                gltfRuntime.importMeshesNames = [];\r\n            }\r\n            else if (typeof meshesNames === \"string\") {\r\n                gltfRuntime.importMeshesNames = [meshesNames];\r\n            }\r\n            else if (meshesNames && !(meshesNames instanceof Array)) {\r\n                gltfRuntime.importMeshesNames = [meshesNames];\r\n            }\r\n            else {\r\n                gltfRuntime.importMeshesNames = [];\r\n                Tools.Warn(\"Argument meshesNames must be of type string or string[]\");\r\n            }\r\n\r\n            // Create nodes\r\n            this._createNodes(gltfRuntime);\r\n\r\n            var meshes = new Array<AbstractMesh>();\r\n            var skeletons = new Array<Skeleton>();\r\n\r\n            // Fill arrays of meshes and skeletons\r\n            for (var nde in gltfRuntime.nodes) {\r\n                var node: IGLTFNode = gltfRuntime.nodes[nde];\r\n\r\n                if (node.babylonNode instanceof AbstractMesh) {\r\n                    meshes.push(<AbstractMesh>node.babylonNode);\r\n                }\r\n            }\r\n\r\n            for (var skl in gltfRuntime.skins) {\r\n                var skin: IGLTFSkins = gltfRuntime.skins[skl];\r\n\r\n                if (skin.babylonSkeleton instanceof Skeleton) {\r\n                    skeletons.push(skin.babylonSkeleton);\r\n                }\r\n            }\r\n\r\n            // Load buffers, shaders, materials, etc.\r\n            this._loadBuffersAsync(gltfRuntime, () => {\r\n                this._loadShadersAsync(gltfRuntime, () => {\r\n                    importMaterials(gltfRuntime);\r\n                    postLoad(gltfRuntime);\r\n\r\n                    if (!GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                        onSuccess(meshes, skeletons);\r\n                    }\r\n                });\r\n            }, onProgress);\r\n\r\n            if (GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                onSuccess(meshes, skeletons);\r\n            }\r\n        }, onError);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Imports one or more meshes from a loaded gltf file and adds them to the scene\r\n    * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n    * @param scene the scene the meshes should be added to\r\n    * @param data gltf data containing information of the meshes in a loaded file\r\n    * @param rootUrl root url to load from\r\n    * @param onProgress event that fires when loading progress has occured\r\n    * @returns a promise containg the loaded meshes, particles, skeletons and animations\r\n    */\r\n    public importMeshAsync(meshesNames: any, scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void): Promise<{ meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], animationGroups: AnimationGroup[] }> {\r\n        return new Promise((resolve, reject) => {\r\n            this._importMeshAsync(meshesNames, scene, data, rootUrl, (meshes, skeletons) => {\r\n                resolve({\r\n                    meshes: meshes,\r\n                    particleSystems: [],\r\n                    skeletons: skeletons,\r\n                    animationGroups: []\r\n                });\r\n            }, onProgress, (message) => {\r\n                reject(new Error(message));\r\n            });\r\n        });\r\n    }\r\n\r\n    private _loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess: () => void, onProgress?: (event: SceneLoaderProgressEvent) => void, onError?: (message: string) => void): void {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, (gltfRuntime) => {\r\n            // Load runtime extensios\r\n            GLTFLoaderExtension.LoadRuntimeExtensionsAsync(gltfRuntime, () => {\r\n                // Create nodes\r\n                this._createNodes(gltfRuntime);\r\n\r\n                // Load buffers, shaders, materials, etc.\r\n                this._loadBuffersAsync(gltfRuntime, () => {\r\n                    this._loadShadersAsync(gltfRuntime, () => {\r\n                        importMaterials(gltfRuntime);\r\n                        postLoad(gltfRuntime);\r\n\r\n                        if (!GLTFFileLoader.IncrementalLoading) {\r\n                            onSuccess();\r\n                        }\r\n                    });\r\n                });\r\n\r\n                if (GLTFFileLoader.IncrementalLoading) {\r\n                    onSuccess();\r\n                }\r\n            }, onError);\r\n        }, onError);\r\n    }\r\n\r\n    /**\r\n    * Imports all objects from a loaded gltf file and adds them to the scene\r\n    * @param scene the scene the objects should be added to\r\n    * @param data gltf data containing information of the meshes in a loaded file\r\n    * @param rootUrl root url to load from\r\n    * @param onProgress event that fires when loading progress has occured\r\n    * @returns a promise which completes when objects have been loaded to the scene\r\n    */\r\n    public loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this._loadAsync(scene, data, rootUrl, () => {\r\n                resolve();\r\n            }, onProgress, (message) => {\r\n                reject(new Error(message));\r\n            });\r\n        });\r\n    }\r\n\r\n    private _loadShadersAsync(gltfRuntime: IGLTFRuntime, onload: () => void): void {\r\n        var hasShaders = false;\r\n\r\n        var processShader = (sha: string, shader: IGLTFShader) => {\r\n            GLTFLoaderExtension.LoadShaderStringAsync(gltfRuntime, sha, (shaderString) => {\r\n                if (shaderString instanceof ArrayBuffer) {\r\n                    return;\r\n                }\r\n\r\n                gltfRuntime.loadedShaderCount++;\r\n\r\n                if (shaderString) {\r\n                    Effect.ShadersStore[sha + (shader.type === EShaderType.VERTEX ? \"VertexShader\" : \"PixelShader\")] = shaderString;\r\n                }\r\n\r\n                if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {\r\n                    onload();\r\n                }\r\n            }, () => {\r\n                Tools.Error(\"Error when loading shader program named \" + sha + \" located at \" + shader.uri);\r\n            });\r\n        };\r\n\r\n        for (var sha in gltfRuntime.shaders) {\r\n            hasShaders = true;\r\n\r\n            var shader: IGLTFShader = gltfRuntime.shaders[sha];\r\n            if (shader) {\r\n                processShader.bind(this, sha, shader)();\r\n            }\r\n            else {\r\n                Tools.Error(\"No shader named: \" + sha);\r\n            }\r\n        }\r\n\r\n        if (!hasShaders) {\r\n            onload();\r\n        }\r\n    }\r\n\r\n    private _loadBuffersAsync(gltfRuntime: IGLTFRuntime, onLoad: () => void, onProgress?: (event: SceneLoaderProgressEvent) => void): void {\r\n        var hasBuffers = false;\r\n\r\n        var processBuffer = (buf: string, buffer: IGLTFBuffer) => {\r\n            GLTFLoaderExtension.LoadBufferAsync(gltfRuntime, buf, (bufferView) => {\r\n                gltfRuntime.loadedBufferCount++;\r\n\r\n                if (bufferView) {\r\n                    if (bufferView.byteLength != gltfRuntime.buffers[buf].byteLength) {\r\n                        Tools.Error(\"Buffer named \" + buf + \" is length \" + bufferView.byteLength + \". Expected: \" + buffer.byteLength); // Improve error message\r\n                    }\r\n\r\n                    gltfRuntime.loadedBufferViews[buf] = bufferView;\r\n                }\r\n\r\n                if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {\r\n                    onLoad();\r\n                }\r\n            }, () => {\r\n                Tools.Error(\"Error when loading buffer named \" + buf + \" located at \" + buffer.uri);\r\n            });\r\n        };\r\n\r\n        for (var buf in gltfRuntime.buffers) {\r\n            hasBuffers = true;\r\n\r\n            var buffer: IGLTFBuffer = gltfRuntime.buffers[buf];\r\n            if (buffer) {\r\n                processBuffer.bind(this, buf, buffer)();\r\n            }\r\n            else {\r\n                Tools.Error(\"No buffer named: \" + buf);\r\n            }\r\n        }\r\n\r\n        if (!hasBuffers) {\r\n            onLoad();\r\n        }\r\n    }\r\n\r\n    private _createNodes(gltfRuntime: IGLTFRuntime): void {\r\n        var currentScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n        if (currentScene) {\r\n            // Only one scene even if multiple scenes are defined\r\n            for (var i = 0; i < currentScene.nodes.length; i++) {\r\n                traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        }\r\n        else {\r\n            // Load all scenes\r\n            for (var thing in gltfRuntime.scenes) {\r\n                currentScene = <IGLTFScene>gltfRuntime.scenes[thing];\r\n\r\n                for (var i = 0; i < currentScene.nodes.length; i++) {\r\n                    traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nGLTFFileLoader._CreateGLTFLoaderV1 = () => new GLTFLoaderV1();\r\n","import { IDisposable, Nullable, Scene, ISceneLoaderPluginAsync, ISceneLoaderPluginFactory, Observable, Observer, SceneLoaderProgressEvent, AbstractMesh, IParticleSystem, Skeleton, AnimationGroup, BaseTexture, Material, Camera, ISceneLoaderPluginExtensions, ISceneLoaderPlugin, AssetContainer, Tools, SceneLoader } from \"babylonjs\";\r\nimport { IGLTFValidationResults, IGLTFValidationOptions } from \"babylonjs-gltf2interface\";\r\n\r\n/**\r\n * glTF validator object\r\n */\r\ndeclare var GLTFValidator: {\r\n    validateString: (json: string, options?: IGLTFValidationOptions) => Promise<IGLTFValidationResults>;\r\n};\r\n\r\n/**\r\n * Mode that determines the coordinate system to use.\r\n */\r\nexport enum GLTFLoaderCoordinateSystemMode {\r\n    /**\r\n     * Automatically convert the glTF right-handed data to the appropriate system based on the current coordinate system mode of the scene.\r\n     */\r\n    AUTO,\r\n\r\n    /**\r\n     * Sets the useRightHandedSystem flag on the scene.\r\n     */\r\n    FORCE_RIGHT_HANDED,\r\n}\r\n\r\n/**\r\n * Mode that determines what animations will start.\r\n */\r\nexport enum GLTFLoaderAnimationStartMode {\r\n    /**\r\n     * No animation will start.\r\n     */\r\n    NONE,\r\n\r\n    /**\r\n     * The first animation will start.\r\n     */\r\n    FIRST,\r\n\r\n    /**\r\n     * All animations will start.\r\n     */\r\n    ALL,\r\n}\r\n\r\n/**\r\n * Interface that contains the data for the glTF asset.\r\n */\r\nexport interface IGLTFLoaderData {\r\n    /**\r\n     * Object that represents the glTF JSON.\r\n     */\r\n    json: Object;\r\n\r\n    /**\r\n     * The BIN chunk of a binary glTF.\r\n     */\r\n    bin: Nullable<ArrayBufferView>;\r\n}\r\n\r\n/**\r\n * Interface for extending the loader.\r\n */\r\nexport interface IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    readonly name: string;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    enabled: boolean;\r\n}\r\n\r\n/**\r\n * Loader state.\r\n */\r\nexport enum GLTFLoaderState {\r\n    /**\r\n     * The asset is loading.\r\n     */\r\n    LOADING,\r\n\r\n    /**\r\n     * The asset is ready for rendering.\r\n     */\r\n    READY,\r\n\r\n    /**\r\n     * The asset is completely loaded.\r\n     */\r\n    COMPLETE\r\n}\r\n\r\n/** @hidden */\r\nexport interface IGLTFLoader extends IDisposable {\r\n    readonly state: Nullable<GLTFLoaderState>;\r\n    importMeshAsync: (meshesNames: any, scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string) => Promise<{ meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], animationGroups: AnimationGroup[] }>;\r\n    loadAsync: (scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string) => Promise<void>;\r\n}\r\n\r\n/**\r\n * File loader for loading glTF files into a scene.\r\n */\r\nexport class GLTFFileLoader implements IDisposable, ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\r\n    /** @hidden */\r\n    public static _CreateGLTFLoaderV1: (parent: GLTFFileLoader) => IGLTFLoader;\r\n\r\n    /** @hidden */\r\n    public static _CreateGLTFLoaderV2: (parent: GLTFFileLoader) => IGLTFLoader;\r\n\r\n    // --------------\r\n    // Common options\r\n    // --------------\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public onParsedObservable = new Observable<IGLTFLoaderData>();\r\n\r\n    private _onParsedObserver: Nullable<Observer<IGLTFLoaderData>>;\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public set onParsed(callback: (loaderData: IGLTFLoaderData) => void) {\r\n        if (this._onParsedObserver) {\r\n            this.onParsedObservable.remove(this._onParsedObserver);\r\n        }\r\n        this._onParsedObserver = this.onParsedObservable.add(callback);\r\n    }\r\n\r\n    // ----------\r\n    // V1 options\r\n    // ----------\r\n\r\n    /**\r\n     * Set this property to false to disable incremental loading which delays the loader from calling the success callback until after loading the meshes and shaders.\r\n     * Textures always loads asynchronously. For example, the success callback can compute the bounding information of the loaded meshes when incremental loading is disabled.\r\n     * Defaults to true.\r\n     * @hidden\r\n     */\r\n    public static IncrementalLoading = true;\r\n\r\n    /**\r\n     * Set this property to true in order to work with homogeneous coordinates, available with some converters and exporters.\r\n     * Defaults to false. See https://en.wikipedia.org/wiki/Homogeneous_coordinates.\r\n     * @hidden\r\n     */\r\n    public static HomogeneousCoordinates = false;\r\n\r\n    // ----------\r\n    // V2 options\r\n    // ----------\r\n\r\n    /**\r\n     * The coordinate system mode. Defaults to AUTO.\r\n     */\r\n    public coordinateSystemMode = GLTFLoaderCoordinateSystemMode.AUTO;\r\n\r\n    /**\r\n    * The animation start mode. Defaults to FIRST.\r\n    */\r\n    public animationStartMode = GLTFLoaderAnimationStartMode.FIRST;\r\n\r\n    /**\r\n     * Defines if the loader should compile materials before raising the success callback. Defaults to false.\r\n     */\r\n    public compileMaterials = false;\r\n\r\n    /**\r\n     * Defines if the loader should also compile materials with clip planes. Defaults to false.\r\n     */\r\n    public useClipPlane = false;\r\n\r\n    /**\r\n     * Defines if the loader should compile shadow generators before raising the success callback. Defaults to false.\r\n     */\r\n    public compileShadowGenerators = false;\r\n\r\n    /**\r\n     * Defines if the Alpha blended materials are only applied as coverage.\r\n     * If false, (default) The luminance of each pixel will reduce its opacity to simulate the behaviour of most physical materials.\r\n     * If true, no extra effects are applied to transparent pixels.\r\n     */\r\n    public transparencyAsCoverage = false;\r\n\r\n    /**\r\n     * Function called before loading a url referenced by the asset.\r\n     */\r\n    public preprocessUrlAsync = (url: string) => Promise.resolve(url);\r\n\r\n    /**\r\n     * Observable raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     */\r\n    public readonly onMeshLoadedObservable = new Observable<AbstractMesh>();\r\n\r\n    private _onMeshLoadedObserver: Nullable<Observer<AbstractMesh>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     */\r\n    public set onMeshLoaded(callback: (mesh: AbstractMesh) => void) {\r\n        if (this._onMeshLoadedObserver) {\r\n            this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver);\r\n        }\r\n        this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public readonly onTextureLoadedObservable = new Observable<BaseTexture>();\r\n\r\n    private _onTextureLoadedObserver: Nullable<Observer<BaseTexture>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public set onTextureLoaded(callback: (texture: BaseTexture) => void) {\r\n        if (this._onTextureLoadedObserver) {\r\n            this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver);\r\n        }\r\n        this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public readonly onMaterialLoadedObservable = new Observable<Material>();\r\n\r\n    private _onMaterialLoadedObserver: Nullable<Observer<Material>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public set onMaterialLoaded(callback: (material: Material) => void) {\r\n        if (this._onMaterialLoadedObserver) {\r\n            this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver);\r\n        }\r\n        this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public readonly onCameraLoadedObservable = new Observable<Camera>();\r\n\r\n    private _onCameraLoadedObserver: Nullable<Observer<Camera>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public set onCameraLoaded(callback: (camera: Camera) => void) {\r\n        if (this._onCameraLoadedObserver) {\r\n            this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver);\r\n        }\r\n        this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the asset is completely loaded, immediately before the loader is disposed.\r\n     * For assets with LODs, raised when all of the LODs are complete.\r\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\r\n     */\r\n    public readonly onCompleteObservable = new Observable<void>();\r\n\r\n    private _onCompleteObserver: Nullable<Observer<void>>;\r\n\r\n    /**\r\n     * Callback raised when the asset is completely loaded, immediately before the loader is disposed.\r\n     * For assets with LODs, raised when all of the LODs are complete.\r\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\r\n     */\r\n    public set onComplete(callback: () => void) {\r\n        if (this._onCompleteObserver) {\r\n            this.onCompleteObservable.remove(this._onCompleteObserver);\r\n        }\r\n        this._onCompleteObserver = this.onCompleteObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when an error occurs.\r\n     */\r\n    public readonly onErrorObservable = new Observable<any>();\r\n\r\n    private _onErrorObserver: Nullable<Observer<any>>;\r\n\r\n    /**\r\n     * Callback raised when an error occurs.\r\n     */\r\n    public set onError(callback: (reason: any) => void) {\r\n        if (this._onErrorObserver) {\r\n            this.onErrorObservable.remove(this._onErrorObserver);\r\n        }\r\n        this._onErrorObserver = this.onErrorObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised after the loader is disposed.\r\n     */\r\n    public readonly onDisposeObservable = new Observable<void>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<void>>;\r\n\r\n    /**\r\n     * Callback raised after the loader is disposed.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised after a loader extension is created.\r\n     * Set additional options for a loader extension in this event.\r\n     */\r\n    public readonly onExtensionLoadedObservable = new Observable<IGLTFLoaderExtension>();\r\n\r\n    private _onExtensionLoadedObserver: Nullable<Observer<IGLTFLoaderExtension>>;\r\n\r\n    /**\r\n     * Callback raised after a loader extension is created.\r\n     */\r\n    public set onExtensionLoaded(callback: (extension: IGLTFLoaderExtension) => void) {\r\n        if (this._onExtensionLoadedObserver) {\r\n            this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver);\r\n        }\r\n        this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader logging is enabled.\r\n     */\r\n    public get loggingEnabled(): boolean {\r\n        return this._loggingEnabled;\r\n    }\r\n\r\n    public set loggingEnabled(value: boolean) {\r\n        if (this._loggingEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._loggingEnabled = value;\r\n\r\n        if (this._loggingEnabled) {\r\n            this._log = this._logEnabled;\r\n        }\r\n        else {\r\n            this._log = this._logDisabled;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader should capture performance counters.\r\n     */\r\n    public get capturePerformanceCounters(): boolean {\r\n        return this._capturePerformanceCounters;\r\n    }\r\n\r\n    public set capturePerformanceCounters(value: boolean) {\r\n        if (this._capturePerformanceCounters === value) {\r\n            return;\r\n        }\r\n\r\n        this._capturePerformanceCounters = value;\r\n\r\n        if (this._capturePerformanceCounters) {\r\n            this._startPerformanceCounter = this._startPerformanceCounterEnabled;\r\n            this._endPerformanceCounter = this._endPerformanceCounterEnabled;\r\n        }\r\n        else {\r\n            this._startPerformanceCounter = this._startPerformanceCounterDisabled;\r\n            this._endPerformanceCounter = this._endPerformanceCounterDisabled;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader should validate the asset.\r\n     */\r\n    public validate = false;\r\n\r\n    /**\r\n     * Observable raised after validation when validate is set to true. The event data is the result of the validation.\r\n     */\r\n    public readonly onValidatedObservable = new Observable<IGLTFValidationResults>();\r\n\r\n    private _onValidatedObserver: Nullable<Observer<IGLTFValidationResults>>;\r\n\r\n    /**\r\n     * Callback raised after a loader extension is created.\r\n     */\r\n    public set onValidated(callback: (results: IGLTFValidationResults) => void) {\r\n        if (this._onValidatedObserver) {\r\n            this.onValidatedObservable.remove(this._onValidatedObserver);\r\n        }\r\n        this._onValidatedObserver = this.onValidatedObservable.add(callback);\r\n    }\r\n\r\n    private _loader: Nullable<IGLTFLoader> = null;\r\n\r\n    /**\r\n     * Name of the loader (\"gltf\")\r\n     */\r\n    public name = \"gltf\";\r\n\r\n    /**\r\n     * Supported file extensions of the loader (.gltf, .glb)\r\n     */\r\n    public extensions: ISceneLoaderPluginExtensions = {\r\n        \".gltf\": { isBinary: false },\r\n        \".glb\": { isBinary: true }\r\n    };\r\n\r\n    /**\r\n     * Disposes the loader, releases resources during load, and cancels any outstanding requests.\r\n     */\r\n    public dispose(): void {\r\n        if (this._loader) {\r\n            this._loader.dispose();\r\n            this._loader = null;\r\n        }\r\n\r\n        this._clear();\r\n\r\n        this.onDisposeObservable.notifyObservers(undefined);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _clear(): void {\r\n        this.preprocessUrlAsync = (url) => Promise.resolve(url);\r\n\r\n        this.onMeshLoadedObservable.clear();\r\n        this.onTextureLoadedObservable.clear();\r\n        this.onMaterialLoadedObservable.clear();\r\n        this.onCameraLoadedObservable.clear();\r\n        this.onCompleteObservable.clear();\r\n        this.onExtensionLoadedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Imports one or more meshes from the loaded glTF data and adds them to the scene\r\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene the scene the meshes should be added to\r\n     * @param data the glTF data to load\r\n     * @param rootUrl root url to load from\r\n     * @param onProgress event that fires when loading progress has occured\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns a promise containg the loaded meshes, particles, skeletons and animations\r\n     */\r\n    public importMeshAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<{ meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], animationGroups: AnimationGroup[] }> {\r\n        return this._parseAsync(scene, data, rootUrl, fileName).then((loaderData) => {\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(loaderData);\r\n            return this._loader.importMeshAsync(meshesNames, scene, loaderData, rootUrl, onProgress, fileName);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Imports all objects from the loaded glTF data and adds them to the scene\r\n     * @param scene the scene the objects should be added to\r\n     * @param data the glTF data to load\r\n     * @param rootUrl root url to load from\r\n     * @param onProgress event that fires when loading progress has occured\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns a promise which completes when objects have been loaded to the scene\r\n     */\r\n    public loadAsync(scene: Scene, data: string | ArrayBuffer, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<void> {\r\n        return this._parseAsync(scene, data, rootUrl, fileName).then((loaderData) => {\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(loaderData);\r\n            return this._loader.loadAsync(scene, loaderData, rootUrl, onProgress, fileName);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns The loaded asset container\r\n     */\r\n    public loadAssetContainerAsync(scene: Scene, data: string | ArrayBuffer, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<AssetContainer> {\r\n        return this._parseAsync(scene, data, rootUrl, fileName).then((loaderData) => {\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(loaderData);\r\n            return this._loader.importMeshAsync(null, scene, loaderData, rootUrl, onProgress, fileName).then((result) => {\r\n                const container = new AssetContainer(scene);\r\n                Array.prototype.push.apply(container.meshes, result.meshes);\r\n                Array.prototype.push.apply(container.particleSystems, result.particleSystems);\r\n                Array.prototype.push.apply(container.skeletons, result.skeletons);\r\n                Array.prototype.push.apply(container.animationGroups, result.animationGroups);\r\n                container.removeAllFromScene();\r\n                return container;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * If the data string can be loaded directly.\r\n     * @param data string contianing the file data\r\n     * @returns if the data can be loaded directly\r\n     */\r\n    public canDirectLoad(data: string): boolean {\r\n        return ((data.indexOf(\"scene\") !== -1) && (data.indexOf(\"node\") !== -1));\r\n    }\r\n\r\n    /**\r\n     * Rewrites a url by combining a root url and response url.\r\n     */\r\n    public rewriteRootURL: (rootUrl: string, responseURL?: string) => string;\r\n\r\n    /**\r\n     * Instantiates a glTF file loader plugin.\r\n     * @returns the created plugin\r\n     */\r\n    public createPlugin(): ISceneLoaderPlugin | ISceneLoaderPluginAsync {\r\n        return new GLTFFileLoader();\r\n    }\r\n\r\n    /**\r\n     * The loader state or null if the loader is not active.\r\n     */\r\n    public get loaderState(): Nullable<GLTFLoaderState> {\r\n        return this._loader ? this._loader.state : null;\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when the asset is completely loaded.\r\n     * @returns a promise that resolves when the asset is completely loaded.\r\n     */\r\n    public whenCompleteAsync(): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this.onCompleteObservable.addOnce(() => {\r\n                resolve();\r\n            });\r\n            this.onErrorObservable.addOnce((reason) => {\r\n                reject(reason);\r\n            });\r\n        });\r\n    }\r\n\r\n    private _parseAsync(scene: Scene, data: string | ArrayBuffer, rootUrl: string, fileName?: string): Promise<IGLTFLoaderData> {\r\n        return Promise.resolve().then(() => {\r\n            const unpacked = (data instanceof ArrayBuffer) ? this._unpackBinary(data) : { json: data, bin: null };\r\n\r\n            return this._validateAsync(scene, unpacked.json, rootUrl, fileName).then(() => {\r\n                this._startPerformanceCounter(\"Parse JSON\");\r\n                this._log(`JSON length: ${unpacked.json.length}`);\r\n\r\n                const loaderData: IGLTFLoaderData = {\r\n                    json: JSON.parse(unpacked.json),\r\n                    bin: unpacked.bin\r\n                };\r\n\r\n                this._endPerformanceCounter(\"Parse JSON\");\r\n\r\n                this.onParsedObservable.notifyObservers(loaderData);\r\n                this.onParsedObservable.clear();\r\n\r\n                return loaderData;\r\n            });\r\n        });\r\n    }\r\n\r\n    private _validateAsync(scene: Scene, json: string, rootUrl: string, fileName?: string): Promise<void> {\r\n        if (!this.validate || typeof GLTFValidator === \"undefined\") {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        this._startPerformanceCounter(\"Validate JSON\");\r\n\r\n        const options: IGLTFValidationOptions = {\r\n            externalResourceFunction: (uri) => {\r\n                return this.preprocessUrlAsync(rootUrl + uri)\r\n                    .then((url) => scene._loadFileAsync(url, true, true))\r\n                    .then((data) => new Uint8Array(data as ArrayBuffer));\r\n            }\r\n        };\r\n\r\n        if (fileName && fileName.substr(0, 5) !== \"data:\") {\r\n            options.uri = (rootUrl === \"file:\" ? fileName : `${rootUrl}${fileName}`);\r\n        }\r\n\r\n        return GLTFValidator.validateString(json, options).then((result) => {\r\n            this._endPerformanceCounter(\"Validate JSON\");\r\n\r\n            this.onValidatedObservable.notifyObservers(result);\r\n            this.onValidatedObservable.clear();\r\n        });\r\n    }\r\n\r\n    private _getLoader(loaderData: IGLTFLoaderData): IGLTFLoader {\r\n        const asset = (<any>loaderData.json).asset || {};\r\n\r\n        this._log(`Asset version: ${asset.version}`);\r\n        asset.minVersion && this._log(`Asset minimum version: ${asset.minVersion}`);\r\n        asset.generator && this._log(`Asset generator: ${asset.generator}`);\r\n\r\n        const version = GLTFFileLoader._parseVersion(asset.version);\r\n        if (!version) {\r\n            throw new Error(\"Invalid version: \" + asset.version);\r\n        }\r\n\r\n        if (asset.minVersion !== undefined) {\r\n            const minVersion = GLTFFileLoader._parseVersion(asset.minVersion);\r\n            if (!minVersion) {\r\n                throw new Error(\"Invalid minimum version: \" + asset.minVersion);\r\n            }\r\n\r\n            if (GLTFFileLoader._compareVersion(minVersion, { major: 2, minor: 0 }) > 0) {\r\n                throw new Error(\"Incompatible minimum version: \" + asset.minVersion);\r\n            }\r\n        }\r\n\r\n        const createLoaders: { [key: number]: (parent: GLTFFileLoader) => IGLTFLoader } = {\r\n            1: GLTFFileLoader._CreateGLTFLoaderV1,\r\n            2: GLTFFileLoader._CreateGLTFLoaderV2\r\n        };\r\n\r\n        const createLoader = createLoaders[version.major];\r\n        if (!createLoader) {\r\n            throw new Error(\"Unsupported version: \" + asset.version);\r\n        }\r\n\r\n        return createLoader(this);\r\n    }\r\n\r\n    private _unpackBinary(data: ArrayBuffer): { json: string, bin: Nullable<ArrayBufferView> } {\r\n        this._startPerformanceCounter(\"Unpack binary\");\r\n        this._log(`Binary length: ${data.byteLength}`);\r\n\r\n        const Binary = {\r\n            Magic: 0x46546C67\r\n        };\r\n\r\n        const binaryReader = new BinaryReader(data);\r\n\r\n        const magic = binaryReader.readUint32();\r\n        if (magic !== Binary.Magic) {\r\n            throw new Error(\"Unexpected magic: \" + magic);\r\n        }\r\n\r\n        const version = binaryReader.readUint32();\r\n\r\n        if (this.loggingEnabled) {\r\n            this._log(`Binary version: ${version}`);\r\n        }\r\n\r\n        let unpacked: { json: string, bin: Nullable<ArrayBufferView> };\r\n        switch (version) {\r\n            case 1: {\r\n                unpacked = this._unpackBinaryV1(binaryReader);\r\n                break;\r\n            }\r\n            case 2: {\r\n                unpacked = this._unpackBinaryV2(binaryReader);\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(\"Unsupported version: \" + version);\r\n            }\r\n        }\r\n\r\n        this._endPerformanceCounter(\"Unpack binary\");\r\n        return unpacked;\r\n    }\r\n\r\n    private _unpackBinaryV1(binaryReader: BinaryReader): { json: string, bin: Nullable<ArrayBufferView> } {\r\n        const ContentFormat = {\r\n            JSON: 0\r\n        };\r\n\r\n        const length = binaryReader.readUint32();\r\n        if (length != binaryReader.getLength()) {\r\n            throw new Error(\"Length in header does not match actual data length: \" + length + \" != \" + binaryReader.getLength());\r\n        }\r\n\r\n        const contentLength = binaryReader.readUint32();\r\n        const contentFormat = binaryReader.readUint32();\r\n\r\n        let content: string;\r\n        switch (contentFormat) {\r\n            case ContentFormat.JSON: {\r\n                content = GLTFFileLoader._decodeBufferToText(binaryReader.readUint8Array(contentLength));\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(\"Unexpected content format: \" + contentFormat);\r\n            }\r\n        }\r\n\r\n        const bytesRemaining = binaryReader.getLength() - binaryReader.getPosition();\r\n        const body = binaryReader.readUint8Array(bytesRemaining);\r\n\r\n        return {\r\n            json: content,\r\n            bin: body\r\n        };\r\n    }\r\n\r\n    private _unpackBinaryV2(binaryReader: BinaryReader): { json: string, bin: Nullable<ArrayBufferView> } {\r\n        const ChunkFormat = {\r\n            JSON: 0x4E4F534A,\r\n            BIN: 0x004E4942\r\n        };\r\n\r\n        const length = binaryReader.readUint32();\r\n        if (length !== binaryReader.getLength()) {\r\n            throw new Error(\"Length in header does not match actual data length: \" + length + \" != \" + binaryReader.getLength());\r\n        }\r\n\r\n        // JSON chunk\r\n        const chunkLength = binaryReader.readUint32();\r\n        const chunkFormat = binaryReader.readUint32();\r\n        if (chunkFormat !== ChunkFormat.JSON) {\r\n            throw new Error(\"First chunk format is not JSON\");\r\n        }\r\n        const json = GLTFFileLoader._decodeBufferToText(binaryReader.readUint8Array(chunkLength));\r\n\r\n        // Look for BIN chunk\r\n        let bin: Nullable<Uint8Array> = null;\r\n        while (binaryReader.getPosition() < binaryReader.getLength()) {\r\n            const chunkLength = binaryReader.readUint32();\r\n            const chunkFormat = binaryReader.readUint32();\r\n            switch (chunkFormat) {\r\n                case ChunkFormat.JSON: {\r\n                    throw new Error(\"Unexpected JSON chunk\");\r\n                }\r\n                case ChunkFormat.BIN: {\r\n                    bin = binaryReader.readUint8Array(chunkLength);\r\n                    break;\r\n                }\r\n                default: {\r\n                    // ignore unrecognized chunkFormat\r\n                    binaryReader.skipBytes(chunkLength);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            json: json,\r\n            bin: bin\r\n        };\r\n    }\r\n\r\n    private static _parseVersion(version: string): Nullable<{ major: number, minor: number }> {\r\n        if (version === \"1.0\" || version === \"1.0.1\") {\r\n            return {\r\n                major: 1,\r\n                minor: 0\r\n            };\r\n        }\r\n\r\n        const match = (version + \"\").match(/^(\\d+)\\.(\\d+)/);\r\n        if (!match) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            major: parseInt(match[1]),\r\n            minor: parseInt(match[2])\r\n        };\r\n    }\r\n\r\n    private static _compareVersion(a: { major: number, minor: number }, b: { major: number, minor: number }): number {\r\n        if (a.major > b.major) { return 1; }\r\n        if (a.major < b.major) { return -1; }\r\n        if (a.minor > b.minor) { return 1; }\r\n        if (a.minor < b.minor) { return -1; }\r\n        return 0;\r\n    }\r\n\r\n    private static _decodeBufferToText(buffer: Uint8Array): string {\r\n        let result = \"\";\r\n        const length = buffer.byteLength;\r\n\r\n        for (let i = 0; i < length; i++) {\r\n            result += String.fromCharCode(buffer[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private static readonly _logSpaces = \"                                \";\r\n    private _logIndentLevel = 0;\r\n    private _loggingEnabled = false;\r\n\r\n    /** @hidden */\r\n    public _log = this._logDisabled;\r\n\r\n    /** @hidden */\r\n    public _logOpen(message: string): void {\r\n        this._log(message);\r\n        this._logIndentLevel++;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _logClose(): void {\r\n        --this._logIndentLevel;\r\n    }\r\n\r\n    private _logEnabled(message: string): void {\r\n        const spaces = GLTFFileLoader._logSpaces.substr(0, this._logIndentLevel * 2);\r\n        Tools.Log(`${spaces}${message}`);\r\n    }\r\n\r\n    private _logDisabled(message: string): void {\r\n    }\r\n\r\n    private _capturePerformanceCounters = false;\r\n\r\n    /** @hidden */\r\n    public _startPerformanceCounter = this._startPerformanceCounterDisabled;\r\n\r\n    /** @hidden */\r\n    public _endPerformanceCounter = this._endPerformanceCounterDisabled;\r\n\r\n    private _startPerformanceCounterEnabled(counterName: string): void {\r\n        Tools.StartPerformanceCounter(counterName);\r\n    }\r\n\r\n    private _startPerformanceCounterDisabled(counterName: string): void {\r\n    }\r\n\r\n    private _endPerformanceCounterEnabled(counterName: string): void {\r\n        Tools.EndPerformanceCounter(counterName);\r\n    }\r\n\r\n    private _endPerformanceCounterDisabled(counterName: string): void {\r\n    }\r\n}\r\n\r\nclass BinaryReader {\r\n    private _arrayBuffer: ArrayBuffer;\r\n    private _dataView: DataView;\r\n    private _byteOffset: number;\r\n\r\n    constructor(arrayBuffer: ArrayBuffer) {\r\n        this._arrayBuffer = arrayBuffer;\r\n        this._dataView = new DataView(arrayBuffer);\r\n        this._byteOffset = 0;\r\n    }\r\n\r\n    public getPosition(): number {\r\n        return this._byteOffset;\r\n    }\r\n\r\n    public getLength(): number {\r\n        return this._arrayBuffer.byteLength;\r\n    }\r\n\r\n    public readUint32(): number {\r\n        const value = this._dataView.getUint32(this._byteOffset, true);\r\n        this._byteOffset += 4;\r\n        return value;\r\n    }\r\n\r\n    public readUint8Array(length: number): Uint8Array {\r\n        const value = new Uint8Array(this._arrayBuffer, this._byteOffset, length);\r\n        this._byteOffset += length;\r\n        return value;\r\n    }\r\n\r\n    public skipBytes(length: number): void {\r\n        this._byteOffset += length;\r\n    }\r\n}\r\n\r\nif (SceneLoader) {\r\n    SceneLoader.RegisterPlugin(new GLTFFileLoader());\r\n}\r\n","import { Scene, Texture, Material, Nullable } from \"babylonjs\";\r\nimport { IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport { IGLTFRuntime } from \"./glTFLoaderInterfaces\";\r\nimport { GLTFLoaderV1, GLTFLoaderBase } from \"./glTFLoaderV1\";\r\n\r\nexport abstract class GLTFLoaderExtension {\r\n        private _name: string;\r\n\r\n        public constructor(name: string) {\r\n            this._name = name;\r\n        }\r\n\r\n        public get name(): string {\r\n            return this._name;\r\n        }\r\n\r\n        /**\r\n        * Defines an override for loading the runtime\r\n        * Return true to stop further extensions from loading the runtime\r\n        */\r\n    public loadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess?: (gltfRuntime: IGLTFRuntime) => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an onverride for creating gltf runtime\r\n     * Return true to stop further extensions from creating the runtime\r\n     */\r\n    public loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for loading buffers\r\n    * Return true to stop further extensions from loading this buffer\r\n    */\r\n    public loadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void, onProgress?: () => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for loading texture buffers\r\n    * Return true to stop further extensions from loading this texture data\r\n    */\r\n    public loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for creating textures\r\n    * Return true to stop further extensions from loading this texture\r\n    */\r\n    public createTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: ArrayBufferView, onSuccess: (texture: Texture) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for loading shader strings\r\n    * Return true to stop further extensions from loading this shader data\r\n    */\r\n    public loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for loading materials\r\n    * Return true to stop further extensions from loading this material\r\n    */\r\n    public loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    // ---------\r\n    // Utilities\r\n    // ---------\r\n\r\n    public static LoadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess?: (gltfRuntime: IGLTFRuntime) => void, onError?: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);\r\n        }, () => {\r\n            setTimeout(() => {\r\n                if (!onSuccess) {\r\n                    return;\r\n                }\r\n                onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\r\n            });\r\n        });\r\n    }\r\n\r\n    public static LoadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);\r\n        }, () => {\r\n            setTimeout(() => {\r\n                onSuccess();\r\n            });\r\n        });\r\n    }\r\n\r\n    public static LoadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (bufferView: ArrayBufferView) => void, onError: (message: string) => void, onProgress?: () => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n        }, () => {\r\n            GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n        });\r\n    }\r\n\r\n    public static LoadTextureAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (texture: Texture) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension.LoadTextureBufferAsync(gltfRuntime, id,\r\n            (buffer) => {\r\n                if (buffer) {\r\n                    GLTFLoaderExtension.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n                }\r\n            }, onError);\r\n    }\r\n\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderData: string | ArrayBuffer) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n        }, () => {\r\n            GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n        });\r\n    }\r\n\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n        }, () => {\r\n            GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n        });\r\n    }\r\n\r\n    private static LoadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: Nullable<ArrayBufferView>) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n        }, () => {\r\n            GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n        });\r\n    }\r\n\r\n    private static CreateTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: ArrayBufferView, onSuccess: (texture: Texture) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n        }, () => {\r\n            GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n        });\r\n    }\r\n\r\n    private static ApplyExtensions(func: (loaderExtension: GLTFLoaderExtension) => boolean, defaultFunc: () => void): void {\r\n        for (var extensionName in GLTFLoaderV1.Extensions) {\r\n            var loaderExtension = GLTFLoaderV1.Extensions[extensionName];\r\n            if (func(loaderExtension)) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        defaultFunc();\r\n    }\r\n}","import { Texture, Skeleton, Scene, Bone, Node } from \"babylonjs\";\r\n\r\n/**\r\n* Enums\r\n*/\r\nexport enum EComponentType {\r\n    BYTE = 5120,\r\n    UNSIGNED_BYTE = 5121,\r\n    SHORT = 5122,\r\n    UNSIGNED_SHORT = 5123,\r\n    FLOAT = 5126\r\n}\r\n\r\nexport enum EShaderType {\r\n    FRAGMENT = 35632,\r\n    VERTEX = 35633\r\n}\r\n\r\nexport enum EParameterType {\r\n    BYTE = 5120,\r\n    UNSIGNED_BYTE = 5121,\r\n    SHORT = 5122,\r\n    UNSIGNED_SHORT = 5123,\r\n    INT = 5124,\r\n    UNSIGNED_INT = 5125,\r\n    FLOAT = 5126,\r\n    FLOAT_VEC2 = 35664,\r\n    FLOAT_VEC3 = 35665,\r\n    FLOAT_VEC4 = 35666,\r\n    INT_VEC2 = 35667,\r\n    INT_VEC3 = 35668,\r\n    INT_VEC4 = 35669,\r\n    BOOL = 35670,\r\n    BOOL_VEC2 = 35671,\r\n    BOOL_VEC3 = 35672,\r\n    BOOL_VEC4 = 35673,\r\n    FLOAT_MAT2 = 35674,\r\n    FLOAT_MAT3 = 35675,\r\n    FLOAT_MAT4 = 35676,\r\n    SAMPLER_2D = 35678\r\n}\r\n\r\nexport enum ETextureWrapMode {\r\n    CLAMP_TO_EDGE = 33071,\r\n    MIRRORED_REPEAT = 33648,\r\n    REPEAT = 10497\r\n}\r\n\r\nexport enum ETextureFilterType {\r\n    NEAREST = 9728,\r\n    LINEAR = 9728,\r\n    NEAREST_MIPMAP_NEAREST = 9984,\r\n    LINEAR_MIPMAP_NEAREST = 9985,\r\n    NEAREST_MIPMAP_LINEAR = 9986,\r\n    LINEAR_MIPMAP_LINEAR = 9987\r\n}\r\n\r\nexport enum ETextureFormat {\r\n    ALPHA = 6406,\r\n    RGB = 6407,\r\n    RGBA = 6408,\r\n    LUMINANCE = 6409,\r\n    LUMINANCE_ALPHA = 6410\r\n}\r\n\r\nexport enum ECullingType {\r\n    FRONT = 1028,\r\n    BACK = 1029,\r\n    FRONT_AND_BACK = 1032\r\n}\r\n\r\nexport enum EBlendingFunction {\r\n    ZERO = 0,\r\n    ONE = 1,\r\n    SRC_COLOR = 768,\r\n    ONE_MINUS_SRC_COLOR = 769,\r\n    DST_COLOR = 774,\r\n    ONE_MINUS_DST_COLOR = 775,\r\n    SRC_ALPHA = 770,\r\n    ONE_MINUS_SRC_ALPHA = 771,\r\n    DST_ALPHA = 772,\r\n    ONE_MINUS_DST_ALPHA = 773,\r\n    CONSTANT_COLOR = 32769,\r\n    ONE_MINUS_CONSTANT_COLOR = 32770,\r\n    CONSTANT_ALPHA = 32771,\r\n    ONE_MINUS_CONSTANT_ALPHA = 32772,\r\n    SRC_ALPHA_SATURATE = 776\r\n}\r\n\r\n/**\r\n* Interfaces\r\n*/\r\nexport interface IGLTFProperty {\r\n    extensions?: {[key: string]: any};\r\n    extras?: Object;\r\n}\r\n\r\nexport interface IGLTFChildRootProperty extends IGLTFProperty {\r\n    name?: string;\r\n}\r\n\r\nexport interface IGLTFAccessor extends IGLTFChildRootProperty {\r\n    bufferView: string;\r\n    byteOffset: number;\r\n    byteStride: number;\r\n    count: number;\r\n    type: string;\r\n    componentType: EComponentType;\r\n\r\n    max?: number[];\r\n    min?: number[];\r\n    name?: string;\r\n}\r\n\r\nexport interface IGLTFBufferView extends IGLTFChildRootProperty {\r\n    buffer: string;\r\n    byteOffset: number;\r\n    byteLength: number;\r\n    byteStride: number;\r\n\r\n    target?: number;\r\n}\r\n\r\nexport interface IGLTFBuffer extends IGLTFChildRootProperty {\r\n    uri: string;\r\n\r\n    byteLength?: number;\r\n    type?: string;\r\n}\r\n\r\nexport interface IGLTFShader extends IGLTFChildRootProperty {\r\n    uri: string;\r\n    type: EShaderType;\r\n}\r\n\r\nexport interface IGLTFProgram extends IGLTFChildRootProperty {\r\n    attributes: string[];\r\n    fragmentShader: string;\r\n    vertexShader: string;\r\n}\r\n\r\nexport interface IGLTFTechniqueParameter {\r\n    type: number;\r\n\r\n    count?: number;\r\n    semantic?: string;\r\n    node?: string;\r\n    value?: number | boolean | string | Array<any>;\r\n    source?: string;\r\n\r\n    babylonValue?: any;\r\n}\r\n\r\nexport interface IGLTFTechniqueCommonProfile {\r\n    lightingModel: string;\r\n    texcoordBindings: Object;\r\n\r\n    parameters?: Array<any>;\r\n}\r\n\r\nexport interface IGLTFTechniqueStatesFunctions {\r\n    blendColor?: number[];\r\n    blendEquationSeparate?: number[];\r\n    blendFuncSeparate?: number[];\r\n    colorMask: boolean[];\r\n    cullFace: number[];\r\n}\r\n\r\nexport interface IGLTFTechniqueStates {\r\n    enable: number[];\r\n    functions: IGLTFTechniqueStatesFunctions;\r\n}\r\n\r\nexport interface IGLTFTechnique extends IGLTFChildRootProperty {\r\n    parameters: {[key: string]: IGLTFTechniqueParameter};\r\n    program: string;\r\n\r\n    attributes: {[key: string]: string};\r\n    uniforms: {[key: string]: string};\r\n    states: IGLTFTechniqueStates;\r\n}\r\n\r\nexport interface IGLTFMaterial extends IGLTFChildRootProperty {\r\n    technique?: string;\r\n    values: string[];\r\n}\r\n\r\nexport interface IGLTFMeshPrimitive extends IGLTFProperty {\r\n    attributes: {[key: string]: string};\r\n    indices: string;\r\n    material: string;\r\n\r\n    mode?: number;\r\n}\r\n\r\nexport interface IGLTFMesh extends IGLTFChildRootProperty {\r\n    primitives: IGLTFMeshPrimitive[];\r\n}\r\n\r\nexport interface IGLTFImage extends IGLTFChildRootProperty {\r\n    uri: string;\r\n}\r\n\r\nexport interface IGLTFSampler extends IGLTFChildRootProperty {\r\n    magFilter?: number;\r\n    minFilter?: number;\r\n    wrapS?: number;\r\n    wrapT?: number;\r\n}\r\n\r\nexport interface IGLTFTexture extends IGLTFChildRootProperty {\r\n    sampler: string;\r\n    source: string;\r\n\r\n    format?: ETextureFormat;\r\n    internalFormat?: ETextureFormat;\r\n    target?: number;\r\n    type?: number;\r\n\r\n    // Babylon.js values (optimize)\r\n    babylonTexture?: Texture;\r\n}\r\n\r\nexport interface IGLTFAmbienLight {\r\n    color?: number[];\r\n}\r\n\r\nexport interface IGLTFDirectionalLight {\r\n    color?: number[];\r\n}\r\n\r\nexport interface IGLTFPointLight {\r\n    color?: number[];\r\n    constantAttenuation?: number;\r\n    linearAttenuation?: number;\r\n    quadraticAttenuation?: number;\r\n}\r\n\r\nexport interface IGLTFSpotLight {\r\n    color?: number[];\r\n    constantAttenuation?: number;\r\n    fallOfAngle?: number;\r\n    fallOffExponent?: number;\r\n    linearAttenuation?: number;\r\n    quadraticAttenuation?: number;\r\n}\r\n\r\nexport interface IGLTFLight extends IGLTFChildRootProperty {\r\n    type: string;\r\n}\r\n\r\nexport interface IGLTFCameraOrthographic {\r\n    xmag: number;\r\n    ymag: number;\r\n    zfar: number;\r\n    znear: number;\r\n}\r\n\r\nexport interface IGLTFCameraPerspective {\r\n    aspectRatio: number;\r\n    yfov: number;\r\n    zfar: number;\r\n    znear: number;\r\n}\r\n\r\nexport interface IGLTFCamera extends IGLTFChildRootProperty {\r\n    type: string;\r\n}\r\n\r\nexport interface IGLTFAnimationChannelTarget {\r\n    id: string;\r\n    path: string;\r\n}\r\n\r\nexport interface IGLTFAnimationChannel {\r\n    sampler: string;\r\n    target: IGLTFAnimationChannelTarget;\r\n}\r\n\r\nexport interface IGLTFAnimationSampler {\r\n    input: string;\r\n    output: string;\r\n\r\n    interpolation?: string;\r\n}\r\n\r\nexport interface IGLTFAnimation extends IGLTFChildRootProperty {\r\n    channels?: IGLTFAnimationChannel[];\r\n    parameters?:  {[key: string]: string};\r\n    samplers?: {[key: string]: IGLTFAnimationSampler};\r\n}\r\n\r\nexport interface IGLTFNodeInstanceSkin {\r\n    skeletons: string[];\r\n    skin: string;\r\n    meshes: string[];\r\n}\r\n\r\nexport interface IGLTFSkins extends IGLTFChildRootProperty {\r\n    bindShapeMatrix: number[];\r\n    inverseBindMatrices: string;\r\n    jointNames: string[];\r\n\r\n    babylonSkeleton?: Skeleton;\r\n}\r\n\r\nexport interface IGLTFNode extends IGLTFChildRootProperty {\r\n    camera?: string;\r\n    children: string[];\r\n    skin?: string;\r\n    jointName?: string;\r\n    light?: string;\r\n    matrix: number[];\r\n    mesh?: string;\r\n    meshes?: string[];\r\n    rotation?: number[];\r\n    scale?: number[];\r\n    translation?: number[];\r\n\r\n    // Babylon.js values (optimize)\r\n    babylonNode?: Node;\r\n}\r\n\r\nexport interface IGLTFScene extends IGLTFChildRootProperty {\r\n    nodes: string[];\r\n}\r\n\r\n/**\r\n* Runtime\r\n*/\r\nexport interface IGLTFRuntime {\r\n    extensions: {[key: string]: any};\r\n    accessors: {[key: string]: IGLTFAccessor};\r\n    buffers: {[key: string]: IGLTFBuffer};\r\n    bufferViews: {[key: string]: IGLTFBufferView};\r\n    meshes: {[key: string]: IGLTFMesh};\r\n    lights: {[key: string]: IGLTFLight};\r\n    cameras: {[key: string]: IGLTFCamera};\r\n    nodes: {[key: string]: IGLTFNode};\r\n    images: {[key: string]: IGLTFImage};\r\n    textures: {[key: string]: IGLTFTexture};\r\n    shaders: {[key: string]: IGLTFShader};\r\n    programs: {[key: string]: IGLTFProgram};\r\n    samplers: {[key: string]: IGLTFSampler};\r\n    techniques: {[key: string]: IGLTFTechnique};\r\n    materials: {[key: string]: IGLTFMaterial};\r\n    animations: {[key: string]: IGLTFAnimation};\r\n    skins: {[key: string]: IGLTFSkins};\r\n\r\n    currentScene?: Object;\r\n    scenes: {[key: string]: IGLTFScene}; // v1.1\r\n\r\n    extensionsUsed: string[];\r\n    extensionsRequired?: string[]; // v1.1\r\n\r\n    buffersCount: number;\r\n    shaderscount: number;\r\n\r\n    scene: Scene;\r\n    rootUrl: string;\r\n\r\n    loadedBufferCount: number;\r\n    loadedBufferViews: { [name: string]: ArrayBufferView };\r\n\r\n    loadedShaderCount: number;\r\n\r\n    importOnlyMeshes: boolean;\r\n    importMeshesNames?: string[];\r\n\r\n    dummyNodes: Node[];\r\n}\r\n\r\n/**\r\n* Bones\r\n*/\r\nexport interface INodeToRoot {\r\n    bone: Bone;\r\n    node: IGLTFNode;\r\n    id: string;\r\n}\r\n\r\nexport interface IJointNode {\r\n    node: IGLTFNode;\r\n    id: string;\r\n}\r\n","import { Scene, ShaderMaterial, Effect, Nullable, Matrix, Vector2, Vector3, Vector4, Texture, Color4, Node } from \"babylonjs\";\r\nimport { IGLTFTechniqueParameter, EParameterType, ETextureWrapMode, IGLTFAccessor, ETextureFilterType, IGLTFRuntime, IGLTFBufferView, EComponentType } from \"./glTFLoaderInterfaces\";\r\n\r\n/**\r\n* Utils functions for GLTF\r\n*/\r\nexport class GLTFUtils {\r\n    /**\r\n     * Sets the given \"parameter\" matrix\r\n     * @param scene: the Scene object\r\n     * @param source: the source node where to pick the matrix\r\n     * @param parameter: the GLTF technique parameter\r\n     * @param uniformName: the name of the shader's uniform\r\n     * @param shaderMaterial: the shader material\r\n     */\r\n    public static SetMatrix(scene: Scene, source: Node, parameter: IGLTFTechniqueParameter, uniformName: string, shaderMaterial: ShaderMaterial | Effect): void {\r\n        var mat: Nullable<Matrix> = null;\r\n\r\n        if (parameter.semantic === \"MODEL\") {\r\n            mat = source.getWorldMatrix();\r\n        }\r\n        else if (parameter.semantic === \"PROJECTION\") {\r\n            mat = scene.getProjectionMatrix();\r\n        }\r\n        else if (parameter.semantic === \"VIEW\") {\r\n            mat = scene.getViewMatrix();\r\n        }\r\n        else if (parameter.semantic === \"MODELVIEWINVERSETRANSPOSE\") {\r\n            mat = Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());\r\n        }\r\n        else if (parameter.semantic === \"MODELVIEW\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix());\r\n        }\r\n        else if (parameter.semantic === \"MODELVIEWPROJECTION\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());\r\n        }\r\n        else if (parameter.semantic === \"MODELINVERSE\") {\r\n            mat = source.getWorldMatrix().invert();\r\n        }\r\n        else if (parameter.semantic === \"VIEWINVERSE\") {\r\n            mat = scene.getViewMatrix().invert();\r\n        }\r\n        else if (parameter.semantic === \"PROJECTIONINVERSE\") {\r\n            mat = scene.getProjectionMatrix().invert();\r\n        }\r\n        else if (parameter.semantic === \"MODELVIEWINVERSE\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();\r\n        }\r\n        else if (parameter.semantic === \"MODELVIEWPROJECTIONINVERSE\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();\r\n        }\r\n        else if (parameter.semantic === \"MODELINVERSETRANSPOSE\") {\r\n            mat = Matrix.Transpose(source.getWorldMatrix().invert());\r\n        }\r\n        else {\r\n            debugger;\r\n        }\r\n\r\n        if (mat) {\r\n            switch (parameter.type) {\r\n                case EParameterType.FLOAT_MAT2: shaderMaterial.setMatrix2x2(uniformName, Matrix.GetAsMatrix2x2(mat)); break;\r\n                case EParameterType.FLOAT_MAT3: shaderMaterial.setMatrix3x3(uniformName, Matrix.GetAsMatrix3x3(mat)); break;\r\n                case EParameterType.FLOAT_MAT4: shaderMaterial.setMatrix(uniformName, mat); break;\r\n                default: break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the given \"parameter\" matrix\r\n     * @param shaderMaterial: the shader material\r\n     * @param uniform: the name of the shader's uniform\r\n     * @param value: the value of the uniform\r\n     * @param type: the uniform's type (EParameterType FLOAT, VEC2, VEC3 or VEC4)\r\n     */\r\n    public static SetUniform(shaderMaterial: ShaderMaterial | Effect, uniform: string, value: any, type: number): boolean {\r\n        switch (type) {\r\n            case EParameterType.FLOAT: shaderMaterial.setFloat(uniform, value); return true;\r\n            case EParameterType.FLOAT_VEC2: shaderMaterial.setVector2(uniform, Vector2.FromArray(value)); return true;\r\n            case EParameterType.FLOAT_VEC3: shaderMaterial.setVector3(uniform, Vector3.FromArray(value)); return true;\r\n            case EParameterType.FLOAT_VEC4: shaderMaterial.setVector4(uniform, Vector4.FromArray(value)); return true;\r\n            default: return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Returns the wrap mode of the texture\r\n    * @param mode: the mode value\r\n    */\r\n    public static GetWrapMode(mode: number): number {\r\n        switch (mode) {\r\n            case ETextureWrapMode.CLAMP_TO_EDGE: return Texture.CLAMP_ADDRESSMODE;\r\n            case ETextureWrapMode.MIRRORED_REPEAT: return Texture.MIRROR_ADDRESSMODE;\r\n            case ETextureWrapMode.REPEAT: return Texture.WRAP_ADDRESSMODE;\r\n            default: return Texture.WRAP_ADDRESSMODE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the byte stride giving an accessor\r\n     * @param accessor: the GLTF accessor objet\r\n     */\r\n    public static GetByteStrideFromType(accessor: IGLTFAccessor): number {\r\n        // Needs this function since \"byteStride\" isn't requiered in glTF format\r\n        var type = accessor.type;\r\n\r\n        switch (type) {\r\n            case \"VEC2\": return 2;\r\n            case \"VEC3\": return 3;\r\n            case \"VEC4\": return 4;\r\n            case \"MAT2\": return 4;\r\n            case \"MAT3\": return 9;\r\n            case \"MAT4\": return 16;\r\n            default: return 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the texture filter mode giving a mode value\r\n     * @param mode: the filter mode value\r\n     */\r\n    public static GetTextureFilterMode(mode: number): ETextureFilterType {\r\n        switch (mode) {\r\n            case ETextureFilterType.LINEAR:\r\n            case ETextureFilterType.LINEAR_MIPMAP_NEAREST:\r\n            case ETextureFilterType.LINEAR_MIPMAP_LINEAR: return Texture.TRILINEAR_SAMPLINGMODE;\r\n            case ETextureFilterType.NEAREST:\r\n            case ETextureFilterType.NEAREST_MIPMAP_NEAREST: return Texture.NEAREST_SAMPLINGMODE;\r\n            default: return Texture.BILINEAR_SAMPLINGMODE;\r\n        }\r\n    }\r\n\r\n    public static GetBufferFromBufferView(gltfRuntime: IGLTFRuntime, bufferView: IGLTFBufferView, byteOffset: number, byteLength: number, componentType: EComponentType): ArrayBufferView {\r\n        var byteOffset = bufferView.byteOffset + byteOffset;\r\n\r\n        var loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];\r\n        if (byteOffset + byteLength > loadedBufferView.byteLength) {\r\n            throw new Error(\"Buffer access is out of range\");\r\n        }\r\n\r\n        var buffer = loadedBufferView.buffer;\r\n        byteOffset += loadedBufferView.byteOffset;\r\n\r\n        switch (componentType) {\r\n            case EComponentType.BYTE: return new Int8Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.UNSIGNED_BYTE: return new Uint8Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.SHORT: return new Int16Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.UNSIGNED_SHORT: return new Uint16Array(buffer, byteOffset, byteLength);\r\n            default: return new Float32Array(buffer, byteOffset, byteLength);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a buffer from its accessor\r\n     * @param gltfRuntime: the GLTF runtime\r\n     * @param accessor: the GLTF accessor\r\n     */\r\n    public static GetBufferFromAccessor(gltfRuntime: IGLTFRuntime, accessor: IGLTFAccessor): any {\r\n        var bufferView: IGLTFBufferView = gltfRuntime.bufferViews[accessor.bufferView];\r\n        var byteLength = accessor.count * GLTFUtils.GetByteStrideFromType(accessor);\r\n        return GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);\r\n    }\r\n\r\n    /**\r\n     * Decodes a buffer view into a string\r\n     * @param view: the buffer view\r\n     */\r\n    public static DecodeBufferToText(view: ArrayBufferView): string {\r\n        var result = \"\";\r\n        var length = view.byteLength;\r\n\r\n        for (var i = 0; i < length; ++i) {\r\n            result += String.fromCharCode((<any>view)[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the default material of gltf. Related to\r\n     * https://github.com/KhronosGroup/glTF/tree/master/specification/1.0#appendix-a-default-material\r\n     * @param scene: the Babylon.js scene\r\n     */\r\n    public static GetDefaultMaterial(scene: Scene): ShaderMaterial {\r\n        if (!GLTFUtils._DefaultMaterial) {\r\n            Effect.ShadersStore[\"GLTFDefaultMaterialVertexShader\"] = [\r\n                \"precision highp float;\",\r\n                \"\",\r\n                \"uniform mat4 worldView;\",\r\n                \"uniform mat4 projection;\",\r\n                \"\",\r\n                \"attribute vec3 position;\",\r\n                \"\",\r\n                \"void main(void)\",\r\n                \"{\",\r\n                \"    gl_Position = projection * worldView * vec4(position, 1.0);\",\r\n                \"}\"\r\n            ].join(\"\\n\");\r\n\r\n            Effect.ShadersStore[\"GLTFDefaultMaterialPixelShader\"] = [\r\n                \"precision highp float;\",\r\n                \"\",\r\n                \"uniform vec4 u_emission;\",\r\n                \"\",\r\n                \"void main(void)\",\r\n                \"{\",\r\n                \"    gl_FragColor = u_emission;\",\r\n                \"}\"\r\n            ].join(\"\\n\");\r\n\r\n            var shaderPath = {\r\n                vertex: \"GLTFDefaultMaterial\",\r\n                fragment: \"GLTFDefaultMaterial\"\r\n            };\r\n\r\n            var options = {\r\n                attributes: [\"position\"],\r\n                uniforms: [\"worldView\", \"projection\", \"u_emission\"],\r\n                samplers: new Array<string>(),\r\n                needAlphaBlending: false\r\n            };\r\n\r\n            GLTFUtils._DefaultMaterial = new ShaderMaterial(\"GLTFDefaultMaterial\", scene, shaderPath, options);\r\n            GLTFUtils._DefaultMaterial.setColor4(\"u_emission\", new Color4(0.5, 0.5, 0.5, 1.0));\r\n        }\r\n\r\n        return GLTFUtils._DefaultMaterial;\r\n    }\r\n\r\n    // The GLTF default material\r\n    private static _DefaultMaterial: Nullable<ShaderMaterial> = null;\r\n}","export * from \"./glTF\";\r\nexport * from \"./OBJ\";\r\nexport * from \"./STL\";","export * from \"./glTFBinaryExtension\";\r\nexport * from \"./glTFLoaderV1\";\r\nexport * from \"./glTFLoaderExtension\";\r\n//export * from \"./glTFLoaderInterfaces\";\r\nexport * from \"./glTFLoaderUtils\";\r\nexport * from \"./glTFMaterialsCommonExtension\";","import * as MatLib from \"./index\";\r\n\r\n/**\r\n * Legacy support, defining window.BABYLON.GridMaterial... (global variable).\r\n *\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nvar globalObject = (typeof global !== 'undefined') ? global : ((typeof window !== 'undefined') ? window : undefined);\r\nif (typeof globalObject !== \"undefined\") {\r\n    (<any>globalObject).BABYLON = (<any>globalObject).BABYLON || {};\r\n    for (var mat in MatLib) {\r\n        if (MatLib.hasOwnProperty(mat)) {\r\n            (<any>globalObject).BABYLON[mat] = (<any>MatLib)[mat];\r\n        }\r\n    }\r\n}\r\n\r\nexport * from \"./index\";","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n","export * from \"./glTFFileLoader\";\r\nexport * from \"./1.0\";\r\nexport * from \"./2.0\";","import { GLTFLoaderExtension } from \"./glTFLoaderExtension\";\r\nimport { GLTFUtils } from \"./glTFLoaderUtils\";\r\nimport { GLTFLoaderBase } from \"./glTFLoaderV1\";\r\nimport { Scene } from \"babylonjs\";\r\nimport { IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport { IGLTFRuntime, IGLTFTexture, IGLTFImage, IGLTFBufferView, EComponentType, IGLTFShader } from \"./glTFLoaderInterfaces\";\r\n\r\nimport { GLTFLoaderV1 } from \"./glTFLoaderV1\";\r\n\r\nconst BinaryExtensionBufferName = \"binary_glTF\";\r\n\r\ninterface IGLTFBinaryExtensionShader {\r\n    bufferView: string;\r\n}\r\n\r\ninterface IGLTFBinaryExtensionImage {\r\n    bufferView: string;\r\n    mimeType: string;\r\n    height: number;\r\n    width: number;\r\n}\r\n\r\nexport class GLTFBinaryExtension extends GLTFLoaderExtension {\r\n    private _bin : ArrayBufferView;\r\n\r\n    public constructor() {\r\n        super(\"KHR_binary_glTF\");\r\n    }\r\n\r\n    public loadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess: (gltfRuntime: IGLTFRuntime) => void, onError: (message: string) => void): boolean {\r\n        var extensionsUsed = (<any>data.json).extensionsUsed;\r\n        if (!extensionsUsed || extensionsUsed.indexOf(this.name) === -1 || !data.bin) {\r\n            return false;\r\n        }\r\n\r\n        this._bin = data.bin;\r\n        onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\r\n        return true;\r\n    }\r\n\r\n    public loadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        if (gltfRuntime.extensionsUsed.indexOf(this.name) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (id !== BinaryExtensionBufferName) {\r\n            return false;\r\n        }\r\n\r\n        onSuccess(this._bin);\r\n        return true;\r\n    }\r\n\r\n    public loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        var texture: IGLTFTexture = gltfRuntime.textures[id];\r\n        var source: IGLTFImage = gltfRuntime.images[texture.source];\r\n        if (!source.extensions || !(this.name in source.extensions)) {\r\n            return false;\r\n        }\r\n\r\n        var sourceExt: IGLTFBinaryExtensionImage = source.extensions[this.name];\r\n        var bufferView: IGLTFBufferView = gltfRuntime.bufferViews[sourceExt.bufferView];\r\n        var buffer = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);\r\n        onSuccess(buffer);\r\n        return true;\r\n    }\r\n\r\n    public loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void, onError: (message: string) => void): boolean {\r\n        var shader: IGLTFShader = gltfRuntime.shaders[id];\r\n        if (!shader.extensions || !(this.name in shader.extensions)) {\r\n            return false;\r\n        }\r\n\r\n        var binaryExtensionShader: IGLTFBinaryExtensionShader = shader.extensions[this.name];\r\n        var bufferView: IGLTFBufferView = gltfRuntime.bufferViews[binaryExtensionShader.bufferView];\r\n        var shaderBytes = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);\r\n\r\n        setTimeout(() => {\r\n            var shaderString = GLTFUtils.DecodeBufferToText(shaderBytes);\r\n            onSuccess(shaderString);\r\n        });\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nGLTFLoaderV1.RegisterExtension(new GLTFBinaryExtension());","import { GLTFLoaderExtension, GLTFLoaderBase } from \".\";\n\nimport { IGLTFRuntime, IGLTFMaterial } from \"./glTFLoaderInterfaces\";\n\nimport { HemisphericLight, Vector3, Color3, PointLight, DirectionalLight, SpotLight, Tools, Material, StandardMaterial } from \"babylonjs\";\n\nimport { GLTFLoaderV1 } from \"./glTFLoaderV1\";\n\ninterface IGLTFMaterialsCommonExtensionValues {\n    ambient?: number[] | string;\n    diffuse?: number[] | string;\n    emission?: number[] | string;\n    specular?: number[] | string;\n    shininess?: number;\n    transparency?: number;\n}\n\ninterface IGLTFMaterialsCommonExtension {\n    technique: string;\n    transparent?: number;\n    doubleSided?: boolean;\n    values: IGLTFMaterialsCommonExtensionValues;\n}\n\ninterface IGLTFRuntimeCommonExtension {\n    lights: {[key: string]: IGLTFLightCommonExtension};\n}\n\ninterface IGLTFLightCommonExtension {\n    name: string;\n    type: string;\n\n    ambient?: IGLTFAmbientLightCommonExtension;\n    point?: IGLTFPointLightCommonExtension;\n    directional?: IGLTFDirectionalLightCommonExtension;\n    spot?: IGLTFSpotLightCommonExtension;\n}\n\ninterface IGLTFPointLightCommonExtension {\n    color: number[];\n    constantAttenuation: number;\n    linearAttenuation: number;\n    quadraticAttenuation: number;\n}\n\ninterface IGLTFAmbientLightCommonExtension {\n    color: number[];\n}\n\ninterface IGLTFDirectionalLightCommonExtension {\n    color: number[];\n}\n\ninterface IGLTFSpotLightCommonExtension {\n    color: number[];\n    constantAttenuation: number;\n    fallOffAngle: number;\n    fallOffExponent: number;\n    linearAttenuation: number;\n    quadraticAttenuation: number;\n}\n\nexport class GLTFMaterialsCommonExtension extends GLTFLoaderExtension {\n\n    constructor() {\n        super(\"KHR_materials_common\");\n    }\n\n    public loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError: (message: string) => void): boolean {\n        if (!gltfRuntime.extensions) { return false; }\n\n        var extension: IGLTFRuntimeCommonExtension = gltfRuntime.extensions[this.name];\n        if (!extension) { return false; }\n\n        // Create lights\n        var lights = extension.lights;\n        if (lights) {\n            for (var thing in lights) {\n                var light: IGLTFLightCommonExtension = lights[thing];\n\n                switch (light.type) {\n                    case \"ambient\":\n                        var ambientLight = new HemisphericLight(light.name, new Vector3(0, 1, 0), gltfRuntime.scene);\n                        var ambient = light.ambient;\n                        if (ambient) {\n                            ambientLight.diffuse = Color3.FromArray(ambient.color || [1, 1, 1]);\n                        }\n                        break;\n                    case \"point\":\n                        var pointLight = new PointLight(light.name, new Vector3(10, 10, 10), gltfRuntime.scene);\n                        var point = light.point;\n                        if (point) {\n                            pointLight.diffuse = Color3.FromArray(point.color || [1, 1, 1]);\n                        }\n                        break;\n                    case \"directional\":\n                        var dirLight = new DirectionalLight(light.name, new Vector3(0, -1, 0), gltfRuntime.scene);\n                        var directional = light.directional;\n                        if (directional) {\n                            dirLight.diffuse = Color3.FromArray(directional.color || [1, 1, 1]);\n                        }\n                        break;\n                    case \"spot\":\n                        var spot = light.spot;\n                        if (spot) {\n                            var spotLight = new SpotLight(light.name, new Vector3(0, 10, 0), new Vector3(0, -1, 0),\n                                                        spot.fallOffAngle || Math.PI,\n                                                        spot.fallOffExponent || 0.0,\n                                                        gltfRuntime.scene);\n                            spotLight.diffuse = Color3.FromArray(spot.color || [1, 1, 1]);\n                        }\n                        break;\n                    default: Tools.Warn(\"GLTF Material Common extension: light type \\\"\" + light.type + \"\\ not supported\"); break;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\n        var material: IGLTFMaterial = gltfRuntime.materials[id];\n        if (!material || !material.extensions) { return false; }\n\n        var extension: IGLTFMaterialsCommonExtension = material.extensions[this.name];\n        if (!extension) { return false; }\n\n        var standardMaterial = new StandardMaterial(id, gltfRuntime.scene);\n        standardMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\n\n        if (extension.technique === \"CONSTANT\") {\n            standardMaterial.disableLighting = true;\n        }\n\n        standardMaterial.backFaceCulling = extension.doubleSided === undefined ? false : !extension.doubleSided;\n        standardMaterial.alpha = extension.values.transparency === undefined ? 1.0 : extension.values.transparency;\n        standardMaterial.specularPower = extension.values.shininess === undefined ? 0.0 : extension.values.shininess;\n\n        // Ambient\n        if (typeof extension.values.ambient === \"string\") {\n            this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, \"ambientTexture\", onError);\n        }\n        else {\n            standardMaterial.ambientColor = Color3.FromArray(extension.values.ambient || [0, 0, 0]);\n        }\n\n        // Diffuse\n        if (typeof extension.values.diffuse === \"string\") {\n            this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, \"diffuseTexture\", onError);\n        }\n        else {\n            standardMaterial.diffuseColor = Color3.FromArray(extension.values.diffuse || [0, 0, 0]);\n        }\n\n        // Emission\n        if (typeof extension.values.emission === \"string\") {\n            this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, \"emissiveTexture\", onError);\n        }\n        else {\n            standardMaterial.emissiveColor = Color3.FromArray(extension.values.emission || [0, 0, 0]);\n        }\n\n        // Specular\n        if (typeof extension.values.specular === \"string\") {\n            this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, \"specularTexture\", onError);\n        }\n        else {\n            standardMaterial.specularColor = Color3.FromArray(extension.values.specular || [0, 0, 0]);\n        }\n\n        return true;\n    }\n\n    private _loadTexture(gltfRuntime: IGLTFRuntime, id: string, material: StandardMaterial, propertyPath: string, onError: (message: string) => void): void {\n        // Create buffer from texture url\n        GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, (buffer) => {\n            // Create texture from buffer\n            GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, (texture) => (<any>material)[propertyPath] = texture, onError);\n        }, onError);\n    }\n}\n\nGLTFLoaderV1.RegisterExtension(new GLTFMaterialsCommonExtension());\n","export * from \"./glTFLoader\";\r\nexport * from \"./glTFLoaderExtension\";\r\n//export * from \"./glTFLoaderInterfaces\";\r\nexport * from \"./Extensions\";","import { IDisposable, Nullable, Mesh, Camera, Geometry, Material, BaseTexture, AnimationGroup } from \"babylonjs\";\r\nimport { ISceneV2, INodeV2, ICameraV2, IMeshPrimitiveV2, IMaterialV2, ITextureInfoV2, IAnimationV2 } from \"./glTFLoaderInterfaces\";\r\nimport { IGLTFLoaderExtension } from \"../glTFFileLoader\";\r\n\r\nexport var tata = 0;\r\n\r\n/**\r\n * Interface for a glTF loader extension.\r\n */\r\nexport interface IGLTFLoaderExtensionV2 extends IGLTFLoaderExtension, IDisposable {\r\n    /**\r\n     * Called after the loader state changes to LOADING.\r\n     */\r\n    onLoading?(): void;\r\n\r\n    /**\r\n     * Called after the loader state changes to READY.\r\n     */\r\n    onReady?(): void;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when loading scenes.\r\n     * @param context The context when loading the asset\r\n     * @param scene The glTF scene property\r\n     * @returns A promise that resolves when the load is complete or null if not handled\r\n     */\r\n    loadSceneAsync?(context: string, scene: ISceneV2): Nullable<Promise<void>>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when loading nodes.\r\n     * @param context The context when loading the asset\r\n     * @param node The glTF node property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon mesh when the load is complete or null if not handled\r\n     */\r\n    loadNodeAsync?(context: string, node: INodeV2, assign: (babylonMesh: Mesh) => void): Nullable<Promise<Mesh>>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when loading cameras.\r\n     * @param context The context when loading the asset\r\n     * @param camera The glTF camera property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon camera when the load is complete or null if not handled\r\n     */\r\n    loadCameraAsync?(context: string, camera: ICameraV2, assign: (babylonCamera: Camera) => void): Nullable<Promise<Camera>>;\r\n\r\n    /**\r\n     * @hidden Define this method to modify the default behavior when loading vertex data for mesh primitives.\r\n     * @param context The context when loading the asset\r\n     * @param primitive The glTF mesh primitive property\r\n     * @returns A promise that resolves with the loaded geometry when the load is complete or null if not handled\r\n     */\r\n    _loadVertexDataAsync?(context: string, primitive: IMeshPrimitiveV2, babylonMesh: Mesh): Nullable<Promise<Geometry>>;\r\n\r\n    /**\r\n     * @hidden Define this method to modify the default behavior when loading materials. Load material creates the material and then loads material properties.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon material when the load is complete or null if not handled\r\n     */\r\n    _loadMaterialAsync?(context: string, material: IMaterialV2, babylonMesh: Mesh, babylonDrawMode: number, assign: (babylonMaterial: Material) => void): Nullable<Promise<Material>>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when creating materials.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonDrawMode The draw mode for the Babylon material\r\n     * @returns The Babylon material or null if not handled\r\n     */\r\n    createMaterial?(context: string, material: IMaterialV2, babylonDrawMode: number): Nullable<Material>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when loading material properties.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     * @returns A promise that resolves when the load is complete or null if not handled\r\n     */\r\n    loadMaterialPropertiesAsync?(context: string, material: IMaterialV2, babylonMaterial: Material): Nullable<Promise<void>>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when loading texture infos.\r\n     * @param context The context when loading the asset\r\n     * @param textureInfo The glTF texture info property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon texture when the load is complete or null if not handled\r\n     */\r\n    loadTextureInfoAsync?(context: string, textureInfo: ITextureInfoV2, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when loading animations.\r\n     * @param context The context when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @returns A promise that resolves with the loaded Babylon animation group when the load is complete or null if not handled\r\n     */\r\n    loadAnimationAsync?(context: string, animation: IAnimationV2): Nullable<Promise<AnimationGroup>>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when loading uris.\r\n     * @param context The context when loading the asset\r\n     * @param uri The uri to load\r\n     * @returns A promise that resolves with the loaded data when the load is complete or null if not handled\r\n     */\r\n    _loadUriAsync?(context: string, uri: string): Nullable<Promise<ArrayBufferView>>;\r\n}","export * from \"./EXT_lights_image_based\";\r\nexport * from \"./KHR_draco_mesh_compression\";\r\nexport * from \"./KHR_lights_punctual\";\r\nexport * from \"./KHR_materials_pbrSpecularGlossiness\";\r\nexport * from \"./KHR_materials_unlit\";\r\nexport * from \"./KHR_texture_transform\";\r\nexport * from \"./MSFT_audio_emitter\";\r\nexport * from \"./MSFT_lod\";\r\nexport * from \"./MSFT_minecraftMesh\";\r\nexport * from \"./MSFT_sRGBFactors\";","import { BaseTexture, Nullable, RawCubeTexture, Quaternion, Matrix, SphericalHarmonics, SphericalPolynomial, Scalar } from \"babylonjs\";\r\nimport { IChildRootProperty } from \"babylonjs-gltf2interface\";\r\nimport { ISceneV2 } from \"../glTFLoaderInterfaces\";\r\nimport { IGLTFLoaderExtensionV2 } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoaderV2, ArrayItem } from \"../glTFLoader\";\r\n\r\nconst NAME = \"EXT_lights_image_based\";\r\n\r\ninterface ILightReference {\r\n    light: number;\r\n}\r\n\r\ninterface ILight extends IChildRootProperty {\r\n    intensity: number;\r\n    rotation: number[];\r\n    specularImageSize: number;\r\n    specularImages: number[][];\r\n    irradianceCoefficients: number[][];\r\n\r\n    _babylonTexture?: BaseTexture;\r\n    _loaded?: Promise<void>;\r\n}\r\n\r\ninterface ILights {\r\n    lights: ILight[];\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/eb3e32332042e04691a5f35103f8c261e50d8f1e/extensions/2.0/Khronos/EXT_lights_image_based/README.md) (Experimental)\r\n */\r\nexport class EXT_lights_image_based implements IGLTFLoaderExtensionV2 {\r\n    /** The name of this extension. */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled. */\r\n    public enabled = true;\r\n\r\n    private _loader: GLTFLoaderV2;\r\n    private _lights?: ILight[];\r\n\r\n    /** @hidden */\r\n    constructor(loader: GLTFLoaderV2) {\r\n        this._loader = loader;\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose() {\r\n        delete this._loader;\r\n        delete this._lights;\r\n    }\r\n\r\n    /** @hidden */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as ILights;\r\n            this._lights = extension.lights;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public loadSceneAsync(context: string, scene: ISceneV2): Nullable<Promise<void>> {\r\n        return GLTFLoaderV2.LoadExtensionAsync<ILightReference>(context, scene, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            promises.push(this._loader.loadSceneAsync(context, scene));\r\n\r\n            this._loader.logOpen(`${extensionContext}`);\r\n\r\n            const light = ArrayItem.Get(`${extensionContext}/light`, this._lights, extension.light);\r\n            promises.push(this._loadLightAsync(`#/extensions/${this.name}/lights/${extension.light}`, light).then((texture) => {\r\n                this._loader.babylonScene.environmentTexture = texture;\r\n            }));\r\n\r\n            this._loader.logClose();\r\n\r\n            return Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    private _loadLightAsync(context: string, light: ILight): Promise<BaseTexture> {\r\n        if (!light._loaded) {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            this._loader.logOpen(`${context}`);\r\n\r\n            const imageData = new Array<Array<ArrayBufferView>>(light.specularImages.length);\r\n            for (let mipmap = 0; mipmap < light.specularImages.length; mipmap++) {\r\n                const faces = light.specularImages[mipmap];\r\n                imageData[mipmap] = new Array<ArrayBufferView>(faces.length);\r\n                for (let face = 0; face < faces.length; face++) {\r\n                    const specularImageContext = `${context}/specularImages/${mipmap}/${face}`;\r\n                    this._loader.logOpen(`${specularImageContext}`);\r\n\r\n                    const index = faces[face];\r\n                    const image = ArrayItem.Get(specularImageContext, this._loader.gltf.images, index);\r\n                    promises.push(this._loader.loadImageAsync(`#/images/${index}`, image).then((data) => {\r\n                        imageData[mipmap][face] = data;\r\n                    }));\r\n\r\n                    this._loader.logClose();\r\n                }\r\n            }\r\n\r\n            this._loader.logClose();\r\n\r\n            light._loaded = Promise.all(promises).then(() => {\r\n                const babylonTexture = new RawCubeTexture(this._loader.babylonScene, null, light.specularImageSize);\r\n                light._babylonTexture = babylonTexture;\r\n\r\n                if (light.intensity != undefined) {\r\n                    babylonTexture.level = light.intensity;\r\n                }\r\n\r\n                if (light.rotation) {\r\n                    let rotation = Quaternion.FromArray(light.rotation);\r\n\r\n                    // Invert the rotation so that positive rotation is counter-clockwise.\r\n                    if (!this._loader.babylonScene.useRightHandedSystem) {\r\n                        rotation = Quaternion.Inverse(rotation);\r\n                    }\r\n\r\n                    Matrix.FromQuaternionToRef(rotation, babylonTexture.getReflectionTextureMatrix());\r\n                }\r\n\r\n                const sphericalHarmonics = SphericalHarmonics.FromArray(light.irradianceCoefficients);\r\n                sphericalHarmonics.scale(light.intensity);\r\n\r\n                sphericalHarmonics.convertIrradianceToLambertianRadiance();\r\n                const sphericalPolynomial = SphericalPolynomial.FromHarmonics(sphericalHarmonics);\r\n\r\n                // Compute the lod generation scale to fit exactly to the number of levels available.\r\n                const lodGenerationScale = (imageData.length - 1) / Scalar.Log2(light.specularImageSize);\r\n                return babylonTexture.updateRGBDAsync(imageData, sphericalPolynomial, lodGenerationScale);\r\n            });\r\n        }\r\n\r\n        return light._loaded.then(() => {\r\n            return light._babylonTexture!;\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoaderV2.RegisterExtension(NAME, (loader) => new EXT_lights_image_based(loader));","import { Geometry, DracoCompression, Mesh, Nullable, VertexBuffer } from \"babylonjs\";\r\nimport { MeshPrimitiveMode } from \"babylonjs-gltf2interface\";\r\nimport { IBufferViewV2, IMeshPrimitiveV2 } from \"../glTFLoaderInterfaces\";\r\nimport { IGLTFLoaderExtensionV2 } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoaderV2, ArrayItem } from \"../glTFLoader\";\r\n\r\nconst NAME = \"KHR_draco_mesh_compression\";\r\n\r\ninterface IKHRDracoMeshCompression {\r\n    bufferView: number;\r\n    attributes: { [name: string]: number };\r\n}\r\n\r\ninterface IBufferViewDraco extends IBufferViewV2 {\r\n    _dracoBabylonGeometry?: Promise<Geometry>;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression)\r\n */\r\nexport class KHR_draco_mesh_compression implements IGLTFLoaderExtensionV2 {\r\n    /** The name of this extension. */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled. */\r\n    public enabled = DracoCompression.DecoderAvailable;\r\n\r\n    private _loader: GLTFLoaderV2;\r\n    private _dracoCompression?: DracoCompression;\r\n\r\n    /** @hidden */\r\n    constructor(loader: GLTFLoaderV2) {\r\n        this._loader = loader;\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose(): void {\r\n        if (this._dracoCompression) {\r\n            this._dracoCompression.dispose();\r\n            delete this._dracoCompression;\r\n        }\r\n\r\n        delete this._loader;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _loadVertexDataAsync(context: string, primitive: IMeshPrimitiveV2, babylonMesh: Mesh): Nullable<Promise<Geometry>> {\r\n        return GLTFLoaderV2.LoadExtensionAsync<IKHRDracoMeshCompression, Geometry>(context, primitive, this.name, (extensionContext, extension) => {\r\n            if (primitive.mode != undefined) {\r\n                if (primitive.mode !== MeshPrimitiveMode.TRIANGLE_STRIP &&\r\n                    primitive.mode !== MeshPrimitiveMode.TRIANGLES) {\r\n                    throw new Error(`${context}: Unsupported mode ${primitive.mode}`);\r\n                }\r\n\r\n                // TODO: handle triangle strips\r\n                if (primitive.mode === MeshPrimitiveMode.TRIANGLE_STRIP) {\r\n                    throw new Error(`${context}: Mode ${primitive.mode} is not currently supported`);\r\n                }\r\n            }\r\n\r\n            const attributes: { [kind: string]: number } = {};\r\n            const loadAttribute = (name: string, kind: string) => {\r\n                const uniqueId = extension.attributes[name];\r\n                if (uniqueId == undefined) {\r\n                    return;\r\n                }\r\n\r\n                babylonMesh._delayInfo = babylonMesh._delayInfo || [];\r\n                if (babylonMesh._delayInfo.indexOf(kind) === -1) {\r\n                    babylonMesh._delayInfo.push(kind);\r\n                }\r\n\r\n                attributes[kind] = uniqueId;\r\n            };\r\n\r\n            loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\r\n            loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\r\n            loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\r\n            loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\r\n            loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\r\n            loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\r\n            loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\r\n            loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind);\r\n\r\n            var bufferView = ArrayItem.Get(extensionContext, this._loader.gltf.bufferViews, extension.bufferView) as IBufferViewDraco;\r\n            if (!bufferView._dracoBabylonGeometry) {\r\n                bufferView._dracoBabylonGeometry = this._loader.loadBufferViewAsync(`#/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n                    if (!this._dracoCompression) {\r\n                        this._dracoCompression = new DracoCompression();\r\n                    }\r\n\r\n                    return this._dracoCompression.decodeMeshAsync(data, attributes).then((babylonVertexData) => {\r\n                        const babylonGeometry = new Geometry(babylonMesh.name, this._loader.babylonScene);\r\n                        babylonVertexData.applyToGeometry(babylonGeometry);\r\n                        return babylonGeometry;\r\n                    }).catch((error) => {\r\n                        throw new Error(`${context}: ${error.message}`);\r\n                    });\r\n                });\r\n            }\r\n\r\n            return bufferView._dracoBabylonGeometry;\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoaderV2.RegisterExtension(NAME, (loader) => new KHR_draco_mesh_compression(loader));","import { Mesh, Nullable, Light, DirectionalLight, Vector3, PointLight, SpotLight, Color3 } from \"babylonjs\";\nimport { IChildRootProperty } from \"babylonjs-gltf2interface\";\nimport { INodeV2 } from \"../glTFLoaderInterfaces\";\nimport { IGLTFLoaderExtensionV2 } from \"../glTFLoaderExtension\";\nimport { GLTFLoaderV2, ArrayItem } from \"../glTFLoader\";\n\nconst NAME = \"KHR_lights_punctual\";\n\nenum LightType {\n    DIRECTIONAL = \"directional\",\n    POINT = \"point\",\n    SPOT = \"spot\"\n}\n\ninterface ILightReference {\n    light: number;\n}\n\ninterface ILight extends IChildRootProperty {\n    type: LightType;\n    color?: number[];\n    intensity?: number;\n    range?: number;\n    spot?: {\n        innerConeAngle?: number;\n        outerConeAngle?: number;\n    };\n}\n\ninterface ILights {\n    lights: ILight[];\n}\n\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/1048d162a44dbcb05aefc1874bfd423cf60135a6/extensions/2.0/Khronos/KHR_lights_punctual/README.md) (Experimental)\n */\nexport class KHR_lights implements IGLTFLoaderExtensionV2 {\n    /** The name of this extension. */\n    public readonly name = NAME;\n\n    /** Defines whether this extension is enabled. */\n    public enabled = true;\n\n    private _loader: GLTFLoaderV2;\n    private _lights?: ILight[];\n\n    /** @hidden */\n    constructor(loader: GLTFLoaderV2) {\n        this._loader = loader;\n    }\n\n    /** @hidden */\n    public dispose() {\n        delete this._loader;\n        delete this._lights;\n    }\n\n    /** @hidden */\n    public onLoading(): void {\n        const extensions = this._loader.gltf.extensions;\n        if (extensions && extensions[this.name]) {\n            const extension = extensions[this.name] as ILights;\n            this._lights = extension.lights;\n        }\n    }\n\n    /** @hidden */\n    public loadNodeAsync(context: string, node: INodeV2, assign: (babylonMesh: Mesh) => void): Nullable<Promise<Mesh>> {\n        return GLTFLoaderV2.LoadExtensionAsync<ILightReference, Mesh>(context, node, this.name, (extensionContext, extension) => {\n            return this._loader.loadNodeAsync(context, node, (babylonMesh) => {\n                let babylonLight: Light;\n\n                const light = ArrayItem.Get(extensionContext, this._lights, extension.light);\n                const name = light.name || babylonMesh.name;\n\n                switch (light.type) {\n                    case LightType.DIRECTIONAL: {\n                        babylonLight = new DirectionalLight(name, Vector3.Backward(), this._loader.babylonScene);\n                        break;\n                    }\n                    case LightType.POINT: {\n                        babylonLight = new PointLight(name, Vector3.Zero(), this._loader.babylonScene);\n                        break;\n                    }\n                    case LightType.SPOT: {\n                        const babylonSpotLight = new SpotLight(name, Vector3.Zero(), Vector3.Backward(), 0, 1, this._loader.babylonScene);\n                        babylonSpotLight.angle = ((light.spot && light.spot.outerConeAngle) || Math.PI / 4) * 2;\n                        babylonSpotLight.innerAngle = ((light.spot && light.spot.innerConeAngle) || 0) * 2;\n                        babylonLight = babylonSpotLight;\n                        break;\n                    }\n                    default: {\n                        throw new Error(`${extensionContext}: Invalid light type (${light.type})`);\n                    }\n                }\n\n                babylonLight.falloffType = Light.FALLOFF_GLTF;\n                babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();\n                babylonLight.intensity = light.intensity == undefined ? 1 : light.intensity;\n                babylonLight.range = light.range == undefined ? Number.MAX_VALUE : light.range;\n                babylonLight.parent = babylonMesh;\n\n                assign(babylonMesh);\n            });\n        });\n    }\n}\n\nGLTFLoaderV2.RegisterExtension(NAME, (loader) => new KHR_lights(loader));","import { Material, Nullable, PBRMaterial, Color3 } from \"babylonjs\";\nimport { ITextureInfoV2, IMaterialV2 } from \"../glTFLoaderInterfaces\";\nimport { IGLTFLoaderExtensionV2 } from \"../glTFLoaderExtension\";\nimport { GLTFLoaderV2 } from \"../glTFLoader\";\n\nconst NAME = \"KHR_materials_pbrSpecularGlossiness\";\n\ninterface IKHRMaterialsPbrSpecularGlossiness {\n    diffuseFactor: number[];\n    diffuseTexture: ITextureInfoV2;\n    specularFactor: number[];\n    glossinessFactor: number;\n    specularGlossinessTexture: ITextureInfoV2;\n}\n\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness)\n */\nexport class KHR_materials_pbrSpecularGlossiness implements IGLTFLoaderExtensionV2 {\n    /** The name of this extension. */\n    public readonly name = NAME;\n\n    /** Defines whether this extension is enabled. */\n    public enabled = true;\n\n    private _loader: GLTFLoaderV2;\n\n    /** @hidden */\n    constructor(loader: GLTFLoaderV2) {\n        this._loader = loader;\n    }\n\n    /** @hidden */\n    public dispose() {\n        delete this._loader;\n    }\n\n    /** @hidden */\n    public loadMaterialPropertiesAsync(context: string, material: IMaterialV2, babylonMaterial: Material): Nullable<Promise<void>> {\n        return GLTFLoaderV2.LoadExtensionAsync<IKHRMaterialsPbrSpecularGlossiness>(context, material, this.name, (extensionContext, extension) => {\n            const promises = new Array<Promise<any>>();\n            promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\n            promises.push(this._loadSpecularGlossinessPropertiesAsync(extensionContext, material, extension, babylonMaterial));\n            this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);\n            return Promise.all(promises).then(() => {});\n        });\n    }\n\n    private _loadSpecularGlossinessPropertiesAsync(context: string, material: IMaterialV2, properties: IKHRMaterialsPbrSpecularGlossiness, babylonMaterial: Material): Promise<void> {\n        if (!(babylonMaterial instanceof PBRMaterial)) {\n            throw new Error(`${context}: Material type not supported`);\n        }\n\n        const promises = new Array<Promise<any>>();\n\n        babylonMaterial.metallic = null;\n        babylonMaterial.roughness = null;\n\n        if (properties.diffuseFactor) {\n            babylonMaterial.albedoColor = Color3.FromArray(properties.diffuseFactor);\n            babylonMaterial.alpha = properties.diffuseFactor[3];\n        }\n        else {\n            babylonMaterial.albedoColor = Color3.White();\n        }\n\n        babylonMaterial.reflectivityColor = properties.specularFactor ? Color3.FromArray(properties.specularFactor) : Color3.White();\n        babylonMaterial.microSurface = properties.glossinessFactor == undefined ? 1 : properties.glossinessFactor;\n\n        if (properties.diffuseTexture) {\n            promises.push(this._loader.loadTextureInfoAsync(`${context}/diffuseTexture`, properties.diffuseTexture, (texture) => {\n                babylonMaterial.albedoTexture = texture;\n                return Promise.resolve();\n            }));\n        }\n\n        if (properties.specularGlossinessTexture) {\n            promises.push(this._loader.loadTextureInfoAsync(`${context}/specularGlossinessTexture`, properties.specularGlossinessTexture, (texture) => {\n                babylonMaterial.reflectivityTexture = texture;\n                return Promise.resolve();\n            }));\n\n            babylonMaterial.reflectivityTexture.hasAlpha = true;\n            babylonMaterial.useMicroSurfaceFromReflectivityMapAlpha = true;\n        }\n\n        return Promise.all(promises).then(() => {});\n    }\n}\n\nGLTFLoaderV2.RegisterExtension(NAME, (loader) => new KHR_materials_pbrSpecularGlossiness(loader));","import { Material, Nullable, PBRMaterial, Color3 } from \"babylonjs\";\r\nimport { IMaterialV2 } from \"../glTFLoaderInterfaces\";\r\nimport { IGLTFLoaderExtensionV2 } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoaderV2 } from \"../glTFLoader\";\r\n\r\nconst NAME = \"KHR_materials_unlit\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit)\r\n */\r\nexport class KHR_materials_unlit implements IGLTFLoaderExtensionV2 {\r\n    /** The name of this extension. */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled. */\r\n    public enabled = true;\r\n\r\n    private _loader: GLTFLoaderV2;\r\n\r\n    /** @hidden */\r\n    constructor(loader: GLTFLoaderV2) {\r\n        this._loader = loader;\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose() {\r\n        delete this._loader;\r\n    }\r\n\r\n    /** @hidden */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterialV2, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoaderV2.LoadExtensionAsync(context, material, this.name, () => {\r\n            return this._loadUnlitPropertiesAsync(context, material, babylonMaterial);\r\n        });\r\n    }\r\n\r\n    private _loadUnlitPropertiesAsync(context: string, material: IMaterialV2, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        babylonMaterial.unlit = true;\r\n\r\n        const properties = material.pbrMetallicRoughness;\r\n        if (properties) {\r\n            if (properties.baseColorFactor) {\r\n                babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);\r\n                babylonMaterial.alpha = properties.baseColorFactor[3];\r\n            }\r\n            else {\r\n                babylonMaterial.albedoColor = Color3.White();\r\n            }\r\n\r\n            if (properties.baseColorTexture) {\r\n                promises.push(this._loader.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {\r\n                    babylonMaterial.albedoTexture = texture;\r\n                    return Promise.resolve();\r\n                }));\r\n            }\r\n        }\r\n\r\n        if (material.doubleSided) {\r\n            babylonMaterial.backFaceCulling = false;\r\n            babylonMaterial.twoSidedLighting = true;\r\n        }\r\n\r\n        this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nGLTFLoaderV2.RegisterExtension(NAME, (loader) => new KHR_materials_unlit(loader));","import { BaseTexture, Nullable, Texture } from \"babylonjs\";\r\nimport { ITextureInfoV2 } from \"../glTFLoaderInterfaces\";\r\nimport { IGLTFLoaderExtensionV2 } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoaderV2 } from \"../glTFLoader\";\r\n\r\nconst NAME = \"KHR_texture_transform\";\r\n\r\ninterface IKHRTextureTransform {\r\n    offset?: number[];\r\n    rotation?: number;\r\n    scale?: number[];\r\n    texCoord?: number;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_transform/README.md)\r\n */\r\nexport class KHR_texture_transform implements IGLTFLoaderExtensionV2 {\r\n    /** The name of this extension. */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled. */\r\n    public enabled = true;\r\n\r\n    private _loader: GLTFLoaderV2;\r\n\r\n    /** @hidden */\r\n    constructor(loader: GLTFLoaderV2) {\r\n        this._loader = loader;\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose() {\r\n        delete this._loader;\r\n    }\r\n\r\n    /** @hidden */\r\n    public loadTextureInfoAsync(context: string, textureInfo: ITextureInfoV2, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return GLTFLoaderV2.LoadExtensionAsync<IKHRTextureTransform, BaseTexture>(context, textureInfo, this.name, (extensionContext, extension) => {\r\n            return this._loader.loadTextureInfoAsync(context, textureInfo, (babylonTexture) => {\r\n                if (!(babylonTexture instanceof Texture)) {\r\n                    throw new Error(`${extensionContext}: Texture type not supported`);\r\n                }\r\n\r\n                if (extension.offset) {\r\n                    babylonTexture.uOffset = extension.offset[0];\r\n                    babylonTexture.vOffset = extension.offset[1];\r\n                }\r\n\r\n                // Always rotate around the origin.\r\n                babylonTexture.uRotationCenter = 0;\r\n                babylonTexture.vRotationCenter = 0;\r\n\r\n                if (extension.rotation) {\r\n                    babylonTexture.wAng = -extension.rotation;\r\n                }\r\n\r\n                if (extension.scale) {\r\n                    babylonTexture.uScale = extension.scale[0];\r\n                    babylonTexture.vScale = extension.scale[1];\r\n                }\r\n\r\n                if (extension.texCoord != undefined) {\r\n                    babylonTexture.coordinatesIndex = extension.texCoord;\r\n                }\r\n\r\n                assign(babylonTexture);\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoaderV2.RegisterExtension(NAME, (loader) => new KHR_texture_transform(loader));","import { WeightedSound, Sound, Nullable, Mesh, Vector3, Tools, AnimationGroup, AnimationEvent } from \"babylonjs\";\nimport { IArrayItemV2, ISceneV2, INodeV2, IAnimationV2 } from \"../glTFLoaderInterfaces\";\nimport { IGLTFLoaderExtensionV2 } from \"../glTFLoaderExtension\";\nimport { GLTFLoaderV2, ArrayItem } from \"../glTFLoader\";\n\nconst NAME = \"MSFT_audio_emitter\";\n\ninterface IClipReference {\n    clip: number;\n    weight?: number;\n}\n\ninterface IEmittersReference {\n    emitters: number[];\n}\n\nconst enum DistanceModel {\n    linear = \"linear\",\n    inverse = \"inverse\",\n    exponential = \"exponential\",\n}\n\ninterface IEmitter {\n    name?: string;\n    distanceModel?: DistanceModel;\n    refDistance?: number;\n    maxDistance?: number;\n    rolloffFactor?: number;\n    innerAngle?: number;\n    outerAngle?: number;\n    loop?: boolean;\n    volume?: number;\n    clips: IClipReference[];\n}\n\nconst enum AudioMimeType {\n    WAV = \"audio/wav\",\n}\n\ninterface IClip {\n    uri?: string;\n    bufferView?: number;\n    mimeType?: AudioMimeType;\n}\n\ninterface ILoaderClip extends IClip, IArrayItemV2 {\n    _objectURL?: Promise<string>;\n}\n\ninterface ILoaderEmitter extends IEmitter, IArrayItemV2 {\n    _babylonData?: {\n        sound?: WeightedSound;\n        loaded: Promise<void>;\n    };\n    _babylonSounds: Sound[];\n}\n\ninterface IMSFTAudioEmitter {\n    clips: ILoaderClip[];\n    emitters: ILoaderEmitter[];\n}\n\nconst enum AnimationEventAction {\n    play = \"play\",\n    pause = \"pause\",\n    stop = \"stop\",\n}\n\ninterface IAnimationEvent {\n    action: AnimationEventAction;\n    emitter: number;\n    time: number;\n    startOffset?: number;\n}\n\ninterface ILoaderAnimationEvent extends IAnimationEvent, IArrayItemV2 {\n}\n\ninterface ILoaderAnimationEvents {\n    events: ILoaderAnimationEvent[];\n}\n\n/**\n * [Specification](https://github.com/najadojo/glTF/tree/MSFT_audio_emitter/extensions/2.0/Vendor/MSFT_audio_emitter)\n */\nexport class MSFT_audio_emitter implements IGLTFLoaderExtensionV2 {\n    /** The name of this extension. */\n    public readonly name = NAME;\n\n    /** Defines whether this extension is enabled. */\n    public enabled = true;\n\n    private _loader: GLTFLoaderV2;\n    private _clips: Array<ILoaderClip>;\n    private _emitters: Array<ILoaderEmitter>;\n\n    /** @hidden */\n    constructor(loader: GLTFLoaderV2) {\n        this._loader = loader;\n    }\n\n    /** @hidden */\n    public dispose() {\n        delete this._loader;\n        delete this._clips;\n        delete this._emitters;\n    }\n\n    /** @hidden */\n    public onLoading(): void {\n        const extensions = this._loader.gltf.extensions;\n        if (extensions && extensions[this.name]) {\n            const extension = extensions[this.name] as IMSFTAudioEmitter;\n\n            this._clips = extension.clips;\n            this._emitters = extension.emitters;\n\n            ArrayItem.Assign(this._clips);\n            ArrayItem.Assign(this._emitters);\n        }\n    }\n\n    /** @hidden */\n    public loadSceneAsync(context: string, scene: ISceneV2): Nullable<Promise<void>> {\n        return GLTFLoaderV2.LoadExtensionAsync<IEmittersReference>(context, scene, this.name, (extensionContext, extension) => {\n            const promises = new Array<Promise<any>>();\n\n            promises.push(this._loader.loadSceneAsync(context, scene));\n\n            for (const emitterIndex of extension.emitters) {\n                const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\n                if (emitter.refDistance != undefined || emitter.maxDistance != undefined || emitter.rolloffFactor != undefined ||\n                    emitter.distanceModel != undefined || emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\n                    throw new Error(`${extensionContext}: Direction or Distance properties are not allowed on emitters attached to a scene`);\n                }\n\n                promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter));\n            }\n\n            return Promise.all(promises).then(() => {});\n        });\n    }\n\n    /** @hidden */\n    public loadNodeAsync(context: string, node: INodeV2, assign: (babylonMesh: Mesh) => void): Nullable<Promise<Mesh>> {\n        return GLTFLoaderV2.LoadExtensionAsync<IEmittersReference, Mesh>(context, node, this.name, (extensionContext, extension) => {\n            const promises = new Array<Promise<any>>();\n\n            return this._loader.loadNodeAsync(extensionContext, node, (babylonMesh) => {\n                for (const emitterIndex of extension.emitters) {\n                    const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\n                    promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter).then(() => {\n                        for (const sound of emitter._babylonSounds) {\n                            sound.attachToMesh(babylonMesh);\n                            if (emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\n                                sound.setLocalDirectionToMesh(Vector3.Forward());\n                                sound.setDirectionalCone(\n                                    2 * Tools.ToDegrees(emitter.innerAngle == undefined ? Math.PI : emitter.innerAngle),\n                                    2 * Tools.ToDegrees(emitter.outerAngle == undefined ? Math.PI : emitter.outerAngle),\n                                    0);\n                            }\n                        }\n                    }));\n                }\n\n                assign(babylonMesh);\n            }).then((babylonMesh) => {\n                return Promise.all(promises).then(() => {\n                    return babylonMesh;\n                });\n            });\n        });\n    }\n\n    /** @hidden */\n    public loadAnimationAsync(context: string, animation: IAnimationV2): Nullable<Promise<AnimationGroup>> {\n        return GLTFLoaderV2.LoadExtensionAsync<ILoaderAnimationEvents, AnimationGroup>(context, animation, this.name, (extensionContext, extension) => {\n            return this._loader.loadAnimationAsync(context, animation).then((babylonAnimationGroup) => {\n                const promises = new Array<Promise<any>>();\n\n                ArrayItem.Assign(extension.events);\n                for (const event of extension.events) {\n                    promises.push(this._loadAnimationEventAsync(`${extensionContext}/events/${event.index}`, context, animation, event, babylonAnimationGroup));\n                }\n\n                return Promise.all(promises).then(() => {\n                    return babylonAnimationGroup;\n                });\n            });\n        });\n    }\n\n    private _loadClipAsync(context: string, clip: ILoaderClip): Promise<string> {\n        if (clip._objectURL) {\n            return clip._objectURL;\n        }\n\n        let promise: Promise<ArrayBufferView>;\n        if (clip.uri) {\n            promise = this._loader.loadUriAsync(context, clip.uri);\n        }\n        else {\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._loader.gltf.bufferViews, clip.bufferView);\n            promise = this._loader.loadBufferViewAsync(`#/bufferViews/${bufferView.index}`, bufferView);\n        }\n\n        clip._objectURL = promise.then((data) => {\n            return URL.createObjectURL(new Blob([data], { type: clip.mimeType }));\n        });\n\n        return clip._objectURL;\n    }\n\n    private _loadEmitterAsync(context: string, emitter: ILoaderEmitter): Promise<void> {\n        emitter._babylonSounds = emitter._babylonSounds || [];\n        if (!emitter._babylonData) {\n            const clipPromises = new Array<Promise<any>>();\n            const name = emitter.name || `emitter${emitter.index}`;\n            const options = {\n                loop: false,\n                autoplay: false,\n                volume: emitter.volume == undefined ? 1 : emitter.volume,\n            };\n\n            for (let i = 0; i < emitter.clips.length; i++) {\n                const clipContext = `#/extensions/${this.name}/clips`;\n                const clip = ArrayItem.Get(clipContext, this._clips, emitter.clips[i].clip);\n                clipPromises.push(this._loadClipAsync(`${clipContext}/${emitter.clips[i].clip}`, clip).then((objectURL: string) => {\n                    const sound = emitter._babylonSounds[i] = new Sound(name, objectURL, this._loader.babylonScene, null, options);\n                    sound.refDistance = emitter.refDistance || 1;\n                    sound.maxDistance = emitter.maxDistance || 256;\n                    sound.rolloffFactor = emitter.rolloffFactor || 1;\n                    sound.distanceModel = emitter.distanceModel || 'exponential';\n                    sound._positionInEmitterSpace = true;\n                }));\n            }\n\n            const promise = Promise.all(clipPromises).then(() => {\n                const weights = emitter.clips.map((clip) => { return clip.weight || 1; });\n                const weightedSound = new WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);\n                if (emitter.innerAngle) { weightedSound.directionalConeInnerAngle = 2 * Tools.ToDegrees(emitter.innerAngle); }\n                if (emitter.outerAngle) { weightedSound.directionalConeOuterAngle = 2 * Tools.ToDegrees(emitter.outerAngle); }\n                if (emitter.volume) { weightedSound.volume = emitter.volume; }\n                emitter._babylonData!.sound = weightedSound;\n            });\n\n            emitter._babylonData = {\n                loaded: promise\n            };\n        }\n\n        return emitter._babylonData.loaded;\n    }\n\n    private _getEventAction(context: string, sound: WeightedSound, action: AnimationEventAction, time: number, startOffset?: number): (currentFrame: number) => void {\n        switch (action) {\n            case AnimationEventAction.play: {\n                return (currentFrame: number) => {\n                    const frameOffset = (startOffset || 0) + (currentFrame - time);\n                    sound.play(frameOffset);\n                };\n            }\n            case AnimationEventAction.stop: {\n                return (currentFrame: number) => {\n                    sound.stop();\n                };\n            }\n            case AnimationEventAction.pause: {\n                return (currentFrame: number) => {\n                    sound.pause();\n                };\n            }\n            default: {\n                throw new Error(`${context}: Unsupported action ${action}`);\n            }\n        }\n    }\n\n    private _loadAnimationEventAsync(context: string, animationContext: string, animation: IAnimationV2, event: ILoaderAnimationEvent, babylonAnimationGroup: AnimationGroup): Promise<void> {\n        if (babylonAnimationGroup.targetedAnimations.length == 0) {\n            return Promise.resolve();\n        }\n        const babylonAnimation = babylonAnimationGroup.targetedAnimations[0];\n        const emitterIndex = event.emitter;\n        const emitter = ArrayItem.Get(`#/extensions/${this.name}/emitters`, this._emitters, emitterIndex);\n        return this._loadEmitterAsync(context, emitter).then(() => {\n            const sound = emitter._babylonData!.sound;\n            if (sound) {\n                var babylonAnimationEvent = new AnimationEvent(event.time, this._getEventAction(context, sound, event.action, event.time, event.startOffset));\n                babylonAnimation.animation.addEvent(babylonAnimationEvent);\n                // Make sure all started audio stops when this animation is terminated.\n                babylonAnimationGroup.onAnimationGroupEndObservable.add(() => {\n                    sound.stop();\n                });\n                babylonAnimationGroup.onAnimationGroupPauseObservable.add(() => {\n                    sound.pause();\n                });\n            }\n        });\n    }\n}\n\nGLTFLoaderV2.RegisterExtension(NAME, (loader) => new MSFT_audio_emitter(loader));","import { Observable, Nullable, Deferred, Mesh, Material } from \"babylonjs\";\nimport { INodeV2, IMaterialV2 } from \"../glTFLoaderInterfaces\";\nimport { IGLTFLoaderExtensionV2 } from \"../glTFLoaderExtension\";\nimport { GLTFLoaderV2, ArrayItem } from \"../glTFLoader\";\n\nconst NAME = \"MSFT_lod\";\n\ninterface IMSFTLOD {\n    ids: number[];\n}\n\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_lod)\n */\nexport class MSFT_lod implements IGLTFLoaderExtensionV2 {\n    /** The name of this extension. */\n    public readonly name = NAME;\n\n    /** Defines whether this extension is enabled. */\n    public enabled = true;\n\n    /**\n     * Maximum number of LODs to load, starting from the lowest LOD.\n     */\n    public maxLODsToLoad = Number.MAX_VALUE;\n\n    /**\n     * Observable raised when all node LODs of one level are loaded.\n     * The event data is the index of the loaded LOD starting from zero.\n     * Dispose the loader to cancel the loading of the next level of LODs.\n     */\n    public onNodeLODsLoadedObservable = new Observable<number>();\n\n    /**\n     * Observable raised when all material LODs of one level are loaded.\n     * The event data is the index of the loaded LOD starting from zero.\n     * Dispose the loader to cancel the loading of the next level of LODs.\n     */\n    public onMaterialLODsLoadedObservable = new Observable<number>();\n\n    private _loader: GLTFLoaderV2;\n\n    private _nodeIndexLOD: Nullable<number> = null;\n    private _nodeSignalLODs = new Array<Deferred<void>>();\n    private _nodePromiseLODs = new Array<Array<Promise<any>>>();\n\n    private _materialIndexLOD: Nullable<number> = null;\n    private _materialSignalLODs = new Array<Deferred<void>>();\n    private _materialPromiseLODs = new Array<Array<Promise<any>>>();\n\n    /** @hidden */\n    constructor(loader: GLTFLoaderV2) {\n        this._loader = loader;\n    }\n\n    /** @hidden */\n    public dispose() {\n        delete this._loader;\n\n        this._nodeIndexLOD = null;\n        this._nodeSignalLODs.length = 0;\n        this._nodePromiseLODs.length = 0;\n\n        this._materialIndexLOD = null;\n        this._materialSignalLODs.length = 0;\n        this._materialPromiseLODs.length = 0;\n\n        this.onMaterialLODsLoadedObservable.clear();\n        this.onNodeLODsLoadedObservable.clear();\n    }\n\n    /** @hidden */\n    public onReady(): void {\n        for (let indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {\n            const promise = Promise.all(this._nodePromiseLODs[indexLOD]).then(() => {\n                if (indexLOD !== 0) {\n                    this._loader.endPerformanceCounter(`Node LOD ${indexLOD}`);\n                }\n\n                this._loader.log(`Loaded node LOD ${indexLOD}`);\n                this.onNodeLODsLoadedObservable.notifyObservers(indexLOD);\n\n                if (indexLOD !== this._nodePromiseLODs.length - 1) {\n                    this._loader.startPerformanceCounter(`Node LOD ${indexLOD + 1}`);\n                    if (this._nodeSignalLODs[indexLOD]) {\n                        this._nodeSignalLODs[indexLOD].resolve();\n                    }\n                }\n            });\n\n            this._loader._completePromises.push(promise);\n        }\n\n        for (let indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {\n            const promise = Promise.all(this._materialPromiseLODs[indexLOD]).then(() => {\n                if (indexLOD !== 0) {\n                    this._loader.endPerformanceCounter(`Material LOD ${indexLOD}`);\n                }\n\n                this._loader.log(`Loaded material LOD ${indexLOD}`);\n                this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD);\n\n                if (indexLOD !== this._materialPromiseLODs.length - 1) {\n                    this._loader.startPerformanceCounter(`Material LOD ${indexLOD + 1}`);\n                    if (this._materialSignalLODs[indexLOD]) {\n                        this._materialSignalLODs[indexLOD].resolve();\n                    }\n                }\n            });\n\n            this._loader._completePromises.push(promise);\n        }\n    }\n\n    /** @hidden */\n    public loadNodeAsync(context: string, node: INodeV2, assign: (babylonMesh: Mesh) => void): Nullable<Promise<Mesh>> {\n        return GLTFLoaderV2.LoadExtensionAsync<IMSFTLOD, Mesh>(context, node, this.name, (extensionContext, extension) => {\n            let firstPromise: Promise<Mesh>;\n\n            const nodeLODs = this._getLODs(extensionContext, node, this._loader.gltf.nodes, extension.ids);\n            this._loader.logOpen(`${extensionContext}`);\n\n            for (let indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {\n                const nodeLOD = nodeLODs[indexLOD];\n\n                if (indexLOD !== 0) {\n                    this._nodeIndexLOD = indexLOD;\n                    this._nodeSignalLODs[indexLOD] = this._nodeSignalLODs[indexLOD] || new Deferred();\n                }\n\n                const promise = this._loader.loadNodeAsync(`#/nodes/${nodeLOD.index}`, nodeLOD).then((babylonMesh) => {\n                    if (indexLOD !== 0) {\n                        // TODO: should not rely on _babylonMesh\n                        const previousNodeLOD = nodeLODs[indexLOD - 1];\n                        if (previousNodeLOD._babylonMesh) {\n                            previousNodeLOD._babylonMesh.dispose();\n                            delete previousNodeLOD._babylonMesh;\n                            this._disposeUnusedMaterials();\n                        }\n                    }\n\n                    return babylonMesh;\n                });\n\n                if (indexLOD === 0) {\n                    firstPromise = promise;\n                }\n                else {\n                    this._nodeIndexLOD = null;\n                }\n\n                this._nodePromiseLODs[indexLOD] = this._nodePromiseLODs[indexLOD] || [];\n                this._nodePromiseLODs[indexLOD].push(promise);\n            }\n\n            this._loader.logClose();\n            return firstPromise!;\n        });\n    }\n\n    /** @hidden */\n    public _loadMaterialAsync(context: string, material: IMaterialV2, babylonMesh: Mesh, babylonDrawMode: number, assign: (babylonMaterial: Material) => void): Nullable<Promise<Material>> {\n        // Don't load material LODs if already loading a node LOD.\n        if (this._nodeIndexLOD) {\n            return null;\n        }\n\n        return GLTFLoaderV2.LoadExtensionAsync<IMSFTLOD, Material>(context, material, this.name, (extensionContext, extension) => {\n            let firstPromise: Promise<Material>;\n\n            const materialLODs = this._getLODs(extensionContext, material, this._loader.gltf.materials, extension.ids);\n            this._loader.logOpen(`${extensionContext}`);\n\n            for (let indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {\n                const materialLOD = materialLODs[indexLOD];\n\n                if (indexLOD !== 0) {\n                    this._materialIndexLOD = indexLOD;\n                }\n\n                const promise = this._loader._loadMaterialAsync(`#/materials/${materialLOD.index}`, materialLOD, babylonMesh, babylonDrawMode, (babylonMaterial) => {\n                    if (indexLOD === 0) {\n                        assign(babylonMaterial);\n                    }\n                }).then((babylonMaterial) => {\n                    if (indexLOD !== 0) {\n                        assign(babylonMaterial);\n\n                        // TODO: should not rely on _babylonData\n                        const previousBabylonDataLOD = materialLODs[indexLOD - 1]._babylonData!;\n                        if (previousBabylonDataLOD[babylonDrawMode]) {\n                            previousBabylonDataLOD[babylonDrawMode].material.dispose();\n                            delete previousBabylonDataLOD[babylonDrawMode];\n                        }\n                    }\n\n                    return babylonMaterial;\n                });\n\n                if (indexLOD === 0) {\n                    firstPromise = promise;\n                }\n                else {\n                    this._materialIndexLOD = null;\n                }\n\n                this._materialPromiseLODs[indexLOD] = this._materialPromiseLODs[indexLOD] || [];\n                this._materialPromiseLODs[indexLOD].push(promise);\n            }\n\n            this._loader.logClose();\n            return firstPromise!;\n        });\n    }\n\n    /** @hidden */\n    public _loadUriAsync(context: string, uri: string): Nullable<Promise<ArrayBufferView>> {\n        // Defer the loading of uris if loading a material or node LOD.\n        if (this._materialIndexLOD !== null) {\n            this._loader.log(`deferred`);\n            const previousIndexLOD = this._materialIndexLOD - 1;\n            this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new Deferred<void>();\n            return this._materialSignalLODs[previousIndexLOD].promise.then(() => {\n                return this._loader.loadUriAsync(context, uri);\n            });\n        }\n        else if (this._nodeIndexLOD !== null) {\n            this._loader.log(`deferred`);\n            const previousIndexLOD = this._nodeIndexLOD - 1;\n            this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new Deferred<void>();\n            return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(() => {\n                return this._loader.loadUriAsync(context, uri);\n            });\n        }\n\n        return null;\n    }\n\n    /**\n     * Gets an array of LOD properties from lowest to highest.\n     */\n    private _getLODs<T>(context: string, property: T, array: ArrayLike<T> | undefined, ids: number[]): T[] {\n        if (this.maxLODsToLoad <= 0) {\n            throw new Error(\"maxLODsToLoad must be greater than zero\");\n        }\n\n        const properties = new Array<T>();\n\n        for (let i = ids.length - 1; i >= 0; i--) {\n            properties.push(ArrayItem.Get(`${context}/ids/${ids[i]}`, array, ids[i]));\n            if (properties.length === this.maxLODsToLoad) {\n                return properties;\n            }\n        }\n\n        properties.push(property);\n        return properties;\n    }\n\n    private _disposeUnusedMaterials(): void {\n        // TODO: should not rely on _babylonData\n        const materials = this._loader.gltf.materials;\n        if (materials) {\n            for (const material of materials) {\n                if (material._babylonData) {\n                    for (const drawMode in material._babylonData) {\n                        const babylonData = material._babylonData[drawMode];\n                        if (babylonData.meshes.length === 0) {\n                            babylonData.material.dispose(false, true);\n                            delete material._babylonData[drawMode];\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nGLTFLoaderV2.RegisterExtension(NAME, (loader) => new MSFT_lod(loader));\n","import { Material, Nullable, PBRMaterial } from \"babylonjs\";\r\nimport { IMaterialV2 } from \"../glTFLoaderInterfaces\";\r\nimport { IGLTFLoaderExtensionV2 } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoaderV2 } from \"../glTFLoader\";\r\n\r\nconst NAME = \"MSFT_minecraftMesh\";\r\n\r\n/** @hidden */\r\nexport class MSFT_minecraftMesh implements IGLTFLoaderExtensionV2 {\r\n    public readonly name = NAME;\r\n    public enabled = true;\r\n\r\n    private _loader: GLTFLoaderV2;\r\n\r\n    constructor(loader: GLTFLoaderV2) {\r\n        this._loader = loader;\r\n    }\r\n\r\n    public dispose() {\r\n        delete this._loader;\r\n    }\r\n\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterialV2, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoaderV2.LoadExtraAsync<boolean>(context, material, this.name, (extraContext, extra) => {\r\n            if (extra) {\r\n                if (!(babylonMaterial instanceof PBRMaterial)) {\r\n                    throw new Error(`${extraContext}: Material type not supported`);\r\n                }\r\n\r\n                const promise = this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);\r\n\r\n                if (babylonMaterial.needAlphaBlending()) {\r\n                    babylonMaterial.forceDepthWrite = true;\r\n                    babylonMaterial.separateCullingPass = true;\r\n                }\r\n\r\n                babylonMaterial.backFaceCulling = babylonMaterial.forceDepthWrite;\r\n                babylonMaterial.twoSidedLighting = true;\r\n\r\n                return promise;\r\n            }\r\n\r\n            return null;\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoaderV2.RegisterExtension(NAME, (loader) => new MSFT_minecraftMesh(loader));","import { Material, Nullable, PBRMaterial } from \"babylonjs\";\r\nimport { IMaterialV2 } from \"../glTFLoaderInterfaces\";\r\nimport { IGLTFLoaderExtensionV2 } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoaderV2 } from \"../glTFLoader\";\r\n\r\nconst NAME = \"MSFT_sRGBFactors\";\r\n\r\n/** @hidden */\r\nexport class MSFT_sRGBFactors implements IGLTFLoaderExtensionV2 {\r\n    public readonly name = NAME;\r\n    public enabled = true;\r\n\r\n    private _loader: GLTFLoaderV2;\r\n\r\n    constructor(loader: GLTFLoaderV2) {\r\n        this._loader = loader;\r\n    }\r\n\r\n    public dispose() {\r\n        delete this._loader;\r\n    }\r\n\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterialV2, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoaderV2.LoadExtraAsync<boolean>(context, material, this.name, (extraContext, extra) => {\r\n            if (extra) {\r\n                if (!(babylonMaterial instanceof PBRMaterial)) {\r\n                    throw new Error(`${extraContext}: Material type not supported`);\r\n                }\r\n\r\n                const promise = this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);\r\n\r\n                if (!babylonMaterial.albedoTexture) {\r\n                    babylonMaterial.albedoColor.toLinearSpaceToRef(babylonMaterial.albedoColor);\r\n                }\r\n\r\n                if (!babylonMaterial.reflectivityTexture) {\r\n                    babylonMaterial.reflectivityColor.toLinearSpaceToRef(babylonMaterial.reflectivityColor);\r\n                }\r\n\r\n                return promise;\r\n            }\r\n\r\n            return null;\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoaderV2.RegisterExtension(NAME, (loader) => new MSFT_sRGBFactors(loader));","export * from \"./objFileLoader\";","import { Geometry, Mesh, SceneLoader, Vector3, Vector2, Tools, Color3, StandardMaterial, Nullable, Scene, Texture, ISceneLoaderPluginAsync, SceneLoaderProgressEvent, AbstractMesh, IParticleSystem, Skeleton, AnimationGroup, AssetContainer, VertexData } from \"babylonjs\";\n\n/**\n * Class reading and parsing the MTL file bundled with the obj file.\n */\nexport class MTLFileLoader {\n\n    // All material loaded from the mtl will be set here\n    public materials: StandardMaterial[] = [];\n\n    /**\n     * This function will read the mtl file and create each material described inside\n     * This function could be improve by adding :\n     * -some component missing (Ni, Tf...)\n     * -including the specific options available\n     *\n     * @param scene\n     * @param data\n     * @param rootUrl\n     */\n    public parseMTL(scene: Scene, data: string | ArrayBuffer, rootUrl: string) {\n        if (data instanceof ArrayBuffer) {\n            return;\n        }\n\n        //Split the lines from the file\n        var lines = data.split('\\n');\n        //Space char\n        var delimiter_pattern = /\\s+/;\n        //Array with RGB colors\n        var color: number[];\n        //New material\n        var material: Nullable<StandardMaterial> = null;\n\n        //Look at each line\n        for (var i = 0; i < lines.length; i++) {\n            var line = lines[i].trim();\n\n            // Blank line or comment\n            if (line.length === 0 || line.charAt(0) === '#') {\n                continue;\n            }\n\n            //Get the first parameter (keyword)\n            var pos = line.indexOf(' ');\n            var key = (pos >= 0) ? line.substring(0, pos) : line;\n            key = key.toLowerCase();\n\n            //Get the data following the key\n            var value: string = (pos >= 0) ? line.substring(pos + 1).trim() : \"\";\n\n            //This mtl keyword will create the new material\n            if (key === \"newmtl\") {\n                //Check if it is the first material.\n                // Materials specifications are described after this keyword.\n                if (material) {\n                    //Add the previous material in the material array.\n                    this.materials.push(material);\n                }\n                //Create a new material.\n                // value is the name of the material read in the mtl file\n                material = new StandardMaterial(value, scene);\n            } else if (key === \"kd\" && material) {\n                // Diffuse color (color under white light) using RGB values\n\n                //value  = \"r g b\"\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set tghe color into the material\n                material.diffuseColor = Color3.FromArray(color);\n            } else if (key === \"ka\" && material) {\n                // Ambient color (color under shadow) using RGB values\n\n                //value = \"r g b\"\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set tghe color into the material\n                material.ambientColor = Color3.FromArray(color);\n            } else if (key === \"ks\" && material) {\n                // Specular color (color when light is reflected from shiny surface) using RGB values\n\n                //value = \"r g b\"\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set the color into the material\n                material.specularColor = Color3.FromArray(color);\n            } else if (key === \"ke\" && material) {\n                // Emissive color using RGB values\n                color = value.split(delimiter_pattern, 3).map(parseFloat);\n                material.emissiveColor = Color3.FromArray(color);\n            } else if (key === \"ns\" && material) {\n\n                //value = \"Integer\"\n                material.specularPower = parseFloat(value);\n            } else if (key === \"d\" && material) {\n                //d is dissolve for current material. It mean alpha for BABYLON\n                material.alpha = parseFloat(value);\n\n                //Texture\n                //This part can be improved by adding the possible options of texture\n            } else if (key === \"map_ka\" && material) {\n                // ambient texture map with a loaded image\n                //We must first get the folder of the image\n                material.ambientTexture = MTLFileLoader._getTexture(rootUrl, value, scene);\n            } else if (key === \"map_kd\" && material) {\n                // Diffuse texture map with a loaded image\n                material.diffuseTexture = MTLFileLoader._getTexture(rootUrl, value, scene);\n            } else if (key === \"map_ks\" && material) {\n                // Specular texture map with a loaded image\n                //We must first get the folder of the image\n                material.specularTexture = MTLFileLoader._getTexture(rootUrl, value, scene);\n            } else if (key === \"map_ns\") {\n                //Specular\n                //Specular highlight component\n                //We must first get the folder of the image\n                //\n                //Not supported by BABYLON\n                //\n                //    continue;\n            } else if (key === \"map_bump\" && material) {\n                //The bump texture\n                material.bumpTexture = MTLFileLoader._getTexture(rootUrl, value, scene);\n            } else if (key === \"map_d\" && material) {\n                // The dissolve of the material\n                material.opacityTexture = MTLFileLoader._getTexture(rootUrl, value, scene);\n\n                //Options for illumination\n            } else if (key === \"illum\") {\n                //Illumination\n                if (value === \"0\") {\n                    //That mean Kd == Kd\n                } else if (value === \"1\") {\n                    //Color on and Ambient on\n                } else if (value === \"2\") {\n                    //Highlight on\n                } else if (value === \"3\") {\n                    //Reflection on and Ray trace on\n                } else if (value === \"4\") {\n                    //Transparency: Glass on, Reflection: Ray trace on\n                } else if (value === \"5\") {\n                    //Reflection: Fresnel on and Ray trace on\n                } else if (value === \"6\") {\n                    //Transparency: Refraction on, Reflection: Fresnel off and Ray trace on\n                } else if (value === \"7\") {\n                    //Transparency: Refraction on, Reflection: Fresnel on and Ray trace on\n                } else if (value === \"8\") {\n                    //Reflection on and Ray trace off\n                } else if (value === \"9\") {\n                    //Transparency: Glass on, Reflection: Ray trace off\n                } else if (value === \"10\") {\n                    //Casts shadows onto invisible surfaces\n                }\n            } else {\n                // console.log(\"Unhandled expression at line : \" + i +'\\n' + \"with value : \" + line);\n            }\n        }\n        //At the end of the file, add the last material\n        if (material) {\n            this.materials.push(material);\n        }\n    }\n\n    /**\n     * Gets the texture for the material.\n     *\n     * If the material is imported from input file,\n     * We sanitize the url to ensure it takes the textre from aside the material.\n     *\n     * @param rootUrl The root url to load from\n     * @param value The value stored in the mtl\n     * @return The Texture\n     */\n    private static _getTexture(rootUrl: string, value: string, scene: Scene): Nullable<Texture> {\n        if (!value) {\n            return null;\n        }\n\n        var url = rootUrl;\n        // Load from input file.\n        if (rootUrl === \"file:\") {\n            var lastDelimiter = value.lastIndexOf(\"\\\\\");\n            if (lastDelimiter === -1) {\n                lastDelimiter = value.lastIndexOf(\"/\");\n            }\n\n            if (lastDelimiter > -1) {\n                url += value.substr(lastDelimiter + 1);\n            }\n            else {\n                url += value;\n            }\n        }\n        // Not from input file.\n        else {\n            url += value;\n        }\n\n        return new Texture(url, scene);\n    }\n}\n\nexport class OBJFileLoader implements ISceneLoaderPluginAsync {\n\n    public static OPTIMIZE_WITH_UV = false;\n    public static INVERT_Y = false;\n    public name = \"obj\";\n    public extensions = \".obj\";\n    public obj = /^o/;\n    public group = /^g/;\n    public mtllib = /^mtllib /;\n    public usemtl = /^usemtl /;\n    public smooth = /^s /;\n    public vertexPattern = /v( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/;\n    // vn float float float\n    public normalPattern = /vn( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/;\n    // vt float float\n    public uvPattern = /vt( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/;\n    // f vertex vertex vertex ...\n    public facePattern1 = /f\\s+(([\\d]{1,}[\\s]?){3,})+/;\n    // f vertex/uvs vertex/uvs vertex/uvs ...\n    public facePattern2 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\n    // f vertex/uvs/normal vertex/uvs/normal vertex/uvs/normal ...\n    public facePattern3 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\n    // f vertex//normal vertex//normal vertex//normal ...\n    public facePattern4 = /f\\s+((([\\d]{1,}\\/\\/[\\d]{1,}[\\s]?){3,})+)/;\n    // f -vertex/-uvs/-normal -vertex/-uvs/-normal -vertex/-uvs/-normal ...\n    public facePattern5 = /f\\s+(((-[\\d]{1,}\\/-[\\d]{1,}\\/-[\\d]{1,}[\\s]?){3,})+)/;\n\n    /**\n     * Calls synchronously the MTL file attached to this obj.\n     * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.\n     * Without this function materials are not displayed in the first frame (but displayed after).\n     * In consequence it is impossible to get material information in your HTML file\n     *\n     * @param url The URL of the MTL file\n     * @param rootUrl\n     * @param onSuccess Callback function to be called when the MTL file is loaded\n     * @private\n     */\n    private _loadMTL(url: string, rootUrl: string, onSuccess: (response: string | ArrayBuffer, responseUrl?: string) => any) {\n        //The complete path to the mtl file\n        var pathOfFile = Tools.BaseUrl + rootUrl + url;\n\n        // Loads through the babylon tools to allow fileInput search.\n        Tools.LoadFile(pathOfFile,\n            onSuccess,\n            undefined,\n            undefined,\n            false,\n            () => { console.warn(\"Error - Unable to load \" + pathOfFile); });\n    }\n\n    /**\n     * Imports one or more meshes from the loaded glTF data and adds them to the scene\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene the scene the meshes should be added to\n     * @param data the glTF data to load\n     * @param rootUrl root url to load from\n     * @param onProgress event that fires when loading progress has occured\n     * @param fileName Defines the name of the file to load\n     * @returns a promise containg the loaded meshes, particles, skeletons and animations\n     */\n    public importMeshAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<{ meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], animationGroups: AnimationGroup[] }> {\n        //get the meshes from OBJ file\n        return this._parseSolid(meshesNames, scene, data, rootUrl).then((meshes) => {\n            return {\n                meshes,\n                particleSystems: [],\n                skeletons: [],\n                animationGroups: []\n            };\n        });\n    }\n\n    /**\n     * Imports all objects from the loaded glTF data and adds them to the scene\n     * @param scene the scene the objects should be added to\n     * @param data the glTF data to load\n     * @param rootUrl root url to load from\n     * @param onProgress event that fires when loading progress has occured\n     * @param fileName Defines the name of the file to load\n     * @returns a promise which completes when objects have been loaded to the scene\n     */\n    public loadAsync(scene: Scene, data: string, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<void> {\n        //Get the 3D model\n        return this.importMeshAsync(null, scene, data, rootUrl, onProgress).then(() => {\n            // return void\n        });\n    }\n\n    /**\n     * Load into an asset container.\n     * @param scene The scene to load into\n     * @param data The data to import\n     * @param rootUrl The root url for scene and resources\n     * @param onProgress The callback when the load progresses\n     * @param fileName Defines the name of the file to load\n     * @returns The loaded asset container\n     */\n    public loadAssetContainerAsync(scene: Scene, data: string, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<AssetContainer> {\n        return this.importMeshAsync(null, scene, data, rootUrl).then((result) => {\n            var container = new AssetContainer(scene);\n            result.meshes.forEach((mesh) => container.meshes.push(mesh));\n            container.removeAllFromScene();\n            return container;\n        });\n    }\n\n    /**\n     * Read the OBJ file and create an Array of meshes.\n     * Each mesh contains all information given by the OBJ and the MTL file.\n     * i.e. vertices positions and indices, optional normals values, optional UV values, optional material\n     *\n     * @param meshesNames\n     * @param scene Scene The scene where are displayed the data\n     * @param data String The content of the obj file\n     * @param rootUrl String The path to the folder\n     * @returns Array<AbstractMesh>\n     * @private\n     */\n    private _parseSolid(meshesNames: any, scene: Scene, data: string, rootUrl: string): Promise<Array<AbstractMesh>> {\n\n        var positions: Array<Vector3> = [];      //values for the positions of vertices\n        var normals: Array<Vector3> = [];      //Values for the normals\n        var uvs: Array<Vector2> = [];      //Values for the textures\n        var meshesFromObj: Array<any> = [];      //[mesh] Contains all the obj meshes\n        var handledMesh: any;      //The current mesh of meshes array\n        var indicesForBabylon: Array<number> = [];      //The list of indices for VertexData\n        var wrappedPositionForBabylon: Array<Vector3> = [];      //The list of position in vectors\n        var wrappedUvsForBabylon: Array<Vector2> = [];      //Array with all value of uvs to match with the indices\n        var wrappedNormalsForBabylon: Array<Vector3> = [];      //Array with all value of normals to match with the indices\n        var tuplePosNorm: Array<{ normals: Array<number>; idx: Array<number>; uv: Array<number> }> = [];      //Create a tuple with indice of Position, Normal, UV  [pos, norm, uvs]\n        var curPositionInIndices = 0;\n        var hasMeshes: Boolean = false;   //Meshes are defined in the file\n        var unwrappedPositionsForBabylon: Array<number> = [];      //Value of positionForBabylon w/o Vector3() [x,y,z]\n        var unwrappedNormalsForBabylon: Array<number> = [];      //Value of normalsForBabylon w/o Vector3()  [x,y,z]\n        var unwrappedUVForBabylon: Array<number> = [];      //Value of uvsForBabylon w/o Vector3()      [x,y,z]\n        var triangles: Array<string> = [];      //Indices from new triangles coming from polygons\n        var materialNameFromObj: string = \"\";      //The name of the current material\n        var fileToLoad: string = \"\";      //The name of the mtlFile to load\n        var materialsFromMTLFile: MTLFileLoader = new MTLFileLoader();\n        var objMeshName: string = \"\";      //The name of the current obj mesh\n        var increment: number = 1;      //Id for meshes created by the multimaterial\n        var isFirstMaterial: boolean = true;\n\n        /**\n         * Search for obj in the given array.\n         * This function is called to check if a couple of data already exists in an array.\n         *\n         * If found, returns the index of the founded tuple index. Returns -1 if not found\n         * @param arr Array<{ normals: Array<number>, idx: Array<number> }>\n         * @param obj Array<number>\n         * @returns {boolean}\n         */\n        var isInArray = (arr: Array<{ normals: Array<number>; idx: Array<number> }>, obj: Array<number>) => {\n            if (!arr[obj[0]]) { arr[obj[0]] = { normals: [], idx: [] }; }\n            var idx = arr[obj[0]].normals.indexOf(obj[1]);\n\n            return idx === -1 ? -1 : arr[obj[0]].idx[idx];\n        };\n        var isInArrayUV = (arr: Array<{ normals: Array<number>; idx: Array<number>; uv: Array<number> }>, obj: Array<number>) => {\n            if (!arr[obj[0]]) { arr[obj[0]] = { normals: [], idx: [], uv: [] }; }\n            var idx = arr[obj[0]].normals.indexOf(obj[1]);\n\n            if (idx != 1 && (obj[2] == arr[obj[0]].uv[idx])) {\n                return arr[obj[0]].idx[idx];\n            }\n            return -1;\n        };\n\n        /**\n         * This function set the data for each triangle.\n         * Data are position, normals and uvs\n         * If a tuple of (position, normal) is not set, add the data into the corresponding array\n         * If the tuple already exist, add only their indice\n         *\n         * @param indicePositionFromObj Integer The index in positions array\n         * @param indiceUvsFromObj Integer The index in uvs array\n         * @param indiceNormalFromObj Integer The index in normals array\n         * @param positionVectorFromOBJ Vector3 The value of position at index objIndice\n         * @param textureVectorFromOBJ Vector3 The value of uvs\n         * @param normalsVectorFromOBJ Vector3 The value of normals at index objNormale\n         */\n        var setData = (indicePositionFromObj: number, indiceUvsFromObj: number, indiceNormalFromObj: number, positionVectorFromOBJ: Vector3, textureVectorFromOBJ: Vector2, normalsVectorFromOBJ: Vector3) => {\n            //Check if this tuple already exists in the list of tuples\n            var _index: number;\n            if (OBJFileLoader.OPTIMIZE_WITH_UV) {\n                _index = isInArrayUV(\n                    tuplePosNorm,\n                    [\n                        indicePositionFromObj,\n                        indiceNormalFromObj,\n                        indiceUvsFromObj\n                    ]\n                );\n            }\n            else {\n                _index = isInArray(\n                    tuplePosNorm,\n                    [\n                        indicePositionFromObj,\n                        indiceNormalFromObj\n                    ]\n                );\n            }\n\n            //If it not exists\n            if (_index == -1) {\n                //Add an new indice.\n                //The array of indices is only an array with his length equal to the number of triangles - 1.\n                //We add vertices data in this order\n                indicesForBabylon.push(wrappedPositionForBabylon.length);\n                //Push the position of vertice for Babylon\n                //Each element is a Vector3(x,y,z)\n                wrappedPositionForBabylon.push(positionVectorFromOBJ);\n                //Push the uvs for Babylon\n                //Each element is a Vector3(u,v)\n                wrappedUvsForBabylon.push(textureVectorFromOBJ);\n                //Push the normals for Babylon\n                //Each element is a Vector3(x,y,z)\n                wrappedNormalsForBabylon.push(normalsVectorFromOBJ);\n                //Add the tuple in the comparison list\n                tuplePosNorm[indicePositionFromObj].normals.push(indiceNormalFromObj);\n                tuplePosNorm[indicePositionFromObj].idx.push(curPositionInIndices++);\n                if (OBJFileLoader.OPTIMIZE_WITH_UV) { tuplePosNorm[indicePositionFromObj].uv.push(indiceUvsFromObj); }\n            } else {\n                //The tuple already exists\n                //Add the index of the already existing tuple\n                //At this index we can get the value of position, normal and uvs of vertex\n                indicesForBabylon.push(_index);\n            }\n        };\n\n        /**\n         * Transform Vector() object onto 3 digits in an array\n         */\n        var unwrapData = () => {\n            //Every array has the same length\n            for (var l = 0; l < wrappedPositionForBabylon.length; l++) {\n                //Push the x, y, z values of each element in the unwrapped array\n                unwrappedPositionsForBabylon.push(wrappedPositionForBabylon[l].x, wrappedPositionForBabylon[l].y, wrappedPositionForBabylon[l].z);\n                unwrappedNormalsForBabylon.push(wrappedNormalsForBabylon[l].x, wrappedNormalsForBabylon[l].y, wrappedNormalsForBabylon[l].z);\n                unwrappedUVForBabylon.push(wrappedUvsForBabylon[l].x, wrappedUvsForBabylon[l].y); //z is an optional value not supported by BABYLON\n            }\n            // Reset arrays for the next new meshes\n            wrappedPositionForBabylon = [];\n            wrappedNormalsForBabylon = [];\n            wrappedUvsForBabylon = [];\n            tuplePosNorm = [];\n            curPositionInIndices = 0;\n        };\n\n        /**\n         * Create triangles from polygons by recursion\n         * The best to understand how it works is to draw it in the same time you get the recursion.\n         * It is important to notice that a triangle is a polygon\n         * We get 5 patterns of face defined in OBJ File :\n         * facePattern1 = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"]\n         * facePattern2 = [\"1/1\",\"2/2\",\"3/3\",\"4/4\",\"5/5\",\"6/6\"]\n         * facePattern3 = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"4/4/4\",\"5/5/5\",\"6/6/6\"]\n         * facePattern4 = [\"1//1\",\"2//2\",\"3//3\",\"4//4\",\"5//5\",\"6//6\"]\n         * facePattern5 = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-4/-4/-4\",\"-5/-5/-5\",\"-6/-6/-6\"]\n         * Each pattern is divided by the same method\n         * @param face Array[String] The indices of elements\n         * @param v Integer The variable to increment\n         */\n        var getTriangles = (face: Array<string>, v: number) => {\n            //Work for each element of the array\n            if (v + 1 < face.length) {\n                //Add on the triangle variable the indexes to obtain triangles\n                triangles.push(face[0], face[v], face[v + 1]);\n                //Incrementation for recursion\n                v += 1;\n                //Recursion\n                getTriangles(face, v);\n            }\n\n            //Result obtained after 2 iterations:\n            //Pattern1 => triangle = [\"1\",\"2\",\"3\",\"1\",\"3\",\"4\"];\n            //Pattern2 => triangle = [\"1/1\",\"2/2\",\"3/3\",\"1/1\",\"3/3\",\"4/4\"];\n            //Pattern3 => triangle = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"1/1/1\",\"3/3/3\",\"4/4/4\"];\n            //Pattern4 => triangle = [\"1//1\",\"2//2\",\"3//3\",\"1//1\",\"3//3\",\"4//4\"];\n            //Pattern5 => triangle = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-1/-1/-1\",\"-3/-3/-3\",\"-4/-4/-4\"];\n        };\n\n        /**\n         * Create triangles and push the data for each polygon for the pattern 1\n         * In this pattern we get vertice positions\n         * @param face\n         * @param v\n         */\n        var setDataForCurrentFaceWithPattern1 = (face: Array<string>, v: number) => {\n            //Get the indices of triangles for each polygon\n            getTriangles(face, v);\n            //For each element in the triangles array.\n            //This var could contains 1 to an infinity of triangles\n            for (var k = 0; k < triangles.length; k++) {\n                // Set position indice\n                var indicePositionFromObj = parseInt(triangles[k]) - 1;\n\n                setData(\n                    indicePositionFromObj,\n                    0, 0,                                           //In the pattern 1, normals and uvs are not defined\n                    positions[indicePositionFromObj],               //Get the vectors data\n                    Vector2.Zero(), Vector3.Up()    //Create default vectors\n                );\n            }\n            //Reset variable for the next line\n            triangles = [];\n        };\n\n        /**\n         * Create triangles and push the data for each polygon for the pattern 2\n         * In this pattern we get vertice positions and uvsu\n         * @param face\n         * @param v\n         */\n        var setDataForCurrentFaceWithPattern2 = (face: Array<string>, v: number) => {\n            //Get the indices of triangles for each polygon\n            getTriangles(face, v);\n            for (var k = 0; k < triangles.length; k++) {\n                //triangle[k] = \"1/1\"\n                //Split the data for getting position and uv\n                var point = triangles[k].split(\"/\"); // [\"1\", \"1\"]\n                //Set position indice\n                var indicePositionFromObj = parseInt(point[0]) - 1;\n                //Set uv indice\n                var indiceUvsFromObj = parseInt(point[1]) - 1;\n\n                setData(\n                    indicePositionFromObj,\n                    indiceUvsFromObj,\n                    0,                                  //Default value for normals\n                    positions[indicePositionFromObj],   //Get the values for each element\n                    uvs[indiceUvsFromObj],\n                    Vector3.Up()                //Default value for normals\n                );\n            }\n\n            //Reset variable for the next line\n            triangles = [];\n        };\n\n        /**\n         * Create triangles and push the data for each polygon for the pattern 3\n         * In this pattern we get vertice positions, uvs and normals\n         * @param face\n         * @param v\n         */\n        var setDataForCurrentFaceWithPattern3 = (face: Array<string>, v: number) => {\n            //Get the indices of triangles for each polygon\n            getTriangles(face, v);\n\n            for (var k = 0; k < triangles.length; k++) {\n                //triangle[k] = \"1/1/1\"\n                //Split the data for getting position, uv, and normals\n                var point = triangles[k].split(\"/\"); // [\"1\", \"1\", \"1\"]\n                // Set position indice\n                var indicePositionFromObj = parseInt(point[0]) - 1;\n                // Set uv indice\n                var indiceUvsFromObj = parseInt(point[1]) - 1;\n                // Set normal indice\n                var indiceNormalFromObj = parseInt(point[2]) - 1;\n\n                setData(\n                    indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj,\n                    positions[indicePositionFromObj], uvs[indiceUvsFromObj], normals[indiceNormalFromObj] //Set the vector for each component\n                );\n\n            }\n            //Reset variable for the next line\n            triangles = [];\n        };\n\n        /**\n         * Create triangles and push the data for each polygon for the pattern 4\n         * In this pattern we get vertice positions and normals\n         * @param face\n         * @param v\n         */\n        var setDataForCurrentFaceWithPattern4 = (face: Array<string>, v: number) => {\n            getTriangles(face, v);\n\n            for (var k = 0; k < triangles.length; k++) {\n                //triangle[k] = \"1//1\"\n                //Split the data for getting position and normals\n                var point = triangles[k].split(\"//\"); // [\"1\", \"1\"]\n                // We check indices, and normals\n                var indicePositionFromObj = parseInt(point[0]) - 1;\n                var indiceNormalFromObj = parseInt(point[1]) - 1;\n\n                setData(\n                    indicePositionFromObj,\n                    1, //Default value for uv\n                    indiceNormalFromObj,\n                    positions[indicePositionFromObj], //Get each vector of data\n                    Vector2.Zero(),\n                    normals[indiceNormalFromObj]\n                );\n            }\n            //Reset variable for the next line\n            triangles = [];\n        };\n\n        /**\n         * Create triangles and push the data for each polygon for the pattern 3\n         * In this pattern we get vertice positions, uvs and normals\n         * @param face\n         * @param v\n         */\n        var setDataForCurrentFaceWithPattern5 = (face: Array<string>, v: number) => {\n            //Get the indices of triangles for each polygon\n            getTriangles(face, v);\n\n            for (var k = 0; k < triangles.length; k++) {\n                //triangle[k] = \"-1/-1/-1\"\n                //Split the data for getting position, uv, and normals\n                var point = triangles[k].split(\"/\"); // [\"-1\", \"-1\", \"-1\"]\n                // Set position indice\n                var indicePositionFromObj =  positions.length + parseInt(point[0]);\n                // Set uv indice\n                var indiceUvsFromObj =  uvs.length + parseInt(point[1]);\n                // Set normal indice\n                var indiceNormalFromObj = normals.length + parseInt(point[2]);\n\n                setData(\n                    indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj,\n                    positions[indicePositionFromObj], uvs[indiceUvsFromObj], normals[indiceNormalFromObj] //Set the vector for each component\n                );\n\n            }\n            //Reset variable for the next line\n            triangles = [];\n        };\n\n        var addPreviousObjMesh = () => {\n\n            //Check if it is not the first mesh. Otherwise we don't have data.\n            if (meshesFromObj.length > 0) {\n                //Get the previous mesh for applying the data about the faces\n                //=> in obj file, faces definition append after the name of the mesh\n                handledMesh = meshesFromObj[meshesFromObj.length - 1];\n\n                //Set the data into Array for the mesh\n                unwrapData();\n\n                // Reverse tab. Otherwise face are displayed in the wrong sens\n                indicesForBabylon.reverse();\n                //Set the information for the mesh\n                //Slice the array to avoid rewriting because of the fact this is the same var which be rewrited\n                handledMesh.indices = indicesForBabylon.slice();\n                handledMesh.positions = unwrappedPositionsForBabylon.slice();\n                handledMesh.normals = unwrappedNormalsForBabylon.slice();\n                handledMesh.uvs = unwrappedUVForBabylon.slice();\n\n                //Reset the array for the next mesh\n                indicesForBabylon = [];\n                unwrappedPositionsForBabylon = [];\n                unwrappedNormalsForBabylon = [];\n                unwrappedUVForBabylon = [];\n            }\n        };\n        //Main function\n\n        //Split the file into lines\n        var lines = data.split('\\n');\n        //Look at each line\n        for (var i = 0; i < lines.length; i++) {\n            var line = lines[i].trim();\n            var result;\n\n            //Comment or newLine\n            if (line.length === 0 || line.charAt(0) === '#') {\n                continue;\n\n                //Get information about one position possible for the vertices\n            } else if ((result = this.vertexPattern.exec(line)) !== null) {\n                //Create a Vector3 with the position x, y, z\n                //Value of result:\n                // [\"v 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n                //Add the Vector in the list of positions\n                positions.push(new Vector3(\n                    parseFloat(result[1]),\n                    parseFloat(result[2]),\n                    parseFloat(result[3])\n                ));\n\n            } else if ((result = this.normalPattern.exec(line)) !== null) {\n                //Create a Vector3 with the normals x, y, z\n                //Value of result\n                // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n                //Add the Vector in the list of normals\n                normals.push(new Vector3(\n                    parseFloat(result[1]),\n                    parseFloat(result[2]),\n                    parseFloat(result[3])\n                ));\n\n            } else if ((result = this.uvPattern.exec(line)) !== null) {\n                //Create a Vector2 with the normals u, v\n                //Value of result\n                // [\"vt 0.1 0.2 0.3\", \"0.1\", \"0.2\"]\n                //Add the Vector in the list of uvs\n                uvs.push(new Vector2(\n                    parseFloat(result[1]),\n                    parseFloat(result[2])\n                ));\n\n                //Identify patterns of faces\n                //Face could be defined in different type of pattern\n            } else if ((result = this.facePattern3.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1/1/1 2/2/2 3/3/3\", \"1/1/1 2/2/2 3/3/3\"...]\n\n                //Set the data for this face\n                setDataForCurrentFaceWithPattern3(\n                    result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\", \"3/3/3\"]\n                    1\n                );\n\n            } else if ((result = this.facePattern4.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1//1 2//2 3//3\", \"1//1 2//2 3//3\"...]\n\n                //Set the data for this face\n                setDataForCurrentFaceWithPattern4(\n                    result[1].trim().split(\" \"), // [\"1//1\", \"2//2\", \"3//3\"]\n                    1\n                );\n\n            } else if ((result = this.facePattern5.exec(line)) !== null) {\n                //Value of result:\n                //[\"f -1/-1/-1 -2/-2/-2 -3/-3/-3\", \"-1/-1/-1 -2/-2/-2 -3/-3/-3\"...]\n\n                //Set the data for this face\n                setDataForCurrentFaceWithPattern5(\n                    result[1].trim().split(\" \"), // [\"-1/-1/-1\", \"-2/-2/-2\", \"-3/-3/-3\"]\n                    1\n                );\n\n            } else if ((result = this.facePattern2.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1/1 2/2 3/3\", \"1/1 2/2 3/3\"...]\n\n                //Set the data for this face\n                setDataForCurrentFaceWithPattern2(\n                    result[1].trim().split(\" \"), // [\"1/1\", \"2/2\", \"3/3\"]\n                    1\n                );\n\n            } else if ((result = this.facePattern1.exec(line)) !== null) {\n                //Value of result\n                //[\"f 1 2 3\", \"1 2 3\"...]\n\n                //Set the data for this face\n                setDataForCurrentFaceWithPattern1(\n                    result[1].trim().split(\" \"), // [\"1\", \"2\", \"3\"]\n                    1\n                );\n\n                //Define a mesh or an object\n                //Each time this keyword is analysed, create a new Object with all data for creating a babylonMesh\n            } else if (this.group.test(line) || this.obj.test(line)) {\n                //Create a new mesh corresponding to the name of the group.\n                //Definition of the mesh\n                var objMesh: {\n                    name: string;\n                    indices?: Array<number>;\n                    positions?: Array<number>;\n                    normals?: Array<number>;\n                    uvs?: Array<number>;\n                    materialName: string;\n                } =\n                //Set the name of the current obj mesh\n                {\n                    name: line.substring(2).trim(),\n                    indices: undefined,\n                    positions: undefined,\n                    normals: undefined,\n                    uvs: undefined,\n                    materialName: \"\"\n                };\n                addPreviousObjMesh();\n\n                //Push the last mesh created with only the name\n                meshesFromObj.push(objMesh);\n\n                //Set this variable to indicate that now meshesFromObj has objects defined inside\n                hasMeshes = true;\n                isFirstMaterial = true;\n                increment = 1;\n                //Keyword for applying a material\n            } else if (this.usemtl.test(line)) {\n                //Get the name of the material\n                materialNameFromObj = line.substring(7).trim();\n\n                //If this new material is in the same mesh\n\n                if (!isFirstMaterial) {\n                    //Set the data for the previous mesh\n                    addPreviousObjMesh();\n                    //Create a new mesh\n                    var objMesh: {\n                        name: string;\n                        indices?: Array<number>;\n                        positions?: Array<number>;\n                        normals?: Array<number>;\n                        uvs?: Array<number>;\n                        materialName: string;\n                    } =\n                    //Set the name of the current obj mesh\n                    {\n                        name: objMeshName + \"_mm\" + increment.toString(),\n                        indices: undefined,\n                        positions: undefined,\n                        normals: undefined,\n                        uvs: undefined,\n                        materialName: materialNameFromObj\n                    };\n                    increment++;\n                    //If meshes are already defined\n                    meshesFromObj.push(objMesh);\n                }\n                //Set the material name if the previous line define a mesh\n\n                if (hasMeshes && isFirstMaterial) {\n                    //Set the material name to the previous mesh (1 material per mesh)\n                    meshesFromObj[meshesFromObj.length - 1].materialName = materialNameFromObj;\n                    isFirstMaterial = false;\n                }\n                //Keyword for loading the mtl file\n            } else if (this.mtllib.test(line)) {\n                //Get the name of mtl file\n                fileToLoad = line.substring(7).trim();\n\n                //Apply smoothing\n            } else if (this.smooth.test(line)) {\n                // smooth shading => apply smoothing\n                //Toda  y I don't know it work with babylon and with obj.\n                //With the obj file  an integer is set\n            } else {\n                //If there is another possibility\n                console.log(\"Unhandled expression at line : \" + line);\n            }\n        }\n\n        //At the end of the file, add the last mesh into the meshesFromObj array\n        if (hasMeshes) {\n            //Set the data for the last mesh\n            handledMesh = meshesFromObj[meshesFromObj.length - 1];\n\n            //Reverse indices for displaying faces in the good sens\n            indicesForBabylon.reverse();\n            //Get the good array\n            unwrapData();\n            //Set array\n            handledMesh.indices = indicesForBabylon;\n            handledMesh.positions = unwrappedPositionsForBabylon;\n            handledMesh.normals = unwrappedNormalsForBabylon;\n            handledMesh.uvs = unwrappedUVForBabylon;\n        }\n\n        //If any o or g keyword found, create a mesj with a random id\n        if (!hasMeshes) {\n            // reverse tab of indices\n            indicesForBabylon.reverse();\n            //Get positions normals uvs\n            unwrapData();\n            //Set data for one mesh\n            meshesFromObj.push({\n                name: Geometry.RandomId(),\n                indices: indicesForBabylon,\n                positions: unwrappedPositionsForBabylon,\n                normals: unwrappedNormalsForBabylon,\n                uvs: unwrappedUVForBabylon,\n                materialName: materialNameFromObj\n            });\n        }\n\n        //Create a Mesh list\n        var babylonMeshesArray: Array<Mesh> = []; //The mesh for babylon\n        var materialToUse = new Array<string>();\n\n        //Set data for each mesh\n        for (var j = 0; j < meshesFromObj.length; j++) {\n\n            //check meshesNames (stlFileLoader)\n            if (meshesNames && meshesFromObj[j].name) {\n                if (meshesNames instanceof Array) {\n                    if (meshesNames.indexOf(meshesFromObj[j].name) == -1) {\n                        continue;\n                    }\n                }\n                else {\n                    if (meshesFromObj[j].name !== meshesNames) {\n                        continue;\n                    }\n                }\n            }\n\n            //Get the current mesh\n            //Set the data with VertexBuffer for each mesh\n            handledMesh = meshesFromObj[j];\n            //Create a Mesh with the name of the obj mesh\n            var babylonMesh = new Mesh(meshesFromObj[j].name, scene);\n            //Push the name of the material to an array\n            //This is indispensable for the importMesh function\n            materialToUse.push(meshesFromObj[j].materialName);\n\n            var vertexData: VertexData = new VertexData(); //The container for the values\n            //Set the data for the babylonMesh\n            vertexData.positions = handledMesh.positions;\n            vertexData.normals = handledMesh.normals;\n            vertexData.uvs = handledMesh.uvs;\n            vertexData.indices = handledMesh.indices;\n            //Set the data from the VertexBuffer to the current Mesh\n            vertexData.applyToMesh(babylonMesh);\n            if (OBJFileLoader.INVERT_Y) {\n                babylonMesh.scaling.y *= -1;\n            }\n\n            //Push the mesh into an array\n            babylonMeshesArray.push(babylonMesh);\n        }\n\n        let mtlPromises: Array<Promise<any>> = [];\n        //load the materials\n        //Check if we have a file to load\n        if (fileToLoad !== \"\") {\n            //Load the file synchronously\n            mtlPromises.push(new Promise((resolve, reject) => {\n                this._loadMTL(fileToLoad, rootUrl, function(dataLoaded) {\n                    try {\n                        //Create materials thanks MTLLoader function\n                        materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl);\n                        //Look at each material loaded in the mtl file\n                        for (var n = 0; n < materialsFromMTLFile.materials.length; n++) {\n                            //Three variables to get all meshes with the same material\n                            var startIndex = 0;\n                            var _indices = [];\n                            var _index;\n\n                            //The material from MTL file is used in the meshes loaded\n                            //Push the indice in an array\n                            //Check if the material is not used for another mesh\n                            while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {\n                                _indices.push(_index);\n                                startIndex = _index + 1;\n                            }\n                            //If the material is not used dispose it\n                            if (_index == -1 && _indices.length == 0) {\n                                //If the material is not needed, remove it\n                                materialsFromMTLFile.materials[n].dispose();\n                            } else {\n                                for (var o = 0; o < _indices.length; o++) {\n                                    //Apply the material to the Mesh for each mesh with the material\n                                    babylonMeshesArray[_indices[o]].material = materialsFromMTLFile.materials[n];\n                                }\n                            }\n                        }\n                        resolve();\n                    } catch (e) {\n                        reject(e);\n                    }\n\n                });\n            }));\n\n        }\n        //Return an array with all Mesh\n        return Promise.all(mtlPromises).then(() => {\n            return babylonMeshesArray;\n        });\n    }\n\n}\n\nif (SceneLoader) {\n    //Add this loader into the register plugin\n    SceneLoader.RegisterPlugin(new OBJFileLoader());\n}","export * from \"./stlFileLoader\";","import { SceneLoader, ISceneLoaderPlugin, ISceneLoaderPluginExtensions, Scene, Nullable, AbstractMesh, IParticleSystem, Skeleton, Mesh, Tools, AssetContainer, VertexBuffer } from \"babylonjs\";\n\nexport class STLFileLoader implements ISceneLoaderPlugin {\n\n    public solidPattern = /solid (\\S*)([\\S\\s]*)endsolid[ ]*(\\S*)/g;\n    public facetsPattern = /facet([\\s\\S]*?)endfacet/g;\n    public normalPattern = /normal[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g;\n    public vertexPattern = /vertex[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g;\n\n    public name = \"stl\";\n\n    // force data to come in as an ArrayBuffer\n    // we'll convert to string if it looks like it's an ASCII .stl\n    public extensions: ISceneLoaderPluginExtensions = {\n        \".stl\": { isBinary: true },\n    };\n\n    public importMesh(meshesNames: any, scene: Scene, data: any, rootUrl: string, meshes: Nullable<AbstractMesh[]>, particleSystems: Nullable<IParticleSystem[]>, skeletons: Nullable<Skeleton[]>): boolean {\n        var matches;\n\n        if (typeof data !== \"string\") {\n\n            if (this.isBinary(data)) {\n                // binary .stl\n                var babylonMesh = new Mesh(\"stlmesh\", scene);\n                this.parseBinary(babylonMesh, data);\n                if (meshes) {\n                    meshes.push(babylonMesh);\n                }\n                return true;\n            }\n\n            // ASCII .stl\n\n            // convert to string\n            var array_buffer = new Uint8Array(data);\n            var str = '';\n            for (var i = 0; i < data.byteLength; i++) {\n                str += String.fromCharCode(array_buffer[i]); // implicitly assumes little-endian\n            }\n            data = str;\n        }\n\n        //if arrived here, data is a string, containing the STLA data.\n\n        while (matches = this.solidPattern.exec(data)) {\n            var meshName = matches[1];\n            var meshNameFromEnd = matches[3];\n            if (meshName != meshNameFromEnd) {\n                Tools.Error(\"Error in STL, solid name != endsolid name\");\n                return false;\n            }\n\n            // check meshesNames\n            if (meshesNames && meshName) {\n                if (meshesNames instanceof Array) {\n                    if (!meshesNames.indexOf(meshName)) {\n                        continue;\n                    }\n                } else {\n                    if (meshName !== meshesNames) {\n                        continue;\n                    }\n                }\n            }\n\n            // stl mesh name can be empty as well\n            meshName = meshName || \"stlmesh\";\n\n            var babylonMesh = new Mesh(meshName, scene);\n            this.parseASCII(babylonMesh, matches[2]);\n            if (meshes) {\n                meshes.push(babylonMesh);\n            }\n        }\n\n        return true;\n\n    }\n\n    public load(scene: Scene, data: any, rootUrl: string): boolean {\n        var result = this.importMesh(null, scene, data, rootUrl, null, null, null);\n\n        if (result) {\n            scene.createDefaultCameraOrLight();\n        }\n\n        return result;\n    }\n\n    public loadAssetContainer(scene: Scene, data: string, rootUrl: string, onError?: (message: string, exception?: any) => void): AssetContainer {\n        var container = new AssetContainer(scene);\n        this.importMesh(null, scene, data, rootUrl, container.meshes, null, null);\n        container.removeAllFromScene();\n        return container;\n    }\n\n    private isBinary(data: any) {\n\n        // check if file size is correct for binary stl\n        var faceSize, nFaces, reader;\n        reader = new DataView(data);\n        faceSize = (32 / 8 * 3) + ((32 / 8 * 3) * 3) + (16 / 8);\n        nFaces = reader.getUint32(80, true);\n\n        if (80 + (32 / 8) + (nFaces * faceSize) === reader.byteLength) {\n            return true;\n        }\n\n        // check characters higher than ASCII to confirm binary\n        var fileLength = reader.byteLength;\n        for (var index = 0; index < fileLength; index++) {\n            if (reader.getUint8(index) > 127) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private parseBinary(mesh: Mesh, data: ArrayBuffer) {\n\n        var reader = new DataView(data);\n        var faces = reader.getUint32(80, true);\n\n        var dataOffset = 84;\n        var faceLength = 12 * 4 + 2;\n\n        var offset = 0;\n\n        var positions = new Float32Array(faces * 3 * 3);\n        var normals = new Float32Array(faces * 3 * 3);\n        var indices = new Uint32Array(faces * 3);\n        var indicesCount = 0;\n\n        for (var face = 0; face < faces; face++) {\n\n            var start = dataOffset + face * faceLength;\n            var normalX = reader.getFloat32(start, true);\n            var normalY = reader.getFloat32(start + 4, true);\n            var normalZ = reader.getFloat32(start + 8, true);\n\n            for (var i = 1; i <= 3; i++) {\n\n                var vertexstart = start + i * 12;\n\n                // ordering is intentional to match ascii import\n                positions[offset] = reader.getFloat32(vertexstart, true);\n                positions[offset + 2] = reader.getFloat32(vertexstart + 4, true);\n                positions[offset + 1] = reader.getFloat32(vertexstart + 8, true);\n\n                normals[offset] = normalX;\n                normals[offset + 2] = normalY;\n                normals[offset + 1] = normalZ;\n\n                offset += 3;\n            }\n            indices[indicesCount] = indicesCount++;\n            indices[indicesCount] = indicesCount++;\n            indices[indicesCount] = indicesCount++;\n        }\n\n        mesh.setVerticesData(VertexBuffer.PositionKind, positions);\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\n        mesh.setIndices(indices);\n        mesh.computeWorldMatrix(true);\n    }\n\n    private parseASCII(mesh: Mesh, solidData: string) {\n\n        var positions = [];\n        var normals = [];\n        var indices = [];\n        var indicesCount = 0;\n\n        //load facets, ignoring loop as the standard doesn't define it can contain more than vertices\n        var matches;\n        while (matches = this.facetsPattern.exec(solidData)) {\n            var facet = matches[1];\n            //one normal per face\n            var normalMatches = this.normalPattern.exec(facet);\n            this.normalPattern.lastIndex = 0;\n            if (!normalMatches) {\n                continue;\n            }\n            var normal = [Number(normalMatches[1]), Number(normalMatches[5]), Number(normalMatches[3])];\n\n            var vertexMatch;\n            while (vertexMatch = this.vertexPattern.exec(facet)) {\n                positions.push(Number(vertexMatch[1]), Number(vertexMatch[5]), Number(vertexMatch[3]));\n                normals.push(normal[0], normal[1], normal[2]);\n            }\n            indices.push(indicesCount++, indicesCount++, indicesCount++);\n            this.vertexPattern.lastIndex = 0;\n        }\n\n        this.facetsPattern.lastIndex = 0;\n        mesh.setVerticesData(VertexBuffer.PositionKind, positions);\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\n        mesh.setIndices(indices);\n        mesh.computeWorldMatrix(true);\n    }\n}\n\nif (SceneLoader) {\n    SceneLoader.RegisterPlugin(new STLFileLoader());\n}"],"sourceRoot":""}