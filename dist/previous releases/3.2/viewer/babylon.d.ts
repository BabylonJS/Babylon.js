

declare module 'babylonjs' { 
    export = BABYLON; 
}
declare module BABYLON {
    /**
     * Set of assets to keep when moving a scene into an asset container.
     */
    class KeepAssets {
        /**
         * Cameras to keep.
         */
        cameras: Camera[];
        /**
         * Lights to keep.
         */
        lights: Light[];
        /**
         * Meshes to keep.
         */
        meshes: AbstractMesh[];
        /**
         * Skeletons to keep.
         */
        skeletons: Skeleton[];
        /**
         * ParticleSystems to keep.
         */
        particleSystems: IParticleSystem[];
        /**
         * Animations to keep.
         */
        animations: Animation[];
        /**
         * AnimationGroups to keep.
         */
        animationGroups: AnimationGroup[];
        /**
         * MultiMaterials to keep.
         */
        multiMaterials: MultiMaterial[];
        /**
         * Materials to keep.
         */
        materials: Material[];
        /**
         * MorphTargetManagers to keep.
         */
        morphTargetManagers: MorphTargetManager[];
        /**
         * Geometries to keep.
         */
        geometries: Geometry[];
        /**
         * TransformNodes to keep.
         */
        transformNodes: TransformNode[];
        /**
         * LensFlareSystems to keep.
         */
        lensFlareSystems: LensFlareSystem[];
        /**
         * ShadowGenerators to keep.
         */
        shadowGenerators: ShadowGenerator[];
        /**
         * ActionManagers to keep.
         */
        actionManagers: ActionManager[];
        /**
         * Sounds to keep.
         */
        sounds: Sound[];
        /**
         * Textures to keep.
         */
        textures: Texture[];
        /**
         * Effect layers to keep.
         */
        effectLayers: EffectLayer[];
    }
    /**
     * Container with a set of assets that can be added or removed from a scene.
     */
    class AssetContainer {
        /**
         * The scene the AssetContainer belongs to.
         */
        scene: Scene;
        /**
         * Cameras populated in the container.
         */
        cameras: Camera[];
        /**
         * Lights populated in the container.
         */
        lights: Light[];
        /**
         * Meshes populated in the container.
         */
        meshes: AbstractMesh[];
        /**
         * Skeletons populated in the container.
         */
        skeletons: Skeleton[];
        /**
         * ParticleSystems populated in the container.
         */
        particleSystems: IParticleSystem[];
        /**
         * Animations populated in the container.
         */
        animations: Animation[];
        /**
         * AnimationGroups populated in the container.
         */
        animationGroups: AnimationGroup[];
        /**
         * MultiMaterials populated in the container.
         */
        multiMaterials: MultiMaterial[];
        /**
         * Materials populated in the container.
         */
        materials: Material[];
        /**
         * MorphTargetManagers populated in the container.
         */
        morphTargetManagers: MorphTargetManager[];
        /**
         * Geometries populated in the container.
         */
        geometries: Geometry[];
        /**
         * TransformNodes populated in the container.
         */
        transformNodes: TransformNode[];
        /**
         * LensFlareSystems populated in the container.
         */
        lensFlareSystems: LensFlareSystem[];
        /**
         * ShadowGenerators populated in the container.
         */
        shadowGenerators: ShadowGenerator[];
        /**
         * ActionManagers populated in the container.
         */
        actionManagers: ActionManager[];
        /**
         * Sounds populated in the container.
         */
        sounds: Sound[];
        /**
         * Textures populated in the container.
         */
        textures: Texture[];
        /**
         * Effect layers populated in the container.
         */
        effectLayers: EffectLayer[];
        /**
         * Instantiates an AssetContainer.
         * @param scene The scene the AssetContainer belongs to.
         */
        constructor(scene: Scene);
        /**
         * Adds all the assets from the container to the scene.
         */
        addAllToScene(): void;
        /**
         * Removes all the assets in the container from the scene
         */
        removeAllFromScene(): void;
        private _moveAssets<T>(sourceAssets, targetAssets, keepAssets);
        /**
         * Removes all the assets contained in the scene and adds them to the container.
         * @param keepAssets Set of assets to keep in the scene. (default: empty)
         */
        moveAllFromScene(keepAssets?: KeepAssets): void;
    }
}

interface Window {
    mozIndexedDB: IDBFactory;
    webkitIndexedDB: IDBFactory;
    msIndexedDB: IDBFactory;
    webkitURL: typeof URL;
    mozRequestAnimationFrame(callback: FrameRequestCallback): number;
    oRequestAnimationFrame(callback: FrameRequestCallback): number;
    WebGLRenderingContext: WebGLRenderingContext;
    MSGesture: MSGesture;
    CANNON: any;
    AudioContext: AudioContext;
    webkitAudioContext: AudioContext;
    PointerEvent: any;
    Math: Math;
    Uint8Array: Uint8ArrayConstructor;
    Float32Array: Float32ArrayConstructor;
    mozURL: typeof URL;
    msURL: typeof URL;
    VRFrameData: any;
    DracoDecoderModule: any;
}
interface WebGLRenderingContext {
    drawArraysInstanced(mode: number, first: number, count: number, primcount: number): void;
    drawElementsInstanced(mode: number, count: number, type: number, offset: number, primcount: number): void;
    vertexAttribDivisor(index: number, divisor: number): void;
    createVertexArray(): any;
    bindVertexArray(vao?: WebGLVertexArrayObject | null): void;
    deleteVertexArray(vao: WebGLVertexArrayObject): void;
    blitFramebuffer(srcX0: number, srcY0: number, srcX1: number, srcY1: number, dstX0: number, dstY0: number, dstX1: number, dstY1: number, mask: number, filter: number): void;
    renderbufferStorageMultisample(target: number, samples: number, internalformat: number, width: number, height: number): void;
    bindBufferBase(target: number, index: number, buffer: WebGLBuffer | null): void;
    getUniformBlockIndex(program: WebGLProgram, uniformBlockName: string): number;
    uniformBlockBinding(program: WebGLProgram, uniformBlockIndex: number, uniformBlockBinding: number): void;
    createQuery(): WebGLQuery;
    deleteQuery(query: WebGLQuery): void;
    beginQuery(target: number, query: WebGLQuery): void;
    endQuery(target: number): void;
    getQueryParameter(query: WebGLQuery, pname: number): any;
    getQuery(target: number, pname: number): any;
    MAX_SAMPLES: number;
    RGBA8: number;
    READ_FRAMEBUFFER: number;
    DRAW_FRAMEBUFFER: number;
    UNIFORM_BUFFER: number;
    HALF_FLOAT_OES: number;
    RGBA16F: number;
    RGBA32F: number;
    R32F: number;
    RG32F: number;
    RGB32F: number;
    RED: number;
    RG: number;
    UNSIGNED_INT_24_8: number;
    DEPTH24_STENCIL8: number;
    drawBuffers(buffers: number[]): void;
    readBuffer(src: number): void;
    readonly COLOR_ATTACHMENT0: number;
    readonly COLOR_ATTACHMENT1: number;
    readonly COLOR_ATTACHMENT2: number;
    readonly COLOR_ATTACHMENT3: number;
    ANY_SAMPLES_PASSED_CONSERVATIVE: number;
    ANY_SAMPLES_PASSED: number;
    QUERY_RESULT_AVAILABLE: number;
    QUERY_RESULT: number;
}
interface Document {
    mozCancelFullScreen(): void;
    msCancelFullScreen(): void;
    mozFullScreen: boolean;
    msIsFullScreen: boolean;
    fullscreen: boolean;
    mozPointerLockElement: HTMLElement;
    msPointerLockElement: HTMLElement;
    webkitPointerLockElement: HTMLElement;
}
interface HTMLCanvasElement {
    msRequestPointerLock?(): void;
    mozRequestPointerLock?(): void;
    webkitRequestPointerLock?(): void;
}
interface CanvasRenderingContext2D {
    msImageSmoothingEnabled: boolean;
}
interface WebGLBuffer {
    references: number;
    capacity: number;
    is32Bits: boolean;
}
interface WebGLProgram {
    transformFeedback?: WebGLTransformFeedback | null;
    __SPECTOR_rebuildProgram?: ((vertexSourceCode: string, fragmentSourceCode: string, onCompiled: (program: WebGLProgram) => void, onError: (message: string) => void) => void) | null;
}
interface MouseEvent {
    mozMovementX: number;
    mozMovementY: number;
    webkitMovementX: number;
    webkitMovementY: number;
    msMovementX: number;
    msMovementY: number;
}
interface Navigator {
    mozGetVRDevices: (any: any) => any;
    webkitGetUserMedia(constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback): void;
    mozGetUserMedia(constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback): void;
    msGetUserMedia(constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback): void;
    webkitGetGamepads(): Gamepad[];
    msGetGamepads(): Gamepad[];
    webkitGamepads(): Gamepad[];
}
interface HTMLVideoElement {
    mozSrcObject: any;
}
interface Screen {
    orientation: string;
    mozOrientation: string;
}
interface Math {
    fround(x: number): number;
    imul(a: number, b: number): number;
}
interface EXT_disjoint_timer_query {
    QUERY_COUNTER_BITS_EXT: number;
    TIME_ELAPSED_EXT: number;
    TIMESTAMP_EXT: number;
    GPU_DISJOINT_EXT: number;
    QUERY_RESULT_EXT: number;
    QUERY_RESULT_AVAILABLE_EXT: number;
    queryCounterEXT(query: WebGLQuery, target: number): void;
    createQueryEXT(): WebGLQuery;
    beginQueryEXT(target: number, query: WebGLQuery): void;
    endQueryEXT(target: number): void;
    getQueryObjectEXT(query: WebGLQuery, target: number): any;
    deleteQueryEXT(query: WebGLQuery): void;
}
interface WebGLUniformLocation {
    _currentState: any;
}

declare module BABYLON {
    /**
     * Node is the basic class for all scene objects (Mesh, Light Camera).
     */
    class Node {
        /**
         * Gets or sets the name of the node
         */
        name: string;
        /**
         * Gets or sets the id of the node
         */
        id: string;
        /**
         * Gets or sets the unique id of the node
         */
        uniqueId: number;
        /**
         * Gets or sets a string used to store user defined state for the node
         */
        state: string;
        /**
         * Gets or sets an object used to store user defined information for the node
         */
        metadata: any;
        /**
         * Gets or sets a boolean used to define if the node must be serialized
         */
        doNotSerialize: boolean;
        /** @hidden */
        _isDisposed: boolean;
        /**
         * Gets a list of Animations associated with the node
         */
        animations: Animation[];
        private _ranges;
        /**
         * Callback raised when the node is ready to be used
         */
        onReady: (node: Node) => void;
        private _isEnabled;
        private _isReady;
        /** @hidden */
        _currentRenderId: number;
        private _parentRenderId;
        protected _childRenderId: number;
        /** @hidden */
        _waitingParentId: Nullable<string>;
        private _scene;
        /** @hidden */
        _cache: any;
        private _parentNode;
        private _children;
        /**
         * Gets a boolean indicating if the node has been disposed
         * @returns true if the node was disposed
         */
        isDisposed(): boolean;
        /**
         * Gets or sets the parent of the node
         */
        parent: Nullable<Node>;
        private _animationPropertiesOverride;
        /**
         * Gets or sets the animation properties override
         */
        animationPropertiesOverride: Nullable<AnimationPropertiesOverride>;
        /**
         * Gets a string idenfifying the name of the class
         * @returns "Node" string
         */
        getClassName(): string;
        /**
        * An event triggered when the mesh is disposed
        */
        onDisposeObservable: Observable<Node>;
        private _onDisposeObserver;
        /**
         * Sets a callback that will be raised when the node will be disposed
         */
        onDispose: () => void;
        /**
         * Creates a new Node
         * @param {string} name - the name and id to be given to this node
         * @param {BABYLON.Scene} the scene this node will be added to
         */
        constructor(name: string, scene?: Nullable<Scene>);
        /**
         * Gets the scene of the node
         * @returns a {BABYLON.Scene}
         */
        getScene(): Scene;
        /**
         * Gets the engine of the node
         * @returns a {BABYLON.Engine}
         */
        getEngine(): Engine;
        private _behaviors;
        /**
         * Attach a behavior to the node
         * @see http://doc.babylonjs.com/features/behaviour
         * @param behavior defines the behavior to attach
         * @returns the current Node
         */
        addBehavior(behavior: Behavior<Node>): Node;
        /**
         * Remove an attached behavior
         * @see http://doc.babylonjs.com/features/behaviour
         * @param behavior defines the behavior to attach
         * @returns the current Node
         */
        removeBehavior(behavior: Behavior<Node>): Node;
        /**
         * Gets the list of attached behaviors
         * @see http://doc.babylonjs.com/features/behaviour
         */
        readonly behaviors: Behavior<Node>[];
        /**
         * Gets an attached behavior by name
         * @param name defines the name of the behavior to look for
         * @see http://doc.babylonjs.com/features/behaviour
         * @returns null if behavior was not found else the requested behavior
         */
        getBehaviorByName(name: string): Nullable<Behavior<Node>>;
        /**
         * Returns the world matrix of the node
         * @returns a matrix containing the node's world matrix
         */
        getWorldMatrix(): Matrix;
        /** @hidden */
        _getWorldMatrixDeterminant(): number;
        /** @hidden */
        _initCache(): void;
        /** @hidden */
        updateCache(force?: boolean): void;
        /** @hidden */
        _updateCache(ignoreParentClass?: boolean): void;
        /** @hidden */
        _isSynchronized(): boolean;
        /** @hidden */
        _markSyncedWithParent(): void;
        /** @hidden */
        isSynchronizedWithParent(): boolean;
        /** @hidden */
        isSynchronized(updateCache?: boolean): boolean;
        /** @hidden */
        hasNewParent(update?: boolean): boolean;
        /**
         * Is this node ready to be used/rendered
         * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)
         * @return true if the node is ready
         */
        isReady(completeCheck?: boolean): boolean;
        /**
         * Is this node enabled?
         * If the node has a parent, all ancestors will be checked and false will be returned if any are false (not enabled), otherwise will return true
         * @param checkAncestors indicates if this method should check the ancestors. The default is to check the ancestors. If set to false, the method will return the value of this node without checking ancestors
         * @return whether this node (and its parent) is enabled
         */
        isEnabled(checkAncestors?: boolean): boolean;
        /**
         * Set the enabled state of this node
         * @param value defines the new enabled state
         */
        setEnabled(value: boolean): void;
        /**
         * Is this node a descendant of the given node?
         * The function will iterate up the hierarchy until the ancestor was found or no more parents defined
         * @param ancestor defines the parent node to inspect
         * @returns a boolean indicating if this node is a descendant of the given node
         */
        isDescendantOf(ancestor: Node): boolean;
        /** @hidden */
        _getDescendants(results: Node[], directDescendantsOnly?: boolean, predicate?: (node: Node) => boolean): void;
        /**
         * Will return all nodes that have this node as ascendant
         * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered
         * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
         * @return all children nodes of all types
         */
        getDescendants(directDescendantsOnly?: boolean, predicate?: (node: Node) => boolean): Node[];
        /**
         * Get all child-meshes of this node
         * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered
         * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
         * @returns an array of {BABYLON.AbstractMesh}
         */
        getChildMeshes(directDescendantsOnly?: boolean, predicate?: (node: Node) => boolean): AbstractMesh[];
        /**
         * Get all child-transformNodes of this node
         * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered
         * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
         * @returns an array of {BABYLON.TransformNode}
         */
        getChildTransformNodes(directDescendantsOnly?: boolean, predicate?: (node: Node) => boolean): TransformNode[];
        /**
         * Get all direct children of this node
         * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
         * @returns an array of {BABYLON.Node}
         */
        getChildren(predicate?: (node: Node) => boolean): Node[];
        /** @hidden */
        _setReady(state: boolean): void;
        /**
         * Get an animation by name
         * @param name defines the name of the animation to look for
         * @returns null if not found else the requested animation
         */
        getAnimationByName(name: string): Nullable<Animation>;
        /**
         * Creates an animation range for this node
         * @param name defines the name of the range
         * @param from defines the starting key
         * @param to defines the end key
         */
        createAnimationRange(name: string, from: number, to: number): void;
        /**
         * Delete a specific animation range
         * @param name defines the name of the range to delete
         * @param deleteFrames defines if animation frames from the range must be deleted as well
         */
        deleteAnimationRange(name: string, deleteFrames?: boolean): void;
        /**
         * Get an animation range by name
         * @param name defines the name of the animation range to look for
         * @returns null if not found else the requested animation range
         */
        getAnimationRange(name: string): Nullable<AnimationRange>;
        /**
         * Will start the animation sequence
         * @param name defines the range frames for animation sequence
         * @param loop defines if the animation should loop (false by default)
         * @param speedRatio defines the speed factor in which to run the animation (1 by default)
         * @param onAnimationEnd defines a function to be executed when the animation ended (undefined by default)
         * @returns the object created for this animation. If range does not exist, it will return null
         */
        beginAnimation(name: string, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void): Nullable<Animatable>;
        /**
         * Serialize animation ranges into a JSON compatible object
         * @returns serialization object
         */
        serializeAnimationRanges(): any;
        /**
         * Computes the world matrix of the node
         * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch
         * @returns the world matrix
         */
        computeWorldMatrix(force?: boolean): Matrix;
        /**
         * Releases resources associated with this node.
         * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
         * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
         */
        dispose(doNotRecurse?: boolean, disposeMaterialAndTextures?: boolean): void;
        /**
         * Parse animation range data from a serialization object and store them into a given node
         * @param node defines where to store the animation ranges
         * @param parsedNode defines the serialization object to read data from
         * @param scene defines the hosting scene
         */
        static ParseAnimationRanges(node: Node, parsedNode: any, scene: Scene): void;
    }
}

declare module BABYLON {
    /**
     * Define an interface for all classes that will hold resources
     */
    interface IDisposable {
        /**
         * Releases all held resources
         */
        dispose(): void;
    }
    /**
     * Interface used to let developers provide their own mesh selection mechanism
     */
    interface IActiveMeshCandidateProvider {
        /**
         * Return the list of active meshes
         * @param scene defines the current scene
         * @returns the list of active meshes
         */
        getMeshes(scene: Scene): AbstractMesh[];
        /**
         * Indicates if the meshes have been checked to make sure they are isEnabled()
         */
        readonly checksIsEnabled: boolean;
    }
    /**
     * This class is used by the onRenderingGroupObservable
     */
    class RenderingGroupInfo {
        /**
         * The Scene that being rendered
         */
        scene: Scene;
        /**
         * The camera currently used for the rendering pass
         */
        camera: Nullable<Camera>;
        /**
         * The ID of the renderingGroup being processed
         */
        renderingGroupId: number;
        /**
         * The rendering stage, can be either STAGE_PRECLEAR, STAGE_PREOPAQUE, STAGE_PRETRANSPARENT, STAGE_POSTTRANSPARENT
         */
        renderStage: number;
        /**
         * Stage corresponding to the very first hook in the renderingGroup phase: before the render buffer may be cleared
         * This stage will be fired no matter what
         */
        static STAGE_PRECLEAR: number;
        /**
         * Called before opaque object are rendered.
         * This stage will be fired only if there's 3D Opaque content to render
         */
        static STAGE_PREOPAQUE: number;
        /**
         * Called after the opaque objects are rendered and before the transparent ones
         * This stage will be fired only if there's 3D transparent content to render
         */
        static STAGE_PRETRANSPARENT: number;
        /**
         * Called after the transparent object are rendered, last hook of the renderingGroup phase
         * This stage will be fired no matter what
         */
        static STAGE_POSTTRANSPARENT: number;
    }
    /**
     * Represents a scene to be rendered by the engine.
     * @see http://doc.babylonjs.com/features/scene
     */
    class Scene implements IAnimatable {
        private static _FOGMODE_NONE;
        private static _FOGMODE_EXP;
        private static _FOGMODE_EXP2;
        private static _FOGMODE_LINEAR;
        private static _uniqueIdCounter;
        /**
         * Gets or sets the minimum deltatime when deterministic lock step is enabled
         * @see http://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         */
        static MinDeltaTime: number;
        /**
         * Gets or sets the maximum deltatime when deterministic lock step is enabled
         * @see http://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         */
        static MaxDeltaTime: number;
        /** The fog is deactivated */
        static readonly FOGMODE_NONE: number;
        /** The fog density is following an exponential function */
        static readonly FOGMODE_EXP: number;
        /** The fog density is following an exponential function faster than FOGMODE_EXP */
        static readonly FOGMODE_EXP2: number;
        /** The fog density is following a linear function. */
        static readonly FOGMODE_LINEAR: number;
        /**
         * Gets or sets a boolean that indicates if the scene must clear the render buffer before rendering a frame
         */
        autoClear: boolean;
        /**
         * Gets or sets a boolean that indicates if the scene must clear the depth and stencil buffers before rendering a frame
         */
        autoClearDepthAndStencil: boolean;
        /**
         * Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))
         */
        clearColor: Color4;
        /**
         * Defines the color used to simulate the ambient color (Default is (0, 0, 0))
         */
        ambientColor: Color3;
        /** @hidden */
        _environmentBRDFTexture: BaseTexture;
        /** @hidden */
        protected _environmentTexture: BaseTexture;
        /**
         * Texture used in all pbr material as the reflection texture.
         * As in the majority of the scene they are the same (exception for multi room and so on),
         * this is easier to reference from here than from all the materials.
         */
        /**
         * Texture used in all pbr material as the reflection texture.
         * As in the majority of the scene they are the same (exception for multi room and so on),
         * this is easier to set here than in all the materials.
         */
        environmentTexture: BaseTexture;
        /** @hidden */
        protected _imageProcessingConfiguration: ImageProcessingConfiguration;
        /**
         * Default image processing configuration used either in the rendering
         * Forward main pass or through the imageProcessingPostProcess if present.
         * As in the majority of the scene they are the same (exception for multi camera),
         * this is easier to reference from here than from all the materials and post process.
         *
         * No setter as we it is a shared configuration, you can set the values instead.
         */
        readonly imageProcessingConfiguration: ImageProcessingConfiguration;
        private _forceWireframe;
        /**
         * Gets or sets a boolean indicating if all rendering must be done in wireframe
         */
        forceWireframe: boolean;
        private _forcePointsCloud;
        /**
         * Gets or sets a boolean indicating if all rendering must be done in point cloud
         */
        forcePointsCloud: boolean;
        /**
         * Gets or sets a boolean indicating if all bounding boxes must be rendered
         */
        forceShowBoundingBoxes: boolean;
        /**
         * Gets or sets the active clipplane
         */
        clipPlane: Nullable<Plane>;
        /**
         * Gets or sets a boolean indicating if animations are enabled
         */
        animationsEnabled: boolean;
        private _animationPropertiesOverride;
        /**
         * Gets or sets the animation properties override
         */
        animationPropertiesOverride: Nullable<AnimationPropertiesOverride>;
        /**
         * Gets or sets a boolean indicating if a constant deltatime has to be used
         * This is mostly useful for testing purposes when you do not want the animations to scale with the framerate
         */
        useConstantAnimationDeltaTime: boolean;
        /**
         * Gets or sets a boolean indicating if the scene must keep the meshUnderPointer property updated
         * Please note that it requires to run a ray cast through the scene on every frame
         */
        constantlyUpdateMeshUnderPointer: boolean;
        /**
         * Defines the HTML cursor to use when hovering over interactive elements
         */
        hoverCursor: string;
        /**
         * Defines the HTML default cursor to use (empty by default)
         */
        defaultCursor: string;
        /**
         * This is used to call preventDefault() on pointer down
         * in order to block unwanted artifacts like system double clicks
         */
        preventDefaultOnPointerDown: boolean;
        /**
         * Gets or sets user defined metadata
         */
        metadata: any;
        /**
         * Gets the name of the plugin used to load this scene (null by default)
         */
        loadingPluginName: string;
        /**
         * Use this array to add regular expressions used to disable offline support for specific urls
         */
        disableOfflineSupportExceptionRules: RegExp[];
        private _spritePredicate;
        /**
        * An event triggered when the scene is disposed.
        */
        onDisposeObservable: Observable<Scene>;
        private _onDisposeObserver;
        /** Sets a function to be executed when this scene is disposed. */
        onDispose: () => void;
        /**
        * An event triggered before rendering the scene (right after animations and physics)
        */
        onBeforeRenderObservable: Observable<Scene>;
        private _onBeforeRenderObserver;
        /** Sets a function to be executed before rendering this scene */
        beforeRender: Nullable<() => void>;
        /**
        * An event triggered after rendering the scene
        */
        onAfterRenderObservable: Observable<Scene>;
        private _onAfterRenderObserver;
        /** Sets a function to be executed after rendering this scene */
        afterRender: Nullable<() => void>;
        /**
        * An event triggered before animating the scene
        */
        onBeforeAnimationsObservable: Observable<Scene>;
        /**
        * An event triggered after animations processing
        */
        onAfterAnimationsObservable: Observable<Scene>;
        /**
        * An event triggered before draw calls are ready to be sent
        */
        onBeforeDrawPhaseObservable: Observable<Scene>;
        /**
        * An event triggered after draw calls have been sent
        */
        onAfterDrawPhaseObservable: Observable<Scene>;
        /**
        * An event triggered when physic simulation is about to be run
        */
        onBeforePhysicsObservable: Observable<Scene>;
        /**
        * An event triggered when physic simulation has been done
        */
        onAfterPhysicsObservable: Observable<Scene>;
        /**
        * An event triggered when the scene is ready
        */
        onReadyObservable: Observable<Scene>;
        /**
        * An event triggered before rendering a camera
        */
        onBeforeCameraRenderObservable: Observable<Camera>;
        private _onBeforeCameraRenderObserver;
        /** Sets a function to be executed before rendering a camera*/
        beforeCameraRender: () => void;
        /**
        * An event triggered after rendering a camera
        */
        onAfterCameraRenderObservable: Observable<Camera>;
        private _onAfterCameraRenderObserver;
        /** Sets a function to be executed after rendering a camera*/
        afterCameraRender: () => void;
        /**
        * An event triggered when active meshes evaluation is about to start
        */
        onBeforeActiveMeshesEvaluationObservable: Observable<Scene>;
        /**
        * An event triggered when active meshes evaluation is done
        */
        onAfterActiveMeshesEvaluationObservable: Observable<Scene>;
        /**
        * An event triggered when particles rendering is about to start
        * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)
        */
        onBeforeParticlesRenderingObservable: Observable<Scene>;
        /**
        * An event triggered when particles rendering is done
        * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)
        */
        onAfterParticlesRenderingObservable: Observable<Scene>;
        /**
        * An event triggered when sprites rendering is about to start
        * Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)
        */
        onBeforeSpritesRenderingObservable: Observable<Scene>;
        /**
        * An event triggered when sprites rendering is done
        * Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)
        */
        onAfterSpritesRenderingObservable: Observable<Scene>;
        /**
        * An event triggered when SceneLoader.Append or SceneLoader.Load or SceneLoader.ImportMesh were successfully executed
        */
        onDataLoadedObservable: Observable<Scene>;
        /**
        * An event triggered when a camera is created
        */
        onNewCameraAddedObservable: Observable<Camera>;
        /**
        * An event triggered when a camera is removed
        */
        onCameraRemovedObservable: Observable<Camera>;
        /**
        * An event triggered when a light is created
        */
        onNewLightAddedObservable: Observable<Light>;
        /**
        * An event triggered when a light is removed
        */
        onLightRemovedObservable: Observable<Light>;
        /**
        * An event triggered when a geometry is created
        */
        onNewGeometryAddedObservable: Observable<Geometry>;
        /**
        * An event triggered when a geometry is removed
        */
        onGeometryRemovedObservable: Observable<Geometry>;
        /**
        * An event triggered when a transform node is created
        */
        onNewTransformNodeAddedObservable: Observable<TransformNode>;
        /**
        * An event triggered when a transform node is removed
        */
        onTransformNodeRemovedObservable: Observable<TransformNode>;
        /**
        * An event triggered when a mesh is created
        */
        onNewMeshAddedObservable: Observable<AbstractMesh>;
        /**
        * An event triggered when a mesh is removed
        */
        onMeshRemovedObservable: Observable<AbstractMesh>;
        /**
        * An event triggered when render targets are about to be rendered
        * Can happen multiple times per frame.
        */
        onBeforeRenderTargetsRenderObservable: Observable<Scene>;
        /**
        * An event triggered when render targets were rendered.
        * Can happen multiple times per frame.
        */
        onAfterRenderTargetsRenderObservable: Observable<Scene>;
        /**
        * An event triggered before calculating deterministic simulation step
        */
        onBeforeStepObservable: Observable<Scene>;
        /**
        * An event triggered after calculating deterministic simulation step
        */
        onAfterStepObservable: Observable<Scene>;
        /**
         * This Observable will be triggered for each stage of each renderingGroup of each rendered camera.
         * The RenderinGroupInfo class contains all the information about the context in which the observable is called
         * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)
         */
        onRenderingGroupObservable: Observable<RenderingGroupInfo>;
        /**
         * Gets a list of Animations associated with the scene
         */
        animations: Animation[];
        private _registeredForLateAnimationBindings;
        /**
         * Gets or sets a predicate used to select candidate meshes for a pointer down event
         */
        pointerDownPredicate: (Mesh: AbstractMesh) => boolean;
        /**
         * Gets or sets a predicate used to select candidate meshes for a pointer up event
         */
        pointerUpPredicate: (Mesh: AbstractMesh) => boolean;
        /**
         * Gets or sets a predicate used to select candidate meshes for a pointer move event
         */
        pointerMovePredicate: (Mesh: AbstractMesh) => boolean;
        private _onPointerMove;
        private _onPointerDown;
        private _onPointerUp;
        /** Deprecated. Use onPointerObservable instead */
        onPointerMove: (evt: PointerEvent, pickInfo: PickingInfo, type: PointerEventTypes) => void;
        /** Deprecated. Use onPointerObservable instead */
        onPointerDown: (evt: PointerEvent, pickInfo: PickingInfo, type: PointerEventTypes) => void;
        /** Deprecated. Use onPointerObservable instead */
        onPointerUp: (evt: PointerEvent, pickInfo: Nullable<PickingInfo>, type: PointerEventTypes) => void;
        /** Deprecated. Use onPointerObservable instead */
        onPointerPick: (evt: PointerEvent, pickInfo: PickingInfo) => void;
        private _gamepadManager;
        /**
         * Gets the gamepad manager associated with the scene
         * @see http://doc.babylonjs.com/how_to/how_to_use_gamepads
         */
        readonly gamepadManager: GamepadManager;
        /**
         * This observable event is triggered when any ponter event is triggered. It is registered during Scene.attachControl() and it is called BEFORE the 3D engine process anything (mesh/sprite picking for instance).
         * You have the possibility to skip the process and the call to onPointerObservable by setting PointerInfoPre.skipOnPointerObservable to true
         */
        onPrePointerObservable: Observable<PointerInfoPre>;
        /**
         * Observable event triggered each time an input event is received from the rendering canvas
         */
        onPointerObservable: Observable<PointerInfo>;
        /**
         * Gets the pointer coordinates without any translation (ie. straight out of the pointer event)
         */
        readonly unTranslatedPointer: Vector2;
        /** The distance in pixel that you have to move to prevent some events */
        static DragMovementThreshold: number;
        /** Time in milliseconds to wait to raise long press events if button is still pressed */
        static LongPressDelay: number;
        /** Time in milliseconds with two consecutive clicks will be considered as a double click */
        static DoubleClickDelay: number;
        /** If you need to check double click without raising a single click at first click, enable this flag */
        static ExclusiveDoubleClickMode: boolean;
        private _initClickEvent;
        private _initActionManager;
        private _delayedSimpleClick;
        private _delayedSimpleClickTimeout;
        private _previousDelayedSimpleClickTimeout;
        private _meshPickProceed;
        private _previousButtonPressed;
        private _currentPickResult;
        private _previousPickResult;
        private _totalPointersPressed;
        private _doubleClickOccured;
        /** Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position */
        cameraToUseForPointers: Nullable<Camera>;
        private _pointerX;
        private _pointerY;
        private _unTranslatedPointerX;
        private _unTranslatedPointerY;
        private _startingPointerPosition;
        private _previousStartingPointerPosition;
        private _startingPointerTime;
        private _previousStartingPointerTime;
        private _pointerCaptures;
        private _timeAccumulator;
        private _currentStepId;
        private _currentInternalStep;
        /** @hidden */
        _mirroredCameraPosition: Nullable<Vector3>;
        /**
         * This observable event is triggered when any keyboard event si raised and registered during Scene.attachControl()
         * You have the possibility to skip the process and the call to onKeyboardObservable by setting KeyboardInfoPre.skipOnPointerObservable to true
         */
        onPreKeyboardObservable: Observable<KeyboardInfoPre>;
        /**
         * Observable event triggered each time an keyboard event is received from the hosting window
         */
        onKeyboardObservable: Observable<KeyboardInfo>;
        private _onKeyDown;
        private _onKeyUp;
        private _onCanvasFocusObserver;
        private _onCanvasBlurObserver;
        private _useRightHandedSystem;
        /**
        * Gets or sets a boolean indicating if the scene must use right-handed coordinates system
        */
        useRightHandedSystem: boolean;
        /**
         * Sets the step Id used by deterministic lock step
         * @see http://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         * @param newStepId defines the step Id
         */
        setStepId(newStepId: number): void;
        /**
         * Gets the step Id used by deterministic lock step
         * @see http://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         * @returns the step Id
         */
        getStepId(): number;
        /**
         * Gets the internal step used by deterministic lock step
         * @see http://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         * @returns the internal step
         */
        getInternalStep(): number;
        private _fogEnabled;
        /**
        * Gets or sets a boolean indicating if fog is enabled on this scene
        * @see http://doc.babylonjs.com/babylon101/environment#fog
        */
        fogEnabled: boolean;
        private _fogMode;
        /**
        * Gets or sets the fog mode to use
        * @see http://doc.babylonjs.com/babylon101/environment#fog
        */
        fogMode: number;
        /**
        * Gets or sets the fog color to use
        * @see http://doc.babylonjs.com/babylon101/environment#fog
        */
        fogColor: Color3;
        /**
        * Gets or sets the fog density to use
        * @see http://doc.babylonjs.com/babylon101/environment#fog
        */
        fogDensity: number;
        /**
        * Gets or sets the fog start distance to use
        * @see http://doc.babylonjs.com/babylon101/environment#fog
        */
        fogStart: number;
        /**
        * Gets or sets the fog end distance to use
        * @see http://doc.babylonjs.com/babylon101/environment#fog
        */
        fogEnd: number;
        private _shadowsEnabled;
        /**
        * Gets or sets a boolean indicating if shadows are enabled on this scene
        */
        shadowsEnabled: boolean;
        private _lightsEnabled;
        /**
        * Gets or sets a boolean indicating if lights are enabled on this scene
        */
        lightsEnabled: boolean;
        /**
        * All of the lights added to this scene
        * @see http://doc.babylonjs.com/babylon101/lights
        */
        lights: Light[];
        /** All of the cameras added to this scene.
         * @see http://doc.babylonjs.com/babylon101/cameras
         */
        cameras: Camera[];
        /** All of the active cameras added to this scene. */
        activeCameras: Camera[];
        /** The current active camera */
        activeCamera: Nullable<Camera>;
        /**
        * All of the tranform nodes added to this scene
        * @see http://doc.babylonjs.com/how_to/transformnode
        */
        transformNodes: TransformNode[];
        /**
        * All of the (abstract) meshes added to this scene
        */
        meshes: AbstractMesh[];
        /**
        * All of the animation groups added to this scene
        * @see http://doc.babylonjs.com/how_to/group
        */
        animationGroups: AnimationGroup[];
        private _geometries;
        /**
        * All of the materials added to this scene
        * @see http://doc.babylonjs.com/babylon101/materials
        */
        materials: Material[];
        /**
        * All of the multi-materials added to this scene
        * @see http://doc.babylonjs.com/how_to/multi_materials
        */
        multiMaterials: MultiMaterial[];
        private _defaultMaterial;
        /** The default material used on meshes when no material is affected */
        /** The default material used on meshes when no material is affected */
        defaultMaterial: Material;
        private _texturesEnabled;
        /**
        * Gets or sets a boolean indicating if textures are enabled on this scene
        */
        texturesEnabled: boolean;
        /**
        * All of the textures added to this scene
        */
        textures: BaseTexture[];
        /**
        * Gets or sets a boolean indicating if particles are enabled on this scene
        */
        particlesEnabled: boolean;
        /**
        * All of the particle systems added to this scene
        * @see http://doc.babylonjs.com/babylon101/particles
        */
        particleSystems: IParticleSystem[];
        /**
        * Gets or sets a boolean indicating if sprites are enabled on this scene
        */
        spritesEnabled: boolean;
        /**
        * All of the sprite managers added to this scene
        * @see http://doc.babylonjs.com/babylon101/sprites
        */
        spriteManagers: SpriteManager[];
        /**
         * The list of layers (background and foreground) of the scene
         */
        layers: Layer[];
        /**
         * The list of effect layers (highlights/glow) added to the scene
         * @see http://doc.babylonjs.com/how_to/highlight_layer
         * @see http://doc.babylonjs.com/how_to/glow_layer
         */
        effectLayers: EffectLayer[];
        private _skeletonsEnabled;
        /**
        * Gets or sets a boolean indicating if skeletons are enabled on this scene
        */
        skeletonsEnabled: boolean;
        /**
         * The list of skeletons added to the scene
         * @see http://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons
         */
        skeletons: Skeleton[];
        /**
         * The list of morph target managers added to the scene
         * @see http://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh
         */
        morphTargetManagers: MorphTargetManager[];
        /**
        * Gets or sets a boolean indicating if lens flares are enabled on this scene
        */
        lensFlaresEnabled: boolean;
        /**
         * The list of lens flare system added to the scene
         * @see http://doc.babylonjs.com/how_to/how_to_use_lens_flares
         */
        lensFlareSystems: LensFlareSystem[];
        /**
        * Gets or sets a boolean indicating if collisions are enabled on this scene
        * @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
        */
        collisionsEnabled: boolean;
        private _workerCollisions;
        /** @hidden */
        collisionCoordinator: ICollisionCoordinator;
        /**
         * Defines the gravity applied to this scene (used only for collisions)
         * @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
         */
        gravity: Vector3;
        /**
        * Gets or sets a boolean indicating if postprocesses are enabled on this scene
        */
        postProcessesEnabled: boolean;
        /**
         * The list of postprocesses added to the scene
         */
        postProcesses: PostProcess[];
        /**
         * Gets the current postprocess manager
         */
        postProcessManager: PostProcessManager;
        private _postProcessRenderPipelineManager;
        /**
         * Gets the postprocess render pipeline manager
         * @see http://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline
         * @see http://doc.babylonjs.com/how_to/using_default_rendering_pipeline
         */
        readonly postProcessRenderPipelineManager: PostProcessRenderPipelineManager;
        /**
        * Gets or sets a boolean indicating if render targets are enabled on this scene
        */
        renderTargetsEnabled: boolean;
        /**
        * Gets or sets a boolean indicating if next render targets must be dumped as image for debugging purposes
        * We recommend not using it and instead rely on Spector.js: http://spector.babylonjs.com
        */
        dumpNextRenderTargets: boolean;
        /**
         * The list of user defined render targets added to the scene
         */
        customRenderTargets: RenderTargetTexture[];
        /**
         * Defines if texture loading must be delayed
         * If true, textures will only be loaded when they need to be rendered
         */
        useDelayedTextureLoading: boolean;
        /**
         * Gets the list of meshes imported to the scene through SceneLoader
         */
        importedMeshesFiles: String[];
        /**
        * Gets or sets a boolean indicating if probes are enabled on this scene
        */
        probesEnabled: boolean;
        /**
         * The list of reflection probes added to the scene
         * @see http://doc.babylonjs.com/how_to/how_to_use_reflection_probes
         */
        reflectionProbes: ReflectionProbe[];
        /**
         * @hidden
         */
        database: Database;
        /**
         * Gets or sets the action manager associated with the scene
         * @see http://doc.babylonjs.com/how_to/how_to_use_actions
        */
        actionManager: ActionManager;
        /** @hidden */
        _actionManagers: ActionManager[];
        private _meshesForIntersections;
        /**
        * Gets or sets a boolean indicating if procedural textures are enabled on this scene
        */
        proceduralTexturesEnabled: boolean;
        /**
         * The list of procedural textures added to the scene
         * @see http://doc.babylonjs.com/how_to/how_to_use_procedural_textures
         */
        proceduralTextures: ProceduralTexture[];
        private _mainSoundTrack;
        /**
         * The list of sound tracks added to the scene
         * @see http://doc.babylonjs.com/how_to/playing_sounds_and_music
         */
        soundTracks: SoundTrack[];
        private _audioEnabled;
        private _headphone;
        /**
         * Gets the main soundtrack associated with the scene
         */
        readonly mainSoundTrack: SoundTrack;
        /**
         * Gets or sets the VRExperienceHelper attached to the scene
         * @see http://doc.babylonjs.com/how_to/webvr_helper
         * @ignorenaming
         */
        VRHelper: VRExperienceHelper;
        /**
         * Gets or sets the simplification queue attached to the scene
         * @see http://doc.babylonjs.com/how_to/in-browser_mesh_simplification
         */
        simplificationQueue: SimplificationQueue;
        private _engine;
        private _totalVertices;
        /** @hidden */
        _activeIndices: PerfCounter;
        /** @hidden */
        _activeParticles: PerfCounter;
        /** @hidden */
        _activeBones: PerfCounter;
        private _animationRatio;
        private _animationTimeLast;
        private _animationTime;
        /**
         * Gets or sets a general scale for animation speed
         * @see https://www.babylonjs-playground.com/#IBU2W7#3
         */
        animationTimeScale: number;
        /** @hidden */
        _cachedMaterial: Nullable<Material>;
        /** @hidden */
        _cachedEffect: Nullable<Effect>;
        /** @hidden */
        _cachedVisibility: Nullable<number>;
        private _renderId;
        private _executeWhenReadyTimeoutId;
        private _intermediateRendering;
        private _viewUpdateFlag;
        private _projectionUpdateFlag;
        private _alternateViewUpdateFlag;
        private _alternateProjectionUpdateFlag;
        /** @hidden */
        _toBeDisposed: SmartArray<Nullable<IDisposable>>;
        private _activeRequests;
        private _pendingData;
        private _isDisposed;
        /**
         * Gets or sets a boolean indicating that all submeshes of active meshes must be rendered
         * Use this boolean to avoid computing frustum clipping on submeshes (This could help when you are CPU bound)
         */
        dispatchAllSubMeshesOfActiveMeshes: boolean;
        private _activeMeshes;
        private _processedMaterials;
        private _renderTargets;
        /** @hidden */
        _activeParticleSystems: SmartArray<IParticleSystem>;
        private _activeSkeletons;
        private _softwareSkinnedMeshes;
        private _renderingManager;
        private _physicsEngine;
        /** @hidden */
        _activeAnimatables: Animatable[];
        private _transformMatrix;
        private _sceneUbo;
        private _alternateSceneUbo;
        private _pickWithRayInverseMatrix;
        private _boundingBoxRenderer;
        private _outlineRenderer;
        private _viewMatrix;
        private _projectionMatrix;
        private _alternateViewMatrix;
        private _alternateProjectionMatrix;
        private _alternateTransformMatrix;
        private _useAlternateCameraConfiguration;
        private _alternateRendering;
        /** @hidden */
        _forcedViewPosition: Nullable<Vector3>;
        /** @hidden */
        readonly _isAlternateRenderingEnabled: boolean;
        private _frustumPlanes;
        /**
         * Gets the list of frustum planes (built from the active camera)
         */
        readonly frustumPlanes: Plane[];
        /**
         * Gets or sets a boolean indicating if lights must be sorted by priority (off by default)
         * This is useful if there are more lights that the maximum simulteanous authorized
         */
        requireLightSorting: boolean;
        private _selectionOctree;
        private _pointerOverMesh;
        private _pointerOverSprite;
        private _debugLayer;
        private _depthRenderer;
        private _geometryBufferRenderer;
        /**
         * Gets the current geometry buffer associated to the scene.
         */
        /**
         * Sets the current geometry buffer for the scene.
         */
        geometryBufferRenderer: Nullable<GeometryBufferRenderer>;
        private _pickedDownMesh;
        private _pickedUpMesh;
        private _pickedDownSprite;
        private _externalData;
        private _uid;
        /**
         * Creates a new Scene
         * @param engine defines the engine to use to render this scene
         */
        constructor(engine: Engine);
        /**
         * Gets the debug layer associated with the scene
         * @see http://doc.babylonjs.com/features/playground_debuglayer
         */
        readonly debugLayer: DebugLayer;
        /**
         * Gets a boolean indicating if collisions are processed on a web worker
         * @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#web-worker-based-collision-system-since-21
         */
        workerCollisions: boolean;
        /**
         * Gets the octree used to boost mesh selection (picking)
         * @see http://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
         */
        readonly selectionOctree: Octree<AbstractMesh>;
        /**
         * Gets the mesh that is currently under the pointer
         */
        readonly meshUnderPointer: Nullable<AbstractMesh>;
        /**
         * Gets the current on-screen X position of the pointer
         */
        readonly pointerX: number;
        /**
         * Gets the current on-screen Y position of the pointer
         */
        readonly pointerY: number;
        /**
         * Gets the cached material (ie. the latest rendered one)
         * @returns the cached material
         */
        getCachedMaterial(): Nullable<Material>;
        /**
         * Gets the cached effect (ie. the latest rendered one)
         * @returns the cached effect
         */
        getCachedEffect(): Nullable<Effect>;
        /**
         * Gets the cached visibility state (ie. the latest rendered one)
         * @returns the cached visibility state
         */
        getCachedVisibility(): Nullable<number>;
        /**
         * Gets a boolean indicating if the current material / effect / visibility must be bind again
         * @param material defines the current material
         * @param effect defines the current effect
         * @param visibility defines the current visibility state
         * @returns true if one parameter is not cached
         */
        isCachedMaterialInvalid(material: Material, effect: Effect, visibility?: number): boolean;
        /**
         * Gets the bounding box renderer associated with the scene
         * @returns a BoundingBoxRenderer
         */
        getBoundingBoxRenderer(): BoundingBoxRenderer;
        /**
         * Gets the outline renderer associated with the scene
         * @returns a OutlineRenderer
         */
        getOutlineRenderer(): OutlineRenderer;
        /**
         * Gets the engine associated with the scene
         * @returns an Engine
         */
        getEngine(): Engine;
        /**
         * Gets the total number of vertices rendered per frame
         * @returns the total number of vertices rendered per frame
         */
        getTotalVertices(): number;
        /**
         * Gets the performance counter for total vertices
         * @see http://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation
         */
        readonly totalVerticesPerfCounter: PerfCounter;
        /**
         * Gets the total number of active indices rendered per frame (You can deduce the number of rendered triangles by dividing this number by 3)
         * @returns the total number of active indices rendered per frame
         */
        getActiveIndices(): number;
        /**
         * Gets the performance counter for active indices
         * @see http://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation
         */
        readonly totalActiveIndicesPerfCounter: PerfCounter;
        /**
         * Gets the total number of active particles rendered per frame
         * @returns the total number of active particles rendered per frame
         */
        getActiveParticles(): number;
        /**
         * Gets the performance counter for active particles
         * @see http://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation
         */
        readonly activeParticlesPerfCounter: PerfCounter;
        /**
         * Gets the total number of active bones rendered per frame
         * @returns the total number of active bones rendered per frame
         */
        getActiveBones(): number;
        /**
         * Gets the performance counter for active bones
         * @see http://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation
         */
        readonly activeBonesPerfCounter: PerfCounter;
        /** @hidden */
        getInterFramePerfCounter(): number;
        /** @hidden */
        readonly interFramePerfCounter: Nullable<PerfCounter>;
        /** @hidden */
        getLastFrameDuration(): number;
        /** @hidden */
        readonly lastFramePerfCounter: Nullable<PerfCounter>;
        /** @hidden */
        getEvaluateActiveMeshesDuration(): number;
        /** @hidden */
        readonly evaluateActiveMeshesDurationPerfCounter: Nullable<PerfCounter>;
        /**
         * Gets the array of active meshes
         * @returns an array of AbstractMesh
         */
        getActiveMeshes(): SmartArray<AbstractMesh>;
        /** @hidden */
        getRenderTargetsDuration(): number;
        /** @hidden */
        getRenderDuration(): number;
        /** @hidden */
        readonly renderDurationPerfCounter: Nullable<PerfCounter>;
        /** @hidden */
        getParticlesDuration(): number;
        /** @hidden */
        readonly particlesDurationPerfCounter: Nullable<PerfCounter>;
        /** @hidden */
        getSpritesDuration(): number;
        /** @hidden */
        readonly spriteDuractionPerfCounter: Nullable<PerfCounter>;
        /**
         * Gets the animation ratio (which is 1.0 is the scene renders at 60fps and 2 if the scene renders at 30fps, etc.)
         * @returns a number
         */
        getAnimationRatio(): number;
        /**
         * Gets an unique Id for the current frame
         * @returns a number
         */
        getRenderId(): number;
        /** Call this function if you want to manually increment the render Id*/
        incrementRenderId(): void;
        private _updatePointerPosition(evt);
        private _createUbo();
        private _createAlternateUbo();
        /**
         * Use this method to simulate a pointer move on a mesh
         * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
         * @param pickResult pickingInfo of the object wished to simulate pointer event on
         * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
         * @returns the current scene
         */
        simulatePointerMove(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): Scene;
        private _processPointerMove(pickResult, evt);
        /**
         * Use this method to simulate a pointer down on a mesh
         * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
         * @param pickResult pickingInfo of the object wished to simulate pointer event on
         * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
         * @returns the current scene
         */
        simulatePointerDown(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): Scene;
        private _processPointerDown(pickResult, evt);
        /**
         * Use this method to simulate a pointer up on a mesh
         * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
         * @param pickResult pickingInfo of the object wished to simulate pointer event on
         * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
         * @returns the current scene
         */
        simulatePointerUp(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): Scene;
        private _processPointerUp(pickResult, evt, clickInfo);
        /**
        * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp
        * @param attachUp defines if you want to attach events to pointerup
        * @param attachDown defines if you want to attach events to pointerdown
        * @param attachMove defines if you want to attach events to pointermove
        */
        attachControl(attachUp?: boolean, attachDown?: boolean, attachMove?: boolean): void;
        /** Detaches all event handlers*/
        detachControl(): void;
        /**
         * This function will check if the scene can be rendered (textures are loaded, shaders are compiled)
         * Delay loaded resources are not taking in account
         * @return true if all required resources are ready
         */
        isReady(): boolean;
        /** Resets all cached information relative to material (including effect and visibility) */
        resetCachedMaterial(): void;
        /**
         * Registers a function to be called before every frame render
         * @param func defines the function to register
         */
        registerBeforeRender(func: () => void): void;
        /**
         * Unregisters a function called before every frame render
         * @param func defines the function to unregister
         */
        unregisterBeforeRender(func: () => void): void;
        /**
         * Registers a function to be called after every frame render
         * @param func defines the function to register
         */
        registerAfterRender(func: () => void): void;
        /**
         * Unregisters a function called after every frame render
         * @param func defines the function to unregister
         */
        unregisterAfterRender(func: () => void): void;
        private _executeOnceBeforeRender(func);
        /**
         * The provided function will run before render once and will be disposed afterwards.
         * A timeout delay can be provided so that the function will be executed in N ms.
         * The timeout is using the browser's native setTimeout so time percision cannot be guaranteed.
         * @param func The function to be executed.
         * @param timeout optional delay in ms
         */
        executeOnceBeforeRender(func: () => void, timeout?: number): void;
        /** @hidden */
        _addPendingData(data: any): void;
        /** @hidden */
        _removePendingData(data: any): void;
        /**
         * Returns the number of items waiting to be loaded
         * @returns the number of items waiting to be loaded
         */
        getWaitingItemsCount(): number;
        /**
         * Returns a boolean indicating if the scene is still loading data
         */
        readonly isLoading: boolean;
        /**
         * Registers a function to be executed when the scene is ready
         * @param {Function} func - the function to be executed
         */
        executeWhenReady(func: () => void): void;
        /**
         * Returns a promise that resolves when the scene is ready
         * @returns A promise that resolves when the scene is ready
         */
        whenReadyAsync(): Promise<void>;
        /** @hidden */
        _checkIsReady(): void;
        /**
         * Will start the animation sequence of a given target
         * @param target defines the target
         * @param from defines from which frame should animation start
         * @param to defines until which frame should animation run.
         * @param weight defines the weight to apply to the animation (1.0 by default)
         * @param loop defines if the animation loops
         * @param speedRatio defines the speed in which to run the animation (1.0 by default)
         * @param onAnimationEnd defines the function to be executed when the animation ends
         * @param animatable defines an animatable object. If not provided a new one will be created from the given params
         * @returns the animatable object created for this animation
         */
        beginWeightedAnimation(target: any, from: number, to: number, weight?: number, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void, animatable?: Animatable): Animatable;
        /**
         * Will start the animation sequence of a given target
         * @param target defines the target
         * @param from defines from which frame should animation start
         * @param to defines until which frame should animation run.
         * @param loop defines if the animation loops
         * @param speedRatio defines the speed in which to run the animation (1.0 by default)
         * @param onAnimationEnd defines the function to be executed when the animation ends
         * @param animatable defines an animatable object. If not provided a new one will be created from the given params
         * @param stopCurrent defines if the current animations must be stopped first (true by default)
         * @returns the animatable object created for this animation
         */
        beginAnimation(target: any, from: number, to: number, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void, animatable?: Animatable, stopCurrent?: boolean): Animatable;
        /**
         * Begin a new animation on a given node
         * @param target defines the target where the animation will take place
         * @param animations defines the list of animations to start
         * @param from defines the initial value
         * @param to defines the final value
         * @param loop defines if you want animation to loop (off by default)
         * @param speedRatio defines the speed ratio to apply to all animations
         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)
         * @returns the list of created animatables
         */
        beginDirectAnimation(target: any, animations: Animation[], from: number, to: number, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void): Animatable;
        /**
         * Begin a new animation on a given node and its hierarchy
         * @param target defines the root node where the animation will take place
         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.
         * @param animations defines the list of animations to start
         * @param from defines the initial value
         * @param to defines the final value
         * @param loop defines if you want animation to loop (off by default)
         * @param speedRatio defines the speed ratio to apply to all animations
         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)
         * @returns the list of animatables created for all nodes
         */
        beginDirectHierarchyAnimation(target: Node, directDescendantsOnly: boolean, animations: Animation[], from: number, to: number, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void): Animatable[];
        /**
         * Gets the animatable associated with a specific target
         * @param target defines the target of the animatable
         * @returns the required animatable if found
         */
        getAnimatableByTarget(target: any): Nullable<Animatable>;
        /**
         * Gets all animatables associated with a given target
         * @param target defines the target to look animatables for
         * @returns an array of Animatables
         */
        getAllAnimatablesByTarget(target: any): Array<Animatable>;
        /**
         * Gets all animatable attached to the scene
         */
        readonly animatables: Animatable[];
        /**
         * Will stop the animation of the given target
         * @param target - the target
         * @param animationName - the name of the animation to stop (all animations will be stopped if empty)
         */
        stopAnimation(target: any, animationName?: string): void;
        /**
         * Stops and removes all animations that have been applied to the scene
         */
        stopAllAnimations(): void;
        private _animate();
        /** @hidden */
        _registerTargetForLateAnimationBinding(runtimeAnimation: RuntimeAnimation, originalValue: any): void;
        private _processLateAnimationBindingsForMatrices(holder);
        private _processLateAnimationBindingsForQuaternions(holder);
        private _processLateAnimationBindings();
        /** @hidden */
        _switchToAlternateCameraConfiguration(active: boolean): void;
        /**
         * Gets the current view matrix
         * @returns a Matrix
         */
        getViewMatrix(): Matrix;
        /**
         * Gets the current projection matrix
         * @returns a Matrix
         */
        getProjectionMatrix(): Matrix;
        /**
         * Gets the current transform matrix
         * @returns a Matrix made of View * Projection
         */
        getTransformMatrix(): Matrix;
        /**
         * Sets the current transform matrix
         * @param view defines the View matrix to use
         * @param projection defines the Projection matrix to use
         */
        setTransformMatrix(view: Matrix, projection: Matrix): void;
        /** @hidden */
        _setAlternateTransformMatrix(view: Matrix, projection: Matrix): void;
        /**
         * Gets the uniform buffer used to store scene data
         * @returns a UniformBuffer
         */
        getSceneUniformBuffer(): UniformBuffer;
        /**
         * Gets an unique (relatively to the current scene) Id
         * @returns an unique number for the scene
         */
        getUniqueId(): number;
        /**
         * Add a mesh to the list of scene's meshes
         * @param newMesh defines the mesh to add
         */
        addMesh(newMesh: AbstractMesh): void;
        /**
           * Remove a mesh for the list of scene's meshes
           * @param toRemove defines the mesh to remove
           * @param recursive if all child meshes should also be removed from the scene
           * @returns the index where the mesh was in the mesh list
           */
        removeMesh(toRemove: AbstractMesh, recursive?: boolean): number;
        /**
         * Add a transform node to the list of scene's transform nodes
         * @param newTransformNode defines the transform node to add
         */
        addTransformNode(newTransformNode: TransformNode): void;
        /**
         * Remove a transform node for the list of scene's transform nodes
         * @param toRemove defines the transform node to remove
         * @returns the index where the transform node was in the transform node list
         */
        removeTransformNode(toRemove: TransformNode): number;
        /**
         * Remove a skeleton for the list of scene's skeletons
         * @param toRemove defines the skeleton to remove
         * @returns the index where the skeleton was in the skeleton list
         */
        removeSkeleton(toRemove: Skeleton): number;
        /**
         * Remove a morph target for the list of scene's morph targets
         * @param toRemove defines the morph target to remove
         * @returns the index where the morph target was in the morph target list
         */
        removeMorphTargetManager(toRemove: MorphTargetManager): number;
        /**
         * Remove a light for the list of scene's lights
         * @param toRemove defines the light to remove
         * @returns the index where the light was in the light list
         */
        removeLight(toRemove: Light): number;
        /**
         * Remove a camera for the list of scene's cameras
         * @param toRemove defines the camera to remove
         * @returns the index where the camera was in the camera list
         */
        removeCamera(toRemove: Camera): number;
        /**
         * Remove a particle system for the list of scene's particle systems
         * @param toRemove defines the particle system to remove
         * @returns the index where the particle system was in the particle system list
         */
        removeParticleSystem(toRemove: IParticleSystem): number;
        /**
         * Remove a animation for the list of scene's animations
         * @param toRemove defines the animation to remove
         * @returns the index where the animation was in the animation list
         */
        removeAnimation(toRemove: Animation): number;
        /**
         * Removes the given animation group from this scene.
         * @param toRemove The animation group to remove
         * @returns The index of the removed animation group
         */
        removeAnimationGroup(toRemove: AnimationGroup): number;
        /**
         * Removes the given multi-material from this scene.
         * @param toRemove The multi-material to remove
         * @returns The index of the removed multi-material
         */
        removeMultiMaterial(toRemove: MultiMaterial): number;
        /**
         * Removes the given material from this scene.
         * @param toRemove The material to remove
         * @returns The index of the removed material
         */
        removeMaterial(toRemove: Material): number;
        /**
         * Removes the given lens flare system from this scene.
         * @param toRemove The lens flare system to remove
         * @returns The index of the removed lens flare system
         */
        removeLensFlareSystem(toRemove: LensFlareSystem): number;
        /**
         * Removes the given action manager from this scene.
         * @param toRemove The action manager to remove
         * @returns The index of the removed action manager
         */
        removeActionManager(toRemove: ActionManager): number;
        /**
         * Removes the given effect layer from this scene.
         * @param toRemove defines the effect layer to remove
         * @returns the index of the removed effect layer
         */
        removeEffectLayer(toRemove: EffectLayer): number;
        /**
         * Removes the given texture from this scene.
         * @param toRemove The texture to remove
         * @returns The index of the removed texture
         */
        removeTexture(toRemove: BaseTexture): number;
        /**
         * Adds the given light to this scene
         * @param newLight The light to add
         */
        addLight(newLight: Light): void;
        /**
         * Sorts the list list based on light priorities
         */
        sortLightsByPriority(): void;
        /**
         * Adds the given camera to this scene
         * @param newCamera The camera to add
         */
        addCamera(newCamera: Camera): void;
        /**
         * Adds the given skeleton to this scene
         * @param newSkeleton The skeleton to add
         */
        addSkeleton(newSkeleton: Skeleton): void;
        /**
         * Adds the given particle system to this scene
         * @param newParticleSystem The particle system to add
         */
        addParticleSystem(newParticleSystem: IParticleSystem): void;
        /**
         * Adds the given animation to this scene
         * @param newAnimation The animation to add
         */
        addAnimation(newAnimation: Animation): void;
        /**
         * Adds the given animation group to this scene.
         * @param newAnimationGroup The animation group to add
         */
        addAnimationGroup(newAnimationGroup: AnimationGroup): void;
        /**
         * Adds the given multi-material to this scene
         * @param newMultiMaterial The multi-material to add
         */
        addMultiMaterial(newMultiMaterial: MultiMaterial): void;
        /**
         * Adds the given material to this scene
         * @param newMaterial The material to add
         */
        addMaterial(newMaterial: Material): void;
        /**
         * Adds the given morph target to this scene
         * @param newMorphTargetManager The morph target to add
         */
        addMorphTargetManager(newMorphTargetManager: MorphTargetManager): void;
        /**
         * Adds the given geometry to this scene
         * @param newGeometry The geometry to add
         */
        addGeometry(newGeometry: Geometry): void;
        /**
         * Adds the given lens flare system to this scene
         * @param newLensFlareSystem The lens flare system to add
         */
        addLensFlareSystem(newLensFlareSystem: LensFlareSystem): void;
        /**
         * Adds the given effect layer to this scene
         * @param newEffectLayer defines the effect layer to add
         */
        addEffectLayer(newEffectLayer: EffectLayer): void;
        /**
         * Adds the given action manager to this scene
         * @param newActionManager The action manager to add
         */
        addActionManager(newActionManager: ActionManager): void;
        /**
         * Adds the given texture to this scene.
         * @param newTexture The texture to add
         */
        addTexture(newTexture: BaseTexture): void;
        /**
         * Switch active camera
         * @param newCamera defines the new active camera
         * @param attachControl defines if attachControl must be called for the new active camera (default: true)
         */
        switchActiveCamera(newCamera: Camera, attachControl?: boolean): void;
        /**
         * sets the active camera of the scene using its ID
         * @param id defines the camera's ID
         * @return the new active camera or null if none found.
         */
        setActiveCameraByID(id: string): Nullable<Camera>;
        /**
         * sets the active camera of the scene using its name
         * @param name defines the camera's name
         * @returns the new active camera or null if none found.
         */
        setActiveCameraByName(name: string): Nullable<Camera>;
        /**
         * get an animation group using its name
         * @param name defines the material's name
         * @return the animation group or null if none found.
         */
        getAnimationGroupByName(name: string): Nullable<AnimationGroup>;
        /**
         * get a material using its id
         * @param id defines the material's ID
         * @return the material or null if none found.
         */
        getMaterialByID(id: string): Nullable<Material>;
        /**
         * Gets a material using its name
         * @param name defines the material's name
         * @return the material or null if none found.
         */
        getMaterialByName(name: string): Nullable<Material>;
        /**
         * Gets a lens flare system using its name
         * @param name defines the name to look for
         * @returns the lens flare system or null if not found
         */
        getLensFlareSystemByName(name: string): Nullable<LensFlareSystem>;
        /**
         * Gets a lens flare system using its id
         * @param id defines the id to look for
         * @returns the lens flare system or null if not found
         */
        getLensFlareSystemByID(id: string): Nullable<LensFlareSystem>;
        /**
         * Gets a camera using its id
         * @param id defines the id to look for
         * @returns the camera or null if not found
         */
        getCameraByID(id: string): Nullable<Camera>;
        /**
         * Gets a camera using its unique id
         * @param uniqueId defines the unique id to look for
         * @returns the camera or null if not found
         */
        getCameraByUniqueID(uniqueId: number): Nullable<Camera>;
        /**
         * Gets a camera using its name
         * @param name defines the camera's name
         * @return the camera or null if none found.
         */
        getCameraByName(name: string): Nullable<Camera>;
        /**
         * Gets a bone using its id
         * @param id defines the bone's id
         * @return the bone or null if not found
         */
        getBoneByID(id: string): Nullable<Bone>;
        /**
        * Gets a bone using its id
        * @param name defines the bone's name
        * @return the bone or null if not found
        */
        getBoneByName(name: string): Nullable<Bone>;
        /**
         * Gets a light node using its name
         * @param name defines the the light's name
         * @return the light or null if none found.
         */
        getLightByName(name: string): Nullable<Light>;
        /**
         * Gets a light node using its id
         * @param id defines the light's id
         * @return the light or null if none found.
         */
        getLightByID(id: string): Nullable<Light>;
        /**
         * Gets a light node using its scene-generated unique ID
         * @param uniqueId defines the light's unique id
         * @return the light or null if none found.
         */
        getLightByUniqueID(uniqueId: number): Nullable<Light>;
        /**
         * Gets a particle system by id
         * @param id defines the particle system id
         * @return the corresponding system or null if none found
         */
        getParticleSystemByID(id: string): Nullable<IParticleSystem>;
        /**
         * Gets a geometry using its ID
         * @param id defines the geometry's id
         * @return the geometry or null if none found.
         */
        getGeometryByID(id: string): Nullable<Geometry>;
        /**
         * Add a new geometry to this scene
         * @param geometry defines the geometry to be added to the scene.
         * @param force defines if the geometry must be pushed even if a geometry with this id already exists
         * @return a boolean defining if the geometry was added or not
         */
        pushGeometry(geometry: Geometry, force?: boolean): boolean;
        /**
         * Removes an existing geometry
         * @param geometry defines the geometry to be removed from the scene
         * @return a boolean defining if the geometry was removed or not
         */
        removeGeometry(geometry: Geometry): boolean;
        /**
         * Gets the list of geometries attached to the scene
         * @returns an array of Geometry
         */
        getGeometries(): Geometry[];
        /**
         * Gets the first added mesh found of a given ID
         * @param id defines the id to search for
         * @return the mesh found or null if not found at all
         */
        getMeshByID(id: string): Nullable<AbstractMesh>;
        /**
         * Gets a list of meshes using their id
         * @param id defines the id to search for
         * @returns a list of meshes
         */
        getMeshesByID(id: string): Array<AbstractMesh>;
        /**
         * Gets the first added transform node found of a given ID
         * @param id defines the id to search for
         * @return the found transform node or null if not found at all.
         */
        getTransformNodeByID(id: string): Nullable<TransformNode>;
        /**
         * Gets a list of transform nodes using their id
         * @param id defines the id to search for
         * @returns a list of transform nodes
         */
        getTransformNodesByID(id: string): Array<TransformNode>;
        /**
         * Gets a mesh with its auto-generated unique id
         * @param uniqueId defines the unique id to search for
         * @return the found mesh or null if not found at all.
         */
        getMeshByUniqueID(uniqueId: number): Nullable<AbstractMesh>;
        /**
         * Gets a the last added mesh using a given id
         * @param id defines the id to search for
         * @return the found mesh or null if not found at all.
         */
        getLastMeshByID(id: string): Nullable<AbstractMesh>;
        /**
         * Gets a the last added node (Mesh, Camera, Light) using a given id
         * @param id defines the id to search for
         * @return the found node or null if not found at all
         */
        getLastEntryByID(id: string): Nullable<Node>;
        /**
         * Gets a node (Mesh, Camera, Light) using a given id
         * @param id defines the id to search for
         * @return the found node or null if not found at all
         */
        getNodeByID(id: string): Nullable<Node>;
        /**
         * Gets a node (Mesh, Camera, Light) using a given name
         * @param name defines the name to search for
         * @return the found node or null if not found at all.
         */
        getNodeByName(name: string): Nullable<Node>;
        /**
         * Gets a mesh using a given name
         * @param name defines the name to search for
         * @return the found mesh or null if not found at all.
         */
        getMeshByName(name: string): Nullable<AbstractMesh>;
        /**
         * Gets a transform node using a given name
         * @param name defines the name to search for
         * @return the found transform node or null if not found at all.
         */
        getTransformNodeByName(name: string): Nullable<TransformNode>;
        /**
         * Gets a sound using a given name
         * @param name defines the name to search for
         * @return the found sound or null if not found at all.
         */
        getSoundByName(name: string): Nullable<Sound>;
        /**
         * Gets a skeleton using a given id (if many are found, this function will pick the last one)
         * @param id defines the id to search for
         * @return the found skeleton or null if not found at all.
         */
        getLastSkeletonByID(id: string): Nullable<Skeleton>;
        /**
         * Gets a skeleton using a given id (if many are found, this function will pick the first one)
         * @param id defines the id to search for
         * @return the found skeleton or null if not found at all.
         */
        getSkeletonById(id: string): Nullable<Skeleton>;
        /**
         * Gets a skeleton using a given name
         * @param name defines the name to search for
         * @return the found skeleton or null if not found at all.
         */
        getSkeletonByName(name: string): Nullable<Skeleton>;
        /**
         * Gets a morph target manager  using a given id (if many are found, this function will pick the last one)
         * @param id defines the id to search for
         * @return the found morph target manager or null if not found at all.
         */
        getMorphTargetManagerById(id: number): Nullable<MorphTargetManager>;
        /**
         * Gets a boolean indicating if the given mesh is active
         * @param mesh defines the mesh to look for
         * @returns true if the mesh is in the active list
         */
        isActiveMesh(mesh: AbstractMesh): boolean;
        /**
         * Return a the first highlight layer of the scene with a given name.
         * @param name The name of the highlight layer to look for.
         * @return The highlight layer if found otherwise null.
         */
        getHighlightLayerByName(name: string): Nullable<HighlightLayer>;
        /**
         * Return a the first highlight layer of the scene with a given name.
         * @param name The name of the highlight layer to look for.
         * @return The highlight layer if found otherwise null.
         */
        getGlowLayerByName(name: string): Nullable<GlowLayer>;
        /**
         * Return a unique id as a string which can serve as an identifier for the scene
         */
        readonly uid: string;
        /**
         * Add an externaly attached data from its key.
         * This method call will fail and return false, if such key already exists.
         * If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.
         * @param key the unique key that identifies the data
         * @param data the data object to associate to the key for this Engine instance
         * @return true if no such key were already present and the data was added successfully, false otherwise
         */
        addExternalData<T>(key: string, data: T): boolean;
        /**
         * Get an externaly attached data from its key
         * @param key the unique key that identifies the data
         * @return the associated data, if present (can be null), or undefined if not present
         */
        getExternalData<T>(key: string): Nullable<T>;
        /**
         * Get an externaly attached data from its key, create it using a factory if it's not already present
         * @param key the unique key that identifies the data
         * @param factory the factory that will be called to create the instance if and only if it doesn't exists
         * @return the associated data, can be null if the factory returned null.
         */
        getOrAddExternalDataWithFactory<T>(key: string, factory: (k: string) => T): T;
        /**
         * Remove an externaly attached data from the Engine instance
         * @param key the unique key that identifies the data
         * @return true if the data was successfully removed, false if it doesn't exist
         */
        removeExternalData(key: string): boolean;
        private _evaluateSubMesh(subMesh, mesh);
        /**
         * Clear the processed materials smart array preventing retention point in material dispose.
         */
        freeProcessedMaterials(): void;
        /**
         * Clear the active meshes smart array preventing retention point in mesh dispose.
         */
        freeActiveMeshes(): void;
        /**
         * Clear the info related to rendering groups preventing retention points during dispose.
         */
        freeRenderingGroups(): void;
        /** @hidden */
        _isInIntermediateRendering(): boolean;
        private _activeMeshCandidateProvider;
        /**
         * Defines the current active mesh candidate provider
         * @param provider defines the provider to use
         */
        setActiveMeshCandidateProvider(provider: IActiveMeshCandidateProvider): void;
        /**
         * Gets the current active mesh candidate provider
         * @returns the current active mesh candidate provider
         */
        getActiveMeshCandidateProvider(): IActiveMeshCandidateProvider;
        private _activeMeshesFrozen;
        /**
         * Use this function to stop evaluating active meshes. The current list will be keep alive between frames
         * @returns the current scene
         */
        freezeActiveMeshes(): Scene;
        /**
         * Use this function to restart evaluating active meshes on every frame
         * @returns the current scene
         */
        unfreezeActiveMeshes(): Scene;
        private _evaluateActiveMeshes();
        private _activeMesh(sourceMesh, mesh);
        /**
         * Update the transform matrix to update from the current active camera
         * @param force defines a boolean used to force the update even if cache is up to date
         */
        updateTransformMatrix(force?: boolean): void;
        /**
         * Defines an alternate camera (used mostly in VR-like scenario where two cameras can render the same scene from a slightly different point of view)
         * @param alternateCamera defines the camera to use
         */
        updateAlternateTransformMatrix(alternateCamera: Camera): void;
        private _renderForCamera(camera, rigParent?);
        private _processSubCameras(camera);
        private _checkIntersections();
        /**
         * Render the scene
         */
        render(): void;
        private _updateAudioParameters();
        /**
         * Gets or sets if audio support is enabled
         * @see http://doc.babylonjs.com/how_to/playing_sounds_and_music
         */
        audioEnabled: boolean;
        private _disableAudio();
        private _enableAudio();
        /**
         * Gets or sets if audio will be output to headphones
         * @see http://doc.babylonjs.com/how_to/playing_sounds_and_music
         */
        headphone: boolean;
        private _switchAudioModeForHeadphones();
        private _switchAudioModeForNormalSpeakers();
        /**
         * Creates a depth renderer a given camera which contains a depth map which can be used for post processing.
         * @param camera The camera to create the depth renderer on (default: scene's active camera)
         * @returns the created depth renderer
         */
        enableDepthRenderer(camera?: Nullable<Camera>): DepthRenderer;
        /**
         * Disables a depth renderer for a given camera
         * @param camera The camera to disable the depth renderer on (default: scene's active camera)
         */
        disableDepthRenderer(camera?: Nullable<Camera>): void;
        /**
         * Enables a GeometryBufferRender and associates it with the scene
         * @param ratio defines the scaling ratio to apply to the renderer (1 by default which means same resolution)
         * @returns the GeometryBufferRenderer
         */
        enableGeometryBufferRenderer(ratio?: number): Nullable<GeometryBufferRenderer>;
        /**
         * Disables the GeometryBufferRender associated with the scene
         */
        disableGeometryBufferRenderer(): void;
        /**
         * Freeze all materials
         * A frozen material will not be updatable but should be faster to render
         */
        freezeMaterials(): void;
        /**
         * Unfreeze all materials
         * A frozen material will not be updatable but should be faster to render
         */
        unfreezeMaterials(): void;
        /**
         * Releases all held ressources
         */
        dispose(): void;
        /**
         * Gets if the scene is already disposed
         */
        readonly isDisposed: boolean;
        /**
         *  Releases sounds & soundtracks
         */
        disposeSounds(): void;
        /**
         * Get the world extend vectors with an optional filter
         *
         * @param filterPredicate the predicate - which meshes should be included when calculating the world size
         * @returns {{ min: Vector3; max: Vector3 }} min and max vectors
         */
        getWorldExtends(filterPredicate?: (mesh: AbstractMesh) => boolean): {
            min: Vector3;
            max: Vector3;
        };
        /**
         * Creates or updates the octree used to boost selection (picking)
         * @see http://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
         * @param maxCapacity defines the maximum capacity per leaf
         * @param maxDepth defines the maximum depth of the octree
         * @returns an octree of AbstractMesh
         */
        createOrUpdateSelectionOctree(maxCapacity?: number, maxDepth?: number): Octree<AbstractMesh>;
        /**
         * Creates a ray that can be used to pick in the scene
         * @param x defines the x coordinate of the origin (on-screen)
         * @param y defines the y coordinate of the origin (on-screen)
         * @param world defines the world matrix to use if you want to pick in object space (instead of world space)
         * @param camera defines the camera to use for the picking
         * @param cameraViewSpace defines if picking will be done in view space (false by default)
         * @returns a Ray
         */
        createPickingRay(x: number, y: number, world: Matrix, camera: Nullable<Camera>, cameraViewSpace?: boolean): Ray;
        /**
         * Creates a ray that can be used to pick in the scene
         * @param x defines the x coordinate of the origin (on-screen)
         * @param y defines the y coordinate of the origin (on-screen)
         * @param world defines the world matrix to use if you want to pick in object space (instead of world space)
         * @param result defines the ray where to store the picking ray
         * @param camera defines the camera to use for the picking
         * @param cameraViewSpace defines if picking will be done in view space (false by default)
         * @returns the current scene
         */
        createPickingRayToRef(x: number, y: number, world: Matrix, result: Ray, camera: Nullable<Camera>, cameraViewSpace?: boolean): Scene;
        /**
         * Creates a ray that can be used to pick in the scene
         * @param x defines the x coordinate of the origin (on-screen)
         * @param y defines the y coordinate of the origin (on-screen)
         * @param camera defines the camera to use for the picking
         * @returns a Ray
         */
        createPickingRayInCameraSpace(x: number, y: number, camera?: Camera): Ray;
        /**
         * Creates a ray that can be used to pick in the scene
         * @param x defines the x coordinate of the origin (on-screen)
         * @param y defines the y coordinate of the origin (on-screen)
         * @param result defines the ray where to store the picking ray
         * @param camera defines the camera to use for the picking
         * @returns the current scene
         */
        createPickingRayInCameraSpaceToRef(x: number, y: number, result: Ray, camera?: Camera): Scene;
        private _internalPick(rayFunction, predicate?, fastCheck?);
        private _internalMultiPick(rayFunction, predicate?);
        private _internalPickSprites(ray, predicate?, fastCheck?, camera?);
        private _tempPickingRay;
        /** Launch a ray to try to pick a mesh in the scene
         * @param x position on screen
         * @param y position on screen
         * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true
         * @param fastCheck Launch a fast check only using the bounding boxes. Can be set to null.
         * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used
         * @returns a PickingInfo
         */
        pick(x: number, y: number, predicate?: (mesh: AbstractMesh) => boolean, fastCheck?: boolean, camera?: Nullable<Camera>): Nullable<PickingInfo>;
        /** Launch a ray to try to pick a sprite in the scene
         * @param x position on screen
         * @param y position on screen
         * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true
         * @param fastCheck Launch a fast check only using the bounding boxes. Can be set to null.
         * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used
         * @returns a PickingInfo
         */
        pickSprite(x: number, y: number, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo>;
        private _cachedRayForTransform;
        /** Use the given ray to pick a mesh in the scene
         * @param ray The ray to use to pick meshes
         * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true
         * @param fastCheck Launch a fast check only using the bounding boxes. Can be set to null
         * @returns a PickingInfo
         */
        pickWithRay(ray: Ray, predicate: (mesh: AbstractMesh) => boolean, fastCheck?: boolean): Nullable<PickingInfo>;
        /**
         * Launch a ray to try to pick a mesh in the scene
         * @param x X position on screen
         * @param y Y position on screen
         * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true
         * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used
         * @returns an array of PickingInfo
         */
        multiPick(x: number, y: number, predicate?: (mesh: AbstractMesh) => boolean, camera?: Camera): Nullable<PickingInfo[]>;
        /**
         * Launch a ray to try to pick a mesh in the scene
         * @param ray Ray to use
         * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true
         * @returns an array of PickingInfo
         */
        multiPickWithRay(ray: Ray, predicate: (mesh: AbstractMesh) => boolean): Nullable<PickingInfo[]>;
        /**
         * Force the value of meshUnderPointer
         * @param mesh defines the mesh to use
         */
        setPointerOverMesh(mesh: Nullable<AbstractMesh>): void;
        /**
         * Gets the mesh under the pointer
         * @returns a Mesh or null if no mesh is under the pointer
         */
        getPointerOverMesh(): Nullable<AbstractMesh>;
        /**
         * Force the sprite under the pointer
         * @param sprite defines the sprite to use
         */
        setPointerOverSprite(sprite: Nullable<Sprite>): void;
        /**
         * Gets the sprite under the pointer
         * @returns a Sprite or null if no sprite is under the pointer
         */
        getPointerOverSprite(): Nullable<Sprite>;
        /**
         * Gets the current physics engine
         * @returns a PhysicsEngine or null if none attached
         */
        getPhysicsEngine(): Nullable<PhysicsEngine>;
        /**
         * Enables physics to the current scene
         * @param gravity defines the scene's gravity for the physics engine
         * @param plugin defines the physics engine to be used. defaults to OimoJS.
         * @return a boolean indicating if the physics engine was initialized
         */
        enablePhysics(gravity?: Nullable<Vector3>, plugin?: IPhysicsEnginePlugin): boolean;
        /**
         * Disables and disposes the physics engine associated with the scene
         */
        disablePhysicsEngine(): void;
        /**
         * Gets a boolean indicating if there is an active physics engine
         * @returns a boolean indicating if there is an active physics engine
         */
        isPhysicsEnabled(): boolean;
        /**
         * Deletes a physics compound impostor
         * @param compound defines the compound to delete
         */
        deleteCompoundImpostor(compound: any): void;
        /** @hidden */
        _rebuildGeometries(): void;
        /** @hidden */
        _rebuildTextures(): void;
        /**
         * Creates a default light for the scene.
         * @param replace Whether to replace the existing lights in the scene.
         */
        createDefaultLight(replace?: boolean): void;
        /**
         * Creates a default camera for the scene.
         * @param createArcRotateCamera Whether to create an arc rotate or a free camera.
         * @param replace Whether to replace the existing active camera in the scene.
         * @param attachCameraControls Whether to attach camera controls to the canvas.
         */
        createDefaultCamera(createArcRotateCamera?: boolean, replace?: boolean, attachCameraControls?: boolean): void;
        /**
         * Creates a default camera and a default light
         * @param createArcRotateCamera defines that the camera will be an ArcRotateCamera
         * @param replace defines if the camera and/or light will replace the existing ones
         * @param attachCameraControls defines if attachControl will be called on the new camera
         */
        createDefaultCameraOrLight(createArcRotateCamera?: boolean, replace?: boolean, attachCameraControls?: boolean): void;
        /**
         * Creates a new sky box
         * @see http://doc.babylonjs.com/babylon101/environment#skybox
         * @param environmentTexture defines the texture to use as environment texture
         * @param pbr defines if PBRMaterial must be used instead of StandardMaterial
         * @param scale defines the overall scale of the skybox
         * @param blur defines if blurring must be applied to the environment texture (works only with pbr === true)
         * @param setGlobalEnvTexture defines a boolean indicating that scene.environmentTexture must match the current skybox texture (true by default)
         * @returns a new mesh holding the sky box
         */
        createDefaultSkybox(environmentTexture?: BaseTexture, pbr?: boolean, scale?: number, blur?: number, setGlobalEnvTexture?: boolean): Nullable<Mesh>;
        /**
         * Creates a new environment
         * @see http://doc.babylonjs.com/babylon101/environment#skybox
         * @param options defines the options you can use to configure the environment
         * @returns the new EnvironmentHelper
         */
        createDefaultEnvironment(options: Partial<IEnvironmentHelperOptions>): Nullable<EnvironmentHelper>;
        /**
         * Creates a new VREXperienceHelper
         * @see http://doc.babylonjs.com/how_to/webvr_helper
         * @param webVROptions defines the options used to create the new VREXperienceHelper
         * @returns a new VREXperienceHelper
         */
        createDefaultVRExperience(webVROptions?: VRExperienceHelperOptions): VRExperienceHelper;
        private _getByTags(list, tagsQuery, forEach?);
        /**
         * Get a list of meshes by tags
         * @param tagsQuery defines the tags query to use
         * @param forEach defines a predicate used to filter results
         * @returns an array of Mesh
         */
        getMeshesByTags(tagsQuery: string, forEach?: (mesh: AbstractMesh) => void): Mesh[];
        /**
         * Get a list of cameras by tags
         * @param tagsQuery defines the tags query to use
         * @param forEach defines a predicate used to filter results
         * @returns an array of Camera
         */
        getCamerasByTags(tagsQuery: string, forEach?: (camera: Camera) => void): Camera[];
        /**
         * Get a list of lights by tags
         * @param tagsQuery defines the tags query to use
         * @param forEach defines a predicate used to filter results
         * @returns an array of Light
         */
        getLightsByTags(tagsQuery: string, forEach?: (light: Light) => void): Light[];
        /**
         * Get a list of materials by tags
         * @param tagsQuery defines the tags query to use
         * @param forEach defines a predicate used to filter results
         * @returns an array of Material
         */
        getMaterialByTags(tagsQuery: string, forEach?: (material: Material) => void): Material[];
        /**
         * Overrides the default sort function applied in the renderging group to prepare the meshes.
         * This allowed control for front to back rendering or reversly depending of the special needs.
         *
         * @param renderingGroupId The rendering group id corresponding to its index
         * @param opaqueSortCompareFn The opaque queue comparison function use to sort.
         * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.
         * @param transparentSortCompareFn The transparent queue comparison function use to sort.
         */
        setRenderingOrder(renderingGroupId: number, opaqueSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>, alphaTestSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>, transparentSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>): void;
        /**
         * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
         *
         * @param renderingGroupId The rendering group id corresponding to its index
         * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
         * @param depth Automatically clears depth between groups if true and autoClear is true.
         * @param stencil Automatically clears stencil between groups if true and autoClear is true.
         */
        setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean, depth?: boolean, stencil?: boolean): void;
        /**
         * Will flag all materials as dirty to trigger new shader compilation
         * @param flag defines the flag used to specify which material part must be marked as dirty
         * @param predicate If not null, it will be used to specifiy if a material has to be marked as dirty
         */
        markAllMaterialsAsDirty(flag: number, predicate?: (mat: Material) => boolean): void;
        /** @hidden */
        _loadFile(url: string, onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void, onProgress?: (data: any) => void, useDatabase?: boolean, useArrayBuffer?: boolean, onError?: (request?: XMLHttpRequest, exception?: any) => void): IFileRequest;
        /** @hidden */
        _loadFileAsync(url: string, useDatabase?: boolean, useArrayBuffer?: boolean): Promise<string | ArrayBuffer>;
    }
}

declare module BABYLON {
    type Nullable<T> = T | null;
    type float = number;
    type double = number;
    type int = number;
    type FloatArray = number[] | Float32Array;
    type IndicesArray = number[] | Int32Array | Uint32Array | Uint16Array;
    /**
     * Alias for types that can be used by a Buffer or VertexBuffer.
     */
    type DataArray = number[] | ArrayBuffer | ArrayBufferView;
}

declare module BABYLON {
    /**
     * The action to be carried out following a trigger
     * @see http://doc.babylonjs.com/how_to/how_to_use_actions#available-actions
     */
    class Action {
        /** the trigger, with or without parameters, for the action */
        triggerOptions: any;
        /**
         * Trigger for the action
         */
        trigger: number;
        /**
         * Internal only - manager for action
         * @hidden
         */
        _actionManager: ActionManager;
        private _nextActiveAction;
        private _child;
        private _condition?;
        private _triggerParameter;
        /**
        * An event triggered prior to action being executed.
        */
        onBeforeExecuteObservable: Observable<Action>;
        /**
         * Creates a new Action
         * @param triggerOptions the trigger, with or without parameters, for the action
         * @param condition an optional determinant of action
         */
        constructor(
            /** the trigger, with or without parameters, for the action */
            triggerOptions: any, condition?: Condition);
        /**
         * Internal only
         * @hidden
         */
        _prepare(): void;
        /**
         * Gets the trigger parameters
         * @returns the trigger parameters
         */
        getTriggerParameter(): any;
        /**
         * Internal only - executes current action event
         * @hidden
         */
        _executeCurrent(evt?: ActionEvent): void;
        /**
         * Execute placeholder for child classes
         * @param evt optional action event
         */
        execute(evt?: ActionEvent): void;
        /**
         * Skips to next active action
         */
        skipToNextActiveAction(): void;
        /**
         * Adds action to chain of actions, may be a DoNothingAction
         * @param action defines the next action to execute
         * @returns The action passed in
         * @see https://www.babylonjs-playground.com/#1T30HR#0
         */
        then(action: Action): Action;
        /**
         * Internal only
         * @hidden
         */
        _getProperty(propertyPath: string): string;
        /**
         * Internal only
         * @hidden
         */
        _getEffectiveTarget(target: any, propertyPath: string): any;
        /**
         * Serialize placeholder for child classes
         * @param parent of child
         * @returns the serialized object
         */
        serialize(parent: any): any;
        /**
         * Internal only called by serialize
         * @hidden
         */
        protected _serialize(serializedAction: any, parent?: any): any;
        /**
         * Internal only
         * @hidden
         */
        static _SerializeValueAsString: (value: any) => string;
        /**
         * Internal only
         * @hidden
         */
        static _GetTargetProperty: (target: Scene | Node) => {
            name: string;
            targetType: string;
            value: string;
        };
    }
}

declare module BABYLON {
    /**
     * ActionEvent is the event being sent when an action is triggered.
     */
    class ActionEvent {
        /** The mesh or sprite that triggered the action */
        source: any;
        /** The X mouse cursor position at the time of the event */
        pointerX: number;
        /** The Y mouse cursor position at the time of the event */
        pointerY: number;
        /** The mesh that is currently pointed at (can be null) */
        meshUnderPointer: Nullable<AbstractMesh>;
        /** the original (browser) event that triggered the ActionEvent */
        sourceEvent: any;
        /** additional data for the event */
        additionalData: any;
        /**
         * Creates a new ActionEvent
         * @param source The mesh or sprite that triggered the action
         * @param pointerX The X mouse cursor position at the time of the event
         * @param pointerY The Y mouse cursor position at the time of the event
         * @param meshUnderPointer The mesh that is currently pointed at (can be null)
         * @param sourceEvent the original (browser) event that triggered the ActionEvent
         * @param additionalData additional data for the event
         */
        constructor(
            /** The mesh or sprite that triggered the action */
            source: any, 
            /** The X mouse cursor position at the time of the event */
            pointerX: number, 
            /** The Y mouse cursor position at the time of the event */
            pointerY: number, 
            /** The mesh that is currently pointed at (can be null) */
            meshUnderPointer: Nullable<AbstractMesh>, 
            /** the original (browser) event that triggered the ActionEvent */
            sourceEvent?: any, 
            /** additional data for the event */
            additionalData?: any);
        /**
         * Helper function to auto-create an ActionEvent from a source mesh.
         * @param source The source mesh that triggered the event
         * @param evt The original (browser) event
         * @param additionalData additional data for the event
         * @returns the new ActionEvent
         */
        static CreateNew(source: AbstractMesh, evt?: Event, additionalData?: any): ActionEvent;
        /**
         * Helper function to auto-create an ActionEvent from a source sprite
         * @param source The source sprite that triggered the event
         * @param scene Scene associated with the sprite
         * @param evt The original (browser) event
         * @param additionalData additional data for the event
         * @returns the new ActionEvent
         */
        static CreateNewFromSprite(source: Sprite, scene: Scene, evt?: Event, additionalData?: any): ActionEvent;
        /**
         * Helper function to auto-create an ActionEvent from a scene. If triggered by a mesh use ActionEvent.CreateNew
         * @param scene the scene where the event occurred
         * @param evt The original (browser) event
         * @returns the new ActionEvent
         */
        static CreateNewFromScene(scene: Scene, evt: Event): ActionEvent;
        /**
         * Helper function to auto-create an ActionEvent from a primitive
         * @param prim defines the target primitive
         * @param pointerPos defines the pointer position
         * @param evt The original (browser) event
         * @param additionalData additional data for the event
         * @returns the new ActionEvent
         */
        static CreateNewFromPrimitive(prim: any, pointerPos: Vector2, evt?: Event, additionalData?: any): ActionEvent;
    }
    /**
     * Action Manager manages all events to be triggered on a given mesh or the global scene.
     * A single scene can have many Action Managers to handle predefined actions on specific meshes.
     * @see http://doc.babylonjs.com/how_to/how_to_use_actions
     */
    class ActionManager {
        private static _NothingTrigger;
        private static _OnPickTrigger;
        private static _OnLeftPickTrigger;
        private static _OnRightPickTrigger;
        private static _OnCenterPickTrigger;
        private static _OnPickDownTrigger;
        private static _OnDoublePickTrigger;
        private static _OnPickUpTrigger;
        private static _OnLongPressTrigger;
        private static _OnPointerOverTrigger;
        private static _OnPointerOutTrigger;
        private static _OnEveryFrameTrigger;
        private static _OnIntersectionEnterTrigger;
        private static _OnIntersectionExitTrigger;
        private static _OnKeyDownTrigger;
        private static _OnKeyUpTrigger;
        private static _OnPickOutTrigger;
        /**
         * Nothing
         * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly NothingTrigger: number;
        /**
         * On pick
         * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnPickTrigger: number;
        /**
         * On left pick
         * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnLeftPickTrigger: number;
        /**
         * On right pick
         * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnRightPickTrigger: number;
        /**
         * On center pick
         * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnCenterPickTrigger: number;
        /**
         * On pick down
         * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnPickDownTrigger: number;
        /**
         * On double pick
         * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnDoublePickTrigger: number;
        /**
         * On pick up
         * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnPickUpTrigger: number;
        /**
         * On pick out.
         * This trigger will only be raised if you also declared a OnPickDown
         * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnPickOutTrigger: number;
        /**
         * On long press
         * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnLongPressTrigger: number;
        /**
         * On pointer over
         * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnPointerOverTrigger: number;
        /**
         * On pointer out
         * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnPointerOutTrigger: number;
        /**
         * On every frame
         * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnEveryFrameTrigger: number;
        /**
         * On intersection enter
         * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnIntersectionEnterTrigger: number;
        /**
         * On intersection exit
         * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnIntersectionExitTrigger: number;
        /**
         * On key down
         * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnKeyDownTrigger: number;
        /**
         * On key up
         * @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
         */
        static readonly OnKeyUpTrigger: number;
        /** Gets the list of active triggers */
        static Triggers: {
            [key: string]: number;
        };
        /** Gets the list of actions */
        actions: Action[];
        /** Gets the cursor to use when hovering items */
        hoverCursor: string;
        private _scene;
        /**
         * Creates a new action manager
         * @param scene defines the hosting scene
         */
        constructor(scene: Scene);
        /**
         * Releases all associated resources
         */
        dispose(): void;
        /**
         * Gets hosting scene
         * @returns the hosting scene
         */
        getScene(): Scene;
        /**
         * Does this action manager handles actions of any of the given triggers
         * @param triggers defines the triggers to be tested
         * @return a boolean indicating whether one (or more) of the triggers is handled
         */
        hasSpecificTriggers(triggers: number[]): boolean;
        /**
         * Does this action manager handles actions of a given trigger
         * @param trigger defines the trigger to be tested
         * @param parameterPredicate defines an optional predicate to filter triggers by parameter
         * @return whether the trigger is handled
         */
        hasSpecificTrigger(trigger: number, parameterPredicate?: (parameter: any) => boolean): boolean;
        /**
         * Does this action manager has pointer triggers
         */
        readonly hasPointerTriggers: boolean;
        /**
         * Does this action manager has pick triggers
         */
        readonly hasPickTriggers: boolean;
        /**
         * Does exist one action manager with at least one trigger
         **/
        static readonly HasTriggers: boolean;
        /**
         * Does exist one action manager with at least one pick trigger
         **/
        static readonly HasPickTriggers: boolean;
        /**
         * Does exist one action manager that handles actions of a given trigger
         * @param trigger defines the trigger to be tested
         * @return a boolean indicating whether the trigger is handeled by at least one action manager
        **/
        static HasSpecificTrigger(trigger: number): boolean;
        /**
         * Registers an action to this action manager
         * @param action defines the action to be registered
         * @return the action amended (prepared) after registration
         */
        registerAction(action: Action): Nullable<Action>;
        /**
         * Unregisters an action to this action manager
         * @param action defines the action to be unregistered
         * @return a boolean indicating whether the action has been unregistered
         */
        unregisterAction(action: Action): Boolean;
        /**
         * Process a specific trigger
         * @param trigger defines the trigger to process
         * @param evt defines the event details to be processed
         */
        processTrigger(trigger: number, evt?: ActionEvent): void;
        /** @hidden */
        _getEffectiveTarget(target: any, propertyPath: string): any;
        /** @hidden */
        _getProperty(propertyPath: string): string;
        /**
         * Serialize this manager to a JSON object
         * @param name defines the property name to store this manager
         * @returns a JSON representation of this manager
         */
        serialize(name: string): any;
        /**
         * Creates a new ActionManager from a JSON data
         * @param parsedActions defines the JSON data to read from
         * @param object defines the hosting mesh
         * @param scene defines the hosting scene
         */
        static Parse(parsedActions: any, object: Nullable<AbstractMesh>, scene: Scene): void;
        /**
         * Get a trigger name by index
         * @param trigger defines the trigger index
         * @returns a trigger name
         */
        static GetTriggerName(trigger: number): string;
    }
}

declare module BABYLON {
    /**
     * A Condition applied to an Action
     */
    class Condition {
        /**
         * Internal only - manager for action
         * @hidden
         */
        _actionManager: ActionManager;
        /**
         * Internal only
         * @hidden
         */
        _evaluationId: number;
        /**
         * Internal only
         * @hidden
         */
        _currentResult: boolean;
        /**
         * Creates a new Condition
         * @param actionManager the manager of the action the condition is applied to
         */
        constructor(actionManager: ActionManager);
        /**
         * Check if the current condition is valid
         * @returns a boolean
         */
        isValid(): boolean;
        /**
         * Internal only
         * @hidden
         */
        _getProperty(propertyPath: string): string;
        /**
         * Internal only
         * @hidden
         */
        _getEffectiveTarget(target: any, propertyPath: string): any;
        /**
         * Serialize placeholder for child classes
         * @returns the serialized object
         */
        serialize(): any;
        /**
         * Internal only
         * @hidden
         */
        protected _serialize(serializedCondition: any): any;
    }
    /**
     * Defines specific conditional operators as extensions of Condition
     */
    class ValueCondition extends Condition {
        /** path to specify the property of the target the conditional operator uses  */
        propertyPath: string;
        /** the value compared by the conditional operator against the current value of the property */
        value: any;
        /** the conditional operator, default ValueCondition.IsEqual */
        operator: number;
        /**
         * Internal only
         * @hidden
         */
        private static _IsEqual;
        /**
         * Internal only
         * @hidden
         */
        private static _IsDifferent;
        /**
         * Internal only
         * @hidden
         */
        private static _IsGreater;
        /**
         * Internal only
         * @hidden
         */
        private static _IsLesser;
        /**
         * returns the number for IsEqual
         */
        static readonly IsEqual: number;
        /**
         * Returns the number for IsDifferent
         */
        static readonly IsDifferent: number;
        /**
         * Returns the number for IsGreater
         */
        static readonly IsGreater: number;
        /**
         * Returns the number for IsLesser
         */
        static readonly IsLesser: number;
        /**
         * Internal only The action manager for the condition
         * @hidden
         */
        _actionManager: ActionManager;
        /**
         * Internal only
         * @hidden
         */
        private _target;
        /**
         * Internal only
         * @hidden
         */
        private _effectiveTarget;
        /**
         * Internal only
         * @hidden
         */
        private _property;
        /**
         * Creates a new ValueCondition
         * @param actionManager manager for the action the condition applies to
         * @param target for the action
         * @param propertyPath path to specify the property of the target the conditional operator uses
         * @param value the value compared by the conditional operator against the current value of the property
         * @param operator the conditional operator, default ValueCondition.IsEqual
         */
        constructor(actionManager: ActionManager, target: any, 
            /** path to specify the property of the target the conditional operator uses  */
            propertyPath: string, 
            /** the value compared by the conditional operator against the current value of the property */
            value: any, 
            /** the conditional operator, default ValueCondition.IsEqual */
            operator?: number);
        /**
         * Compares the given value with the property value for the specified conditional operator
         * @returns the result of the comparison
         */
        isValid(): boolean;
        /**
         * Serialize the ValueCondition into a JSON compatible object
         * @returns serialization object
         */
        serialize(): any;
        /**
         * Gets the name of the conditional operator for the ValueCondition
         * @param operator the conditional operator
         * @returns the name
         */
        static GetOperatorName(operator: number): string;
    }
    /**
     * Defines a predicate condition as an extension of Condition
     */
    class PredicateCondition extends Condition {
        /** defines the predicate function used to validate the condition */
        predicate: () => boolean;
        /**
         * Internal only - manager for action
         * @hidden
         */
        _actionManager: ActionManager;
        /**
         * Creates a new PredicateCondition
         * @param actionManager manager for the action the condition applies to
         * @param predicate defines the predicate function used to validate the condition
         */
        constructor(actionManager: ActionManager, 
            /** defines the predicate function used to validate the condition */
            predicate: () => boolean);
        /**
         * @returns the validity of the predicate condition
         */
        isValid(): boolean;
    }
    /**
     * Defines a state condition as an extension of Condition
     */
    class StateCondition extends Condition {
        value: string;
        /**
         * Internal only - manager for action
         * @hidden
         */
        _actionManager: ActionManager;
        /**
         * Internal only
         * @hidden
         */
        private _target;
        /**
         * Creates a new StateCondition
         * @param actionManager manager for the action the condition applies to
         * @param target of the condition
         * @param value to compare with target state
         */
        constructor(actionManager: ActionManager, target: any, value: string);
        /**
         * @returns the validity of the state
         */
        isValid(): boolean;
        /**
         * Serialize the StateCondition into a JSON compatible object
         * @returns serialization object
         */
        serialize(): any;
    }
}

declare module BABYLON {
    class SwitchBooleanAction extends Action {
        propertyPath: string;
        private _target;
        private _effectiveTarget;
        private _property;
        constructor(triggerOptions: any, target: any, propertyPath: string, condition?: Condition);
        _prepare(): void;
        execute(): void;
        serialize(parent: any): any;
    }
    class SetStateAction extends Action {
        value: string;
        private _target;
        constructor(triggerOptions: any, target: any, value: string, condition?: Condition);
        execute(): void;
        serialize(parent: any): any;
    }
    class SetValueAction extends Action {
        propertyPath: string;
        value: any;
        private _target;
        private _effectiveTarget;
        private _property;
        constructor(triggerOptions: any, target: any, propertyPath: string, value: any, condition?: Condition);
        _prepare(): void;
        execute(): void;
        serialize(parent: any): any;
    }
    class IncrementValueAction extends Action {
        propertyPath: string;
        value: any;
        private _target;
        private _effectiveTarget;
        private _property;
        constructor(triggerOptions: any, target: any, propertyPath: string, value: any, condition?: Condition);
        _prepare(): void;
        execute(): void;
        serialize(parent: any): any;
    }
    class PlayAnimationAction extends Action {
        from: number;
        to: number;
        loop: boolean | undefined;
        private _target;
        constructor(triggerOptions: any, target: any, from: number, to: number, loop?: boolean | undefined, condition?: Condition);
        _prepare(): void;
        execute(): void;
        serialize(parent: any): any;
    }
    class StopAnimationAction extends Action {
        private _target;
        constructor(triggerOptions: any, target: any, condition?: Condition);
        _prepare(): void;
        execute(): void;
        serialize(parent: any): any;
    }
    class DoNothingAction extends Action {
        constructor(triggerOptions?: any, condition?: Condition);
        execute(): void;
        serialize(parent: any): any;
    }
    class CombineAction extends Action {
        children: Action[];
        constructor(triggerOptions: any, children: Action[], condition?: Condition);
        _prepare(): void;
        execute(evt: ActionEvent): void;
        serialize(parent: any): any;
    }
    class ExecuteCodeAction extends Action {
        func: (evt: ActionEvent) => void;
        constructor(triggerOptions: any, func: (evt: ActionEvent) => void, condition?: Condition);
        execute(evt: ActionEvent): void;
    }
    class SetParentAction extends Action {
        private _parent;
        private _target;
        constructor(triggerOptions: any, target: any, parent: any, condition?: Condition);
        _prepare(): void;
        execute(): void;
        serialize(parent: any): any;
    }
    class PlaySoundAction extends Action {
        private _sound;
        constructor(triggerOptions: any, sound: Sound, condition?: Condition);
        _prepare(): void;
        execute(): void;
        serialize(parent: any): any;
    }
    class StopSoundAction extends Action {
        private _sound;
        constructor(triggerOptions: any, sound: Sound, condition?: Condition);
        _prepare(): void;
        execute(): void;
        serialize(parent: any): any;
    }
}

declare module BABYLON {
    class InterpolateValueAction extends Action {
        propertyPath: string;
        value: any;
        duration: number;
        stopOtherAnimations: boolean | undefined;
        onInterpolationDone: (() => void) | undefined;
        private _target;
        private _effectiveTarget;
        private _property;
        onInterpolationDoneObservable: Observable<InterpolateValueAction>;
        constructor(triggerOptions: any, target: any, propertyPath: string, value: any, duration?: number, condition?: Condition, stopOtherAnimations?: boolean | undefined, onInterpolationDone?: (() => void) | undefined);
        _prepare(): void;
        execute(): void;
        serialize(parent: any): any;
    }
}

declare module BABYLON {
    class Animatable {
        target: any;
        fromFrame: number;
        toFrame: number;
        loopAnimation: boolean;
        onAnimationEnd: (() => void) | null | undefined;
        private _localDelayOffset;
        private _pausedDelay;
        private _runtimeAnimations;
        private _paused;
        private _scene;
        private _speedRatio;
        private _weight;
        private _syncRoot;
        animationStarted: boolean;
        /**
         * Gets the root Animatable used to synchronize and normalize animations
         */
        readonly syncRoot: Animatable;
        /**
         * Gets the current frame of the first RuntimeAnimation
         * Used to synchronize Animatables
         */
        readonly masterFrame: number;
        /**
         * Gets or sets the animatable weight (-1.0 by default meaning not weighted)
         */
        weight: number;
        /**
         * Gets or sets the speed ratio to apply to the animatable (1.0 by default)
         */
        speedRatio: number;
        constructor(scene: Scene, target: any, fromFrame?: number, toFrame?: number, loopAnimation?: boolean, speedRatio?: number, onAnimationEnd?: (() => void) | null | undefined, animations?: any);
        /**
         * Synchronize and normalize current Animatable with a source Animatable
         * This is useful when using animation weights and when animations are not of the same length
         * @param root defines the root Animatable to synchronize with
         * @returns the current Animatable
         */
        syncWith(root: Animatable): Animatable;
        getAnimations(): RuntimeAnimation[];
        appendAnimations(target: any, animations: Animation[]): void;
        getAnimationByTargetProperty(property: string): Nullable<Animation>;
        getRuntimeAnimationByTargetProperty(property: string): Nullable<RuntimeAnimation>;
        reset(): void;
        enableBlending(blendingSpeed: number): void;
        disableBlending(): void;
        goToFrame(frame: number): void;
        pause(): void;
        restart(): void;
        stop(animationName?: string): void;
        _animate(delay: number): boolean;
    }
}

declare module BABYLON {
    /**
     * Represents the range of an animation
     */
    class AnimationRange {
        /**The name of the animation range**/
        name: string;
        /**The starting frame of the animation */
        from: number;
        /**The ending frame of the animation*/
        to: number;
        /**
         * Initializes the range of an animation
         * @param name The name of the animation range
         * @param from The starting frame of the animation
         * @param to The ending frame of the animation
         */
        constructor(
            /**The name of the animation range**/
            name: string, 
            /**The starting frame of the animation */
            from: number, 
            /**The ending frame of the animation*/
            to: number);
        /**
         * Makes a copy of the animation range
         * @returns A copy of the animation range
         */
        clone(): AnimationRange;
    }
    /**
     * Composed of a frame, and an action function
     */
    class AnimationEvent {
        /** The frame for which the event is triggered **/
        frame: number;
        /** The event to perform when triggered **/
        action: () => void;
        /** Specifies if the event should be triggered only once**/
        onlyOnce: boolean | undefined;
        /**
         * Specifies if the animation event is done
         */
        isDone: boolean;
        /**
         * Initializes the animation event
         * @param frame The frame for which the event is triggered
         * @param action The event to perform when triggered
         * @param onlyOnce Specifies if the event should be triggered only once
         */
        constructor(
            /** The frame for which the event is triggered **/
            frame: number, 
            /** The event to perform when triggered **/
            action: () => void, 
            /** Specifies if the event should be triggered only once**/
            onlyOnce?: boolean | undefined);
    }
    /**
     * A cursor which tracks a point on a path
     */
    class PathCursor {
        private path;
        /**
         * Stores path cursor callbacks for when an onchange event is triggered
         */
        private _onchange;
        /**
         * The value of the path cursor
         */
        value: number;
        /**
         * The animation array of the path cursor
         */
        animations: Animation[];
        /**
         * Initializes the path cursor
         * @param path The path to track
         */
        constructor(path: Path2);
        /**
         * Gets the cursor point on the path
         * @returns A point on the path cursor at the cursor location
         */
        getPoint(): Vector3;
        /**
         * Moves the cursor ahead by the step amount
         * @param step The amount to move the cursor forward
         * @returns This path cursor
         */
        moveAhead(step?: number): PathCursor;
        /**
         * Moves the cursor behind by the step amount
         * @param step The amount to move the cursor back
         * @returns This path cursor
         */
        moveBack(step?: number): PathCursor;
        /**
         * Moves the cursor by the step amount
         * If the step amount is greater than one, an exception is thrown
         * @param step The amount to move the cursor
         * @returns This path cursor
         */
        move(step: number): PathCursor;
        /**
         * Ensures that the value is limited between zero and one
         * @returns This path cursor
         */
        private ensureLimits();
        /**
         * Runs onchange callbacks on change (used by the animation engine)
         * @returns This path cursor
         */
        private raiseOnChange();
        /**
         * Executes a function on change
         * @param f A path cursor onchange callback
         * @returns This path cursor
         */
        onchange(f: (cursor: PathCursor) => void): PathCursor;
    }
    /**
     * Defines an interface which represents an animation key frame
     */
    interface IAnimationKey {
        /**
         * Frame of the key frame
         */
        frame: number;
        /**
         * Value at the specifies key frame
         */
        value: any;
        /**
         * The input tangent for the cubic hermite spline
         */
        inTangent?: any;
        /**
         * The output tangent for the cubic hermite spline
         */
        outTangent?: any;
        /**
         * The animation interpolation type
         */
        interpolation?: AnimationKeyInterpolation;
    }
    /**
     * Enum for the animation key frame interpolation type
     */
    enum AnimationKeyInterpolation {
        /**
         * Do not interpolate between keys and use the start key value only. Tangents are ignored
         */
        STEP = 1,
    }
    /**
     * Class used to store any kind of animation
     */
    class Animation {
        /**Name of the animation */
        name: string;
        /**Property to animate */
        targetProperty: string;
        /**The frames per second of the animation */
        framePerSecond: number;
        /**The data type of the animation */
        dataType: number;
        /**The loop mode of the animation */
        loopMode: number | undefined;
        /**Specifies if blending should be enabled */
        enableBlending: boolean | undefined;
        /**
         * Use matrix interpolation instead of using direct key value when animating matrices
         */
        static AllowMatricesInterpolation: boolean;
        /**
         * When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower
         */
        static AllowMatrixDecomposeForInterpolation: boolean;
        /**
         * Stores the key frames of the animation
         */
        private _keys;
        /**
         * Stores the easing function of the animation
         */
        private _easingFunction;
        /**
         * @hidden Internal use only
         */
        _runtimeAnimations: RuntimeAnimation[];
        /**
         * The set of event that will be linked to this animation
         */
        private _events;
        /**
         * Stores an array of target property paths
         */
        targetPropertyPath: string[];
        /**
         * Stores the blending speed of the animation
         */
        blendingSpeed: number;
        /**
         * Stores the animation ranges for the animation
         */
        private _ranges;
        /**
         * @hidden Internal use
         */
        static _PrepareAnimation(name: string, targetProperty: string, framePerSecond: number, totalFrame: number, from: any, to: any, loopMode?: number, easingFunction?: EasingFunction): Nullable<Animation>;
        /**
         * Sets up an animation
         * @param property The property to animate
         * @param animationType The animation type to apply
         * @param framePerSecond The frames per second of the animation
         * @param easingFunction The easing function used in the animation
         * @returns The created animation
         */
        static CreateAnimation(property: string, animationType: number, framePerSecond: number, easingFunction: EasingFunction): Animation;
        /**
         * Create and start an animation on a node
         * @param name defines the name of the global animation that will be run on all nodes
         * @param node defines the root node where the animation will take place
         * @param targetProperty defines property to animate
         * @param framePerSecond defines the number of frame per second yo use
         * @param totalFrame defines the number of frames in total
         * @param from defines the initial value
         * @param to defines the final value
         * @param loopMode defines which loop mode you want to use (off by default)
         * @param easingFunction defines the easing function to use (linear by default)
         * @param onAnimationEnd defines the callback to call when animation end
         * @returns the animatable created for this animation
         */
        static CreateAndStartAnimation(name: string, node: Node, targetProperty: string, framePerSecond: number, totalFrame: number, from: any, to: any, loopMode?: number, easingFunction?: EasingFunction, onAnimationEnd?: () => void): Nullable<Animatable>;
        /**
         * Create and start an animation on a node and its descendants
         * @param name defines the name of the global animation that will be run on all nodes
         * @param node defines the root node where the animation will take place
         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used
         * @param targetProperty defines property to animate
         * @param framePerSecond defines the number of frame per second to use
         * @param totalFrame defines the number of frames in total
         * @param from defines the initial value
         * @param to defines the final value
         * @param loopMode defines which loop mode you want to use (off by default)
         * @param easingFunction defines the easing function to use (linear by default)
         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)
         * @returns the list of animatables created for all nodes
         * @example https://www.babylonjs-playground.com/#MH0VLI
         */
        static CreateAndStartHierarchyAnimation(name: string, node: Node, directDescendantsOnly: boolean, targetProperty: string, framePerSecond: number, totalFrame: number, from: any, to: any, loopMode?: number, easingFunction?: EasingFunction, onAnimationEnd?: () => void): Nullable<Animatable[]>;
        /**
         * Creates a new animation, merges it with the existing animations and starts it
         * @param name Name of the animation
         * @param node Node which contains the scene that begins the animations
         * @param targetProperty Specifies which property to animate
         * @param framePerSecond The frames per second of the animation
         * @param totalFrame The total number of frames
         * @param from The frame at the beginning of the animation
         * @param to The frame at the end of the animation
         * @param loopMode Specifies the loop mode of the animation
         * @param easingFunction (Optional) The easing function of the animation, which allow custom mathematical formulas for animations
         * @param onAnimationEnd Callback to run once the animation is complete
         * @returns Nullable animation
         */
        static CreateMergeAndStartAnimation(name: string, node: Node, targetProperty: string, framePerSecond: number, totalFrame: number, from: any, to: any, loopMode?: number, easingFunction?: EasingFunction, onAnimationEnd?: () => void): Nullable<Animatable>;
        /**
         * Transition property of the Camera to the target Value
         * @param property The property to transition
         * @param targetValue The target Value of the property
         * @param host The object where the property to animate belongs
         * @param scene Scene used to run the animation
         * @param frameRate Framerate (in frame/s) to use
         * @param transition The transition type we want to use
         * @param duration The duration of the animation, in milliseconds
         * @param onAnimationEnd Callback trigger at the end of the animation
         * @returns Nullable animation
         */
        static TransitionTo(property: string, targetValue: any, host: any, scene: Scene, frameRate: number, transition: Animation, duration: number, onAnimationEnd?: Nullable<() => void>): Nullable<Animatable>;
        /**
         * Return the array of runtime animations currently using this animation
         */
        readonly runtimeAnimations: RuntimeAnimation[];
        /**
         * Specifies if any of the runtime animations are currently running
         */
        readonly hasRunningRuntimeAnimations: boolean;
        /**
         * Initializes the animation
         * @param name Name of the animation
         * @param targetProperty Property to animate
         * @param framePerSecond The frames per second of the animation
         * @param dataType The data type of the animation
         * @param loopMode The loop mode of the animation
         * @param enableBlendings Specifies if blending should be enabled
         */
        constructor(
            /**Name of the animation */
            name: string, 
            /**Property to animate */
            targetProperty: string, 
            /**The frames per second of the animation */
            framePerSecond: number, 
            /**The data type of the animation */
            dataType: number, 
            /**The loop mode of the animation */
            loopMode?: number | undefined, 
            /**Specifies if blending should be enabled */
            enableBlending?: boolean | undefined);
        /**
         * Converts the animation to a string
         * @param fullDetails support for multiple levels of logging within scene loading
         * @returns String form of the animation
         */
        toString(fullDetails?: boolean): string;
        /**
         * Add an event to this animation
         * @param event Event to add
         */
        addEvent(event: AnimationEvent): void;
        /**
         * Remove all events found at the given frame
         * @param frame The frame to remove events from
         */
        removeEvents(frame: number): void;
        /**
         * Retrieves all the events from the animation
         * @returns Events from the animation
         */
        getEvents(): AnimationEvent[];
        /**
         * Creates an animation range
         * @param name Name of the animation range
         * @param from Starting frame of the animation range
         * @param to Ending frame of the animation
         */
        createRange(name: string, from: number, to: number): void;
        /**
         * Deletes an animation range by name
         * @param name Name of the animation range to delete
         * @param deleteFrames Specifies if the key frames for the range should also be deleted (true) or not (false)
         */
        deleteRange(name: string, deleteFrames?: boolean): void;
        /**
         * Gets the animation range by name, or null if not defined
         * @param name Name of the animation range
         * @returns Nullable animation range
         */
        getRange(name: string): Nullable<AnimationRange>;
        /**
         * Gets the key frames from the animation
         * @returns The key frames of the animation
         */
        getKeys(): Array<IAnimationKey>;
        /**
         * Gets the highest frame rate of the animation
         * @returns Highest frame rate of the animation
         */
        getHighestFrame(): number;
        /**
         * Gets the easing function of the animation
         * @returns Easing function of the animation
         */
        getEasingFunction(): IEasingFunction;
        /**
         * Sets the easing function of the animation
         * @param easingFunction A custom mathematical formula for animation
         */
        setEasingFunction(easingFunction: EasingFunction): void;
        /**
         * Interpolates a scalar linearly
         * @param startValue Start value of the animation curve
         * @param endValue End value of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns Interpolated scalar value
         */
        floatInterpolateFunction(startValue: number, endValue: number, gradient: number): number;
        /**
         * Interpolates a scalar cubically
         * @param startValue Start value of the animation curve
         * @param outTangent End tangent of the animation
         * @param endValue End value of the animation curve
         * @param inTangent Start tangent of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns Interpolated scalar value
         */
        floatInterpolateFunctionWithTangents(startValue: number, outTangent: number, endValue: number, inTangent: number, gradient: number): number;
        /**
         * Interpolates a quaternion using a spherical linear interpolation
         * @param startValue Start value of the animation curve
         * @param endValue End value of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns Interpolated quaternion value
         */
        quaternionInterpolateFunction(startValue: Quaternion, endValue: Quaternion, gradient: number): Quaternion;
        /**
         * Interpolates a quaternion cubically
         * @param startValue Start value of the animation curve
         * @param outTangent End tangent of the animation curve
         * @param endValue End value of the animation curve
         * @param inTangent Start tangent of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns Interpolated quaternion value
         */
        quaternionInterpolateFunctionWithTangents(startValue: Quaternion, outTangent: Quaternion, endValue: Quaternion, inTangent: Quaternion, gradient: number): Quaternion;
        /**
         * Interpolates a Vector3 linearl
         * @param startValue Start value of the animation curve
         * @param endValue End value of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns Interpolated scalar value
         */
        vector3InterpolateFunction(startValue: Vector3, endValue: Vector3, gradient: number): Vector3;
        /**
         * Interpolates a Vector3 cubically
         * @param startValue Start value of the animation curve
         * @param outTangent End tangent of the animation
         * @param endValue End value of the animation curve
         * @param inTangent Start tangent of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns InterpolatedVector3 value
         */
        vector3InterpolateFunctionWithTangents(startValue: Vector3, outTangent: Vector3, endValue: Vector3, inTangent: Vector3, gradient: number): Vector3;
        /**
         * Interpolates a Vector2 linearly
         * @param startValue Start value of the animation curve
         * @param endValue End value of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns Interpolated Vector2 value
         */
        vector2InterpolateFunction(startValue: Vector2, endValue: Vector2, gradient: number): Vector2;
        /**
         * Interpolates a Vector2 cubically
         * @param startValue Start value of the animation curve
         * @param outTangent End tangent of the animation
         * @param endValue End value of the animation curve
         * @param inTangent Start tangent of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns Interpolated Vector2 value
         */
        vector2InterpolateFunctionWithTangents(startValue: Vector2, outTangent: Vector2, endValue: Vector2, inTangent: Vector2, gradient: number): Vector2;
        /**
         * Interpolates a size linearly
         * @param startValue Start value of the animation curve
         * @param endValue End value of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns Interpolated Size value
         */
        sizeInterpolateFunction(startValue: Size, endValue: Size, gradient: number): Size;
        /**
         * Interpolates a Color3 linearly
         * @param startValue Start value of the animation curve
         * @param endValue End value of the animation curve
         * @param gradient Scalar amount to interpolate
         * @returns Interpolated Color3 value
         */
        color3InterpolateFunction(startValue: Color3, endValue: Color3, gradient: number): Color3;
        /**
         * @hidden Internal use only
         */
        _getKeyValue(value: any): any;
        /**
         * @hidden Internal use only
         */
        _interpolate(currentFrame: number, repeatCount: number, workValue?: any, loopMode?: number, offsetValue?: any, highLimitValue?: any): any;
        /**
         * Defines the function to use to interpolate matrices
         * @param startValue defines the start matrix
         * @param endValue defines the end matrix
         * @param gradient defines the gradient between both matrices
         * @param result defines an optional target matrix where to store the interpolation
         * @returns the interpolated matrix
         */
        matrixInterpolateFunction(startValue: Matrix, endValue: Matrix, gradient: number, result?: Matrix): Matrix;
        /**
         * Makes a copy of the animation
         * @returns Cloned animation
         */
        clone(): Animation;
        /**
         * Sets the key frames of the animation
         * @param values The animation key frames to set
         */
        setKeys(values: Array<IAnimationKey>): void;
        /**
         * Serializes the animation to an object
         * @returns Serialized object
         */
        serialize(): any;
        /**
         * Float animation type
         */
        private static _ANIMATIONTYPE_FLOAT;
        /**
         * Vector3 animation type
         */
        private static _ANIMATIONTYPE_VECTOR3;
        /**
         * Quaternion animation type
         */
        private static _ANIMATIONTYPE_QUATERNION;
        /**
         * Matrix animation type
         */
        private static _ANIMATIONTYPE_MATRIX;
        /**
         * Color3 animation type
         */
        private static _ANIMATIONTYPE_COLOR3;
        /**
         * Vector2 animation type
         */
        private static _ANIMATIONTYPE_VECTOR2;
        /**
         * Size animation type
         */
        private static _ANIMATIONTYPE_SIZE;
        /**
         * Relative Loop Mode
         */
        private static _ANIMATIONLOOPMODE_RELATIVE;
        /**
         * Cycle Loop Mode
         */
        private static _ANIMATIONLOOPMODE_CYCLE;
        /**
         * Constant Loop Mode
         */
        private static _ANIMATIONLOOPMODE_CONSTANT;
        /**
         * Get the float animation type
         */
        static readonly ANIMATIONTYPE_FLOAT: number;
        /**
         * Get the Vector3 animation type
         */
        static readonly ANIMATIONTYPE_VECTOR3: number;
        /**
         * Get the Vectpr2 animation type
         */
        static readonly ANIMATIONTYPE_VECTOR2: number;
        /**
         * Get the Size animation type
         */
        static readonly ANIMATIONTYPE_SIZE: number;
        /**
         * Get the Quaternion animation type
         */
        static readonly ANIMATIONTYPE_QUATERNION: number;
        /**
         * Get the Matrix animation type
         */
        static readonly ANIMATIONTYPE_MATRIX: number;
        /**
         * Get the Color3 animation type
         */
        static readonly ANIMATIONTYPE_COLOR3: number;
        /**
         * Get the Relative Loop Mode
         */
        static readonly ANIMATIONLOOPMODE_RELATIVE: number;
        /**
         * Get the Cycle Loop Mode
         */
        static readonly ANIMATIONLOOPMODE_CYCLE: number;
        /**
         * Get the Constant Loop Mode
         */
        static readonly ANIMATIONLOOPMODE_CONSTANT: number;
        /** @hidden */
        static _UniversalLerp(left: any, right: any, amount: number): any;
        /**
         * Parses an animation object and creates an animation
         * @param parsedAnimation Parsed animation object
         * @returns Animation object
         */
        static Parse(parsedAnimation: any): Animation;
        /**
         * Appends the serialized animations from the source animations
         * @param source Source containing the animations
         * @param destination Target to store the animations
         */
        static AppendSerializedAnimations(source: IAnimatable, destination: any): void;
    }
}

declare module BABYLON {
    /**
     * This class defines the direct association between an animation and a target
     */
    class TargetedAnimation {
        animation: Animation;
        target: any;
    }
    /**
     * Use this class to create coordinated animations on multiple targets
     */
    class AnimationGroup implements IDisposable {
        name: string;
        private _scene;
        private _targetedAnimations;
        private _animatables;
        private _from;
        private _to;
        private _isStarted;
        private _speedRatio;
        onAnimationEndObservable: Observable<TargetedAnimation>;
        /**
         * Gets the first frame
         */
        readonly from: number;
        /**
         * Gets the last frame
         */
        readonly to: number;
        /**
         * Define if the animations are started
         */
        readonly isStarted: boolean;
        /**
         * Gets or sets the speed ratio to use for all animations
         */
        /**
         * Gets or sets the speed ratio to use for all animations
         */
        speedRatio: number;
        /**
         * Gets the targeted animations for this animation group
         */
        readonly targetedAnimations: Array<TargetedAnimation>;
        /**
         * returning the list of animatables controlled by this animation group.
         */
        readonly animatables: Array<Animatable>;
        constructor(name: string, scene?: Nullable<Scene>);
        /**
         * Add an animation (with its target) in the group
         * @param animation defines the animation we want to add
         * @param target defines the target of the animation
         * @returns the {BABYLON.TargetedAnimation} object
         */
        addTargetedAnimation(animation: Animation, target: any): TargetedAnimation;
        /**
         * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame
         * It can add constant keys at begin or end
         * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)
         * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)
         */
        normalize(beginFrame?: Nullable<number>, endFrame?: Nullable<number>): AnimationGroup;
        /**
         * Start all animations on given targets
         * @param loop defines if animations must loop
         * @param speedRatio defines the ratio to apply to animation speed (1 by default)
         * @param from defines the from key (optional)
         * @param to defines the to key (optional)
         * @returns the current animation group
         */
        start(loop?: boolean, speedRatio?: number, from?: number, to?: number): AnimationGroup;
        /**
         * Pause all animations
         */
        pause(): AnimationGroup;
        /**
         * Play all animations to initial state
         * This function will start() the animations if they were not started or will restart() them if they were paused
         * @param loop defines if animations must loop
         */
        play(loop?: boolean): AnimationGroup;
        /**
         * Reset all animations to initial state
         */
        reset(): AnimationGroup;
        /**
         * Restart animations from key 0
         */
        restart(): AnimationGroup;
        /**
         * Stop all animations
         */
        stop(): AnimationGroup;
        /**
         * Set animation weight for all animatables
         * @param weight defines the weight to use
         * @return the animationGroup
         * @see http://doc.babylonjs.com/babylon101/animations#animation-weights
         */
        setWeightForAllAnimatables(weight: number): AnimationGroup;
        /**
         * Synchronize and normalize all animatables with a source animatable
         * @param root defines the root animatable to synchronize with
         * @return the animationGroup
         * @see http://doc.babylonjs.com/babylon101/animations#animation-weights
         */
        syncAllAnimationsWith(root: Animatable): AnimationGroup;
        /**
         * Goes to a specific frame in this animation group
         * @param frame the frame number to go to
         * @return the animationGroup
         */
        goToFrame(frame: number): AnimationGroup;
        /**
         * Dispose all associated resources
         */
        dispose(): void;
    }
}

declare module BABYLON {
    /**
     * Class used to override all child animations of a given target
     */
    class AnimationPropertiesOverride {
        /**
         * Gets or sets a value indicating if animation blending must be used
         */
        enableBlending: boolean;
        /**
         * Gets or sets the blending speed to use when enableBlending is true
         */
        blendingSpeed: number;
        /**
         * Gets or sets the default loop mode to use
         */
        loopMode: number;
    }
}

declare module BABYLON {
    interface IEasingFunction {
        ease(gradient: number): number;
    }
    class EasingFunction implements IEasingFunction {
        private static _EASINGMODE_EASEIN;
        private static _EASINGMODE_EASEOUT;
        private static _EASINGMODE_EASEINOUT;
        static readonly EASINGMODE_EASEIN: number;
        static readonly EASINGMODE_EASEOUT: number;
        static readonly EASINGMODE_EASEINOUT: number;
        private _easingMode;
        setEasingMode(easingMode: number): void;
        getEasingMode(): number;
        easeInCore(gradient: number): number;
        ease(gradient: number): number;
    }
    class CircleEase extends EasingFunction implements IEasingFunction {
        easeInCore(gradient: number): number;
    }
    class BackEase extends EasingFunction implements IEasingFunction {
        amplitude: number;
        constructor(amplitude?: number);
        easeInCore(gradient: number): number;
    }
    class BounceEase extends EasingFunction implements IEasingFunction {
        bounces: number;
        bounciness: number;
        constructor(bounces?: number, bounciness?: number);
        easeInCore(gradient: number): number;
    }
    class CubicEase extends EasingFunction implements IEasingFunction {
        easeInCore(gradient: number): number;
    }
    class ElasticEase extends EasingFunction implements IEasingFunction {
        oscillations: number;
        springiness: number;
        constructor(oscillations?: number, springiness?: number);
        easeInCore(gradient: number): number;
    }
    class ExponentialEase extends EasingFunction implements IEasingFunction {
        exponent: number;
        constructor(exponent?: number);
        easeInCore(gradient: number): number;
    }
    class PowerEase extends EasingFunction implements IEasingFunction {
        power: number;
        constructor(power?: number);
        easeInCore(gradient: number): number;
    }
    class QuadraticEase extends EasingFunction implements IEasingFunction {
        easeInCore(gradient: number): number;
    }
    class QuarticEase extends EasingFunction implements IEasingFunction {
        easeInCore(gradient: number): number;
    }
    class QuinticEase extends EasingFunction implements IEasingFunction {
        easeInCore(gradient: number): number;
    }
    class SineEase extends EasingFunction implements IEasingFunction {
        easeInCore(gradient: number): number;
    }
    class BezierCurveEase extends EasingFunction implements IEasingFunction {
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        constructor(x1?: number, y1?: number, x2?: number, y2?: number);
        easeInCore(gradient: number): number;
    }
}

declare module BABYLON {
    /**
     * Defines a runtime animation
     */
    class RuntimeAnimation {
        /**
         * The current frame of the runtime animation
         */
        private _currentFrame;
        /**
         * The animation used by the runtime animation
         */
        private _animation;
        /**
         * The target of the runtime animation
         */
        private _target;
        /**
         * The initiating animatable
         */
        private _host;
        /**
         * The original value of the runtime animation
         */
        private _originalValue;
        /**
         * The original blend value of the runtime animation
         */
        private _originalBlendValue;
        /**
         * The offsets cache of the runtime animation
         */
        private _offsetsCache;
        /**
         * The high limits cache of the runtime animation
         */
        private _highLimitsCache;
        /**
         * Specifies if the runtime animation has been stopped
         */
        private _stopped;
        /**
         * The blending factor of the runtime animation
         */
        private _blendingFactor;
        /**
         * The BabylonJS scene
         */
        private _scene;
        /**
         * The current value of the runtime animation
         */
        private _currentValue;
        /** @hidden */
        _workValue: any;
        /**
         * The active target of the runtime animation
         */
        private _activeTarget;
        /**
         * The target path of the runtime animation
         */
        private _targetPath;
        /**
         * The weight of the runtime animation
         */
        private _weight;
        /**
         * The ratio offset of the runtime animation
         */
        private _ratioOffset;
        /**
         * The previous delay of the runtime animation
         */
        private _previousDelay;
        /**
         * The previous ratio of the runtime animation
         */
        private _previousRatio;
        /**
         * Gets the current frame of the runtime animation
         */
        readonly currentFrame: number;
        /**
         * Gets the weight of the runtime animation
         */
        readonly weight: number;
        /**
         * Gets the current value of the runtime animation
         */
        readonly currentValue: any;
        /**
         * Gets the target path of the runtime animation
         */
        readonly targetPath: string;
        /**
         * Gets the actual target of the runtime animation
         */
        readonly target: any;
        /**
         * Create a new RuntimeAnimation object
         * @param target defines the target of the animation
         * @param animation defines the source animation object
         * @param scene defines the hosting scene
         * @param host defines the initiating Animatable
         */
        constructor(target: any, animation: Animation, scene: Scene, host: Animatable);
        /**
         * Gets the animation from the runtime animation
         */
        readonly animation: Animation;
        /**
         * Resets the runtime animation to the beginning
         * @param restoreOriginal defines whether to restore the target property to the original value
         */
        reset(restoreOriginal?: boolean): void;
        /**
         * Specifies if the runtime animation is stopped
         * @returns Boolean specifying if the runtime animation is stopped
         */
        isStopped(): boolean;
        /**
         * Disposes of the runtime animation
         */
        dispose(): void;
        /**
         * Interpolates the animation from the current frame
         * @param currentFrame The frame to interpolate the animation to
         * @param repeatCount The number of times that the animation should loop
         * @param loopMode The type of looping mode to use
         * @param offsetValue Animation offset value
         * @param highLimitValue The high limit value
         * @returns The interpolated value
         */
        private _interpolate(currentFrame, repeatCount, loopMode?, offsetValue?, highLimitValue?);
        /**
         * Apply the interpolated value to the target
         * @param currentValue defines the value computed by the animation
         * @param weight defines the weight to apply to this value (Defaults to 1.0)
         */
        setValue(currentValue: any, weight?: number): void;
        private _setValue(target, currentValue, weight, targetIndex?);
        /**
         * Gets the loop pmode of the runtime animation
         * @returns Loop Mode
         */
        private _getCorrectLoopMode();
        /**
         * Move the current animation to a given frame
         * @param frame defines the frame to move to
         */
        goToFrame(frame: number): void;
        /**
         * @hidden Internal use only
         */
        _prepareForSpeedRatioChange(newSpeedRatio: number): void;
        /**
         * Execute the current animation
         * @param delay defines the delay to add to the current frame
         * @param from defines the lower bound of the animation range
         * @param to defines the upper bound of the animation range
         * @param loop defines if the current animation must loop
         * @param speedRatio defines the current speed ratio
         * @param weight defines the weight of the animation (default is -1 so no weight)
         * @returns a boolean indicating if the animation has ended
         */
        animate(delay: number, from: number, to: number, loop: boolean, speedRatio: number, weight?: number): boolean;
    }
}

declare module BABYLON {
    /**
     * Class used to work with sound analyzer using fast fourier transform (FFT)
     * @see http://doc.babylonjs.com/how_to/playing_sounds_and_music
     */
    class Analyser {
        /**
         * Gets or sets the smoothing
         * @ignorenaming
         */
        SMOOTHING: number;
        /**
         * Gets or sets the FFT table size
         * @ignorenaming
         */
        FFT_SIZE: number;
        /**
         * Gets or sets the bar graph amplitude
         * @ignorenaming
         */
        BARGRAPHAMPLITUDE: number;
        /**
         * Gets or sets the position of the debug canvas
         * @ignorenaming
         */
        DEBUGCANVASPOS: {
            x: number;
            y: number;
        };
        /**
         * Gets or sets the debug canvas size
         * @ignorenaming
         */
        DEBUGCANVASSIZE: {
            width: number;
            height: number;
        };
        private _byteFreqs;
        private _byteTime;
        private _floatFreqs;
        private _webAudioAnalyser;
        private _debugCanvas;
        private _debugCanvasContext;
        private _scene;
        private _registerFunc;
        private _audioEngine;
        /**
         * Creates a new analyser
         * @param scene defines hosting scene
         */
        constructor(scene: Scene);
        /**
         * Get the number of data values you will have to play with for the visualization
         * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/frequencyBinCount
         * @returns a number
         */
        getFrequencyBinCount(): number;
        /**
         * Gets the current frequency data as a byte array
         * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData
         * @returns a Uint8Array
         */
        getByteFrequencyData(): Uint8Array;
        /**
         * Gets the current waveform as a byte array
         * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteTimeDomainData
         * @returns a Uint8Array
         */
        getByteTimeDomainData(): Uint8Array;
        /**
         * Gets the current frequency data as a float array
         * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData
         * @returns a Float32Array
         */
        getFloatFrequencyData(): Float32Array;
        /**
         * Renders the debug canvas
         */
        drawDebugCanvas(): void;
        /**
         * Stops rendering the debug canvas and removes it
         */
        stopDebugCanvas(): void;
        /**
         * Connects two audio nodes
         * @param inputAudioNode defines first node to connect
         * @param outputAudioNode defines second node to connect
         */
        connectAudioNodes(inputAudioNode: AudioNode, outputAudioNode: AudioNode): void;
        /**
         * Releases all associated resources
         */
        dispose(): void;
    }
}

declare module BABYLON {
    class AudioEngine {
        private _audioContext;
        private _audioContextInitialized;
        canUseWebAudio: boolean;
        masterGain: GainNode;
        private _connectedAnalyser;
        WarnedWebAudioUnsupported: boolean;
        unlocked: boolean;
        onAudioUnlocked: () => any;
        isMP3supported: boolean;
        isOGGsupported: boolean;
        readonly audioContext: Nullable<AudioContext>;
        constructor();
        private _unlockiOSaudio();
        private _initializeAudioContext();
        dispose(): void;
        getGlobalVolume(): number;
        setGlobalVolume(newVolume: number): void;
        connectToAnalyser(analyser: Analyser): void;
    }
}

declare module BABYLON {
    class Sound {
        name: string;
        autoplay: boolean;
        loop: boolean;
        useCustomAttenuation: boolean;
        soundTrackId: number;
        spatialSound: boolean;
        refDistance: number;
        rolloffFactor: number;
        maxDistance: number;
        distanceModel: string;
        private _panningModel;
        onended: () => any;
        private _playbackRate;
        private _streaming;
        private _startTime;
        private _startOffset;
        private _position;
        private _localDirection;
        private _volume;
        private _isReadyToPlay;
        isPlaying: boolean;
        isPaused: boolean;
        private _isDirectional;
        private _readyToPlayCallback;
        private _audioBuffer;
        private _soundSource;
        private _streamingSource;
        private _soundPanner;
        private _soundGain;
        private _inputAudioNode;
        private _ouputAudioNode;
        private _coneInnerAngle;
        private _coneOuterAngle;
        private _coneOuterGain;
        private _scene;
        private _connectedMesh;
        private _customAttenuationFunction;
        private _registerFunc;
        private _isOutputConnected;
        private _htmlAudioElement;
        private _urlType;
        /**
        * Create a sound and attach it to a scene
        * @param name Name of your sound
        * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer
        * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played
        * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming
        */
        constructor(name: string, urlOrArrayBuffer: any, scene: Scene, readyToPlayCallback?: Nullable<() => void>, options?: any);
        dispose(): void;
        isReady(): boolean;
        private _soundLoaded(audioData);
        setAudioBuffer(audioBuffer: AudioBuffer): void;
        updateOptions(options: any): void;
        private _createSpatialParameters();
        private _updateSpatialParameters();
        switchPanningModelToHRTF(): void;
        switchPanningModelToEqualPower(): void;
        private _switchPanningModel();
        connectToSoundTrackAudioNode(soundTrackAudioNode: AudioNode): void;
        /**
        * Transform this sound into a directional source
        * @param coneInnerAngle Size of the inner cone in degree
        * @param coneOuterAngle Size of the outer cone in degree
        * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)
        */
        setDirectionalCone(coneInnerAngle: number, coneOuterAngle: number, coneOuterGain: number): void;
        setPosition(newPosition: Vector3): void;
        setLocalDirectionToMesh(newLocalDirection: Vector3): void;
        private _updateDirection();
        updateDistanceFromListener(): void;
        setAttenuationFunction(callback: (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => number): void;
        /**
        * Play the sound
        * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.
        * @param offset (optional) Start the sound setting it at a specific time
        */
        play(time?: number, offset?: number): void;
        private _onended();
        /**
        * Stop the sound
        * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.
        */
        stop(time?: number): void;
        pause(): void;
        setVolume(newVolume: number, time?: number): void;
        setPlaybackRate(newPlaybackRate: number): void;
        getVolume(): number;
        attachToMesh(meshToConnectTo: AbstractMesh): void;
        detachFromMesh(): void;
        private _onRegisterAfterWorldMatrixUpdate(node);
        clone(): Nullable<Sound>;
        getAudioBuffer(): AudioBuffer | null;
        serialize(): any;
        static Parse(parsedSound: any, scene: Scene, rootUrl: string, sourceSound?: Sound): Sound;
    }
}

declare module BABYLON {
    class SoundTrack {
        private _outputAudioNode;
        private _scene;
        id: number;
        soundCollection: Array<Sound>;
        private _isMainTrack;
        private _connectedAnalyser;
        private _options;
        private _isInitialized;
        constructor(scene: Scene, options?: any);
        private _initializeSoundTrackAudioGraph();
        dispose(): void;
        AddSound(sound: Sound): void;
        RemoveSound(sound: Sound): void;
        setVolume(newVolume: number): void;
        switchPanningModelToHRTF(): void;
        switchPanningModelToEqualPower(): void;
        connectToAnalyser(analyser: Analyser): void;
    }
}

declare module BABYLON {
    interface Behavior<T extends Node> {
        name: string;
        init(): void;
        attach(node: T): void;
        detach(): void;
    }
}

declare module BABYLON {
    /**
     * Class used to store bone information
     * @see http://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons
     */
    class Bone extends Node {
        /**
         * defines the bone name
         */
        name: string;
        private static _tmpVecs;
        private static _tmpQuat;
        private static _tmpMats;
        /**
         * Gets the list of child bones
         */
        children: Bone[];
        /** Gets the animations associated with this bone */
        animations: Animation[];
        /**
         * Gets or sets bone length
         */
        length: number;
        /**
         * @hidden Internal only
         * Set this value to map this bone to a different index in the transform matrices
         * Set this value to -1 to exclude the bone from the transform matrices
         */
        _index: Nullable<number>;
        private _skeleton;
        private _localMatrix;
        private _restPose;
        private _baseMatrix;
        private _absoluteTransform;
        private _invertedAbsoluteTransform;
        private _parent;
        private _scalingDeterminant;
        private _worldTransform;
        private _localScaling;
        private _localRotation;
        private _localPosition;
        private _needToDecompose;
        private _needToCompose;
        /** @hidden */
        /** @hidden */
        _matrix: Matrix;
        /**
         * Create a new bone
         * @param name defines the bone name
         * @param skeleton defines the parent skeleton
         * @param parentBone defines the parent (can be null if the bone is the root)
         * @param localMatrix defines the local matrix
         * @param restPose defines the rest pose matrix
         * @param baseMatrix defines the base matrix
         * @param index defines index of the bone in the hiearchy
         */
        constructor(
            /**
             * defines the bone name
             */
            name: string, skeleton: Skeleton, parentBone?: Nullable<Bone>, localMatrix?: Nullable<Matrix>, restPose?: Nullable<Matrix>, baseMatrix?: Nullable<Matrix>, index?: Nullable<number>);
        /**
         * Gets the parent skeleton
         * @returns a skeleton
         */
        getSkeleton(): Skeleton;
        /**
         * Gets parent bone
         * @returns a bone or null if the bone is the root of the bone hierarchy
         */
        getParent(): Nullable<Bone>;
        /**
         * Sets the parent bone
         * @param parent defines the parent (can be null if the bone is the root)
         * @param updateDifferenceMatrix defines if the difference matrix must be updated
         */
        setParent(parent: Nullable<Bone>, updateDifferenceMatrix?: boolean): void;
        /**
         * Gets the local matrix
         * @returns a matrix
         */
        getLocalMatrix(): Matrix;
        /**
         * Gets the base matrix (initial matrix which remains unchanged)
         * @returns a matrix
         */
        getBaseMatrix(): Matrix;
        /**
         * Gets the rest pose matrix
         * @returns a matrix
         */
        getRestPose(): Matrix;
        /**
         * Gets a matrix used to store world matrix (ie. the matrix sent to shaders)
         */
        getWorldMatrix(): Matrix;
        /**
         * Sets the local matrix to rest pose matrix
         */
        returnToRest(): void;
        /**
         * Gets the inverse of the absolute transform matrix.
         * This matrix will be multiplied by local matrix to get the difference matrix (ie. the difference between original state and current state)
         * @returns a matrix
         */
        getInvertedAbsoluteTransform(): Matrix;
        /**
         * Gets the absolute transform matrix (ie base matrix * parent world matrix)
         * @returns a matrix
         */
        getAbsoluteTransform(): Matrix;
        /** Gets or sets current position (in local space) */
        position: Vector3;
        /** Gets or sets current rotation (in local space) */
        rotation: Vector3;
        /** Gets or sets current rotation quaternion (in local space) */
        rotationQuaternion: Quaternion;
        /** Gets or sets current scaling (in local space) */
        scaling: Vector3;
        /**
         * Gets the animation properties override
         */
        readonly animationPropertiesOverride: Nullable<AnimationPropertiesOverride>;
        private _decompose();
        private _compose();
        /**
         * Update the base and local matrices
         * @param matrix defines the new base or local matrix
         * @param updateDifferenceMatrix defines if the difference matrix must be updated
         * @param updateLocalMatrix defines if the local matrix should be updated
         */
        updateMatrix(matrix: Matrix, updateDifferenceMatrix?: boolean, updateLocalMatrix?: boolean): void;
        /** @hidden */
        _updateDifferenceMatrix(rootMatrix?: Matrix, updateChildren?: boolean): void;
        /**
         * Flag the bone as dirty (Forcing it to update everything)
         */
        markAsDirty(): void;
        private _markAsDirtyAndCompose();
        private _markAsDirtyAndDecompose();
        /**
         * Copy an animation range from another bone
         * @param source defines the source bone
         * @param rangeName defines the range name to copy
         * @param frameOffset defines the frame offset
         * @param rescaleAsRequired defines if rescaling must be applied if required
         * @param skelDimensionsRatio defines the scaling ratio
         * @returns true if operation was successful
         */
        copyAnimationRange(source: Bone, rangeName: string, frameOffset: number, rescaleAsRequired?: boolean, skelDimensionsRatio?: Nullable<Vector3>): boolean;
        /**
         * Translate the bone in local or world space
         * @param vec The amount to translate the bone
         * @param space The space that the translation is in
         * @param mesh The mesh that this bone is attached to. This is only used in world space
         */
        translate(vec: Vector3, space?: Space, mesh?: AbstractMesh): void;
        /**
         * Set the postion of the bone in local or world space
         * @param position The position to set the bone
         * @param space The space that the position is in
         * @param mesh The mesh that this bone is attached to.  This is only used in world space
         */
        setPosition(position: Vector3, space?: Space, mesh?: AbstractMesh): void;
        /**
         * Set the absolute position of the bone (world space)
         * @param position The position to set the bone
         * @param mesh The mesh that this bone is attached to
         */
        setAbsolutePosition(position: Vector3, mesh?: AbstractMesh): void;
        /**
         * Scale the bone on the x, y and z axes (in local space)
         * @param x The amount to scale the bone on the x axis
         * @param y The amount to scale the bone on the y axis
         * @param z The amount to scale the bone on the z axis
         * @param scaleChildren sets this to true if children of the bone should be scaled as well (false by default)
         */
        scale(x: number, y: number, z: number, scaleChildren?: boolean): void;
        /**
         * Set the bone scaling in local space
         * @param scale defines the scaling vector
         */
        setScale(scale: Vector3): void;
        /**
         * Gets the current scaling in local space
         * @returns the current scaling vector
         */
        getScale(): Vector3;
        /**
         * Gets the current scaling in local space and stores it in a target vector
         * @param result defines the target vector
         */
        getScaleToRef(result: Vector3): void;
        /**
         * Set the yaw, pitch, and roll of the bone in local or world space
         * @param yaw The rotation of the bone on the y axis
         * @param pitch The rotation of the bone on the x axis
         * @param roll The rotation of the bone on the z axis
         * @param space The space that the axes of rotation are in
         * @param mesh The mesh that this bone is attached to.  This is only used in world space
         */
        setYawPitchRoll(yaw: number, pitch: number, roll: number, space?: Space, mesh?: AbstractMesh): void;
        /**
         * Add a rotation to the bone on an axis in local or world space
         * @param axis The axis to rotate the bone on
         * @param amount The amount to rotate the bone
         * @param space The space that the axis is in
         * @param mesh The mesh that this bone is attached to. This is only used in world space
         */
        rotate(axis: Vector3, amount: number, space?: Space, mesh?: AbstractMesh): void;
        /**
         * Set the rotation of the bone to a particular axis angle in local or world space
         * @param axis The axis to rotate the bone on
         * @param angle The angle that the bone should be rotated to
         * @param space The space that the axis is in
         * @param mesh The mesh that this bone is attached to.  This is only used in world space
         */
        setAxisAngle(axis: Vector3, angle: number, space?: Space, mesh?: AbstractMesh): void;
        /**
         * Set the euler rotation of the bone in local of world space
         * @param rotation The euler rotation that the bone should be set to
         * @param space The space that the rotation is in
         * @param mesh The mesh that this bone is attached to. This is only used in world space
         */
        setRotation(rotation: Vector3, space?: Space, mesh?: AbstractMesh): void;
        /**
         * Set the quaternion rotation of the bone in local of world space
         * @param quat The quaternion rotation that the bone should be set to
         * @param space The space that the rotation is in
         * @param mesh The mesh that this bone is attached to. This is only used in world space
         */
        setRotationQuaternion(quat: Quaternion, space?: Space, mesh?: AbstractMesh): void;
        /**
         * Set the rotation matrix of the bone in local of world space
         * @param rotMat The rotation matrix that the bone should be set to
         * @param space The space that the rotation is in
         * @param mesh The mesh that this bone is attached to. This is only used in world space
         */
        setRotationMatrix(rotMat: Matrix, space?: Space, mesh?: AbstractMesh): void;
        private _rotateWithMatrix(rmat, space?, mesh?);
        private _getNegativeRotationToRef(rotMatInv, mesh?);
        /**
         * Get the position of the bone in local or world space
         * @param space The space that the returned position is in
         * @param mesh The mesh that this bone is attached to. This is only used in world space
         * @returns The position of the bone
         */
        getPosition(space?: Space, mesh?: Nullable<AbstractMesh>): Vector3;
        /**
         * Copy the position of the bone to a vector3 in local or world space
         * @param space The space that the returned position is in
         * @param mesh The mesh that this bone is attached to. This is only used in world space
         * @param result The vector3 to copy the position to
         */
        getPositionToRef(space: Space | undefined, mesh: Nullable<AbstractMesh>, result: Vector3): void;
        /**
         * Get the absolute position of the bone (world space)
         * @param mesh The mesh that this bone is attached to
         * @returns The absolute position of the bone
         */
        getAbsolutePosition(mesh?: Nullable<AbstractMesh>): Vector3;
        /**
         * Copy the absolute position of the bone (world space) to the result param
         * @param mesh The mesh that this bone is attached to
         * @param result The vector3 to copy the absolute position to
         */
        getAbsolutePositionToRef(mesh: AbstractMesh, result: Vector3): void;
        /**
         * Compute the absolute transforms of this bone and its children
         */
        computeAbsoluteTransforms(): void;
        /**
         * Get the world direction from an axis that is in the local space of the bone
         * @param localAxis The local direction that is used to compute the world direction
         * @param mesh The mesh that this bone is attached to
         * @returns The world direction
         */
        getDirection(localAxis: Vector3, mesh?: Nullable<AbstractMesh>): Vector3;
        /**
         * Copy the world direction to a vector3 from an axis that is in the local space of the bone
         * @param localAxis The local direction that is used to compute the world direction
         * @param mesh The mesh that this bone is attached to
         * @param result The vector3 that the world direction will be copied to
         */
        getDirectionToRef(localAxis: Vector3, mesh: AbstractMesh | null | undefined, result: Vector3): void;
        /**
         * Get the euler rotation of the bone in local or world space
         * @param space The space that the rotation should be in
         * @param mesh The mesh that this bone is attached to.  This is only used in world space
         * @returns The euler rotation
         */
        getRotation(space?: Space, mesh?: Nullable<AbstractMesh>): Vector3;
        /**
         * Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space
         * @param space The space that the rotation should be in
         * @param mesh The mesh that this bone is attached to.  This is only used in world space
         * @param result The vector3 that the rotation should be copied to
         */
        getRotationToRef(space: Space | undefined, mesh: AbstractMesh | null | undefined, result: Vector3): void;
        /**
         * Get the quaternion rotation of the bone in either local or world space
         * @param space The space that the rotation should be in
         * @param mesh The mesh that this bone is attached to.  This is only used in world space
         * @returns The quaternion rotation
         */
        getRotationQuaternion(space?: Space, mesh?: Nullable<AbstractMesh>): Quaternion;
        /**
         * Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space
         * @param space The space that the rotation should be in
         * @param mesh The mesh that this bone is attached to.  This is only used in world space
         * @param result The quaternion that the rotation should be copied to
         */
        getRotationQuaternionToRef(space: Space | undefined, mesh: AbstractMesh | null | undefined, result: Quaternion): void;
        /**
         * Get the rotation matrix of the bone in local or world space
         * @param space The space that the rotation should be in
         * @param mesh The mesh that this bone is attached to.  This is only used in world space
         * @returns The rotation matrix
         */
        getRotationMatrix(space: Space | undefined, mesh: AbstractMesh): Matrix;
        /**
         * Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space
         * @param space The space that the rotation should be in
         * @param mesh The mesh that this bone is attached to.  This is only used in world space
         * @param result The quaternion that the rotation should be copied to
         */
        getRotationMatrixToRef(space: Space | undefined, mesh: AbstractMesh, result: Matrix): void;
        /**
         * Get the world position of a point that is in the local space of the bone
         * @param position The local position
         * @param mesh The mesh that this bone is attached to
         * @returns The world position
         */
        getAbsolutePositionFromLocal(position: Vector3, mesh?: Nullable<AbstractMesh>): Vector3;
        /**
         * Get the world position of a point that is in the local space of the bone and copy it to the result param
         * @param position The local position
         * @param mesh The mesh that this bone is attached to
         * @param result The vector3 that the world position should be copied to
         */
        getAbsolutePositionFromLocalToRef(position: Vector3, mesh: AbstractMesh | null | undefined, result: Vector3): void;
        /**
         * Get the local position of a point that is in world space
         * @param position The world position
         * @param mesh The mesh that this bone is attached to
         * @returns The local position
         */
        getLocalPositionFromAbsolute(position: Vector3, mesh?: Nullable<AbstractMesh>): Vector3;
        /**
         * Get the local position of a point that is in world space and copy it to the result param
         * @param position The world position
         * @param mesh The mesh that this bone is attached to
         * @param result The vector3 that the local position should be copied to
         */
        getLocalPositionFromAbsoluteToRef(position: Vector3, mesh: AbstractMesh | null | undefined, result: Vector3): void;
    }
}

declare module BABYLON {
    /**
     * Class used to apply inverse kinematics to bones
     * @see http://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons#boneikcontroller
     */
    class BoneIKController {
        private static _tmpVecs;
        private static _tmpQuat;
        private static _tmpMats;
        /**
         * Gets or sets the target mesh
         */
        targetMesh: AbstractMesh;
        /** Gets or sets the mesh used as pole */
        poleTargetMesh: AbstractMesh;
        /**
         * Gets or sets the bone used as pole
         */
        poleTargetBone: Nullable<Bone>;
        /**
         * Gets or sets the target position
         */
        targetPosition: Vector3;
        /**
         * Gets or sets the pole target position
         */
        poleTargetPosition: Vector3;
        /**
         * Gets or sets the pole target local offset
         */
        poleTargetLocalOffset: Vector3;
        /**
         * Gets or sets the pole angle
         */
        poleAngle: number;
        /**
         * Gets or sets the mesh associated with the controller
         */
        mesh: AbstractMesh;
        /**
         * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)
         */
        slerpAmount: number;
        private _bone1Quat;
        private _bone1Mat;
        private _bone2Ang;
        private _bone1;
        private _bone2;
        private _bone1Length;
        private _bone2Length;
        private _maxAngle;
        private _maxReach;
        private _rightHandedSystem;
        private _bendAxis;
        private _slerping;
        private _adjustRoll;
        /**
         * Gets or sets maximum allowed angle
         */
        maxAngle: number;
        /**
         * Creates a new BoneIKController
         * @param mesh defines the mesh to control
         * @param bone defines the bone to control
         * @param options defines options to set up the controller
         */
        constructor(mesh: AbstractMesh, bone: Bone, options?: {
            targetMesh?: AbstractMesh;
            poleTargetMesh?: AbstractMesh;
            poleTargetBone?: Bone;
            poleTargetLocalOffset?: Vector3;
            poleAngle?: number;
            bendAxis?: Vector3;
            maxAngle?: number;
            slerpAmount?: number;
        });
        private _setMaxAngle(ang);
        /**
         * Force the controller to update the bones
         */
        update(): void;
    }
}

declare module BABYLON {
    /**
     * Class used to make a bone look toward a point in space
     * @see http://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons#bonelookcontroller
     */
    class BoneLookController {
        private static _tmpVecs;
        private static _tmpQuat;
        private static _tmpMats;
        /**
         * The target Vector3 that the bone will look at
         */
        target: Vector3;
        /**
         * The mesh that the bone is attached to
         */
        mesh: AbstractMesh;
        /**
         * The bone that will be looking to the target
         */
        bone: Bone;
        /**
         * The up axis of the coordinate system that is used when the bone is rotated
         */
        upAxis: Vector3;
        /**
         * The space that the up axis is in - BABYLON.Space.BONE, BABYLON.Space.LOCAL (default), or BABYLON.Space.WORLD
         */
        upAxisSpace: Space;
        /**
         * Used to make an adjustment to the yaw of the bone
         */
        adjustYaw: number;
        /**
         * Used to make an adjustment to the pitch of the bone
         */
        adjustPitch: number;
        /**
         * Used to make an adjustment to the roll of the bone
         */
        adjustRoll: number;
        /**
         * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)
         */
        slerpAmount: number;
        private _minYaw;
        private _maxYaw;
        private _minPitch;
        private _maxPitch;
        private _minYawSin;
        private _minYawCos;
        private _maxYawSin;
        private _maxYawCos;
        private _midYawConstraint;
        private _minPitchTan;
        private _maxPitchTan;
        private _boneQuat;
        private _slerping;
        private _transformYawPitch;
        private _transformYawPitchInv;
        private _firstFrameSkipped;
        private _yawRange;
        private _fowardAxis;
        /**
         * Gets or sets the minimum yaw angle that the bone can look to
         */
        minYaw: number;
        /**
         * Gets or sets the maximum yaw angle that the bone can look to
         */
        maxYaw: number;
        /**
         * Gets or sets the minimum pitch angle that the bone can look to
         */
        minPitch: number;
        /**
         * Gets or sets the maximum pitch angle that the bone can look to
         */
        maxPitch: number;
        /**
         * Create a BoneLookController
         * @param mesh the mesh that the bone belongs to
         * @param bone the bone that will be looking to the target
         * @param target the target Vector3 to look at
         * @param settings optional settings:
         * * maxYaw: the maximum angle the bone will yaw to
         * * minYaw: the minimum angle the bone will yaw to
         * * maxPitch: the maximum angle the bone will pitch to
         * * minPitch: the minimum angle the bone will yaw to
         * * slerpAmount: set the between 0 and 1 to make the bone slerp to the target.
         * * upAxis: the up axis of the coordinate system
         * * upAxisSpace: the space that the up axis is in - BABYLON.Space.BONE, BABYLON.Space.LOCAL (default), or BABYLON.Space.WORLD.
         * * yawAxis: set yawAxis if the bone does not yaw on the y axis
         * * pitchAxis: set pitchAxis if the bone does not pitch on the x axis
         * * adjustYaw: used to make an adjustment to the yaw of the bone
         * * adjustPitch: used to make an adjustment to the pitch of the bone
         * * adjustRoll: used to make an adjustment to the roll of the bone
         **/
        constructor(mesh: AbstractMesh, bone: Bone, target: Vector3, options?: {
            maxYaw?: number;
            minYaw?: number;
            maxPitch?: number;
            minPitch?: number;
            slerpAmount?: number;
            upAxis?: Vector3;
            upAxisSpace?: Space;
            yawAxis?: Vector3;
            pitchAxis?: Vector3;
            adjustYaw?: number;
            adjustPitch?: number;
            adjustRoll?: number;
        });
        /**
         * Update the bone to look at the target.  This should be called before the scene is rendered (use scene.registerBeforeRender())
         */
        update(): void;
        private _getAngleDiff(ang1, ang2);
        private _getAngleBetween(ang1, ang2);
        private _isAngleBetween(ang, ang1, ang2);
    }
}

declare module BABYLON {
    /**
     * Class used to handle skinning animations
     * @see http://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons
     */
    class Skeleton implements IAnimatable {
        /** defines the skeleton name */
        name: string;
        /** defines the skeleton Id */
        id: string;
        /**
         * Gets the list of child bones
         */
        bones: Bone[];
        /**
         * Gets an estimate of the dimension of the skeleton at rest
         */
        dimensionsAtRest: Vector3;
        /**
         * Gets a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)
         */
        needInitialSkinMatrix: boolean;
        /**
         * Gets the list of animations attached to this skeleton
         */
        animations: Array<Animation>;
        private _scene;
        private _isDirty;
        private _transformMatrices;
        private _meshesWithPoseMatrix;
        private _animatables;
        private _identity;
        private _synchronizedWithMesh;
        private _ranges;
        private _lastAbsoluteTransformsUpdateId;
        /**
         * Specifies if the skeleton should be serialized
         */
        doNotSerialize: boolean;
        private _animationPropertiesOverride;
        /**
         * Gets or sets the animation properties override
         */
        animationPropertiesOverride: Nullable<AnimationPropertiesOverride>;
        /**
         * An observable triggered before computing the skeleton's matrices
         */
        onBeforeComputeObservable: Observable<Skeleton>;
        /**
         * Creates a new skeleton
         * @param name defines the skeleton name
         * @param id defines the skeleton Id
         * @param scene defines the hosting scene
         */
        constructor(
            /** defines the skeleton name */
            name: string, 
            /** defines the skeleton Id */
            id: string, scene: Scene);
        /**
         * Gets the list of transform matrices to send to shaders (one matrix per bone)
         * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)
         * @returns a Float32Array containing matrices data
         */
        getTransformMatrices(mesh: AbstractMesh): Float32Array;
        /**
         * Gets the current hosting scene
         * @returns a scene object
         */
        getScene(): Scene;
        /**
         * Gets a string representing the current skeleton data
         * @param fullDetails defines a boolean indicating if we want a verbose version
         * @returns a string representing the current skeleton data
         */
        toString(fullDetails?: boolean): string;
        /**
        * Get bone's index searching by name
        * @param name defines bone's name to search for
        * @return the indice of the bone. Returns -1 if not found
        */
        getBoneIndexByName(name: string): number;
        /**
         * Creater a new animation range
         * @param name defines the name of the range
         * @param from defines the start key
         * @param to defines the end key
         */
        createAnimationRange(name: string, from: number, to: number): void;
        /**
         * Delete a specific animation range
         * @param name defines the name of the range
         * @param deleteFrames defines if frames must be removed as well
         */
        deleteAnimationRange(name: string, deleteFrames?: boolean): void;
        /**
         * Gets a specific animation range
         * @param name defines the name of the range to look for
         * @returns the requested animation range or null if not found
         */
        getAnimationRange(name: string): Nullable<AnimationRange>;
        /**
         * Gets the list of all animation ranges defined on this skeleton
         * @returns an array
         */
        getAnimationRanges(): Nullable<AnimationRange>[];
        /**
         * Copy animation range from a source skeleton.
         * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences
         * @param source defines the source skeleton
         * @param name defines the name of the range to copy
         * @param rescaleAsRequired defines if rescaling must be applied if required
         * @returns true if operation was successful
         */
        copyAnimationRange(source: Skeleton, name: string, rescaleAsRequired?: boolean): boolean;
        /**
         * Forces the skeleton to go to rest pose
         */
        returnToRest(): void;
        private _getHighestAnimationFrame();
        /**
         * Begin a specific animation range
         * @param name defines the name of the range to start
         * @param loop defines if looping must be turned on (false by default)
         * @param speedRatio defines the speed ratio to apply (1 by default)
         * @param onAnimationEnd defines a callback which will be called when animation will end
         * @returns a new animatable
         */
        beginAnimation(name: string, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void): Nullable<Animatable>;
        /** @hidden */
        _markAsDirty(): void;
        /** @hidden */
        _registerMeshWithPoseMatrix(mesh: AbstractMesh): void;
        /** @hidden */
        _unregisterMeshWithPoseMatrix(mesh: AbstractMesh): void;
        /** @hidden */
        _computeTransformMatrices(targetMatrix: Float32Array, initialSkinMatrix: Nullable<Matrix>): void;
        /**
         * Build all resources required to render a skeleton
         */
        prepare(): void;
        /**
         * Gets the list of animatables currently running for this skeleton
         * @returns an array of animatables
         */
        getAnimatables(): IAnimatable[];
        /**
         * Clone the current skeleton
         * @param name defines the name of the new skeleton
         * @param id defines the id of the enw skeleton
         * @returns the new skeleton
         */
        clone(name: string, id: string): Skeleton;
        /**
         * Enable animation blending for this skeleton
         * @param blendingSpeed defines the blending speed to apply
         * @see http://doc.babylonjs.com/babylon101/animations#animation-blending
         */
        enableBlending(blendingSpeed?: number): void;
        /**
         * Releases all resources associated with the current skeleton
         */
        dispose(): void;
        /**
         * Serialize the skeleton in a JSON object
         * @returns a JSON object
         */
        serialize(): any;
        /**
         * Creates a new skeleton from serialized data
         * @param parsedSkeleton defines the serialized data
         * @param scene defines the hosting scene
         * @returns a new skeleton
         */
        static Parse(parsedSkeleton: any, scene: Scene): Skeleton;
        /**
         * Compute all node absolute transforms
         * @param forceUpdate defines if computation must be done even if cache is up to date
         */
        computeAbsoluteTransforms(forceUpdate?: boolean): void;
        /**
         * Gets the root pose matrix
         * @returns a matrix
         */
        getPoseMatrix(): Nullable<Matrix>;
        /**
         * Sorts bones per internal index
         */
        sortBones(): void;
        private _sortBones(index, bones, visited);
    }
}

declare module BABYLON {
    class Collider {
        /** Define if a collision was found */
        collisionFound: boolean;
        /**
         * Define last intersection point in local space
         */
        intersectionPoint: Vector3;
        /**
         * Define last collided mesh
         */
        collidedMesh: Nullable<AbstractMesh>;
        private _collisionPoint;
        private _planeIntersectionPoint;
        private _tempVector;
        private _tempVector2;
        private _tempVector3;
        private _tempVector4;
        private _edge;
        private _baseToVertex;
        private _destinationPoint;
        private _slidePlaneNormal;
        private _displacementVector;
        _radius: Vector3;
        _retry: number;
        private _velocity;
        private _basePoint;
        private _epsilon;
        _velocityWorldLength: number;
        _basePointWorld: Vector3;
        private _velocityWorld;
        private _normalizedVelocity;
        _initialVelocity: Vector3;
        _initialPosition: Vector3;
        private _nearestDistance;
        private _collisionMask;
        collisionMask: number;
        /**
         * Gets the plane normal used to compute the sliding response (in local space)
         */
        readonly slidePlaneNormal: Vector3;
        _initialize(source: Vector3, dir: Vector3, e: number): void;
        _checkPointInTriangle(point: Vector3, pa: Vector3, pb: Vector3, pc: Vector3, n: Vector3): boolean;
        _canDoCollision(sphereCenter: Vector3, sphereRadius: number, vecMin: Vector3, vecMax: Vector3): boolean;
        _testTriangle(faceIndex: number, trianglePlaneArray: Array<Plane>, p1: Vector3, p2: Vector3, p3: Vector3, hasMaterial: boolean): void;
        _collide(trianglePlaneArray: Array<Plane>, pts: Vector3[], indices: IndicesArray, indexStart: number, indexEnd: number, decal: number, hasMaterial: boolean): void;
        _getResponse(pos: Vector3, vel: Vector3): void;
    }
}

declare module BABYLON {
    var CollisionWorker: string;
    interface ICollisionCoordinator {
        getNewPosition(position: Vector3, displacement: Vector3, collider: Collider, maximumRetry: number, excludedMesh: Nullable<AbstractMesh>, onNewPosition: (collisionIndex: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh>) => void, collisionIndex: number): void;
        init(scene: Scene): void;
        destroy(): void;
        onMeshAdded(mesh: AbstractMesh): void;
        onMeshUpdated(mesh: AbstractMesh): void;
        onMeshRemoved(mesh: AbstractMesh): void;
        onGeometryAdded(geometry: Geometry): void;
        onGeometryUpdated(geometry: Geometry): void;
        onGeometryDeleted(geometry: Geometry): void;
    }
    interface SerializedMesh {
        id: string;
        name: string;
        uniqueId: number;
        geometryId: Nullable<string>;
        sphereCenter: Array<number>;
        sphereRadius: number;
        boxMinimum: Array<number>;
        boxMaximum: Array<number>;
        worldMatrixFromCache: any;
        subMeshes: Array<SerializedSubMesh>;
        checkCollisions: boolean;
    }
    interface SerializedSubMesh {
        position: number;
        verticesStart: number;
        verticesCount: number;
        indexStart: number;
        indexCount: number;
        hasMaterial: boolean;
        sphereCenter: Array<number>;
        sphereRadius: number;
        boxMinimum: Array<number>;
        boxMaximum: Array<number>;
    }
    /**
     * Interface describing the value associated with a geometry
     */
    interface SerializedGeometry {
        /**
         * Defines the unique ID of the geometry
         */
        id: string;
        /**
         * Defines the array containing the positions
         */
        positions: Float32Array;
        /**
         * Defines the array containing the indices
         */
        indices: Uint32Array;
        /**
         * Defines the array containing the normals
         */
        normals: Float32Array;
    }
    interface BabylonMessage {
        taskType: WorkerTaskType;
        payload: InitPayload | CollidePayload | UpdatePayload;
    }
    interface SerializedColliderToWorker {
        position: Array<number>;
        velocity: Array<number>;
        radius: Array<number>;
    }
    /** Defines supported task for worker process */
    enum WorkerTaskType {
        /** Initialization */
        INIT = 0,
        /** Update of geometry */
        UPDATE = 1,
        /** Evaluate collision */
        COLLIDE = 2,
    }
    interface WorkerReply {
        error: WorkerReplyType;
        taskType: WorkerTaskType;
        payload?: any;
    }
    interface CollisionReplyPayload {
        newPosition: Array<number>;
        collisionId: number;
        collidedMeshUniqueId: number;
    }
    interface InitPayload {
    }
    interface CollidePayload {
        collisionId: number;
        collider: SerializedColliderToWorker;
        maximumRetry: number;
        excludedMeshUniqueId: Nullable<number>;
    }
    interface UpdatePayload {
        updatedMeshes: {
            [n: number]: SerializedMesh;
        };
        updatedGeometries: {
            [s: string]: SerializedGeometry;
        };
        removedMeshes: Array<number>;
        removedGeometries: Array<string>;
    }
    /** Defines kind of replies returned by worker */
    enum WorkerReplyType {
        /** Success */
        SUCCESS = 0,
        /** Unkown error */
        UNKNOWN_ERROR = 1,
    }
    class CollisionCoordinatorWorker implements ICollisionCoordinator {
        private _scene;
        private _scaledPosition;
        private _scaledVelocity;
        private _collisionsCallbackArray;
        private _init;
        private _runningUpdated;
        private _worker;
        private _addUpdateMeshesList;
        private _addUpdateGeometriesList;
        private _toRemoveMeshesArray;
        private _toRemoveGeometryArray;
        constructor();
        static SerializeMesh: (mesh: AbstractMesh) => SerializedMesh;
        static SerializeGeometry: (geometry: Geometry) => SerializedGeometry;
        getNewPosition(position: Vector3, displacement: Vector3, collider: Collider, maximumRetry: number, excludedMesh: AbstractMesh, onNewPosition: (collisionIndex: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh>) => void, collisionIndex: number): void;
        init(scene: Scene): void;
        destroy(): void;
        onMeshAdded(mesh: AbstractMesh): void;
        onMeshUpdated: (transformNode: TransformNode) => void;
        onMeshRemoved(mesh: AbstractMesh): void;
        onGeometryAdded(geometry: Geometry): void;
        onGeometryUpdated: (geometry: Geometry) => void;
        onGeometryDeleted(geometry: Geometry): void;
        private _afterRender;
        private _onMessageFromWorker;
    }
    class CollisionCoordinatorLegacy implements ICollisionCoordinator {
        private _scene;
        private _scaledPosition;
        private _scaledVelocity;
        private _finalPosition;
        getNewPosition(position: Vector3, displacement: Vector3, collider: Collider, maximumRetry: number, excludedMesh: AbstractMesh, onNewPosition: (collisionIndex: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh>) => void, collisionIndex: number): void;
        init(scene: Scene): void;
        destroy(): void;
        onMeshAdded(mesh: AbstractMesh): void;
        onMeshUpdated(mesh: AbstractMesh): void;
        onMeshRemoved(mesh: AbstractMesh): void;
        onGeometryAdded(geometry: Geometry): void;
        onGeometryUpdated(geometry: Geometry): void;
        onGeometryDeleted(geometry: Geometry): void;
        private _collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh?);
    }
}

declare function importScripts(...urls: string[]): void;
declare const safePostMessage: any;
declare module BABYLON {
    var WorkerIncluded: boolean;
    class CollisionCache {
        private _meshes;
        private _geometries;
        getMeshes(): {
            [n: number]: SerializedMesh;
        };
        getGeometries(): {
            [s: number]: SerializedGeometry;
        };
        getMesh(id: any): SerializedMesh;
        addMesh(mesh: SerializedMesh): void;
        removeMesh(uniqueId: number): void;
        getGeometry(id: string): SerializedGeometry;
        addGeometry(geometry: SerializedGeometry): void;
        removeGeometry(id: string): void;
    }
    class CollideWorker {
        collider: Collider;
        private _collisionCache;
        private finalPosition;
        private collisionsScalingMatrix;
        private collisionTranformationMatrix;
        constructor(collider: Collider, _collisionCache: CollisionCache, finalPosition: Vector3);
        collideWithWorld(position: Vector3, velocity: Vector3, maximumRetry: number, excludedMeshUniqueId: Nullable<number>): void;
        private checkCollision(mesh);
        private processCollisionsForSubMeshes(transformMatrix, mesh);
        private collideForSubMesh(subMesh, transformMatrix, meshGeometry);
        private checkSubmeshCollision(subMesh);
    }
    interface ICollisionDetector {
        onInit(payload: InitPayload): void;
        onUpdate(payload: UpdatePayload): void;
        onCollision(payload: CollidePayload): void;
    }
    class CollisionDetectorTransferable implements ICollisionDetector {
        private _collisionCache;
        onInit(payload: InitPayload): void;
        onUpdate(payload: UpdatePayload): void;
        onCollision(payload: CollidePayload): void;
    }
}

declare module BABYLON {
    class IntersectionInfo {
        bu: Nullable<number>;
        bv: Nullable<number>;
        distance: number;
        faceId: number;
        subMeshId: number;
        constructor(bu: Nullable<number>, bv: Nullable<number>, distance: number);
    }
    class PickingInfo {
        hit: boolean;
        distance: number;
        pickedPoint: Nullable<Vector3>;
        pickedMesh: Nullable<AbstractMesh>;
        bu: number;
        bv: number;
        faceId: number;
        subMeshId: number;
        pickedSprite: Nullable<Sprite>;
        getNormal(useWorldCoordinates?: boolean, useVerticesNormals?: boolean): Nullable<Vector3>;
        getTextureCoordinates(): Nullable<Vector2>;
    }
}

declare module BABYLON {
    class ArcRotateCamera extends TargetCamera {
        alpha: number;
        beta: number;
        radius: number;
        protected _target: Vector3;
        protected _targetHost: Nullable<AbstractMesh>;
        target: Vector3;
        inertialAlphaOffset: number;
        inertialBetaOffset: number;
        inertialRadiusOffset: number;
        lowerAlphaLimit: Nullable<number>;
        upperAlphaLimit: Nullable<number>;
        lowerBetaLimit: number;
        upperBetaLimit: number;
        lowerRadiusLimit: Nullable<number>;
        upperRadiusLimit: Nullable<number>;
        inertialPanningX: number;
        inertialPanningY: number;
        pinchToPanMaxDistance: number;
        panningDistanceLimit: Nullable<number>;
        panningOriginTarget: Vector3;
        panningInertia: number;
        angularSensibilityX: number;
        angularSensibilityY: number;
        pinchPrecision: number;
        pinchDeltaPercentage: number;
        panningSensibility: number;
        keysUp: number[];
        keysDown: number[];
        keysLeft: number[];
        keysRight: number[];
        wheelPrecision: number;
        wheelDeltaPercentage: number;
        zoomOnFactor: number;
        targetScreenOffset: Vector2;
        allowUpsideDown: boolean;
        _viewMatrix: Matrix;
        _useCtrlForPanning: boolean;
        _panningMouseButton: number;
        inputs: ArcRotateCameraInputsManager;
        _reset: () => void;
        panningAxis: Vector3;
        protected _localDirection: Vector3;
        protected _transformedDirection: Vector3;
        private _bouncingBehavior;
        readonly bouncingBehavior: Nullable<BouncingBehavior>;
        useBouncingBehavior: boolean;
        private _framingBehavior;
        readonly framingBehavior: Nullable<FramingBehavior>;
        useFramingBehavior: boolean;
        private _autoRotationBehavior;
        readonly autoRotationBehavior: Nullable<AutoRotationBehavior>;
        useAutoRotationBehavior: boolean;
        onMeshTargetChangedObservable: Observable<Nullable<AbstractMesh>>;
        onCollide: (collidedMesh: AbstractMesh) => void;
        checkCollisions: boolean;
        collisionRadius: Vector3;
        protected _collider: Collider;
        protected _previousPosition: Vector3;
        protected _collisionVelocity: Vector3;
        protected _newPosition: Vector3;
        protected _previousAlpha: number;
        protected _previousBeta: number;
        protected _previousRadius: number;
        protected _collisionTriggered: boolean;
        protected _targetBoundingCenter: Nullable<Vector3>;
        private _computationVector;
        constructor(name: string, alpha: number, beta: number, radius: number, target: Vector3, scene: Scene, setActiveOnSceneIfNoneActive?: boolean);
        _initCache(): void;
        _updateCache(ignoreParentClass?: boolean): void;
        protected _getTargetPosition(): Vector3;
        /**
         * Store current camera state (fov, position, etc..)
         */
        private _storedAlpha;
        private _storedBeta;
        private _storedRadius;
        private _storedTarget;
        storeState(): Camera;
        /**
         * Restored camera state. You must call storeState() first
         */
        _restoreStateValues(): boolean;
        _isSynchronizedViewMatrix(): boolean;
        attachControl(element: HTMLElement, noPreventDefault?: boolean, useCtrlForPanning?: boolean, panningMouseButton?: number): void;
        detachControl(element: HTMLElement): void;
        _checkInputs(): void;
        protected _checkLimits(): void;
        rebuildAnglesAndRadius(): void;
        setPosition(position: Vector3): void;
        setTarget(target: AbstractMesh | Vector3, toBoundingCenter?: boolean, allowSamePosition?: boolean): void;
        _getViewMatrix(): Matrix;
        protected _onCollisionPositionChange: (collisionId: number, newPosition: Vector3, collidedMesh?: Nullable<AbstractMesh>) => void;
        zoomOn(meshes?: AbstractMesh[], doNotUpdateMaxZ?: boolean): void;
        focusOn(meshesOrMinMaxVectorAndDistance: AbstractMesh[] | {
            min: Vector3;
            max: Vector3;
            distance: number;
        }, doNotUpdateMaxZ?: boolean): void;
        /**
         * @override
         * Override Camera.createRigCamera
         */
        createRigCamera(name: string, cameraIndex: number): Camera;
        /**
         * @override
         * Override Camera._updateRigCameras
         */
        _updateRigCameras(): void;
        dispose(): void;
        getClassName(): string;
    }
}

declare module BABYLON {
    class ArcRotateCameraInputsManager extends CameraInputsManager<ArcRotateCamera> {
        constructor(camera: ArcRotateCamera);
        addMouseWheel(): ArcRotateCameraInputsManager;
        addPointers(): ArcRotateCameraInputsManager;
        addKeyboard(): ArcRotateCameraInputsManager;
        addGamepad(): ArcRotateCameraInputsManager;
        addVRDeviceOrientation(): ArcRotateCameraInputsManager;
    }
}

declare module BABYLON {
    class Camera extends Node {
        inputs: CameraInputsManager<Camera>;
        private static _PERSPECTIVE_CAMERA;
        private static _ORTHOGRAPHIC_CAMERA;
        private static _FOVMODE_VERTICAL_FIXED;
        private static _FOVMODE_HORIZONTAL_FIXED;
        private static _RIG_MODE_NONE;
        private static _RIG_MODE_STEREOSCOPIC_ANAGLYPH;
        private static _RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL;
        private static _RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;
        private static _RIG_MODE_STEREOSCOPIC_OVERUNDER;
        private static _RIG_MODE_VR;
        private static _RIG_MODE_WEBVR;
        static readonly PERSPECTIVE_CAMERA: number;
        static readonly ORTHOGRAPHIC_CAMERA: number;
        /**
         * This is the default FOV mode for perspective cameras.
         * This setting aligns the upper and lower bounds of the viewport to the upper and lower bounds of the camera frustum.
         *
         */
        static readonly FOVMODE_VERTICAL_FIXED: number;
        /**
         * This setting aligns the left and right bounds of the viewport to the left and right bounds of the camera frustum.
         *
         */
        static readonly FOVMODE_HORIZONTAL_FIXED: number;
        static readonly RIG_MODE_NONE: number;
        static readonly RIG_MODE_STEREOSCOPIC_ANAGLYPH: number;
        static readonly RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL: number;
        static readonly RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED: number;
        static readonly RIG_MODE_STEREOSCOPIC_OVERUNDER: number;
        static readonly RIG_MODE_VR: number;
        static readonly RIG_MODE_WEBVR: number;
        static ForceAttachControlToAlwaysPreventDefault: boolean;
        static UseAlternateWebVRRendering: boolean;
        position: Vector3;
        /**
         * The vector the camera should consider as up.
         * (default is Vector3(0, 1, 0) aka Vector3.Up())
         */
        upVector: Vector3;
        orthoLeft: Nullable<number>;
        orthoRight: Nullable<number>;
        orthoBottom: Nullable<number>;
        orthoTop: Nullable<number>;
        /**
         * FOV is set in Radians. (default is 0.8)
         */
        fov: number;
        minZ: number;
        maxZ: number;
        inertia: number;
        mode: number;
        isIntermediate: boolean;
        viewport: Viewport;
        /**
         * Restricts the camera to viewing objects with the same layerMask.
         * A camera with a layerMask of 1 will render mesh.layerMask & camera.layerMask!== 0
         */
        layerMask: number;
        /**
         * fovMode sets the camera frustum bounds to the viewport bounds. (default is FOVMODE_VERTICAL_FIXED)
         */
        fovMode: number;
        cameraRigMode: number;
        interaxialDistance: number;
        isStereoscopicSideBySide: boolean;
        _cameraRigParams: any;
        _rigCameras: Camera[];
        _rigPostProcess: Nullable<PostProcess>;
        protected _webvrViewMatrix: Matrix;
        _skipRendering: boolean;
        _alternateCamera: Camera;
        customRenderTargets: RenderTargetTexture[];
        onViewMatrixChangedObservable: Observable<Camera>;
        onProjectionMatrixChangedObservable: Observable<Camera>;
        onAfterCheckInputsObservable: Observable<Camera>;
        onRestoreStateObservable: Observable<Camera>;
        private _computedViewMatrix;
        _projectionMatrix: Matrix;
        private _doNotComputeProjectionMatrix;
        private _worldMatrix;
        _postProcesses: Nullable<PostProcess>[];
        private _transformMatrix;
        _activeMeshes: SmartArray<AbstractMesh>;
        protected _globalPosition: Vector3;
        private _frustumPlanes;
        private _refreshFrustumPlanes;
        constructor(name: string, position: Vector3, scene: Scene, setActiveOnSceneIfNoneActive?: boolean);
        private _storedFov;
        private _stateStored;
        /**
         * Store current camera state (fov, position, etc..)
         */
        storeState(): Camera;
        /**
         * Restores the camera state values if it has been stored. You must call storeState() first
         */
        protected _restoreStateValues(): boolean;
        /**
         * Restored camera state. You must call storeState() first
         */
        restoreState(): boolean;
        getClassName(): string;
        /**
         * @param {boolean} fullDetails - support for multiple levels of logging within scene loading
         */
        toString(fullDetails?: boolean): string;
        readonly globalPosition: Vector3;
        getActiveMeshes(): SmartArray<AbstractMesh>;
        isActiveMesh(mesh: Mesh): boolean;
        /**
         * Is this camera ready to be used/rendered
         * @param completeCheck defines if a complete check (including post processes) has to be done (false by default)
         * @return true if the camera is ready
         */
        isReady(completeCheck?: boolean): boolean;
        _initCache(): void;
        _updateCache(ignoreParentClass?: boolean): void;
        _isSynchronized(): boolean;
        _isSynchronizedViewMatrix(): boolean;
        _isSynchronizedProjectionMatrix(): boolean;
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        detachControl(element: HTMLElement): void;
        update(): void;
        _checkInputs(): void;
        readonly rigCameras: Camera[];
        readonly rigPostProcess: Nullable<PostProcess>;
        /**
         * Internal, gets the first post proces.
         * @returns the first post process to be run on this camera.
         */
        _getFirstPostProcess(): Nullable<PostProcess>;
        private _cascadePostProcessesToRigCams();
        attachPostProcess(postProcess: PostProcess, insertAt?: Nullable<number>): number;
        detachPostProcess(postProcess: PostProcess): void;
        getWorldMatrix(): Matrix;
        _getViewMatrix(): Matrix;
        getViewMatrix(force?: boolean): Matrix;
        freezeProjectionMatrix(projection?: Matrix): void;
        unfreezeProjectionMatrix(): void;
        getProjectionMatrix(force?: boolean): Matrix;
        getTranformationMatrix(): Matrix;
        private updateFrustumPlanes();
        isInFrustum(target: ICullable): boolean;
        isCompletelyInFrustum(target: ICullable): boolean;
        getForwardRay(length?: number, transform?: Matrix, origin?: Vector3): Ray;
        /**
         * Releases resources associated with this node.
         * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
         * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
         */
        dispose(doNotRecurse?: boolean, disposeMaterialAndTextures?: boolean): void;
        readonly leftCamera: Nullable<FreeCamera>;
        readonly rightCamera: Nullable<FreeCamera>;
        getLeftTarget(): Nullable<Vector3>;
        getRightTarget(): Nullable<Vector3>;
        setCameraRigMode(mode: number, rigParams: any): void;
        private _getVRProjectionMatrix();
        protected _updateCameraRotationMatrix(): void;
        protected _updateWebVRCameraRotationMatrix(): void;
        /**
         * This function MUST be overwritten by the different WebVR cameras available.
         * The context in which it is running is the RIG camera. So 'this' is the TargetCamera, left or right.
         */
        protected _getWebVRProjectionMatrix(): Matrix;
        /**
         * This function MUST be overwritten by the different WebVR cameras available.
         * The context in which it is running is the RIG camera. So 'this' is the TargetCamera, left or right.
         */
        protected _getWebVRViewMatrix(): Matrix;
        setCameraRigParameter(name: string, value: any): void;
        /**
         * needs to be overridden by children so sub has required properties to be copied
         */
        createRigCamera(name: string, cameraIndex: number): Nullable<Camera>;
        /**
         * May need to be overridden by children
         */
        _updateRigCameras(): void;
        _setupInputs(): void;
        serialize(): any;
        clone(name: string): Camera;
        getDirection(localAxis: Vector3): Vector3;
        getDirectionToRef(localAxis: Vector3, result: Vector3): void;
        static GetConstructorFromName(type: string, name: string, scene: Scene, interaxial_distance?: number, isStereoscopicSideBySide?: boolean): () => Camera;
        computeWorldMatrix(): Matrix;
        static Parse(parsedCamera: any, scene: Scene): Camera;
    }
}

declare module BABYLON {
    var CameraInputTypes: {};
    interface ICameraInput<TCamera extends Camera> {
        camera: Nullable<TCamera>;
        getClassName(): string;
        getSimpleName(): string;
        attachControl: (element: HTMLElement, noPreventDefault?: boolean) => void;
        detachControl: (element: Nullable<HTMLElement>) => void;
        checkInputs?: () => void;
    }
    interface CameraInputsMap<TCamera extends Camera> {
        [name: string]: ICameraInput<TCamera>;
        [idx: number]: ICameraInput<TCamera>;
    }
    class CameraInputsManager<TCamera extends Camera> {
        attached: CameraInputsMap<TCamera>;
        attachedElement: Nullable<HTMLElement>;
        noPreventDefault: boolean;
        camera: TCamera;
        checkInputs: () => void;
        constructor(camera: TCamera);
        /**
         * Add an input method to a camera.
         * builtin inputs example: camera.inputs.addGamepad();
         * custom inputs example: camera.inputs.add(new BABYLON.FreeCameraGamepadInput());
         * @param input camera input method
         */
        add(input: ICameraInput<TCamera>): void;
        /**
         * Remove a specific input method from a camera
         * example: camera.inputs.remove(camera.inputs.attached.mouse);
         * @param inputToRemove camera input method
         */
        remove(inputToRemove: ICameraInput<TCamera>): void;
        removeByType(inputType: string): void;
        private _addCheckInputs(fn);
        attachInput(input: ICameraInput<TCamera>): void;
        attachElement(element: HTMLElement, noPreventDefault?: boolean): void;
        detachElement(element: HTMLElement, disconnect?: boolean): void;
        rebuildInputCheck(): void;
        /**
         * Remove all attached input methods from a camera
         */
        clear(): void;
        serialize(serializedCamera: any): void;
        parse(parsedCamera: any): void;
    }
}

declare module BABYLON {
    /**
     * This is a camera specifically designed to react to device orientation events such as a modern mobile device
     * being tilted forward or back and left or right.
     */
    class DeviceOrientationCamera extends FreeCamera {
        private _initialQuaternion;
        private _quaternionCache;
        /**
         * Creates a new device orientation camera
         * @param name The name of the camera
         * @param position The start position camera
         * @param scene The scene the camera belongs to
         */
        constructor(name: string, position: Vector3, scene: Scene);
        /**
         * Gets the current instance class name ("DeviceOrientationCamera").
         * This helps avoiding instanceof at run time.
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Checks and applies the current values of the inputs to the camera. (Internal use only)
         */
        _checkInputs(): void;
        /**
         * Reset the camera to its default orientation on the specified axis only.
         * @param axis The axis to reset
         */
        resetToCurrentRotation(axis?: Axis): void;
    }
}

declare module BABYLON {
    class FollowCamera extends TargetCamera {
        radius: number;
        rotationOffset: number;
        heightOffset: number;
        cameraAcceleration: number;
        maxCameraSpeed: number;
        lockedTarget: Nullable<AbstractMesh>;
        constructor(name: string, position: Vector3, scene: Scene, lockedTarget?: Nullable<AbstractMesh>);
        private getRadians(degrees);
        private follow(cameraTarget);
        _checkInputs(): void;
        getClassName(): string;
    }
    class ArcFollowCamera extends TargetCamera {
        alpha: number;
        beta: number;
        radius: number;
        target: Nullable<AbstractMesh>;
        private _cartesianCoordinates;
        constructor(name: string, alpha: number, beta: number, radius: number, target: Nullable<AbstractMesh>, scene: Scene);
        private follow();
        _checkInputs(): void;
        getClassName(): string;
    }
}

declare module BABYLON {
    class FreeCamera extends TargetCamera {
        ellipsoid: Vector3;
        ellipsoidOffset: Vector3;
        checkCollisions: boolean;
        applyGravity: boolean;
        inputs: FreeCameraInputsManager;
        /**
         * Gets the input sensibility for a mouse input. (default is 2000.0)
         * Higher values reduce sensitivity.
         */
        /**
         * Sets the input sensibility for a mouse input. (default is 2000.0)
         * Higher values reduce sensitivity.
         */
        angularSensibility: number;
        keysUp: number[];
        keysDown: number[];
        keysLeft: number[];
        keysRight: number[];
        onCollide: (collidedMesh: AbstractMesh) => void;
        private _collider;
        private _needMoveForGravity;
        private _oldPosition;
        private _diffPosition;
        private _newPosition;
        _localDirection: Vector3;
        _transformedDirection: Vector3;
        constructor(name: string, position: Vector3, scene: Scene, setActiveOnSceneIfNoneActive?: boolean);
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        detachControl(element: HTMLElement): void;
        private _collisionMask;
        collisionMask: number;
        _collideWithWorld(displacement: Vector3): void;
        private _onCollisionPositionChange;
        _checkInputs(): void;
        _decideIfNeedsToMove(): boolean;
        _updatePosition(): void;
        dispose(): void;
        getClassName(): string;
    }
}

declare module BABYLON {
    class FreeCameraInputsManager extends CameraInputsManager<FreeCamera> {
        constructor(camera: FreeCamera);
        addKeyboard(): FreeCameraInputsManager;
        addMouse(touchEnabled?: boolean): FreeCameraInputsManager;
        addGamepad(): FreeCameraInputsManager;
        addDeviceOrientation(): FreeCameraInputsManager;
        addTouch(): FreeCameraInputsManager;
        addVirtualJoystick(): FreeCameraInputsManager;
    }
}

declare module BABYLON {
    class GamepadCamera extends UniversalCamera {
        gamepadAngularSensibility: number;
        gamepadMoveSensibility: number;
        constructor(name: string, position: Vector3, scene: Scene);
        getClassName(): string;
    }
}

declare module BABYLON {
    /**
     * Camera used to simulate anaglyphic rendering (based on FreeCamera)
     */
    class AnaglyphFreeCamera extends FreeCamera {
        /**
         * Creates a new AnaglyphFreeCamera
         * @param name defines camera name
         * @param position defines initial position
         * @param interaxialDistance defines distance between each color axis
         * @param scene defines the hosting scene
         */
        constructor(name: string, position: Vector3, interaxialDistance: number, scene: Scene);
        /**
         * Gets camera class name
         * @returns AnaglyphFreeCamera
         */
        getClassName(): string;
    }
    /**
     * Camera used to simulate anaglyphic rendering (based on ArcRotateCamera)
     */
    class AnaglyphArcRotateCamera extends ArcRotateCamera {
        /**
         * Creates a new AnaglyphArcRotateCamera
         * @param name defines camera name
         * @param alpha defines alpha angle (in radians)
         * @param beta defines beta angle (in radians)
         * @param radius defines radius
         * @param target defines camera target
         * @param interaxialDistance defines distance between each color axis
         * @param scene defines the hosting scene
         */
        constructor(name: string, alpha: number, beta: number, radius: number, target: Vector3, interaxialDistance: number, scene: Scene);
        /**
         * Gets camera class name
         * @returns AnaglyphArcRotateCamera
         */
        getClassName(): string;
    }
    /**
     * Camera used to simulate anaglyphic rendering (based on GamepadCamera)
     */
    class AnaglyphGamepadCamera extends GamepadCamera {
        /**
         * Creates a new AnaglyphGamepadCamera
         * @param name defines camera name
         * @param position defines initial position
         * @param interaxialDistance defines distance between each color axis
         * @param scene defines the hosting scene
         */
        constructor(name: string, position: Vector3, interaxialDistance: number, scene: Scene);
        /**
         * Gets camera class name
         * @returns AnaglyphGamepadCamera
         */
        getClassName(): string;
    }
    /**
     * Camera used to simulate anaglyphic rendering (based on UniversalCamera)
     */
    class AnaglyphUniversalCamera extends UniversalCamera {
        /**
         * Creates a new AnaglyphUniversalCamera
         * @param name defines camera name
         * @param position defines initial position
         * @param interaxialDistance defines distance between each color axis
         * @param scene defines the hosting scene
         */
        constructor(name: string, position: Vector3, interaxialDistance: number, scene: Scene);
        /**
         * Gets camera class name
         * @returns AnaglyphUniversalCamera
         */
        getClassName(): string;
    }
    /**
     * Camera used to simulate stereoscopic rendering (based on FreeCamera)
     */
    class StereoscopicFreeCamera extends FreeCamera {
        /**
         * Creates a new StereoscopicFreeCamera
         * @param name defines camera name
         * @param position defines initial position
         * @param interaxialDistance defines distance between each color axis
         * @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under
         * @param scene defines the hosting scene
         */
        constructor(name: string, position: Vector3, interaxialDistance: number, isStereoscopicSideBySide: boolean, scene: Scene);
        /**
         * Gets camera class name
         * @returns StereoscopicFreeCamera
         */
        getClassName(): string;
    }
    /**
     * Camera used to simulate stereoscopic rendering (based on ArcRotateCamera)
     */
    class StereoscopicArcRotateCamera extends ArcRotateCamera {
        /**
         * Creates a new StereoscopicArcRotateCamera
         * @param name defines camera name
         * @param alpha defines alpha angle (in radians)
         * @param beta defines beta angle (in radians)
         * @param radius defines radius
         * @param target defines camera target
         * @param interaxialDistance defines distance between each color axis
         * @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under
         * @param scene defines the hosting scene
         */
        constructor(name: string, alpha: number, beta: number, radius: number, target: Vector3, interaxialDistance: number, isStereoscopicSideBySide: boolean, scene: Scene);
        /**
         * Gets camera class name
         * @returns StereoscopicArcRotateCamera
         */
        getClassName(): string;
    }
    /**
     * Camera used to simulate stereoscopic rendering (based on GamepadCamera)
     */
    class StereoscopicGamepadCamera extends GamepadCamera {
        /**
         * Creates a new StereoscopicGamepadCamera
         * @param name defines camera name
         * @param position defines initial position
         * @param interaxialDistance defines distance between each color axis
         * @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under
         * @param scene defines the hosting scene
         */
        constructor(name: string, position: Vector3, interaxialDistance: number, isStereoscopicSideBySide: boolean, scene: Scene);
        /**
         * Gets camera class name
         * @returns StereoscopicGamepadCamera
         */
        getClassName(): string;
    }
    /**
     * Camera used to simulate stereoscopic rendering (based on UniversalCamera)
     */
    class StereoscopicUniversalCamera extends UniversalCamera {
        /**
         * Creates a new StereoscopicUniversalCamera
         * @param name defines camera name
         * @param position defines initial position
         * @param interaxialDistance defines distance between each color axis
         * @param isStereoscopicSideBySide defines is stereoscopic is done side by side or over under
         * @param scene defines the hosting scene
         */
        constructor(name: string, position: Vector3, interaxialDistance: number, isStereoscopicSideBySide: boolean, scene: Scene);
        /**
         * Gets camera class name
         * @returns StereoscopicUniversalCamera
         */
        getClassName(): string;
    }
}

declare module BABYLON {
    class TargetCamera extends Camera {
        cameraDirection: Vector3;
        cameraRotation: Vector2;
        rotation: Vector3;
        rotationQuaternion: Quaternion;
        speed: number;
        noRotationConstraint: boolean;
        lockedTarget: any;
        _currentTarget: Vector3;
        _viewMatrix: Matrix;
        _camMatrix: Matrix;
        _cameraTransformMatrix: Matrix;
        _cameraRotationMatrix: Matrix;
        private _rigCamTransformMatrix;
        _referencePoint: Vector3;
        private _currentUpVector;
        _transformedReferencePoint: Vector3;
        protected _globalCurrentTarget: Vector3;
        protected _globalCurrentUpVector: Vector3;
        _reset: () => void;
        constructor(name: string, position: Vector3, scene: Scene, setActiveOnSceneIfNoneActive?: boolean);
        getFrontPosition(distance: number): Vector3;
        _getLockedTargetPosition(): Nullable<Vector3>;
        /**
         * Store current camera state (fov, position, etc..)
         */
        private _storedPosition;
        private _storedRotation;
        private _storedRotationQuaternion;
        storeState(): Camera;
        /**
         * Restored camera state. You must call storeState() first
         */
        _restoreStateValues(): boolean;
        _initCache(): void;
        _updateCache(ignoreParentClass?: boolean): void;
        _isSynchronizedViewMatrix(): boolean;
        _computeLocalCameraSpeed(): number;
        setTarget(target: Vector3): void;
        /**
         * Return the current target position of the camera. This value is expressed in local space.
         */
        getTarget(): Vector3;
        _decideIfNeedsToMove(): boolean;
        _updatePosition(): void;
        _checkInputs(): void;
        protected _updateCameraRotationMatrix(): void;
        _getViewMatrix(): Matrix;
        protected _computeViewMatrix(position: Vector3, target: Vector3, up: Vector3): void;
        /**
         * @override
         * Override Camera.createRigCamera
         */
        createRigCamera(name: string, cameraIndex: number): Nullable<Camera>;
        /**
         * @override
         * Override Camera._updateRigCameras
         */
        _updateRigCameras(): void;
        private _getRigCamPosition(halfSpace, result);
        getClassName(): string;
    }
}

declare module BABYLON {
    class TouchCamera extends FreeCamera {
        touchAngularSensibility: number;
        touchMoveSensibility: number;
        constructor(name: string, position: Vector3, scene: Scene);
        getClassName(): string;
        _setupInputs(): void;
    }
}

declare module BABYLON {
    class UniversalCamera extends TouchCamera {
        gamepadAngularSensibility: number;
        gamepadMoveSensibility: number;
        constructor(name: string, position: Vector3, scene: Scene);
        getClassName(): string;
    }
}

declare module BABYLON {
    class VirtualJoysticksCamera extends FreeCamera {
        constructor(name: string, position: Vector3, scene: Scene);
        getClassName(): string;
    }
}

interface VRDisplay extends EventTarget {
    /**
     * Dictionary of capabilities describing the VRDisplay.
     */
    readonly capabilities: VRDisplayCapabilities;
    /**
     * z-depth defining the far plane of the eye view frustum
     * enables mapping of values in the render target depth
     * attachment to scene coordinates. Initially set to 10000.0.
     */
    depthFar: number;
    /**
     * z-depth defining the near plane of the eye view frustum
     * enables mapping of values in the render target depth
     * attachment to scene coordinates. Initially set to 0.01.
     */
    depthNear: number;
    /**
     * An identifier for this distinct VRDisplay. Used as an
     * association point in the Gamepad API.
     */
    readonly displayId: number;
    /**
     * A display name, a user-readable name identifying it.
     */
    readonly displayName: string;
    readonly isConnected: boolean;
    readonly isPresenting: boolean;
    /**
     * If this VRDisplay supports room-scale experiences, the optional
     * stage attribute contains details on the room-scale parameters.
     */
    readonly stageParameters: VRStageParameters | null;
    /**
     * Passing the value returned by `requestAnimationFrame` to
     * `cancelAnimationFrame` will unregister the callback.
     */
    cancelAnimationFrame(handle: number): void;
    /**
     * Stops presenting to the VRDisplay.
     */
    exitPresent(): Promise<void>;
    getEyeParameters(whichEye: string): VREyeParameters;
    /**
     * Populates the passed VRFrameData with the information required to render
     * the current frame.
     */
    getFrameData(frameData: VRFrameData): boolean;
    /**
     * Get the layers currently being presented.
     */
    getLayers(): VRLayer[];
    /**
     * Return a VRPose containing the future predicted pose of the VRDisplay
     * when the current frame will be presented. The value returned will not
     * change until JavaScript has returned control to the browser.
     *
     * The VRPose will contain the position, orientation, velocity,
     * and acceleration of each of these properties.
     */
    getPose(): VRPose;
    /**
     * Return the current instantaneous pose of the VRDisplay, with no
     * prediction applied.
     */
    getImmediatePose(): VRPose;
    /**
     * The callback passed to `requestAnimationFrame` will be called
     * any time a new frame should be rendered. When the VRDisplay is
     * presenting the callback will be called at the native refresh
     * rate of the HMD. When not presenting this function acts
     * identically to how window.requestAnimationFrame acts. Content should
     * make no assumptions of frame rate or vsync behavior as the HMD runs
     * asynchronously from other displays and at differing refresh rates.
     */
    requestAnimationFrame(callback: FrameRequestCallback): number;
    /**
     * Begin presenting to the VRDisplay. Must be called in response to a user gesture.
     * Repeat calls while already presenting will update the VRLayers being displayed.
     */
    requestPresent(layers: VRLayer[]): Promise<void>;
    /**
     * Reset the pose for this display, treating its current position and
     * orientation as the "origin/zero" values. VRPose.position,
     * VRPose.orientation, and VRStageParameters.sittingToStandingTransform may be
     * updated when calling resetPose(). This should be called in only
     * sitting-space experiences.
     */
    resetPose(): void;
    /**
     * The VRLayer provided to the VRDisplay will be captured and presented
     * in the HMD. Calling this function has the same effect on the source
     * canvas as any other operation that uses its source image, and canvases
     * created without preserveDrawingBuffer set to true will be cleared.
     */
    submitFrame(pose?: VRPose): void;
}
declare var VRDisplay: {
    prototype: VRDisplay;
    new (): VRDisplay;
};
interface VRLayer {
    leftBounds?: number[] | null;
    rightBounds?: number[] | null;
    source?: HTMLCanvasElement | null;
}
interface VRDisplayCapabilities {
    readonly canPresent: boolean;
    readonly hasExternalDisplay: boolean;
    readonly hasOrientation: boolean;
    readonly hasPosition: boolean;
    readonly maxLayers: number;
}
interface VREyeParameters {
    /** @deprecated */
    readonly fieldOfView: VRFieldOfView;
    readonly offset: Float32Array;
    readonly renderHeight: number;
    readonly renderWidth: number;
}
interface VRFieldOfView {
    readonly downDegrees: number;
    readonly leftDegrees: number;
    readonly rightDegrees: number;
    readonly upDegrees: number;
}
interface VRFrameData {
    readonly leftProjectionMatrix: Float32Array;
    readonly leftViewMatrix: Float32Array;
    readonly pose: VRPose;
    readonly rightProjectionMatrix: Float32Array;
    readonly rightViewMatrix: Float32Array;
    readonly timestamp: number;
}
interface VRPose {
    readonly angularAcceleration: Float32Array | null;
    readonly angularVelocity: Float32Array | null;
    readonly linearAcceleration: Float32Array | null;
    readonly linearVelocity: Float32Array | null;
    readonly orientation: Float32Array | null;
    readonly position: Float32Array | null;
    readonly timestamp: number;
}
interface VRStageParameters {
    sittingToStandingTransform?: Float32Array;
    sizeX?: number;
    sizeY?: number;
}
interface Navigator {
    getVRDisplays(): Promise<VRDisplay[]>;
    readonly activeVRDisplays: ReadonlyArray<VRDisplay>;
}
interface Window {
    onvrdisplayconnected: ((this: Window, ev: Event) => any) | null;
    onvrdisplaydisconnected: ((this: Window, ev: Event) => any) | null;
    onvrdisplaypresentchange: ((this: Window, ev: Event) => any) | null;
    addEventListener(type: "vrdisplayconnected", listener: (ev: Event) => any, useCapture?: boolean): void;
    addEventListener(type: "vrdisplaydisconnected", listener: (ev: Event) => any, useCapture?: boolean): void;
    addEventListener(type: "vrdisplaypresentchange", listener: (ev: Event) => any, useCapture?: boolean): void;
}
interface Gamepad {
    readonly displayId: number;
}

/**
 * Module Debug contains the (visual) components to debug a scene correctly
 */
declare module BABYLON.Debug {
    /**
     * The Axes viewer will show 3 axes in a specific point in space
     */
    class AxesViewer {
        private _xline;
        private _yline;
        private _zline;
        private _xmesh;
        private _ymesh;
        private _zmesh;
        scene: Nullable<Scene>;
        scaleLines: number;
        constructor(scene: Scene, scaleLines?: number);
        update(position: Vector3, xaxis: Vector3, yaxis: Vector3, zaxis: Vector3): void;
        dispose(): void;
    }
}

declare module BABYLON.Debug {
    /**
     * The BoneAxesViewer will attach 3 axes to a specific bone of a specific mesh
     */
    class BoneAxesViewer extends AxesViewer {
        mesh: Nullable<Mesh>;
        bone: Nullable<Bone>;
        pos: Vector3;
        xaxis: Vector3;
        yaxis: Vector3;
        zaxis: Vector3;
        constructor(scene: Scene, bone: Bone, mesh: Mesh, scaleLines?: number);
        update(): void;
        dispose(): void;
    }
}

declare module BABYLON {
    class DebugLayer {
        private _scene;
        static InspectorURL: string;
        private _inspector;
        private BJSINSPECTOR;
        constructor(scene: Scene);
        /** Creates the inspector window. */
        private _createInspector(config?);
        isVisible(): boolean;
        hide(): void;
        show(config?: {
            popup?: boolean;
            initialTab?: number;
            parentElement?: HTMLElement;
            newColors?: {
                backgroundColor?: string;
                backgroundColorLighter?: string;
                backgroundColorLighter2?: string;
                backgroundColorLighter3?: string;
                color?: string;
                colorTop?: string;
                colorBot?: string;
            };
        }): void;
    }
}

declare module BABYLON.Debug {
    /**
     * Used to show the physics impostor around the specific mesh.
     */
    class PhysicsViewer {
        protected _impostors: Array<Nullable<PhysicsImpostor>>;
        protected _meshes: Array<Nullable<AbstractMesh>>;
        protected _scene: Nullable<Scene>;
        protected _numMeshes: number;
        protected _physicsEnginePlugin: Nullable<IPhysicsEnginePlugin>;
        private _renderFunction;
        private _debugBoxMesh;
        private _debugSphereMesh;
        private _debugMaterial;
        constructor(scene: Scene);
        protected _updateDebugMeshes(): void;
        showImpostor(impostor: PhysicsImpostor): void;
        hideImpostor(impostor: Nullable<PhysicsImpostor>): void;
        private _getDebugMaterial(scene);
        private _getDebugBoxMesh(scene);
        private _getDebugSphereMesh(scene);
        private _getDebugMesh(impostor, scene);
        dispose(): void;
    }
}

declare module BABYLON {
    class RayHelper {
        ray: Nullable<Ray>;
        private _renderPoints;
        private _renderLine;
        private _renderFunction;
        private _scene;
        private _updateToMeshFunction;
        private _attachedToMesh;
        private _meshSpaceDirection;
        private _meshSpaceOrigin;
        static CreateAndShow(ray: Ray, scene: Scene, color: Color3): RayHelper;
        constructor(ray: Ray);
        show(scene: Scene, color: Color3): void;
        hide(): void;
        private _render();
        attachToMesh(mesh: AbstractMesh, meshSpaceDirection?: Vector3, meshSpaceOrigin?: Vector3, length?: number): void;
        detachFromMesh(): void;
        private _updateToMesh();
        dispose(): void;
    }
}

declare module BABYLON.Debug {
    /**
    * Demo available here: http://www.babylonjs-playground.com/#1BZJVJ#8
    */
    class SkeletonViewer {
        skeleton: Skeleton;
        mesh: AbstractMesh;
        autoUpdateBonesMatrices: boolean;
        renderingGroupId: number;
        color: Color3;
        private _scene;
        private _debugLines;
        private _debugMesh;
        private _isEnabled;
        private _renderFunction;
        constructor(skeleton: Skeleton, mesh: AbstractMesh, scene: Scene, autoUpdateBonesMatrices?: boolean, renderingGroupId?: number);
        isEnabled: boolean;
        private _getBonePosition(position, bone, meshMat, x?, y?, z?);
        private _getLinesForBonesWithLength(bones, meshMat);
        private _getLinesForBonesNoLength(bones, meshMat);
        update(): void;
        dispose(): void;
    }
}

declare module BABYLON {
    /**
     * Interface for attribute information associated with buffer instanciation
     */
    class InstancingAttributeInfo {
        /**
         * Index/offset of the attribute in the vertex shader
         */
        index: number;
        /**
         * size of the attribute, 1, 2, 3 or 4
         */
        attributeSize: number;
        /**
         * type of the attribute, gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.FIXED, gl.FLOAT.
         * default is FLOAT
         */
        attribyteType: number;
        /**
         * normalization of fixed-point data. behavior unclear, use FALSE, default is FALSE
         */
        normalized: boolean;
        /**
         * Offset of the data in the Vertex Buffer acting as the instancing buffer
         */
        offset: number;
        /**
         * Name of the GLSL attribute, for debugging purpose only
         */
        attributeName: string;
    }
    /**
     * Define options used to create a render target texture
     */
    class RenderTargetCreationOptions {
        /**
         * Specifies is mipmaps must be generated
         */
        generateMipMaps?: boolean;
        /** Specifies whether or not a depth should be allocated in the texture (true by default) */
        generateDepthBuffer?: boolean;
        /** Specifies whether or not a stencil should be allocated in the texture (false by default)*/
        generateStencilBuffer?: boolean;
        /** Defines texture type (int by default) */
        type?: number;
        /** Defines sampling mode (trilinear by default) */
        samplingMode?: number;
        /** Defines format (RGBA by default) */
        format?: number;
    }
    /**
     * Define options used to create a depth texture
     */
    class DepthTextureCreationOptions {
        /** Specifies whether or not a stencil should be allocated in the texture */
        generateStencil?: boolean;
        /** Specifies whether or not bilinear filtering is enable on the texture */
        bilinearFiltering?: boolean;
        /** Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode */
        comparisonFunction?: number;
        /** Specifies if the created texture is a cube texture */
        isCube?: boolean;
    }
    /**
     * Class used to describe the capabilities of the engine relatively to the current browser
     */
    class EngineCapabilities {
        /** Maximum textures units per fragment shader */
        maxTexturesImageUnits: number;
        /** Maximum texture units per vertex shader */
        maxVertexTextureImageUnits: number;
        /** Maximum textures units in the entire pipeline */
        maxCombinedTexturesImageUnits: number;
        /** Maximum texture size */
        maxTextureSize: number;
        /** Maximum cube texture size */
        maxCubemapTextureSize: number;
        /** Maximum render texture size */
        maxRenderTextureSize: number;
        /** Maximum number of vertex attributes */
        maxVertexAttribs: number;
        /** Maximum number of varyings */
        maxVaryingVectors: number;
        /** Maximum number of uniforms per vertex shader */
        maxVertexUniformVectors: number;
        /** Maximum number of uniforms per fragment shader */
        maxFragmentUniformVectors: number;
        /** Defines if standard derivates (dx/dy) are supported */
        standardDerivatives: boolean;
        /** Defines if s3tc texture compression is supported */
        s3tc: Nullable<WEBGL_compressed_texture_s3tc>;
        /** Defines if pvrtc texture compression is supported */
        pvrtc: any;
        /** Defines if etc1 texture compression is supported */
        etc1: any;
        /** Defines if etc2 texture compression is supported */
        etc2: any;
        /** Defines if astc texture compression is supported */
        astc: any;
        /** Defines if float textures are supported */
        textureFloat: boolean;
        /** Defines if vertex array objects are supported */
        vertexArrayObject: boolean;
        /** Gets the webgl extension for anisotropic filtering (null if not supported) */
        textureAnisotropicFilterExtension: Nullable<EXT_texture_filter_anisotropic>;
        /** Gets the maximum level of anisotropy supported */
        maxAnisotropy: number;
        /** Defines if instancing is supported */
        instancedArrays: boolean;
        /** Defines if 32 bits indices are supported */
        uintIndices: boolean;
        /** Defines if high precision shaders are supported */
        highPrecisionShaderSupported: boolean;
        /** Defines if depth reading in the fragment shader is supported */
        fragmentDepthSupported: boolean;
        /** Defines if float texture linear filtering is supported*/
        textureFloatLinearFiltering: boolean;
        /** Defines if rendering to float textures is supported */
        textureFloatRender: boolean;
        /** Defines if half float textures are supported*/
        textureHalfFloat: boolean;
        /** Defines if half float texture linear filtering is supported*/
        textureHalfFloatLinearFiltering: boolean;
        /** Defines if rendering to half float textures is supported */
        textureHalfFloatRender: boolean;
        /** Defines if textureLOD shader command is supported */
        textureLOD: boolean;
        /** Defines if draw buffers extension is supported */
        drawBuffersExtension: boolean;
        /** Defines if depth textures are supported */
        depthTextureExtension: boolean;
        /** Defines if float color buffer are supported */
        colorBufferFloat: boolean;
        /** Gets disjoint timer query extension (null if not supported) */
        timerQuery: EXT_disjoint_timer_query;
        /** Defines if timestamp can be used with timer query */
        canUseTimestampForTimerQuery: boolean;
    }
    /** Interface defining initialization parameters for Engine class */
    interface EngineOptions extends WebGLContextAttributes {
        /**
         * Defines if the engine should no exceed a specified device ratio
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio
         */
        limitDeviceRatio?: number;
        /**
         * Defines if webvr should be enabled automatically
         * @see http://doc.babylonjs.com/how_to/webvr_camera
         */
        autoEnableWebVR?: boolean;
        /**
         * Defines if webgl2 should be turned off even if supported
         * @see http://doc.babylonjs.com/features/webgl2
         */
        disableWebGL2Support?: boolean;
        /**
         * Defines if webaudio should be initialized as well
         * @see http://doc.babylonjs.com/how_to/playing_sounds_and_music
         */
        audioEngine?: boolean;
        /**
         * Defines if animations should run using a deterministic lock step
         * @see http://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         */
        deterministicLockstep?: boolean;
        /** Defines the maximum steps to use with deterministic lock step mode */
        lockstepMaxSteps?: number;
        /**
         * Defines that engine should ignore context lost events
         * If this event happens when this parameter is true, you will have to reload the page to restore rendering
         */
        doNotHandleContextLost?: boolean;
    }
    /**
     * Defines the interface used by display changed events
     */
    interface IDisplayChangedEventArgs {
        /** Gets the vrDisplay object (if any) */
        vrDisplay: Nullable<any>;
        /** Gets a boolean indicating if webVR is supported */
        vrSupported: boolean;
    }
    /**
     * The engine class is responsible for interfacing with all lower-level APIs such as WebGL and Audio
     */
    class Engine {
        /** Use this array to turn off some WebGL2 features on known buggy browsers version */
        static ExceptionList: ({
            key: string;
            capture: string;
            captureConstraint: number;
            targets: string[];
        } | {
            key: string;
            capture: null;
            captureConstraint: null;
            targets: string[];
        })[];
        /** Gets the list of created engines */
        static Instances: Engine[];
        /**
         * Gets the latest created engine
         */
        static readonly LastCreatedEngine: Nullable<Engine>;
        /**
         * Gets the latest created scene
         */
        static readonly LastCreatedScene: Nullable<Scene>;
        /**
         * Will flag all materials in all scenes in all engines as dirty to trigger new shader compilation
         * @param flag defines which part of the materials must be marked as dirty
         * @param predicate defines a predicate used to filter which materials should be affected
         */
        static MarkAllMaterialsAsDirty(flag: number, predicate?: (mat: Material) => boolean): void;
        private static _ALPHA_DISABLE;
        private static _ALPHA_ADD;
        private static _ALPHA_COMBINE;
        private static _ALPHA_SUBTRACT;
        private static _ALPHA_MULTIPLY;
        private static _ALPHA_MAXIMIZED;
        private static _ALPHA_ONEONE;
        private static _ALPHA_PREMULTIPLIED;
        private static _ALPHA_PREMULTIPLIED_PORTERDUFF;
        private static _ALPHA_INTERPOLATE;
        private static _ALPHA_SCREENMODE;
        private static _DELAYLOADSTATE_NONE;
        private static _DELAYLOADSTATE_LOADED;
        private static _DELAYLOADSTATE_LOADING;
        private static _DELAYLOADSTATE_NOTLOADED;
        private static _TEXTUREFORMAT_ALPHA;
        private static _TEXTUREFORMAT_LUMINANCE;
        private static _TEXTUREFORMAT_LUMINANCE_ALPHA;
        private static _TEXTUREFORMAT_RGB;
        private static _TEXTUREFORMAT_RGBA;
        private static _TEXTUREFORMAT_R32F;
        private static _TEXTUREFORMAT_RG32F;
        private static _TEXTUREFORMAT_RGB32F;
        private static _TEXTUREFORMAT_RGBA32F;
        private static _TEXTURETYPE_UNSIGNED_INT;
        private static _TEXTURETYPE_FLOAT;
        private static _TEXTURETYPE_HALF_FLOAT;
        private static _NEVER;
        private static _ALWAYS;
        private static _LESS;
        private static _EQUAL;
        private static _LEQUAL;
        private static _GREATER;
        private static _GEQUAL;
        private static _NOTEQUAL;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will never pass. i.e. Nothing will be drawn */
        static readonly NEVER: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn */
        static readonly ALWAYS: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than the stored value */
        static readonly LESS: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is equals to the stored value */
        static readonly EQUAL: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than or equal to the stored value */
        static readonly LEQUAL: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than the stored value */
        static readonly GREATER: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than or equal to the stored value */
        static readonly GEQUAL: number;
        /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is not equal to the stored value */
        static readonly NOTEQUAL: number;
        private static _KEEP;
        private static _REPLACE;
        private static _INCR;
        private static _DECR;
        private static _INVERT;
        private static _INCR_WRAP;
        private static _DECR_WRAP;
        /** Passed to stencilOperation to specify that stencil value must be kept */
        static readonly KEEP: number;
        /** Passed to stencilOperation to specify that stencil value must be replaced */
        static readonly REPLACE: number;
        /** Passed to stencilOperation to specify that stencil value must be incremented */
        static readonly INCR: number;
        /** Passed to stencilOperation to specify that stencil value must be decremented */
        static readonly DECR: number;
        /** Passed to stencilOperation to specify that stencil value must be inverted */
        static readonly INVERT: number;
        /** Passed to stencilOperation to specify that stencil value must be incremented with wrapping */
        static readonly INCR_WRAP: number;
        /** Passed to stencilOperation to specify that stencil value must be decremented with wrapping */
        static readonly DECR_WRAP: number;
        /** Defines that alpha blending is disabled */
        static readonly ALPHA_DISABLE: number;
        /** Defines that alpha blending to SRC + DEST */
        static readonly ALPHA_ONEONE: number;
        /** Defines that alpha blending to SRC ALPHA * SRC + DEST */
        static readonly ALPHA_ADD: number;
        /** Defines that alpha blending to SRC ALPHA * SRC + (1 - SRC ALPHA) * DEST */
        static readonly ALPHA_COMBINE: number;
        /** Defines that alpha blending to DEST - SRC * DEST */
        static readonly ALPHA_SUBTRACT: number;
        /** Defines that alpha blending to SRC * DEST */
        static readonly ALPHA_MULTIPLY: number;
        /** Defines that alpha blending to SRC ALPHA * SRC + (1 - SRC) * DEST */
        static readonly ALPHA_MAXIMIZED: number;
        /** Defines that alpha blending to SRC + (1 - SRC ALPHA) * DEST */
        static readonly ALPHA_PREMULTIPLIED: number;
        /**
         * Defines that alpha blending to SRC + (1 - SRC ALPHA) * DEST
         * Alpha will be set to (1 - SRC ALPHA) * DEST ALPHA
         */
        static readonly ALPHA_PREMULTIPLIED_PORTERDUFF: number;
        /** Defines that alpha blending to CST * SRC + (1 - CST) * DEST */
        static readonly ALPHA_INTERPOLATE: number;
        /**
         * Defines that alpha blending to SRC + (1 - SRC) * DEST
         * Alpha will be set to SRC ALPHA + (1 - SRC ALPHA) * DEST ALPHA
         */
        static readonly ALPHA_SCREENMODE: number;
        /** Defines that the ressource is not delayed*/
        static readonly DELAYLOADSTATE_NONE: number;
        /** Defines that the ressource was successfully delay loaded */
        static readonly DELAYLOADSTATE_LOADED: number;
        /** Defines that the ressource is currently delay loading */
        static readonly DELAYLOADSTATE_LOADING: number;
        /** Defines that the ressource is delayed and has not started loading */
        static readonly DELAYLOADSTATE_NOTLOADED: number;
        /** ALPHA */
        static readonly TEXTUREFORMAT_ALPHA: number;
        /** LUMINANCE */
        static readonly TEXTUREFORMAT_LUMINANCE: number;
        /**
         * R32F
         */
        static readonly TEXTUREFORMAT_R32F: number;
        /**
         * RG32F
         */
        static readonly TEXTUREFORMAT_RG32F: number;
        /**
         * RGB32F
         */
        static readonly TEXTUREFORMAT_RGB32F: number;
        /**
         * RGBA32F
         */
        static readonly TEXTUREFORMAT_RGBA32F: number;
        /** LUMINANCE_ALPHA */
        static readonly TEXTUREFORMAT_LUMINANCE_ALPHA: number;
        /** RGB */
        static readonly TEXTUREFORMAT_RGB: number;
        /** RGBA */
        static readonly TEXTUREFORMAT_RGBA: number;
        /** UNSIGNED_INT */
        static readonly TEXTURETYPE_UNSIGNED_INT: number;
        /** FLOAT */
        static readonly TEXTURETYPE_FLOAT: number;
        /** HALF_FLOAT */
        static readonly TEXTURETYPE_HALF_FLOAT: number;
        private static _SCALEMODE_FLOOR;
        private static _SCALEMODE_NEAREST;
        private static _SCALEMODE_CEILING;
        /** Defines that texture rescaling will use a floor to find the closer power of 2 size */
        static readonly SCALEMODE_FLOOR: number;
        /** Defines that texture rescaling will look for the nearest power of 2 size */
        static readonly SCALEMODE_NEAREST: number;
        /** Defines that texture rescaling will use a ceil to find the closer power of 2 size */
        static readonly SCALEMODE_CEILING: number;
        /**
         * Returns the current version of the framework
         */
        static readonly Version: string;
        /**
         * Gets or sets the epsilon value used by collision engine
         */
        static CollisionsEpsilon: number;
        /**
         * Gets or sets the relative url used to load code if using the engine in non-minified mode
         */
        static CodeRepository: string;
        /**
         * Gets or sets the relative url used to load shaders if using the engine in non-minified mode
         */
        static ShadersRepository: string;
        /**
         * Gets or sets a boolean that indicates if textures must be forced to power of 2 size even if not required
         */
        forcePOTTextures: boolean;
        /**
         * Gets a boolean indicating if the engine is currently rendering in fullscreen mode
         */
        isFullscreen: boolean;
        /**
         * Gets a boolean indicating if the pointer is currently locked
         */
        isPointerLock: boolean;
        /**
         * Gets or sets a boolean indicating if back faces must be culled (true by default)
         */
        cullBackFaces: boolean;
        /**
         * Gets or sets a boolean indicating if the engine must keep rendering even if the window is not in foregroun
         */
        renderEvenInBackground: boolean;
        /**
         * Gets or sets a boolean indicating that cache can be kept between frames
         */
        preventCacheWipeBetweenFrames: boolean;
        /**
         * Gets or sets a boolean to enable/disable IndexedDB support and avoid XHR on .manifest
         **/
        enableOfflineSupport: boolean;
        /**
         * Gets or sets a boolean to enable/disable checking manifest if IndexedDB support is enabled (Babylon.js will always consider the database is up to date)
         **/
        disableManifestCheck: boolean;
        /**
         * Gets the list of created scenes
         */
        scenes: Scene[];
        /**
         * Gets the list of created postprocesses
         */
        postProcesses: PostProcess[];
        /**
         * Observable event triggered each time the rendering canvas is resized
         */
        onResizeObservable: Observable<Engine>;
        /**
         * Observable event triggered each time the canvas loses focus
         */
        onCanvasBlurObservable: Observable<Engine>;
        /**
         * Observable event triggered each time the canvas gains focus
         */
        onCanvasFocusObservable: Observable<Engine>;
        /**
         * Observable event triggered each time the canvas receives pointerout event
         */
        onCanvasPointerOutObservable: Observable<PointerEvent>;
        /**
         * Observable event triggered before each texture is initialized
         */
        onBeforeTextureInitObservable: Observable<Texture>;
        private _vrDisplay;
        private _vrSupported;
        private _oldSize;
        private _oldHardwareScaleFactor;
        private _vrExclusivePointerMode;
        private _webVRInitPromise;
        /**
         * Gets a boolean indicating that the engine is currently in VR exclusive mode for the pointers
         * @see https://docs.microsoft.com/en-us/microsoft-edge/webvr/essentials#mouse-input
         */
        readonly isInVRExclusivePointerMode: boolean;
        /**
         * Gets or sets a boolean indicating that uniform buffers must be disabled even if they are supported
         */
        disableUniformBuffers: boolean;
        /** @hidden */
        _uniformBuffers: UniformBuffer[];
        /**
         * Gets a boolean indicating that the engine supports uniform buffers
         * @see http://doc.babylonjs.com/features/webgl2#uniform-buffer-objets
         */
        readonly supportsUniformBuffers: boolean;
        /**
         * Observable raised when the engine begins a new frame
         */
        onBeginFrameObservable: Observable<Engine>;
        /**
         * Observable raised when the engine ends the current frame
         */
        onEndFrameObservable: Observable<Engine>;
        /**
         * Observable raised when the engine is about to compile a shader
         */
        onBeforeShaderCompilationObservable: Observable<Engine>;
        /**
         * Observable raised when the engine has jsut compiled a shader
         */
        onAfterShaderCompilationObservable: Observable<Engine>;
        private _gl;
        private _renderingCanvas;
        private _windowIsBackground;
        private _webGLVersion;
        /**
         * Gets a boolean indicating that only power of 2 textures are supported
         * Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them
         */
        readonly needPOTTextures: boolean;
        /** @hidden */
        _badOS: boolean;
        /** @hidden */
        _badDesktopOS: boolean;
        /**
         * Gets or sets a value indicating if we want to disable texture binding optmization.
         * This could be required on some buggy drivers which wants to have textures bound in a progressive order.
         * By default Babylon.js will try to let textures bound where they are and only update the samplers to point where the texture is
         */
        disableTextureBindingOptimization: boolean;
        /**
         * Gets the audio engine
         * @see http://doc.babylonjs.com/how_to/playing_sounds_and_music
         * @ignorenaming
         */
        static audioEngine: AudioEngine;
        private _onFocus;
        private _onBlur;
        private _onCanvasPointerOut;
        private _onCanvasBlur;
        private _onCanvasFocus;
        private _onFullscreenChange;
        private _onPointerLockChange;
        private _onVRDisplayPointerRestricted;
        private _onVRDisplayPointerUnrestricted;
        private _onVrDisplayConnect;
        private _onVrDisplayDisconnect;
        private _onVrDisplayPresentChange;
        /**
         * Observable signaled when VR display mode changes
         */
        onVRDisplayChangedObservable: Observable<IDisplayChangedEventArgs>;
        /**
         * Observable signaled when VR request present is complete
         */
        onVRRequestPresentComplete: Observable<boolean>;
        /**
         * Observable signaled when VR request present starts
         */
        onVRRequestPresentStart: Observable<Engine>;
        private _hardwareScalingLevel;
        /** @hidden */
        protected _caps: EngineCapabilities;
        private _pointerLockRequested;
        private _isStencilEnable;
        private _colorWrite;
        private _loadingScreen;
        /** @hidden */
        _drawCalls: PerfCounter;
        /** @hidden */
        _textureCollisions: PerfCounter;
        private _glVersion;
        private _glRenderer;
        private _glVendor;
        private _videoTextureSupported;
        private _renderingQueueLaunched;
        private _activeRenderLoops;
        private _deterministicLockstep;
        private _lockstepMaxSteps;
        /**
         * Observable signaled when a context lost event is raised
         */
        onContextLostObservable: Observable<Engine>;
        /**
         * Observable signaled when a context restored event is raised
         */
        onContextRestoredObservable: Observable<Engine>;
        private _onContextLost;
        private _onContextRestored;
        private _contextWasLost;
        private _doNotHandleContextLost;
        private _performanceMonitor;
        private _fps;
        private _deltaTime;
        /**
         * Turn this value on if you want to pause FPS computation when in background
         */
        disablePerformanceMonitorInBackground: boolean;
        /**
         * Gets the performance monitor attached to this engine
         * @see http://doc.babylonjs.com/how_to/optimizing_your_scene#engineinstrumentation
         */
        readonly performanceMonitor: PerformanceMonitor;
        /** @hidden */
        protected _depthCullingState: _DepthCullingState;
        /** @hidden */
        protected _stencilState: _StencilState;
        /** @hidden */
        protected _alphaState: _AlphaState;
        /** @hidden */
        protected _alphaMode: number;
        private _internalTexturesCache;
        /** @hidden */
        protected _activeChannel: number;
        private _currentTextureChannel;
        /** @hidden */
        protected _boundTexturesCache: {
            [key: string]: Nullable<InternalTexture>;
        };
        /** @hidden */
        protected _currentEffect: Nullable<Effect>;
        /** @hidden */
        protected _currentProgram: Nullable<WebGLProgram>;
        private _compiledEffects;
        private _vertexAttribArraysEnabled;
        /** @hidden */
        protected _cachedViewport: Nullable<Viewport>;
        private _cachedVertexArrayObject;
        /** @hidden */
        protected _cachedVertexBuffers: any;
        /** @hidden */
        protected _cachedIndexBuffer: Nullable<WebGLBuffer>;
        /** @hidden */
        protected _cachedEffectForVertexBuffers: Nullable<Effect>;
        /** @hidden */
        protected _currentRenderTarget: Nullable<InternalTexture>;
        private _uintIndicesCurrentlySet;
        private _currentBoundBuffer;
        /** @hidden */
        protected _currentFramebuffer: Nullable<WebGLFramebuffer>;
        private _currentBufferPointers;
        private _currentInstanceLocations;
        private _currentInstanceBuffers;
        private _textureUnits;
        private _firstBoundInternalTextureTracker;
        private _lastBoundInternalTextureTracker;
        private _workingCanvas;
        private _workingContext;
        private _rescalePostProcess;
        private _dummyFramebuffer;
        private _externalData;
        private _bindedRenderFunction;
        private _vaoRecordInProgress;
        private _mustWipeVertexAttributes;
        private _emptyTexture;
        private _emptyCubeTexture;
        private _emptyTexture3D;
        private _frameHandler;
        private _nextFreeTextureSlots;
        private _maxSimultaneousTextures;
        private _activeRequests;
        private _texturesSupported;
        private _textureFormatInUse;
        /**
         * Gets the list of texture formats supported
         */
        readonly texturesSupported: Array<string>;
        /**
         * Gets the list of texture formats in use
         */
        readonly textureFormatInUse: Nullable<string>;
        /**
         * Gets the current viewport
         */
        readonly currentViewport: Nullable<Viewport>;
        /**
         * Gets the default empty texture
         */
        readonly emptyTexture: InternalTexture;
        /**
         * Gets the default empty 3D texture
         */
        readonly emptyTexture3D: InternalTexture;
        /**
         * Gets the default empty cube texture
         */
        readonly emptyCubeTexture: InternalTexture;
        /**
         * Creates a new engine
         * @param canvasOrContext defines the canvas or WebGL context to use for rendering
         * @param antialias defines enable antialiasing (default: false)
         * @param options defines further options to be sent to the getContext() function
         * @param adaptToDeviceRatio defines whether to adapt to the device's viewport characteristics (default: false)
         */
        constructor(canvasOrContext: Nullable<HTMLCanvasElement | WebGLRenderingContext>, antialias?: boolean, options?: EngineOptions, adaptToDeviceRatio?: boolean);
        private _rebuildInternalTextures();
        private _rebuildEffects();
        private _rebuildBuffers();
        private _initGLContext();
        /**
         * Gets version of the current webGL context
         */
        readonly webGLVersion: number;
        /**
         * Returns true if the stencil buffer has been enabled through the creation option of the context.
         */
        readonly isStencilEnable: boolean;
        private _prepareWorkingCanvas();
        /**
         * Reset the texture cache to empty state
         */
        resetTextureCache(): void;
        /**
         * Gets a boolean indicating that the engine is running in deterministic lock step mode
         * @see http://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         * @returns true if engine is in deterministic lock step mode
         */
        isDeterministicLockStep(): boolean;
        /**
         * Gets the max steps when engine is running in deterministic lock step
         * @see http://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         * @returns the max steps
         */
        getLockstepMaxSteps(): number;
        /**
         * Gets an object containing information about the current webGL context
         * @returns an object containing the vender, the renderer and the version of the current webGL context
         */
        getGlInfo(): {
            vendor: string;
            renderer: string;
            version: string;
        };
        /**
         * Gets current aspect ratio
         * @param camera defines the camera to use to get the aspect ratio
         * @param useScreen defines if screen size must be used (or the current render target if any)
         * @returns a number defining the aspect ratio
         */
        getAspectRatio(camera: Camera, useScreen?: boolean): number;
        /**
         * Gets the current render width
         * @param useScreen defines if screen size must be used (or the current render target if any)
         * @returns a number defining the current render width
         */
        getRenderWidth(useScreen?: boolean): number;
        /**
         * Gets the current render height
         * @param useScreen defines if screen size must be used (or the current render target if any)
         * @returns a number defining the current render height
         */
        getRenderHeight(useScreen?: boolean): number;
        /**
         * Gets the HTML canvas attached with the current webGL context
         * @returns a HTML canvas
         */
        getRenderingCanvas(): Nullable<HTMLCanvasElement>;
        /**
         * Gets the client rect of the HTML canvas attached with the current webGL context
         * @returns a client rectanglee
         */
        getRenderingCanvasClientRect(): Nullable<ClientRect>;
        /**
         * Defines the hardware scaling level.
         * By default the hardware scaling level is computed from the window device ratio.
         * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.
         * @param level defines the level to use
         */
        setHardwareScalingLevel(level: number): void;
        /**
         * Gets the current hardware scaling level.
         * By default the hardware scaling level is computed from the window device ratio.
         * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.
         * @returns a number indicating the current hardware scaling level
         */
        getHardwareScalingLevel(): number;
        /**
         * Gets the list of loaded textures
         * @returns an array containing all loaded textures
         */
        getLoadedTexturesCache(): InternalTexture[];
        /**
         * Gets the object containing all engine capabilities
         * @returns the EngineCapabilities object
         */
        getCaps(): EngineCapabilities;
        /** @hidden */
        readonly drawCalls: number;
        /** @hidden */
        readonly drawCallsPerfCounter: Nullable<PerfCounter>;
        /**
         * Gets the current depth function
         * @returns a number defining the depth function
         */
        getDepthFunction(): Nullable<number>;
        /**
         * Sets the current depth function
         * @param depthFunc defines the function to use
         */
        setDepthFunction(depthFunc: number): void;
        /**
         * Sets the current depth function to GREATER
         */
        setDepthFunctionToGreater(): void;
        /**
         * Sets the current depth function to GEQUAL
         */
        setDepthFunctionToGreaterOrEqual(): void;
        /**
         * Sets the current depth function to LESS
         */
        setDepthFunctionToLess(): void;
        /**
         * Sets the current depth function to LEQUAL
         */
        setDepthFunctionToLessOrEqual(): void;
        /**
         * Gets a boolean indicating if stencil buffer is enabled
         * @returns the current stencil buffer state
         */
        getStencilBuffer(): boolean;
        /**
         * Enable or disable the stencil buffer
         * @param enable defines if the stencil buffer must be enabled or disabled
         */
        setStencilBuffer(enable: boolean): void;
        /**
         * Gets the current stencil mask
         * @returns a number defining the new stencil mask to use
         */
        getStencilMask(): number;
        /**
         * Sets the current stencil mask
         * @param mask defines the new stencil mask to use
         */
        setStencilMask(mask: number): void;
        /**
         * Gets the current stencil function
         * @returns a number defining the stencil function to use
         */
        getStencilFunction(): number;
        /**
         * Gets the current stencil reference value
         * @returns a number defining the stencil reference value to use
         */
        getStencilFunctionReference(): number;
        /**
         * Gets the current stencil mask
         * @returns a number defining the stencil mask to use
         */
        getStencilFunctionMask(): number;
        /**
         * Sets the current stencil function
         * @param stencilFunc defines the new stencil function to use
         */
        setStencilFunction(stencilFunc: number): void;
        /**
         * Sets the current stencil reference
         * @param reference defines the new stencil reference to use
         */
        setStencilFunctionReference(reference: number): void;
        /**
         * Sets the current stencil mask
         * @param mask defines the new stencil mask to use
         */
        setStencilFunctionMask(mask: number): void;
        /**
         * Gets the current stencil operation when stencil fails
         * @returns a number defining stencil operation to use when stencil fails
         */
        getStencilOperationFail(): number;
        /**
         * Gets the current stencil operation when depth fails
         * @returns a number defining stencil operation to use when depth fails
         */
        getStencilOperationDepthFail(): number;
        /**
         * Gets the current stencil operation when stencil passes
         * @returns a number defining stencil operation to use when stencil passes
         */
        getStencilOperationPass(): number;
        /**
         * Sets the stencil operation to use when stencil fails
         * @param operation defines the stencil operation to use when stencil fails
         */
        setStencilOperationFail(operation: number): void;
        /**
         * Sets the stencil operation to use when depth fails
         * @param operation defines the stencil operation to use when depth fails
         */
        setStencilOperationDepthFail(operation: number): void;
        /**
         * Sets the stencil operation to use when stencil passes
         * @param operation defines the stencil operation to use when stencil passes
         */
        setStencilOperationPass(operation: number): void;
        /**
         * Sets a boolean indicating if the dithering state is enabled or disabled
         * @param value defines the dithering state
         */
        setDitheringState(value: boolean): void;
        /**
         * Sets a boolean indicating if the rasterizer state is enabled or disabled
         * @param value defines the rasterizer state
         */
        setRasterizerState(value: boolean): void;
        /**
         * stop executing a render loop function and remove it from the execution array
         * @param renderFunction defines the function to be removed. If not provided all functions will be removed.
         */
        stopRenderLoop(renderFunction?: () => void): void;
        /** @hidden */
        _renderLoop(): void;
        /**
         * Register and execute a render loop. The engine can have more than one render function
         * @param renderFunction defines the function to continuously execute
         */
        runRenderLoop(renderFunction: () => void): void;
        /**
         * Toggle full screen mode
         * @param requestPointerLock defines if a pointer lock should be requested from the user
         * @param options defines an option object to be sent to the requestFullscreen function
         */
        switchFullscreen(requestPointerLock: boolean): void;
        /**
         * Clear the current render buffer or the current render target (if any is set up)
         * @param color defines the color to use
         * @param backBuffer defines if the back buffer must be cleared
         * @param depth defines if the depth buffer must be cleared
         * @param stencil defines if the stencil buffer must be cleared
         */
        clear(color: Nullable<Color4>, backBuffer: boolean, depth: boolean, stencil?: boolean): void;
        /**
         * Executes a scissor clear (ie. a clear on a specific portion of the screen)
         * @param x defines the x-coordinate of the top left corner of the clear rectangle
         * @param y defines the y-coordinate of the corner of the clear rectangle
         * @param width defines the width of the clear rectangle
         * @param height defines the height of the clear rectangle
         * @param clearColor defines the clear color
         */
        scissorClear(x: number, y: number, width: number, height: number, clearColor: Color4): void;
        /**
         * Set the WebGL's viewport
         * @param viewport defines the viewport element to be used
         * @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used
         * @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used
         */
        setViewport(viewport: Viewport, requiredWidth?: number, requiredHeight?: number): void;
        /**
         * Directly set the WebGL Viewport
         * @param x defines the x coordinate of the viewport (in screen space)
         * @param y defines the y coordinate of the viewport (in screen space)
         * @param width defines the width of the viewport (in screen space)
         * @param height defines the height of the viewport (in screen space)
         * @return the current viewport Object (if any) that is being replaced by this call. You can restore this viewport later on to go back to the original state
         */
        setDirectViewport(x: number, y: number, width: number, height: number): Nullable<Viewport>;
        /**
         * Begin a new frame
         */
        beginFrame(): void;
        /**
         * Enf the current frame
         */
        endFrame(): void;
        /**
         * Resize the view according to the canvas' size
         */
        resize(): void;
        /**
         * Force a specific size of the canvas
         * @param width defines the new canvas' width
         * @param height defines the new canvas' height
         */
        setSize(width: number, height: number): void;
        /**
         * Gets a boolean indicating if a webVR device was detected
         * @returns true if a webVR device was detected
         */
        isVRDevicePresent(): boolean;
        /**
         * Gets the current webVR device
         * @returns the current webVR device (or null)
         */
        getVRDevice(): any;
        /**
         * Initializes a webVR display and starts listening to display change events
         * The onVRDisplayChangedObservable will be notified upon these changes
         * @returns The onVRDisplayChangedObservable
         */
        initWebVR(): Observable<IDisplayChangedEventArgs>;
        /**
         * Initializes a webVR display and starts listening to display change events
         * The onVRDisplayChangedObservable will be notified upon these changes
         * @returns A promise containing a VRDisplay and if vr is supported
         */
        initWebVRAsync(): Promise<IDisplayChangedEventArgs>;
        /**
         * Call this function to switch to webVR mode
         * Will do nothing if webVR is not supported or if there is no webVR device
         * @see http://doc.babylonjs.com/how_to/webvr_camera
         */
        enableVR(): void;
        /**
         * Call this function to leave webVR mode
         * Will do nothing if webVR is not supported or if there is no webVR device
         * @see http://doc.babylonjs.com/how_to/webvr_camera
         */
        disableVR(): void;
        private _onVRFullScreenTriggered;
        private _getVRDisplaysAsync();
        /**
         * Binds the frame buffer to the specified texture.
         * @param texture The texture to render to or null for the default canvas
         * @param faceIndex The face of the texture to render to in case of cube texture
         * @param requiredWidth The width of the target to render to
         * @param requiredHeight The height of the target to render to
         * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true
         * @param depthStencilTexture The depth stencil texture to use to render
         */
        bindFramebuffer(texture: InternalTexture, faceIndex?: number, requiredWidth?: number, requiredHeight?: number, forceFullscreenViewport?: boolean, depthStencilTexture?: InternalTexture): void;
        private bindUnboundFramebuffer(framebuffer);
        /**
         * Unbind the current render target texture from the webGL context
         * @param texture defines the render target texture to unbind
         * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated
         * @param onBeforeUnbind defines a function which will be called before the effective unbind
         */
        unBindFramebuffer(texture: InternalTexture, disableGenerateMipMaps?: boolean, onBeforeUnbind?: () => void): void;
        /**
         * Unbind a list of render target textures from the webGL context
         * This is used only when drawBuffer extension or webGL2 are active
         * @param textures defines the render target textures to unbind
         * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated
         * @param onBeforeUnbind defines a function which will be called before the effective unbind
         */
        unBindMultiColorAttachmentFramebuffer(textures: InternalTexture[], disableGenerateMipMaps?: boolean, onBeforeUnbind?: () => void): void;
        /**
         * Force the mipmap generation for the given render target texture
         * @param texture defines the render target texture to use
         */
        generateMipMapsForCubemap(texture: InternalTexture): void;
        /**
         * Force a webGL flush (ie. a flush of all waiting webGL commands)
         */
        flushFramebuffer(): void;
        /**
         * Unbind the current render target and bind the default framebuffer
         */
        restoreDefaultFramebuffer(): void;
        /**
         * Create an uniform buffer
         * @see http://doc.babylonjs.com/features/webgl2#uniform-buffer-objets
         * @param elements defines the content of the uniform buffer
         * @returns the webGL uniform buffer
         */
        createUniformBuffer(elements: FloatArray): WebGLBuffer;
        /**
         * Create a dynamic uniform buffer
         * @see http://doc.babylonjs.com/features/webgl2#uniform-buffer-objets
         * @param elements defines the content of the uniform buffer
         * @returns the webGL uniform buffer
         */
        createDynamicUniformBuffer(elements: FloatArray): WebGLBuffer;
        /**
         * Update an existing uniform buffer
         * @see http://doc.babylonjs.com/features/webgl2#uniform-buffer-objets
         * @param uniformBuffer defines the target uniform buffer
         * @param elements defines the content to update
         * @param offset defines the offset in the uniform buffer where update should start
         * @param count defines the size of the data to update
         */
        updateUniformBuffer(uniformBuffer: WebGLBuffer, elements: FloatArray, offset?: number, count?: number): void;
        private _resetVertexBufferBinding();
        /**
         * Creates a vertex buffer
         * @param data the data for the vertex buffer
         * @returns the new WebGL static buffer
         */
        createVertexBuffer(data: DataArray): WebGLBuffer;
        /**
         * Creates a dynamic vertex buffer
         * @param data the data for the dynamic vertex buffer
         * @returns the new WebGL dynamic buffer
         */
        createDynamicVertexBuffer(data: DataArray): WebGLBuffer;
        /**
         * Update a dynamic index buffer
         * @param indexBuffer defines the target index buffer
         * @param indices defines the data to update
         * @param offset defines the offset in the target index buffer where update should start
         */
        updateDynamicIndexBuffer(indexBuffer: WebGLBuffer, indices: IndicesArray, offset?: number): void;
        /**
         * Updates a dynamic vertex buffer.
         * @param vertexBuffer the vertex buffer to update
         * @param data the data used to update the vertex buffer
         * @param byteOffset the byte offset of the data
         * @param byteLength the byte length of the data
         */
        updateDynamicVertexBuffer(vertexBuffer: WebGLBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void;
        private _resetIndexBufferBinding();
        /**
         * Creates a new index buffer
         * @param indices defines the content of the index buffer
         * @param updatable defines if the index buffer must be updatable
         * @returns a new webGL buffer
         */
        createIndexBuffer(indices: IndicesArray, updatable?: boolean): WebGLBuffer;
        /**
         * Bind a webGL buffer to the webGL context
         * @param buffer defines the buffer to bind
         */
        bindArrayBuffer(buffer: Nullable<WebGLBuffer>): void;
        /**
         * Bind an uniform buffer to the current webGL context
         * @param buffer defines the buffer to bind
         */
        bindUniformBuffer(buffer: Nullable<WebGLBuffer>): void;
        /**
         * Bind a buffer to the current webGL context at a given location
         * @param buffer defines the buffer to bind
         * @param location defines the index where to bind the buffer
         */
        bindUniformBufferBase(buffer: WebGLBuffer, location: number): void;
        /**
         * Bind a specific block at a given index in a specific shader program
         * @param shaderProgram defines the shader program
         * @param blockName defines the block name
         * @param index defines the index where to bind the block
         */
        bindUniformBlock(shaderProgram: WebGLProgram, blockName: string, index: number): void;
        private bindIndexBuffer(buffer);
        private bindBuffer(buffer, target);
        /**
         * update the bound buffer with the given data
         * @param data defines the data to update
         */
        updateArrayBuffer(data: Float32Array): void;
        private _vertexAttribPointer(buffer, indx, size, type, normalized, stride, offset);
        private _bindIndexBufferWithCache(indexBuffer);
        private _bindVertexBuffersAttributes(vertexBuffers, effect);
        /**
         * Records a vertex array object
         * @see http://doc.babylonjs.com/features/webgl2#vertex-array-objects
         * @param vertexBuffers defines the list of vertex buffers to store
         * @param indexBuffer defines the index buffer to store
         * @param effect defines the effect to store
         * @returns the new vertex array object
         */
        recordVertexArrayObject(vertexBuffers: {
            [key: string]: VertexBuffer;
        }, indexBuffer: Nullable<WebGLBuffer>, effect: Effect): WebGLVertexArrayObject;
        /**
         * Bind a specific vertex array object
         * @see http://doc.babylonjs.com/features/webgl2#vertex-array-objects
         * @param vertexArrayObject defines the vertex array object to bind
         * @param indexBuffer defines the index buffer to bind
         */
        bindVertexArrayObject(vertexArrayObject: WebGLVertexArrayObject, indexBuffer: Nullable<WebGLBuffer>): void;
        /**
         * Bind webGl buffers directly to the webGL context
         * @param vertexBuffer defines the vertex buffer to bind
         * @param indexBuffer defines the index buffer to bind
         * @param vertexDeclaration defines the vertex declaration to use with the vertex buffer
         * @param vertexStrideSize defines the vertex stride of the vertex buffer
         * @param effect defines the effect associated with the vertex buffer
         */
        bindBuffersDirectly(vertexBuffer: WebGLBuffer, indexBuffer: WebGLBuffer, vertexDeclaration: number[], vertexStrideSize: number, effect: Effect): void;
        private _unbindVertexArrayObject();
        /**
         * Bind a list of vertex buffers to the webGL context
         * @param vertexBuffers defines the list of vertex buffers to bind
         * @param indexBuffer defines the index buffer to bind
         * @param effect defines the effect associated with the vertex buffers
         */
        bindBuffers(vertexBuffers: {
            [key: string]: Nullable<VertexBuffer>;
        }, indexBuffer: Nullable<WebGLBuffer>, effect: Effect): void;
        /**
         * Unbind all instance attributes
         */
        unbindInstanceAttributes(): void;
        /**
         * Release and free the memory of a vertex array object
         * @param vao defines the vertex array object to delete
         */
        releaseVertexArrayObject(vao: WebGLVertexArrayObject): void;
        /** @hidden */
        _releaseBuffer(buffer: WebGLBuffer): boolean;
        /**
         * Creates a webGL buffer to use with instanciation
         * @param capacity defines the size of the buffer
         * @returns the webGL buffer
         */
        createInstancesBuffer(capacity: number): WebGLBuffer;
        /**
         * Delete a webGL buffer used with instanciation
         * @param buffer defines the webGL buffer to delete
         */
        deleteInstancesBuffer(buffer: WebGLBuffer): void;
        /**
         * Update the content of a webGL buffer used with instanciation and bind it to the webGL context
         * @param instancesBuffer defines the webGL buffer to update and bind
         * @param data defines the data to store in the buffer
         * @param offsetLocations defines the offsets or attributes information used to determine where data must be stored in the buffer
         */
        updateAndBindInstancesBuffer(instancesBuffer: WebGLBuffer, data: Float32Array, offsetLocations: number[] | InstancingAttributeInfo[]): void;
        /**
         * Apply all cached states (depth, culling, stencil and alpha)
         */
        applyStates(): void;
        /**
         * Send a draw order
         * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)
         * @param indexStart defines the starting index
         * @param indexCount defines the number of index to draw
         * @param instancesCount defines the number of instances to draw (if instanciation is enabled)
         */
        draw(useTriangles: boolean, indexStart: number, indexCount: number, instancesCount?: number): void;
        /**
         * Draw a list of points
         * @param verticesStart defines the index of first vertex to draw
         * @param verticesCount defines the count of vertices to draw
         * @param instancesCount defines the number of instances to draw (if instanciation is enabled)
         */
        drawPointClouds(verticesStart: number, verticesCount: number, instancesCount?: number): void;
        /**
         * Draw a list of unindexed primitives
         * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)
         * @param verticesStart defines the index of first vertex to draw
         * @param verticesCount defines the count of vertices to draw
         * @param instancesCount defines the number of instances to draw (if instanciation is enabled)
         */
        drawUnIndexed(useTriangles: boolean, verticesStart: number, verticesCount: number, instancesCount?: number): void;
        /**
         * Draw a list of indexed primitives
         * @param fillMode defines the primitive to use
         * @param indexStart defines the starting index
         * @param indexCount defines the number of index to draw
         * @param instancesCount defines the number of instances to draw (if instanciation is enabled)
         */
        drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount?: number): void;
        /**
         * Draw a list of unindexed primitives
         * @param fillMode defines the primitive to use
         * @param verticesStart defines the index of first vertex to draw
         * @param verticesCount defines the count of vertices to draw
         * @param instancesCount defines the number of instances to draw (if instanciation is enabled)
         */
        drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount?: number): void;
        private _drawMode(fillMode);
        /** @hidden */
        _releaseEffect(effect: Effect): void;
        /** @hidden */
        _deleteProgram(program: WebGLProgram): void;
        /**
         * Create a new effect (used to store vertex/fragment shaders)
         * @param baseName defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)
         * @param attributesNamesOrOptions defines either a list of attribute names or an EffectCreationOptions object
         * @param uniformsNamesOrEngine defines either a list of uniform names or the engine to use
         * @param samplers defines an array of string used to represent textures
         * @param defines defines the string containing the defines to use to compile the shaders
         * @param fallbacks defines the list of potential fallbacks to use if shader conmpilation fails
         * @param onCompiled defines a function to call when the effect creation is successful
         * @param onError defines a function to call when the effect creation has failed
         * @param indexParameters defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)
         * @returns the new Effect
         */
        createEffect(baseName: any, attributesNamesOrOptions: string[] | EffectCreationOptions, uniformsNamesOrEngine: string[] | Engine, samplers?: string[], defines?: string, fallbacks?: EffectFallbacks, onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void, indexParameters?: any): Effect;
        /**
         * Create an effect to use with particle systems
         * @param fragmentName defines the base name of the effect (The name of file without .fragment.fx)
         * @param uniformsNames defines a list of attribute names
         * @param samplers defines an array of string used to represent textures
         * @param defines defines the string containing the defines to use to compile the shaders
         * @param fallbacks defines the list of potential fallbacks to use if shader conmpilation fails
         * @param onCompiled defines a function to call when the effect creation is successful
         * @param onError defines a function to call when the effect creation has failed
         * @returns the new Effect
         */
        createEffectForParticles(fragmentName: string, uniformsNames?: string[], samplers?: string[], defines?: string, fallbacks?: EffectFallbacks, onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void): Effect;
        /**
         * Directly creates a webGL program
         * @param vertexCode defines the vertex shader code to use
         * @param fragmentCode defines the fragment shader code to use
         * @param context defines the webGL context to use (if not set, the current one will be used)
         * @param transformFeedbackVaryings defines the list of transform feedback varyings to use
         * @returns the new webGL program
         */
        createRawShaderProgram(vertexCode: string, fragmentCode: string, context?: WebGLRenderingContext, transformFeedbackVaryings?: Nullable<string[]>): WebGLProgram;
        /**
         * Creates a webGL program
         * @param vertexCode  defines the vertex shader code to use
         * @param fragmentCode defines the fragment shader code to use
         * @param defines defines the string containing the defines to use to compile the shaders
         * @param context defines the webGL context to use (if not set, the current one will be used)
         * @param transformFeedbackVaryings defines the list of transform feedback varyings to use
         * @returns the new webGL program
         */
        createShaderProgram(vertexCode: string, fragmentCode: string, defines: Nullable<string>, context?: WebGLRenderingContext, transformFeedbackVaryings?: Nullable<string[]>): WebGLProgram;
        private _createShaderProgram(vertexShader, fragmentShader, context, transformFeedbackVaryings?);
        /**
         * Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names
         * @param shaderProgram defines the webGL program to use
         * @param uniformsNames defines the list of uniform names
         * @returns an array of webGL uniform locations
         */
        getUniforms(shaderProgram: WebGLProgram, uniformsNames: string[]): Nullable<WebGLUniformLocation>[];
        /**
         * Gets the lsit of active attributes for a given webGL program
         * @param shaderProgram defines the webGL program to use
         * @param attributesNames defines the list of attribute names to get
         * @returns an array of indices indicating the offset of each attribute
         */
        getAttributes(shaderProgram: WebGLProgram, attributesNames: string[]): number[];
        /**
         * Activates an effect, mkaing it the current one (ie. the one used for rendering)
         * @param effect defines the effect to activate
         */
        enableEffect(effect: Nullable<Effect>): void;
        /**
         * Set the value of an uniform to an array of int32
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of int32 to store
         */
        setIntArray(uniform: Nullable<WebGLUniformLocation>, array: Int32Array): void;
        /**
         * Set the value of an uniform to an array of int32 (stored as vec2)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of int32 to store
         */
        setIntArray2(uniform: Nullable<WebGLUniformLocation>, array: Int32Array): void;
        /**
         * Set the value of an uniform to an array of int32 (stored as vec3)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of int32 to store
         */
        setIntArray3(uniform: Nullable<WebGLUniformLocation>, array: Int32Array): void;
        /**
         * Set the value of an uniform to an array of int32 (stored as vec4)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of int32 to store
         */
        setIntArray4(uniform: Nullable<WebGLUniformLocation>, array: Int32Array): void;
        /**
         * Set the value of an uniform to an array of float32
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of float32 to store
         */
        setFloatArray(uniform: Nullable<WebGLUniformLocation>, array: Float32Array): void;
        /**
         * Set the value of an uniform to an array of float32 (stored as vec2)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of float32 to store
         */
        setFloatArray2(uniform: Nullable<WebGLUniformLocation>, array: Float32Array): void;
        /**
         * Set the value of an uniform to an array of float32 (stored as vec3)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of float32 to store
         */
        setFloatArray3(uniform: Nullable<WebGLUniformLocation>, array: Float32Array): void;
        /**
         * Set the value of an uniform to an array of float32 (stored as vec4)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of float32 to store
         */
        setFloatArray4(uniform: Nullable<WebGLUniformLocation>, array: Float32Array): void;
        /**
         * Set the value of an uniform to an array of number
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of number to store
         */
        setArray(uniform: Nullable<WebGLUniformLocation>, array: number[]): void;
        /**
         * Set the value of an uniform to an array of number (stored as vec2)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of number to store
         */
        setArray2(uniform: Nullable<WebGLUniformLocation>, array: number[]): void;
        /**
         * Set the value of an uniform to an array of number (stored as vec3)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of number to store
         */
        setArray3(uniform: Nullable<WebGLUniformLocation>, array: number[]): void;
        /**
         * Set the value of an uniform to an array of number (stored as vec4)
         * @param uniform defines the webGL uniform location where to store the value
         * @param array defines the array of number to store
         */
        setArray4(uniform: Nullable<WebGLUniformLocation>, array: number[]): void;
        /**
         * Set the value of an uniform to an array of float32 (stored as matrices)
         * @param uniform defines the webGL uniform location where to store the value
         * @param matrices defines the array of float32 to store
         */
        setMatrices(uniform: Nullable<WebGLUniformLocation>, matrices: Float32Array): void;
        /**
         * Set the value of an uniform to a matrix
         * @param uniform defines the webGL uniform location where to store the value
         * @param matrix defines the matrix to store
         */
        setMatrix(uniform: Nullable<WebGLUniformLocation>, matrix: Matrix): void;
        /**
         * Set the value of an uniform to a matrix (3x3)
         * @param uniform defines the webGL uniform location where to store the value
         * @param matrix defines the Float32Array representing the 3x3 matrix to store
         */
        setMatrix3x3(uniform: Nullable<WebGLUniformLocation>, matrix: Float32Array): void;
        /**
         * Set the value of an uniform to a matrix (2x2)
         * @param uniform defines the webGL uniform location where to store the value
         * @param matrix defines the Float32Array representing the 2x2 matrix to store
         */
        setMatrix2x2(uniform: Nullable<WebGLUniformLocation>, matrix: Float32Array): void;
        /**
         * Set the value of an uniform to a number (int)
         * @param uniform defines the webGL uniform location where to store the value
         * @param value defines the int number to store
         */
        setInt(uniform: Nullable<WebGLUniformLocation>, value: number): void;
        /**
         * Set the value of an uniform to a number (float)
         * @param uniform defines the webGL uniform location where to store the value
         * @param value defines the float number to store
         */
        setFloat(uniform: Nullable<WebGLUniformLocation>, value: number): void;
        /**
         * Set the value of an uniform to a vec2
         * @param uniform defines the webGL uniform location where to store the value
         * @param x defines the 1st component of the value
         * @param y defines the 2nd component of the value
         */
        setFloat2(uniform: Nullable<WebGLUniformLocation>, x: number, y: number): void;
        /**
         * Set the value of an uniform to a vec3
         * @param uniform defines the webGL uniform location where to store the value
         * @param x defines the 1st component of the value
         * @param y defines the 2nd component of the value
         * @param z defines the 3rd component of the value
         */
        setFloat3(uniform: Nullable<WebGLUniformLocation>, x: number, y: number, z: number): void;
        /**
         * Set the value of an uniform to a boolean
         * @param uniform defines the webGL uniform location where to store the value
         * @param bool defines the boolean to store
         */
        setBool(uniform: Nullable<WebGLUniformLocation>, bool: number): void;
        /**
         * Set the value of an uniform to a vec4
         * @param uniform defines the webGL uniform location where to store the value
         * @param x defines the 1st component of the value
         * @param y defines the 2nd component of the value
         * @param z defines the 3rd component of the value
         * @param w defines the 4th component of the value
         */
        setFloat4(uniform: Nullable<WebGLUniformLocation>, x: number, y: number, z: number, w: number): void;
        /**
         * Set the value of an uniform to a Color3
         * @param uniform defines the webGL uniform location where to store the value
         * @param color3 defines the color to store
         */
        setColor3(uniform: Nullable<WebGLUniformLocation>, color3: Color3): void;
        /**
         * Set the value of an uniform to a Color3 and an alpha value
         * @param uniform defines the webGL uniform location where to store the value
         * @param color3 defines the color to store
         * @param alpha defines the alpha component to store
         */
        setColor4(uniform: Nullable<WebGLUniformLocation>, color3: Color3, alpha: number): void;
        /**
         * Sets a Color4 on a uniform variable
         * @param uniform defines the uniform location
         * @param color4 defines the value to be set
         */
        setDirectColor4(uniform: Nullable<WebGLUniformLocation>, color4: Color4): void;
        /**
         * Set various states to the webGL context
         * @param culling defines backface culling state
         * @param zOffset defines the value to apply to zOffset (0 by default)
         * @param force defines if states must be applied even if cache is up to date
         * @param reverseSide defines if culling must be reversed (CCW instead of CW and CW instead of CCW)
         */
        setState(culling: boolean, zOffset?: number, force?: boolean, reverseSide?: boolean): void;
        /**
         * Set the z offset to apply to current rendering
         * @param value defines the offset to apply
         */
        setZOffset(value: number): void;
        /**
         * Gets the current value of the zOffset
         * @returns the current zOffset state
         */
        getZOffset(): number;
        /**
         * Enable or disable depth buffering
         * @param enable defines the state to set
         */
        setDepthBuffer(enable: boolean): void;
        /**
         * Gets a boolean indicating if depth writing is enabled
         * @returns the current depth writing state
         */
        getDepthWrite(): boolean;
        /**
         * Enable or disable depth writing
         * @param enable defines the state to set
         */
        setDepthWrite(enable: boolean): void;
        /**
         * Enable or disable color writing
         * @param enable defines the state to set
         */
        setColorWrite(enable: boolean): void;
        /**
         * Gets a boolean indicating if color writing is enabled
         * @returns the current color writing state
         */
        getColorWrite(): boolean;
        /**
         * Sets alpha constants used by some alpha blending modes
         * @param r defines the red component
         * @param g defines the green component
         * @param b defines the blue component
         * @param a defines the alpha component
         */
        setAlphaConstants(r: number, g: number, b: number, a: number): void;
        /**
         * Sets the current alpha mode
         * @param mode defines the mode to use (one of the BABYLON.Engine.ALPHA_XXX)
         * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)
         * @see http://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered
         */
        setAlphaMode(mode: number, noDepthWriteChange?: boolean): void;
        /**
         * Gets the current alpha mode
         * @see http://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered
         * @returns the current alpha mode
         */
        getAlphaMode(): number;
        /**
         * Force the entire cache to be cleared
         * You should not have to use this function unless your engine needs to share the webGL context with another engine
         * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)
         */
        wipeCaches(bruteForce?: boolean): void;
        /**
         * Set the compressed texture format to use, based on the formats you have, and the formats
         * supported by the hardware / browser.
         *
         * Khronos Texture Container (.ktx) files are used to support this.  This format has the
         * advantage of being specifically designed for OpenGL.  Header elements directly correspond
         * to API arguments needed to compressed textures.  This puts the burden on the container
         * generator to house the arcane code for determining these for current & future formats.
         *
         * for description see https://www.khronos.org/opengles/sdk/tools/KTX/
         * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
         *
         * Note: The result of this call is not taken into account when a texture is base64.
         *
         * @param formatsAvailable defines the list of those format families you have created
         * on your server.  Syntax: '-' + format family + '.ktx'.  (Case and order do not matter.)
         *
         * Current families are astc, dxt, pvrtc, etc2, & etc1.
         * @returns The extension selected.
         */
        setTextureFormatToUse(formatsAvailable: Array<string>): Nullable<string>;
        /** @hidden */
        _createTexture(): WebGLTexture;
        /**
         * Usually called from BABYLON.Texture.ts.
         * Passed information to create a WebGLTexture
         * @param urlArg defines a value which contains one of the following:
         * * A conventional http URL, e.g. 'http://...' or 'file://...'
         * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'
         * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'
         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file
         * @param invertY when true, image is flipped when loaded.  You probably want true. Ignored for compressed textures.  Must be flipped in the file
         * @param scene needed for loading to the correct scene
         * @param samplingMode mode with should be used sample / access the texture (Default: BABYLON.Texture.TRILINEAR_SAMPLINGMODE)
         * @param onLoad optional callback to be called upon successful completion
         * @param onError optional callback to be called upon failure
         * @param buffer a source of a file previously fetched as either an ArrayBuffer (compressed or image format) or HTMLImageElement (image format)
         * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities
         * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures
         * @returns a InternalTexture for assignment back into BABYLON.Texture
         */
        createTexture(urlArg: Nullable<string>, noMipmap: boolean, invertY: boolean, scene: Nullable<Scene>, samplingMode?: number, onLoad?: Nullable<() => void>, onError?: Nullable<(message: string, exception: any) => void>, buffer?: Nullable<ArrayBuffer | HTMLImageElement>, fallback?: Nullable<InternalTexture>, format?: Nullable<number>): InternalTexture;
        private _rescaleTexture(source, destination, scene, internalFormat, onComplete);
        /**
         * Update a raw texture
         * @param texture defines the texture to update
         * @param data defines the data to store in the texture
         * @param format defines the format of the data
         * @param invertY defines if data must be stored with Y axis inverted
         * @param compression defines the compression used (null by default)
         * @param type defines the type fo the data (BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT by default)
         */
        updateRawTexture(texture: Nullable<InternalTexture>, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression?: Nullable<string>, type?: number): void;
        /**
         * Creates a raw texture
         * @param data defines the data to store in the texture
         * @param width defines the width of the texture
         * @param height defines the height of the texture
         * @param format defines the format of the data
         * @param generateMipMaps defines if the engine should generate the mip levels
         * @param invertY defines if data must be stored with Y axis inverted
         * @param samplingMode defines the required sampling mode (BABYLON.Texture.NEAREST_SAMPLINGMODE by default)
         * @param compression defines the compression used (null by default)
         * @param type defines the type fo the data (BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT by default)
         * @returns the raw texture inside an InternalTexture
         */
        createRawTexture(data: Nullable<ArrayBufferView>, width: number, height: number, format: number, generateMipMaps: boolean, invertY: boolean, samplingMode: number, compression?: Nullable<string>, type?: number): InternalTexture;
        /**
         * Creates a dynamic texture
         * @param width defines the width of the texture
         * @param height defines the height of the texture
         * @param generateMipMaps defines if the engine should generate the mip levels
         * @param samplingMode defines the required sampling mode (BABYLON.Texture.NEAREST_SAMPLINGMODE by default)
         * @returns the dynamic texture inside an InternalTexture
         */
        createDynamicTexture(width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture;
        /**
         * Update the sampling mode of a given texture
         * @param samplingMode defines the required sampling mode
         * @param texture defines the texture to update
         */
        updateTextureSamplingMode(samplingMode: number, texture: InternalTexture): void;
        /**
         * Update the content of a dynamic texture
         * @param texture defines the texture to update
         * @param canvas defines the canvas containing the source
         * @param invertY defines if data must be stored with Y axis inverted
         * @param premulAlpha defines if alpha is stored as premultiplied
         * @param format defines the format of the data
         */
        updateDynamicTexture(texture: Nullable<InternalTexture>, canvas: HTMLCanvasElement, invertY: boolean, premulAlpha?: boolean, format?: number): void;
        /**
         * Update a video texture
         * @param texture defines the texture to update
         * @param video defines the video element to use
         * @param invertY defines if data must be stored with Y axis inverted
         */
        updateVideoTexture(texture: Nullable<InternalTexture>, video: HTMLVideoElement, invertY: boolean): void;
        /**
         * Updates a depth texture Comparison Mode and Function.
         * If the comparison Function is equal to 0, the mode will be set to none.
         * Otherwise, this only works in webgl 2 and requires a shadow sampler in the shader.
         * @param texture The texture to set the comparison function for
         * @param comparisonFunction The comparison function to set, 0 if no comparison required
         */
        updateTextureComparisonFunction(texture: InternalTexture, comparisonFunction: number): void;
        private _setupDepthStencilTexture(internalTexture, size, generateStencil, bilinearFiltering, comparisonFunction);
        /**
         * Creates a depth stencil texture.
         * This is only available in WebGL 2 or with the depth texture extension available.
         * @param size The size of face edge in the texture.
         * @param options The options defining the texture.
         * @returns The texture
         */
        createDepthStencilTexture(size: number | {
            width: number;
            height: number;
        }, options: DepthTextureCreationOptions): InternalTexture;
        /**
         * Creates a depth stencil texture.
         * This is only available in WebGL 2 or with the depth texture extension available.
         * @param size The size of face edge in the texture.
         * @param options The options defining the texture.
         * @returns The texture
         */
        private _createDepthStencilTexture(size, options);
        /**
         * Creates a depth stencil cube texture.
         * This is only available in WebGL 2.
         * @param size The size of face edge in the cube texture.
         * @param options The options defining the cube texture.
         * @returns The cube texture
         */
        private _createDepthStencilCubeTexture(size, options);
        /**
         * Sets the frame buffer Depth / Stencil attachement of the render target to the defined depth stencil texture.
         * @param renderTarget The render target to set the frame buffer for
         */
        setFrameBufferDepthStencilTexture(renderTarget: RenderTargetTexture): void;
        /**
         * Creates a new render target texture
         * @param size defines the size of the texture
         * @param options defines the options used to create the texture
         * @returns a new render target texture stored in an InternalTexture
         */
        createRenderTargetTexture(size: number | {
            width: number;
            height: number;
        }, options: boolean | RenderTargetCreationOptions): InternalTexture;
        /**
         * Create a multi render target texture
         * @see http://doc.babylonjs.com/features/webgl2#multiple-render-target
         * @param size defines the size of the texture
         * @param options defines the creation options
         * @returns the cube texture as an InternalTexture
         */
        createMultipleRenderTarget(size: any, options: IMultiRenderTargetOptions): InternalTexture[];
        private _setupFramebufferDepthAttachments(generateStencilBuffer, generateDepthBuffer, width, height, samples?);
        /**
         * Updates the sample count of a render target texture
         * @see http://doc.babylonjs.com/features/webgl2#multisample-render-targets
         * @param texture defines the texture to update
         * @param samples defines the sample count to set
         * @returns the effective sample count (could be 0 if multisample render targets are not supported)
         */
        updateRenderTargetTextureSampleCount(texture: Nullable<InternalTexture>, samples: number): number;
        /**
         * Update the sample count for a given multiple render target texture
         * @see http://doc.babylonjs.com/features/webgl2#multisample-render-targets
         * @param textures defines the textures to update
         * @param samples defines the sample count to set
         * @returns the effective sample count (could be 0 if multisample render targets are not supported)
         */
        updateMultipleRenderTargetTextureSampleCount(textures: Nullable<InternalTexture[]>, samples: number): number;
        /** @hidden */
        _uploadDataToTexture(target: number, lod: number, internalFormat: number, width: number, height: number, format: number, type: number, data: ArrayBufferView): void;
        /** @hidden */
        _uploadCompressedDataToTexture(target: number, lod: number, internalFormat: number, width: number, height: number, data: ArrayBufferView): void;
        /**
         * Creates a new render target cube texture
         * @param size defines the size of the texture
         * @param options defines the options used to create the texture
         * @returns a new render target cube texture stored in an InternalTexture
         */
        createRenderTargetCubeTexture(size: number, options?: Partial<RenderTargetCreationOptions>): InternalTexture;
        /**
         * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)
         * @param rootUrl defines the url where the file to load is located
         * @param scene defines the current scene
         * @param scale defines scale to apply to the mip map selection
         * @param offset defines offset to apply to the mip map selection
         * @param onLoad defines an optional callback raised when the texture is loaded
         * @param onError defines an optional callback raised if there is an issue to load the texture
         * @param format defines the format of the data
         * @param forcedExtension defines the extension to use to pick the right loader
         * @returns the cube texture as an InternalTexture
         */
        createPrefilteredCubeTexture(rootUrl: string, scene: Nullable<Scene>, scale: number, offset: number, onLoad?: Nullable<(internalTexture: Nullable<InternalTexture>) => void>, onError?: Nullable<(message?: string, exception?: any) => void>, format?: number, forcedExtension?: any): InternalTexture;
        /**
         * Creates a cube texture
         * @param rootUrl defines the url where the files to load is located
         * @param scene defines the current scene
         * @param files defines the list of files to load (1 per face)
         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)
         * @param onLoad defines an optional callback raised when the texture is loaded
         * @param onError defines an optional callback raised if there is an issue to load the texture
         * @param format defines the format of the data
         * @param forcedExtension defines the extension to use to pick the right loader
         * @param createPolynomials if a polynomial sphere should be created for the cube texture
         * @returns the cube texture as an InternalTexture
         */
        createCubeTexture(rootUrl: string, scene: Nullable<Scene>, files: Nullable<string[]>, noMipmap?: boolean, onLoad?: Nullable<(data?: any) => void>, onError?: Nullable<(message?: string, exception?: any) => void>, format?: number, forcedExtension?: any, createPolynomials?: boolean): InternalTexture;
        private setCubeMapTextureParams(gl, loadMipmap);
        /**
         * Update a raw cube texture
         * @param texture defines the texture to udpdate
         * @param data defines the data to store
         * @param format defines the data format
         * @param type defines the type fo the data (BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT by default)
         * @param invertY defines if data must be stored with Y axis inverted
         * @param compression defines the compression used (null by default)
         * @param level defines which level of the texture to update
         */
        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression?: Nullable<string>, level?: number): void;
        /**
         * Creates a new raw cube texture
         * @param data defines the array of data to use to create each face
         * @param size defines the size of the textures
         * @param format defines the format of the data
         * @param type defines the type fo the data (like BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT)
         * @param generateMipMaps  defines if the engine should generate the mip levels
         * @param invertY defines if data must be stored with Y axis inverted
         * @param samplingMode defines the required sampling mode (like BABYLON.Texture.NEAREST_SAMPLINGMODE)
         * @param compression defines the compression used (null by default)
         * @returns the cube texture as an InternalTexture
         */
        createRawCubeTexture(data: Nullable<ArrayBufferView[]>, size: number, format: number, type: number, generateMipMaps: boolean, invertY: boolean, samplingMode: number, compression?: Nullable<string>): InternalTexture;
        /**
         * Creates a new raw cube texture from a specified url
         * @param url defines the url where the data is located
         * @param scene defines the current scene
         * @param size defines the size of the textures
         * @param format defines the format of the data
         * @param type defines the type fo the data (like BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT)
         * @param noMipmap defines if the engine should avoid generating the mip levels
         * @param callback defines a callback used to extract texture data from loaded data
         * @param mipmapGenerator defines to provide an optional tool to generate mip levels
         * @param onLoad defines a callback called when texture is loaded
         * @param onError defines a callback called if there is an error
         * @param samplingMode defines the required sampling mode (like BABYLON.Texture.NEAREST_SAMPLINGMODE)
         * @param invertY defines if data must be stored with Y axis inverted
         * @returns the cube texture as an InternalTexture
         */
        createRawCubeTextureFromUrl(url: string, scene: Scene, size: number, format: number, type: number, noMipmap: boolean, callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>, mipmapGenerator: Nullable<((faces: ArrayBufferView[]) => ArrayBufferView[][])>, onLoad?: Nullable<() => void>, onError?: Nullable<(message?: string, exception?: any) => void>, samplingMode?: number, invertY?: boolean): InternalTexture;
        /**
         * Update a raw 3D texture
         * @param texture defines the texture to update
         * @param data defines the data to store
         * @param format defines the data format
         * @param invertY defines if data must be stored with Y axis inverted
         * @param compression defines the used compression (can be null)
         */
        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression?: Nullable<string>): void;
        /**
         * Creates a new raw 3D texture
         * @param data defines the data used to create the texture
         * @param width defines the width of the texture
         * @param height defines the height of the texture
         * @param depth defines the depth of the texture
         * @param format defines the format of the texture
         * @param generateMipMaps defines if the engine must generate mip levels
         * @param invertY defines if data must be stored with Y axis inverted
         * @param samplingMode defines the required sampling mode (like BABYLON.Texture.NEAREST_SAMPLINGMODE)
         * @param compression defines the compressed used (can be null)
         * @returns a new raw 3D texture (stored in an InternalTexture)
         */
        createRawTexture3D(data: Nullable<ArrayBufferView>, width: number, height: number, depth: number, format: number, generateMipMaps: boolean, invertY: boolean, samplingMode: number, compression?: Nullable<string>): InternalTexture;
        private _prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);
        private _prepareWebGLTexture(texture, scene, width, height, invertY, noMipmap, isCompressed, processFunction, samplingMode?);
        private _convertRGBtoRGBATextureData(rgbData, width, height, textureType);
        /** @hidden */
        _releaseFramebufferObjects(texture: InternalTexture): void;
        /** @hidden */
        _releaseTexture(texture: InternalTexture): void;
        private setProgram(program);
        private _boundUniforms;
        /**
         * Binds an effect to the webGL context
         * @param effect defines the effect to bind
         */
        bindSamplers(effect: Effect): void;
        private _moveBoundTextureOnTop(internalTexture);
        private _getCorrectTextureChannel(channel, internalTexture);
        private _linkTrackers(previous, next);
        private _removeDesignatedSlot(internalTexture);
        private _activateCurrentTexture();
        /** @hidden */
        protected _bindTextureDirectly(target: number, texture: Nullable<InternalTexture>, forTextureDataUpdate?: boolean, force?: boolean): void;
        /** @hidden */
        _bindTexture(channel: number, texture: Nullable<InternalTexture>): void;
        /**
         * Sets a texture to the webGL context from a postprocess
         * @param channel defines the channel to use
         * @param postProcess defines the source postprocess
         */
        setTextureFromPostProcess(channel: number, postProcess: Nullable<PostProcess>): void;
        /**
         * Binds the output of the passed in post process to the texture channel specified
         * @param channel The channel the texture should be bound to
         * @param postProcess The post process which's output should be bound
         */
        setTextureFromPostProcessOutput(channel: number, postProcess: Nullable<PostProcess>): void;
        /**
         * Unbind all textures from the webGL context
         */
        unbindAllTextures(): void;
        /**
         * Sets a texture to the according uniform.
         * @param channel The texture channel
         * @param uniform The uniform to set
         * @param texture The texture to apply
         */
        setTexture(channel: number, uniform: Nullable<WebGLUniformLocation>, texture: Nullable<BaseTexture>): void;
        /**
         * Sets a depth stencil texture from a render target to the according uniform.
         * @param channel The texture channel
         * @param uniform The uniform to set
         * @param texture The render target texture containing the depth stencil texture to apply
         */
        setDepthStencilTexture(channel: number, uniform: Nullable<WebGLUniformLocation>, texture: Nullable<RenderTargetTexture>): void;
        private _bindSamplerUniformToChannel(sourceSlot, destination);
        private _getTextureWrapMode(mode);
        private _setTexture(channel, texture, isPartOfTextureArray?, depthStencilTexture?);
        /**
         * Sets an array of texture to the webGL context
         * @param channel defines the channel where the texture array must be set
         * @param uniform defines the associated uniform location
         * @param textures defines the array of textures to bind
         */
        setTextureArray(channel: number, uniform: Nullable<WebGLUniformLocation>, textures: BaseTexture[]): void;
        /** @hidden */
        _setAnisotropicLevel(target: number, texture: BaseTexture): void;
        private _setTextureParameterFloat(target, parameter, value, texture);
        private _setTextureParameterInteger(target, parameter, value, texture?);
        /**
         * Reads pixels from the current frame buffer. Please note that this function can be slow
         * @param x defines the x coordinate of the rectangle where pixels must be read
         * @param y defines the y coordinate of the rectangle where pixels must be read
         * @param width defines the width of the rectangle where pixels must be read
         * @param height defines the height of the rectangle where pixels must be read
         * @returns a Uint8Array containing RGBA colors
         */
        readPixels(x: number, y: number, width: number, height: number): Uint8Array;
        /**
         * Add an externaly attached data from its key.
         * This method call will fail and return false, if such key already exists.
         * If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.
         * @param key the unique key that identifies the data
         * @param data the data object to associate to the key for this Engine instance
         * @return true if no such key were already present and the data was added successfully, false otherwise
         */
        addExternalData<T>(key: string, data: T): boolean;
        /**
         * Get an externaly attached data from its key
         * @param key the unique key that identifies the data
         * @return the associated data, if present (can be null), or undefined if not present
         */
        getExternalData<T>(key: string): T;
        /**
         * Get an externaly attached data from its key, create it using a factory if it's not already present
         * @param key the unique key that identifies the data
         * @param factory the factory that will be called to create the instance if and only if it doesn't exists
         * @return the associated data, can be null if the factory returned null.
         */
        getOrAddExternalDataWithFactory<T>(key: string, factory: (k: string) => T): T;
        /**
         * Remove an externaly attached data from the Engine instance
         * @param key the unique key that identifies the data
         * @return true if the data was successfully removed, false if it doesn't exist
         */
        removeExternalData(key: string): boolean;
        /**
         * Unbind all vertex attributes from the webGL context
         */
        unbindAllAttributes(): void;
        /**
         * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled
         */
        releaseEffects(): void;
        /**
         * Dispose and release all associated resources
         */
        dispose(): void;
        /**
         * Display the loading screen
         * @see http://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
         */
        displayLoadingUI(): void;
        /**
         * Hide the loading screen
         * @see http://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
         */
        hideLoadingUI(): void;
        /**
         * Gets the current loading screen object
         * @see http://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
         */
        /**
         * Sets the current loading screen object
         * @see http://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
         */
        loadingScreen: ILoadingScreen;
        /**
         * Sets the current loading screen text
         * @see http://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
         */
        loadingUIText: string;
        /**
         * Sets the current loading screen background color
         * @see http://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
         */
        loadingUIBackgroundColor: string;
        /**
         * Attach a new callback raised when context lost event is fired
         * @param callback defines the callback to call
         */
        attachContextLostEvent(callback: ((event: WebGLContextEvent) => void)): void;
        /**
         * Attach a new callback raised when context restored event is fired
         * @param callback defines the callback to call
         */
        attachContextRestoredEvent(callback: ((event: WebGLContextEvent) => void)): void;
        /**
         * Gets the source code of the vertex shader associated with a specific webGL program
         * @param program defines the program to use
         * @returns a string containing the source code of the vertex shader associated with the program
         */
        getVertexShaderSource(program: WebGLProgram): Nullable<string>;
        /**
         * Gets the source code of the fragment shader associated with a specific webGL program
         * @param program defines the program to use
         * @returns a string containing the source code of the fragment shader associated with the program
         */
        getFragmentShaderSource(program: WebGLProgram): Nullable<string>;
        /**
         * Get the current error code of the webGL context
         * @returns the error code
         * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError
         */
        getError(): number;
        /**
         * Gets the current framerate
         * @returns a number representing the framerate
         */
        getFps(): number;
        /**
         * Gets the time spent between current and previous frame
         * @returns a number representing the delta time in ms
         */
        getDeltaTime(): number;
        private _measureFps();
        /** @hidden */
        _readTexturePixels(texture: InternalTexture, width: number, height: number, faceIndex?: number): ArrayBufferView;
        private _canRenderToFloatFramebuffer();
        private _canRenderToHalfFloatFramebuffer();
        private _canRenderToFramebuffer(type);
        /** @hidden */
        _getWebGLTextureType(type: number): number;
        private _getInternalFormat(format);
        /** @hidden */
        _getRGBABufferInternalSizedFormat(type: number, format?: number): number;
        /** @hidden */
        _getRGBAMultiSampleBufferFormat(type: number): number;
        /**
         * Create a new webGL query (you must be sure that queries are supported by checking getCaps() function)
         * @return the new query
         */
        createQuery(): WebGLQuery;
        /**
         * Delete and release a webGL query
         * @param query defines the query to delete
         * @return the current engine
         */
        deleteQuery(query: WebGLQuery): Engine;
        /**
         * Check if a given query has resolved and got its value
         * @param query defines the query to check
         * @returns true if the query got its value
         */
        isQueryResultAvailable(query: WebGLQuery): boolean;
        /**
         * Gets the value of a given query
         * @param query defines the query to check
         * @returns the value of the query
         */
        getQueryResult(query: WebGLQuery): number;
        /**
         * Initiates an occlusion query
         * @param algorithmType defines the algorithm to use
         * @param query defines the query to use
         * @returns the current engine
         * @see http://doc.babylonjs.com/features/occlusionquery
         */
        beginOcclusionQuery(algorithmType: number, query: WebGLQuery): Engine;
        /**
         * Ends an occlusion query
         * @see http://doc.babylonjs.com/features/occlusionquery
         * @param algorithmType defines the algorithm to use
         * @returns the current engine
         */
        endOcclusionQuery(algorithmType: number): Engine;
        private _createTimeQuery();
        private _deleteTimeQuery(query);
        private _getTimeQueryResult(query);
        private _getTimeQueryAvailability(query);
        private _currentNonTimestampToken;
        /**
         * Starts a time query (used to measure time spent by the GPU on a specific frame)
         * Please note that only one query can be issued at a time
         * @returns a time token used to track the time span
         */
        startTimeQuery(): Nullable<_TimeToken>;
        /**
         * Ends a time query
         * @param token defines the token used to measure the time span
         * @returns the time spent (in ns)
         */
        endTimeQuery(token: _TimeToken): int;
        private getGlAlgorithmType(algorithmType);
        /**
         * Creates a webGL transform feedback object
         * Please makes sure to check webGLVersion property to check if you are running webGL 2+
         * @returns the webGL transform feedback object
         */
        createTransformFeedback(): WebGLTransformFeedback;
        /**
         * Delete a webGL transform feedback object
         * @param value defines the webGL transform feedback object to delete
         */
        deleteTransformFeedback(value: WebGLTransformFeedback): void;
        /**
         * Bind a webGL transform feedback object to the webgl context
         * @param value defines the webGL transform feedback object to bind
         */
        bindTransformFeedback(value: Nullable<WebGLTransformFeedback>): void;
        /**
         * Begins a transform feedback operation
         * @param usePoints defines if points or triangles must be used
         */
        beginTransformFeedback(usePoints?: boolean): void;
        /**
         * Ends a transform feedback operation
         */
        endTransformFeedback(): void;
        /**
         * Specify the varyings to use with transform feedback
         * @param program defines the associated webGL program
         * @param value defines the list of strings representing the varying names
         */
        setTranformFeedbackVaryings(program: WebGLProgram, value: string[]): void;
        /**
         * Bind a webGL buffer for a transform feedback operation
         * @param value defines the webGL buffer to bind
         */
        bindTransformFeedbackBuffer(value: Nullable<WebGLBuffer>): void;
        /** @hidden */
        _loadFile(url: string, onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void, onProgress?: (data: any) => void, database?: Database, useArrayBuffer?: boolean, onError?: (request?: XMLHttpRequest, exception?: any) => void): IFileRequest;
        /** @hidden */
        _loadFileAsync(url: string, database?: Database, useArrayBuffer?: boolean): Promise<string | ArrayBuffer>;
        private _partialLoadFile(url, index, loadedFiles, scene, onfinish, onErrorCallBack?);
        private _cascadeLoadFiles(scene, onfinish, files, onError?);
        /**
         * Gets a boolean indicating if the engine can be instanciated (ie. if a webGL context can be found)
         * @returns true if the engine can be created
         * @ignorenaming
         */
        static isSupported(): boolean;
    }
}

declare module BABYLON {
    class NullEngineOptions {
        renderWidth: number;
        renderHeight: number;
        textureSize: number;
        deterministicLockstep: boolean;
        lockstepMaxSteps: number;
    }
    /**
     * The null engine class provides support for headless version of babylon.js.
     * This can be used in server side scenario or for testing purposes
     */
    class NullEngine extends Engine {
        private _options;
        isDeterministicLockStep(): boolean;
        getLockstepMaxSteps(): number;
        getHardwareScalingLevel(): number;
        constructor(options?: NullEngineOptions);
        createVertexBuffer(vertices: FloatArray): WebGLBuffer;
        createIndexBuffer(indices: IndicesArray): WebGLBuffer;
        clear(color: Color4, backBuffer: boolean, depth: boolean, stencil?: boolean): void;
        getRenderWidth(useScreen?: boolean): number;
        getRenderHeight(useScreen?: boolean): number;
        setViewport(viewport: Viewport, requiredWidth?: number, requiredHeight?: number): void;
        createShaderProgram(vertexCode: string, fragmentCode: string, defines: string, context?: WebGLRenderingContext): WebGLProgram;
        getUniforms(shaderProgram: WebGLProgram, uniformsNames: string[]): WebGLUniformLocation[];
        getAttributes(shaderProgram: WebGLProgram, attributesNames: string[]): number[];
        bindSamplers(effect: Effect): void;
        enableEffect(effect: Effect): void;
        setState(culling: boolean, zOffset?: number, force?: boolean, reverseSide?: boolean): void;
        setIntArray(uniform: WebGLUniformLocation, array: Int32Array): void;
        setIntArray2(uniform: WebGLUniformLocation, array: Int32Array): void;
        setIntArray3(uniform: WebGLUniformLocation, array: Int32Array): void;
        setIntArray4(uniform: WebGLUniformLocation, array: Int32Array): void;
        setFloatArray(uniform: WebGLUniformLocation, array: Float32Array): void;
        setFloatArray2(uniform: WebGLUniformLocation, array: Float32Array): void;
        setFloatArray3(uniform: WebGLUniformLocation, array: Float32Array): void;
        setFloatArray4(uniform: WebGLUniformLocation, array: Float32Array): void;
        setArray(uniform: WebGLUniformLocation, array: number[]): void;
        setArray2(uniform: WebGLUniformLocation, array: number[]): void;
        setArray3(uniform: WebGLUniformLocation, array: number[]): void;
        setArray4(uniform: WebGLUniformLocation, array: number[]): void;
        setMatrices(uniform: WebGLUniformLocation, matrices: Float32Array): void;
        setMatrix(uniform: WebGLUniformLocation, matrix: Matrix): void;
        setMatrix3x3(uniform: WebGLUniformLocation, matrix: Float32Array): void;
        setMatrix2x2(uniform: WebGLUniformLocation, matrix: Float32Array): void;
        setFloat(uniform: WebGLUniformLocation, value: number): void;
        setFloat2(uniform: WebGLUniformLocation, x: number, y: number): void;
        setFloat3(uniform: WebGLUniformLocation, x: number, y: number, z: number): void;
        setBool(uniform: WebGLUniformLocation, bool: number): void;
        setFloat4(uniform: WebGLUniformLocation, x: number, y: number, z: number, w: number): void;
        setColor3(uniform: WebGLUniformLocation, color3: Color3): void;
        setColor4(uniform: WebGLUniformLocation, color3: Color3, alpha: number): void;
        setAlphaMode(mode: number, noDepthWriteChange?: boolean): void;
        bindBuffers(vertexBuffers: {
            [key: string]: VertexBuffer;
        }, indexBuffer: WebGLBuffer, effect: Effect): void;
        wipeCaches(bruteForce?: boolean): void;
        draw(useTriangles: boolean, indexStart: number, indexCount: number, instancesCount?: number): void;
        drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount?: number): void;
        drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount?: number): void;
        _createTexture(): WebGLTexture;
        _releaseTexture(texture: InternalTexture): void;
        createTexture(urlArg: string, noMipmap: boolean, invertY: boolean, scene: Scene, samplingMode?: number, onLoad?: Nullable<() => void>, onError?: Nullable<(message: string, exception: any) => void>, buffer?: Nullable<ArrayBuffer | HTMLImageElement>, fallBack?: InternalTexture, format?: number): InternalTexture;
        createRenderTargetTexture(size: any, options: boolean | RenderTargetCreationOptions): InternalTexture;
        updateTextureSamplingMode(samplingMode: number, texture: InternalTexture): void;
        bindFramebuffer(texture: InternalTexture, faceIndex?: number, requiredWidth?: number, requiredHeight?: number, forceFullscreenViewport?: boolean): void;
        unBindFramebuffer(texture: InternalTexture, disableGenerateMipMaps?: boolean, onBeforeUnbind?: () => void): void;
        createDynamicVertexBuffer(vertices: FloatArray): WebGLBuffer;
        updateDynamicIndexBuffer(indexBuffer: WebGLBuffer, indices: IndicesArray, offset?: number): void;
        /**
         * Updates a dynamic vertex buffer.
         * @param vertexBuffer the vertex buffer to update
         * @param data the data used to update the vertex buffer
         * @param byteOffset the byte offset of the data (optional)
         * @param byteLength the byte length of the data (optional)
         */
        updateDynamicVertexBuffer(vertexBuffer: WebGLBuffer, vertices: FloatArray, byteOffset?: number, byteLength?: number): void;
        protected _bindTextureDirectly(target: number, texture: InternalTexture): void;
        _bindTexture(channel: number, texture: InternalTexture): void;
        _releaseBuffer(buffer: WebGLBuffer): boolean;
        releaseEffects(): void;
    }
}

interface WebGLRenderingContext {
    readonly RASTERIZER_DISCARD: number;
    readonly DEPTH_COMPONENT24: number;
    readonly TEXTURE_3D: number;
    readonly TEXTURE_2D_ARRAY: number;
    readonly TEXTURE_COMPARE_FUNC: number;
    readonly TEXTURE_COMPARE_MODE: number;
    readonly COMPARE_REF_TO_TEXTURE: number;
    readonly TEXTURE_WRAP_R: number;
    texImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, format: number, type: number, pixels: ArrayBufferView | null): void;
    texImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, format: number, type: number, pixels: ArrayBufferView, offset: number): void;
    texImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, format: number, type: number, pixels: ImageBitmap | ImageData | HTMLVideoElement | HTMLImageElement | HTMLCanvasElement): void;
    compressedTexImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, data: ArrayBufferView, offset?: number, length?: number): void;
    readonly TRANSFORM_FEEDBACK: number;
    readonly INTERLEAVED_ATTRIBS: number;
    readonly TRANSFORM_FEEDBACK_BUFFER: number;
    createTransformFeedback(): WebGLTransformFeedback;
    deleteTransformFeedback(transformFeedbac: WebGLTransformFeedback): void;
    bindTransformFeedback(target: number, transformFeedback: WebGLTransformFeedback | null): void;
    beginTransformFeedback(primitiveMode: number): void;
    endTransformFeedback(): void;
    transformFeedbackVaryings(program: WebGLProgram, varyings: string[], bufferMode: number): void;
}
interface ImageBitmap {
    readonly width: number;
    readonly height: number;
    close(): void;
}
interface WebGLQuery extends WebGLObject {
}
declare var WebGLQuery: {
    prototype: WebGLQuery;
    new (): WebGLQuery;
};
interface WebGLSampler extends WebGLObject {
}
declare var WebGLSampler: {
    prototype: WebGLSampler;
    new (): WebGLSampler;
};
interface WebGLSync extends WebGLObject {
}
declare var WebGLSync: {
    prototype: WebGLSync;
    new (): WebGLSync;
};
interface WebGLTransformFeedback extends WebGLObject {
}
declare var WebGLTransformFeedback: {
    prototype: WebGLTransformFeedback;
    new (): WebGLTransformFeedback;
};
interface WebGLVertexArrayObject extends WebGLObject {
}
declare var WebGLVertexArrayObject: {
    prototype: WebGLVertexArrayObject;
    new (): WebGLVertexArrayObject;
};

declare module BABYLON {
    class KeyboardEventTypes {
        static _KEYDOWN: number;
        static _KEYUP: number;
        static readonly KEYDOWN: number;
        static readonly KEYUP: number;
    }
    class KeyboardInfo {
        type: number;
        event: KeyboardEvent;
        constructor(type: number, event: KeyboardEvent);
    }
    /**
     * This class is used to store keyboard related info for the onPreKeyboardObservable event.
     * Set the skipOnKeyboardObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onKeyboardObservable
     */
    class KeyboardInfoPre extends KeyboardInfo {
        constructor(type: number, event: KeyboardEvent);
        skipOnPointerObservable: boolean;
    }
}

declare module BABYLON {
    class PointerEventTypes {
        static _POINTERDOWN: number;
        static _POINTERUP: number;
        static _POINTERMOVE: number;
        static _POINTERWHEEL: number;
        static _POINTERPICK: number;
        static _POINTERTAP: number;
        static _POINTERDOUBLETAP: number;
        static readonly POINTERDOWN: number;
        static readonly POINTERUP: number;
        static readonly POINTERMOVE: number;
        static readonly POINTERWHEEL: number;
        static readonly POINTERPICK: number;
        static readonly POINTERTAP: number;
        static readonly POINTERDOUBLETAP: number;
    }
    class PointerInfoBase {
        type: number;
        event: PointerEvent | MouseWheelEvent;
        constructor(type: number, event: PointerEvent | MouseWheelEvent);
    }
    /**
     * This class is used to store pointer related info for the onPrePointerObservable event.
     * Set the skipOnPointerObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onPointerObservable
     */
    class PointerInfoPre extends PointerInfoBase {
        constructor(type: number, event: PointerEvent | MouseWheelEvent, localX: number, localY: number);
        localPosition: Vector2;
        skipOnPointerObservable: boolean;
    }
    /**
     * This type contains all the data related to a pointer event in Babylon.js.
     * The event member is an instance of PointerEvent for all types except PointerWheel and is of type MouseWheelEvent when type equals PointerWheel. The different event types can be found in the PointerEventTypes class.
     */
    class PointerInfo extends PointerInfoBase {
        pickInfo: Nullable<PickingInfo>;
        constructor(type: number, event: PointerEvent | MouseWheelEvent, pickInfo: Nullable<PickingInfo>);
    }
}

declare module BABYLON {
    class BoundingBox implements ICullable {
        vectors: Vector3[];
        center: Vector3;
        centerWorld: Vector3;
        extendSize: Vector3;
        extendSizeWorld: Vector3;
        directions: Vector3[];
        vectorsWorld: Vector3[];
        minimumWorld: Vector3;
        maximumWorld: Vector3;
        minimum: Vector3;
        maximum: Vector3;
        private _worldMatrix;
        /**
         * Creates a new bounding box
         * @param min defines the minimum vector (in local space)
         * @param max defines the maximum vector (in local space)
         */
        constructor(min: Vector3, max: Vector3);
        /**
         * Recreates the entire bounding box from scratch
         * @param min defines the new minimum vector (in local space)
         * @param max defines the new maximum vector (in local space)
         */
        reConstruct(min: Vector3, max: Vector3): void;
        getWorldMatrix(): Matrix;
        setWorldMatrix(matrix: Matrix): BoundingBox;
        _update(world: Matrix): void;
        isInFrustum(frustumPlanes: Plane[]): boolean;
        isCompletelyInFrustum(frustumPlanes: Plane[]): boolean;
        intersectsPoint(point: Vector3): boolean;
        intersectsSphere(sphere: BoundingSphere): boolean;
        intersectsMinMax(min: Vector3, max: Vector3): boolean;
        static Intersects(box0: BoundingBox, box1: BoundingBox): boolean;
        static IntersectsSphere(minPoint: Vector3, maxPoint: Vector3, sphereCenter: Vector3, sphereRadius: number): boolean;
        static IsCompletelyInFrustum(boundingVectors: Vector3[], frustumPlanes: Plane[]): boolean;
        static IsInFrustum(boundingVectors: Vector3[], frustumPlanes: Plane[]): boolean;
    }
}

declare module BABYLON {
    interface ICullable {
        isInFrustum(frustumPlanes: Plane[]): boolean;
        isCompletelyInFrustum(frustumPlanes: Plane[]): boolean;
    }
    class BoundingInfo implements ICullable {
        minimum: Vector3;
        maximum: Vector3;
        boundingBox: BoundingBox;
        boundingSphere: BoundingSphere;
        private _isLocked;
        constructor(minimum: Vector3, maximum: Vector3);
        isLocked: boolean;
        update(world: Matrix): void;
        /**
         * Recreate the bounding info to be centered around a specific point given a specific extend.
         * @param center New center of the bounding info
         * @param extend New extend of the bounding info
         */
        centerOn(center: Vector3, extend: Vector3): BoundingInfo;
        isInFrustum(frustumPlanes: Plane[]): boolean;
        /**
         * Gets the world distance between the min and max points of the bounding box
         */
        readonly diagonalLength: number;
        isCompletelyInFrustum(frustumPlanes: Plane[]): boolean;
        _checkCollision(collider: Collider): boolean;
        intersectsPoint(point: Vector3): boolean;
        intersects(boundingInfo: BoundingInfo, precise: boolean): boolean;
    }
}

declare module BABYLON {
    class BoundingSphere {
        center: Vector3;
        radius: number;
        centerWorld: Vector3;
        radiusWorld: number;
        minimum: Vector3;
        maximum: Vector3;
        private _tempRadiusVector;
        /**
         * Creates a new bounding sphere
         * @param min defines the minimum vector (in local space)
         * @param max defines the maximum vector (in local space)
         */
        constructor(min: Vector3, max: Vector3);
        /**
         * Recreates the entire bounding sphere from scratch
         * @param min defines the new minimum vector (in local space)
         * @param max defines the new maximum vector (in local space)
         */
        reConstruct(min: Vector3, max: Vector3): void;
        _update(world: Matrix): void;
        isInFrustum(frustumPlanes: Plane[]): boolean;
        intersectsPoint(point: Vector3): boolean;
        static Intersects(sphere0: BoundingSphere, sphere1: BoundingSphere): boolean;
    }
}

declare module BABYLON {
    class Ray {
        origin: Vector3;
        direction: Vector3;
        length: number;
        private _edge1;
        private _edge2;
        private _pvec;
        private _tvec;
        private _qvec;
        private _tmpRay;
        constructor(origin: Vector3, direction: Vector3, length?: number);
        intersectsBoxMinMax(minimum: Vector3, maximum: Vector3): boolean;
        intersectsBox(box: BoundingBox): boolean;
        intersectsSphere(sphere: BoundingSphere): boolean;
        intersectsTriangle(vertex0: Vector3, vertex1: Vector3, vertex2: Vector3): Nullable<IntersectionInfo>;
        intersectsPlane(plane: Plane): Nullable<number>;
        intersectsMesh(mesh: AbstractMesh, fastCheck?: boolean): PickingInfo;
        intersectsMeshes(meshes: Array<AbstractMesh>, fastCheck?: boolean, results?: Array<PickingInfo>): Array<PickingInfo>;
        private _comparePickingInfo(pickingInfoA, pickingInfoB);
        private static smallnum;
        private static rayl;
        /**
         * Intersection test between the ray and a given segment whithin a given tolerance (threshold)
         * @param sega the first point of the segment to test the intersection against
         * @param segb the second point of the segment to test the intersection against
         * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful
         * @return the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection
         */
        intersectionSegment(sega: Vector3, segb: Vector3, threshold: number): number;
        update(x: number, y: number, viewportWidth: number, viewportHeight: number, world: Matrix, view: Matrix, projection: Matrix): Ray;
        static Zero(): Ray;
        static CreateNew(x: number, y: number, viewportWidth: number, viewportHeight: number, world: Matrix, view: Matrix, projection: Matrix): Ray;
        /**
        * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be
        * transformed to the given world matrix.
        * @param origin The origin point
        * @param end The end point
        * @param world a matrix to transform the ray to. Default is the identity matrix.
        */
        static CreateNewFromTo(origin: Vector3, end: Vector3, world?: Matrix): Ray;
        static Transform(ray: Ray, matrix: Matrix): Ray;
        static TransformToRef(ray: Ray, matrix: Matrix, result: Ray): void;
    }
}

declare module BABYLON {
    class StickValues {
        x: number;
        y: number;
        constructor(x: number, y: number);
    }
    interface GamepadButtonChanges {
        changed: boolean;
        pressChanged: boolean;
        touchChanged: boolean;
        valueChanged: boolean;
    }
    class Gamepad {
        id: string;
        index: number;
        browserGamepad: any;
        type: number;
        private _leftStick;
        private _rightStick;
        _isConnected: boolean;
        private _leftStickAxisX;
        private _leftStickAxisY;
        private _rightStickAxisX;
        private _rightStickAxisY;
        private _onleftstickchanged;
        private _onrightstickchanged;
        static GAMEPAD: number;
        static GENERIC: number;
        static XBOX: number;
        static POSE_ENABLED: number;
        protected _invertLeftStickY: boolean;
        readonly isConnected: boolean;
        constructor(id: string, index: number, browserGamepad: any, leftStickX?: number, leftStickY?: number, rightStickX?: number, rightStickY?: number);
        onleftstickchanged(callback: (values: StickValues) => void): void;
        onrightstickchanged(callback: (values: StickValues) => void): void;
        leftStick: StickValues;
        rightStick: StickValues;
        update(): void;
        dispose(): void;
    }
    class GenericPad extends Gamepad {
        private _buttons;
        private _onbuttondown;
        private _onbuttonup;
        onButtonDownObservable: Observable<number>;
        onButtonUpObservable: Observable<number>;
        onbuttondown(callback: (buttonPressed: number) => void): void;
        onbuttonup(callback: (buttonReleased: number) => void): void;
        constructor(id: string, index: number, browserGamepad: any);
        private _setButtonValue(newValue, currentValue, buttonIndex);
        update(): void;
        dispose(): void;
    }
}

declare module BABYLON {
    class GamepadManager {
        private _scene;
        private _babylonGamepads;
        private _oneGamepadConnected;
        _isMonitoring: boolean;
        private _gamepadEventSupported;
        private _gamepadSupport;
        onGamepadConnectedObservable: Observable<Gamepad>;
        onGamepadDisconnectedObservable: Observable<Gamepad>;
        private _onGamepadConnectedEvent;
        private _onGamepadDisconnectedEvent;
        constructor(_scene?: Scene | undefined);
        readonly gamepads: Gamepad[];
        getGamepadByType(type?: number): Nullable<Gamepad>;
        dispose(): void;
        private _addNewGamepad(gamepad);
        private _startMonitoringGamepads();
        private _stopMonitoringGamepads();
        _checkGamepadsStatus(): void;
        private _updateGamepadObjects();
    }
}

declare module BABYLON {
    /**
     * Defines supported buttons for XBox360 compatible gamepads
     */
    enum Xbox360Button {
        /** A */
        A = 0,
        /** B */
        B = 1,
        /** X */
        X = 2,
        /** Y */
        Y = 3,
        /** Start */
        Start = 4,
        /** Back */
        Back = 5,
        /** Left button */
        LB = 6,
        /** Right button */
        RB = 7,
        /** Left stick */
        LeftStick = 8,
        /** Right stick */
        RightStick = 9,
    }
    /** Defines values for XBox360 DPad  */
    enum Xbox360Dpad {
        /** Up */
        Up = 0,
        /** Down */
        Down = 1,
        /** Left */
        Left = 2,
        /** Right */
        Right = 3,
    }
    /**
     * Defines a XBox360 gamepad
     */
    class Xbox360Pad extends Gamepad {
        private _leftTrigger;
        private _rightTrigger;
        private _onlefttriggerchanged;
        private _onrighttriggerchanged;
        private _onbuttondown;
        private _onbuttonup;
        private _ondpaddown;
        private _ondpadup;
        /** Observable raised when a button is pressed */
        onButtonDownObservable: Observable<Xbox360Button>;
        /** Observable raised when a button is released */
        onButtonUpObservable: Observable<Xbox360Button>;
        /** Observable raised when a pad is pressed */
        onPadDownObservable: Observable<Xbox360Dpad>;
        /** Observable raised when a pad is released */
        onPadUpObservable: Observable<Xbox360Dpad>;
        private _buttonA;
        private _buttonB;
        private _buttonX;
        private _buttonY;
        private _buttonBack;
        private _buttonStart;
        private _buttonLB;
        private _buttonRB;
        private _buttonLeftStick;
        private _buttonRightStick;
        private _dPadUp;
        private _dPadDown;
        private _dPadLeft;
        private _dPadRight;
        private _isXboxOnePad;
        /**
         * Creates a new XBox360 gamepad object
         * @param id defines the id of this gamepad
         * @param index defines its index
         * @param gamepad defines the internal HTML gamepad object
         * @param xboxOne defines if it is a XBox One gamepad
         */
        constructor(id: string, index: number, gamepad: any, xboxOne?: boolean);
        /**
         * Defines the callback to call when left trigger is pressed
         * @param callback defines the callback to use
         */
        onlefttriggerchanged(callback: (value: number) => void): void;
        /**
         * Defines the callback to call when right trigger is pressed
         * @param callback defines the callback to use
         */
        onrighttriggerchanged(callback: (value: number) => void): void;
        /**
         * Gets or sets left trigger value
         */
        leftTrigger: number;
        /**
         * Gets or sets right trigger value
         */
        rightTrigger: number;
        /**
         * Defines the callback to call when a button is pressed
         * @param callback defines the callback to use
         */
        onbuttondown(callback: (buttonPressed: Xbox360Button) => void): void;
        /**
         * Defines the callback to call when a button is released
         * @param callback defines the callback to use
         */
        onbuttonup(callback: (buttonReleased: Xbox360Button) => void): void;
        /**
         * Defines the callback to call when a pad is pressed
         * @param callback defines the callback to use
         */
        ondpaddown(callback: (dPadPressed: Xbox360Dpad) => void): void;
        /**
         * Defines the callback to call when a pad is released
         * @param callback defines the callback to use
         */
        ondpadup(callback: (dPadReleased: Xbox360Dpad) => void): void;
        private _setButtonValue(newValue, currentValue, buttonType);
        private _setDPadValue(newValue, currentValue, buttonType);
        /** Gets or sets value of A button */
        buttonA: number;
        /** Gets or sets value of B button */
        buttonB: number;
        /** Gets or sets value of X button */
        buttonX: number;
        /** Gets or sets value of Y button */
        buttonY: number;
        /** Gets or sets value of Start button  */
        buttonStart: number;
        /** Gets or sets value of Back button  */
        buttonBack: number;
        /** Gets or sets value of Left button  */
        buttonLB: number;
        /** Gets or sets value of Right button  */
        buttonRB: number;
        /** Gets or sets value of left stick */
        buttonLeftStick: number;
        /** Gets or sets value of right stick */
        buttonRightStick: number;
        /** Gets or sets value of DPad up */
        dPadUp: number;
        /** Gets or sets value of DPad down */
        dPadDown: number;
        /** Gets or sets value of DPad left */
        dPadLeft: number;
        /** Gets or sets value of DPad right */
        dPadRight: number;
        /**
         * Force the gamepad to synchronize with device values
         */
        update(): void;
        dispose(): void;
    }
}

declare module BABYLON {
    /**
     * Represents the different options available during the creation of
     * a Environment helper.
     *
     * This can control the default ground, skybox and image processing setup of your scene.
     */
    interface IEnvironmentHelperOptions {
        /**
         * Specifies wether or not to create a ground.
         * True by default.
         */
        createGround: boolean;
        /**
         * Specifies the ground size.
         * 15 by default.
         */
        groundSize: number;
        /**
         * The texture used on the ground for the main color.
         * Comes from the BabylonJS CDN by default.
         *
         * Remarks: Can be either a texture or a url.
         */
        groundTexture: string | BaseTexture;
        /**
         * The color mixed in the ground texture by default.
         * BabylonJS clearColor by default.
         */
        groundColor: Color3;
        /**
         * Specifies the ground opacity.
         * 1 by default.
         */
        groundOpacity: number;
        /**
         * Enables the ground to receive shadows.
         * True by default.
         */
        enableGroundShadow: boolean;
        /**
         * Helps preventing the shadow to be fully black on the ground.
         * 0.5 by default.
         */
        groundShadowLevel: number;
        /**
         * Creates a mirror texture attach to the ground.
         * false by default.
         */
        enableGroundMirror: boolean;
        /**
         * Specifies the ground mirror size ratio.
         * 0.3 by default as the default kernel is 64.
         */
        groundMirrorSizeRatio: number;
        /**
         * Specifies the ground mirror blur kernel size.
         * 64 by default.
         */
        groundMirrorBlurKernel: number;
        /**
         * Specifies the ground mirror visibility amount.
         * 1 by default
         */
        groundMirrorAmount: number;
        /**
         * Specifies the ground mirror reflectance weight.
         * This uses the standard weight of the background material to setup the fresnel effect
         * of the mirror.
         * 1 by default.
         */
        groundMirrorFresnelWeight: number;
        /**
         * Specifies the ground mirror Falloff distance.
         * This can helps reducing the size of the reflection.
         * 0 by Default.
         */
        groundMirrorFallOffDistance: number;
        /**
         * Specifies the ground mirror texture type.
         * Unsigned Int by Default.
         */
        groundMirrorTextureType: number;
        /**
         * Specifies a bias applied to the ground vertical position to prevent z-fighyting with
         * the shown objects.
         */
        groundYBias: number;
        /**
         * Specifies wether or not to create a skybox.
         * True by default.
         */
        createSkybox: boolean;
        /**
         * Specifies the skybox size.
         * 20 by default.
         */
        skyboxSize: number;
        /**
         * The texture used on the skybox for the main color.
         * Comes from the BabylonJS CDN by default.
         *
         * Remarks: Can be either a texture or a url.
         */
        skyboxTexture: string | BaseTexture;
        /**
         * The color mixed in the skybox texture by default.
         * BabylonJS clearColor by default.
         */
        skyboxColor: Color3;
        /**
         * The background rotation around the Y axis of the scene.
         * This helps aligning the key lights of your scene with the background.
         * 0 by default.
         */
        backgroundYRotation: number;
        /**
         * Compute automatically the size of the elements to best fit with the scene.
         */
        sizeAuto: boolean;
        /**
         * Default position of the rootMesh if autoSize is not true.
         */
        rootPosition: Vector3;
        /**
         * Sets up the image processing in the scene.
         * true by default.
         */
        setupImageProcessing: boolean;
        /**
         * The texture used as your environment texture in the scene.
         * Comes from the BabylonJS CDN by default and in use if setupImageProcessing is true.
         *
         * Remarks: Can be either a texture or a url.
         */
        environmentTexture: string | BaseTexture;
        /**
         * The value of the exposure to apply to the scene.
         * 0.6 by default if setupImageProcessing is true.
         */
        cameraExposure: number;
        /**
         * The value of the contrast to apply to the scene.
         * 1.6 by default if setupImageProcessing is true.
         */
        cameraContrast: number;
        /**
         * Specifies wether or not tonemapping should be enabled in the scene.
         * true by default if setupImageProcessing is true.
         */
        toneMappingEnabled: boolean;
    }
    /**
     * The Environment helper class can be used to add a fully featuread none expensive background to your scene.
     * It includes by default a skybox and a ground relying on the BackgroundMaterial.
     * It also helps with the default setup of your imageProcessing configuration.
     */
    class EnvironmentHelper {
        /**
         * Default ground texture URL.
         */
        private static _groundTextureCDNUrl;
        /**
         * Default skybox texture URL.
         */
        private static _skyboxTextureCDNUrl;
        /**
         * Default environment texture URL.
         */
        private static _environmentTextureCDNUrl;
        /**
         * Creates the default options for the helper.
         */
        private static _getDefaultOptions();
        private _rootMesh;
        /**
         * Gets the root mesh created by the helper.
         */
        readonly rootMesh: Mesh;
        private _skybox;
        /**
         * Gets the skybox created by the helper.
         */
        readonly skybox: Nullable<Mesh>;
        private _skyboxTexture;
        /**
         * Gets the skybox texture created by the helper.
         */
        readonly skyboxTexture: Nullable<BaseTexture>;
        private _skyboxMaterial;
        /**
         * Gets the skybox material created by the helper.
         */
        readonly skyboxMaterial: Nullable<BackgroundMaterial>;
        private _ground;
        /**
         * Gets the ground mesh created by the helper.
         */
        readonly ground: Nullable<Mesh>;
        private _groundTexture;
        /**
         * Gets the ground texture created by the helper.
         */
        readonly groundTexture: Nullable<BaseTexture>;
        private _groundMirror;
        /**
         * Gets the ground mirror created by the helper.
         */
        readonly groundMirror: Nullable<MirrorTexture>;
        /**
         * Gets the ground mirror render list to helps pushing the meshes
         * you wish in the ground reflection.
         */
        readonly groundMirrorRenderList: Nullable<AbstractMesh[]>;
        private _groundMaterial;
        /**
         * Gets the ground material created by the helper.
         */
        readonly groundMaterial: Nullable<BackgroundMaterial>;
        /**
         * Stores the creation options.
         */
        private readonly _scene;
        private _options;
        /**
         * This observable will be notified with any error during the creation of the environment,
         * mainly texture creation errors.
         */
        onErrorObservable: Observable<{
            message?: string;
            exception?: any;
        }>;
        /**
         * constructor
         * @param options
         * @param scene The scene to add the material to
         */
        constructor(options: Partial<IEnvironmentHelperOptions>, scene: Scene);
        /**
         * Updates the background according to the new options
         * @param options
         */
        updateOptions(options: Partial<IEnvironmentHelperOptions>): void;
        /**
         * Sets the primary color of all the available elements.
         * @param color the main color to affect to the ground and the background
         */
        setMainColor(color: Color3): void;
        /**
         * Setup the image processing according to the specified options.
         */
        private _setupImageProcessing();
        /**
         * Setup the environment texture according to the specified options.
         */
        private _setupEnvironmentTexture();
        /**
         * Setup the background according to the specified options.
         */
        private _setupBackground();
        /**
         * Get the scene sizes according to the setup.
         */
        private _getSceneSize();
        /**
         * Setup the ground according to the specified options.
         */
        private _setupGround(sceneSize);
        /**
         * Setup the ground material according to the specified options.
         */
        private _setupGroundMaterial();
        /**
         * Setup the ground diffuse texture according to the specified options.
         */
        private _setupGroundDiffuseTexture();
        /**
         * Setup the ground mirror texture according to the specified options.
         */
        private _setupGroundMirrorTexture(sceneSize);
        /**
         * Setup the ground to receive the mirror texture.
         */
        private _setupMirrorInGroundMaterial();
        /**
         * Setup the skybox according to the specified options.
         */
        private _setupSkybox(sceneSize);
        /**
         * Setup the skybox material according to the specified options.
         */
        private _setupSkyboxMaterial();
        /**
         * Setup the skybox reflection texture according to the specified options.
         */
        private _setupSkyboxReflectionTexture();
        private _errorHandler;
        /**
         * Dispose all the elements created by the Helper.
         */
        dispose(): void;
    }
}

declare module BABYLON {
    /**
     * Display a 360 degree video on an approximately spherical surface, useful for VR applications or skyboxes.
     * As a subclass of Node, this allow parenting to the camera or multiple videos with different locations in the scene.
     * This class achieves its effect with a VideoTexture and a correctly configured BackgroundMaterial on an inverted sphere.
     * Potential additions to this helper include zoom and and non-infinite distance rendering effects.
     */
    class VideoDome extends Node {
        /**
         * The video texture being displayed on the sphere
         */
        protected _videoTexture: VideoTexture;
        /**
         * The skybox material
         */
        protected _material: BackgroundMaterial;
        /**
         * The surface used for the skybox
         */
        protected _mesh: Mesh;
        /**
         * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values "zoom in" and higher values "zoom out".
         * Also see the options.resolution property.
         */
        fovMultiplier: number;
        /**
         * Create an instance of this class and pass through the parameters to the relevant classes, VideoTexture, StandardMaterial, and Mesh.
         * @param name Element's name, child elements will append suffixes for their own names.
         * @param urlsOrVideo
         * @param options An object containing optional or exposed sub element properties:
         * @param options **resolution=12** Integer, lower resolutions have more artifacts at extreme fovs
         * @param options **clickToPlay=false** Add a click to play listener to the video, does not prevent autoplay.
         * @param options **autoPlay=true** Automatically attempt to being playing the video.
         * @param options **loop=true** Automatically loop video on end.
         * @param options **size=1000** Physical radius to create the dome at, defaults to approximately half the far clip plane.
         */
        constructor(name: string, urlsOrVideo: string | string[] | HTMLVideoElement, options: {
            resolution?: number;
            clickToPlay?: boolean;
            autoPlay?: boolean;
            loop?: boolean;
            size?: number;
        }, scene: Scene);
        /**
         * Releases resources associated with this node.
         * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
         * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
         */
        dispose(doNotRecurse?: boolean, disposeMaterialAndTextures?: boolean): void;
    }
}

declare module BABYLON {
    /**
     * This class can be used to get instrumentation data from a Babylon engine
     */
    class EngineInstrumentation implements IDisposable {
        engine: Engine;
        private _captureGPUFrameTime;
        private _gpuFrameTimeToken;
        private _gpuFrameTime;
        private _captureShaderCompilationTime;
        private _shaderCompilationTime;
        private _onBeginFrameObserver;
        private _onEndFrameObserver;
        private _onBeforeShaderCompilationObserver;
        private _onAfterShaderCompilationObserver;
        /**
         * Gets the perf counter used for GPU frame time
         */
        readonly gpuFrameTimeCounter: PerfCounter;
        /**
         * Gets the GPU frame time capture status
         */
        /**
         * Enable or disable the GPU frame time capture
         */
        captureGPUFrameTime: boolean;
        /**
         * Gets the perf counter used for shader compilation time
         */
        readonly shaderCompilationTimeCounter: PerfCounter;
        /**
         * Gets the shader compilation time capture status
         */
        /**
         * Enable or disable the shader compilation time capture
         */
        captureShaderCompilationTime: boolean;
        constructor(engine: Engine);
        dispose(): void;
    }
}

declare module BABYLON {
    /**
     * This class can be used to get instrumentation data from a Babylon engine
     */
    class SceneInstrumentation implements IDisposable {
        scene: Scene;
        private _captureActiveMeshesEvaluationTime;
        private _activeMeshesEvaluationTime;
        private _captureRenderTargetsRenderTime;
        private _renderTargetsRenderTime;
        private _captureFrameTime;
        private _frameTime;
        private _captureRenderTime;
        private _renderTime;
        private _captureInterFrameTime;
        private _interFrameTime;
        private _captureParticlesRenderTime;
        private _particlesRenderTime;
        private _captureSpritesRenderTime;
        private _spritesRenderTime;
        private _capturePhysicsTime;
        private _physicsTime;
        private _captureAnimationsTime;
        private _animationsTime;
        private _onBeforeActiveMeshesEvaluationObserver;
        private _onAfterActiveMeshesEvaluationObserver;
        private _onBeforeRenderTargetsRenderObserver;
        private _onAfterRenderTargetsRenderObserver;
        private _onAfterRenderObserver;
        private _onBeforeDrawPhaseObserver;
        private _onAfterDrawPhaseObserver;
        private _onBeforeAnimationsObserver;
        private _onBeforeParticlesRenderingObserver;
        private _onAfterParticlesRenderingObserver;
        private _onBeforeSpritesRenderingObserver;
        private _onAfterSpritesRenderingObserver;
        private _onBeforePhysicsObserver;
        private _onAfterPhysicsObserver;
        private _onAfterAnimationsObserver;
        /**
         * Gets the perf counter used for active meshes evaluation time
         */
        readonly activeMeshesEvaluationTimeCounter: PerfCounter;
        /**
         * Gets the active meshes evaluation time capture status
         */
        /**
         * Enable or disable the active meshes evaluation time capture
         */
        captureActiveMeshesEvaluationTime: boolean;
        /**
         * Gets the perf counter used for render targets render time
         */
        readonly renderTargetsRenderTimeCounter: PerfCounter;
        /**
         * Gets the render targets render time capture status
         */
        /**
         * Enable or disable the render targets render time capture
         */
        captureRenderTargetsRenderTime: boolean;
        /**
         * Gets the perf counter used for particles render time
         */
        readonly particlesRenderTimeCounter: PerfCounter;
        /**
         * Gets the particles render time capture status
         */
        /**
         * Enable or disable the particles render time capture
         */
        captureParticlesRenderTime: boolean;
        /**
         * Gets the perf counter used for sprites render time
         */
        readonly spritesRenderTimeCounter: PerfCounter;
        /**
         * Gets the sprites render time capture status
         */
        /**
         * Enable or disable the sprites render time capture
         */
        captureSpritesRenderTime: boolean;
        /**
         * Gets the perf counter used for physics time
         */
        readonly physicsTimeCounter: PerfCounter;
        /**
         * Gets the physics time capture status
         */
        /**
         * Enable or disable the physics time capture
         */
        capturePhysicsTime: boolean;
        /**
         * Gets the perf counter used for animations time
         */
        readonly animationsTimeCounter: PerfCounter;
        /**
         * Gets the animations time capture status
         */
        /**
         * Enable or disable the animations time capture
         */
        captureAnimationsTime: boolean;
        /**
         * Gets the perf counter used for frame time capture
         */
        readonly frameTimeCounter: PerfCounter;
        /**
         * Gets the frame time capture status
         */
        /**
         * Enable or disable the frame time capture
         */
        captureFrameTime: boolean;
        /**
         * Gets the perf counter used for inter-frames time capture
         */
        readonly interFrameTimeCounter: PerfCounter;
        /**
         * Gets the inter-frames time capture status
         */
        /**
         * Enable or disable the inter-frames time capture
         */
        captureInterFrameTime: boolean;
        /**
         * Gets the perf counter used for render time capture
         */
        readonly renderTimeCounter: PerfCounter;
        /**
         * Gets the render time capture status
         */
        /**
         * Enable or disable the render time capture
         */
        captureRenderTime: boolean;
        /**
         * Gets the perf counter used for draw calls
         */
        readonly drawCallsCounter: PerfCounter;
        /**
         * Gets the perf counter used for texture collisions
         */
        readonly textureCollisionsCounter: PerfCounter;
        constructor(scene: Scene);
        dispose(): void;
    }
}

declare module BABYLON {
    /**
     * @hidden
     **/
    class _TimeToken {
        _startTimeQuery: Nullable<WebGLQuery>;
        _endTimeQuery: Nullable<WebGLQuery>;
        _timeElapsedQuery: Nullable<WebGLQuery>;
        _timeElapsedQueryEnded: boolean;
    }
}

declare module BABYLON {
    /**
     * Effect layer options. This helps customizing the behaviour
     * of the effect layer.
     */
    interface IEffectLayerOptions {
        /**
         * Multiplication factor apply to the canvas size to compute the render target size
         * used to generated the objects (the smaller the faster).
         */
        mainTextureRatio: number;
        /**
         * Enforces a fixed size texture to ensure effect stability across devices.
         */
        mainTextureFixedSize?: number;
        /**
         * Alpha blending mode used to apply the blur. Default depends of the implementation.
         */
        alphaBlendingMode: number;
        /**
         * The camera attached to the layer.
         */
        camera: Nullable<Camera>;
    }
    /**
     * The effect layer Helps adding post process effect blended with the main pass.
     *
     * This can be for instance use to generate glow or higlight effects on the scene.
     *
     * The effect layer class can not be used directly and is intented to inherited from to be
     * customized per effects.
     */
    abstract class EffectLayer {
        private _vertexBuffers;
        private _indexBuffer;
        private _cachedDefines;
        private _effectLayerMapGenerationEffect;
        private _effectLayerOptions;
        private _mergeEffect;
        protected _scene: Scene;
        protected _engine: Engine;
        protected _maxSize: number;
        protected _mainTextureDesiredSize: ISize;
        protected _mainTexture: RenderTargetTexture;
        protected _shouldRender: boolean;
        protected _postProcesses: PostProcess[];
        protected _textures: BaseTexture[];
        protected _emissiveTextureAndColor: {
            texture: Nullable<BaseTexture>;
            color: Color4;
        };
        /**
         * The name of the layer
         */
        name: string;
        /**
         * The clear color of the texture used to generate the glow map.
         */
        neutralColor: Color4;
        /**
         * Specifies wether the highlight layer is enabled or not.
         */
        isEnabled: boolean;
        /**
         * Gets the camera attached to the layer.
         */
        readonly camera: Nullable<Camera>;
        /**
         * An event triggered when the effect layer has been disposed.
         */
        onDisposeObservable: Observable<EffectLayer>;
        /**
         * An event triggered when the effect layer is about rendering the main texture with the glowy parts.
         */
        onBeforeRenderMainTextureObservable: Observable<EffectLayer>;
        /**
         * An event triggered when the generated texture is being merged in the scene.
         */
        onBeforeComposeObservable: Observable<EffectLayer>;
        /**
         * An event triggered when the generated texture has been merged in the scene.
         */
        onAfterComposeObservable: Observable<EffectLayer>;
        /**
         * An event triggered when the efffect layer changes its size.
         */
        onSizeChangedObservable: Observable<EffectLayer>;
        /**
         * Instantiates a new effect Layer and references it in the scene.
         * @param name The name of the layer
         * @param scene The scene to use the layer in
         */
        constructor(
            /** The Friendly of the effect in the scene */
            name: string, scene: Scene);
        /**
         * Get the effect name of the layer.
         * @return The effect name
         */
        abstract getEffectName(): string;
        /**
         * Checks for the readiness of the element composing the layer.
         * @param subMesh the mesh to check for
         * @param useInstances specify wether or not to use instances to render the mesh
         * @return true if ready otherwise, false
         */
        abstract isReady(subMesh: SubMesh, useInstances: boolean): boolean;
        /**
         * Returns wether or nood the layer needs stencil enabled during the mesh rendering.
         * @returns true if the effect requires stencil during the main canvas render pass.
         */
        abstract needStencil(): boolean;
        /**
         * Create the merge effect. This is the shader use to blit the information back
         * to the main canvas at the end of the scene rendering.
         * @returns The effect containing the shader used to merge the effect on the  main canvas
         */
        protected abstract _createMergeEffect(): Effect;
        /**
         * Creates the render target textures and post processes used in the effect layer.
         */
        protected abstract _createTextureAndPostProcesses(): void;
        /**
         * Implementation specific of rendering the generating effect on the main canvas.
         * @param effect The effect used to render through
         */
        protected abstract _internalRender(effect: Effect): void;
        /**
         * Sets the required values for both the emissive texture and and the main color.
         */
        protected abstract _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void;
        /**
         * Free any resources and references associated to a mesh.
         * Internal use
         * @param mesh The mesh to free.
         */
        abstract _disposeMesh(mesh: Mesh): void;
        /**
         * Serializes this layer (Glow or Highlight for example)
         * @returns a serialized layer object
         */
        abstract serialize?(): any;
        /**
         * Initializes the effect layer with the required options.
         * @param options Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)
         */
        protected _init(options: Partial<IEffectLayerOptions>): void;
        /**
         * Generates the index buffer of the full screen quad blending to the main canvas.
         */
        private _generateIndexBuffer();
        /**
         * Generates the vertex buffer of the full screen quad blending to the main canvas.
         */
        private _genrateVertexBuffer();
        /**
         * Sets the main texture desired size which is the closest power of two
         * of the engine canvas size.
         */
        private _setMainTextureSize();
        /**
         * Creates the main texture for the effect layer.
         */
        protected _createMainTexture(): void;
        /**
         * Checks for the readiness of the element composing the layer.
         * @param subMesh the mesh to check for
         * @param useInstances specify wether or not to use instances to render the mesh
         * @param emissiveTexture the associated emissive texture used to generate the glow
         * @return true if ready otherwise, false
         */
        protected _isReady(subMesh: SubMesh, useInstances: boolean, emissiveTexture: Nullable<BaseTexture>): boolean;
        /**
         * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.
         */
        render(): void;
        /**
         * Determine if a given mesh will be used in the current effect.
         * @param mesh mesh to test
         * @returns true if the mesh will be used
         */
        hasMesh(mesh: AbstractMesh): boolean;
        /**
         * Returns true if the layer contains information to display, otherwise false.
         * @returns true if the glow layer should be rendered
         */
        shouldRender(): boolean;
        /**
         * Returns true if the mesh should render, otherwise false.
         * @param mesh The mesh to render
         * @returns true if it should render otherwise false
         */
        protected _shouldRenderMesh(mesh: Mesh): boolean;
        /**
         * Returns true if the mesh should render, otherwise false.
         * @param mesh The mesh to render
         * @returns true if it should render otherwise false
         */
        protected _shouldRenderEmissiveTextureForMesh(mesh: Mesh): boolean;
        /**
         * Renders the submesh passed in parameter to the generation map.
         */
        protected _renderSubMesh(subMesh: SubMesh): void;
        /**
         * Rebuild the required buffers.
         * @hidden Internal use only.
         */
        _rebuild(): void;
        /**
         * Dispose only the render target textures and post process.
         */
        private _disposeTextureAndPostProcesses();
        /**
         * Dispose the highlight layer and free resources.
         */
        dispose(): void;
        /**
          * Gets the class name of the effect layer
          * @returns the string with the class name of the effect layer
          */
        getClassName(): string;
        /**
         * Creates an effect layer from parsed effect layer data
         * @param parsedEffectLayer defines effect layer data
         * @param scene defines the current scene
         * @param rootUrl defines the root URL containing the effect layer information
         * @returns a parsed effect Layer
         */
        static Parse(parsedEffectLayer: any, scene: Scene, rootUrl: string): EffectLayer;
    }
}

declare module BABYLON {
    /**
     * Glow layer options. This helps customizing the behaviour
     * of the glow layer.
     */
    interface IGlowLayerOptions {
        /**
         * Multiplication factor apply to the canvas size to compute the render target size
         * used to generated the glowing objects (the smaller the faster).
         */
        mainTextureRatio: number;
        /**
         * Enforces a fixed size texture to ensure resize independant blur.
         */
        mainTextureFixedSize?: number;
        /**
         * How big is the kernel of the blur texture.
         */
        blurKernelSize: number;
        /**
         * The camera attached to the layer.
         */
        camera: Nullable<Camera>;
        /**
         * Enable MSAA by chosing the number of samples.
         */
        mainTextureSamples?: number;
    }
    /**
     * The glow layer Helps adding a glow effect around the emissive parts of a mesh.
     *
     * Once instantiated in a scene, simply use the pushMesh or removeMesh method to add or remove
     * glowy meshes to your scene.
     *
     * Documentation: https://doc.babylonjs.com/how_to/glow_layer
     */
    class GlowLayer extends EffectLayer {
        /**
         * Effect Name of the layer.
         */
        static readonly EffectName: string;
        /**
         * The default blur kernel size used for the glow.
         */
        static DefaultBlurKernelSize: number;
        /**
         * The default texture size ratio used for the glow.
         */
        static DefaultTextureRatio: number;
        /**
         * Gets the kernel size of the blur.
         */
        /**
         * Sets the kernel size of the blur.
         */
        blurKernelSize: number;
        /**
         * Gets the glow intensity.
         */
        /**
         * Sets the glow intensity.
         */
        intensity: number;
        private _options;
        private _intensity;
        private _horizontalBlurPostprocess1;
        private _verticalBlurPostprocess1;
        private _horizontalBlurPostprocess2;
        private _verticalBlurPostprocess2;
        private _blurTexture1;
        private _blurTexture2;
        private _postProcesses1;
        private _postProcesses2;
        private _includedOnlyMeshes;
        private _excludedMeshes;
        /**
         * Callback used to let the user override the color selection on a per mesh basis
         */
        customEmissiveColorSelector: (mesh: Mesh, subMesh: SubMesh, material: Material, result: Color4) => void;
        /**
         * Callback used to let the user override the texture selection on a per mesh basis
         */
        customEmissiveTextureSelector: (mesh: Mesh, subMesh: SubMesh, material: Material) => Texture;
        /**
         * Instantiates a new glow Layer and references it to the scene.
         * @param name The name of the layer
         * @param scene The scene to use the layer in
         * @param options Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)
         */
        constructor(name: string, scene: Scene, options?: Partial<IGlowLayerOptions>);
        /**
         * Get the effect name of the layer.
         * @return The effect name
         */
        getEffectName(): string;
        /**
         * Create the merge effect. This is the shader use to blit the information back
         * to the main canvas at the end of the scene rendering.
         */
        protected _createMergeEffect(): Effect;
        /**
         * Creates the render target textures and post processes used in the glow layer.
         */
        protected _createTextureAndPostProcesses(): void;
        /**
         * Checks for the readiness of the element composing the layer.
         * @param subMesh the mesh to check for
         * @param useInstances specify wether or not to use instances to render the mesh
         * @param emissiveTexture the associated emissive texture used to generate the glow
         * @return true if ready otherwise, false
         */
        isReady(subMesh: SubMesh, useInstances: boolean): boolean;
        /**
         * Returns wether or nood the layer needs stencil enabled during the mesh rendering.
         */
        needStencil(): boolean;
        /**
         * Implementation specific of rendering the generating effect on the main canvas.
         * @param effect The effect used to render through
         */
        protected _internalRender(effect: Effect): void;
        /**
         * Sets the required values for both the emissive texture and and the main color.
         */
        protected _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void;
        /**
         * Returns true if the mesh should render, otherwise false.
         * @param mesh The mesh to render
         * @returns true if it should render otherwise false
         */
        protected _shouldRenderMesh(mesh: Mesh): boolean;
        /**
         * Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.
         * @param mesh The mesh to exclude from the glow layer
         */
        addExcludedMesh(mesh: Mesh): void;
        /**
          * Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.
          * @param mesh The mesh to remove
          */
        removeExcludedMesh(mesh: Mesh): void;
        /**
         * Add a mesh in the inclusion list to impact or being impacted by the glow layer.
         * @param mesh The mesh to include in the glow layer
         */
        addIncludedOnlyMesh(mesh: Mesh): void;
        /**
          * Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.
          * @param mesh The mesh to remove
          */
        removeIncludedOnlyMesh(mesh: Mesh): void;
        /**
         * Determine if a given mesh will be used in the glow layer
         * @param mesh The mesh to test
         * @returns true if the mesh will be highlighted by the current glow layer
         */
        hasMesh(mesh: AbstractMesh): boolean;
        /**
         * Free any resources and references associated to a mesh.
         * Internal use
         * @param mesh The mesh to free.
         */
        _disposeMesh(mesh: Mesh): void;
        /**
          * Gets the class name of the effect layer
          * @returns the string with the class name of the effect layer
          */
        getClassName(): string;
        /**
         * Serializes this glow layer
         * @returns a serialized glow layer object
         */
        serialize(): any;
        /**
         * Creates a Glow Layer from parsed glow layer data
         * @param parsedGlowLayer defines glow layer data
         * @param scene defines the current scene
         * @param rootUrl defines the root URL containing the glow layer information
         * @returns a parsed Glow Layer
         */
        static Parse(parsedGlowLayer: any, scene: Scene, rootUrl: string): GlowLayer;
    }
}

declare module BABYLON {
    /**
     * Highlight layer options. This helps customizing the behaviour
     * of the highlight layer.
     */
    interface IHighlightLayerOptions {
        /**
         * Multiplication factor apply to the canvas size to compute the render target size
         * used to generated the glowing objects (the smaller the faster).
         */
        mainTextureRatio: number;
        /**
         * Enforces a fixed size texture to ensure resize independant blur.
         */
        mainTextureFixedSize?: number;
        /**
         * Multiplication factor apply to the main texture size in the first step of the blur to reduce the size
         * of the picture to blur (the smaller the faster).
         */
        blurTextureSizeRatio: number;
        /**
         * How big in texel of the blur texture is the vertical blur.
         */
        blurVerticalSize: number;
        /**
         * How big in texel of the blur texture is the horizontal blur.
         */
        blurHorizontalSize: number;
        /**
         * Alpha blending mode used to apply the blur. Default is combine.
         */
        alphaBlendingMode: number;
        /**
         * The camera attached to the layer.
         */
        camera: Nullable<Camera>;
        /**
         * Should we display highlight as a solid stroke?
         */
        isStroke?: boolean;
    }
    /**
     * The highlight layer Helps adding a glow effect around a mesh.
     *
     * Once instantiated in a scene, simply use the pushMesh or removeMesh method to add or remove
     * glowy meshes to your scene.
     *
     * !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!
     */
    class HighlightLayer extends EffectLayer {
        name: string;
        /**
         * Effect Name of the highlight layer.
         */
        static readonly EffectName: string;
        /**
         * The neutral color used during the preparation of the glow effect.
         * This is black by default as the blend operation is a blend operation.
         */
        static NeutralColor: Color4;
        /**
         * Stencil value used for glowing meshes.
         */
        static GlowingMeshStencilReference: number;
        /**
         * Stencil value used for the other meshes in the scene.
         */
        static NormalMeshStencilReference: number;
        /**
         * Specifies whether or not the inner glow is ACTIVE in the layer.
         */
        innerGlow: boolean;
        /**
         * Specifies whether or not the outer glow is ACTIVE in the layer.
         */
        outerGlow: boolean;
        /**
         * Gets the horizontal size of the blur.
         */
        /**
         * Specifies the horizontal size of the blur.
         */
        blurHorizontalSize: number;
        /**
         * Gets the vertical size of the blur.
         */
        /**
         * Specifies the vertical size of the blur.
         */
        blurVerticalSize: number;
        /**
         * An event triggered when the highlight layer is being blurred.
         */
        onBeforeBlurObservable: Observable<HighlightLayer>;
        /**
         * An event triggered when the highlight layer has been blurred.
         */
        onAfterBlurObservable: Observable<HighlightLayer>;
        private _instanceGlowingMeshStencilReference;
        private _options;
        private _downSamplePostprocess;
        private _horizontalBlurPostprocess;
        private _verticalBlurPostprocess;
        private _blurTexture;
        private _meshes;
        private _excludedMeshes;
        /**
         * Instantiates a new highlight Layer and references it to the scene..
         * @param name The name of the layer
         * @param scene The scene to use the layer in
         * @param options Sets of none mandatory options to use with the layer (see IHighlightLayerOptions for more information)
         */
        constructor(name: string, scene: Scene, options?: Partial<IHighlightLayerOptions>);
        /**
         * Get the effect name of the layer.
         * @return The effect name
         */
        getEffectName(): string;
        /**
         * Create the merge effect. This is the shader use to blit the information back
         * to the main canvas at the end of the scene rendering.
         */
        protected _createMergeEffect(): Effect;
        /**
         * Creates the render target textures and post processes used in the highlight layer.
         */
        protected _createTextureAndPostProcesses(): void;
        /**
         * Returns wether or nood the layer needs stencil enabled during the mesh rendering.
         */
        needStencil(): boolean;
        /**
         * Checks for the readiness of the element composing the layer.
         * @param subMesh the mesh to check for
         * @param useInstances specify wether or not to use instances to render the mesh
         * @param emissiveTexture the associated emissive texture used to generate the glow
         * @return true if ready otherwise, false
         */
        isReady(subMesh: SubMesh, useInstances: boolean): boolean;
        /**
         * Implementation specific of rendering the generating effect on the main canvas.
         * @param effect The effect used to render through
         */
        protected _internalRender(effect: Effect): void;
        /**
         * Returns true if the layer contains information to display, otherwise false.
         */
        shouldRender(): boolean;
        /**
         * Returns true if the mesh should render, otherwise false.
         * @param mesh The mesh to render
         * @returns true if it should render otherwise false
         */
        protected _shouldRenderMesh(mesh: Mesh): boolean;
        /**
         * Sets the required values for both the emissive texture and and the main color.
         */
        protected _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void;
        /**
         * Add a mesh in the exclusion list to prevent it to impact or being impacted by the highlight layer.
         * @param mesh The mesh to exclude from the highlight layer
         */
        addExcludedMesh(mesh: Mesh): void;
        /**
          * Remove a mesh from the exclusion list to let it impact or being impacted by the highlight layer.
          * @param mesh The mesh to highlight
          */
        removeExcludedMesh(mesh: Mesh): void;
        /**
         * Determine if a given mesh will be highlighted by the current HighlightLayer
         * @param mesh mesh to test
         * @returns true if the mesh will be highlighted by the current HighlightLayer
         */
        hasMesh(mesh: AbstractMesh): boolean;
        /**
         * Add a mesh in the highlight layer in order to make it glow with the chosen color.
         * @param mesh The mesh to highlight
         * @param color The color of the highlight
         * @param glowEmissiveOnly Extract the glow from the emissive texture
         */
        addMesh(mesh: Mesh, color: Color3, glowEmissiveOnly?: boolean): void;
        /**
         * Remove a mesh from the highlight layer in order to make it stop glowing.
         * @param mesh The mesh to highlight
         */
        removeMesh(mesh: Mesh): void;
        /**
         * Force the stencil to the normal expected value for none glowing parts
         */
        private _defaultStencilReference(mesh);
        /**
         * Free any resources and references associated to a mesh.
         * Internal use
         * @param mesh The mesh to free.
         */
        _disposeMesh(mesh: Mesh): void;
        /**
         * Dispose the highlight layer and free resources.
         */
        dispose(): void;
        /**
          * Gets the class name of the effect layer
          * @returns the string with the class name of the effect layer
          */
        getClassName(): string;
        /**
         * Serializes this Highlight layer
         * @returns a serialized Highlight layer object
         */
        serialize(): any;
        /**
         * Creates a Highlight layer from parsed Highlight layer data
         * @param parsedHightlightLayer defines the Highlight layer data
         * @param scene defines the current scene
         * @param rootUrl defines the root URL containing the Highlight layer information
         * @returns a parsed Highlight layer
         */
        static Parse(parsedHightlightLayer: any, scene: Scene, rootUrl: string): HighlightLayer;
    }
}

declare module BABYLON {
    class Layer {
        name: string;
        texture: Nullable<Texture>;
        isBackground: boolean;
        color: Color4;
        scale: Vector2;
        offset: Vector2;
        alphaBlendingMode: number;
        alphaTest: boolean;
        layerMask: number;
        private _scene;
        private _vertexBuffers;
        private _indexBuffer;
        private _effect;
        private _alphaTestEffect;
        /**
        * An event triggered when the layer is disposed.
        */
        onDisposeObservable: Observable<Layer>;
        private _onDisposeObserver;
        onDispose: () => void;
        /**
        * An event triggered before rendering the scene
        */
        onBeforeRenderObservable: Observable<Layer>;
        private _onBeforeRenderObserver;
        onBeforeRender: () => void;
        /**
        * An event triggered after rendering the scene
        */
        onAfterRenderObservable: Observable<Layer>;
        private _onAfterRenderObserver;
        onAfterRender: () => void;
        constructor(name: string, imgUrl: Nullable<string>, scene: Nullable<Scene>, isBackground?: boolean, color?: Color4);
        private _createIndexBuffer();
        _rebuild(): void;
        render(): void;
        dispose(): void;
    }
}

declare module BABYLON {
    class LensFlare {
        size: number;
        position: number;
        color: Color3;
        texture: Nullable<Texture>;
        alphaMode: number;
        private _system;
        static AddFlare(size: number, position: number, color: Color3, imgUrl: string, system: LensFlareSystem): LensFlare;
        constructor(size: number, position: number, color: Color3, imgUrl: string, system: LensFlareSystem);
        dispose(): void;
    }
}

declare module BABYLON {
    class LensFlareSystem {
        name: string;
        lensFlares: LensFlare[];
        borderLimit: number;
        viewportBorder: number;
        meshesSelectionPredicate: (mesh: AbstractMesh) => boolean;
        layerMask: number;
        id: string;
        private _scene;
        private _emitter;
        private _vertexBuffers;
        private _indexBuffer;
        private _effect;
        private _positionX;
        private _positionY;
        private _isEnabled;
        constructor(name: string, emitter: any, scene: Scene);
        isEnabled: boolean;
        getScene(): Scene;
        getEmitter(): any;
        setEmitter(newEmitter: any): void;
        getEmitterPosition(): Vector3;
        computeEffectivePosition(globalViewport: Viewport): boolean;
        _isVisible(): boolean;
        render(): boolean;
        dispose(): void;
        static Parse(parsedLensFlareSystem: any, scene: Scene, rootUrl: string): LensFlareSystem;
        serialize(): any;
    }
}

declare module BABYLON {
    /**
     * A directional light is defined by a direction (what a surprise!).
     * The light is emitted from everywhere in the specified direction, and has an infinite range.
     * An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.
     * Documentation: https://doc.babylonjs.com/babylon101/lights
     */
    class DirectionalLight extends ShadowLight {
        private _shadowFrustumSize;
        /**
         * Fix frustum size for the shadow generation. This is disabled if the value is 0.
         */
        /**
         * Specifies a fix frustum size for the shadow generation.
         */
        shadowFrustumSize: number;
        private _shadowOrthoScale;
        /**
         * Gets the shadow projection scale against the optimal computed one.
         * 0.1 by default which means that the projection window is increase by 10% from the optimal size.
         * This does not impact in fixed frustum size (shadowFrustumSize being set)
         */
        /**
         * Sets the shadow projection scale against the optimal computed one.
         * 0.1 by default which means that the projection window is increase by 10% from the optimal size.
         * This does not impact in fixed frustum size (shadowFrustumSize being set)
         */
        shadowOrthoScale: number;
        /**
         * Automatically compute the projection matrix to best fit (including all the casters)
         * on each frame.
         */
        autoUpdateExtends: boolean;
        private _orthoLeft;
        private _orthoRight;
        private _orthoTop;
        private _orthoBottom;
        /**
         * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).
         * The directional light is emitted from everywhere in the given direction.
         * It can cast shawdows.
         * Documentation : http://doc.babylonjs.com/tutorials/lights
         * @param name The friendly name of the light
         * @param direction The direction of the light
         * @param scene The scene the light belongs to
         */
        constructor(name: string, direction: Vector3, scene: Scene);
        /**
         * Returns the string "DirectionalLight".
         * @return The class name
         */
        getClassName(): string;
        /**
         * Returns the integer 1.
         * @return The light Type id as a constant defines in Light.LIGHTTYPEID_x
         */
        getTypeID(): number;
        /**
         * Sets the passed matrix "matrix" as projection matrix for the shadows cast by the light according to the passed view matrix.
         * Returns the DirectionalLight Shadow projection matrix.
         */
        protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void;
        /**
         * Sets the passed matrix "matrix" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.
         * Returns the DirectionalLight Shadow projection matrix.
         */
        protected _setDefaultFixedFrustumShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix): void;
        /**
         * Sets the passed matrix "matrix" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.
         * Returns the DirectionalLight Shadow projection matrix.
         */
        protected _setDefaultAutoExtendShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void;
        protected _buildUniformLayout(): void;
        /**
         * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.
         * @param effect The effect to update
         * @param lightIndex The index of the light in the effect to update
         * @returns The directional light
         */
        transferToEffect(effect: Effect, lightIndex: string): DirectionalLight;
        /**
         * Gets the minZ used for shadow according to both the scene and the light.
         *
         * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
         * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.
         * @param activeCamera The camera we are returning the min for
         * @returns the depth min z
         */
        getDepthMinZ(activeCamera: Camera): number;
        /**
         * Gets the maxZ used for shadow according to both the scene and the light.
         *
         * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
         * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.
         * @param activeCamera The camera we are returning the max for
         * @returns the depth max z
         */
        getDepthMaxZ(activeCamera: Camera): number;
    }
}

declare module BABYLON {
    /**
     * The HemisphericLight simulates the ambient environment light,
     * so the passed direction is the light reflection direction, not the incoming direction.
     */
    class HemisphericLight extends Light {
        /**
         * The groundColor is the light in the opposite direction to the one specified during creation.
         * You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.
         */
        groundColor: Color3;
        /**
         * The light reflection direction, not the incoming direction.
         */
        direction: Vector3;
        private _worldMatrix;
        /**
         * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).
         * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.
         * The HemisphericLight can't cast shadows.
         * Documentation : http://doc.babylonjs.com/tutorials/lights
         * @param name The friendly name of the light
         * @param direction The direction of the light reflection
         * @param scene The scene the light belongs to
         */
        constructor(name: string, direction: Vector3, scene: Scene);
        protected _buildUniformLayout(): void;
        /**
         * Returns the string "HemisphericLight".
         * @return The class name
         */
        getClassName(): string;
        /**
         * Sets the HemisphericLight direction towards the passed target (Vector3).
         * Returns the updated direction.
         * @param target The target the direction should point to
         * @return The computed direction
         */
        setDirectionToTarget(target: Vector3): Vector3;
        /**
         * Returns the shadow generator associated to the light.
         * @returns Always null for hemispheric lights because it does not support shadows.
         */
        getShadowGenerator(): Nullable<ShadowGenerator>;
        /**
         * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).
         * @param effect The effect to update
         * @param lightIndex The index of the light in the effect to update
         * @returns The hemispheric light
         */
        transferToEffect(effect: Effect, lightIndex: string): HemisphericLight;
        /**
         * @hidden internal use only.
         */
        _getWorldMatrix(): Matrix;
        /**
         * Returns the integer 3.
         * @return The light Type id as a constant defines in Light.LIGHTTYPEID_x
         */
        getTypeID(): number;
    }
}

declare module BABYLON {
    /**
     * Base class of all the lights in Babylon. It groups all the generic information about lights.
     * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.
     * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.
     */
    abstract class Light extends Node {
        private static _LIGHTMAP_DEFAULT;
        private static _LIGHTMAP_SPECULAR;
        private static _LIGHTMAP_SHADOWSONLY;
        /**
         * If every light affecting the material is in this lightmapMode,
         * material.lightmapTexture adds or multiplies
         * (depends on material.useLightmapAsShadowmap)
         * after every other light calculations.
         */
        static readonly LIGHTMAP_DEFAULT: number;
        /**
         * material.lightmapTexture as only diffuse lighting from this light
         * adds only specular lighting from this light
         * adds dynamic shadows
         */
        static readonly LIGHTMAP_SPECULAR: number;
        /**
         * material.lightmapTexture as only lighting
         * no light calculation from this light
         * only adds dynamic shadows from this light
         */
        static readonly LIGHTMAP_SHADOWSONLY: number;
        private static _INTENSITYMODE_AUTOMATIC;
        private static _INTENSITYMODE_LUMINOUSPOWER;
        private static _INTENSITYMODE_LUMINOUSINTENSITY;
        private static _INTENSITYMODE_ILLUMINANCE;
        private static _INTENSITYMODE_LUMINANCE;
        /**
         * Each light type uses the default quantity according to its type:
         *      point/spot lights use luminous intensity
         *      directional lights use illuminance
         */
        static readonly INTENSITYMODE_AUTOMATIC: number;
        /**
         * lumen (lm)
         */
        static readonly INTENSITYMODE_LUMINOUSPOWER: number;
        /**
         * candela (lm/sr)
         */
        static readonly INTENSITYMODE_LUMINOUSINTENSITY: number;
        /**
         * lux (lm/m^2)
         */
        static readonly INTENSITYMODE_ILLUMINANCE: number;
        /**
         * nit (cd/m^2)
         */
        static readonly INTENSITYMODE_LUMINANCE: number;
        private static _LIGHTTYPEID_POINTLIGHT;
        private static _LIGHTTYPEID_DIRECTIONALLIGHT;
        private static _LIGHTTYPEID_SPOTLIGHT;
        private static _LIGHTTYPEID_HEMISPHERICLIGHT;
        /**
         * Light type const id of the point light.
         */
        static readonly LIGHTTYPEID_POINTLIGHT: number;
        /**
         * Light type const id of the directional light.
         */
        static readonly LIGHTTYPEID_DIRECTIONALLIGHT: number;
        /**
         * Light type const id of the spot light.
         */
        static readonly LIGHTTYPEID_SPOTLIGHT: number;
        /**
         * Light type const id of the hemispheric light.
         */
        static readonly LIGHTTYPEID_HEMISPHERICLIGHT: number;
        /**
         * Diffuse gives the basic color to an object.
         */
        diffuse: Color3;
        /**
         * Specular produces a highlight color on an object.
         * Note: This is note affecting PBR materials.
         */
        specular: Color3;
        /**
         * Strength of the light.
         * Note: By default it is define in the framework own unit.
         * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.
         */
        intensity: number;
        /**
         * Defines how far from the source the light is impacting in scene units.
         * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.
         */
        range: number;
        /**
         * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type
         * of light.
         */
        private _photometricScale;
        private _intensityMode;
        /**
         * Gets the photometric scale used to interpret the intensity.
         * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
         */
        /**
         * Sets the photometric scale used to interpret the intensity.
         * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
         */
        intensityMode: number;
        private _radius;
        /**
         * Gets the light radius used by PBR Materials to simulate soft area lights.
         */
        /**
         * sets the light radius used by PBR Materials to simulate soft area lights.
         */
        radius: number;
        private _renderPriority;
        /**
         * Defines the rendering priority of the lights. It can help in case of fallback or number of lights
         * exceeding the number allowed of the materials.
         */
        renderPriority: number;
        /**
         * Defines wether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching
         * the current shadow generator.
         */
        shadowEnabled: boolean;
        private _includedOnlyMeshes;
        /**
         * Gets the only meshes impacted by this light.
         */
        /**
         * Sets the only meshes impacted by this light.
         */
        includedOnlyMeshes: AbstractMesh[];
        private _excludedMeshes;
        /**
         * Gets the meshes not impacted by this light.
         */
        /**
         * Sets the meshes not impacted by this light.
         */
        excludedMeshes: AbstractMesh[];
        private _excludeWithLayerMask;
        /**
         * Gets the layer id use to find what meshes are not impacted by the light.
         * Inactive if 0
         */
        /**
         * Sets the layer id use to find what meshes are not impacted by the light.
         * Inactive if 0
         */
        excludeWithLayerMask: number;
        private _includeOnlyWithLayerMask;
        /**
         * Gets the layer id use to find what meshes are impacted by the light.
         * Inactive if 0
         */
        /**
         * Sets the layer id use to find what meshes are impacted by the light.
         * Inactive if 0
         */
        includeOnlyWithLayerMask: number;
        private _lightmapMode;
        /**
         * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
         */
        /**
         * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
         */
        lightmapMode: number;
        private _parentedWorldMatrix;
        /**
         * Shadow generator associted to the light.
         * Internal use only.
         */
        _shadowGenerator: Nullable<IShadowGenerator>;
        /**
         * @hidden Internal use only.
         */
        _excludedMeshesIds: string[];
        /**
         * @hidden Internal use only.
         */
        _includedOnlyMeshesIds: string[];
        /**
         * The current light unifom buffer.
         * @hidden Internal use only.
         */
        _uniformBuffer: UniformBuffer;
        /**
         * Creates a Light object in the scene.
         * Documentation : http://doc.babylonjs.com/tutorials/lights
         * @param name The firendly name of the light
         * @param scene The scene the light belongs too
         */
        constructor(name: string, scene: Scene);
        protected abstract _buildUniformLayout(): void;
        /**
         * Sets the passed Effect "effect" with the Light information.
         * @param effect The effect to update
         * @param lightIndex The index of the light in the effect to update
         * @returns The light
         */
        abstract transferToEffect(effect: Effect, lightIndex: string): Light;
        /**
         * @hidden internal use only.
         */
        abstract _getWorldMatrix(): Matrix;
        /**
         * Returns the string "Light".
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Converts the light information to a readable string for debug purpose.
         * @param fullDetails Supports for multiple levels of logging within scene loading
         * @returns the human readable light info
         */
        toString(fullDetails?: boolean): string;
        /**
         * Set the enabled state of this node.
         * @param value - the new enabled state
         */
        setEnabled(value: boolean): void;
        /**
         * Returns the Light associated shadow generator if any.
         * @return the associated shadow generator.
         */
        getShadowGenerator(): Nullable<IShadowGenerator>;
        /**
         * Returns a Vector3, the absolute light position in the World.
         * @returns the world space position of the light
         */
        getAbsolutePosition(): Vector3;
        /**
         * Specifies if the light will affect the passed mesh.
         * @param mesh The mesh to test against the light
         * @return true the mesh is affected otherwise, false.
         */
        canAffectMesh(mesh: AbstractMesh): boolean;
        /**
         * Computes and Returns the light World matrix.
         * @returns the world matrix
         */
        getWorldMatrix(): Matrix;
        /**
         * Sort function to order lights for rendering.
         * @param a First Light object to compare to second.
         * @param b Second Light object to compare first.
         * @return -1 to reduce's a's index relative to be, 0 for no change, 1 to increase a's index relative to b.
         */
        static CompareLightsPriority(a: Light, b: Light): number;
        /**
         * Releases resources associated with this node.
         * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
         * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
         */
        dispose(doNotRecurse?: boolean, disposeMaterialAndTextures?: boolean): void;
        /**
         * Returns the light type ID (integer).
         * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
         */
        getTypeID(): number;
        /**
         * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.
         * @returns the scaled intensity in intensity mode unit
         */
        getScaledIntensity(): number;
        /**
         * Returns a new Light object, named "name", from the current one.
         * @param name The name of the cloned light
         * @returns the new created light
         */
        clone(name: string): Nullable<Light>;
        /**
         * Serializes the current light into a Serialization object.
         * @returns the serialized object.
         */
        serialize(): any;
        /**
         * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.
         * This new light is named "name" and added to the passed scene.
         * @param type Type according to the types available in Light.LIGHTTYPEID_x
         * @param name The friendly name of the light
         * @param scene The scene the new light will belong to
         * @returns the constructor function
         */
        static GetConstructorFromName(type: number, name: string, scene: Scene): Nullable<() => Light>;
        /**
         * Parses the passed "parsedLight" and returns a new instanced Light from this parsing.
         * @param parsedLight The JSON representation of the light
         * @param scene The scene to create the parsed light in
         * @returns the created light after parsing
         */
        static Parse(parsedLight: any, scene: Scene): Nullable<Light>;
        private _hookArrayForExcluded(array);
        private _hookArrayForIncludedOnly(array);
        private _resyncMeshes();
        /**
         * Forces the meshes to update their light related information in their rendering used effects
         * @hidden Internal Use Only
         */
        _markMeshesAsLightDirty(): void;
        /**
         * Recomputes the cached photometric scale if needed.
         */
        private _computePhotometricScale();
        /**
         * Returns the Photometric Scale according to the light type and intensity mode.
         */
        private _getPhotometricScale();
        /**
         * Reorder the light in the scene according to their defined priority.
         * @hidden Internal Use Only
         */
        _reorderLightsInScene(): void;
    }
}

declare module BABYLON {
    /**
     * A point light is a light defined by an unique point in world space.
     * The light is emitted in every direction from this point.
     * A good example of a point light is a standard light bulb.
     * Documentation: https://doc.babylonjs.com/babylon101/lights
     */
    class PointLight extends ShadowLight {
        private _shadowAngle;
        /**
         * Getter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
         * This specifies what angle the shadow will use to be created.
         *
         * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.
         */
        /**
         * Setter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
         * This specifies what angle the shadow will use to be created.
         *
         * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.
         */
        shadowAngle: number;
        /**
         * Gets the direction if it has been set.
         * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
         */
        /**
         * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
         */
        direction: Vector3;
        /**
         * Creates a PointLight object from the passed name and position (Vector3) and adds it in the scene.
         * A PointLight emits the light in every direction.
         * It can cast shadows.
         * If the scene camera is already defined and you want to set your PointLight at the camera position, just set it :
         * ```javascript
         * var pointLight = new BABYLON.PointLight("pl", camera.position, scene);
         * ```
         * Documentation : http://doc.babylonjs.com/tutorials/lights
         * @param name The light friendly name
         * @param position The position of the point light in the scene
         * @param scene The scene the lights belongs to
         */
        constructor(name: string, position: Vector3, scene: Scene);
        /**
         * Returns the string "PointLight"
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Returns the integer 0.
         * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
         */
        getTypeID(): number;
        /**
         * Specifies wether or not the shadowmap should be a cube texture.
         * @returns true if the shadowmap needs to be a cube texture.
         */
        needCube(): boolean;
        /**
         * Returns a new Vector3 aligned with the PointLight cube system according to the passed cube face index (integer).
         * @param faceIndex The index of the face we are computed the direction to generate shadow
         * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true
         */
        getShadowDirection(faceIndex?: number): Vector3;
        /**
         * Sets the passed matrix "matrix" as a left-handed perspective projection matrix with the following settings :
         * - fov = PI / 2
         * - aspect ratio : 1.0
         * - z-near and far equal to the active camera minZ and maxZ.
         * Returns the PointLight.
         */
        protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void;
        protected _buildUniformLayout(): void;
        /**
         * Sets the passed Effect "effect" with the PointLight transformed position (or position, if none) and passed name (string).
         * @param effect The effect to update
         * @param lightIndex The index of the light in the effect to update
         * @returns The point light
         */
        transferToEffect(effect: Effect, lightIndex: string): PointLight;
    }
}

declare module BABYLON {
    /**
     * Interface describing all the common properties and methods a shadow light needs to implement.
     * This helps both the shadow generator and materials to genrate the corresponding shadow maps
     * as well as binding the different shadow properties to the effects.
     */
    interface IShadowLight extends Light {
        /**
         * The light id in the scene (used in scene.findLighById for instance)
         */
        id: string;
        /**
         * The position the shdow will be casted from.
         */
        position: Vector3;
        /**
         * In 2d mode (needCube being false), the direction used to cast the shadow.
         */
        direction: Vector3;
        /**
         * The transformed position. Position of the light in world space taking parenting in account.
         */
        transformedPosition: Vector3;
        /**
         * The transformed direction. Direction of the light in world space taking parenting in account.
         */
        transformedDirection: Vector3;
        /**
         * The friendly name of the light in the scene.
         */
        name: string;
        /**
         * Defines the shadow projection clipping minimum z value.
         */
        shadowMinZ: number;
        /**
         * Defines the shadow projection clipping maximum z value.
         */
        shadowMaxZ: number;
        /**
         * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light
         * @returns true if the information has been computed, false if it does not need to (no parenting)
         */
        computeTransformedInformation(): boolean;
        /**
         * Gets the scene the light belongs to.
         * @returns The scene
         */
        getScene(): Scene;
        /**
         * Callback defining a custom Projection Matrix Builder.
         * This can be used to override the default projection matrix computation.
         */
        customProjectionMatrixBuilder: (viewMatrix: Matrix, renderList: Array<AbstractMesh>, result: Matrix) => void;
        /**
         * Sets the shadow projection matrix in parameter to the generated projection matrix.
         * @param matrix The materix to updated with the projection information
         * @param viewMatrix The transform matrix of the light
         * @param renderList The list of mesh to render in the map
         * @returns The current light
         */
        setShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): IShadowLight;
        /**
         * Gets the current depth scale used in ESM.
         * @returns The scale
         */
        getDepthScale(): number;
        /**
         * Returns whether or not the shadow generation require a cube texture or a 2d texture.
         * @returns true if a cube texture needs to be use
         */
        needCube(): boolean;
        /**
         * Detects if the projection matrix requires to be recomputed this frame.
         * @returns true if it requires to be recomputed otherwise, false.
         */
        needProjectionMatrixCompute(): boolean;
        /**
         * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.
         */
        forceProjectionMatrixCompute(): void;
        /**
         * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.
         * @param faceIndex The index of the face we are computed the direction to generate shadow
         * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true
         */
        getShadowDirection(faceIndex?: number): Vector3;
        /**
         * Gets the minZ used for shadow according to both the scene and the light.
         * @param activeCamera The camera we are returning the min for
         * @returns the depth min z
         */
        getDepthMinZ(activeCamera: Camera): number;
        /**
         * Gets the maxZ used for shadow according to both the scene and the light.
         * @param activeCamera The camera we are returning the max for
         * @returns the depth max z
         */
        getDepthMaxZ(activeCamera: Camera): number;
    }
    /**
     * Base implementation IShadowLight
     * It groups all the common behaviour in order to reduce dupplication and better follow the DRY pattern.
     */
    abstract class ShadowLight extends Light implements IShadowLight {
        protected abstract _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void;
        protected _position: Vector3;
        protected _setPosition(value: Vector3): void;
        /**
         * Sets the position the shadow will be casted from. Also use as the light position for both
         * point and spot lights.
         */
        /**
         * Sets the position the shadow will be casted from. Also use as the light position for both
         * point and spot lights.
         */
        position: Vector3;
        protected _direction: Vector3;
        protected _setDirection(value: Vector3): void;
        /**
         * In 2d mode (needCube being false), gets the direction used to cast the shadow.
         * Also use as the light direction on spot and directional lights.
         */
        /**
         * In 2d mode (needCube being false), sets the direction used to cast the shadow.
         * Also use as the light direction on spot and directional lights.
         */
        direction: Vector3;
        private _shadowMinZ;
        /**
         * Gets the shadow projection clipping minimum z value.
         */
        /**
         * Sets the shadow projection clipping minimum z value.
         */
        shadowMinZ: number;
        private _shadowMaxZ;
        /**
         * Sets the shadow projection clipping maximum z value.
         */
        /**
         * Gets the shadow projection clipping maximum z value.
         */
        shadowMaxZ: number;
        /**
         * Callback defining a custom Projection Matrix Builder.
         * This can be used to override the default projection matrix computation.
         */
        customProjectionMatrixBuilder: (viewMatrix: Matrix, renderList: Array<AbstractMesh>, result: Matrix) => void;
        /**
         * The transformed position. Position of the light in world space taking parenting in account.
         */
        transformedPosition: Vector3;
        /**
         * The transformed direction. Direction of the light in world space taking parenting in account.
         */
        transformedDirection: Vector3;
        private _worldMatrix;
        private _needProjectionMatrixCompute;
        /**
         * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light
         * @returns true if the information has been computed, false if it does not need to (no parenting)
         */
        computeTransformedInformation(): boolean;
        /**
         * Return the depth scale used for the shadow map.
         * @returns the depth scale.
         */
        getDepthScale(): number;
        /**
         * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.
         * @param faceIndex The index of the face we are computed the direction to generate shadow
         * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true
         */
        getShadowDirection(faceIndex?: number): Vector3;
        /**
         * Returns the ShadowLight absolute position in the World.
         * @returns the position vector in world space
         */
        getAbsolutePosition(): Vector3;
        /**
         * Sets the ShadowLight direction toward the passed target.
         * @param target The point tot target in local space
         * @returns the updated ShadowLight direction
         */
        setDirectionToTarget(target: Vector3): Vector3;
        /**
         * Returns the light rotation in euler definition.
         * @returns the x y z rotation in local space.
         */
        getRotation(): Vector3;
        /**
         * Returns whether or not the shadow generation require a cube texture or a 2d texture.
         * @returns true if a cube texture needs to be use
         */
        needCube(): boolean;
        /**
         * Detects if the projection matrix requires to be recomputed this frame.
         * @returns true if it requires to be recomputed otherwise, false.
         */
        needProjectionMatrixCompute(): boolean;
        /**
         * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.
         */
        forceProjectionMatrixCompute(): void;
        /**
         * Get the world matrix of the sahdow lights.
         * @hidden Internal Use Only
         */
        _getWorldMatrix(): Matrix;
        /**
         * Gets the minZ used for shadow according to both the scene and the light.
         * @param activeCamera The camera we are returning the min for
         * @returns the depth min z
         */
        getDepthMinZ(activeCamera: Camera): number;
        /**
         * Gets the maxZ used for shadow according to both the scene and the light.
         * @param activeCamera The camera we are returning the max for
         * @returns the depth max z
         */
        getDepthMaxZ(activeCamera: Camera): number;
        /**
         * Sets the shadow projection matrix in parameter to the generated projection matrix.
         * @param matrix The materix to updated with the projection information
         * @param viewMatrix The transform matrix of the light
         * @param renderList The list of mesh to render in the map
         * @returns The current light
         */
        setShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): IShadowLight;
    }
}

declare module BABYLON {
    /**
     * A spot light is defined by a position, a direction, an angle, and an exponent.
     * These values define a cone of light starting from the position, emitting toward the direction.
     * The angle, in radians, defines the size (field of illumination) of the spotlight's conical beam,
     * and the exponent defines the speed of the decay of the light with distance (reach).
     * Documentation: https://doc.babylonjs.com/babylon101/lights
     */
    class SpotLight extends ShadowLight {
        private _angle;
        /**
         * Gets the cone angle of the spot light in Radians.
         */
        /**
         * Sets the cone angle of the spot light in Radians.
         */
        angle: number;
        private _shadowAngleScale;
        /**
         * Allows scaling the angle of the light for shadow generation only.
         */
        /**
         * Allows scaling the angle of the light for shadow generation only.
         */
        shadowAngleScale: number;
        /**
         * The light decay speed with the distance from the emission spot.
         */
        exponent: number;
        private _projectionTextureMatrix;
        /**
        * Allows reading the projecton texture
        */
        readonly projectionTextureMatrix: Matrix;
        protected _projectionTextureLightNear: number;
        /**
         * Gets the near clip of the Spotlight for texture projection.
         */
        /**
         * Sets the near clip of the Spotlight for texture projection.
         */
        projectionTextureLightNear: number;
        protected _projectionTextureLightFar: number;
        /**
         * Gets the far clip of the Spotlight for texture projection.
         */
        /**
         * Sets the far clip of the Spotlight for texture projection.
         */
        projectionTextureLightFar: number;
        protected _projectionTextureUpDirection: Vector3;
        /**
         * Gets the Up vector of the Spotlight for texture projection.
         */
        /**
         * Sets the Up vector of the Spotlight for texture projection.
         */
        projectionTextureUpDirection: Vector3;
        private _projectionTexture;
        /**
         * Gets the projection texture of the light.
        */
        /**
        * Sets the projection texture of the light.
        */
        projectionTexture: Nullable<BaseTexture>;
        private _projectionTextureViewLightDirty;
        private _projectionTextureProjectionLightDirty;
        private _projectionTextureDirty;
        private _projectionTextureViewTargetVector;
        private _projectionTextureViewLightMatrix;
        private _projectionTextureProjectionLightMatrix;
        private _projectionTextureScalingMatrix;
        /**
         * Creates a SpotLight object in the scene. A spot light is a simply light oriented cone.
         * It can cast shadows.
         * Documentation : http://doc.babylonjs.com/tutorials/lights
         * @param name The light friendly name
         * @param position The position of the spot light in the scene
         * @param direction The direction of the light in the scene
         * @param angle The cone angle of the light in Radians
         * @param exponent The light decay speed with the distance from the emission spot
         * @param scene The scene the lights belongs to
         */
        constructor(name: string, position: Vector3, direction: Vector3, angle: number, exponent: number, scene: Scene);
        /**
         * Returns the string "SpotLight".
         * @returns the class name
         */
        getClassName(): string;
        /**
         * Returns the integer 2.
         * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
         */
        getTypeID(): number;
        /**
         * Overrides the direction setter to recompute the projection texture view light Matrix.
         */
        protected _setDirection(value: Vector3): void;
        /**
         * Overrides the position setter to recompute the projection texture view light Matrix.
         */
        protected _setPosition(value: Vector3): void;
        /**
         * Sets the passed matrix "matrix" as perspective projection matrix for the shadows and the passed view matrix with the fov equal to the SpotLight angle and and aspect ratio of 1.0.
         * Returns the SpotLight.
         */
        protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void;
        protected _computeProjectionTextureViewLightMatrix(): void;
        protected _computeProjectionTextureProjectionLightMatrix(): void;
        /**
         * Main function for light texture projection matrix computing.
         */
        protected _computeProjectionTextureMatrix(): void;
        protected _buildUniformLayout(): void;
        /**
         * Sets the passed Effect object with the SpotLight transfomed position (or position if not parented) and normalized direction.
         * @param effect The effect to update
         * @param lightIndex The index of the light in the effect to update
         * @returns The spot light
         */
        transferToEffect(effect: Effect, lightIndex: string): SpotLight;
        /**
         * Disposes the light and the associated resources.
         */
        dispose(): void;
    }
}

declare module BABYLON {
    interface ILoadingScreen {
        displayLoadingUI: () => void;
        hideLoadingUI: () => void;
        loadingUIBackgroundColor: string;
        loadingUIText: string;
    }
    class DefaultLoadingScreen implements ILoadingScreen {
        private _renderingCanvas;
        private _loadingText;
        private _loadingDivBackgroundColor;
        private _loadingDiv;
        private _loadingTextDiv;
        constructor(_renderingCanvas: HTMLCanvasElement, _loadingText?: string, _loadingDivBackgroundColor?: string);
        displayLoadingUI(): void;
        hideLoadingUI(): void;
        loadingUIText: string;
        loadingUIBackgroundColor: string;
        private _resizeLoadingUI;
    }
}

declare module BABYLON {
    class SceneLoaderProgressEvent {
        readonly lengthComputable: boolean;
        readonly loaded: number;
        readonly total: number;
        constructor(lengthComputable: boolean, loaded: number, total: number);
        static FromProgressEvent(event: ProgressEvent): SceneLoaderProgressEvent;
    }
    interface ISceneLoaderPluginExtensions {
        [extension: string]: {
            isBinary: boolean;
        };
    }
    interface ISceneLoaderPluginFactory {
        name: string;
        createPlugin(): ISceneLoaderPlugin | ISceneLoaderPluginAsync;
        canDirectLoad?: (data: string) => boolean;
    }
    interface ISceneLoaderPlugin {
        /**
         * The friendly name of this plugin.
         */
        name: string;
        /**
         * The file extensions supported by this plugin.
         */
        extensions: string | ISceneLoaderPluginExtensions;
        /**
         * Import meshes into a scene.
         * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
         * @param scene The scene to import into
         * @param data The data to import
         * @param rootUrl The root url for scene and resources
         * @param meshes The meshes array to import into
         * @param particleSystems The particle systems array to import into
         * @param skeletons The skeletons array to import into
         * @param onError The callback when import fails
         * @returns True if successful or false otherwise
         */
        importMesh(meshesNames: any, scene: Scene, data: any, rootUrl: string, meshes: AbstractMesh[], particleSystems: ParticleSystem[], skeletons: Skeleton[], onError?: (message: string, exception?: any) => void): boolean;
        /**
         * Load into a scene.
         * @param scene The scene to load into
         * @param data The data to import
         * @param rootUrl The root url for scene and resources
         * @param onError The callback when import fails
         * @returns true if successful or false otherwise
         */
        load(scene: Scene, data: string, rootUrl: string, onError?: (message: string, exception?: any) => void): boolean;
        /**
         * The callback that returns true if the data can be directly loaded.
         */
        canDirectLoad?: (data: string) => boolean;
        /**
         * The callback that allows custom handling of the root url based on the response url.
         */
        rewriteRootURL?: (rootUrl: string, responseURL?: string) => string;
        /**
         * Load into an asset container.
         * @param scene The scene to load into
         * @param data The data to import
         * @param rootUrl The root url for scene and resources
         * @param onError The callback when import fails
         * @returns The loaded asset container
         */
        loadAssetContainer(scene: Scene, data: string, rootUrl: string, onError?: (message: string, exception?: any) => void): AssetContainer;
    }
    interface ISceneLoaderPluginAsync {
        /**
         * The friendly name of this plugin.
         */
        name: string;
        /**
         * The file extensions supported by this plugin.
         */
        extensions: string | ISceneLoaderPluginExtensions;
        /**
         * Import meshes into a scene.
         * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
         * @param scene The scene to import into
         * @param data The data to import
         * @param rootUrl The root url for scene and resources
         * @param onProgress The callback when the load progresses
         * @returns The loaded meshes, particle systems, skeletons, and animation groups
         */
        importMeshAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void): Promise<{
            meshes: AbstractMesh[];
            particleSystems: ParticleSystem[];
            skeletons: Skeleton[];
            animationGroups: AnimationGroup[];
        }>;
        /**
         * Load into a scene.
         * @param scene The scene to load into
         * @param data The data to import
         * @param rootUrl The root url for scene and resources
         * @param onProgress The callback when the load progresses
         * @returns Nothing
         */
        loadAsync(scene: Scene, data: string, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void): Promise<void>;
        /**
         * The callback that returns true if the data can be directly loaded.
         */
        canDirectLoad?: (data: string) => boolean;
        /**
         * The callback that allows custom handling of the root url based on the response url.
         */
        rewriteRootURL?: (rootUrl: string, responseURL?: string) => string;
        /**
         * Load into an asset container.
         * @param scene The scene to load into
         * @param data The data to import
         * @param rootUrl The root url for scene and resources
         * @param onProgress The callback when the load progresses
         * @returns The loaded asset container
         */
        loadAssetContainerAsync(scene: Scene, data: string, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void): Promise<AssetContainer>;
    }
    class SceneLoader {
        private static _ForceFullSceneLoadingForIncremental;
        private static _ShowLoadingScreen;
        private static _CleanBoneMatrixWeights;
        static readonly NO_LOGGING: number;
        static readonly MINIMAL_LOGGING: number;
        static readonly SUMMARY_LOGGING: number;
        static readonly DETAILED_LOGGING: number;
        private static _loggingLevel;
        static ForceFullSceneLoadingForIncremental: boolean;
        static ShowLoadingScreen: boolean;
        static loggingLevel: number;
        static CleanBoneMatrixWeights: boolean;
        static OnPluginActivatedObservable: Observable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>;
        private static _registeredPlugins;
        private static _getDefaultPlugin();
        private static _getPluginForExtension(extension);
        private static _getPluginForDirectLoad(data);
        private static _getPluginForFilename(sceneFilename);
        private static _getDirectLoad(sceneFilename);
        private static _loadData(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, onDispose, pluginExtension);
        static GetPluginForExtension(extension: string): ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory;
        static IsPluginForExtensionAvailable(extension: string): boolean;
        static RegisterPlugin(plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync): void;
        /**
         * Import meshes into a scene
         * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
         * @param rootUrl a string that defines the root url for scene and resources
         * @param sceneFilename a string that defines the name of the scene file. can start with "data:" following by the stringified version of the scene
         * @param scene the instance of BABYLON.Scene to append to
         * @param onSuccess a callback with a list of imported meshes, particleSystems, and skeletons when import succeeds
         * @param onProgress a callback with a progress event for each file being loaded
         * @param onError a callback with the scene, a message, and possibly an exception when import fails
         * @param pluginExtension the extension used to determine the plugin
         * @returns The loaded plugin
         */
        static ImportMesh(meshNames: any, rootUrl: string, sceneFilename: string, scene: Scene, onSuccess?: Nullable<(meshes: AbstractMesh[], particleSystems: ParticleSystem[], skeletons: Skeleton[], animationGroups: AnimationGroup[]) => void>, onProgress?: Nullable<(event: SceneLoaderProgressEvent) => void>, onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>, pluginExtension?: Nullable<string>): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>;
        /**
        * Import meshes into a scene
        * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
        * @param rootUrl a string that defines the root url for scene and resources
        * @param sceneFilename a string that defines the name of the scene file. can start with "data:" following by the stringified version of the scene
        * @param scene the instance of BABYLON.Scene to append to
        * @param onProgress a callback with a progress event for each file being loaded
        * @param pluginExtension the extension used to determine the plugin
        * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups
        */
        static ImportMeshAsync(meshNames: any, rootUrl: string, sceneFilename: string, scene: Scene, onProgress?: Nullable<(event: SceneLoaderProgressEvent) => void>, pluginExtension?: Nullable<string>): Promise<{
            meshes: AbstractMesh[];
            particleSystems: ParticleSystem[];
            skeletons: Skeleton[];
            animationGroups: AnimationGroup[];
        }>;
        /**
        * Load a scene
        * @param rootUrl a string that defines the root url for scene and resources
        * @param sceneFilename a string that defines the name of the scene file. can start with "data:" following by the stringified version of the scene
        * @param engine is the instance of BABYLON.Engine to use to create the scene
        * @param onSuccess a callback with the scene when import succeeds
        * @param onProgress a callback with a progress event for each file being loaded
        * @param onError a callback with the scene, a message, and possibly an exception when import fails
        * @param pluginExtension the extension used to determine the plugin
        * @returns The loaded plugin
        */
        static Load(rootUrl: string, sceneFilename: any, engine: Engine, onSuccess?: Nullable<(scene: Scene) => void>, onProgress?: Nullable<(event: SceneLoaderProgressEvent) => void>, onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>, pluginExtension?: Nullable<string>): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>;
        /**
        * Load a scene
        * @param rootUrl a string that defines the root url for scene and resources
        * @param sceneFilename a string that defines the name of the scene file. can start with "data:" following by the stringified version of the scene
        * @param engine is the instance of BABYLON.Engine to use to create the scene
        * @param onProgress a callback with a progress event for each file being loaded
        * @param pluginExtension the extension used to determine the plugin
        * @returns The loaded scene
        */
        static LoadAsync(rootUrl: string, sceneFilename: any, engine: Engine, onProgress?: Nullable<(event: SceneLoaderProgressEvent) => void>, pluginExtension?: Nullable<string>): Promise<Scene>;
        /**
        * Append a scene
        * @param rootUrl a string that defines the root url for scene and resources
        * @param sceneFilename a string that defines the name of the scene file. can start with "data:" following by the stringified version of the scene
        * @param scene is the instance of BABYLON.Scene to append to
        * @param onSuccess a callback with the scene when import succeeds
        * @param onProgress a callback with a progress event for each file being loaded
        * @param onError a callback with the scene, a message, and possibly an exception when import fails
        * @param pluginExtension the extension used to determine the plugin
        * @returns The loaded plugin
        */
        static Append(rootUrl: string, sceneFilename: any, scene: Scene, onSuccess?: Nullable<(scene: Scene) => void>, onProgress?: Nullable<(event: SceneLoaderProgressEvent) => void>, onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>, pluginExtension?: Nullable<string>): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>;
        /**
        * Append a scene
        * @param rootUrl a string that defines the root url for scene and resources
        * @param sceneFilename a string that defines the name of the scene file. can start with "data:" following by the stringified version of the scene
        * @param scene is the instance of BABYLON.Scene to append to
        * @param onProgress a callback with a progress event for each file being loaded
        * @param pluginExtension the extension used to determine the plugin
        * @returns The given scene
        */
        static AppendAsync(rootUrl: string, sceneFilename: any, scene: Scene, onProgress?: Nullable<(event: SceneLoaderProgressEvent) => void>, pluginExtension?: Nullable<string>): Promise<Scene>;
        /**
        * Load a scene into an asset container
        * @param rootUrl a string that defines the root url for scene and resources
        * @param sceneFilename a string that defines the name of the scene file. can start with "data:" following by the stringified version of the scene
        * @param scene is the instance of BABYLON.Scene to append to
        * @param onSuccess a callback with the scene when import succeeds
        * @param onProgress a callback with a progress event for each file being loaded
        * @param onError a callback with the scene, a message, and possibly an exception when import fails
        * @param pluginExtension the extension used to determine the plugin
        * @returns The loaded plugin
        */
        static LoadAssetContainer(rootUrl: string, sceneFilename: any, scene: Scene, onSuccess?: Nullable<(assets: AssetContainer) => void>, onProgress?: Nullable<(event: SceneLoaderProgressEvent) => void>, onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>, pluginExtension?: Nullable<string>): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>;
        /**
        * Load a scene into an asset container
        * @param rootUrl a string that defines the root url for scene and resources
        * @param sceneFilename a string that defines the name of the scene file. can start with "data:" following by the stringified version of the scene
        * @param scene is the instance of BABYLON.Scene to append to
        * @param onProgress a callback with a progress event for each file being loaded
        * @param pluginExtension the extension used to determine the plugin
        * @returns The loaded asset container
        */
        static LoadAssetContainerAsync(rootUrl: string, sceneFilename: any, scene: Scene, onProgress?: Nullable<(event: SceneLoaderProgressEvent) => void>, pluginExtension?: Nullable<string>): Promise<AssetContainer>;
    }
}

declare module BABYLON {
    /**
     * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
     * corresponding to low luminance, medium luminance, and high luminance areas respectively.
     */
    class ColorCurves {
        private _dirty;
        private _tempColor;
        private _globalCurve;
        private _highlightsCurve;
        private _midtonesCurve;
        private _shadowsCurve;
        private _positiveCurve;
        private _negativeCurve;
        private _globalHue;
        private _globalDensity;
        private _globalSaturation;
        private _globalExposure;
        /**
         * Gets the global Hue value.
         * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
         */
        /**
         * Sets the global Hue value.
         * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
         */
        globalHue: number;
        /**
         * Gets the global Density value.
         * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
         * Values less than zero provide a filter of opposite hue.
         */
        /**
         * Sets the global Density value.
         * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
         * Values less than zero provide a filter of opposite hue.
         */
        globalDensity: number;
        /**
         * Gets the global Saturation value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
         */
        /**
         * Sets the global Saturation value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
         */
        globalSaturation: number;
        private _highlightsHue;
        private _highlightsDensity;
        private _highlightsSaturation;
        private _highlightsExposure;
        /**
         * Gets the highlights Hue value.
         * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
         */
        /**
         * Sets the highlights Hue value.
         * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
         */
        highlightsHue: number;
        /**
         * Gets the highlights Density value.
         * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
         * Values less than zero provide a filter of opposite hue.
         */
        /**
         * Sets the highlights Density value.
         * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
         * Values less than zero provide a filter of opposite hue.
         */
        highlightsDensity: number;
        /**
         * Gets the highlights Saturation value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
         */
        /**
         * Sets the highlights Saturation value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
         */
        highlightsSaturation: number;
        /**
         * Gets the highlights Exposure value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
         */
        /**
         * Sets the highlights Exposure value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
         */
        highlightsExposure: number;
        private _midtonesHue;
        private _midtonesDensity;
        private _midtonesSaturation;
        private _midtonesExposure;
        /**
         * Gets the midtones Hue value.
         * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
         */
        /**
         * Sets the midtones Hue value.
         * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
         */
        midtonesHue: number;
        /**
         * Gets the midtones Density value.
         * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
         * Values less than zero provide a filter of opposite hue.
         */
        /**
         * Sets the midtones Density value.
         * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
         * Values less than zero provide a filter of opposite hue.
         */
        midtonesDensity: number;
        /**
         * Gets the midtones Saturation value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
         */
        /**
         * Sets the midtones Saturation value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
         */
        midtonesSaturation: number;
        /**
         * Gets the midtones Exposure value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
         */
        /**
         * Sets the midtones Exposure value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
         */
        midtonesExposure: number;
        private _shadowsHue;
        private _shadowsDensity;
        private _shadowsSaturation;
        private _shadowsExposure;
        /**
         * Gets the shadows Hue value.
         * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
         */
        /**
         * Sets the shadows Hue value.
         * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
         */
        shadowsHue: number;
        /**
         * Gets the shadows Density value.
         * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
         * Values less than zero provide a filter of opposite hue.
         */
        /**
         * Sets the shadows Density value.
         * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
         * Values less than zero provide a filter of opposite hue.
         */
        shadowsDensity: number;
        /**
         * Gets the shadows Saturation value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
         */
        /**
         * Sets the shadows Saturation value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
         */
        shadowsSaturation: number;
        /**
         * Gets the shadows Exposure value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
         */
        /**
         * Sets the shadows Exposure value.
         * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
         */
        shadowsExposure: number;
        getClassName(): string;
        /**
         * Binds the color curves to the shader.
         * @param colorCurves The color curve to bind
         * @param effect The effect to bind to
         */
        static Bind(colorCurves: ColorCurves, effect: Effect, positiveUniform?: string, neutralUniform?: string, negativeUniform?: string): void;
        /**
         * Prepare the list of uniforms associated with the ColorCurves effects.
         * @param uniformsList The list of uniforms used in the effect
         */
        static PrepareUniforms(uniformsList: string[]): void;
        /**
         * Returns color grading data based on a hue, density, saturation and exposure value.
         * @param filterHue The hue of the color filter.
         * @param filterDensity The density of the color filter.
         * @param saturation The saturation.
         * @param exposure The exposure.
         * @param result The result data container.
         */
        private getColorGradingDataToRef(hue, density, saturation, exposure, result);
        /**
         * Takes an input slider value and returns an adjusted value that provides extra control near the centre.
         * @param value The input slider value in range [-100,100].
         * @returns Adjusted value.
         */
        private static applyColorGradingSliderNonlinear(value);
        /**
         * Returns an RGBA Color4 based on Hue, Saturation and Brightness (also referred to as value, HSV).
         * @param hue The hue (H) input.
         * @param saturation The saturation (S) input.
         * @param brightness The brightness (B) input.
         * @result An RGBA color represented as Vector4.
         */
        private static fromHSBToRef(hue, saturation, brightness, result);
        /**
         * Returns a value clamped between min and max
         * @param value The value to clamp
         * @param min The minimum of value
         * @param max The maximum of value
         * @returns The clamped value.
         */
        private static clamp(value, min, max);
        /**
         * Clones the current color curve instance.
         * @return The cloned curves
         */
        clone(): ColorCurves;
        /**
         * Serializes the current color curve instance to a json representation.
         * @return a JSON representation
         */
        serialize(): any;
        /**
         * Parses the color curve from a json representation.
         * @param source the JSON source to parse
         * @return The parsed curves
         */
        static Parse(source: any): ColorCurves;
    }
}

declare module BABYLON {
    /**
     * EffectFallbacks can be used to add fallbacks (properties to disable) to certain properties when desired to improve performance.
     * (Eg. Start at high quality with reflection and fog, if fps is low, remove reflection, if still low remove fog)
     */
    class EffectFallbacks {
        private _defines;
        private _currentRank;
        private _maxRank;
        private _mesh;
        /**
         * Removes the fallback from the bound mesh.
         */
        unBindMesh(): void;
        /**
         * Adds a fallback on the specified property.
         * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)
         * @param define The name of the define in the shader
         */
        addFallback(rank: number, define: string): void;
        /**
         * Sets the mesh to use CPU skinning when needing to fallback.
         * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)
         * @param mesh The mesh to use the fallbacks.
         */
        addCPUSkinningFallback(rank: number, mesh: AbstractMesh): void;
        /**
         * Checks to see if more fallbacks are still availible.
         */
        readonly isMoreFallbacks: boolean;
        /**
         * Removes the defines that shoould be removed when falling back.
         * @param currentDefines defines the current define statements for the shader.
         * @param effect defines the current effect we try to compile
         * @returns The resulting defines with defines of the current rank removed.
         */
        reduce(currentDefines: string, effect: Effect): string;
    }
    /**
     * Options to be used when creating an effect.
     */
    class EffectCreationOptions {
        /**
         * Atrributes that will be used in the shader.
         */
        attributes: string[];
        /**
         * Uniform varible names that will be set in the shader.
         */
        uniformsNames: string[];
        /**
         * Uniform buffer varible names that will be set in the shader.
         */
        uniformBuffersNames: string[];
        /**
         * Sampler texture variable names that will be set in the shader.
         */
        samplers: string[];
        /**
         * Define statements that will be set in the shader.
         */
        defines: any;
        /**
         * Possible fallbacks for this effect to improve performance when needed.
         */
        fallbacks: Nullable<EffectFallbacks>;
        /**
         * Callback that will be called when the shader is compiled.
         */
        onCompiled: Nullable<(effect: Effect) => void>;
        /**
         * Callback that will be called if an error occurs during shader compilation.
         */
        onError: Nullable<(effect: Effect, errors: string) => void>;
        /**
         * Parameters to be used with Babylons include syntax to iterate over an array (eg. {lights: 10})
         */
        indexParameters: any;
        /**
         * Max number of lights that can be used in the shader.
         */
        maxSimultaneousLights: number;
        /**
         * See https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/transformFeedbackVaryings
         */
        transformFeedbackVaryings: Nullable<string[]>;
    }
    /**
     * Effect containing vertex and fragment shader that can be executed on an object.
     */
    class Effect {
        /**
         * Name of the effect.
         */
        name: any;
        /**
         * String container all the define statements that should be set on the shader.
         */
        defines: string;
        /**
         * Callback that will be called when the shader is compiled.
         */
        onCompiled: Nullable<(effect: Effect) => void>;
        /**
         * Callback that will be called if an error occurs during shader compilation.
         */
        onError: Nullable<(effect: Effect, errors: string) => void>;
        /**
         * Callback that will be called when effect is bound.
         */
        onBind: Nullable<(effect: Effect) => void>;
        /**
         * Unique ID of the effect.
         */
        uniqueId: number;
        /**
         * Observable that will be called when the shader is compiled.
         */
        onCompileObservable: Observable<Effect>;
        /**
         * Observable that will be called if an error occurs during shader compilation.
         */
        onErrorObservable: Observable<Effect>;
        /**
         * Observable that will be called when effect is bound.
         */
        onBindObservable: Observable<Effect>;
        /** @hidden */
        _bonesComputationForcedToCPU: boolean;
        private static _uniqueIdSeed;
        private _engine;
        private _uniformBuffersNames;
        private _uniformsNames;
        private _samplers;
        private _isReady;
        private _compilationError;
        private _attributesNames;
        private _attributes;
        private _uniforms;
        /**
         * Key for the effect.
         */
        _key: string;
        private _indexParameters;
        private _fallbacks;
        private _vertexSourceCode;
        private _fragmentSourceCode;
        private _vertexSourceCodeOverride;
        private _fragmentSourceCodeOverride;
        private _transformFeedbackVaryings;
        /**
         * Compiled shader to webGL program.
         */
        _program: WebGLProgram;
        private _valueCache;
        private static _baseCache;
        /**
         * Instantiates an effect.
         * An effect can be used to create/manage/execute vertex and fragment shaders.
         * @param baseName Name of the effect.
         * @param attributesNamesOrOptions List of attribute names that will be passed to the shader or set of all options to create the effect.
         * @param uniformsNamesOrEngine List of uniform variable names that will be passed to the shader or the engine that will be used to render effect.
         * @param samplers List of sampler variables that will be passed to the shader.
         * @param engine Engine to be used to render the effect
         * @param defines Define statements to be added to the shader.
         * @param fallbacks Possible fallbacks for this effect to improve performance when needed.
         * @param onCompiled Callback that will be called when the shader is compiled.
         * @param onError Callback that will be called if an error occurs during shader compilation.
         * @param indexParameters Parameters to be used with Babylons include syntax to iterate over an array (eg. {lights: 10})
         */
        constructor(baseName: any, attributesNamesOrOptions: string[] | EffectCreationOptions, uniformsNamesOrEngine: string[] | Engine, samplers?: Nullable<string[]>, engine?: Engine, defines?: Nullable<string>, fallbacks?: Nullable<EffectFallbacks>, onCompiled?: Nullable<(effect: Effect) => void>, onError?: Nullable<(effect: Effect, errors: string) => void>, indexParameters?: any);
        /**
         * Unique key for this effect
         */
        readonly key: string;
        /**
         * If the effect has been compiled and prepared.
         * @returns if the effect is compiled and prepared.
         */
        isReady(): boolean;
        /**
         * The engine the effect was initialized with.
         * @returns the engine.
         */
        getEngine(): Engine;
        /**
         * The compiled webGL program for the effect
         * @returns the webGL program.
         */
        getProgram(): WebGLProgram;
        /**
         * The set of names of attribute variables for the shader.
         * @returns An array of attribute names.
         */
        getAttributesNames(): string[];
        /**
         * Returns the attribute at the given index.
         * @param index The index of the attribute.
         * @returns The location of the attribute.
         */
        getAttributeLocation(index: number): number;
        /**
         * Returns the attribute based on the name of the variable.
         * @param name of the attribute to look up.
         * @returns the attribute location.
         */
        getAttributeLocationByName(name: string): number;
        /**
         * The number of attributes.
         * @returns the numnber of attributes.
         */
        getAttributesCount(): number;
        /**
         * Gets the index of a uniform variable.
         * @param uniformName of the uniform to look up.
         * @returns the index.
         */
        getUniformIndex(uniformName: string): number;
        /**
         * Returns the attribute based on the name of the variable.
         * @param uniformName of the uniform to look up.
         * @returns the location of the uniform.
         */
        getUniform(uniformName: string): Nullable<WebGLUniformLocation>;
        /**
         * Returns an array of sampler variable names
         * @returns The array of sampler variable neames.
         */
        getSamplers(): string[];
        /**
         * The error from the last compilation.
         * @returns the error string.
         */
        getCompilationError(): string;
        /**
         * Adds a callback to the onCompiled observable and call the callback imediatly if already ready.
         * @param func The callback to be used.
         */
        executeWhenCompiled(func: (effect: Effect) => void): void;
        /** @hidden */
        _loadVertexShader(vertex: any, callback: (data: any) => void): void;
        /** @hidden */
        _loadFragmentShader(fragment: any, callback: (data: any) => void): void;
        private _dumpShadersSource(vertexCode, fragmentCode, defines);
        private _processShaderConversion(sourceCode, isFragment, callback);
        private _processIncludes(sourceCode, callback);
        private _processPrecision(source);
        /**
         * Recompiles the webGL program
         * @param vertexSourceCode The source code for the vertex shader.
         * @param fragmentSourceCode The source code for the fragment shader.
         * @param onCompiled Callback called when completed.
         * @param onError Callback called on error.
         */
        _rebuildProgram(vertexSourceCode: string, fragmentSourceCode: string, onCompiled: (program: WebGLProgram) => void, onError: (message: string) => void): void;
        /**
         * Gets the uniform locations of the the specified variable names
         * @param names THe names of the variables to lookup.
         * @returns Array of locations in the same order as variable names.
         */
        getSpecificUniformLocations(names: string[]): Nullable<WebGLUniformLocation>[];
        /**
         * Prepares the effect
         */
        _prepareEffect(): void;
        /**
         * Checks if the effect is supported. (Must be called after compilation)
         */
        readonly isSupported: boolean;
        /**
         * Binds a texture to the engine to be used as output of the shader.
         * @param channel Name of the output variable.
         * @param texture Texture to bind.
         */
        _bindTexture(channel: string, texture: InternalTexture): void;
        /**
         * Sets a texture on the engine to be used in the shader.
         * @param channel Name of the sampler variable.
         * @param texture Texture to set.
         */
        setTexture(channel: string, texture: Nullable<BaseTexture>): void;
        /**
         * Sets a depth stencil texture from a render target on the engine to be used in the shader.
         * @param channel Name of the sampler variable.
         * @param texture Texture to set.
         */
        setDepthStencilTexture(channel: string, texture: Nullable<RenderTargetTexture>): void;
        /**
         * Sets an array of textures on the engine to be used in the shader.
         * @param channel Name of the variable.
         * @param textures Textures to set.
         */
        setTextureArray(channel: string, textures: BaseTexture[]): void;
        /**
         * Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)
         * @param channel Name of the sampler variable.
         * @param postProcess Post process to get the input texture from.
         */
        setTextureFromPostProcess(channel: string, postProcess: Nullable<PostProcess>): void;
        /**
         * (Warning! setTextureFromPostProcessOutput may be desired instead)
         * Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)
         * @param channel Name of the sampler variable.
         * @param postProcess Post process to get the output texture from.
         */
        setTextureFromPostProcessOutput(channel: string, postProcess: Nullable<PostProcess>): void;
        /** @hidden */
        _cacheMatrix(uniformName: string, matrix: Matrix): boolean;
        /** @hidden */
        _cacheFloat2(uniformName: string, x: number, y: number): boolean;
        /** @hidden */
        _cacheFloat3(uniformName: string, x: number, y: number, z: number): boolean;
        /** @hidden */
        _cacheFloat4(uniformName: string, x: number, y: number, z: number, w: number): boolean;
        /**
         * Binds a buffer to a uniform.
         * @param buffer Buffer to bind.
         * @param name Name of the uniform variable to bind to.
         */
        bindUniformBuffer(buffer: WebGLBuffer, name: string): void;
        /**
         * Binds block to a uniform.
         * @param blockName Name of the block to bind.
         * @param index Index to bind.
         */
        bindUniformBlock(blockName: string, index: number): void;
        /**
         * Sets an interger value on a uniform variable.
         * @param uniformName Name of the variable.
         * @param value Value to be set.
         * @returns this effect.
         */
        setInt(uniformName: string, value: number): Effect;
        /**
         * Sets an int array on a uniform variable.
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setIntArray(uniformName: string, array: Int32Array): Effect;
        /**
         * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setIntArray2(uniformName: string, array: Int32Array): Effect;
        /**
         * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setIntArray3(uniformName: string, array: Int32Array): Effect;
        /**
         * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setIntArray4(uniformName: string, array: Int32Array): Effect;
        /**
         * Sets an float array on a uniform variable.
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setFloatArray(uniformName: string, array: Float32Array): Effect;
        /**
         * Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setFloatArray2(uniformName: string, array: Float32Array): Effect;
        /**
         * Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setFloatArray3(uniformName: string, array: Float32Array): Effect;
        /**
         * Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setFloatArray4(uniformName: string, array: Float32Array): Effect;
        /**
         * Sets an array on a uniform variable.
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setArray(uniformName: string, array: number[]): Effect;
        /**
         * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setArray2(uniformName: string, array: number[]): Effect;
        /**
         * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setArray3(uniformName: string, array: number[]): Effect;
        /**
         * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
         * @param uniformName Name of the variable.
         * @param array array to be set.
         * @returns this effect.
         */
        setArray4(uniformName: string, array: number[]): Effect;
        /**
         * Sets matrices on a uniform variable.
         * @param uniformName Name of the variable.
         * @param matrices matrices to be set.
         * @returns this effect.
         */
        setMatrices(uniformName: string, matrices: Float32Array): Effect;
        /**
         * Sets matrix on a uniform variable.
         * @param uniformName Name of the variable.
         * @param matrix matrix to be set.
         * @returns this effect.
         */
        setMatrix(uniformName: string, matrix: Matrix): Effect;
        /**
         * Sets a 3x3 matrix on a uniform variable. (Speicified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)
         * @param uniformName Name of the variable.
         * @param matrix matrix to be set.
         * @returns this effect.
         */
        setMatrix3x3(uniformName: string, matrix: Float32Array): Effect;
        /**
         * Sets a 2x2 matrix on a uniform variable. (Speicified as [1,2,3,4] will result in [1,2][3,4] matrix)
         * @param uniformName Name of the variable.
         * @param matrix matrix to be set.
         * @returns this effect.
         */
        setMatrix2x2(uniformName: string, matrix: Float32Array): Effect;
        /**
         * Sets a float on a uniform variable.
         * @param uniformName Name of the variable.
         * @param value value to be set.
         * @returns this effect.
         */
        setFloat(uniformName: string, value: number): Effect;
        /**
         * Sets a boolean on a uniform variable.
         * @param uniformName Name of the variable.
         * @param bool value to be set.
         * @returns this effect.
         */
        setBool(uniformName: string, bool: boolean): Effect;
        /**
         * Sets a Vector2 on a uniform variable.
         * @param uniformName Name of the variable.
         * @param vector2 vector2 to be set.
         * @returns this effect.
         */
        setVector2(uniformName: string, vector2: Vector2): Effect;
        /**
         * Sets a float2 on a uniform variable.
         * @param uniformName Name of the variable.
         * @param x First float in float2.
         * @param y Second float in float2.
         * @returns this effect.
         */
        setFloat2(uniformName: string, x: number, y: number): Effect;
        /**
         * Sets a Vector3 on a uniform variable.
         * @param uniformName Name of the variable.
         * @param vector3 Value to be set.
         * @returns this effect.
         */
        setVector3(uniformName: string, vector3: Vector3): Effect;
        /**
         * Sets a float3 on a uniform variable.
         * @param uniformName Name of the variable.
         * @param x First float in float3.
         * @param y Second float in float3.
         * @param z Third float in float3.
         * @returns this effect.
         */
        setFloat3(uniformName: string, x: number, y: number, z: number): Effect;
        /**
         * Sets a Vector4 on a uniform variable.
         * @param uniformName Name of the variable.
         * @param vector4 Value to be set.
         * @returns this effect.
         */
        setVector4(uniformName: string, vector4: Vector4): Effect;
        /**
         * Sets a float4 on a uniform variable.
         * @param uniformName Name of the variable.
         * @param x First float in float4.
         * @param y Second float in float4.
         * @param z Third float in float4.
         * @param w Fourth float in float4.
         * @returns this effect.
         */
        setFloat4(uniformName: string, x: number, y: number, z: number, w: number): Effect;
        /**
         * Sets a Color3 on a uniform variable.
         * @param uniformName Name of the variable.
         * @param color3 Value to be set.
         * @returns this effect.
         */
        setColor3(uniformName: string, color3: Color3): Effect;
        /**
         * Sets a Color4 on a uniform variable.
         * @param uniformName Name of the variable.
         * @param color3 Value to be set.
         * @param alpha Alpha value to be set.
         * @returns this effect.
         */
        setColor4(uniformName: string, color3: Color3, alpha: number): Effect;
        /**
         * Sets a Color4 on a uniform variable
         * @param uniformName defines the name of the variable
         * @param color4 defines the value to be set
         * @returns this effect.
         */
        setDirectColor4(uniformName: string, color4: Color4): Effect;
        /**
         * Store of each shader (The can be looked up using effect.key)
         */
        static ShadersStore: {
            [key: string]: string;
        };
        /**
         * Store of each included file for a shader (The can be looked up using effect.key)
         */
        static IncludesShadersStore: {
            [key: string]: string;
        };
        /**
         * Resets the cache of effects.
         */
        static ResetCache(): void;
    }
}

declare module BABYLON {
    class FresnelParameters {
        private _isEnabled;
        isEnabled: boolean;
        leftColor: Color3;
        rightColor: Color3;
        bias: number;
        power: number;
        clone(): FresnelParameters;
        serialize(): any;
        static Parse(parsedFresnelParameters: any): FresnelParameters;
    }
}

declare module BABYLON {
    /**
     * Interface to follow in your material defines to integrate easily the
     * Image proccessing functions.
     * @hidden
     */
    interface IImageProcessingConfigurationDefines {
        IMAGEPROCESSING: boolean;
        VIGNETTE: boolean;
        VIGNETTEBLENDMODEMULTIPLY: boolean;
        VIGNETTEBLENDMODEOPAQUE: boolean;
        TONEMAPPING: boolean;
        CONTRAST: boolean;
        EXPOSURE: boolean;
        COLORCURVES: boolean;
        COLORGRADING: boolean;
        COLORGRADING3D: boolean;
        SAMPLER3DGREENDEPTH: boolean;
        SAMPLER3DBGRMAP: boolean;
        IMAGEPROCESSINGPOSTPROCESS: boolean;
    }
    /**
     * This groups together the common properties used for image processing either in direct forward pass
     * or through post processing effect depending on the use of the image processing pipeline in your scene
     * or not.
     */
    class ImageProcessingConfiguration {
        /**
         * Color curves setup used in the effect if colorCurvesEnabled is set to true
         */
        colorCurves: Nullable<ColorCurves>;
        private _colorCurvesEnabled;
        /**
         * Gets wether the color curves effect is enabled.
         */
        /**
         * Sets wether the color curves effect is enabled.
         */
        colorCurvesEnabled: boolean;
        /**
         * Color grading LUT texture used in the effect if colorGradingEnabled is set to true
         */
        colorGradingTexture: Nullable<BaseTexture>;
        private _colorGradingEnabled;
        /**
         * Gets wether the color grading effect is enabled.
         */
        /**
         * Sets wether the color grading effect is enabled.
         */
        colorGradingEnabled: boolean;
        private _colorGradingWithGreenDepth;
        /**
         * Gets wether the color grading effect is using a green depth for the 3d Texture.
         */
        /**
         * Sets wether the color grading effect is using a green depth for the 3d Texture.
         */
        colorGradingWithGreenDepth: boolean;
        private _colorGradingBGR;
        /**
         * Gets wether the color grading texture contains BGR values.
         */
        /**
         * Sets wether the color grading texture contains BGR values.
         */
        colorGradingBGR: boolean;
        _exposure: number;
        /**
         * Gets the Exposure used in the effect.
         */
        /**
         * Sets the Exposure used in the effect.
         */
        exposure: number;
        private _toneMappingEnabled;
        /**
         * Gets wether the tone mapping effect is enabled.
         */
        /**
         * Sets wether the tone mapping effect is enabled.
         */
        toneMappingEnabled: boolean;
        protected _contrast: number;
        /**
         * Gets the contrast used in the effect.
         */
        /**
         * Sets the contrast used in the effect.
         */
        contrast: number;
        /**
         * Vignette stretch size.
         */
        vignetteStretch: number;
        /**
         * Vignette centre X Offset.
         */
        vignetteCentreX: number;
        /**
         * Vignette centre Y Offset.
         */
        vignetteCentreY: number;
        /**
         * Vignette weight or intensity of the vignette effect.
         */
        vignetteWeight: number;
        /**
         * Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
         * if vignetteEnabled is set to true.
         */
        vignetteColor: Color4;
        /**
         * Camera field of view used by the Vignette effect.
         */
        vignetteCameraFov: number;
        private _vignetteBlendMode;
        /**
         * Gets the vignette blend mode allowing different kind of effect.
         */
        /**
         * Sets the vignette blend mode allowing different kind of effect.
         */
        vignetteBlendMode: number;
        private _vignetteEnabled;
        /**
         * Gets wether the vignette effect is enabled.
         */
        /**
         * Sets wether the vignette effect is enabled.
         */
        vignetteEnabled: boolean;
        private _applyByPostProcess;
        /**
         * Gets wether the image processing is applied through a post process or not.
         */
        /**
         * Sets wether the image processing is applied through a post process or not.
         */
        applyByPostProcess: boolean;
        private _isEnabled;
        /**
         * Gets wether the image processing is enabled or not.
         */
        /**
         * Sets wether the image processing is enabled or not.
         */
        isEnabled: boolean;
        /**
        * An event triggered when the configuration changes and requires Shader to Update some parameters.
        */
        onUpdateParameters: Observable<ImageProcessingConfiguration>;
        /**
         * Method called each time the image processing information changes requires to recompile the effect.
         */
        protected _updateParameters(): void;
        getClassName(): string;
        /**
         * Prepare the list of uniforms associated with the Image Processing effects.
         * @param uniformsList The list of uniforms used in the effect
         * @param defines the list of defines currently in use
         */
        static PrepareUniforms(uniforms: string[], defines: IImageProcessingConfigurationDefines): void;
        /**
         * Prepare the list of samplers associated with the Image Processing effects.
         * @param uniformsList The list of uniforms used in the effect
         * @param defines the list of defines currently in use
         */
        static PrepareSamplers(samplersList: string[], defines: IImageProcessingConfigurationDefines): void;
        /**
         * Prepare the list of defines associated to the shader.
         * @param defines the list of defines to complete
         */
        prepareDefines(defines: IImageProcessingConfigurationDefines, forPostProcess?: boolean): void;
        /**
         * Returns true if all the image processing information are ready.
         */
        isReady(): boolean;
        /**
         * Binds the image processing to the shader.
         * @param effect The effect to bind to
         */
        bind(effect: Effect, aspectRatio?: number): void;
        /**
         * Clones the current image processing instance.
         * @return The cloned image processing
         */
        clone(): ImageProcessingConfiguration;
        /**
         * Serializes the current image processing instance to a json representation.
         * @return a JSON representation
         */
        serialize(): any;
        /**
         * Parses the image processing from a json representation.
         * @param source the JSON source to parse
         * @return The parsed image processing
         */
        static Parse(source: any): ImageProcessingConfiguration;
        private static _VIGNETTEMODE_MULTIPLY;
        private static _VIGNETTEMODE_OPAQUE;
        /**
         * Used to apply the vignette as a mix with the pixel color.
         */
        static readonly VIGNETTEMODE_MULTIPLY: number;
        /**
         * Used to apply the vignette as a replacement of the pixel color.
         */
        static readonly VIGNETTEMODE_OPAQUE: number;
    }
}

declare module BABYLON {
    /**
     * Manages the defines for the Material
     */
    class MaterialDefines {
        private _keys;
        private _isDirty;
        /** @hidden */
        _renderId: number;
        /** @hidden */
        _areLightsDirty: boolean;
        /** @hidden */
        _areAttributesDirty: boolean;
        /** @hidden */
        _areTexturesDirty: boolean;
        /** @hidden */
        _areFresnelDirty: boolean;
        /** @hidden */
        _areMiscDirty: boolean;
        /** @hidden */
        _areImageProcessingDirty: boolean;
        /** @hidden */
        _normals: boolean;
        /** @hidden */
        _uvs: boolean;
        /** @hidden */
        _needNormals: boolean;
        /** @hidden */
        _needUVs: boolean;
        /**
         * Specifies if the material needs to be re-calculated
         */
        readonly isDirty: boolean;
        /**
         * Marks the material to indicate that it has been re-calculated
         */
        markAsProcessed(): void;
        /**
         * Marks the material to indicate that it needs to be re-calculated
         */
        markAsUnprocessed(): void;
        /**
         * Marks the material to indicate all of its defines need to be re-calculated
         */
        markAllAsDirty(): void;
        /**
         * Marks the material to indicate that image processing needs to be re-calculated
         */
        markAsImageProcessingDirty(): void;
        /**
         * Marks the material to indicate the lights need to be re-calculated
         */
        markAsLightDirty(): void;
        /**
         * Marks the attribute state as changed
         */
        markAsAttributesDirty(): void;
        /**
         * Marks the texture state as changed
         */
        markAsTexturesDirty(): void;
        /**
         * Marks the fresnel state as changed
         */
        markAsFresnelDirty(): void;
        /**
         * Marks the misc state as changed
         */
        markAsMiscDirty(): void;
        /**
         * Rebuilds the material defines
         */
        rebuild(): void;
        /**
         * Specifies if two material defines are equal
         * @param other - A material define instance to compare to
         * @returns - Boolean indicating if the material defines are equal (true) or not (false)
         */
        isEqual(other: MaterialDefines): boolean;
        /**
         * Clones this instance's defines to another instance
         * @param other - material defines to clone values to
         */
        cloneTo(other: MaterialDefines): void;
        /**
         * Resets the material define values
         */
        reset(): void;
        /**
         * Converts the material define values to a string
         * @returns - String of material define information
         */
        toString(): string;
    }
    /**
     * Base class for the main features of a material in Babylon.js
     */
    class Material implements IAnimatable {
        private static _TriangleFillMode;
        private static _WireFrameFillMode;
        private static _PointFillMode;
        private static _PointListDrawMode;
        private static _LineListDrawMode;
        private static _LineLoopDrawMode;
        private static _LineStripDrawMode;
        private static _TriangleStripDrawMode;
        private static _TriangleFanDrawMode;
        /**
         * Returns the triangle fill mode
         */
        static readonly TriangleFillMode: number;
        /**
         * Returns the wireframe mode
         */
        static readonly WireFrameFillMode: number;
        /**
         * Returns the point fill mode
         */
        static readonly PointFillMode: number;
        /**
         * Returns the point list draw mode
         */
        static readonly PointListDrawMode: number;
        /**
         * Returns the line list draw mode
         */
        static readonly LineListDrawMode: number;
        /**
         * Returns the line loop draw mode
         */
        static readonly LineLoopDrawMode: number;
        /**
         * Returns the line strip draw mode
         */
        static readonly LineStripDrawMode: number;
        /**
         * Returns the triangle strip draw mode
         */
        static readonly TriangleStripDrawMode: number;
        /**
         * Returns the triangle fan draw mode
         */
        static readonly TriangleFanDrawMode: number;
        /**
         * Stores the clock-wise side orientation
         */
        private static _ClockWiseSideOrientation;
        /**
         * Stores the counter clock-wise side orientation
         */
        private static _CounterClockWiseSideOrientation;
        /**
         * Returns the clock-wise side orientation
         */
        static readonly ClockWiseSideOrientation: number;
        /**
         * Returns the counter clock-wise side orientation
         */
        static readonly CounterClockWiseSideOrientation: number;
        /**
         * The dirty texture flag value
         */
        private static _TextureDirtyFlag;
        /**
         * The dirty light flag value
         */
        private static _LightDirtyFlag;
        /**
         * The dirty fresnel flag value
         */
        private static _FresnelDirtyFlag;
        /**
         * The dirty attribute flag value
         */
        private static _AttributesDirtyFlag;
        /**
         * The dirty misc flag value
         */
        private static _MiscDirtyFlag;
        /**
         * Returns the dirty texture flag value
         */
        static readonly TextureDirtyFlag: number;
        /**
         * Returns the dirty light flag value
         */
        static readonly LightDirtyFlag: number;
        /**
         * Returns the dirty fresnel flag value
         */
        static readonly FresnelDirtyFlag: number;
        /**
         * Returns the dirty attributes flag value
         */
        static readonly AttributesDirtyFlag: number;
        /**
         * Returns the dirty misc flag value
         */
        static readonly MiscDirtyFlag: number;
        /**
         * The ID of the material
         */
        id: string;
        /**
         * The name of the material
         */
        name: string;
        /**
         * Specifies if the ready state should be checked on each call
         */
        checkReadyOnEveryCall: boolean;
        /**
         * Specifies if the ready state should be checked once
         */
        checkReadyOnlyOnce: boolean;
        /**
         * The state of the material
         */
        state: string;
        /**
         * The alpha value of the material
         */
        protected _alpha: number;
        /**
         * Gets the alpha value of the material
         */
        /**
         * Sets the alpha value of the material
         */
        alpha: number;
        /**
         * Specifies if back face culling is enabled
         */
        protected _backFaceCulling: boolean;
        /**
         * Gets the back-face culling state
         */
        /**
         * Sets the back-face culling state
         */
        backFaceCulling: boolean;
        /**
         * Stores the value for side orientation
         */
        sideOrientation: number;
        /**
         * Callback triggered when the material is compiled
         */
        onCompiled: (effect: Effect) => void;
        /**
         * Callback triggered when an error occurs
         */
        onError: (effect: Effect, errors: string) => void;
        /**
         * Callback triggered to get the render target textures
         */
        getRenderTargetTextures: () => SmartArray<RenderTargetTexture>;
        /**
         * Specifies if the material should be serialized
         */
        doNotSerialize: boolean;
        /**
         * Specifies if the effect should be stored on sub meshes
         */
        storeEffectOnSubMeshes: boolean;
        /**
         * Stores the animations for the material
         */
        animations: Array<Animation>;
        /**
        * An event triggered when the material is disposed
        */
        onDisposeObservable: Observable<Material>;
        /**
         * An observer which watches for dispose events
         */
        private _onDisposeObserver;
        /**
         * Called during a dispose event
         */
        onDispose: () => void;
        /**
        * An event triggered when the material is bound
        */
        onBindObservable: Observable<AbstractMesh>;
        /**
         * An observer which watches for bind events
         */
        private _onBindObserver;
        /**
         * Called during a bind event
         */
        onBind: (Mesh: AbstractMesh) => void;
        /**
        * An event triggered when the material is unbound
        */
        onUnBindObservable: Observable<Material>;
        /**
         * Stores the value of the alpha mode
         */
        private _alphaMode;
        /**
         * Gets the value of the alpha mode
         */
        /**
         * Sets the value of the alpha mode.
         *
         * | Value | Type | Description |
         * | --- | --- | --- |
         * | 0 | ALPHA_DISABLE |   |
         * | 1 | ALPHA_ADD |   |
         * | 2 | ALPHA_COMBINE |   |
         * | 3 | ALPHA_SUBTRACT |   |
         * | 4 | ALPHA_MULTIPLY |   |
         * | 5 | ALPHA_MAXIMIZED |   |
         * | 6 | ALPHA_ONEONE |   |
         * | 7 | ALPHA_PREMULTIPLIED |   |
         * | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF |   |
         * | 9 | ALPHA_INTERPOLATE |   |
         * | 10 | ALPHA_SCREENMODE |   |
         *
         */
        alphaMode: number;
        /**
         * Stores the state of the need depth pre-pass value
         */
        private _needDepthPrePass;
        /**
         * Gets the depth pre-pass value
         */
        /**
         * Sets the need depth pre-pass value
         */
        needDepthPrePass: boolean;
        /**
         * Specifies if depth writing should be disabled
         */
        disableDepthWrite: boolean;
        /**
         * Specifies if depth writing should be forced
         */
        forceDepthWrite: boolean;
        /**
         * Specifies if there should be a separate pass for culling
         */
        separateCullingPass: boolean;
        /**
         * Stores the state specifing if fog should be enabled
         */
        private _fogEnabled;
        /**
         * Gets the value of the fog enabled state
         */
        /**
         * Sets the state for enabling fog
         */
        fogEnabled: boolean;
        /**
         * Stores the size of points
         */
        pointSize: number;
        /**
         * Stores the z offset value
         */
        zOffset: number;
        /**
         * Gets a value specifying if wireframe mode is enabled
         */
        /**
         * Sets the state of wireframe mode
         */
        wireframe: boolean;
        /**
         * Gets the value specifying if point clouds are enabled
         */
        /**
         * Sets the state of point cloud mode
         */
        pointsCloud: boolean;
        /**
         * Gets the material fill mode
         */
        /**
         * Sets the material fill mode
         */
        fillMode: number;
        /**
         * Stores the effects for the material
         */
        _effect: Nullable<Effect>;
        /**
         * Specifies if the material was previously ready
         */
        _wasPreviouslyReady: boolean;
        /**
         * Specifies if uniform buffers should be used
         */
        private _useUBO;
        /**
         * Stores a reference to the scene
         */
        private _scene;
        /**
         * Stores the fill mode state
         */
        private _fillMode;
        /**
         * Specifies if the depth write state should be cached
         */
        private _cachedDepthWriteState;
        /**
         * Stores the uniform buffer
         */
        protected _uniformBuffer: UniformBuffer;
        /**
         * Creates a material instance
         * @param name defines the name of the material
         * @param scene defines the scene to reference
         * @param doNotAdd specifies if the material should be added to the scene
         */
        constructor(name: string, scene: Scene, doNotAdd?: boolean);
        /**
         * Returns a string representation of the current material
         * @param fullDetails defines a boolean indicating which levels of logging is desired
         * @returns a string with material information
         */
        toString(fullDetails?: boolean): string;
        /**
         * Gets the class name of the material
         * @returns a string with the class name of the material
         */
        getClassName(): string;
        /**
         * Specifies if updates for the material been locked
         */
        readonly isFrozen: boolean;
        /**
         * Locks updates for the material
         */
        freeze(): void;
        /**
         * Unlocks updates for the material
         */
        unfreeze(): void;
        /**
         * Specifies if the material is ready to be used
         * @param mesh defines the mesh to check
         * @param useInstances specifies if instances should be used
         * @returns a boolean indicating if the material is ready to be used
         */
        isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean;
        /**
         * Specifies that the submesh is ready to be used
         * @param mesh defines the mesh to check
         * @param subMesh defines which submesh to check
         * @param useInstances specifies that instances should be used
         * @returns a boolean indicating that the submesh is ready or not
         */
        isReadyForSubMesh(mesh: AbstractMesh, subMesh: BaseSubMesh, useInstances?: boolean): boolean;
        /**
         * Returns the material effect
         * @returns the effect associated with the material
         */
        getEffect(): Nullable<Effect>;
        /**
         * Returns the current scene
         * @returns a Scene
         */
        getScene(): Scene;
        /**
         * Specifies if the material will require alpha blending
         * @returns a boolean specifying if alpha blending is needed
         */
        needAlphaBlending(): boolean;
        /**
         * Specifies if the mesh will require alpha blending
         * @param mesh defines the mesh to check
         * @returns a boolean specifying if alpha blending is needed for the mesh
         */
        needAlphaBlendingForMesh(mesh: AbstractMesh): boolean;
        /**
         * Specifies if this material should be rendered in alpha test mode
         * @returns a boolean specifying if an alpha test is needed.
         */
        needAlphaTesting(): boolean;
        /**
         * Gets the texture used for the alpha test
         * @returns the texture to use for alpha testing
         */
        getAlphaTestTexture(): Nullable<BaseTexture>;
        /**
         * Marks the material to indicate that it needs to be re-calculated
         */
        markDirty(): void;
        /** @hidden */
        _preBind(effect?: Effect, overrideOrientation?: Nullable<number>): boolean;
        /**
         * Binds the material to the mesh
         * @param world defines the world transformation matrix
         * @param mesh defines the mesh to bind the material to
         */
        bind(world: Matrix, mesh?: Mesh): void;
        /**
         * Binds the submesh to the material
         * @param world defines the world transformation matrix
         * @param mesh defines the mesh containing the submesh
         * @param subMesh defines the submesh to bind the material to
         */
        bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void;
        /**
         * Binds the world matrix to the material
         * @param world defines the world transformation matrix
         */
        bindOnlyWorldMatrix(world: Matrix): void;
        /**
         * Binds the scene's uniform buffer to the effect.
         * @param effect defines the effect to bind to the scene uniform buffer
         * @param sceneUbo defines the uniform buffer storing scene data
         */
        bindSceneUniformBuffer(effect: Effect, sceneUbo: UniformBuffer): void;
        /**
         * Binds the view matrix to the effect
         * @param effect defines the effect to bind the view matrix to
         */
        bindView(effect: Effect): void;
        /**
         * Binds the view projection matrix to the effect
         * @param effect defines the effect to bind the view projection matrix to
         */
        bindViewProjection(effect: Effect): void;
        /**
         * Specifies if material alpha testing should be turned on for the mesh
         * @param mesh defines the mesh to check
         */
        protected _shouldTurnAlphaTestOn(mesh: AbstractMesh): boolean;
        /**
         * Processes to execute after binding the material to a mesh
         * @param mesh defines the rendered mesh
         */
        protected _afterBind(mesh?: Mesh): void;
        /**
         * Unbinds the material from the mesh
         */
        unbind(): void;
        /**
         * Gets the active textures from the material
         * @returns an array of textures
         */
        getActiveTextures(): BaseTexture[];
        /**
         * Specifies if the material uses a texture
         * @param texture defines the texture to check against the material
         * @returns a boolean specifying if the material uses the texture
         */
        hasTexture(texture: BaseTexture): boolean;
        /**
         * Makes a duplicate of the material, and gives it a new name
         * @param name defines the new name for the duplicated material
         * @returns the cloned material
         */
        clone(name: string): Nullable<Material>;
        /**
         * Gets the meshes bound to the material
         * @returns an array of meshes bound to the material
         */
        getBindedMeshes(): AbstractMesh[];
        /**
         * Force shader compilation
         * @param mesh defines the mesh associated with this material
         * @param onCompiled defines a function to execute once the material is compiled
         * @param options defines the options to configure the compilation
         */
        forceCompilation(mesh: AbstractMesh, onCompiled?: (material: Material) => void, options?: Partial<{
            clipPlane: boolean;
        }>): void;
        /**
         * Force shader compilation
         * @param mesh defines the mesh that will use this material
         * @param options defines additional options for compiling the shaders
         * @returns a promise that resolves when the compilation completes
         */
        forceCompilationAsync(mesh: AbstractMesh, options?: Partial<{
            clipPlane: boolean;
        }>): Promise<void>;
        /**
         * Marks a define in the material to indicate that it needs to be re-computed
         * @param flag defines a flag used to determine which parts of the material have to be marked as dirty
         */
        markAsDirty(flag: number): void;
        /**
         * Marks all submeshes of a material to indicate that their material defines need to be re-calculated
         * @param func defines a function which checks material defines against the submeshes
         */
        protected _markAllSubMeshesAsDirty(func: (defines: MaterialDefines) => void): void;
        /**
         * Indicates that image processing needs to be re-calculated for all submeshes
         */
        protected _markAllSubMeshesAsImageProcessingDirty(): void;
        /**
         * Indicates that textures need to be re-calculated for all submeshes
         */
        protected _markAllSubMeshesAsTexturesDirty(): void;
        /**
         * Indicates that fresnel needs to be re-calculated for all submeshes
         */
        protected _markAllSubMeshesAsFresnelDirty(): void;
        /**
         * Indicates that fresnel and misc need to be re-calculated for all submeshes
         */
        protected _markAllSubMeshesAsFresnelAndMiscDirty(): void;
        /**
         * Indicates that lights need to be re-calculated for all submeshes
         */
        protected _markAllSubMeshesAsLightsDirty(): void;
        /**
         * Indicates that attributes need to be re-calculated for all submeshes
         */
        protected _markAllSubMeshesAsAttributesDirty(): void;
        /**
         * Indicates that misc needs to be re-calculated for all submeshes
         */
        protected _markAllSubMeshesAsMiscDirty(): void;
        /**
         * Indicates that textures and misc need to be re-calculated for all submeshes
         */
        protected _markAllSubMeshesAsTexturesAndMiscDirty(): void;
        /**
         * Disposes the material
         * @param forceDisposeEffect specifies if effects should be forcefully disposed
         * @param forceDisposeTextures specifies if textures should be forcefully disposed
         */
        dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean): void;
        /**
         * Serializes this material
         * @returns the serialized material object
         */
        serialize(): any;
        /**
         * Creates a MultiMaterial from parsed MultiMaterial data.
         * @param parsedMultiMaterial defines parsed MultiMaterial data.
         * @param scene defines the hosting scene
         * @returns a new MultiMaterial
         */
        static ParseMultiMaterial(parsedMultiMaterial: any, scene: Scene): MultiMaterial;
        /**
         * Creates a material from parsed material data
         * @param parsedMaterial defines parsed material data
         * @param scene defines the hosting scene
         * @param rootUrl defines the root URL to use to load textures
         * @returns a new material
         */
        static Parse(parsedMaterial: any, scene: Scene, rootUrl: string): any;
    }
}

declare module BABYLON {
    /**
     * "Static Class" containing the most commonly used helper while dealing with material for
     * rendering purpose.
     *
     * It contains the basic tools to help defining defines, binding uniform for the common part of the materials.
     *
     * This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.
     */
    class MaterialHelper {
        /**
         * Bind the current view position to an effect.
         * @param effect The effect to be bound
         * @param scene The scene the eyes position is used from
         */
        static BindEyePosition(effect: Effect, scene: Scene): void;
        /**
         * Helps preparing the defines values about the UVs in used in the effect.
         * UVs are shared as much as we can accross chanels in the shaders.
         * @param texture The texture we are preparing the UVs for
         * @param defines The defines to update
         * @param key The chanel key "diffuse", "specular"... used in the shader
         */
        static PrepareDefinesForMergedUV(texture: BaseTexture, defines: any, key: string): void;
        /**
         * Binds a texture matrix value to its corrsponding uniform
         * @param texture The texture to bind the matrix for
         * @param uniformBuffer The uniform buffer receivin the data
         * @param key The chanel key "diffuse", "specular"... used in the shader
         */
        static BindTextureMatrix(texture: BaseTexture, uniformBuffer: UniformBuffer, key: string): void;
        /**
         * Helper used to prepare the list of defines associated with misc. values for shader compilation
         * @param mesh defines the current mesh
         * @param scene defines the current scene
         * @param useLogarithmicDepth defines if logarithmic depth has to be turned on
         * @param pointsCloud defines if point cloud rendering has to be turned on
         * @param fogEnabled defines if fog has to be turned on
         * @param alphaTest defines if alpha testing has to be turned on
         * @param defines defines the current list of defines
         */
        static PrepareDefinesForMisc(mesh: AbstractMesh, scene: Scene, useLogarithmicDepth: boolean, pointsCloud: boolean, fogEnabled: boolean, alphaTest: boolean, defines: any): void;
        /**
         * Helper used to prepare the list of defines associated with frame values for shader compilation
         * @param scene defines the current scene
         * @param engine defines the current engine
         * @param defines specifies the list of active defines
         * @param useInstances defines if instances have to be turned on
         * @param useClipPlane defines if clip plane have to be turned on
         */
        static PrepareDefinesForFrameBoundValues(scene: Scene, engine: Engine, defines: any, useInstances: boolean, useClipPlane?: Nullable<boolean>): void;
        /**
         * Prepares the defines used in the shader depending on the attributes data available in the mesh
         * @param mesh The mesh containing the geometry data we will draw
         * @param defines The defines to update
         * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)
         * @param useBones Precise whether bones should be used or not (override mesh info)
         * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)
         * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)
         * @returns false if defines are considered not dirty and have not been checked
         */
        static PrepareDefinesForAttributes(mesh: AbstractMesh, defines: any, useVertexColor: boolean, useBones: boolean, useMorphTargets?: boolean, useVertexAlpha?: boolean): boolean;
        /**
         * Prepares the defines related to the light information passed in parameter
         * @param scene The scene we are intending to draw
         * @param mesh The mesh the effect is compiling for
         * @param defines The defines to update
         * @param specularSupported Specifies whether specular is supported or not (override lights data)
         * @param maxSimultaneousLights Specfies how manuy lights can be added to the effect at max
         * @param disableLighting Specifies whether the lighting is disabled (override scene and light)
         * @returns true if normals will be required for the rest of the effect
         */
        static PrepareDefinesForLights(scene: Scene, mesh: AbstractMesh, defines: any, specularSupported: boolean, maxSimultaneousLights?: number, disableLighting?: boolean): boolean;
        /**
         * Prepares the uniforms and samplers list to be used in the effect. This can automatically remove from the list uniforms
         * that won t be acctive due to defines being turned off.
         * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the liist and extra information
         * @param samplersList The samplers list
         * @param defines The defines helping in the list generation
         * @param maxSimultaneousLights The maximum number of simultanous light allowed in the effect
         */
        static PrepareUniformsAndSamplersList(uniformsListOrOptions: string[] | EffectCreationOptions, samplersList?: string[], defines?: any, maxSimultaneousLights?: number): void;
        /**
         * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)
         * @param defines The defines to update while falling back
         * @param fallbacks The authorized effect fallbacks
         * @param maxSimultaneousLights The maximum number of lights allowed
         * @param rank the current rank of the Effect
         * @returns The newly affected rank
         */
        static HandleFallbacksForShadows(defines: any, fallbacks: EffectFallbacks, maxSimultaneousLights?: number, rank?: number): number;
        /**
         * Prepares the list of attributes required for morph targets according to the effect defines.
         * @param attribs The current list of supported attribs
         * @param mesh The mesh to prepare the morph targets attributes for
         * @param defines The current Defines of the effect
         */
        static PrepareAttributesForMorphTargets(attribs: string[], mesh: AbstractMesh, defines: any): void;
        /**
         * Prepares the list of attributes required for bones according to the effect defines.
         * @param attribs The current list of supported attribs
         * @param mesh The mesh to prepare the bones attributes for
         * @param defines The current Defines of the effect
         * @param fallbacks The current efffect fallback strategy
         */
        static PrepareAttributesForBones(attribs: string[], mesh: AbstractMesh, defines: any, fallbacks: EffectFallbacks): void;
        /**
         * Prepares the list of attributes required for instances according to the effect defines.
         * @param attribs The current list of supported attribs
         * @param defines The current Defines of the effect
         */
        static PrepareAttributesForInstances(attribs: string[], defines: any): void;
        /**
         * Binds the light shadow information to the effect for the given mesh.
         * @param light The light containing the generator
         * @param scene The scene the lights belongs to
         * @param mesh The mesh we are binding the information to render
         * @param lightIndex The light index in the effect used to render the mesh
         * @param effect The effect we are binding the data to
         */
        static BindLightShadow(light: Light, scene: Scene, mesh: AbstractMesh, lightIndex: string, effect: Effect): void;
        /**
         * Binds the light information to the effect.
         * @param light The light containing the generator
         * @param effect The effect we are binding the data to
         * @param lightIndex The light index in the effect used to render
         */
        static BindLightProperties(light: Light, effect: Effect, lightIndex: number): void;
        /**
         * Binds the lights information from the scene to the effect for the given mesh.
         * @param scene The scene the lights belongs to
         * @param mesh The mesh we are binding the information to render
         * @param effect The effect we are binding the data to
         * @param defines The generated defines for the effect
         * @param maxSimultaneousLights The maximum number of light that can be bound to the effect
         * @param usePhysicalLightFalloff Specifies whether the light falloff is defined physically or not
         */
        static BindLights(scene: Scene, mesh: AbstractMesh, effect: Effect, defines: any, maxSimultaneousLights?: number, usePhysicalLightFalloff?: boolean): void;
        /**
         * Binds the fog information from the scene to the effect for the given mesh.
         * @param scene The scene the lights belongs to
         * @param mesh The mesh we are binding the information to render
         * @param effect The effect we are binding the data to
         */
        static BindFogParameters(scene: Scene, mesh: AbstractMesh, effect: Effect): void;
        /**
         * Binds the bones information from the mesh to the effect.
         * @param mesh The mesh we are binding the information to render
         * @param effect The effect we are binding the data to
         */
        static BindBonesParameters(mesh?: AbstractMesh, effect?: Effect): void;
        /**
         * Binds the morph targets information from the mesh to the effect.
         * @param abstractMesh The mesh we are binding the information to render
         * @param effect The effect we are binding the data to
         */
        static BindMorphTargetParameters(abstractMesh: AbstractMesh, effect: Effect): void;
        /**
         * Binds the logarithmic depth information from the scene to the effect for the given defines.
         * @param defines The generated defines used in the effect
         * @param effect The effect we are binding the data to
         * @param scene The scene we are willing to render with logarithmic scale for
         */
        static BindLogDepth(defines: any, effect: Effect, scene: Scene): void;
        /**
         * Binds the clip plane information from the scene to the effect.
         * @param scene The scene the clip plane information are extracted from
         * @param effect The effect we are binding the data to
         */
        static BindClipPlane(effect: Effect, scene: Scene): void;
    }
}

declare module BABYLON {
    class MultiMaterial extends Material {
        private _subMaterials;
        subMaterials: Nullable<Material>[];
        constructor(name: string, scene: Scene);
        private _hookArray(array);
        getSubMaterial(index: number): Nullable<Material>;
        getActiveTextures(): BaseTexture[];
        getClassName(): string;
        isReadyForSubMesh(mesh: AbstractMesh, subMesh: BaseSubMesh, useInstances?: boolean): boolean;
        clone(name: string, cloneChildren?: boolean): MultiMaterial;
        serialize(): any;
        dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean): void;
    }
}

declare module BABYLON {
    class PushMaterial extends Material {
        protected _activeEffect: Effect;
        protected _normalMatrix: Matrix;
        constructor(name: string, scene: Scene);
        getEffect(): Effect;
        isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean;
        /**
        * Binds the given world matrix to the active effect
        *
        * @param world the matrix to bind
        */
        bindOnlyWorldMatrix(world: Matrix): void;
        /**
         * Binds the given normal matrix to the active effect
         *
         * @param normalMatrix the matrix to bind
         */
        bindOnlyNormalMatrix(normalMatrix: Matrix): void;
        bind(world: Matrix, mesh?: Mesh): void;
        protected _afterBind(mesh: Mesh, effect?: Nullable<Effect>): void;
        protected _mustRebind(scene: Scene, effect: Effect, visibility?: number): boolean;
    }
}

declare module BABYLON {
    class ShaderMaterial extends Material {
        private _shaderPath;
        private _options;
        private _textures;
        private _textureArrays;
        private _floats;
        private _ints;
        private _floatsArrays;
        private _colors3;
        private _colors3Arrays;
        private _colors4;
        private _vectors2;
        private _vectors3;
        private _vectors4;
        private _matrices;
        private _matrices3x3;
        private _matrices2x2;
        private _vectors2Arrays;
        private _vectors3Arrays;
        private _cachedWorldViewMatrix;
        private _renderId;
        constructor(name: string, scene: Scene, shaderPath: any, options: any);
        getClassName(): string;
        needAlphaBlending(): boolean;
        needAlphaTesting(): boolean;
        private _checkUniform(uniformName);
        setTexture(name: string, texture: Texture): ShaderMaterial;
        setTextureArray(name: string, textures: Texture[]): ShaderMaterial;
        setFloat(name: string, value: number): ShaderMaterial;
        setInt(name: string, value: number): ShaderMaterial;
        setFloats(name: string, value: number[]): ShaderMaterial;
        setColor3(name: string, value: Color3): ShaderMaterial;
        setColor3Array(name: string, value: Color3[]): ShaderMaterial;
        setColor4(name: string, value: Color4): ShaderMaterial;
        setVector2(name: string, value: Vector2): ShaderMaterial;
        setVector3(name: string, value: Vector3): ShaderMaterial;
        setVector4(name: string, value: Vector4): ShaderMaterial;
        setMatrix(name: string, value: Matrix): ShaderMaterial;
        setMatrix3x3(name: string, value: Float32Array): ShaderMaterial;
        setMatrix2x2(name: string, value: Float32Array): ShaderMaterial;
        setArray2(name: string, value: number[]): ShaderMaterial;
        setArray3(name: string, value: number[]): ShaderMaterial;
        private _checkCache(scene, mesh?, useInstances?);
        isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean;
        bindOnlyWorldMatrix(world: Matrix): void;
        bind(world: Matrix, mesh?: Mesh): void;
        getActiveTextures(): BaseTexture[];
        hasTexture(texture: BaseTexture): boolean;
        clone(name: string): ShaderMaterial;
        dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean): void;
        serialize(): any;
        static Parse(source: any, scene: Scene, rootUrl: string): ShaderMaterial;
    }
}

declare module BABYLON {
    /** @hidden */
    class StandardMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {
        MAINUV1: boolean;
        MAINUV2: boolean;
        DIFFUSE: boolean;
        DIFFUSEDIRECTUV: number;
        AMBIENT: boolean;
        AMBIENTDIRECTUV: number;
        OPACITY: boolean;
        OPACITYDIRECTUV: number;
        OPACITYRGB: boolean;
        REFLECTION: boolean;
        EMISSIVE: boolean;
        EMISSIVEDIRECTUV: number;
        SPECULAR: boolean;
        SPECULARDIRECTUV: number;
        BUMP: boolean;
        BUMPDIRECTUV: number;
        PARALLAX: boolean;
        PARALLAXOCCLUSION: boolean;
        SPECULAROVERALPHA: boolean;
        CLIPPLANE: boolean;
        ALPHATEST: boolean;
        DEPTHPREPASS: boolean;
        ALPHAFROMDIFFUSE: boolean;
        POINTSIZE: boolean;
        FOG: boolean;
        SPECULARTERM: boolean;
        DIFFUSEFRESNEL: boolean;
        OPACITYFRESNEL: boolean;
        REFLECTIONFRESNEL: boolean;
        REFRACTIONFRESNEL: boolean;
        EMISSIVEFRESNEL: boolean;
        FRESNEL: boolean;
        NORMAL: boolean;
        UV1: boolean;
        UV2: boolean;
        VERTEXCOLOR: boolean;
        VERTEXALPHA: boolean;
        NUM_BONE_INFLUENCERS: number;
        BonesPerMesh: number;
        INSTANCES: boolean;
        GLOSSINESS: boolean;
        ROUGHNESS: boolean;
        EMISSIVEASILLUMINATION: boolean;
        LINKEMISSIVEWITHDIFFUSE: boolean;
        REFLECTIONFRESNELFROMSPECULAR: boolean;
        LIGHTMAP: boolean;
        LIGHTMAPDIRECTUV: number;
        OBJECTSPACE_NORMALMAP: boolean;
        USELIGHTMAPASSHADOWMAP: boolean;
        REFLECTIONMAP_3D: boolean;
        REFLECTIONMAP_SPHERICAL: boolean;
        REFLECTIONMAP_PLANAR: boolean;
        REFLECTIONMAP_CUBIC: boolean;
        USE_LOCAL_REFLECTIONMAP_CUBIC: boolean;
        REFLECTIONMAP_PROJECTION: boolean;
        REFLECTIONMAP_SKYBOX: boolean;
        REFLECTIONMAP_EXPLICIT: boolean;
        REFLECTIONMAP_EQUIRECTANGULAR: boolean;
        REFLECTIONMAP_EQUIRECTANGULAR_FIXED: boolean;
        REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED: boolean;
        INVERTCUBICMAP: boolean;
        LOGARITHMICDEPTH: boolean;
        REFRACTION: boolean;
        REFRACTIONMAP_3D: boolean;
        REFLECTIONOVERALPHA: boolean;
        TWOSIDEDLIGHTING: boolean;
        SHADOWFLOAT: boolean;
        MORPHTARGETS: boolean;
        MORPHTARGETS_NORMAL: boolean;
        MORPHTARGETS_TANGENT: boolean;
        NUM_MORPH_INFLUENCERS: number;
        NONUNIFORMSCALING: boolean;
        PREMULTIPLYALPHA: boolean;
        IMAGEPROCESSING: boolean;
        VIGNETTE: boolean;
        VIGNETTEBLENDMODEMULTIPLY: boolean;
        VIGNETTEBLENDMODEOPAQUE: boolean;
        TONEMAPPING: boolean;
        CONTRAST: boolean;
        COLORCURVES: boolean;
        COLORGRADING: boolean;
        COLORGRADING3D: boolean;
        SAMPLER3DGREENDEPTH: boolean;
        SAMPLER3DBGRMAP: boolean;
        IMAGEPROCESSINGPOSTPROCESS: boolean;
        /**
         * If the reflection texture on this material is in linear color space
         * @hidden
         */
        IS_REFLECTION_LINEAR: boolean;
        /**
         * If the refraction texture on this material is in linear color space
         * @hidden
         */
        IS_REFRACTION_LINEAR: boolean;
        EXPOSURE: boolean;
        constructor();
        setReflectionMode(modeToEnable: string): void;
    }
    class StandardMaterial extends PushMaterial {
        private _diffuseTexture;
        diffuseTexture: Nullable<BaseTexture>;
        private _ambientTexture;
        ambientTexture: Nullable<BaseTexture>;
        private _opacityTexture;
        opacityTexture: Nullable<BaseTexture>;
        private _reflectionTexture;
        reflectionTexture: Nullable<BaseTexture>;
        private _emissiveTexture;
        emissiveTexture: Nullable<BaseTexture>;
        private _specularTexture;
        specularTexture: Nullable<BaseTexture>;
        private _bumpTexture;
        bumpTexture: Nullable<BaseTexture>;
        private _lightmapTexture;
        lightmapTexture: Nullable<BaseTexture>;
        private _refractionTexture;
        refractionTexture: Nullable<BaseTexture>;
        ambientColor: Color3;
        diffuseColor: Color3;
        specularColor: Color3;
        emissiveColor: Color3;
        specularPower: number;
        private _useAlphaFromDiffuseTexture;
        useAlphaFromDiffuseTexture: boolean;
        private _useEmissiveAsIllumination;
        useEmissiveAsIllumination: boolean;
        private _linkEmissiveWithDiffuse;
        linkEmissiveWithDiffuse: boolean;
        private _useSpecularOverAlpha;
        useSpecularOverAlpha: boolean;
        private _useReflectionOverAlpha;
        useReflectionOverAlpha: boolean;
        private _disableLighting;
        disableLighting: boolean;
        private _useObjectSpaceNormalMap;
        /**
         * Allows using an object space normal map (instead of tangent space).
         */
        useObjectSpaceNormalMap: boolean;
        private _useParallax;
        useParallax: boolean;
        private _useParallaxOcclusion;
        useParallaxOcclusion: boolean;
        parallaxScaleBias: number;
        private _roughness;
        roughness: number;
        indexOfRefraction: number;
        invertRefractionY: boolean;
        /**
         * Defines the alpha limits in alpha test mode
         */
        alphaCutOff: number;
        private _useLightmapAsShadowmap;
        useLightmapAsShadowmap: boolean;
        private _diffuseFresnelParameters;
        diffuseFresnelParameters: FresnelParameters;
        private _opacityFresnelParameters;
        opacityFresnelParameters: FresnelParameters;
        private _reflectionFresnelParameters;
        reflectionFresnelParameters: FresnelParameters;
        private _refractionFresnelParameters;
        refractionFresnelParameters: FresnelParameters;
        private _emissiveFresnelParameters;
        emissiveFresnelParameters: FresnelParameters;
        private _useReflectionFresnelFromSpecular;
        useReflectionFresnelFromSpecular: boolean;
        private _useGlossinessFromSpecularMapAlpha;
        useGlossinessFromSpecularMapAlpha: boolean;
        private _maxSimultaneousLights;
        maxSimultaneousLights: number;
        /**
         * If sets to true, x component of normal map value will invert (x = 1.0 - x).
         */
        private _invertNormalMapX;
        invertNormalMapX: boolean;
        /**
         * If sets to true, y component of normal map value will invert (y = 1.0 - y).
         */
        private _invertNormalMapY;
        invertNormalMapY: boolean;
        /**
         * If sets to true and backfaceCulling is false, normals will be flipped on the backside.
         */
        private _twoSidedLighting;
        twoSidedLighting: boolean;
        /**
         * Default configuration related to image processing available in the standard Material.
         */
        protected _imageProcessingConfiguration: ImageProcessingConfiguration;
        /**
         * Gets the image processing configuration used either in this material.
         */
        /**
         * Sets the Default image processing configuration used either in the this material.
         *
         * If sets to null, the scene one is in use.
         */
        imageProcessingConfiguration: ImageProcessingConfiguration;
        /**
         * Keep track of the image processing observer to allow dispose and replace.
         */
        private _imageProcessingObserver;
        /**
         * Attaches a new image processing configuration to the Standard Material.
         * @param configuration
         */
        protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void;
        /**
         * Gets wether the color curves effect is enabled.
         */
        /**
         * Sets wether the color curves effect is enabled.
         */
        cameraColorCurvesEnabled: boolean;
        /**
         * Gets wether the color grading effect is enabled.
         */
        /**
         * Gets wether the color grading effect is enabled.
         */
        cameraColorGradingEnabled: boolean;
        /**
         * Gets wether tonemapping is enabled or not.
         */
        /**
         * Sets wether tonemapping is enabled or not
         */
        cameraToneMappingEnabled: boolean;
        /**
         * The camera exposure used on this material.
         * This property is here and not in the camera to allow controlling exposure without full screen post process.
         * This corresponds to a photographic exposure.
         */
        /**
         * The camera exposure used on this material.
         * This property is here and not in the camera to allow controlling exposure without full screen post process.
         * This corresponds to a photographic exposure.
         */
        cameraExposure: number;
        /**
         * Gets The camera contrast used on this material.
         */
        /**
         * Sets The camera contrast used on this material.
         */
        cameraContrast: number;
        /**
         * Gets the Color Grading 2D Lookup Texture.
         */
        /**
         * Sets the Color Grading 2D Lookup Texture.
         */
        cameraColorGradingTexture: Nullable<BaseTexture>;
        /**
         * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
         * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
         * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
         * corresponding to low luminance, medium luminance, and high luminance areas respectively.
         */
        /**
         * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
         * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
         * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
         * corresponding to low luminance, medium luminance, and high luminance areas respectively.
         */
        cameraColorCurves: Nullable<ColorCurves>;
        customShaderNameResolve: (shaderName: string, uniforms: string[], uniformBuffers: string[], samplers: string[], defines: StandardMaterialDefines) => string;
        protected _renderTargets: SmartArray<RenderTargetTexture>;
        protected _worldViewProjectionMatrix: Matrix;
        protected _globalAmbientColor: Color3;
        protected _useLogarithmicDepth: boolean;
        constructor(name: string, scene: Scene);
        getClassName(): string;
        useLogarithmicDepth: boolean;
        needAlphaBlending(): boolean;
        needAlphaTesting(): boolean;
        protected _shouldUseAlphaFromDiffuseTexture(): boolean;
        getAlphaTestTexture(): Nullable<BaseTexture>;
        /**
         * Child classes can use it to update shaders
         */
        isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean;
        buildUniformLayout(): void;
        unbind(): void;
        bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void;
        getAnimatables(): IAnimatable[];
        getActiveTextures(): BaseTexture[];
        hasTexture(texture: BaseTexture): boolean;
        dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean): void;
        clone(name: string): StandardMaterial;
        serialize(): any;
        static Parse(source: any, scene: Scene, rootUrl: string): StandardMaterial;
        static _DiffuseTextureEnabled: boolean;
        static DiffuseTextureEnabled: boolean;
        static _AmbientTextureEnabled: boolean;
        static AmbientTextureEnabled: boolean;
        static _OpacityTextureEnabled: boolean;
        static OpacityTextureEnabled: boolean;
        static _ReflectionTextureEnabled: boolean;
        static ReflectionTextureEnabled: boolean;
        static _EmissiveTextureEnabled: boolean;
        static EmissiveTextureEnabled: boolean;
        static _SpecularTextureEnabled: boolean;
        static SpecularTextureEnabled: boolean;
        static _BumpTextureEnabled: boolean;
        static BumpTextureEnabled: boolean;
        static _LightmapTextureEnabled: boolean;
        static LightmapTextureEnabled: boolean;
        static _RefractionTextureEnabled: boolean;
        static RefractionTextureEnabled: boolean;
        static _ColorGradingTextureEnabled: boolean;
        static ColorGradingTextureEnabled: boolean;
        static _FresnelEnabled: boolean;
        static FresnelEnabled: boolean;
    }
}

declare module BABYLON {
    class UniformBuffer {
        private _engine;
        private _buffer;
        private _data;
        private _bufferData;
        private _dynamic?;
        private _uniformLocations;
        private _uniformSizes;
        private _uniformLocationPointer;
        private _needSync;
        private _noUBO;
        private _currentEffect;
        private static _MAX_UNIFORM_SIZE;
        private static _tempBuffer;
        /**
         * Wrapper for updateUniform.
         * @method updateMatrix3x3
         * @param {string} name Name of the uniform, as used in the uniform block in the shader.
         * @param {Float32Array} matrix
         */
        updateMatrix3x3: (name: string, matrix: Float32Array) => void;
        /**
         * Wrapper for updateUniform.
         * @param {string} name Name of the uniform, as used in the uniform block in the shader.
         * @param {Float32Array} matrix
         */
        updateMatrix2x2: (name: string, matrix: Float32Array) => void;
        /**
         * Wrapper for updateUniform.
         * @param {string} name Name of the uniform, as used in the uniform block in the shader.
         * @param {number} x
         */
        updateFloat: (name: string, x: number) => void;
        /**
         * Wrapper for updateUniform.
         * @param {string} name Name of the uniform, as used in the uniform block in the shader.
         * @param {number} x
         * @param {number} y
         * @param {string} [suffix] Suffix to add to the uniform name.
         */
        updateFloat2: (name: string, x: number, y: number, suffix?: string) => void;
        /**
         * Wrapper for updateUniform.
         * @param {string} name Name of the uniform, as used in the uniform block in the shader.
         * @param {number} x
         * @param {number} y
         * @param {number} z
         * @param {string} [suffix] Suffix to add to the uniform name.
         */
        updateFloat3: (name: string, x: number, y: number, z: number, suffix?: string) => void;
        /**
         * Wrapper for updateUniform.
         * @param {string} name Name of the uniform, as used in the uniform block in the shader.
         * @param {number} x
         * @param {number} y
         * @param {number} z
         * @param {number} w
         * @param {string} [suffix] Suffix to add to the uniform name.
         */
        updateFloat4: (name: string, x: number, y: number, z: number, w: number, suffix?: string) => void;
        /**
         * Wrapper for updateUniform.
         * @param {string} name Name of the uniform, as used in the uniform block in the shader.
         * @param {Matrix} A 4x4 matrix.
         */
        updateMatrix: (name: string, mat: Matrix) => void;
        /**
         * Wrapper for updateUniform.
         * @param {string} name Name of the uniform, as used in the uniform block in the shader.
         * @param {Vector3} vector
         */
        updateVector3: (name: string, vector: Vector3) => void;
        /**
         * Wrapper for updateUniform.
         * @param {string} name Name of the uniform, as used in the uniform block in the shader.
         * @param {Vector4} vector
         */
        updateVector4: (name: string, vector: Vector4) => void;
        /**
         * Wrapper for updateUniform.
         * @param {string} name Name of the uniform, as used in the uniform block in the shader.
         * @param {Color3} color
         * @param {string} [suffix] Suffix to add to the uniform name.
         */
        updateColor3: (name: string, color: Color3, suffix?: string) => void;
        /**
         * Wrapper for updateUniform.
         * @param {string} name Name of the uniform, as used in the uniform block in the shader.
         * @param {Color3} color
         * @param {number} alpha
         * @param {string} [suffix] Suffix to add to the uniform name.
         */
        updateColor4: (name: string, color: Color3, alpha: number, suffix?: string) => void;
        /**
         * Uniform buffer objects.
         *
         * Handles blocks of uniform on the GPU.
         *
         * If WebGL 2 is not available, this class falls back on traditionnal setUniformXXX calls.
         *
         * For more information, please refer to :
         * https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object
         */
        constructor(engine: Engine, data?: number[], dynamic?: boolean);
        /**
         * Indicates if the buffer is using the WebGL2 UBO implementation,
         * or just falling back on setUniformXXX calls.
         */
        readonly useUbo: boolean;
        /**
         * Indicates if the WebGL underlying uniform buffer is in sync
         * with the javascript cache data.
         */
        readonly isSync: boolean;
        /**
         * Indicates if the WebGL underlying uniform buffer is dynamic.
         * Also, a dynamic UniformBuffer will disable cache verification and always
         * update the underlying WebGL uniform buffer to the GPU.
         */
        isDynamic(): boolean;
        /**
         * The data cache on JS side.
         */
        getData(): Float32Array;
        /**
         * The underlying WebGL Uniform buffer.
         */
        getBuffer(): Nullable<WebGLBuffer>;
        /**
         * std140 layout specifies how to align data within an UBO structure.
         * See https://khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf#page=159
         * for specs.
         */
        private _fillAlignment(size);
        /**
         * Adds an uniform in the buffer.
         * Warning : the subsequents calls of this function must be in the same order as declared in the shader
         * for the layout to be correct !
         * @param {string} name Name of the uniform, as used in the uniform block in the shader.
         * @param {number|number[]} size Data size, or data directly.
         */
        addUniform(name: string, size: number | number[]): void;
        /**
         * Wrapper for addUniform.
         * @param {string} name Name of the uniform, as used in the uniform block in the shader.
         * @param {Matrix} mat A 4x4 matrix.
         */
        addMatrix(name: string, mat: Matrix): void;
        /**
         * Wrapper for addUniform.
         * @param {string} name Name of the uniform, as used in the uniform block in the shader.
         * @param {number} x
         * @param {number} y
         */
        addFloat2(name: string, x: number, y: number): void;
        /**
         * Wrapper for addUniform.
         * @param {string} name Name of the uniform, as used in the uniform block in the shader.
         * @param {number} x
         * @param {number} y
         * @param {number} z
         */
        addFloat3(name: string, x: number, y: number, z: number): void;
        /**
         * Wrapper for addUniform.
         * @param {string} name Name of the uniform, as used in the uniform block in the shader.
         * @param {Color3} color
         */
        addColor3(name: string, color: Color3): void;
        /**
         * Wrapper for addUniform.
         * @param {string} name Name of the uniform, as used in the uniform block in the shader.
         * @param {Color3} color
         * @param {number} alpha
         */
        addColor4(name: string, color: Color3, alpha: number): void;
        /**
         * Wrapper for addUniform.
         * @param {string} name Name of the uniform, as used in the uniform block in the shader.
         * @param {Vector3} vector
         */
        addVector3(name: string, vector: Vector3): void;
        /**
         * Wrapper for addUniform.
         * @param {string} name Name of the uniform, as used in the uniform block in the shader.
         */
        addMatrix3x3(name: string): void;
        /**
         * Wrapper for addUniform.
         * @param {string} name Name of the uniform, as used in the uniform block in the shader.
         */
        addMatrix2x2(name: string): void;
        /**
         * Effectively creates the WebGL Uniform Buffer, once layout is completed with `addUniform`.
         */
        create(): void;
        _rebuild(): void;
        /**
         * Updates the WebGL Uniform Buffer on the GPU.
         * If the `dynamic` flag is set to true, no cache comparison is done.
         * Otherwise, the buffer will be updated only if the cache differs.
         */
        update(): void;
        /**
         * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.
         * @param {string} uniformName Name of the uniform, as used in the uniform block in the shader.
         * @param {number[]|Float32Array} data Flattened data
         * @param {number} size Size of the data.
         */
        updateUniform(uniformName: string, data: FloatArray, size: number): void;
        private _updateMatrix3x3ForUniform(name, matrix);
        private _updateMatrix3x3ForEffect(name, matrix);
        private _updateMatrix2x2ForEffect(name, matrix);
        private _updateMatrix2x2ForUniform(name, matrix);
        private _updateFloatForEffect(name, x);
        private _updateFloatForUniform(name, x);
        private _updateFloat2ForEffect(name, x, y, suffix?);
        private _updateFloat2ForUniform(name, x, y, suffix?);
        private _updateFloat3ForEffect(name, x, y, z, suffix?);
        private _updateFloat3ForUniform(name, x, y, z, suffix?);
        private _updateFloat4ForEffect(name, x, y, z, w, suffix?);
        private _updateFloat4ForUniform(name, x, y, z, w, suffix?);
        private _updateMatrixForEffect(name, mat);
        private _updateMatrixForUniform(name, mat);
        private _updateVector3ForEffect(name, vector);
        private _updateVector3ForUniform(name, vector);
        private _updateVector4ForEffect(name, vector);
        private _updateVector4ForUniform(name, vector);
        private _updateColor3ForEffect(name, color, suffix?);
        private _updateColor3ForUniform(name, color, suffix?);
        private _updateColor4ForEffect(name, color, alpha, suffix?);
        private _updateColor4ForUniform(name, color, alpha, suffix?);
        /**
         * Sets a sampler uniform on the effect.
         * @param {string} name Name of the sampler.
         * @param {Texture} texture
         */
        setTexture(name: string, texture: Nullable<BaseTexture>): void;
        /**
         * Directly updates the value of the uniform in the cache AND on the GPU.
         * @param {string} uniformName Name of the uniform, as used in the uniform block in the shader.
         * @param {number[]|Float32Array} data Flattened data
         */
        updateUniformDirectly(uniformName: string, data: FloatArray): void;
        /**
         * Binds this uniform buffer to an effect.
         * @param {Effect} effect
         * @param {string} name Name of the uniform block in the shader.
         */
        bindToEffect(effect: Effect, name: string): void;
        /**
         * Disposes the uniform buffer.
         */
        dispose(): void;
    }
}

declare module BABYLON {
    class Scalar {
        /**
         * Two pi constants convenient for computation.
         */
        static TwoPi: number;
        /**
         * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)
         */
        static WithinEpsilon(a: number, b: number, epsilon?: number): boolean;
        /**
         * Returns a string : the upper case translation of the number i to hexadecimal.
         */
        static ToHex(i: number): string;
        /**
         * Returns -1 if value is negative and +1 is value is positive.
         * Returns the value itself if it's equal to zero.
         */
        static Sign(value: number): number;
        /**
         * Returns the value itself if it's between min and max.
         * Returns min if the value is lower than min.
         * Returns max if the value is greater than max.
         */
        static Clamp(value: number, min?: number, max?: number): number;
        /**
         * Returns the log2 of value.
         */
        static Log2(value: number): number;
        /**
        * Loops the value, so that it is never larger than length and never smaller than 0.
        *
        * This is similar to the modulo operator but it works with floating point numbers.
        * For example, using 3.0 for t and 2.5 for length, the result would be 0.5.
        * With t = 5 and length = 2.5, the result would be 0.0.
        * Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator
        */
        static Repeat(value: number, length: number): number;
        /**
        * Normalize the value between 0.0 and 1.0 using min and max values
        */
        static Normalize(value: number, min: number, max: number): number;
        /**
        * Denormalize the value from 0.0 and 1.0 using min and max values
        */
        static Denormalize(normalized: number, min: number, max: number): number;
        /**
        * Calculates the shortest difference between two given angles given in degrees.
        */
        static DeltaAngle(current: number, target: number): number;
        /**
        * PingPongs the value t, so that it is never larger than length and never smaller than 0.
        *
        * The returned value will move back and forth between 0 and length
        */
        static PingPong(tx: number, length: number): number;
        /**
        * Interpolates between min and max with smoothing at the limits.
        *
        * This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up
        * from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.
        */
        static SmoothStep(from: number, to: number, tx: number): number;
        /**
        * Moves a value current towards target.
        *
        * This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.
        * Negative values of maxDelta pushes the value away from target.
        */
        static MoveTowards(current: number, target: number, maxDelta: number): number;
        /**
        * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.
        *
        * Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta
        *  are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.
        */
        static MoveTowardsAngle(current: number, target: number, maxDelta: number): number;
        /**
            * Creates a new scalar with values linearly interpolated of "amount" between the start scalar and the end scalar.
            */
        static Lerp(start: number, end: number, amount: number): number;
        /**
        * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.
        * The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.
        */
        static LerpAngle(start: number, end: number, amount: number): number;
        /**
        * Calculates the linear parameter t that produces the interpolant value within the range [a, b].
        */
        static InverseLerp(a: number, b: number, value: number): number;
        /**
         * Returns a new scalar located for "amount" (float) on the Hermite spline defined by the scalars "value1", "value3", "tangent1", "tangent2".
         */
        static Hermite(value1: number, tangent1: number, value2: number, tangent2: number, amount: number): number;
        /**
        * Returns a random float number between and min and max values
        */
        static RandomRange(min: number, max: number): number;
        /**
        * This function returns percentage of a number in a given range.
        *
        * RangeToPercent(40,20,60) will return 0.5 (50%)
        * RangeToPercent(34,0,100) will return 0.34 (34%)
        */
        static RangeToPercent(number: number, min: number, max: number): number;
        /**
        * This function returns number that corresponds to the percentage in a given range.
        *
        * PercentToRange(0.34,0,100) will return 34.
        */
        static PercentToRange(percent: number, min: number, max: number): number;
        /**
         * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.
         * @param angle The angle to normalize in radian.
         * @return The converted angle.
         */
        static NormalizeRadians(angle: number): number;
    }
}

declare module BABYLON {
    const ToGammaSpace: number;
    const ToLinearSpace = 2.2;
    const Epsilon = 0.001;
    /**
     * Class used to hold a RBG color
     */
    class Color3 {
        /**
         * Defines the red component (between 0 and 1, default is 0)
         */
        r: number;
        /**
         * Defines the green component (between 0 and 1, default is 0)
         */
        g: number;
        /**
         * Defines the blue component (between 0 and 1, default is 0)
         */
        b: number;
        /**
         * Creates a new Color3 object from red, green, blue values, all between 0 and 1
         * @param r defines the red component (between 0 and 1, default is 0)
         * @param g defines the green component (between 0 and 1, default is 0)
         * @param b defines the blue component (between 0 and 1, default is 0)
         */
        constructor(
            /**
             * Defines the red component (between 0 and 1, default is 0)
             */
            r?: number, 
            /**
             * Defines the green component (between 0 and 1, default is 0)
             */
            g?: number, 
            /**
             * Defines the blue component (between 0 and 1, default is 0)
             */
            b?: number);
        /**
         * Creates a string with the Color3 current values
         * @returns the string representation of the Color3 object
         */
        toString(): string;
        /**
         * Returns the string "Color3"
         * @returns "Color3"
         */
        getClassName(): string;
        /**
         * Compute the Color3 hash code
         * @returns an unique number that can be used to hash Color3 objects
         */
        getHashCode(): number;
        /**
         * Stores in the given array from the given starting index the red, green, blue values as successive elements
         * @param array defines the array where to store the r,g,b components
         * @param index defines an optional index in the target array to define where to start storing values
         * @returns the current Color3 object
         */
        toArray(array: FloatArray, index?: number): Color3;
        /**
         * Returns a new {BABYLON.Color4} object from the current Color3 and the given alpha
         * @param alpha defines the alpha component on the new {BABYLON.Color4} object (default is 1)
         * @returns a new {BABYLON.Color4} object
         */
        toColor4(alpha?: number): Color4;
        /**
         * Returns a new array populated with 3 numeric elements : red, green and blue values
         * @returns the new array
         */
        asArray(): number[];
        /**
         * Returns the luminance value
         * @returns a float value
         */
        toLuminance(): number;
        /**
         * Multiply each Color3 rgb values by the given Color3 rgb values in a new Color3 object
         * @param otherColor defines the second operand
         * @returns the new Color3 object
         */
        multiply(otherColor: Color3): Color3;
        /**
         * Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object "result"
         * @param otherColor defines the second operand
         * @param result defines the Color3 object where to store the result
         * @returns the current Color3
         */
        multiplyToRef(otherColor: Color3, result: Color3): Color3;
        /**
         * Determines equality between Color3 objects
         * @param otherColor defines the second operand
         * @returns true if the rgb values are equal to the given ones
         */
        equals(otherColor: Color3): boolean;
        /**
         * Determines equality between the current Color3 object and a set of r,b,g values
         * @param r defines the red component to check
         * @param g defines the green component to check
         * @param b defines the blue component to check
         * @returns true if the rgb values are equal to the given ones
         */
        equalsFloats(r: number, g: number, b: number): boolean;
        /**
         * Multiplies in place each rgb value by scale
         * @param scale defines the scaling factor
         * @returns the updated Color3
         */
        scale(scale: number): Color3;
        /**
         * Multiplies the rgb values by scale and stores the result into "result"
         * @param scale defines the scaling factor
         * @param result defines the Color3 object where to store the result
         * @returns the unmodified current Color3
         */
        scaleToRef(scale: number, result: Color3): Color3;
        /**
         * Scale the current Color3 values by a factor and add the result to a given Color3
         * @param scale defines the scale factor
         * @param result defines color to store the result into
         * @returns the unmodified current Color3
         */
        scaleAndAddToRef(scale: number, result: Color3): Color3;
        /**
         * Clamps the rgb values by the min and max values and stores the result into "result"
         * @param min defines minimum clamping value (default is 0)
         * @param max defines maximum clamping value (default is 1)
         * @param result defines color to store the result into
         * @returns the original Color3
         */
        clampToRef(min: number | undefined, max: number | undefined, result: Color3): Color3;
        /**
         * Creates a new Color3 set with the added values of the current Color3 and of the given one
         * @param otherColor defines the second operand
         * @returns the new Color3
         */
        add(otherColor: Color3): Color3;
        /**
         * Stores the result of the addition of the current Color3 and given one rgb values into "result"
         * @param otherColor defines the second operand
         * @param result defines Color3 object to store the result into
         * @returns the unmodified current Color3
         */
        addToRef(otherColor: Color3, result: Color3): Color3;
        /**
         * Returns a new Color3 set with the subtracted values of the given one from the current Color3
         * @param otherColor defines the second operand
         * @returns the new Color3
         */
        subtract(otherColor: Color3): Color3;
        /**
         * Stores the result of the subtraction of given one from the current Color3 rgb values into "result"
         * @param otherColor defines the second operand
         * @param result defines Color3 object to store the result into
         * @returns the unmodified current Color3
         */
        subtractToRef(otherColor: Color3, result: Color3): Color3;
        /**
         * Copy the current object
         * @returns a new Color3 copied the current one
         */
        clone(): Color3;
        /**
         * Copies the rgb values from the source in the current Color3
         * @param source defines the source Color3 object
         * @returns the updated Color3 object
         */
        copyFrom(source: Color3): Color3;
        /**
         * Updates the Color3 rgb values from the given floats
         * @param r defines the red component to read from
         * @param g defines the green component to read from
         * @param b defines the blue component to read from
         * @returns the current Color3 object
         */
        copyFromFloats(r: number, g: number, b: number): Color3;
        /**
         * Updates the Color3 rgb values from the given floats
         * @param r defines the red component to read from
         * @param g defines the green component to read from
         * @param b defines the blue component to read from
         * @returns the current Color3 object
         */
        set(r: number, g: number, b: number): Color3;
        /**
         * Compute the Color3 hexadecimal code as a string
         * @returns a string containing the hexadecimal representation of the Color3 object
         */
        toHexString(): string;
        /**
         * Computes a new Color3 converted from the current one to linear space
         * @returns a new Color3 object
         */
        toLinearSpace(): Color3;
        /**
         * Converts the Color3 values to linear space and stores the result in "convertedColor"
         * @param convertedColor defines the Color3 object where to store the linear space version
         * @returns the unmodified Color3
         */
        toLinearSpaceToRef(convertedColor: Color3): Color3;
        /**
         * Computes a new Color3 converted from the current one to gamma space
         * @returns a new Color3 object
         */
        toGammaSpace(): Color3;
        /**
         * Converts the Color3 values to gamma space and stores the result in "convertedColor"
         * @param convertedColor defines the Color3 object where to store the gamma space version
         * @returns the unmodified Color3
         */
        toGammaSpaceToRef(convertedColor: Color3): Color3;
        /**
         * Creates a new Color3 from the string containing valid hexadecimal values
         * @param hex defines a string containing valid hexadecimal values
         * @returns a new Color3 object
         */
        static FromHexString(hex: string): Color3;
        /**
         * Creates a new Vector3 from the starting index of the given array
         * @param array defines the source array
         * @param offset defines an offset in the source array
         * @returns a new Color3 object
         */
        static FromArray(array: ArrayLike<number>, offset?: number): Color3;
        /**
         * Creates a new Color3 from integer values (< 256)
         * @param r defines the red component to read from (value between 0 and 255)
         * @param g defines the green component to read from (value between 0 and 255)
         * @param b defines the blue component to read from (value between 0 and 255)
         * @returns a new Color3 object
         */
        static FromInts(r: number, g: number, b: number): Color3;
        /**
         * Creates a new Color3 with values linearly interpolated of "amount" between the start Color3 and the end Color3
         * @param start defines the start Color3 value
         * @param end defines the end Color3 value
         * @param amount defines the gradient value between start and end
         * @returns a new Color3 object
         */
        static Lerp(start: Color3, end: Color3, amount: number): Color3;
        /**
         * Returns a Color3 value containing a red color
         * @returns a new Color3 object
         */
        static Red(): Color3;
        /**
         * Returns a Color3 value containing a green color
         * @returns a new Color3 object
         */
        static Green(): Color3;
        /**
         * Returns a Color3 value containing a blue color
         * @returns a new Color3 object
         */
        static Blue(): Color3;
        /**
         * Returns a Color3 value containing a black color
         * @returns a new Color3 object
         */
        static Black(): Color3;
        /**
         * Returns a Color3 value containing a white color
         * @returns a new Color3 object
         */
        static White(): Color3;
        /**
         * Returns a Color3 value containing a purple color
         * @returns a new Color3 object
         */
        static Purple(): Color3;
        /**
         * Returns a Color3 value containing a magenta color
         * @returns a new Color3 object
         */
        static Magenta(): Color3;
        /**
         * Returns a Color3 value containing a yellow color
         * @returns a new Color3 object
         */
        static Yellow(): Color3;
        /**
         * Returns a Color3 value containing a gray color
         * @returns a new Color3 object
         */
        static Gray(): Color3;
        /**
         * Returns a Color3 value containing a teal color
         * @returns a new Color3 object
         */
        static Teal(): Color3;
        /**
         * Returns a Color3 value containing a random color
         * @returns a new Color3 object
         */
        static Random(): Color3;
    }
    /**
     * Class used to hold a RBGA color
     */
    class Color4 {
        /**
         * Defines the red component (between 0 and 1, default is 0)
         */
        r: number;
        /**
         * Defines the green component (between 0 and 1, default is 0)
         */
        g: number;
        /**
         * Defines the blue component (between 0 and 1, default is 0)
         */
        b: number;
        /**
         * Defines the alpha component (between 0 and 1, default is 1)
         */
        a: number;
        /**
         * Creates a new Color4 object from red, green, blue values, all between 0 and 1
         * @param r defines the red component (between 0 and 1, default is 0)
         * @param g defines the green component (between 0 and 1, default is 0)
         * @param b defines the blue component (between 0 and 1, default is 0)
         * @param a defines the alpha component (between 0 and 1, default is 1)
         */
        constructor(
            /**
             * Defines the red component (between 0 and 1, default is 0)
             */
            r?: number, 
            /**
             * Defines the green component (between 0 and 1, default is 0)
             */
            g?: number, 
            /**
             * Defines the blue component (between 0 and 1, default is 0)
             */
            b?: number, 
            /**
             * Defines the alpha component (between 0 and 1, default is 1)
             */
            a?: number);
        /**
         * Adds in place the given Color4 values to the current Color4 object
         * @param right defines the second operand
         * @returns the current updated Color4 object
         */
        addInPlace(right: Color4): Color4;
        /**
         * Creates a new array populated with 4 numeric elements : red, green, blue, alpha values
         * @returns the new array
         */
        asArray(): number[];
        /**
         * Stores from the starting index in the given array the Color4 successive values
         * @param array defines the array where to store the r,g,b components
         * @param index defines an optional index in the target array to define where to start storing values
         * @returns the current Color4 object
         */
        toArray(array: number[], index?: number): Color4;
        /**
         * Creates a new Color4 set with the added values of the current Color4 and of the given one
         * @param right defines the second operand
         * @returns a new Color4 object
         */
        add(right: Color4): Color4;
        /**
         * Creates a new Color4 set with the subtracted values of the given one from the current Color4
         * @param right defines the second operand
         * @returns a new Color4 object
         */
        subtract(right: Color4): Color4;
        /**
         * Subtracts the given ones from the current Color4 values and stores the results in "result"
         * @param right defines the second operand
         * @param result defines the Color4 object where to store the result
         * @returns the current Color4 object
         */
        subtractToRef(right: Color4, result: Color4): Color4;
        /**
         * Creates a new Color4 with the current Color4 values multiplied by scale
         * @param scale defines the scaling factor to apply
         * @returns a new Color4 object
         */
        scale(scale: number): Color4;
        /**
         * Multiplies the current Color4 values by scale and stores the result in "result"
         * @param scale defines the scaling factor to apply
         * @param result defines the Color4 object where to store the result
         * @returns the current unmodified Color4
         */
        scaleToRef(scale: number, result: Color4): Color4;
        /**
         * Scale the current Color4 values by a factor and add the result to a given Color4
         * @param scale defines the scale factor
         * @param result defines the Color4 object where to store the result
         * @returns the unmodified current Color4
         */
        scaleAndAddToRef(scale: number, result: Color4): Color4;
        /**
         * Clamps the rgb values by the min and max values and stores the result into "result"
         * @param min defines minimum clamping value (default is 0)
         * @param max defines maximum clamping value (default is 1)
         * @param result defines color to store the result into.
         * @returns the cuurent Color4
         */
        clampToRef(min: number | undefined, max: number | undefined, result: Color4): Color4;
        /**
          * Multipy an Color4 value by another and return a new Color4 object
          * @param color defines the Color4 value to multiply by
          * @returns a new Color4 object
          */
        multiply(color: Color4): Color4;
        /**
         * Multipy a Color4 value by another and push the result in a reference value
         * @param color defines the Color4 value to multiply by
         * @param result defines the Color4 to fill the result in
         * @returns the result Color4
         */
        multiplyToRef(color: Color4, result: Color4): Color4;
        /**
         * Creates a string with the Color4 current values
         * @returns the string representation of the Color4 object
         */
        toString(): string;
        /**
         * Returns the string "Color4"
         * @returns "Color4"
         */
        getClassName(): string;
        /**
         * Compute the Color4 hash code
         * @returns an unique number that can be used to hash Color4 objects
         */
        getHashCode(): number;
        /**
         * Creates a new Color4 copied from the current one
         * @returns a new Color4 object
         */
        clone(): Color4;
        /**
         * Copies the given Color4 values into the current one
         * @param source defines the source Color4 object
         * @returns the current updated Color4 object
         */
        copyFrom(source: Color4): Color4;
        /**
         * Copies the given float values into the current one
         * @param r defines the red component to read from
         * @param g defines the green component to read from
         * @param b defines the blue component to read from
         * @param a defines the alpha component to read from
         * @returns the current updated Color4 object
         */
        copyFromFloats(r: number, g: number, b: number, a: number): Color4;
        /**
         * Copies the given float values into the current one
         * @param r defines the red component to read from
         * @param g defines the green component to read from
         * @param b defines the blue component to read from
         * @param a defines the alpha component to read from
         * @returns the current updated Color4 object
         */
        set(r: number, g: number, b: number, a: number): Color4;
        /**
         * Compute the Color4 hexadecimal code as a string
         * @returns a string containing the hexadecimal representation of the Color4 object
         */
        toHexString(): string;
        /**
         * Computes a new Color4 converted from the current one to linear space
         * @returns a new Color4 object
         */
        toLinearSpace(): Color4;
        /**
         * Converts the Color4 values to linear space and stores the result in "convertedColor"
         * @param convertedColor defines the Color4 object where to store the linear space version
         * @returns the unmodified Color4
         */
        toLinearSpaceToRef(convertedColor: Color4): Color4;
        /**
         * Computes a new Color4 converted from the current one to gamma space
         * @returns a new Color4 object
         */
        toGammaSpace(): Color4;
        /**
         * Converts the Color4 values to gamma space and stores the result in "convertedColor"
         * @param convertedColor defines the Color4 object where to store the gamma space version
         * @returns the unmodified Color4
         */
        toGammaSpaceToRef(convertedColor: Color4): Color4;
        /**
         * Creates a new Color4 from the string containing valid hexadecimal values
         * @param hex defines a string containing valid hexadecimal values
         * @returns a new Color4 object
         */
        static FromHexString(hex: string): Color4;
        /**
         * Creates a new Color4 object set with the linearly interpolated values of "amount" between the left Color4 object and the right Color4 object
         * @param left defines the start value
         * @param right defines the end value
         * @param amount defines the gradient factor
         * @returns a new Color4 object
         */
        static Lerp(left: Color4, right: Color4, amount: number): Color4;
        /**
         * Set the given "result" with the linearly interpolated values of "amount" between the left Color4 object and the right Color4 object
         * @param left defines the start value
         * @param right defines the end value
         * @param amount defines the gradient factor
         * @param result defines the Color4 object where to store data
         */
        static LerpToRef(left: Color4, right: Color4, amount: number, result: Color4): void;
        /**
         * Creates a new Color4 from the starting index element of the given array
         * @param array defines the source array to read from
         * @param offset defines the offset in the source array
         * @returns a new Color4 object
         */
        static FromArray(array: ArrayLike<number>, offset?: number): Color4;
        /**
         * Creates a new Color3 from integer values (< 256)
         * @param r defines the red component to read from (value between 0 and 255)
         * @param g defines the green component to read from (value between 0 and 255)
         * @param b defines the blue component to read from (value between 0 and 255)
         * @param a defines the alpha component to read from (value between 0 and 255)
         * @returns a new Color3 object
         */
        static FromInts(r: number, g: number, b: number, a: number): Color4;
        /**
         * Check the content of a given array and convert it to an array containing RGBA data
         * If the original array was already containing count * 4 values then it is returned directly
         * @param colors defines the array to check
         * @param count defines the number of RGBA data to expect
         * @returns an array containing count * 4 values (RGBA)
         */
        static CheckColors4(colors: number[], count: number): number[];
    }
    /**
     * Class representing a vector containing 2 coordinates
     */
    class Vector2 {
        /** defines the first coordinate */
        x: number;
        /** defines the second coordinate */
        y: number;
        /**
         * Creates a new Vector2 from the given x and y coordinates
         * @param x defines the first coordinate
         * @param y defines the second coordinate
         */
        constructor(
            /** defines the first coordinate */
            x: number, 
            /** defines the second coordinate */
            y: number);
        /**
         * Gets a string with the Vector2 coordinates
         * @returns a string with the Vector2 coordinates
         */
        toString(): string;
        /**
         * Gets class name
         * @returns the string "Vector2"
         */
        getClassName(): string;
        /**
         * Gets current vector hash code
         * @returns the Vector2 hash code as a number
         */
        getHashCode(): number;
        /**
         * Sets the Vector2 coordinates in the given array or Float32Array from the given index.
         * @param array defines the source array
         * @param index defines the offset in source array
         * @returns the current Vector2
         */
        toArray(array: FloatArray, index?: number): Vector2;
        /**
         * Copy the current vector to an array
         * @returns a new array with 2 elements: the Vector2 coordinates.
         */
        asArray(): number[];
        /**
         * Sets the Vector2 coordinates with the given Vector2 coordinates
         * @param source defines the source Vector2
         * @returns the current updated Vector2
         */
        copyFrom(source: Vector2): Vector2;
        /**
         * Sets the Vector2 coordinates with the given floats
         * @param x defines the first coordinate
         * @param y defines the second coordinate
         * @returns the current updated Vector2
         */
        copyFromFloats(x: number, y: number): Vector2;
        /**
         * Sets the Vector2 coordinates with the given floats
         * @param x defines the first coordinate
         * @param y defines the second coordinate
         * @returns the current updated Vector2
         */
        set(x: number, y: number): Vector2;
        /**
         * Add another vector with the current one
         * @param otherVector defines the other vector
         * @returns a new Vector2 set with the addition of the current Vector2 and the given one coordinates
         */
        add(otherVector: Vector2): Vector2;
        /**
         * Sets the "result" coordinates with the addition of the current Vector2 and the given one coordinates
         * @param otherVector defines the other vector
         * @param result defines the target vector
         * @returns the unmodified current Vector2
         */
        addToRef(otherVector: Vector2, result: Vector2): Vector2;
        /**
         * Set the Vector2 coordinates by adding the given Vector2 coordinates
         * @param otherVector defines the other vector
         * @returns the current updated Vector2
         */
        addInPlace(otherVector: Vector2): Vector2;
        /**
         * Gets a new Vector2 by adding the current Vector2 coordinates to the given Vector3 x, y coordinates
         * @param otherVector defines the other vector
         * @returns a new Vector2
         */
        addVector3(otherVector: Vector3): Vector2;
        /**
         * Gets a new Vector2 set with the subtracted coordinates of the given one from the current Vector2
         * @param otherVector defines the other vector
         * @returns a new Vector2
         */
        subtract(otherVector: Vector2): Vector2;
        /**
         * Sets the "result" coordinates with the subtraction of the given one from the current Vector2 coordinates.
         * @param otherVector defines the other vector
         * @param result defines the target vector
         * @returns the unmodified current Vector2
         */
        subtractToRef(otherVector: Vector2, result: Vector2): Vector2;
        /**
         * Sets the current Vector2 coordinates by subtracting from it the given one coordinates
         * @param otherVector defines the other vector
         * @returns the current updated Vector2
         */
        subtractInPlace(otherVector: Vector2): Vector2;
        /**
         * Multiplies in place the current Vector2 coordinates by the given ones
         * @param otherVector defines the other vector
         * @returns the current updated Vector2
         */
        multiplyInPlace(otherVector: Vector2): Vector2;
        /**
         * Returns a new Vector2 set with the multiplication of the current Vector2 and the given one coordinates
         * @param otherVector defines the other vector
         * @returns a new Vector2
         */
        multiply(otherVector: Vector2): Vector2;
        /**
         * Sets "result" coordinates with the multiplication of the current Vector2 and the given one coordinates
         * @param otherVector defines the other vector
         * @param result defines the target vector
         * @returns the unmodified current Vector2
         */
        multiplyToRef(otherVector: Vector2, result: Vector2): Vector2;
        /**
         * Gets a new Vector2 set with the Vector2 coordinates multiplied by the given floats
         * @param x defines the first coordinate
         * @param y defines the second coordinate
         * @returns a new Vector2
         */
        multiplyByFloats(x: number, y: number): Vector2;
        /**
         * Returns a new Vector2 set with the Vector2 coordinates divided by the given one coordinates
         * @param otherVector defines the other vector
         * @returns a new Vector2
         */
        divide(otherVector: Vector2): Vector2;
        /**
         * Sets the "result" coordinates with the Vector2 divided by the given one coordinates
         * @param otherVector defines the other vector
         * @param result defines the target vector
         * @returns the unmodified current Vector2
         */
        divideToRef(otherVector: Vector2, result: Vector2): Vector2;
        /**
         * Divides the current Vector3 coordinates by the given ones
         * @param otherVector defines the other vector
         * @returns the current updated Vector2
         */
        divideInPlace(otherVector: Vector2): Vector2;
        /**
         * Gets a new Vector2 with current Vector2 negated coordinates
         * @returns a new Vector2
         */
        negate(): Vector2;
        /**
         * Multiply the Vector2 coordinates by scale
         * @param scale defines the scaling factor
         * @returns the current updated Vector2
         */
        scaleInPlace(scale: number): Vector2;
        /**
         * Returns a new Vector2 scaled by "scale" from the current Vector2
         * @param scale defines the scaling factor
         * @returns a new Vector2
         */
        scale(scale: number): Vector2;
        /**
         * Scale the current Vector2 values by a factor to a given Vector2
         * @param scale defines the scale factor
         * @param result defines the Vector2 object where to store the result
         * @returns the unmodified current Vector2
         */
        scaleToRef(scale: number, result: Vector2): Vector2;
        /**
         * Scale the current Vector2 values by a factor and add the result to a given Vector2
         * @param scale defines the scale factor
         * @param result defines the Vector2 object where to store the result
         * @returns the unmodified current Vector2
         */
        scaleAndAddToRef(scale: number, result: Vector2): Vector2;
        /**
         * Gets a boolean if two vectors are equals
         * @param otherVector defines the other vector
         * @returns true if the given vector coordinates strictly equal the current Vector2 ones
         */
        equals(otherVector: Vector2): boolean;
        /**
         * Gets a boolean if two vectors are equals (using an epsilon value)
         * @param otherVector defines the other vector
         * @param epsilon defines the minimal distance to consider equality
         * @returns true if the given vector coordinates are close to the current ones by a distance of epsilon.
         */
        equalsWithEpsilon(otherVector: Vector2, epsilon?: number): boolean;
        /**
         * Gets the length of the vector
         * @returns the vector length (float)
         */
        length(): number;
        /**
         * Gets the vector squared length
         * @returns the vector squared length (float)
         */
        lengthSquared(): number;
        /**
         * Normalize the vector
         * @returns the current updated Vector2
         */
        normalize(): Vector2;
        /**
         * Gets a new Vector2 copied from the Vector2
         * @returns a new Vector2
         */
        clone(): Vector2;
        /**
         * Gets a new Vector2(0, 0)
         * @returns a new Vector2
         */
        static Zero(): Vector2;
        /**
         * Gets a new Vector2(1, 1)
         * @returns a new Vector2
         */
        static One(): Vector2;
        /**
         * Gets a new Vector2 set from the given index element of the given array
         * @param array defines the data source
         * @param offset defines the offset in the data source
         * @returns a new Vector2
         */
        static FromArray(array: ArrayLike<number>, offset?: number): Vector2;
        /**
         * Sets "result" from the given index element of the given array
         * @param array defines the data source
         * @param offset defines the offset in the data source
         * @param result defines the target vector
         */
        static FromArrayToRef(array: ArrayLike<number>, offset: number, result: Vector2): void;
        /**
         * Gets a new Vector2 located for "amount" (float) on the CatmullRom spline defined by the given four Vector2
         * @param value1 defines 1st point of control
         * @param value2 defines 2nd point of control
         * @param value3 defines 3rd point of control
         * @param value4 defines 4th point of control
         * @param amount defines the interpolation factor
         * @returns a new Vector2
         */
        static CatmullRom(value1: Vector2, value2: Vector2, value3: Vector2, value4: Vector2, amount: number): Vector2;
        /**
         * Returns a new Vector2 set with same the coordinates than "value" ones if the vector "value" is in the square defined by "min" and "max".
         * If a coordinate of "value" is lower than "min" coordinates, the returned Vector2 is given this "min" coordinate.
         * If a coordinate of "value" is greater than "max" coordinates, the returned Vector2 is given this "max" coordinate
         * @param value defines the value to clamp
         * @param min defines the lower limit
         * @param max defines the upper limit
         * @returns a new Vector2
         */
        static Clamp(value: Vector2, min: Vector2, max: Vector2): Vector2;
        /**
         * Returns a new Vector2 located for "amount" (float) on the Hermite spline defined by the vectors "value1", "value3", "tangent1", "tangent2"
         * @param value1 defines the 1st control point
         * @param tangent1 defines the outgoing tangent
         * @param value2 defines the 2nd control point
         * @param tangent2 defines the incoming tangent
         * @param amount defines the interpolation factor
         * @returns a new Vector2
         */
        static Hermite(value1: Vector2, tangent1: Vector2, value2: Vector2, tangent2: Vector2, amount: number): Vector2;
        /**
         * Returns a new Vector2 located for "amount" (float) on the linear interpolation between the vector "start" adn the vector "end".
         * @param start defines the start vector
         * @param end defines the end vector
         * @param amount defines the interpolation factor
         * @returns a new Vector2
         */
        static Lerp(start: Vector2, end: Vector2, amount: number): Vector2;
        /**
         * Gets the dot product of the vector "left" and the vector "right"
         * @param left defines first vector
         * @param right defines second vector
         * @returns the dot product (float)
         */
        static Dot(left: Vector2, right: Vector2): number;
        /**
         * Returns a new Vector2 equal to the normalized given vector
         * @param vector defines the vector to normalize
         * @returns a new Vector2
         */
        static Normalize(vector: Vector2): Vector2;
        /**
         * Gets a new Vector2 set with the minimal coordinate values from the "left" and "right" vectors
         * @param left defines 1st vector
         * @param right defines 2nd vector
         * @returns a new Vector2
         */
        static Minimize(left: Vector2, right: Vector2): Vector2;
        /**
         * Gets a new Vecto2 set with the maximal coordinate values from the "left" and "right" vectors
         * @param left defines 1st vector
         * @param right defines 2nd vector
         * @returns a new Vector2
         */
        static Maximize(left: Vector2, right: Vector2): Vector2;
        /**
         * Gets a new Vector2 set with the transformed coordinates of the given vector by the given transformation matrix
         * @param vector defines the vector to transform
         * @param transformation defines the matrix to apply
         * @returns a new Vector2
         */
        static Transform(vector: Vector2, transformation: Matrix): Vector2;
        /**
         * Transforms the given vector coordinates by the given transformation matrix and stores the result in the vector "result" coordinates
         * @param vector defines the vector to transform
         * @param transformation defines the matrix to apply
         * @param result defines the target vector
         */
        static TransformToRef(vector: Vector2, transformation: Matrix, result: Vector2): void;
        /**
         * Determines if a given vector is included in a triangle
         * @param p defines the vector to test
         * @param p0 defines 1st triangle point
         * @param p1 defines 2nd triangle point
         * @param p2 defines 3rd triangle point
         * @returns true if the point "p" is in the triangle defined by the vertors "p0", "p1", "p2"
         */
        static PointInTriangle(p: Vector2, p0: Vector2, p1: Vector2, p2: Vector2): boolean;
        /**
         * Gets the distance between the vectors "value1" and "value2"
         * @param value1 defines first vector
         * @param value2 defines second vector
         * @returns the distance between vectors
         */
        static Distance(value1: Vector2, value2: Vector2): number;
        /**
         * Returns the squared distance between the vectors "value1" and "value2"
         * @param value1 defines first vector
         * @param value2 defines second vector
         * @returns the squared distance between vectors
         */
        static DistanceSquared(value1: Vector2, value2: Vector2): number;
        /**
         * Gets a new Vector2 located at the center of the vectors "value1" and "value2"
         * @param value1 defines first vector
         * @param value2 defines second vector
         * @returns a new Vector2
         */
        static Center(value1: Vector2, value2: Vector2): Vector2;
        /**
         * Gets the shortest distance (float) between the point "p" and the segment defined by the two points "segA" and "segB".
         * @param p defines the middle point
         * @param segA defines one point of the segment
         * @param segB defines the other point of the segment
         * @returns the shortest distance
         */
        static DistanceOfPointFromSegment(p: Vector2, segA: Vector2, segB: Vector2): number;
    }
    /**
     * Classed used to store (x,y,z) vector representation
     * A Vector3 is the main object used in 3D geometry
     * It can represent etiher the coordinates of a point the space, either a direction
     * Reminder: Babylon.js uses a left handed forward facing system
     */
    class Vector3 {
        /**
         * Defines the first coordinates (on X axis)
         */
        x: number;
        /**
         * Defines the second coordinates (on Y axis)
         */
        y: number;
        /**
         * Defines the third coordinates (on Z axis)
         */
        z: number;
        /**
         * Creates a new Vector3 object from the given x, y, z (floats) coordinates.
         * @param x defines the first coordinates (on X axis)
         * @param y defines the second coordinates (on Y axis)
         * @param z defines the third coordinates (on Z axis)
         */
        constructor(
            /**
             * Defines the first coordinates (on X axis)
             */
            x: number, 
            /**
             * Defines the second coordinates (on Y axis)
             */
            y: number, 
            /**
             * Defines the third coordinates (on Z axis)
             */
            z: number);
        /**
         * Creates a string representation of the Vector3
         * @returns a string with the Vector3 coordinates.
         */
        toString(): string;
        /**
         * Gets the class name
         * @returns the string "Vector3"
         */
        getClassName(): string;
        /**
         * Creates the Vector3 hash code
         * @returns a number which tends to be unique between Vector3 instances
         */
        getHashCode(): number;
        /**
         * Creates an array containing three elements : the coordinates of the Vector3
         * @returns a new array of numbers
         */
        asArray(): number[];
        /**
         * Populates the given array or Float32Array from the given index with the successive coordinates of the Vector3
         * @param array defines the destination array
         * @param index defines the offset in the destination array
         * @returns the current Vector3
         */
        toArray(array: FloatArray, index?: number): Vector3;
        /**
         * Converts the current Vector3 into a quaternion (considering that the Vector3 contains Euler angles representation of a rotation)
         * @returns a new Quaternion object, computed from the Vector3 coordinates
         */
        toQuaternion(): Quaternion;
        /**
         * Adds the given vector to the current Vector3
         * @param otherVector defines the second operand
         * @returns the current updated Vector3
         */
        addInPlace(otherVector: Vector3): Vector3;
        /**
         * Gets a new Vector3, result of the addition the current Vector3 and the given vector
         * @param otherVector defines the second operand
         * @returns the resulting Vector3
         */
        add(otherVector: Vector3): Vector3;
        /**
         * Adds the current Vector3 to the given one and stores the result in the vector "result"
         * @param otherVector defines the second operand
         * @param result defines the Vector3 object where to store the result
         * @returns the current Vector3
         */
        addToRef(otherVector: Vector3, result: Vector3): Vector3;
        /**
         * Subtract the given vector from the current Vector3
         * @param otherVector defines the second operand
         * @returns the current updated Vector3
         */
        subtractInPlace(otherVector: Vector3): Vector3;
        /**
         * Returns a new Vector3, result of the subtraction of the given vector from the current Vector3
         * @param otherVector defines the second operand
         * @returns the resulting Vector3
         */
        subtract(otherVector: Vector3): Vector3;
        /**
         * Subtracts the given vector from the current Vector3 and stores the result in the vector "result".
         * @param otherVector defines the second operand
         * @param result defines the Vector3 object where to store the result
         * @returns the current Vector3
         */
        subtractToRef(otherVector: Vector3, result: Vector3): Vector3;
        /**
         * Returns a new Vector3 set with the subtraction of the given floats from the current Vector3 coordinates
         * @param x defines the x coordinate of the operand
         * @param y defines the y coordinate of the operand
         * @param z defines the z coordinate of the operand
         * @returns the resulting Vector3
         */
        subtractFromFloats(x: number, y: number, z: number): Vector3;
        /**
         * Subtracts the given floats from the current Vector3 coordinates and set the given vector "result" with this result
         * @param x defines the x coordinate of the operand
         * @param y defines the y coordinate of the operand
         * @param z defines the z coordinate of the operand
         * @param result defines the Vector3 object where to store the result
         * @returns the current Vector3
         */
        subtractFromFloatsToRef(x: number, y: number, z: number, result: Vector3): Vector3;
        /**
         * Gets a new Vector3 set with the current Vector3 negated coordinates
         * @returns a new Vector3
         */
        negate(): Vector3;
        /**
         * Multiplies the Vector3 coordinates by the float "scale"
         * @param scale defines the multiplier factor
         * @returns the current updated Vector3
         */
        scaleInPlace(scale: number): Vector3;
        /**
         * Returns a new Vector3 set with the current Vector3 coordinates multiplied by the float "scale"
         * @param scale defines the multiplier factor
         * @returns a new Vector3
         */
        scale(scale: number): Vector3;
        /**
         * Multiplies the current Vector3 coordinates by the float "scale" and stores the result in the given vector "result" coordinates
         * @param scale defines the multiplier factor
         * @param result defines the Vector3 object where to store the result
         * @returns the current Vector3
         */
        scaleToRef(scale: number, result: Vector3): Vector3;
        /**
         * Scale the current Vector3 values by a factor and add the result to a given Vector3
         * @param scale defines the scale factor
         * @param result defines the Vector3 object where to store the result
         * @returns the unmodified current Vector3
         */
        scaleAndAddToRef(scale: number, result: Vector3): Vector3;
        /**
         * Returns true if the current Vector3 and the given vector coordinates are strictly equal
         * @param otherVector defines the second operand
         * @returns true if both vectors are equals
         */
        equals(otherVector: Vector3): boolean;
        /**
         * Returns true if the current Vector3 and the given vector coordinates are distant less than epsilon
         * @param otherVector defines the second operand
         * @param epsilon defines the minimal distance to define values as equals
         * @returns true if both vectors are distant less than epsilon
         */
        equalsWithEpsilon(otherVector: Vector3, epsilon?: number): boolean;
        /**
         * Returns true if the current Vector3 coordinates equals the given floats
         * @param x defines the x coordinate of the operand
         * @param y defines the y coordinate of the operand
         * @param z defines the z coordinate of the operand
         * @returns true if both vectors are equals
         */
        equalsToFloats(x: number, y: number, z: number): boolean;
        /**
         * Multiplies the current Vector3 coordinates by the given ones
         * @param otherVector defines the second operand
         * @returns the current updated Vector3
         */
        multiplyInPlace(otherVector: Vector3): Vector3;
        /**
         * Returns a new Vector3, result of the multiplication of the current Vector3 by the given vector
         * @param otherVector defines the second operand
         * @returns the new Vector3
         */
        multiply(otherVector: Vector3): Vector3;
        /**
         * Multiplies the current Vector3 by the given one and stores the result in the given vector "result"
         * @param otherVector defines the second operand
         * @param result defines the Vector3 object where to store the result
         * @returns the current Vector3
         */
        multiplyToRef(otherVector: Vector3, result: Vector3): Vector3;
        /**
         * Returns a new Vector3 set with the result of the mulliplication of the current Vector3 coordinates by the given floats
         * @param x defines the x coordinate of the operand
         * @param y defines the y coordinate of the operand
         * @param z defines the z coordinate of the operand
         * @returns the new Vector3
         */
        multiplyByFloats(x: number, y: number, z: number): Vector3;
        /**
         * Returns a new Vector3 set with the result of the division of the current Vector3 coordinates by the given ones
         * @param otherVector defines the second operand
         * @returns the new Vector3
         */
        divide(otherVector: Vector3): Vector3;
        /**
         * Divides the current Vector3 coordinates by the given ones and stores the result in the given vector "result"
         * @param otherVector defines the second operand
         * @param result defines the Vector3 object where to store the result
         * @returns the current Vector3
         */
        divideToRef(otherVector: Vector3, result: Vector3): Vector3;
        /**
         * Divides the current Vector3 coordinates by the given ones.
         * @param otherVector defines the second operand
         * @returns the current updated Vector3
         */
        divideInPlace(otherVector: Vector3): Vector3;
        /**
         * Updates the current Vector3 with the minimal coordinate values between its and the given vector ones
         * @param other defines the second operand
         * @returns the current updated Vector3
         */
        minimizeInPlace(other: Vector3): Vector3;
        /**
         * Updates the current Vector3 with the maximal coordinate values between its and the given vector ones.
         * @param other defines the second operand
         * @returns the current updated Vector3
         */
        maximizeInPlace(other: Vector3): Vector3;
        /**
         * Gets a boolean indicating that the vector is non uniform meaning x, y or z are not all the same
         */
        readonly isNonUniform: boolean;
        /**
         * Gets the length of the Vector3
         * @returns the length of the Vecto3
         */
        length(): number;
        /**
         * Gets the squared length of the Vector3
         * @returns squared length of the Vector3
         */
        lengthSquared(): number;
        /**
         * Normalize the current Vector3.
         * Please note that this is an in place operation.
         * @returns the current updated Vector3
         */
        normalize(): Vector3;
        /**
         * Normalize the current Vector3 to a new vector
         * @returns the new Vector3
         */
        normalizeToNew(): Vector3;
        /**
         * Normalize the current Vector3 to the reference
         * @param reference define the Vector3 to update
         * @returns the updated Vector3
         */
        normalizeToRef(reference: Vector3): Vector3;
        /**
         * Creates a new Vector3 copied from the current Vector3
         * @returns the new Vector3
         */
        clone(): Vector3;
        /**
         * Copies the given vector coordinates to the current Vector3 ones
         * @param source defines the source Vector3
         * @returns the current updated Vector3
         */
        copyFrom(source: Vector3): Vector3;
        /**
         * Copies the given floats to the current Vector3 coordinates
         * @param x defines the x coordinate of the operand
         * @param y defines the y coordinate of the operand
         * @param z defines the z coordinate of the operand
         * @returns the current updated Vector3
         */
        copyFromFloats(x: number, y: number, z: number): Vector3;
        /**
         * Copies the given floats to the current Vector3 coordinates
         * @param x defines the x coordinate of the operand
         * @param y defines the y coordinate of the operand
         * @param z defines the z coordinate of the operand
         * @returns the current updated Vector3
         */
        set(x: number, y: number, z: number): Vector3;
        /**
         * Get the clip factor between two vectors
         * @param vector0 defines the first operand
         * @param vector1 defines the second operand
         * @param axis defines the axis to use
         * @param size defines the size along the axis
         * @returns the clip factor
         */
        static GetClipFactor(vector0: Vector3, vector1: Vector3, axis: Vector3, size: number): number;
        /**
         * Get angle between two vectors
         * @param vector0 angle between vector0 and vector1
         * @param vector1 angle between vector0 and vector1
         * @param normal direction of the normal
         * @return the angle between vector0 and vector1
         */
        static GetAngleBetweenVectors(vector0: Vector3, vector1: Vector3, normal: Vector3): number;
        /**
         * Returns a new Vector3 set from the index "offset" of the given array
         * @param array defines the source array
         * @param offset defines the offset in the source array
         * @returns the new Vector3
         */
        static FromArray(array: ArrayLike<number>, offset?: number): Vector3;
        /**
         * Returns a new Vector3 set from the index "offset" of the given Float32Array
         * This function is deprecated.  Use FromArray instead
         * @param array defines the source array
         * @param offset defines the offset in the source array
         * @returns the new Vector3
         */
        static FromFloatArray(array: Float32Array, offset?: number): Vector3;
        /**
         * Sets the given vector "result" with the element values from the index "offset" of the given array
         * @param array defines the source array
         * @param offset defines the offset in the source array
         * @param result defines the Vector3 where to store the result
         */
        static FromArrayToRef(array: ArrayLike<number>, offset: number, result: Vector3): void;
        /**
         * Sets the given vector "result" with the element values from the index "offset" of the given Float32Array
         * This function is deprecated.  Use FromArrayToRef instead.
         * @param array defines the source array
         * @param offset defines the offset in the source array
         * @param result defines the Vector3 where to store the result
         */
        static FromFloatArrayToRef(array: Float32Array, offset: number, result: Vector3): void;
        /**
         * Sets the given vector "result" with the given floats.
         * @param x defines the x coordinate of the source
         * @param y defines the y coordinate of the source
         * @param z defines the z coordinate of the source
         * @param result defines the Vector3 where to store the result
         */
        static FromFloatsToRef(x: number, y: number, z: number, result: Vector3): void;
        /**
         * Returns a new Vector3 set to (0.0, 0.0, 0.0)
         * @returns a new empty Vector3
         */
        static Zero(): Vector3;
        /**
         * Returns a new Vector3 set to (1.0, 1.0, 1.0)
         * @returns a new unit Vector3
         */
        static One(): Vector3;
        /**
         * Returns a new Vector3 set to (0.0, 1.0, 0.0)
         * @returns a new up Vector3
         */
        static Up(): Vector3;
        /**
         * Returns a new Vector3 set to (0.0, 0.0, 1.0)
         * @returns a new forward Vector3
         */
        static Forward(): Vector3;
        /**
         * Returns a new Vector3 set to (1.0, 0.0, 0.0)
         * @returns a new right Vector3
         */
        static Right(): Vector3;
        /**
         * Returns a new Vector3 set to (-1.0, 0.0, 0.0)
         * @returns a new left Vector3
         */
        static Left(): Vector3;
        /**
         * Returns a new Vector3 set with the result of the transformation by the given matrix of the given vector.
         * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)
         * @param vector defines the Vector3 to transform
         * @param transformation defines the transformation matrix
         * @returns the transformed Vector3
         */
        static TransformCoordinates(vector: Vector3, transformation: Matrix): Vector3;
        /**
         * Sets the given vector "result" coordinates with the result of the transformation by the given matrix of the given vector
         * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)
         * @param vector defines the Vector3 to transform
         * @param transformation defines the transformation matrix
         * @param result defines the Vector3 where to store the result
         */
        static TransformCoordinatesToRef(vector: Vector3, transformation: Matrix, result: Vector3): void;
        /**
         * Sets the given vector "result" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)
         * This method computes tranformed coordinates only, not transformed direction vectors
         * @param x define the x coordinate of the source vector
         * @param y define the y coordinate of the source vector
         * @param z define the z coordinate of the source vector
         * @param transformation defines the transformation matrix
         * @param result defines the Vector3 where to store the result
         */
        static TransformCoordinatesFromFloatsToRef(x: number, y: number, z: number, transformation: Matrix, result: Vector3): void;
        /**
         * Returns a new Vector3 set with the result of the normal transformation by the given matrix of the given vector
         * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)
         * @param vector defines the Vector3 to transform
         * @param transformation defines the transformation matrix
         * @returns the new Vector3
         */
        static TransformNormal(vector: Vector3, transformation: Matrix): Vector3;
        /**
         * Sets the given vector "result" with the result of the normal transformation by the given matrix of the given vector
         * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)
         * @param vector defines the Vector3 to transform
         * @param transformation defines the transformation matrix
         * @param result defines the Vector3 where to store the result
         */
        static TransformNormalToRef(vector: Vector3, transformation: Matrix, result: Vector3): void;
        /**
         * Sets the given vector "result" with the result of the normal transformation by the given matrix of the given floats (x, y, z)
         * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)
         * @param x define the x coordinate of the source vector
         * @param y define the y coordinate of the source vector
         * @param z define the z coordinate of the source vector
         * @param transformation defines the transformation matrix
         * @param result defines the Vector3 where to store the result
         */
        static TransformNormalFromFloatsToRef(x: number, y: number, z: number, transformation: Matrix, result: Vector3): void;
        /**
         * Returns a new Vector3 located for "amount" on the CatmullRom interpolation spline defined by the vectors "value1", "value2", "value3", "value4"
         * @param value1 defines the first control point
         * @param value2 defines the second control point
         * @param value3 defines the third control point
         * @param value4 defines the fourth control point
         * @param amount defines the amount on the spline to use
         * @returns the new Vector3
         */
        static CatmullRom(value1: Vector3, value2: Vector3, value3: Vector3, value4: Vector3, amount: number): Vector3;
        /**
         * Returns a new Vector3 set with the coordinates of "value", if the vector "value" is in the cube defined by the vectors "min" and "max"
         * If a coordinate value of "value" is lower than one of the "min" coordinate, then this "value" coordinate is set with the "min" one
         * If a coordinate value of "value" is greater than one of the "max" coordinate, then this "value" coordinate is set with the "max" one
         * @param value defines the current value
         * @param min defines the lower range value
         * @param max defines the upper range value
         * @returns the new Vector3
         */
        static Clamp(value: Vector3, min: Vector3, max: Vector3): Vector3;
        /**
         * Returns a new Vector3 located for "amount" (float) on the Hermite interpolation spline defined by the vectors "value1", "tangent1", "value2", "tangent2"
         * @param value1 defines the first control point
         * @param tangent1 defines the first tangent vector
         * @param value2 defines the second control point
         * @param tangent2 defines the second tangent vector
         * @param amount defines the amount on the interpolation spline (between 0 and 1)
         * @returns the new Vector3
         */
        static Hermite(value1: Vector3, tangent1: Vector3, value2: Vector3, tangent2: Vector3, amount: number): Vector3;
        /**
         * Returns a new Vector3 located for "amount" (float) on the linear interpolation between the vectors "start" and "end"
         * @param start defines the start value
         * @param end defines the end value
         * @param amount max defines amount between both (between 0 and 1)
         * @returns the new Vector3
         */
        static Lerp(start: Vector3, end: Vector3, amount: number): Vector3;
        /**
         * Sets the given vector "result" with the result of the linear interpolation from the vector "start" for "amount" to the vector "end"
         * @param start defines the start value
         * @param end defines the end value
         * @param amount max defines amount between both (between 0 and 1)
         * @param result defines the Vector3 where to store the result
         */
        static LerpToRef(start: Vector3, end: Vector3, amount: number, result: Vector3): void;
        /**
         * Returns the dot product (float) between the vectors "left" and "right"
         * @param left defines the left operand
         * @param right defines the right operand
         * @returns the dot product
         */
        static Dot(left: Vector3, right: Vector3): number;
        /**
         * Returns a new Vector3 as the cross product of the vectors "left" and "right"
         * The cross product is then orthogonal to both "left" and "right"
         * @param left defines the left operand
         * @param right defines the right operand
         * @returns the cross product
         */
        static Cross(left: Vector3, right: Vector3): Vector3;
        /**
         * Sets the given vector "result" with the cross product of "left" and "right"
         * The cross product is then orthogonal to both "left" and "right"
         * @param left defines the left operand
         * @param right defines the right operand
         * @param result defines the Vector3 where to store the result
         */
        static CrossToRef(left: Vector3, right: Vector3, result: Vector3): void;
        /**
         * Returns a new Vector3 as the normalization of the given vector
         * @param vector defines the Vector3 to normalize
         * @returns the new Vector3
         */
        static Normalize(vector: Vector3): Vector3;
        /**
         * Sets the given vector "result" with the normalization of the given first vector
         * @param vector defines the Vector3 to normalize
         * @param result defines the Vector3 where to store the result
         */
        static NormalizeToRef(vector: Vector3, result: Vector3): void;
        private static _viewportMatrixCache;
        /**
         * Project a Vector3 onto screen space
         * @param vector defines the Vector3 to project
         * @param world defines the world matrix to use
         * @param transform defines the transform (view x projection) matrix to use
         * @param viewport defines the screen viewport to use
         * @returns the new Vector3
         */
        static Project(vector: Vector3, world: Matrix, transform: Matrix, viewport: Viewport): Vector3;
        /**
         * Unproject from screen space to object space
         * @param source defines the screen space Vector3 to use
         * @param viewportWidth defines the current width of the viewport
         * @param viewportHeight defines the current height of the viewport
         * @param world defines the world matrix to use (can be set to Identity to go to world space)
         * @param transform defines the transform (view x projection) matrix to use
         * @returns the new Vector3
         */
        static UnprojectFromTransform(source: Vector3, viewportWidth: number, viewportHeight: number, world: Matrix, transform: Matrix): Vector3;
        /**
         * Unproject from screen space to object space
         * @param source defines the screen space Vector3 to use
         * @param viewportWidth defines the current width of the viewport
         * @param viewportHeight defines the current height of the viewport
         * @param world defines the world matrix to use (can be set to Identity to go to world space)
         * @param view defines the view matrix to use
         * @param projection defines the projection matrix to use
         * @returns the new Vector3
         */
        static Unproject(source: Vector3, viewportWidth: number, viewportHeight: number, world: Matrix, view: Matrix, projection: Matrix): Vector3;
        /**
         * Unproject from screen space to object space
         * @param source defines the screen space Vector3 to use
         * @param viewportWidth defines the current width of the viewport
         * @param viewportHeight defines the current height of the viewport
         * @param world defines the world matrix to use (can be set to Identity to go to world space)
         * @param view defines the view matrix to use
         * @param projection defines the projection matrix to use
         * @param result defines the Vector3 where to store the result
         */
        static UnprojectToRef(source: Vector3, viewportWidth: number, viewportHeight: number, world: Matrix, view: Matrix, projection: Matrix, result: Vector3): void;
        /**
         * Unproject from screen space to object space
         * @param sourceX defines the screen space x coordinate to use
         * @param sourceY defines the screen space y coordinate to use
         * @param sourceZ defines the screen space z coordinate to use
         * @param viewportWidth defines the current width of the viewport
         * @param viewportHeight defines the current height of the viewport
         * @param world defines the world matrix to use (can be set to Identity to go to world space)
         * @param view defines the view matrix to use
         * @param projection defines the projection matrix to use
         * @param result defines the Vector3 where to store the result
         */
        static UnprojectFloatsToRef(sourceX: float, sourceY: float, sourceZ: float, viewportWidth: number, viewportHeight: number, world: Matrix, view: Matrix, projection: Matrix, result: Vector3): void;
        /**
         * Gets the minimal coordinate values between two Vector3
         * @param left defines the first operand
         * @param right defines the second operand
         * @returns the new Vector3
         */
        static Minimize(left: Vector3, right: Vector3): Vector3;
        /**
         * Gets the maximal coordinate values between two Vector3
         * @param left defines the first operand
         * @param right defines the second operand
         * @returns the new Vector3
         */
        static Maximize(left: Vector3, right: Vector3): Vector3;
        /**
         * Returns the distance between the vectors "value1" and "value2"
         * @param value1 defines the first operand
         * @param value2 defines the second operand
         * @returns the distance
         */
        static Distance(value1: Vector3, value2: Vector3): number;
        /**
         * Returns the squared distance between the vectors "value1" and "value2"
         * @param value1 defines the first operand
         * @param value2 defines the second operand
         * @returns the squared distance
         */
        static DistanceSquared(value1: Vector3, value2: Vector3): number;
        /**
         * Returns a new Vector3 located at the center between "value1" and "value2"
         * @param value1 defines the first operand
         * @param value2 defines the second operand
         * @returns the new Vector3
         */
        static Center(value1: Vector3, value2: Vector3): Vector3;
        /**
         * Given three orthogonal normalized left-handed oriented Vector3 axis in space (target system),
         * RotationFromAxis() returns the rotation Euler angles (ex : rotation.x, rotation.y, rotation.z) to apply
         * to something in order to rotate it from its local system to the given target system
         * Note: axis1, axis2 and axis3 are normalized during this operation
         * @param axis1 defines the first axis
         * @param axis2 defines the second axis
         * @param axis3 defines the third axis
         * @returns a new Vector3
         */
        static RotationFromAxis(axis1: Vector3, axis2: Vector3, axis3: Vector3): Vector3;
        /**
         * The same than RotationFromAxis but updates the given ref Vector3 parameter instead of returning a new Vector3
         * @param axis1 defines the first axis
         * @param axis2 defines the second axis
         * @param axis3 defines the third axis
         * @param ref defines the Vector3 where to store the result
         */
        static RotationFromAxisToRef(axis1: Vector3, axis2: Vector3, axis3: Vector3, ref: Vector3): void;
    }
    class Vector4 {
        x: number;
        y: number;
        z: number;
        w: number;
        /**
         * Creates a Vector4 object from the given floats.
         */
        constructor(x: number, y: number, z: number, w: number);
        /**
         * Returns the string with the Vector4 coordinates.
         */
        toString(): string;
        /**
         * Returns the string "Vector4".
         */
        getClassName(): string;
        /**
         * Returns the Vector4 hash code.
         */
        getHashCode(): number;
        /**
         * Returns a new array populated with 4 elements : the Vector4 coordinates.
         */
        asArray(): number[];
        /**
         * Populates the given array from the given index with the Vector4 coordinates.
         * Returns the Vector4.
         */
        toArray(array: FloatArray, index?: number): Vector4;
        /**
         * Adds the given vector to the current Vector4.
         * Returns the updated Vector4.
         */
        addInPlace(otherVector: Vector4): Vector4;
        /**
         * Returns a new Vector4 as the result of the addition of the current Vector4 and the given one.
         */
        add(otherVector: Vector4): Vector4;
        /**
         * Updates the given vector "result" with the result of the addition of the current Vector4 and the given one.
         * Returns the current Vector4.
         */
        addToRef(otherVector: Vector4, result: Vector4): Vector4;
        /**
         * Subtract in place the given vector from the current Vector4.
         * Returns the updated Vector4.
         */
        subtractInPlace(otherVector: Vector4): Vector4;
        /**
         * Returns a new Vector4 with the result of the subtraction of the given vector from the current Vector4.
         */
        subtract(otherVector: Vector4): Vector4;
        /**
         * Sets the given vector "result" with the result of the subtraction of the given vector from the current Vector4.
         * Returns the current Vector4.
         */
        subtractToRef(otherVector: Vector4, result: Vector4): Vector4;
        /**
         * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.
         */
        subtractFromFloats(x: number, y: number, z: number, w: number): Vector4;
        /**
         * Sets the given vector "result" set with the result of the subtraction of the given floats from the current Vector4 coordinates.
         * Returns the current Vector4.
         */
        subtractFromFloatsToRef(x: number, y: number, z: number, w: number, result: Vector4): Vector4;
        /**
         * Returns a new Vector4 set with the current Vector4 negated coordinates.
         */
        negate(): Vector4;
        /**
         * Multiplies the current Vector4 coordinates by scale (float).
         * Returns the updated Vector4.
         */
        scaleInPlace(scale: number): Vector4;
        /**
         * Returns a new Vector4 set with the current Vector4 coordinates multiplied by scale (float).
         */
        scale(scale: number): Vector4;
        /**
         * Sets the given vector "result" with the current Vector4 coordinates multiplied by scale (float).
         * Returns the current Vector4.
         */
        scaleToRef(scale: number, result: Vector4): Vector4;
        /**
         * Scale the current Vector4 values by a factor and add the result to a given Vector4
         * @param scale defines the scale factor
         * @param result defines the Vector4 object where to store the result
         * @returns the unmodified current Vector4
         */
        scaleAndAddToRef(scale: number, result: Vector4): Vector4;
        /**
         * Boolean : True if the current Vector4 coordinates are stricly equal to the given ones.
         */
        equals(otherVector: Vector4): boolean;
        /**
         * Boolean : True if the current Vector4 coordinates are each beneath the distance "epsilon" from the given vector ones.
         */
        equalsWithEpsilon(otherVector: Vector4, epsilon?: number): boolean;
        /**
         * Boolean : True if the given floats are strictly equal to the current Vector4 coordinates.
         */
        equalsToFloats(x: number, y: number, z: number, w: number): boolean;
        /**
         * Multiplies in place the current Vector4 by the given one.
         * Returns the updated Vector4.
         */
        multiplyInPlace(otherVector: Vector4): Vector4;
        /**
         * Returns a new Vector4 set with the multiplication result of the current Vector4 and the given one.
         */
        multiply(otherVector: Vector4): Vector4;
        /**
         * Updates the given vector "result" with the multiplication result of the current Vector4 and the given one.
         * Returns the current Vector4.
         */
        multiplyToRef(otherVector: Vector4, result: Vector4): Vector4;
        /**
         * Returns a new Vector4 set with the multiplication result of the given floats and the current Vector4 coordinates.
         */
        multiplyByFloats(x: number, y: number, z: number, w: number): Vector4;
        /**
         * Returns a new Vector4 set with the division result of the current Vector4 by the given one.
         */
        divide(otherVector: Vector4): Vector4;
        /**
         * Updates the given vector "result" with the division result of the current Vector4 by the given one.
         * Returns the current Vector4.
         */
        divideToRef(otherVector: Vector4, result: Vector4): Vector4;
        /**
         * Divides the current Vector3 coordinates by the given ones.
         * @returns the updated Vector3.
         */
        divideInPlace(otherVector: Vector4): Vector4;
        /**
         * Updates the Vector4 coordinates with the minimum values between its own and the given vector ones
         * @param other defines the second operand
         * @returns the current updated Vector4
         */
        minimizeInPlace(other: Vector4): Vector4;
        /**
         * Updates the Vector4 coordinates with the maximum values between its own and the given vector ones
         * @param other defines the second operand
         * @returns the current updated Vector4
         */
        maximizeInPlace(other: Vector4): Vector4;
        /**
         * Returns the Vector4 length (float).
         */
        length(): number;
        /**
         * Returns the Vector4 squared length (float).
         */
        lengthSquared(): number;
        /**
         * Normalizes in place the Vector4.
         * Returns the updated Vector4.
         */
        normalize(): Vector4;
        /**
         * Returns a new Vector3 from the Vector4 (x, y, z) coordinates.
         */
        toVector3(): Vector3;
        /**
         * Returns a new Vector4 copied from the current one.
         */
        clone(): Vector4;
        /**
         * Updates the current Vector4 with the given one coordinates.
         * Returns the updated Vector4.
         */
        copyFrom(source: Vector4): Vector4;
        /**
         * Updates the current Vector4 coordinates with the given floats.
         * Returns the updated Vector4.
         */
        copyFromFloats(x: number, y: number, z: number, w: number): Vector4;
        /**
         * Updates the current Vector4 coordinates with the given floats.
         * Returns the updated Vector4.
         */
        set(x: number, y: number, z: number, w: number): Vector4;
        /**
         * Returns a new Vector4 set from the starting index of the given array.
         */
        static FromArray(array: ArrayLike<number>, offset?: number): Vector4;
        /**
         * Updates the given vector "result" from the starting index of the given array.
         */
        static FromArrayToRef(array: ArrayLike<number>, offset: number, result: Vector4): void;
        /**
         * Updates the given vector "result" from the starting index of the given Float32Array.
         */
        static FromFloatArrayToRef(array: Float32Array, offset: number, result: Vector4): void;
        /**
         * Updates the given vector "result" coordinates from the given floats.
         */
        static FromFloatsToRef(x: number, y: number, z: number, w: number, result: Vector4): void;
        /**
         * Returns a new Vector4 set to (0.0, 0.0, 0.0, 0.0)
         */
        static Zero(): Vector4;
        /**
         * Returns a new Vector4 set to (1.0, 1.0, 1.0, 1.0)
         */
        static One(): Vector4;
        /**
         * Returns a new normalized Vector4 from the given one.
         */
        static Normalize(vector: Vector4): Vector4;
        /**
         * Updates the given vector "result" from the normalization of the given one.
         */
        static NormalizeToRef(vector: Vector4, result: Vector4): void;
        static Minimize(left: Vector4, right: Vector4): Vector4;
        static Maximize(left: Vector4, right: Vector4): Vector4;
        /**
         * Returns the distance (float) between the vectors "value1" and "value2".
         */
        static Distance(value1: Vector4, value2: Vector4): number;
        /**
         * Returns the squared distance (float) between the vectors "value1" and "value2".
         */
        static DistanceSquared(value1: Vector4, value2: Vector4): number;
        /**
         * Returns a new Vector4 located at the center between the vectors "value1" and "value2".
         */
        static Center(value1: Vector4, value2: Vector4): Vector4;
        /**
         * Returns a new Vector4 set with the result of the normal transformation by the given matrix of the given vector.
         * This methods computes transformed normalized direction vectors only.
         */
        static TransformNormal(vector: Vector4, transformation: Matrix): Vector4;
        /**
         * Sets the given vector "result" with the result of the normal transformation by the given matrix of the given vector.
         * This methods computes transformed normalized direction vectors only.
         */
        static TransformNormalToRef(vector: Vector4, transformation: Matrix, result: Vector4): void;
        /**
         * Sets the given vector "result" with the result of the normal transformation by the given matrix of the given floats (x, y, z, w).
         * This methods computes transformed normalized direction vectors only.
         */
        static TransformNormalFromFloatsToRef(x: number, y: number, z: number, w: number, transformation: Matrix, result: Vector4): void;
    }
    interface ISize {
        width: number;
        height: number;
    }
    class Size implements ISize {
        width: number;
        height: number;
        /**
         * Creates a Size object from the given width and height (floats).
         */
        constructor(width: number, height: number);
        toString(): string;
        /**
         * Returns the string "Size"
         */
        getClassName(): string;
        /**
         * Returns the Size hash code.
         */
        getHashCode(): number;
        /**
         * Updates the current size from the given one.
         * Returns the updated Size.
         */
        copyFrom(src: Size): void;
        /**
         * Updates in place the current Size from the given floats.
         * Returns the updated Size.
         */
        copyFromFloats(width: number, height: number): Size;
        /**
         * Updates in place the current Size from the given floats.
         * Returns the updated Size.
         */
        set(width: number, height: number): Size;
        /**
         * Returns a new Size set with the multiplication result of the current Size and the given floats.
         */
        multiplyByFloats(w: number, h: number): Size;
        /**
         * Returns a new Size copied from the given one.
         */
        clone(): Size;
        /**
         * Boolean : True if the current Size and the given one width and height are strictly equal.
         */
        equals(other: Size): boolean;
        /**
         * Returns the surface of the Size : width * height (float).
         */
        readonly surface: number;
        /**
         * Returns a new Size set to (0.0, 0.0)
         */
        static Zero(): Size;
        /**
         * Returns a new Size set as the addition result of the current Size and the given one.
         */
        add(otherSize: Size): Size;
        /**
         * Returns a new Size set as the subtraction result of  the given one from the current Size.
         */
        subtract(otherSize: Size): Size;
        /**
         * Returns a new Size set at the linear interpolation "amount" between "start" and "end".
         */
        static Lerp(start: Size, end: Size, amount: number): Size;
    }
    /**
     * Class used to store quaternion data
     * @see https://en.wikipedia.org/wiki/Quaternion
     * @see http://doc.babylonjs.com/features/position,_rotation,_scaling
     */
    class Quaternion {
        /** defines the first component (0 by default) */
        x: number;
        /** defines the second component (0 by default) */
        y: number;
        /** defines the third component (0 by default) */
        z: number;
        /** defines the fourth component (1.0 by default) */
        w: number;
        /**
         * Creates a new Quaternion from the given floats
         * @param x defines the first component (0 by default)
         * @param y defines the second component (0 by default)
         * @param z defines the third component (0 by default)
         * @param w defines the fourth component (1.0 by default)
         */
        constructor(
            /** defines the first component (0 by default) */
            x?: number, 
            /** defines the second component (0 by default) */
            y?: number, 
            /** defines the third component (0 by default) */
            z?: number, 
            /** defines the fourth component (1.0 by default) */
            w?: number);
        /**
         * Gets a string representation for the current quaternion
         * @returns a string with the Quaternion coordinates
         */
        toString(): string;
        /**
         * Gets the class name of the quaternion
         * @returns the string "Quaternion"
         */
        getClassName(): string;
        /**
         * Gets a hash code for this quaternion
         * @returns the quaternion hash code
         */
        getHashCode(): number;
        /**
         * Copy the quaternion to an array
         * @returns a new array populated with 4 elements from the quaternion coordinates
         */
        asArray(): number[];
        /**
         * Check if two quaternions are equals
         * @param otherQuaternion defines the second operand
         * @return true if the current quaternion and the given one coordinates are strictly equals
         */
        equals(otherQuaternion: Quaternion): boolean;
        /**
         * Clone the current quaternion
         * @returns a new quaternion copied from the current one
         */
        clone(): Quaternion;
        /**
         * Copy a quaternion to the current one
         * @param other defines the other quaternion
         * @returns the updated current quaternion
         */
        copyFrom(other: Quaternion): Quaternion;
        /**
         * Updates the current quaternion with the given float coordinates
         * @param x defines the x coordinate
         * @param y defines the y coordinate
         * @param z defines the z coordinate
         * @param w defines the w coordinate
         * @returns the updated current quaternion
         */
        copyFromFloats(x: number, y: number, z: number, w: number): Quaternion;
        /**
         * Updates the current quaternion from the given float coordinates
         * @param x defines the x coordinate
         * @param y defines the y coordinate
         * @param z defines the z coordinate
         * @param w defines the w coordinate
         * @returns the updated current quaternion
         */
        set(x: number, y: number, z: number, w: number): Quaternion;
        /**
         * Adds two quaternions
         * @param other defines the second operand
         * @returns a new quaternion as the addition result of the given one and the current quaternion
         */
        add(other: Quaternion): Quaternion;
        /**
         * Add a quaternion to the current one
         * @param other defines the quaternion to add
         * @returns the current quaternion
         */
        addInPlace(other: Quaternion): Quaternion;
        /**
         * Subtract two quaternions
         * @param other defines the second operand
         * @returns a new quaternion as the subtraction result of the given one from the current one
         */
        subtract(other: Quaternion): Quaternion;
        /**
         * Multiplies the current quaternion by a scale factor
         * @param value defines the scale factor
         * @returns a new quaternion set by multiplying the current quaternion coordinates by the float "scale"
         */
        scale(value: number): Quaternion;
        /**
         * Scale the current quaternion values by a factor and stores the result to a given quaternion
         * @param scale defines the scale factor
         * @param result defines the Quaternion object where to store the result
         * @returns the unmodified current quaternion
         */
        scaleToRef(scale: number, result: Quaternion): Quaternion;
        /**
         * Multiplies in place the current quaternion by a scale factor
         * @param value defines the scale factor
         * @returns the current modified quaternion
         */
        scaleInPlace(value: number): Quaternion;
        /**
         * Scale the current quaternion values by a factor and add the result to a given quaternion
         * @param scale defines the scale factor
         * @param result defines the Quaternion object where to store the result
         * @returns the unmodified current quaternion
         */
        scaleAndAddToRef(scale: number, result: Quaternion): Quaternion;
        /**
         * Multiplies two quaternions
         * @param q1 defines the second operand
         * @returns a new quaternion set as the multiplication result of the current one with the given one "q1"
         */
        multiply(q1: Quaternion): Quaternion;
        /**
         * Sets the given "result" as the the multiplication result of the current one with the given one "q1"
         * @param q1 defines the second operand
         * @param result defines the target quaternion
         * @returns the current quaternion
         */
        multiplyToRef(q1: Quaternion, result: Quaternion): Quaternion;
        /**
         * Updates the current quaternion with the multiplication of itself with the given one "q1"
         * @param q1 defines the second operand
         * @returns the currentupdated quaternion
         */
        multiplyInPlace(q1: Quaternion): Quaternion;
        /**
         * Conjugates (1-q) the current quaternion and stores the result in the given quaternion
         * @param ref defines the target quaternion
         * @returns the current quaternion
         */
        conjugateToRef(ref: Quaternion): Quaternion;
        /**
         * Conjugates in place (1-q) the current quaternion
         * @returns the current updated quaternion
         */
        conjugateInPlace(): Quaternion;
        /**
         * Conjugates in place (1-q) the current quaternion
         * @returns a new quaternion
         */
        conjugate(): Quaternion;
        /**
         * Gets length of current quaternion
         * @returns the quaternion length (float)
         */
        length(): number;
        /**
         * Normalize in place the current quaternion
         * @returns the current updated quaternion
         */
        normalize(): Quaternion;
        /**
         * Returns a new Vector3 set with the Euler angles translated from the current quaternion
         * @param order is a reserved parameter and is ignore for now
         * @returns a new Vector3 containing the Euler angles
         */
        toEulerAngles(order?: string): Vector3;
        /**
         * Sets the given vector3 "result" with the Euler angles translated from the current quaternion
         * @param result defines the vector which will be filled with the Euler angles
         * @param order is a reserved parameter and is ignore for now
         * @returns the current unchanged quaternion
         */
        toEulerAnglesToRef(result: Vector3, order?: string): Quaternion;
        /**
         * Updates the given rotation matrix with the current quaternion values
         * @param result defines the target matrix
         * @returns the current unchanged quaternion
         */
        toRotationMatrix(result: Matrix): Quaternion;
        /**
         * Updates the current quaternion from the given rotation matrix values
         * @param matrix defines the source matrix
         * @returns the current updated quaternion
         */
        fromRotationMatrix(matrix: Matrix): Quaternion;
        /**
         * Creates a new quaternion from a rotation matrix
         * @param matrix defines the source matrix
         * @returns a new quaternion created from the given rotation matrix values
         */
        static FromRotationMatrix(matrix: Matrix): Quaternion;
        /**
         * Updates the given quaternion with the given rotation matrix values
         * @param matrix defines the source matrix
         * @param result defines the target quaternion
         */
        static FromRotationMatrixToRef(matrix: Matrix, result: Quaternion): void;
        /**
         * Returns the dot product (float) between the quaternions "left" and "right"
         * @param left defines the left operand
         * @param right defines the right operand
         * @returns the dot product
         */
        static Dot(left: Quaternion, right: Quaternion): number;
        /**
         * Checks if the two quaternions are close to each other
         * @param quat0 defines the first quaternion to check
         * @param quat1 defines the second quaternion to check
         * @returns true if the two quaternions are close to each other
         */
        static AreClose(quat0: Quaternion, quat1: Quaternion): boolean;
        /**
         * Creates an empty quaternion
         * @returns a new quaternion set to (0.0, 0.0, 0.0)
         */
        static Zero(): Quaternion;
        /**
         * Inverse a given quaternion
         * @param q defines the source quaternion
         * @returns a new quaternion as the inverted current quaternion
         */
        static Inverse(q: Quaternion): Quaternion;
        /**
         * Creates an identity quaternion
         * @returns the identity quaternion
         */
        static Identity(): Quaternion;
        /**
         * Gets a boolean indicating if the given quaternion is identity
         * @param quaternion defines the quaternion to check
         * @returns true if the quaternion is identity
         */
        static IsIdentity(quaternion: Quaternion): boolean;
        /**
         * Creates a quaternion from a rotation around an axis
         * @param axis defines the axis to use
         * @param angle defines the angle to use
         * @returns a new quaternion created from the given axis (Vector3) and angle in radians (float)
         */
        static RotationAxis(axis: Vector3, angle: number): Quaternion;
        /**
         * Creates a rotation around an axis and stores it into the given quaternion
         * @param axis defines the axis to use
         * @param angle defines the angle to use
         * @param result defines the target quaternion
         * @returns the target quaternion
         */
        static RotationAxisToRef(axis: Vector3, angle: number, result: Quaternion): Quaternion;
        /**
         * Creates a new quaternion from data stored into an array
         * @param array defines the data source
         * @param offset defines the offset in the source array where the data starts
         * @returns a new quaternion
         */
        static FromArray(array: ArrayLike<number>, offset?: number): Quaternion;
        /**
         * Creates a new quaternion from the given Euler float angles (y, x, z)
         * @param yaw defines the rotation around Y axis
         * @param pitch defines the rotation around X axis
         * @param roll defines the rotation around Z axis
         * @returns the new quaternion
         */
        static RotationYawPitchRoll(yaw: number, pitch: number, roll: number): Quaternion;
        /**
         * Creates a new rotation from the given Euler float angles (y, x, z) and stores it in the target quaternion
         * @param yaw defines the rotation around Y axis
         * @param pitch defines the rotation around X axis
         * @param roll defines the rotation around Z axis
         * @param result defines the target quaternion
         */
        static RotationYawPitchRollToRef(yaw: number, pitch: number, roll: number, result: Quaternion): void;
        /**
         * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation
         * @param alpha defines the rotation around first axis
         * @param beta defines the rotation around second axis
         * @param gamma defines the rotation around third axis
         * @returns the new quaternion
         */
        static RotationAlphaBetaGamma(alpha: number, beta: number, gamma: number): Quaternion;
        /**
         * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation and stores it in the target quaternion
         * @param alpha defines the rotation around first axis
         * @param beta defines the rotation around second axis
         * @param gamma defines the rotation around third axis
         * @param result defines the target quaternion
         */
        static RotationAlphaBetaGammaToRef(alpha: number, beta: number, gamma: number, result: Quaternion): void;
        /**
         * Creates a new quaternion containing the rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation)
         * @param axis1 defines the first axis
         * @param axis2 defines the second axis
         * @param axis3 defines the third axis
         * @returns the new quaternion
         */
        static RotationQuaternionFromAxis(axis1: Vector3, axis2: Vector3, axis3: Vector3): Quaternion;
        /**
         * Creates a rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation) and stores it in the target quaternion
         * @param axis1 defines the first axis
         * @param axis2 defines the second axis
         * @param axis3 defines the third axis
         * @param ref defines the target quaternion
         */
        static RotationQuaternionFromAxisToRef(axis1: Vector3, axis2: Vector3, axis3: Vector3, ref: Quaternion): void;
        /**
         * Interpolates between two quaternions
         * @param left defines first quaternion
         * @param right defines second quaternion
         * @param amount defines the gradient to use
         * @returns the new interpolated quaternion
         */
        static Slerp(left: Quaternion, right: Quaternion, amount: number): Quaternion;
        /**
         * Interpolates between two quaternions and stores it into a target quaternion
         * @param left defines first quaternion
         * @param right defines second quaternion
         * @param amount defines the gradient to use
         * @param result defines the target quaternion
         */
        static SlerpToRef(left: Quaternion, right: Quaternion, amount: number, result: Quaternion): void;
        /**
         * Interpolate between two quaternions using Hermite interpolation
         * @param value1 defines first quaternion
         * @param tangent1 defines the incoming tangent
         * @param value2 defines second quaternion
         * @param tangent2 defines the outgoing tangent
         * @param amount defines the target quaternion
         * @returns the new interpolated quaternion
         */
        static Hermite(value1: Quaternion, tangent1: Quaternion, value2: Quaternion, tangent2: Quaternion, amount: number): Quaternion;
    }
    /**
     * Class used to store matrix data (4x4)
     */
    class Matrix {
        private static _tempQuaternion;
        private static _xAxis;
        private static _yAxis;
        private static _zAxis;
        private static _updateFlagSeed;
        private static _identityReadOnly;
        private _isIdentity;
        private _isIdentityDirty;
        /**
         * Gets the update flag of the matrix which is an unique number for the matrix.
         * It will be incremented every time the matrix data change.
         * You can use it to speed the comparison between two versions of the same matrix.
         */
        updateFlag: number;
        /**
         * Gets or sets the internal data of the matrix
         */
        m: Float32Array;
        /** @hidden */
        _markAsUpdated(): void;
        /**
         * Creates an empty matrix (filled with zeros)
         */
        constructor();
        /**
         * Check if the current matrix is indentity
         * @param considerAsTextureMatrix defines if the current matrix must be considered as a texture matrix (3x2)
         * @returns true is the matrix is the identity matrix
         */
        isIdentity(considerAsTextureMatrix?: boolean): boolean;
        /**
         * Gets the determinant of the matrix
         * @returns the matrix determinant
         */
        determinant(): number;
        /**
         * Returns the matrix as a Float32Array
         * @returns the matrix underlying array
         */
        toArray(): Float32Array;
        /**
         * Returns the matrix as a Float32Array
        * @returns the matrix underlying array.
        */
        asArray(): Float32Array;
        /**
         * Inverts the current matrix in place
         * @returns the current inverted matrix
         */
        invert(): Matrix;
        /**
         * Sets all the matrix elements to zero
         * @returns the current matrix
         */
        reset(): Matrix;
        /**
         * Adds the current matrix with a second one
         * @param other defines the matrix to add
         * @returns a new matrix as the addition of the current matrix and the given one
         */
        add(other: Matrix): Matrix;
        /**
         * Sets the given matrix "result" to the addition of the current matrix and the given one
         * @param other defines the matrix to add
         * @param result defines the target matrix
         * @returns the current matrix
         */
        addToRef(other: Matrix, result: Matrix): Matrix;
        /**
         * Adds in place the given matrix to the current matrix
         * @param other defines the second operand
         * @returns the current updated matrix
         */
        addToSelf(other: Matrix): Matrix;
        /**
         * Sets the given matrix to the current inverted Matrix
         * @param other defines the target matrix
         * @returns the unmodified current matrix
         */
        invertToRef(other: Matrix): Matrix;
        /**
         * Inserts the translation vector (using 3 floats) in the current matrix
         * @param x defines the 1st component of the translation
         * @param y defines the 2nd component of the translation
         * @param z defines the 3rd component of the translation
         * @returns the current updated matrix
         */
        setTranslationFromFloats(x: number, y: number, z: number): Matrix;
        /**
         * Inserts the translation vector in the current matrix
         * @param vector3 defines the translation to insert
         * @returns the current updated matrix
         */
        setTranslation(vector3: Vector3): Matrix;
        /**
         * Gets the translation value of the current matrix
         * @returns a new Vector3 as the extracted translation from the matrix
         */
        getTranslation(): Vector3;
        /**
         * Fill a Vector3 with the extracted translation from the matrix
         * @param result defines the Vector3 where to store the translation
         * @returns the current matrix
         */
        getTranslationToRef(result: Vector3): Matrix;
        /**
         * Remove rotation and scaling part from the matrix
         * @returns the updated matrix
         */
        removeRotationAndScaling(): Matrix;
        /**
         * Multiply two matrices
         * @param other defines the second operand
         * @returns a new matrix set with the multiplication result of the current Matrix and the given one
         */
        multiply(other: Matrix): Matrix;
        /**
         * Copy the current matrix from the given one
         * @param other defines the source matrix
         * @returns the current updated matrix
         */
        copyFrom(other: Matrix): Matrix;
        /**
         * Populates the given array from the starting index with the current matrix values
         * @param array defines the target array
         * @param offset defines the offset in the target array where to start storing values
         * @returns the current matrix
         */
        copyToArray(array: Float32Array, offset?: number): Matrix;
        /**
         * Sets the given matrix "result" with the multiplication result of the current Matrix and the given one
         * @param other defines the second operand
         * @param result defines the matrix where to store the multiplication
         * @returns the current matrix
         */
        multiplyToRef(other: Matrix, result: Matrix): Matrix;
        /**
         * Sets the Float32Array "result" from the given index "offset" with the multiplication of the current matrix and the given one
         * @param other defines the second operand
         * @param result defines the array where to store the multiplication
         * @param offset defines the offset in the target array where to start storing values
         * @returns the current matrix
         */
        multiplyToArray(other: Matrix, result: Float32Array, offset: number): Matrix;
        /**
         * Check equality between this matrix and a second one
         * @param value defines the second matrix to compare
         * @returns true is the current matrix and the given one values are strictly equal
         */
        equals(value: Matrix): boolean;
        /**
         * Clone the current matrix
         * @returns a new matrix from the current matrix
         */
        clone(): Matrix;
        /**
         * Returns the name of the current matrix class
         * @returns the string "Matrix"
         */
        getClassName(): string;
        /**
         * Gets the hash code of the current matrix
         * @returns the hash code
         */
        getHashCode(): number;
        /**
         * Decomposes the current Matrix into a translation, rotation and scaling components
         * @param scale defines the scale vector3 given as a reference to update
         * @param rotation defines the rotation quaternion given as a reference to update
         * @param translation defines the translation vector3 given as a reference to update
         * @returns true if operation was successful
         */
        decompose(scale?: Vector3, rotation?: Quaternion, translation?: Vector3): boolean;
        /**
         * Gets specific row of the matrix
         * @param index defines the number of the row to get
         * @returns the index-th row of the current matrix as a new Vector4
         */
        getRow(index: number): Nullable<Vector4>;
        /**
         * Sets the index-th row of the current matrix to the vector4 values
         * @param index defines the number of the row to set
         * @param row defines the target vector4
         * @returns the updated current matrix
         */
        setRow(index: number, row: Vector4): Matrix;
        /**
         * Compute the transpose of the matrix
         * @returns the new transposed matrix
         */
        transpose(): Matrix;
        /**
         * Compute the transpose of the matrix and store it in a given matrix
         * @param result defines the target matrix
         * @returns the current matrix
         */
        transposeToRef(result: Matrix): Matrix;
        /**
         * Sets the index-th row of the current matrix with the given 4 x float values
         * @param index defines the row index
         * @param x defines the x component to set
         * @param y defines the y component to set
         * @param z defines the z component to set
         * @param w defines the w component to set
         * @returns the updated current matrix
         */
        setRowFromFloats(index: number, x: number, y: number, z: number, w: number): Matrix;
        /**
         * Compute a new matrix set with the current matrix values multiplied by scale (float)
         * @param scale defines the scale factor
         * @returns a new matrix
         */
        scale(scale: number): Matrix;
        /**
         * Scale the current matrix values by a factor to a given result matrix
         * @param scale defines the scale factor
         * @param result defines the matrix to store the result
         * @returns the current matrix
         */
        scaleToRef(scale: number, result: Matrix): Matrix;
        /**
         * Scale the current matrix values by a factor and add the result to a given matrix
         * @param scale defines the scale factor
         * @param result defines the Matrix to store the result
         * @returns the current matrix
         */
        scaleAndAddToRef(scale: number, result: Matrix): Matrix;
        /**
         * Writes to the given matrix a normal matrix, computed from this one (using values from identity matrix for fourth row and column).
         * @param ref matrix to store the result
         */
        toNormalMatrix(ref: Matrix): void;
        /**
         * Gets only rotation part of the current matrix
         * @returns a new matrix sets to the extracted rotation matrix from the current one
         */
        getRotationMatrix(): Matrix;
        /**
         * Extracts the rotation matrix from the current one and sets it as the given "result"
         * @param result defines the target matrix to store data to
         * @returns the current matrix
         */
        getRotationMatrixToRef(result: Matrix): Matrix;
        /**
         * Creates a matrix from an array
         * @param array defines the source array
         * @param offset defines an offset in the source array
         * @returns a new Matrix set from the starting index of the given array
         */
        static FromArray(array: ArrayLike<number>, offset?: number): Matrix;
        /**
         * Copy the content of an array into a given matrix
         * @param array defines the source array
         * @param offset defines an offset in the source array
         * @param result defines the target matrix
         */
        static FromArrayToRef(array: ArrayLike<number>, offset: number, result: Matrix): void;
        /**
         * Stores an array into a matrix after having multiplied each component by a given factor
         * @param array defines the source array
         * @param offset defines the offset in the source array
         * @param scale defines the scaling factor
         * @param result defines the target matrix
         */
        static FromFloat32ArrayToRefScaled(array: Float32Array, offset: number, scale: number, result: Matrix): void;
        /**
         * Stores a list of values (16) inside a given matrix
         * @param initialM11 defines 1st value of 1st row
         * @param initialM12 defines 2nd value of 1st row
         * @param initialM13 defines 3rd value of 1st row
         * @param initialM14 defines 4th value of 1st row
         * @param initialM21 defines 1st value of 2nd row
         * @param initialM22 defines 2nd value of 2nd row
         * @param initialM23 defines 3rd value of 2nd row
         * @param initialM24 defines 4th value of 2nd row
         * @param initialM31 defines 1st value of 3rd row
         * @param initialM32 defines 2nd value of 3rd row
         * @param initialM33 defines 3rd value of 3rd row
         * @param initialM34 defines 4th value of 3rd row
         * @param initialM41 defines 1st value of 4th row
         * @param initialM42 defines 2nd value of 4th row
         * @param initialM43 defines 3rd value of 4th row
         * @param initialM44 defines 4th value of 4th row
         * @param result defines the target matrix
         */
        static FromValuesToRef(initialM11: number, initialM12: number, initialM13: number, initialM14: number, initialM21: number, initialM22: number, initialM23: number, initialM24: number, initialM31: number, initialM32: number, initialM33: number, initialM34: number, initialM41: number, initialM42: number, initialM43: number, initialM44: number, result: Matrix): void;
        /**
         * Gets an identity matrix that must not be updated
         */
        static readonly IdentityReadOnly: Matrix;
        /**
         * Creates new matrix from a list of values (16)
         * @param initialM11 defines 1st value of 1st row
         * @param initialM12 defines 2nd value of 1st row
         * @param initialM13 defines 3rd value of 1st row
         * @param initialM14 defines 4th value of 1st row
         * @param initialM21 defines 1st value of 2nd row
         * @param initialM22 defines 2nd value of 2nd row
         * @param initialM23 defines 3rd value of 2nd row
         * @param initialM24 defines 4th value of 2nd row
         * @param initialM31 defines 1st value of 3rd row
         * @param initialM32 defines 2nd value of 3rd row
         * @param initialM33 defines 3rd value of 3rd row
         * @param initialM34 defines 4th value of 3rd row
         * @param initialM41 defines 1st value of 4th row
         * @param initialM42 defines 2nd value of 4th row
         * @param initialM43 defines 3rd value of 4th row
         * @param initialM44 defines 4th value of 4th row
         * @returns the new matrix
         */
        static FromValues(initialM11: number, initialM12: number, initialM13: number, initialM14: number, initialM21: number, initialM22: number, initialM23: number, initialM24: number, initialM31: number, initialM32: number, initialM33: number, initialM34: number, initialM41: number, initialM42: number, initialM43: number, initialM44: number): Matrix;
        /**
         * Creates a new matrix composed by merging scale (vector3), rotation (quaternion) and translation (vector3)
         * @param scale defines the scale vector3
         * @param rotation defines the rotation quaternion
         * @param translation defines the translation vector3
         * @returns a new matrix
         */
        static Compose(scale: Vector3, rotation: Quaternion, translation: Vector3): Matrix;
        /**
         * Sets a matrix to a value composed by merging scale (vector3), rotation (quaternion) and translation (vector3)
         * @param scale defines the scale vector3
         * @param rotation defines the rotation quaternion
         * @param translation defines the translation vector3
         * @param result defines the target matrix
         */
        static ComposeToRef(scale: Vector3, rotation: Quaternion, translation: Vector3, result: Matrix): void;
        /**
         * Creates a new identity matrix
         * @returns a new identity matrix
         */
        static Identity(): Matrix;
        /**
         * Creates a new identity matrix and stores the result in a given matrix
         * @param result defines the target matrix
         */
        static IdentityToRef(result: Matrix): void;
        /**
         * Creates a new zero matrix
         * @returns a new zero matrix
         */
        static Zero(): Matrix;
        /**
         * Creates a new rotation matrix for "angle" radians around the X axis
         * @param angle defines the angle (in radians) to use
         * @return the new matrix
         */
        static RotationX(angle: number): Matrix;
        /**
         * Creates a new matrix as the invert of a given matrix
         * @param source defines the source matrix
         * @returns the new matrix
         */
        static Invert(source: Matrix): Matrix;
        /**
         * Creates a new rotation matrix for "angle" radians around the X axis and stores it in a given matrix
         * @param angle defines the angle (in radians) to use
         * @param result defines the target matrix
         */
        static RotationXToRef(angle: number, result: Matrix): void;
        /**
         * Creates a new rotation matrix for "angle" radians around the Y axis
         * @param angle defines the angle (in radians) to use
         * @return the new matrix
         */
        static RotationY(angle: number): Matrix;
        /**
         * Creates a new rotation matrix for "angle" radians around the Y axis and stores it in a given matrix
         * @param angle defines the angle (in radians) to use
         * @param result defines the target matrix
         */
        static RotationYToRef(angle: number, result: Matrix): void;
        /**
         * Creates a new rotation matrix for "angle" radians around the Z axis
         * @param angle defines the angle (in radians) to use
         * @return the new matrix
         */
        static RotationZ(angle: number): Matrix;
        /**
         * Creates a new rotation matrix for "angle" radians around the Z axis and stores it in a given matrix
         * @param angle defines the angle (in radians) to use
         * @param result defines the target matrix
         */
        static RotationZToRef(angle: number, result: Matrix): void;
        /**
         * Creates a new rotation matrix for "angle" radians around the given axis
         * @param axis defines the axis to use
         * @param angle defines the angle (in radians) to use
         * @return the new matrix
         */
        static RotationAxis(axis: Vector3, angle: number): Matrix;
        /**
         * Creates a new rotation matrix for "angle" radians around the given axis and stores it in a given matrix
         * @param axis defines the axis to use
         * @param angle defines the angle (in radians) to use
         * @param result defines the target matrix
         */
        static RotationAxisToRef(axis: Vector3, angle: number, result: Matrix): void;
        /**
         * Creates a rotation matrix
         * @param yaw defines the yaw angle in radians (Y axis)
         * @param pitch defines the pitch angle in radians (X axis)
         * @param roll defines the roll angle in radians (X axis)
         * @returns the new rotation matrix
         */
        static RotationYawPitchRoll(yaw: number, pitch: number, roll: number): Matrix;
        /**
         * Creates a rotation matrix and stores it in a given matrix
         * @param yaw defines the yaw angle in radians (Y axis)
         * @param pitch defines the pitch angle in radians (X axis)
         * @param roll defines the roll angle in radians (X axis)
         * @param result defines the target matrix
         */
        static RotationYawPitchRollToRef(yaw: number, pitch: number, roll: number, result: Matrix): void;
        /**
         * Creates a scaling matrix
         * @param x defines the scale factor on X axis
         * @param y defines the scale factor on Y axis
         * @param z defines the scale factor on Z axis
         * @returns the new matrix
         */
        static Scaling(x: number, y: number, z: number): Matrix;
        /**
         * Creates a scaling matrix and stores it in a given matrix
         * @param x defines the scale factor on X axis
         * @param y defines the scale factor on Y axis
         * @param z defines the scale factor on Z axis
         * @param result defines the target matrix
         */
        static ScalingToRef(x: number, y: number, z: number, result: Matrix): void;
        /**
         * Creates a translation matrix
         * @param x defines the translation on X axis
         * @param y defines the translation on Y axis
         * @param z defines the translationon Z axis
         * @returns the new matrix
         */
        static Translation(x: number, y: number, z: number): Matrix;
        /**
         * Creates a translation matrix and stores it in a given matrix
         * @param x defines the translation on X axis
         * @param y defines the translation on Y axis
         * @param z defines the translationon Z axis
         * @param result defines the target matrix
         */
        static TranslationToRef(x: number, y: number, z: number, result: Matrix): void;
        /**
         * Returns a new Matrix whose values are the interpolated values for "gradient" (float) between the ones of the matrices "startValue" and "endValue".
         * @param startValue defines the start value
         * @param endValue defines the end value
         * @param gradient defines the gradient factor
         * @returns the new matrix
         */
        static Lerp(startValue: Matrix, endValue: Matrix, gradient: number): Matrix;
        /**
         * Set the given matrix "result" as the interpolated values for "gradient" (float) between the ones of the matrices "startValue" and "endValue".
         * @param startValue defines the start value
         * @param endValue defines the end value
         * @param gradient defines the gradient factor
         * @param result defines the Matrix object where to store data
         */
        static LerpToRef(startValue: Matrix, endValue: Matrix, gradient: number, result: Matrix): void;
        /**
         * Builds a new matrix whose values are computed by:
         * * decomposing the the "startValue" and "endValue" matrices into their respective scale, rotation and translation matrices
         * * interpolating for "gradient" (float) the values between each of these decomposed matrices between the start and the end
         * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices
         * @param startValue defines the first matrix
         * @param endValue defines the second matrix
         * @param gradient defines the gradient between the two matrices
         * @returns the new matrix
         */
        static DecomposeLerp(startValue: Matrix, endValue: Matrix, gradient: number): Matrix;
        /**
         * Update a matrix to values which are computed by:
         * * decomposing the the "startValue" and "endValue" matrices into their respective scale, rotation and translation matrices
         * * interpolating for "gradient" (float) the values between each of these decomposed matrices between the start and the end
         * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices
         * @param startValue defines the first matrix
         * @param endValue defines the second matrix
         * @param gradient defines the gradient between the two matrices
         * @param result defines the target matrix
         */
        static DecomposeLerpToRef(startValue: Matrix, endValue: Matrix, gradient: number, result: Matrix): void;
        /**
         * Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up"
         * This function works in left handed mode
         * @param eye defines the final position of the entity
         * @param target defines where the entity should look at
         * @param up defines the up vector for the entity
         * @returns the new matrix
         */
        static LookAtLH(eye: Vector3, target: Vector3, up: Vector3): Matrix;
        /**
         * Sets the given "result" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up".
         * This function works in left handed mode
         * @param eye defines the final position of the entity
         * @param target defines where the entity should look at
         * @param up defines the up vector for the entity
         * @param result defines the target matrix
         */
        static LookAtLHToRef(eye: Vector3, target: Vector3, up: Vector3, result: Matrix): void;
        /**
         * Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up"
         * This function works in right handed mode
         * @param eye defines the final position of the entity
         * @param target defines where the entity should look at
         * @param up defines the up vector for the entity
         * @returns the new matrix
         */
        static LookAtRH(eye: Vector3, target: Vector3, up: Vector3): Matrix;
        /**
         * Sets the given "result" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up".
         * This function works in right handed mode
         * @param eye defines the final position of the entity
         * @param target defines where the entity should look at
         * @param up defines the up vector for the entity
         * @param result defines the target matrix
         */
        static LookAtRHToRef(eye: Vector3, target: Vector3, up: Vector3, result: Matrix): void;
        /**
         * Create a left-handed orthographic projection matrix
         * @param width defines the viewport width
         * @param height defines the viewport height
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @returns a new matrix as a left-handed orthographic projection matrix
         */
        static OrthoLH(width: number, height: number, znear: number, zfar: number): Matrix;
        /**
         * Store a left-handed orthographic projection to a given matrix
         * @param width defines the viewport width
         * @param height defines the viewport height
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @param result defines the target matrix
         */
        static OrthoLHToRef(width: number, height: number, znear: number, zfar: number, result: Matrix): void;
        /**
         * Create a left-handed orthographic projection matrix
         * @param left defines the viewport left coordinate
         * @param right defines the viewport right coordinate
         * @param bottom defines the viewport bottom coordinate
         * @param top defines the viewport top coordinate
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @returns a new matrix as a left-handed orthographic projection matrix
         */
        static OrthoOffCenterLH(left: number, right: number, bottom: number, top: number, znear: number, zfar: number): Matrix;
        /**
         * Stores a left-handed orthographic projection into a given matrix
         * @param left defines the viewport left coordinate
         * @param right defines the viewport right coordinate
         * @param bottom defines the viewport bottom coordinate
         * @param top defines the viewport top coordinate
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @param result defines the target matrix
         */
        static OrthoOffCenterLHToRef(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, result: Matrix): void;
        /**
         * Creates a right-handed orthographic projection matrix
         * @param left defines the viewport left coordinate
         * @param right defines the viewport right coordinate
         * @param bottom defines the viewport bottom coordinate
         * @param top defines the viewport top coordinate
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @returns a new matrix as a right-handed orthographic projection matrix
         */
        static OrthoOffCenterRH(left: number, right: number, bottom: number, top: number, znear: number, zfar: number): Matrix;
        /**
         * Stores a right-handed orthographic projection into a given matrix
         * @param left defines the viewport left coordinate
         * @param right defines the viewport right coordinate
         * @param bottom defines the viewport bottom coordinate
         * @param top defines the viewport top coordinate
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @param result defines the target matrix
         */
        static OrthoOffCenterRHToRef(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, result: Matrix): void;
        /**
         * Creates a left-handed perspective projection matrix
         * @param width defines the viewport width
         * @param height defines the viewport height
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @returns a new matrix as a left-handed perspective projection matrix
         */
        static PerspectiveLH(width: number, height: number, znear: number, zfar: number): Matrix;
        /**
         * Creates a left-handed perspective projection matrix
         * @param fov defines the horizontal field of view
         * @param aspect defines the aspect ratio
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @returns a new matrix as a left-handed perspective projection matrix
         */
        static PerspectiveFovLH(fov: number, aspect: number, znear: number, zfar: number): Matrix;
        /**
         * Stores a left-handed perspective projection into a given matrix
         * @param fov defines the horizontal field of view
         * @param aspect defines the aspect ratio
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @param result defines the target matrix
         * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally
         */
        static PerspectiveFovLHToRef(fov: number, aspect: number, znear: number, zfar: number, result: Matrix, isVerticalFovFixed?: boolean): void;
        /**
         * Creates a right-handed perspective projection matrix
         * @param fov defines the horizontal field of view
         * @param aspect defines the aspect ratio
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @returns a new matrix as a right-handed perspective projection matrix
         */
        static PerspectiveFovRH(fov: number, aspect: number, znear: number, zfar: number): Matrix;
        /**
         * Stores a right-handed perspective projection into a given matrix
         * @param fov defines the horizontal field of view
         * @param aspect defines the aspect ratio
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @param result defines the target matrix
         * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally
         */
        static PerspectiveFovRHToRef(fov: number, aspect: number, znear: number, zfar: number, result: Matrix, isVerticalFovFixed?: boolean): void;
        /**
         * Stores a perspective projection for WebVR info a given matrix
         * @param fov defines the field of view
         * @param znear defines the near clip plane
         * @param zfar defines the far clip plane
         * @param result defines the target matrix
         * @param rightHanded defines if the matrix must be in right-handed mode (false by default)
         */
        static PerspectiveFovWebVRToRef(fov: {
            upDegrees: number;
            downDegrees: number;
            leftDegrees: number;
            rightDegrees: number;
        }, znear: number, zfar: number, result: Matrix, rightHanded?: boolean): void;
        /**
         * Computes a complete transformation matrix
         * @param viewport defines the viewport to use
         * @param world defines the world matrix
         * @param view defines the view matrix
         * @param projection defines the projection matrix
         * @param zmin defines the near clip plane
         * @param zmax defines the far clip plane
         * @returns the transformation matrix
         */
        static GetFinalMatrix(viewport: Viewport, world: Matrix, view: Matrix, projection: Matrix, zmin: number, zmax: number): Matrix;
        /**
         * Extracts a 2x2 matrix from a given matrix and store the result in a Float32Array
         * @param matrix defines the matrix to use
         * @returns a new Float32Array array with 4 elements : the 2x2 matrix extracted from the given matrix
         */
        static GetAsMatrix2x2(matrix: Matrix): Float32Array;
        /**
         * Extracts a 3x3 matrix from a given matrix and store the result in a Float32Array
         * @param matrix defines the matrix to use
         * @returns a new Float32Array array with 9 elements : the 3x3 matrix extracted from the given matrix
         */
        static GetAsMatrix3x3(matrix: Matrix): Float32Array;
        /**
         * Compute the transpose of a given matrix
         * @param matrix defines the matrix to transpose
         * @returns the new matrix
         */
        static Transpose(matrix: Matrix): Matrix;
        /**
         * Compute the transpose of a matrix and store it in a target matrix
         * @param matrix defines the matrix to transpose
         * @param result defines the target matrix
         */
        static TransposeToRef(matrix: Matrix, result: Matrix): void;
        /**
         * Computes a reflection matrix from a plane
         * @param plane defines the reflection plane
         * @returns a new matrix
         */
        static Reflection(plane: Plane): Matrix;
        /**
         * Computes a reflection matrix from a plane
         * @param plane defines the reflection plane
         * @param result defines the target matrix
         */
        static ReflectionToRef(plane: Plane, result: Matrix): void;
        /**
         * Sets the given matrix as a rotation matrix composed from the 3 left handed axes
         * @param xaxis defines the value of the 1st axis
         * @param yaxis defines the value of the 2nd axis
         * @param zaxis defines the value of the 3rd axis
         * @param result defines the target matrix
         */
        static FromXYZAxesToRef(xaxis: Vector3, yaxis: Vector3, zaxis: Vector3, result: Matrix): void;
        /**
         * Creates a rotation matrix from a quaternion and stores it in a target matrix
         * @param quat defines the quaternion to use
         * @param result defines the target matrix
         */
        static FromQuaternionToRef(quat: Quaternion, result: Matrix): void;
    }
    class Plane {
        normal: Vector3;
        d: number;
        /**
         * Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0
         */
        constructor(a: number, b: number, c: number, d: number);
        /**
         * Returns the plane coordinates as a new array of 4 elements [a, b, c, d].
         */
        asArray(): number[];
        /**
         * Returns a new plane copied from the current Plane.
         */
        clone(): Plane;
        /**
         * Returns the string "Plane".
         */
        getClassName(): string;
        /**
         * Returns the Plane hash code.
         */
        getHashCode(): number;
        /**
         * Normalize the current Plane in place.
         * Returns the updated Plane.
         */
        normalize(): Plane;
        /**
         * Returns a new Plane as the result of the transformation of the current Plane by the given matrix.
         */
        transform(transformation: Matrix): Plane;
        /**
         * Returns the dot product (float) of the point coordinates and the plane normal.
         */
        dotCoordinate(point: Vector3): number;
        /**
         * Updates the current Plane from the plane defined by the three given points.
         * Returns the updated Plane.
         */
        copyFromPoints(point1: Vector3, point2: Vector3, point3: Vector3): Plane;
        /**
         * Boolean : True is the vector "direction"  is the same side than the plane normal.
         */
        isFrontFacingTo(direction: Vector3, epsilon: number): boolean;
        /**
         * Returns the signed distance (float) from the given point to the Plane.
         */
        signedDistanceTo(point: Vector3): number;
        /**
         * Returns a new Plane from the given array.
         */
        static FromArray(array: ArrayLike<number>): Plane;
        /**
         * Returns a new Plane defined by the three given points.
         */
        static FromPoints(point1: Vector3, point2: Vector3, point3: Vector3): Plane;
        /**
         * Returns a new Plane the normal vector to this plane at the given origin point.
         * Note : the vector "normal" is updated because normalized.
         */
        static FromPositionAndNormal(origin: Vector3, normal: Vector3): Plane;
        /**
         * Returns the signed distance between the plane defined by the normal vector at the "origin"" point and the given other point.
         */
        static SignedDistanceToPlaneFromPositionAndNormal(origin: Vector3, normal: Vector3, point: Vector3): number;
    }
    class Viewport {
        x: number;
        y: number;
        width: number;
        height: number;
        /**
         * Creates a Viewport object located at (x, y) and sized (width, height).
         */
        constructor(x: number, y: number, width: number, height: number);
        toGlobal(renderWidthOrEngine: number | Engine, renderHeight: number): Viewport;
        /**
         * Returns a new Viewport copied from the current one.
         */
        clone(): Viewport;
    }
    class Frustum {
        /**
         * Returns a new array of 6 Frustum planes computed by the given transformation matrix.
         */
        static GetPlanes(transform: Matrix): Plane[];
        static GetNearPlaneToRef(transform: Matrix, frustumPlane: Plane): void;
        static GetFarPlaneToRef(transform: Matrix, frustumPlane: Plane): void;
        static GetLeftPlaneToRef(transform: Matrix, frustumPlane: Plane): void;
        static GetRightPlaneToRef(transform: Matrix, frustumPlane: Plane): void;
        static GetTopPlaneToRef(transform: Matrix, frustumPlane: Plane): void;
        static GetBottomPlaneToRef(transform: Matrix, frustumPlane: Plane): void;
        /**
         * Sets the given array "frustumPlanes" with the 6 Frustum planes computed by the given transformation matrix.
         */
        static GetPlanesToRef(transform: Matrix, frustumPlanes: Plane[]): void;
    }
    /** Defines supported spaces */
    enum Space {
        /** Local (object) space */
        LOCAL = 0,
        /** World space */
        WORLD = 1,
        /** Bone space */
        BONE = 2,
    }
    /** Defines the 3 main axes */
    class Axis {
        /** X axis */
        static X: Vector3;
        /** Y axis */
        static Y: Vector3;
        /** Z axis */
        static Z: Vector3;
    }
    class BezierCurve {
        /**
         * Returns the cubic Bezier interpolated value (float) at "t" (float) from the given x1, y1, x2, y2 floats.
         */
        static interpolate(t: number, x1: number, y1: number, x2: number, y2: number): number;
    }
    /**
     * Defines potential orientation for back face culling
     */
    enum Orientation {
        /**
         * Clockwise
         */
        CW = 0,
        /** Counter clockwise */
        CCW = 1,
    }
    /**
     * Defines angle representation
     */
    class Angle {
        private _radians;
        /**
         * Creates an Angle object of "radians" radians (float).
         */
        constructor(radians: number);
        /**
         * Get value in degrees
         * @returns the Angle value in degrees (float)
         */
        degrees(): number;
        /**
         * Get value in radians
         * @returns the Angle value in radians (float)
         */
        radians(): number;
        /**
         * Gets a new Angle object valued with the angle value in radians between the two given vectors
         * @param a defines first vector
         * @param b defines second vector
         * @returns a new Angle
         */
        static BetweenTwoPoints(a: Vector2, b: Vector2): Angle;
        /**
         * Gets a new Angle object from the given float in radians
         * @param radians defines the angle value in radians
         * @returns a new Angle
         */
        static FromRadians(radians: number): Angle;
        /**
         * Gets a new Angle object from the given float in degrees
         * @param degrees defines the angle value in degrees
         * @returns a new Angle
         */
        static FromDegrees(degrees: number): Angle;
    }
    class Arc2 {
        startPoint: Vector2;
        midPoint: Vector2;
        endPoint: Vector2;
        centerPoint: Vector2;
        radius: number;
        angle: Angle;
        startAngle: Angle;
        orientation: Orientation;
        /**
         * Creates an Arc object from the three given points : start, middle and end.
         */
        constructor(startPoint: Vector2, midPoint: Vector2, endPoint: Vector2);
    }
    class Path2 {
        private _points;
        private _length;
        closed: boolean;
        /**
         * Creates a Path2 object from the starting 2D coordinates x and y.
         */
        constructor(x: number, y: number);
        /**
         * Adds a new segment until the given coordinates (x, y) to the current Path2.
         * Returns the updated Path2.
         */
        addLineTo(x: number, y: number): Path2;
        /**
         * Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.
         * Returns the updated Path2.
         */
        addArcTo(midX: number, midY: number, endX: number, endY: number, numberOfSegments?: number): Path2;
        /**
         * Closes the Path2.
         * Returns the Path2.
         */
        close(): Path2;
        /**
         * Returns the Path2 total length (float).
         */
        length(): number;
        /**
         * Returns the Path2 internal array of points.
         */
        getPoints(): Vector2[];
        /**
         * Returns a new Vector2 located at a percentage of the Path2 total length on this path.
         */
        getPointAtLengthPosition(normalizedLengthPosition: number): Vector2;
        /**
         * Returns a new Path2 starting at the coordinates (x, y).
         */
        static StartingAt(x: number, y: number): Path2;
    }
    class Path3D {
        path: Vector3[];
        private _curve;
        private _distances;
        private _tangents;
        private _normals;
        private _binormals;
        private _raw;
        /**
        * new Path3D(path, normal, raw)
        * Creates a Path3D. A Path3D is a logical math object, so not a mesh.
        * please read the description in the tutorial :  http://doc.babylonjs.com/tutorials/How_to_use_Path3D
        * path : an array of Vector3, the curve axis of the Path3D
        * normal (optional) : Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.
        * raw (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.
        */
        constructor(path: Vector3[], firstNormal?: Nullable<Vector3>, raw?: boolean);
        /**
         * Returns the Path3D array of successive Vector3 designing its curve.
         */
        getCurve(): Vector3[];
        /**
         * Returns an array populated with tangent vectors on each Path3D curve point.
         */
        getTangents(): Vector3[];
        /**
         * Returns an array populated with normal vectors on each Path3D curve point.
         */
        getNormals(): Vector3[];
        /**
         * Returns an array populated with binormal vectors on each Path3D curve point.
         */
        getBinormals(): Vector3[];
        /**
         * Returns an array populated with distances (float) of the i-th point from the first curve point.
         */
        getDistances(): number[];
        /**
         * Forces the Path3D tangent, normal, binormal and distance recomputation.
         * Returns the same object updated.
         */
        update(path: Vector3[], firstNormal?: Nullable<Vector3>): Path3D;
        private _compute(firstNormal);
        private _getFirstNonNullVector(index);
        private _getLastNonNullVector(index);
        private _normalVector(v0, vt, va);
    }
    class Curve3 {
        private _points;
        private _length;
        /**
         * Returns a Curve3 object along a Quadratic Bezier curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#quadratic-bezier-curve
         * @param v0 (Vector3) the origin point of the Quadratic Bezier
         * @param v1 (Vector3) the control point
         * @param v2 (Vector3) the end point of the Quadratic Bezier
         * @param nbPoints (integer) the wanted number of points in the curve
         */
        static CreateQuadraticBezier(v0: Vector3, v1: Vector3, v2: Vector3, nbPoints: number): Curve3;
        /**
         * Returns a Curve3 object along a Cubic Bezier curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#cubic-bezier-curve
         * @param v0 (Vector3) the origin point of the Cubic Bezier
         * @param v1 (Vector3) the first control point
         * @param v2 (Vector3) the second control point
         * @param v3 (Vector3) the end point of the Cubic Bezier
         * @param nbPoints (integer) the wanted number of points in the curve
         */
        static CreateCubicBezier(v0: Vector3, v1: Vector3, v2: Vector3, v3: Vector3, nbPoints: number): Curve3;
        /**
         * Returns a Curve3 object along a Hermite Spline curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#hermite-spline
         * @param p1 (Vector3) the origin point of the Hermite Spline
         * @param t1 (Vector3) the tangent vector at the origin point
         * @param p2 (Vector3) the end point of the Hermite Spline
         * @param t2 (Vector3) the tangent vector at the end point
         * @param nbPoints (integer) the wanted number of points in the curve
         */
        static CreateHermiteSpline(p1: Vector3, t1: Vector3, p2: Vector3, t2: Vector3, nbPoints: number): Curve3;
        /**
         * Returns a Curve3 object along a CatmullRom Spline curve :
         * @param points (array of Vector3) the points the spline must pass through. At least, four points required.
         * @param nbPoints (integer) the wanted number of points between each curve control points.
         */
        static CreateCatmullRomSpline(points: Vector3[], nbPoints: number): Curve3;
        /**
         * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.
         * A Curve3 is designed from a series of successive Vector3.
         * Tuto : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#curve3-object
         */
        constructor(points: Vector3[]);
        /**
         * Returns the Curve3 stored array of successive Vector3
         */
        getPoints(): Vector3[];
        /**
         * Returns the computed length (float) of the curve.
         */
        length(): number;
        /**
         * Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);
         * This new Curve3 is built by translating and sticking the curveB at the end of the curveA.
         * curveA and curveB keep unchanged.
         */
        continue(curve: Curve3): Curve3;
        private _computeLength(path);
    }
    class PositionNormalVertex {
        position: Vector3;
        normal: Vector3;
        constructor(position?: Vector3, normal?: Vector3);
        clone(): PositionNormalVertex;
    }
    class PositionNormalTextureVertex {
        position: Vector3;
        normal: Vector3;
        uv: Vector2;
        constructor(position?: Vector3, normal?: Vector3, uv?: Vector2);
        clone(): PositionNormalTextureVertex;
    }
    class Tmp {
        static Color3: Color3[];
        static Vector2: Vector2[];
        static Vector3: Vector3[];
        static Vector4: Vector4[];
        static Quaternion: Quaternion[];
        static Matrix: Matrix[];
    }
}

declare module BABYLON {
    class SphericalPolynomial {
        x: Vector3;
        y: Vector3;
        z: Vector3;
        xx: Vector3;
        yy: Vector3;
        zz: Vector3;
        xy: Vector3;
        yz: Vector3;
        zx: Vector3;
        addAmbient(color: Color3): void;
        static getSphericalPolynomialFromHarmonics(harmonics: SphericalHarmonics): SphericalPolynomial;
        scale(scale: number): void;
    }
    class SphericalHarmonics {
        L00: Vector3;
        L1_1: Vector3;
        L10: Vector3;
        L11: Vector3;
        L2_2: Vector3;
        L2_1: Vector3;
        L20: Vector3;
        L21: Vector3;
        L22: Vector3;
        addLight(direction: Vector3, color: Color3, deltaSolidAngle: number): void;
        scale(scale: number): void;
        convertIncidentRadianceToIrradiance(): void;
        convertIrradianceToLambertianRadiance(): void;
        static getsphericalHarmonicsFromPolynomial(polynomial: SphericalPolynomial): SphericalHarmonics;
    }
}

declare module BABYLON {
    /**
     * Defines a target to use with MorphTargetManager
     * @see http://doc.babylonjs.com/how_to/how_to_use_morphtargets
     */
    class MorphTarget implements IAnimatable {
        /** defines the name of the target */
        name: string;
        /**
         * Gets or sets the list of animations
         */
        animations: Animation[];
        private _scene;
        private _positions;
        private _normals;
        private _tangents;
        private _influence;
        /**
         * Observable raised when the influence changes
         */
        onInfluenceChanged: Observable<boolean>;
        /**
         * Gets or sets the influence of this target (ie. its weight in the overall morphing)
         */
        influence: number;
        private _animationPropertiesOverride;
        /**
         * Gets or sets the animation properties override
         */
        animationPropertiesOverride: Nullable<AnimationPropertiesOverride>;
        /**
         * Creates a new MorphTarget
         * @param name defines the name of the target
         * @param influence defines the influence to use
         */
        constructor(
            /** defines the name of the target */
            name: string, influence?: number, scene?: Nullable<Scene>);
        /**
         * Gets a boolean defining if the target contains position data
         */
        readonly hasPositions: boolean;
        /**
         * Gets a boolean defining if the target contains normal data
         */
        readonly hasNormals: boolean;
        /**
         * Gets a boolean defining if the target contains tangent data
         */
        readonly hasTangents: boolean;
        /**
         * Affects position data to this target
         * @param data defines the position data to use
         */
        setPositions(data: Nullable<FloatArray>): void;
        /**
         * Gets the position data stored in this target
         * @returns a FloatArray containing the position data (or null if not present)
         */
        getPositions(): Nullable<FloatArray>;
        /**
         * Affects normal data to this target
         * @param data defines the normal data to use
         */
        setNormals(data: Nullable<FloatArray>): void;
        /**
         * Gets the normal data stored in this target
         * @returns a FloatArray containing the normal data (or null if not present)
         */
        getNormals(): Nullable<FloatArray>;
        /**
         * Affects tangent data to this target
         * @param data defines the tangent data to use
         */
        setTangents(data: Nullable<FloatArray>): void;
        /**
         * Gets the tangent data stored in this target
         * @returns a FloatArray containing the tangent data (or null if not present)
         */
        getTangents(): Nullable<FloatArray>;
        /**
         * Serializes the current target into a Serialization object
         * @returns the serialized object
         */
        serialize(): any;
        /**
         * Creates a new target from serialized data
         * @param serializationObject defines the serialized data to use
         * @returns a new MorphTarget
         */
        static Parse(serializationObject: any): MorphTarget;
        /**
         * Creates a MorphTarget from mesh data
         * @param mesh defines the source mesh
         * @param name defines the name to use for the new target
         * @param influence defines the influence to attach to the target
         * @returns a new MorphTarget
         */
        static FromMesh(mesh: AbstractMesh, name?: string, influence?: number): MorphTarget;
    }
}

declare module BABYLON {
    /**
     * This class is used to deform meshes using morphing between different targets
     * @see http://doc.babylonjs.com/how_to/how_to_use_morphtargets
     */
    class MorphTargetManager {
        private _targets;
        private _targetObservable;
        private _activeTargets;
        private _scene;
        private _influences;
        private _supportsNormals;
        private _supportsTangents;
        private _vertexCount;
        private _uniqueId;
        private _tempInfluences;
        /**
         * Creates a new MorphTargetManager
         * @param scene defines the current scene
         */
        constructor(scene?: Nullable<Scene>);
        /**
         * Gets the unique ID of this manager
         */
        readonly uniqueId: number;
        /**
         * Gets the number of vertices handled by this manager
         */
        readonly vertexCount: number;
        /**
         * Gets a boolean indicating if this manager supports morphing of normals
         */
        readonly supportsNormals: boolean;
        /**
         * Gets a boolean indicating if this manager supports morphing of tangents
         */
        readonly supportsTangents: boolean;
        /**
         * Gets the number of targets stored in this manager
         */
        readonly numTargets: number;
        /**
         * Gets the number of influencers (ie. the number of targets with influences > 0)
         */
        readonly numInfluencers: number;
        /**
         * Gets the list of influences (one per target)
         */
        readonly influences: Float32Array;
        /**
         * Gets the active target at specified index. An active target is a target with an influence > 0
         * @param index defines the index to check
         * @returns the requested target
         */
        getActiveTarget(index: number): MorphTarget;
        /**
         * Gets the target at specified index
         * @param index defines the index to check
         * @returns the requested target
         */
        getTarget(index: number): MorphTarget;
        /**
         * Add a new target to this manager
         * @param target defines the target to add
         */
        addTarget(target: MorphTarget): void;
        /**
         * Removes a target from the manager
         * @param target defines the target to remove
         */
        removeTarget(target: MorphTarget): void;
        /**
         * Serializes the current manager into a Serialization object
         * @returns the serialized object
         */
        serialize(): any;
        private _syncActiveTargets(needUpdate);
        /**
         * Syncrhonize the targets with all the meshes using this morph target manager
         */
        synchronize(): void;
        /**
         * Creates a new MorphTargetManager from serialized data
         * @param serializationObject defines the serialized data
         * @param scene defines the hosting scene
         * @returns the new MorphTargetManager
         */
        static Parse(serializationObject: any, scene: Scene): MorphTargetManager;
    }
}

declare module BABYLON {
    /**
     * Class used to store all common mesh properties
     */
    class AbstractMesh extends TransformNode implements IDisposable, ICullable, IGetSetVerticesData {
        /** No occlusion */
        static OCCLUSION_TYPE_NONE: number;
        /** Occlusion set to optimisitic */
        static OCCLUSION_TYPE_OPTIMISTIC: number;
        /** Occlusion set to strict */
        static OCCLUSION_TYPE_STRICT: number;
        /** Use an accurante occlusion algorithm */
        static OCCLUSION_ALGORITHM_TYPE_ACCURATE: number;
        /** Use a conservative occlusion algorithm */
        static OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE: number;
        /**
         * No billboard
         */
        static readonly BILLBOARDMODE_NONE: number;
        /** Billboard on X axis */
        static readonly BILLBOARDMODE_X: number;
        /** Billboard on Y axis */
        static readonly BILLBOARDMODE_Y: number;
        /** Billboard on Z axis */
        static readonly BILLBOARDMODE_Z: number;
        /** Billboard on all axes */
        static readonly BILLBOARDMODE_ALL: number;
        private _facetPositions;
        private _facetNormals;
        private _facetPartitioning;
        private _facetNb;
        private _partitioningSubdivisions;
        private _partitioningBBoxRatio;
        private _facetDataEnabled;
        private _facetParameters;
        private _bbSize;
        private _subDiv;
        private _facetDepthSort;
        private _facetDepthSortEnabled;
        private _depthSortedIndices;
        private _depthSortedFacets;
        private _facetDepthSortFunction;
        private _facetDepthSortFrom;
        private _facetDepthSortOrigin;
        private _invertedMatrix;
        /**
         * Gets the number of facets in the mesh
         * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet
         */
        readonly facetNb: number;
        /**
         * Gets or set the number (integer) of subdivisions per axis in the partioning space
         * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning
         */
        partitioningSubdivisions: number;
        /**
         * The ratio (float) to apply to the bouding box size to set to the partioning space.
         * Ex : 1.01 (default) the partioning space is 1% bigger than the bounding box
         * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning
         */
        partitioningBBoxRatio: number;
        /**
         * Gets or sets a boolean indicating that the facets must be depth sorted on next call to `updateFacetData()`.
         * Works only for updatable meshes.
         * Doesn't work with multi-materials
         * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort
         */
        mustDepthSortFacets: boolean;
        /**
         * The location (Vector3) where the facet depth sort must be computed from.
         * By default, the active camera position.
         * Used only when facet depth sort is enabled
         * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort
         */
        facetDepthSortFrom: Vector3;
        /**
         * gets a boolean indicating if facetData is enabled
         * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet
         */
        readonly isFacetDataEnabled: boolean;
        /** @hidden */
        _updateNonUniformScalingState(value: boolean): boolean;
        /**
        * An event triggered when this mesh collides with another one
        */
        onCollideObservable: Observable<AbstractMesh>;
        private _onCollideObserver;
        /** Set a function to call when this mesh collides with another one */
        onCollide: () => void;
        /**
        * An event triggered when the collision's position changes
        */
        onCollisionPositionChangeObservable: Observable<Vector3>;
        private _onCollisionPositionChangeObserver;
        /** Set a function to call when the collision's position changes */
        onCollisionPositionChange: () => void;
        /**
        * An event triggered when material is changed
        */
        onMaterialChangedObservable: Observable<AbstractMesh>;
        /**
         * Gets or sets the orientation for POV movement & rotation
         */
        definedFacingForward: boolean;
        /**
        * This property determines the type of occlusion query algorithm to run in WebGl, you can use:
        * * AbstractMesh.OCCLUSION_ALGORITHM_TYPE_ACCURATE which is mapped to GL_ANY_SAMPLES_PASSED.
        * * AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE (Default Value) which is mapped to GL_ANY_SAMPLES_PASSED_CONSERVATIVE which is a false positive algorithm that is faster than GL_ANY_SAMPLES_PASSED but less accurate.
        * @see http://doc.babylonjs.com/features/occlusionquery
        */
        occlusionQueryAlgorithmType: number;
        /**
         * This property is responsible for starting the occlusion query within the Mesh or not, this property is also used to determine what should happen when the occlusionRetryCount is reached. It has supports 3 values:
         * * OCCLUSION_TYPE_NONE (Default Value): this option means no occlusion query whith the Mesh.
         * * OCCLUSION_TYPE_OPTIMISTIC: this option is means use occlusion query and if occlusionRetryCount is reached and the query is broken show the mesh.
         * * OCCLUSION_TYPE_STRICT: this option is means use occlusion query and if occlusionRetryCount is reached and the query is broken restore the last state of the mesh occlusion if the mesh was visible then show the mesh if was hidden then hide don't show.
         * @see http://doc.babylonjs.com/features/occlusionquery
         */
        occlusionType: number;
        /**
        * This number indicates the number of allowed retries before stop the occlusion query, this is useful if the occlusion query is taking long time before to the query result is retireved, the query result indicates if the object is visible within the scene or not and based on that Babylon.Js engine decideds to show or hide the object.
        * The default value is -1 which means don't break the query and wait till the result
        * @see http://doc.babylonjs.com/features/occlusionquery
        */
        occlusionRetryCount: number;
        private _occlusionInternalRetryCounter;
        protected _isOccluded: boolean;
        /**
        * Gets or sets whether the mesh is occluded or not, it is used also to set the intial state of the mesh to be occluded or not
        * @see http://doc.babylonjs.com/features/occlusionquery
        */
        isOccluded: boolean;
        private _isOcclusionQueryInProgress;
        /**
         * Flag to check the progress status of the query
         * @see http://doc.babylonjs.com/features/occlusionquery
         */
        readonly isOcclusionQueryInProgress: boolean;
        private _occlusionQuery;
        private _visibility;
        /**
         * Gets or sets mesh visibility between 0 and 1 (default is 1)
         */
        /**
         * Gets or sets mesh visibility between 0 and 1 (default is 1)
         */
        visibility: number;
        /** Gets or sets the alpha index used to sort transparent meshes
         * @see http://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#alpha-index
         */
        alphaIndex: number;
        /**
         * Gets or sets a boolean indicating if the mesh is visible (renderable). Default is true
         */
        isVisible: boolean;
        /**
         * Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true
         */
        isPickable: boolean;
        /**
         * Gets or sets a boolean indicating if the bounding box must be rendered as well (false by default)
         */
        showBoundingBox: boolean;
        /** Gets or sets a boolean indicating that bounding boxes of subMeshes must be rendered as well (false by default) */
        showSubMeshesBoundingBox: boolean;
        /** Gets or sets a boolean indicating if the mesh must be considered as a ray blocker for lens flares (false by default)
         * @see http://doc.babylonjs.com/how_to/how_to_use_lens_flares
         */
        isBlocker: boolean;
        /**
         * Gets or sets a boolean indicating that pointer move events must be supported on this mesh (false by default)
         */
        enablePointerMoveEvents: boolean;
        /**
         * Specifies the rendering group id for this mesh (0 by default)
         * @see http://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#rendering-groups
         */
        renderingGroupId: number;
        private _material;
        /** Gets or sets current material */
        material: Nullable<Material>;
        private _receiveShadows;
        /**
         * Gets or sets a boolean indicating that this mesh can receive realtime shadows
         * @see http://doc.babylonjs.com/babylon101/shadows
         */
        receiveShadows: boolean;
        /**
         * Gets or sets a boolean indicating if the outline must be rendered as well
         * @see https://www.babylonjs-playground.com/#10WJ5S#3
         */
        renderOutline: boolean;
        /** Defines color to use when rendering outline */
        outlineColor: Color3;
        /** Define width to use when rendering outline */
        outlineWidth: number;
        /**
         * Gets or sets a boolean indicating if the overlay must be rendered as well
         * @see https://www.babylonjs-playground.com/#10WJ5S#2
         */
        renderOverlay: boolean;
        /** Defines color to use when rendering overlay */
        overlayColor: Color3;
        /** Defines alpha to use when rendering overlay */
        overlayAlpha: number;
        private _hasVertexAlpha;
        /** Gets or sets a boolean indicating that this mesh contains vertex color data with alpha values */
        hasVertexAlpha: boolean;
        private _useVertexColors;
        /** Gets or sets a boolean indicating that this mesh needs to use vertex color data to render (if this kind of vertex data is available in the geometry) */
        useVertexColors: boolean;
        private _computeBonesUsingShaders;
        /**
         * Gets or sets a boolean indicating that bone animations must be computed by the CPU (false by default)
         */
        computeBonesUsingShaders: boolean;
        private _numBoneInfluencers;
        /** Gets or sets the number of allowed bone influences per vertex (4 by default) */
        numBoneInfluencers: number;
        private _applyFog;
        /** Gets or sets a boolean indicating that this mesh will allow fog to be rendered on it (true by default) */
        applyFog: boolean;
        /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes selection (true by default) */
        useOctreeForRenderingSelection: boolean;
        /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes picking (true by default) */
        useOctreeForPicking: boolean;
        /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes collision (true by default) */
        useOctreeForCollisions: boolean;
        private _layerMask;
        /**
         * Gets or sets the current layer mask (default is 0x0FFFFFFF)
         * @see http://doc.babylonjs.com/how_to/layermasks_and_multi-cam_textures
         */
        layerMask: number;
        /**
         * True if the mesh must be rendered in any case (this will shortcut the frustum clipping phase)
         */
        alwaysSelectAsActiveMesh: boolean;
        /**
         * Gets or sets the current action manager
         * @see http://doc.babylonjs.com/how_to/how_to_use_actions
         */
        actionManager: Nullable<ActionManager>;
        /**
         * Gets or sets impostor used for physic simulation
         * @see http://doc.babylonjs.com/features/physics_engine
         */
        physicsImpostor: Nullable<PhysicsImpostor>;
        private _checkCollisions;
        private _collisionMask;
        private _collisionGroup;
        /**
         * Gets or sets the ellipsoid used to impersonate this mesh when using collision engine (default is (0.5, 1, 0.5))
         * @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
         */
        ellipsoid: Vector3;
        /**
         * Gets or sets the ellipsoid offset used to impersonate this mesh when using collision engine (default is (0, 0, 0))
         * @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
         */
        ellipsoidOffset: Vector3;
        private _collider;
        private _oldPositionForCollisions;
        private _diffPositionForCollisions;
        /**
         * Gets or sets a collision mask used to mask collisions (default is -1).
         * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0
         */
        collisionMask: number;
        /**
         * Gets or sets the current collision group mask (-1 by default).
         * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0
         */
        collisionGroup: number;
        /**
         * Defines edge width used when edgesRenderer is enabled
         * @see https://www.babylonjs-playground.com/#10OJSG#13
         */
        edgesWidth: number;
        /**
         * Defines edge color used when edgesRenderer is enabled
         * @see https://www.babylonjs-playground.com/#10OJSG#13
         */
        edgesColor: Color4;
        /** @hidden */
        _edgesRenderer: Nullable<EdgesRenderer>;
        private _collisionsTransformMatrix;
        private _collisionsScalingMatrix;
        /** @hidden */
        _masterMesh: Nullable<AbstractMesh>;
        /** @hidden */
        _boundingInfo: Nullable<BoundingInfo>;
        /** @hidden */
        _renderId: number;
        /**
         * Gets or sets the list of subMeshes
         * @see http://doc.babylonjs.com/how_to/multi_materials
         */
        subMeshes: SubMesh[];
        /** @hidden */
        _submeshesOctree: Octree<SubMesh>;
        /** @hidden */
        _intersectionsInProgress: AbstractMesh[];
        /** @hidden */
        _unIndexed: boolean;
        /** @hidden */
        _lightSources: Light[];
        /** @hidden */
        readonly _positions: Nullable<Vector3[]>;
        /** @hidden */
        _waitingActions: any;
        /** @hidden */
        _waitingFreezeWorldMatrix: Nullable<boolean>;
        private _skeleton;
        /** @hidden */
        _bonesTransformMatrices: Nullable<Float32Array>;
        /**
         * Gets or sets a skeleton to apply skining transformations
         * @see http://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons
         */
        skeleton: Nullable<Skeleton>;
        /**
         * Creates a new AbstractMesh
         * @param name defines the name of the mesh
         * @param scene defines the hosting scene
         */
        constructor(name: string, scene?: Nullable<Scene>);
        /**
         * Returns the string "AbstractMesh"
         * @returns "AbstractMesh"
         */
        getClassName(): string;
        /**
         * Gets a string representation of the current mesh
         * @param fullDetails defines a boolean indicating if full details must be included
         * @returns a string representation of the current mesh
         */
        toString(fullDetails?: boolean): string;
        /** @hidden */
        _rebuild(): void;
        /** @hidden */
        _resyncLightSources(): void;
        /** @hidden */
        _resyncLighSource(light: Light): void;
        /** @hidden */
        _unBindEffect(): void;
        /** @hidden */
        _removeLightSource(light: Light): void;
        private _markSubMeshesAsDirty(func);
        /** @hidden */
        _markSubMeshesAsLightDirty(): void;
        /** @hidden */
        _markSubMeshesAsAttributesDirty(): void;
        /** @hidden */
        _markSubMeshesAsMiscDirty(): void;
        /**
        * Gets or sets a Vector3 depicting the mesh scaling along each local axis X, Y, Z.  Default is (1.0, 1.0, 1.0)
        */
        scaling: Vector3;
        /**
         * Disables the mesh edge rendering mode
         * @returns the currentAbstractMesh
         */
        disableEdgesRendering(): AbstractMesh;
        /**
         * Enables the edge rendering mode on the mesh.
         * This mode makes the mesh edges visible
         * @param epsilon defines the maximal distance between two angles to detect a face
         * @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces
         * @returns the currentAbstractMesh
         * @see https://www.babylonjs-playground.com/#19O9TU#0
         */
        enableEdgesRendering(epsilon?: number, checkVerticesInsteadOfIndices?: boolean): AbstractMesh;
        /**
         * Returns true if the mesh is blocked. Implemented by child classes
         */
        readonly isBlocked: boolean;
        /**
         * Returns the mesh itself by default. Implemented by child classes
         * @param camera defines the camera to use to pick the right LOD level
         * @returns the currentAbstractMesh
         */
        getLOD(camera: Camera): AbstractMesh;
        /**
         * Returns 0 by default. Implemented by child classes
         * @returns an integer
         */
        getTotalVertices(): number;
        /**
         * Returns null by default. Implemented by child classes
         * @returns null
         */
        getIndices(): Nullable<IndicesArray>;
        /**
         * Returns the array of the requested vertex data kind. Implemented by child classes
         * @param kind defines the vertex data kind to use
         * @returns null
         */
        getVerticesData(kind: string): Nullable<FloatArray>;
        /**
         * Sets the vertex data of the mesh geometry for the requested `kind`.
         * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
         * Note that a new underlying VertexBuffer object is created each call.
         * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
         * @param kind defines vertex data kind:
         * * BABYLON.VertexBuffer.PositionKind
         * * BABYLON.VertexBuffer.UVKind
         * * BABYLON.VertexBuffer.UV2Kind
         * * BABYLON.VertexBuffer.UV3Kind
         * * BABYLON.VertexBuffer.UV4Kind
         * * BABYLON.VertexBuffer.UV5Kind
         * * BABYLON.VertexBuffer.UV6Kind
         * * BABYLON.VertexBuffer.ColorKind
         * * BABYLON.VertexBuffer.MatricesIndicesKind
         * * BABYLON.VertexBuffer.MatricesIndicesExtraKind
         * * BABYLON.VertexBuffer.MatricesWeightsKind
         * * BABYLON.VertexBuffer.MatricesWeightsExtraKind
         * @param data defines the data source
         * @param updatable defines if the data must be flagged as updatable (or static)
         * @param stride defines the vertex stride (size of an entire vertex). Can be null and in this case will be deduced from vertex data kind
         * @returns the current mesh
         */
        setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh;
        /**
         * Updates the existing vertex data of the mesh geometry for the requested `kind`.
         * If the mesh has no geometry, it is simply returned as it is.
         * @param kind defines vertex data kind:
         * * BABYLON.VertexBuffer.PositionKind
         * * BABYLON.VertexBuffer.UVKind
         * * BABYLON.VertexBuffer.UV2Kind
         * * BABYLON.VertexBuffer.UV3Kind
         * * BABYLON.VertexBuffer.UV4Kind
         * * BABYLON.VertexBuffer.UV5Kind
         * * BABYLON.VertexBuffer.UV6Kind
         * * BABYLON.VertexBuffer.ColorKind
         * * BABYLON.VertexBuffer.MatricesIndicesKind
         * * BABYLON.VertexBuffer.MatricesIndicesExtraKind
         * * BABYLON.VertexBuffer.MatricesWeightsKind
         * * BABYLON.VertexBuffer.MatricesWeightsExtraKind
         * @param data defines the data source
         * @param updateExtends If `kind` is `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed
         * @param makeItUnique If true, a new global geometry is created from this data and is set to the mesh
         * @returns the current mesh
         */
        updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): AbstractMesh;
        /**
         * Sets the mesh indices,
         * If the mesh has no geometry, a new Geometry object is created and set to the mesh.
         * @param indices Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array)
         * @param totalVertices Defines the total number of vertices
         * @returns the current mesh
         */
        setIndices(indices: IndicesArray, totalVertices: Nullable<number>): AbstractMesh;
        /**
         * Gets a boolean indicating if specific vertex data is present
         * @param kind defines the vertex data kind to use
         * @returns true is data kind is present
         */
        isVerticesDataPresent(kind: string): boolean;
        /**
         * Returns the mesh BoundingInfo object or creates a new one and returns if it was undefined
         * @returns a BoundingInfo
         */
        getBoundingInfo(): BoundingInfo;
        /**
         * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)
         * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box
         * @returns the current mesh
         */
        normalizeToUnitCube(includeDescendants?: boolean): AbstractMesh;
        /**
         * Overwrite the current bounding info
         * @param boundingInfo defines the new bounding info
         * @returns the current mesh
         */
        setBoundingInfo(boundingInfo: BoundingInfo): AbstractMesh;
        /** Gets a boolean indicating if this mesh has skinning data and an attached skeleton */
        readonly useBones: boolean;
        /** @hidden */
        _preActivate(): void;
        /** @hidden */
        _preActivateForIntermediateRendering(renderId: number): void;
        /** @hidden */
        _activate(renderId: number): void;
        /**
         * Gets the current world matrix
         * @returns a Matrix
         */
        getWorldMatrix(): Matrix;
        /** @hidden */
        _getWorldMatrixDeterminant(): number;
        /**
         * Perform relative position change from the point of view of behind the front of the mesh.
         * This is performed taking into account the meshes current rotation, so you do not have to care.
         * Supports definition of mesh facing forward or backward
         * @param amountRight defines the distance on the right axis
         * @param amountUp defines the distance on the up axis
         * @param amountForward defines the distance on the forward axis
         * @returns the current mesh
         */
        movePOV(amountRight: number, amountUp: number, amountForward: number): AbstractMesh;
        /**
         * Calculate relative position change from the point of view of behind the front of the mesh.
         * This is performed taking into account the meshes current rotation, so you do not have to care.
         * Supports definition of mesh facing forward or backward
         * @param amountRight defines the distance on the right axis
         * @param amountUp defines the distance on the up axis
         * @param amountForward defines the distance on the forward axis
         * @returns the new displacement vector
         */
        calcMovePOV(amountRight: number, amountUp: number, amountForward: number): Vector3;
        /**
         * Perform relative rotation change from the point of view of behind the front of the mesh.
         * Supports definition of mesh facing forward or backward
         * @param flipBack defines the flip
         * @param twirlClockwise defines the twirl
         * @param tiltRight defines the tilt
         * @returns the current mesh
         */
        rotatePOV(flipBack: number, twirlClockwise: number, tiltRight: number): AbstractMesh;
        /**
         * Calculate relative rotation change from the point of view of behind the front of the mesh.
         * Supports definition of mesh facing forward or backward.
         * @param flipBack defines the flip
         * @param twirlClockwise defines the twirl
         * @param tiltRight defines the tilt
         * @returns the new rotation vector
         */
        calcRotatePOV(flipBack: number, twirlClockwise: number, tiltRight: number): Vector3;
        /**
         * Return the minimum and maximum world vectors of the entire hierarchy under current mesh
         * @param includeDescendants Include bounding info from descendants as well (true by default)
         * @returns the new bounding vectors
         */
        getHierarchyBoundingVectors(includeDescendants?: boolean): {
            min: Vector3;
            max: Vector3;
        };
        /** @hidden */
        _updateBoundingInfo(): AbstractMesh;
        /** @hidden */
        _updateSubMeshesBoundingInfo(matrix: Matrix): AbstractMesh;
        /** @hidden */
        protected _afterComputeWorldMatrix(): void;
        /**
         * Returns `true` if the mesh is within the frustum defined by the passed array of planes.
         * A mesh is in the frustum if its bounding box intersects the frustum
         * @param frustumPlanes defines the frustum to test
         * @returns true if the mesh is in the frustum planes
         */
        isInFrustum(frustumPlanes: Plane[]): boolean;
        /**
         * Returns `true` if the mesh is completely in the frustum defined be the passed array of planes.
         * A mesh is completely in the frustum if its bounding box it completely inside the frustum.
         * @param frustumPlanes defines the frustum to test
         * @returns true if the mesh is completely in the frustum planes
         */
        isCompletelyInFrustum(frustumPlanes: Plane[]): boolean;
        /**
         * True if the mesh intersects another mesh or a SolidParticle object
         * @param mesh defines a target mesh or SolidParticle to test
         * @param precise Unless the parameter `precise` is set to `true` the intersection is computed according to Axis Aligned Bounding Boxes (AABB), else according to OBB (Oriented BBoxes)
         * @param includeDescendants Can be set to true to test if the mesh defined in parameters intersects with the current mesh or any child meshes
         * @returns true if there is an intersection
         */
        intersectsMesh(mesh: AbstractMesh | SolidParticle, precise?: boolean, includeDescendants?: boolean): boolean;
        /**
         * Returns true if the passed point (Vector3) is inside the mesh bounding box
         * @param point defines the point to test
         * @returns true if there is an intersection
         */
        intersectsPoint(point: Vector3): boolean;
        /**
         * Gets the current physics impostor
         * @see http://doc.babylonjs.com/features/physics_engine
         * @returns a physics impostor or null
         */
        getPhysicsImpostor(): Nullable<PhysicsImpostor>;
        /**
         * Gets the position of the current mesh in camera space
         * @param camera defines the camera to use
         * @returns a position
         */
        getPositionInCameraSpace(camera?: Nullable<Camera>): Vector3;
        /**
         * Returns the distance from the mesh to the active camera
         * @param camera defines the camera to use
         * @returns the distance
         */
        getDistanceToCamera(camera?: Nullable<Camera>): number;
        /**
         * Apply a physic impulse to the mesh
         * @param force defines the force to apply
         * @param contactPoint defines where to apply the force
         * @returns the current mesh
         * @see http://doc.babylonjs.com/how_to/using_the_physics_engine
         */
        applyImpulse(force: Vector3, contactPoint: Vector3): AbstractMesh;
        /**
         * Creates a physic joint between two meshes
         * @param otherMesh defines the other mesh to use
         * @param pivot1 defines the pivot to use on this mesh
         * @param pivot2 defines the pivot to use on the other mesh
         * @param options defines additional options (can be plugin dependent)
         * @returns the current mesh
         * @see https://www.babylonjs-playground.com/#0BS5U0#0
         */
        setPhysicsLinkWith(otherMesh: Mesh, pivot1: Vector3, pivot2: Vector3, options?: any): AbstractMesh;
        /**
         * Gets or sets a boolean indicating that this mesh can be used in the collision engine
         * @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
         */
        checkCollisions: boolean;
        /**
         * Gets Collider object used to compute collisions (not physics)
         * @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
         */
        readonly collider: Collider;
        /**
         * Move the mesh using collision engine
         * @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
         * @param displacement defines the requested displacement vector
         * @returns the current mesh
         */
        moveWithCollisions(displacement: Vector3): AbstractMesh;
        private _onCollisionPositionChange;
        /**
        * This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.
        * Please note that you must have a decent number of submeshes to get performance improvements when using an octree
        * @param maxCapacity defines the maximum size of each block (64 by default)
        * @param maxDepth defines the maximum depth to use (no more than 2 levels by default)
        * @returns the new octree
        * @see https://www.babylonjs-playground.com/#NA4OQ#12
        * @see http://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
        */
        createOrUpdateSubmeshesOctree(maxCapacity?: number, maxDepth?: number): Octree<SubMesh>;
        /** @hidden */
        _collideForSubMesh(subMesh: SubMesh, transformMatrix: Matrix, collider: Collider): AbstractMesh;
        /** @hidden */
        _processCollisionsForSubMeshes(collider: Collider, transformMatrix: Matrix): AbstractMesh;
        /** @hidden */
        _checkCollision(collider: Collider): AbstractMesh;
        /** @hidden */
        _generatePointsArray(): boolean;
        /**
         * Checks if the passed Ray intersects with the mesh
         * @param ray defines the ray to use
         * @param fastCheck defines if fast mode (but less precise) must be used (false by default)
         * @returns the picking info
         * @see http://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh
         */
        intersects(ray: Ray, fastCheck?: boolean): PickingInfo;
        /**
         * Clones the current mesh
         * @param name defines the mesh name
         * @param newParent defines the new mesh parent
         * @param doNotCloneChildren defines a boolean indicating that children must not be cloned (false by default)
         * @returns the new mesh
         */
        clone(name: string, newParent: Node, doNotCloneChildren?: boolean): Nullable<AbstractMesh>;
        /**
         * Disposes all the submeshes of the current meshnp
         * @returns the current mesh
         */
        releaseSubMeshes(): AbstractMesh;
        /**
         * Releases resources associated with this abstract mesh.
         * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
         * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
         */
        dispose(doNotRecurse?: boolean, disposeMaterialAndTextures?: boolean): void;
        /**
         * Adds the passed mesh as a child to the current mesh
         * @param mesh defines the child mesh
         * @returns the current mesh
         */
        addChild(mesh: AbstractMesh): AbstractMesh;
        /**
         * Removes the passed mesh from the current mesh children list
         * @param mesh defines the child mesh
         * @returns the current mesh
         */
        removeChild(mesh: AbstractMesh): AbstractMesh;
        /** @hidden */
        private _initFacetData();
        /**
         * Updates the mesh facetData arrays and the internal partitioning when the mesh is morphed or updated.
         * This method can be called within the render loop.
         * You don't need to call this method by yourself in the render loop when you update/morph a mesh with the methods CreateXXX() as they automatically manage this computation
         * @returns the current mesh
         * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        updateFacetData(): AbstractMesh;
        /**
         * Returns the facetLocalNormals array.
         * The normals are expressed in the mesh local spac
         * @returns an array of Vector3
         * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getFacetLocalNormals(): Vector3[];
        /**
         * Returns the facetLocalPositions array.
         * The facet positions are expressed in the mesh local space
         * @returns an array of Vector3
         * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getFacetLocalPositions(): Vector3[];
        /**
         * Returns the facetLocalPartioning array
         * @returns an array of array of numbers
         * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getFacetLocalPartitioning(): number[][];
        /**
         * Returns the i-th facet position in the world system.
         * This method allocates a new Vector3 per call
         * @param i defines the facet index
         * @returns a new Vector3
         * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getFacetPosition(i: number): Vector3;
        /**
         * Sets the reference Vector3 with the i-th facet position in the world system
         * @param i defines the facet index
         * @param ref defines the target vector
         * @returns the current mesh
         * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getFacetPositionToRef(i: number, ref: Vector3): AbstractMesh;
        /**
         * Returns the i-th facet normal in the world system.
         * This method allocates a new Vector3 per call
         * @param i defines the facet index
         * @returns a new Vector3
         * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getFacetNormal(i: number): Vector3;
        /**
         * Sets the reference Vector3 with the i-th facet normal in the world system
         * @param i defines the facet index
         * @param ref defines the target vector
         * @returns the current mesh
         * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getFacetNormalToRef(i: number, ref: Vector3): this;
        /**
         * Returns the facets (in an array) in the same partitioning block than the one the passed coordinates are located (expressed in the mesh local system)
         * @param x defines x coordinate
         * @param y defines y coordinate
         * @param z defines z coordinate
         * @returns the array of facet indexes
         * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getFacetsAtLocalCoordinates(x: number, y: number, z: number): Nullable<number[]>;
        /**
         * Returns the closest mesh facet index at (x,y,z) World coordinates, null if not found
         * @param projected sets as the (x,y,z) world projection on the facet
         * @param checkFace if true (default false), only the facet "facing" to (x,y,z) or only the ones "turning their backs", according to the parameter "facing" are returned
         * @param facing if facing and checkFace are true, only the facet "facing" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet "turning their backs" to (x, y, z) are returned : negative dot (x, y, z) * facet position
         * @param x defines x coordinate
         * @param y defines y coordinate
         * @param z defines z coordinate
         * @returns the face index if found (or null instead)
         * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getClosestFacetAtCoordinates(x: number, y: number, z: number, projected?: Vector3, checkFace?: boolean, facing?: boolean): Nullable<number>;
        /**
         * Returns the closest mesh facet index at (x,y,z) local coordinates, null if not found
         * @param projected sets as the (x,y,z) local projection on the facet
         * @param checkFace if true (default false), only the facet "facing" to (x,y,z) or only the ones "turning their backs", according to the parameter "facing" are returned
         * @param facing if facing and checkFace are true, only the facet "facing" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet "turning their backs" to (x, y, z) are returned : negative dot (x, y, z) * facet position
         * @param x defines x coordinate
         * @param y defines y coordinate
         * @param z defines z coordinate
         * @returns the face index if found (or null instead)
         * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getClosestFacetAtLocalCoordinates(x: number, y: number, z: number, projected?: Vector3, checkFace?: boolean, facing?: boolean): Nullable<number>;
        /**
         * Returns the object "parameter" set with all the expected parameters for facetData computation by ComputeNormals()
         * @returns the parameters
         * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        getFacetDataParameters(): any;
        /**
         * Disables the feature FacetData and frees the related memory
         * @returns the current mesh
         * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
         */
        disableFacetData(): AbstractMesh;
        /**
         * Updates the AbstractMesh indices array
         * @param indices defines the data source
         * @returns the current mesh
         */
        updateIndices(indices: IndicesArray): AbstractMesh;
        /**
         * Creates new normals data for the mesh
         * @param updatable defines if the normal vertex buffer must be flagged as updatable
         * @returns the current mesh
         */
        createNormals(updatable: boolean): AbstractMesh;
        /**
         * Align the mesh with a normal
         * @param normal defines the normal to use
         * @param upDirection can be used to redefined the up vector to use (will use the (0, 1, 0) by default)
         * @returns the current mesh
         */
        alignWithNormal(normal: Vector3, upDirection?: Vector3): AbstractMesh;
        /** @hidden */
        protected _checkOcclusionQuery(): void;
    }
}

declare module BABYLON {
    class Buffer {
        private _engine;
        private _buffer;
        private _data;
        private _updatable;
        private _instanced;
        /**
         * Gets the byte stride.
         */
        readonly byteStride: number;
        /**
         * Constructor
         * @param engine the engine
         * @param data the data to use for this buffer
         * @param updatable whether the data is updatable
         * @param stride the stride (optional)
         * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)
         * @param instanced whether the buffer is instanced (optional)
         * @param useBytes set to true if the stride in in bytes (optional)
         */
        constructor(engine: any, data: DataArray, updatable: boolean, stride?: number, postponeInternalCreation?: boolean, instanced?: boolean, useBytes?: boolean);
        /**
         * Create a new {BABYLON.VertexBuffer} based on the current buffer
         * @param kind defines the vertex buffer kind (position, normal, etc.)
         * @param offset defines offset in the buffer (0 by default)
         * @param size defines the size in floats of attributes (position is 3 for instance)
         * @param stride defines the stride size in floats in the buffer (the offset to apply to reach next value when data is interleaved)
         * @param instanced defines if the vertex buffer contains indexed data
         * @param useBytes defines if the offset and stride are in bytes
         * @returns the new vertex buffer
         */
        createVertexBuffer(kind: string, offset: number, size: number, stride?: number, instanced?: boolean, useBytes?: boolean): VertexBuffer;
        isUpdatable(): boolean;
        getData(): Nullable<DataArray>;
        getBuffer(): Nullable<WebGLBuffer>;
        /**
         * Gets the stride in float32 units (i.e. byte stride / 4).
         * May not be an integer if the byte stride is not divisible by 4.
         * DEPRECATED. Use byteStride instead.
         * @returns the stride in float32 units
         */
        getStrideSize(): number;
        create(data?: Nullable<DataArray>): void;
        _rebuild(): void;
        update(data: DataArray): void;
        /**
         * Updates the data directly.
         * @param data the new data
         * @param offset the new offset
         * @param vertexCount the vertex count (optional)
         * @param useBytes set to true if the offset is in bytes
         */
        updateDirectly(data: DataArray, offset: number, vertexCount?: number, useBytes?: boolean): void;
        dispose(): void;
    }
}

declare module BABYLON {
    class CSG {
        private polygons;
        matrix: Matrix;
        position: Vector3;
        rotation: Vector3;
        rotationQuaternion: Nullable<Quaternion>;
        scaling: Vector3;
        static FromMesh(mesh: Mesh): CSG;
        private static FromPolygons(polygons);
        clone(): CSG;
        union(csg: CSG): CSG;
        unionInPlace(csg: CSG): void;
        subtract(csg: CSG): CSG;
        subtractInPlace(csg: CSG): void;
        intersect(csg: CSG): CSG;
        intersectInPlace(csg: CSG): void;
        inverse(): CSG;
        inverseInPlace(): void;
        copyTransformAttributes(csg: CSG): CSG;
        buildMeshGeometry(name: string, scene: Scene, keepSubMeshes: boolean): Mesh;
        toMesh(name: string, material: Nullable<Material>, scene: Scene, keepSubMeshes: boolean): Mesh;
    }
}

declare module BABYLON {
    /**
     * Class used to store geometry data (vertex buffers + index buffer)
     */
    class Geometry implements IGetSetVerticesData {
        /**
         * Gets or sets the unique ID of the geometry
         */
        id: string;
        /**
         * Gets the delay loading state of the geometry (none by default which means not delayed)
         */
        delayLoadState: number;
        /**
         * Gets the file containing the data to load when running in delay load state
         */
        delayLoadingFile: Nullable<string>;
        /**
         * Callback called when the geometry is updated
         */
        onGeometryUpdated: (geometry: Geometry, kind?: string) => void;
        private _scene;
        private _engine;
        private _meshes;
        private _totalVertices;
        private _indices;
        private _vertexBuffers;
        private _isDisposed;
        private _extend;
        private _boundingBias;
        /** @hidden */
        _delayInfo: Array<string>;
        private _indexBuffer;
        private _indexBufferIsUpdatable;
        /** @hidden */
        _boundingInfo: Nullable<BoundingInfo>;
        /** @hidden */
        _delayLoadingFunction: Nullable<(any: any, geometry: Geometry) => void>;
        /** @hidden */
        _softwareSkinningRenderId: number;
        private _vertexArrayObjects;
        private _updatable;
        /** @hidden */
        _positions: Nullable<Vector3[]>;
        /**
         *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y
         */
        /**
         *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y
         */
        boundingBias: Vector2;
        /**
         * Static function used to attach a new empty geometry to a mesh
         * @param mesh defines the mesh to attach the geometry to
         * @returns the new {BABYLON.Geometry}
         */
        static CreateGeometryForMesh(mesh: Mesh): Geometry;
        /**
         * Creates a new geometry
         * @param id defines the unique ID
         * @param scene defines the hosting scene
         * @param vertexData defines the {BABYLON.VertexData} used to get geometry data
         * @param updatable defines if geometry must be updatable (false by default)
         * @param mesh defines the mesh that will be associated with the geometry
         */
        constructor(id: string, scene: Scene, vertexData?: VertexData, updatable?: boolean, mesh?: Nullable<Mesh>);
        /**
         * Gets the current extend of the geometry
         */
        readonly extend: {
            minimum: Vector3;
            maximum: Vector3;
        };
        /**
         * Gets the hosting scene
         * @returns the hosting {BABYLON.Scene}
         */
        getScene(): Scene;
        /**
         * Gets the hosting engine
         * @returns the hosting {BABYLON.Engine}
         */
        getEngine(): Engine;
        /**
         * Defines if the geometry is ready to use
         * @returns true if the geometry is ready to be used
         */
        isReady(): boolean;
        /**
         * Gets a value indicating that the geometry should not be serialized
         */
        readonly doNotSerialize: boolean;
        /** @hidden */
        _rebuild(): void;
        /**
         * Affects all gemetry data in one call
         * @param vertexData defines the geometry data
         * @param updatable defines if the geometry must be flagged as updatable (false as default)
         */
        setAllVerticesData(vertexData: VertexData, updatable?: boolean): void;
        /**
         * Set specific vertex data
         * @param kind defines the data kind (Position, normal, etc...)
         * @param data defines the vertex data to use
         * @param updatable defines if the vertex must be flagged as updatable (false as default)
         * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified
         */
        setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): void;
        /**
         * Removes a specific vertex data
         * @param kind defines the data kind (Position, normal, etc...)
         */
        removeVerticesData(kind: string): void;
        /**
         * Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data
         * @param buffer defines the vertex buffer to use
         * @param totalVertices defines the total number of vertices for position kind (could be null)
         */
        setVerticesBuffer(buffer: VertexBuffer, totalVertices?: Nullable<number>): void;
        /**
         * Update a specific vertex buffer
         * This function will directly update the underlying WebGLBuffer according to the passed numeric array or Float32Array
         * It will do nothing if the buffer is not updatable
         * @param kind defines the data kind (Position, normal, etc...)
         * @param data defines the data to use
         * @param offset defines the offset in the target buffer where to store the data
         * @param useBytes set to true if the offset is in bytes
         */
        updateVerticesDataDirectly(kind: string, data: DataArray, offset: number, useBytes?: boolean): void;
        /**
         * Update a specific vertex buffer
         * This function will create a new buffer if the current one is not updatable
         * @param kind defines the data kind (Position, normal, etc...)
         * @param data defines the data to use
         * @param updateExtends defines if the geometry extends must be recomputed (false by default)
         */
        updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean): void;
        private _updateBoundingInfo(updateExtends, data);
        /** @hidden */
        _bind(effect: Nullable<Effect>, indexToBind?: Nullable<WebGLBuffer>): void;
        /**
         * Gets total number of vertices
         * @returns the total number of vertices
         */
        getTotalVertices(): number;
        /**
         * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.
         * @param kind defines the data kind (Position, normal, etc...)
         * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes
         * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it
         * @returns a float array containing vertex data
         */
        getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray>;
        /**
         * Returns a boolean defining if the vertex data for the requested `kind` is updatable
         * @param kind defines the data kind (Position, normal, etc...)
         * @returns true if the vertex buffer with the specified kind is updatable
         */
        isVertexBufferUpdatable(kind: string): boolean;
        /**
         * Gets a specific vertex buffer
         * @param kind defines the data kind (Position, normal, etc...)
         * @returns a {BABYLON.VertexBuffer}
         */
        getVertexBuffer(kind: string): Nullable<VertexBuffer>;
        /**
         * Returns all vertex buffers
         * @return an object holding all vertex buffers indexed by kind
         */
        getVertexBuffers(): Nullable<{
            [key: string]: VertexBuffer;
        }>;
        /**
         * Gets a boolean indicating if specific vertex buffer is present
         * @param kind defines the data kind (Position, normal, etc...)
         * @returns true if data is present
         */
        isVerticesDataPresent(kind: string): boolean;
        /**
         * Gets a list of all attached data kinds (Position, normal, etc...)
         * @returns a list of string containing all kinds
         */
        getVerticesDataKinds(): string[];
        /**
         * Update index buffer
         * @param indices defines the indices to store in the index buffer
         * @param offset defines the offset in the target buffer where to store the data
         */
        updateIndices(indices: IndicesArray, offset?: number): void;
        /**
         * Creates a new index buffer
         * @param indices defines the indices to store in the index buffer
         * @param totalVertices defines the total number of vertices (could be null)
         * @param updatable defines if the index buffer must be flagged as updatable (false by default)
         */
        setIndices(indices: IndicesArray, totalVertices?: Nullable<number>, updatable?: boolean): void;
        /**
         * Return the total number of indices
         * @returns the total number of indices
         */
        getTotalIndices(): number;
        /**
         * Gets the index buffer array
         * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes
         * @returns the index buffer array
         */
        getIndices(copyWhenShared?: boolean): Nullable<IndicesArray>;
        /**
         * Gets the index buffer
         * @return the index buffer
         */
        getIndexBuffer(): Nullable<WebGLBuffer>;
        /** @hidden */
        _releaseVertexArrayObject(effect?: Nullable<Effect>): void;
        /**
         * Release the associated resources for a specific mesh
         * @param mesh defines the source mesh
         * @param shouldDispose defines if the geometry must be disposed if there is no more mesh pointing to it
         */
        releaseForMesh(mesh: Mesh, shouldDispose?: boolean): void;
        /**
         * Apply current geometry to a given mesh
         * @param mesh defines the mesh to apply geometry to
         */
        applyToMesh(mesh: Mesh): void;
        private _updateExtend(data?);
        private _applyToMesh(mesh);
        private notifyUpdate(kind?);
        /**
         * Load the geometry if it was flagged as delay loaded
         * @param scene defines the hosting scene
         * @param onLoaded defines a callback called when the geometry is loaded
         */
        load(scene: Scene, onLoaded?: () => void): void;
        private _queueLoad(scene, onLoaded?);
        /**
         * Invert the geometry to move from a right handed system to a left handed one.
         */
        toLeftHanded(): void;
        /** @hidden */
        _resetPointsArrayCache(): void;
        /** @hidden */
        _generatePointsArray(): boolean;
        /**
         * Gets a value indicating if the geometry is disposed
         * @returns true if the geometry was disposed
         */
        isDisposed(): boolean;
        private _disposeVertexArrayObjects();
        /**
         * Free all associated resources
         */
        dispose(): void;
        /**
         * Clone the current geometry into a new geometry
         * @param id defines the unique ID of the new geometry
         * @returns a new geometry object
         */
        copy(id: string): Geometry;
        /**
         * Serialize the current geometry info (and not the vertices data) into a JSON object
         * @return a JSON representation of the current geometry data (without the vertices data)
         */
        serialize(): any;
        private toNumberArray(origin);
        /**
         * Serialize all vertices data into a JSON oject
         * @returns a JSON representation of the current geometry data
         */
        serializeVerticeData(): any;
        /**
         * Extracts a clone of a mesh geometry
         * @param mesh defines the source mesh
         * @param id defines the unique ID of the new geometry object
         * @returns the new geometry object
         */
        static ExtractFromMesh(mesh: Mesh, id: string): Nullable<Geometry>;
        /**
         * You should now use Tools.RandomId(), this method is still here for legacy reasons.
         * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
         * Be aware Math.random() could cause collisions, but:
         * "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
         * @returns a string containing a new GUID
         */
        static RandomId(): string;
        /** @hidden */
        static _ImportGeometry(parsedGeometry: any, mesh: Mesh): void;
        private static _CleanMatricesWeights(parsedGeometry, mesh);
        /**
         * Create a new geometry from persisted data (Using .babylon file format)
         * @param parsedVertexData defines the persisted data
         * @param scene defines the hosting scene
         * @param rootUrl defines the root url to use to load assets (like delayed data)
         * @returns the new geometry object
         */
        static Parse(parsedVertexData: any, scene: Scene, rootUrl: string): Nullable<Geometry>;
    }
    /**
     * Abstract class used to provide common services for all typed geometries
     * @hidden
     */
    class _PrimitiveGeometry extends Geometry {
        private _canBeRegenerated;
        private _beingRegenerated;
        /**
         * Creates a new typed geometry
         * @param id defines the unique ID of the geometry
         * @param scene defines the hosting scene
         * @param _canBeRegenerated defines if the geometry supports being regenerated with new parameters (false by default)
         * @param mesh defines the hosting mesh (can be null)
         */
        constructor(id: string, scene: Scene, _canBeRegenerated?: boolean, mesh?: Nullable<Mesh>);
        /**
         * Gets a value indicating if the geometry supports being regenerated with new parameters (false by default)
         * @returns true if the geometry can be regenerated
         */
        canBeRegenerated(): boolean;
        /**
         * If the geometry supports regeneration, the function will recreates the geometry with updated parameter values
         */
        regenerate(): void;
        /**
         * Clone the geometry
         * @param id defines the unique ID of the new geometry
         * @returns the new geometry
         */
        asNewGeometry(id: string): Geometry;
        setAllVerticesData(vertexData: VertexData, updatable?: boolean): void;
        setVerticesData(kind: string, data: FloatArray, updatable?: boolean): void;
        /** @hidden */
        _regenerateVertexData(): VertexData;
        copy(id: string): Geometry;
        serialize(): any;
    }
    /**
     * Creates a ribbon geometry
     * @description See http://doc.babylonjs.com/how_to/ribbon_tutorial, http://doc.babylonjs.com/resources/maths_make_ribbons
     */
    class RibbonGeometry extends _PrimitiveGeometry {
        /**
         * Defines the array of paths to use
         */
        pathArray: Vector3[][];
        /**
         * Defines if the last and first points of each path in your pathArray must be joined
         */
        closeArray: boolean;
        /**
         * Defines if the last and first points of each path in your pathArray must be joined
         */
        closePath: boolean;
        /**
         * Defines the offset between points
         */
        offset: number;
        /**
         * Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
         */
        side: number;
        /**
         * Creates a ribbon geometry
         * @param id defines the unique ID of the geometry
         * @param scene defines the hosting scene
         * @param pathArray defines the array of paths to use
         * @param closeArray defines if the last path and the first path must be  joined
         * @param closePath defines if the last and first points of each path in your pathArray must be joined
         * @param offset defines the offset between points
         * @param canBeRegenerated defines if the geometry supports being regenerated with new parameters (false by default)
         * @param mesh defines the hosting mesh (can be null)
         * @param side defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
         */
        constructor(id: string, scene: Scene, 
            /**
             * Defines the array of paths to use
             */
            pathArray: Vector3[][], 
            /**
             * Defines if the last and first points of each path in your pathArray must be joined
             */
            closeArray: boolean, 
            /**
             * Defines if the last and first points of each path in your pathArray must be joined
             */
            closePath: boolean, 
            /**
             * Defines the offset between points
             */
            offset: number, canBeRegenerated?: boolean, mesh?: Mesh, 
            /**
             * Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
             */
            side?: number);
        /** @hidden */
        _regenerateVertexData(): VertexData;
        copy(id: string): Geometry;
    }
    /**
     * Creates a box geometry
     * @description see http://doc.babylonjs.com/how_to/set_shapes#box
     */
    class BoxGeometry extends _PrimitiveGeometry {
        /**
         * Defines the zise of the box (width, height and depth are the same)
         */
        size: number;
        /**
         * Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
         */
        side: number;
        /**
         * Creates a box geometry
         * @param id defines the unique ID of the geometry
         * @param scene defines the hosting scene
         * @param size defines the zise of the box (width, height and depth are the same)
         * @param canBeRegenerated defines if the geometry supports being regenerated with new parameters (false by default)
         * @param mesh defines the hosting mesh (can be null)
         * @param side defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
         */
        constructor(id: string, scene: Scene, 
            /**
             * Defines the zise of the box (width, height and depth are the same)
             */
            size: number, canBeRegenerated?: boolean, mesh?: Nullable<Mesh>, 
            /**
             * Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
             */
            side?: number);
        _regenerateVertexData(): VertexData;
        copy(id: string): Geometry;
        serialize(): any;
        static Parse(parsedBox: any, scene: Scene): Nullable<BoxGeometry>;
    }
    /**
     * Creates a sphere geometry
     * @description see http://doc.babylonjs.com/how_to/set_shapes#sphere
     */
    class SphereGeometry extends _PrimitiveGeometry {
        /**
         * Defines the number of segments to use to create the sphere
         */
        segments: number;
        /**
         * Defines the diameter of the sphere
         */
        diameter: number;
        /**
         * Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
         */
        side: number;
        /**
         * Create a new sphere geometry
         * @param id defines the unique ID of the geometry
         * @param scene defines the hosting scene
         * @param segments defines the number of segments to use to create the sphere
         * @param diameter defines the diameter of the sphere
         * @param canBeRegenerated defines if the geometry supports being regenerated with new parameters (false by default)
         * @param mesh defines the hosting mesh (can be null)
         * @param side defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
         */
        constructor(id: string, scene: Scene, 
            /**
             * Defines the number of segments to use to create the sphere
             */
            segments: number, 
            /**
             * Defines the diameter of the sphere
             */
            diameter: number, canBeRegenerated?: boolean, mesh?: Nullable<Mesh>, 
            /**
             * Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
             */
            side?: number);
        _regenerateVertexData(): VertexData;
        copy(id: string): Geometry;
        serialize(): any;
        static Parse(parsedSphere: any, scene: Scene): Nullable<SphereGeometry>;
    }
    /**
     * Creates a disc geometry
     * @description see http://doc.babylonjs.com/how_to/set_shapes#disc-or-regular-polygon
     */
    class DiscGeometry extends _PrimitiveGeometry {
        /**
         * Defines the radius of the disc
         */
        radius: number;
        /**
         * Defines the tesselation factor to apply to the disc
         */
        tessellation: number;
        /**
         * Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
         */
        side: number;
        /**
         * Creates a new disc geometry
         * @param id defines the unique ID of the geometry
         * @param scene defines the hosting scene
         * @param radius defines the radius of the disc
         * @param tessellation defines the tesselation factor to apply to the disc
         * @param canBeRegenerated defines if the geometry supports being regenerated with new parameters (false by default)
         * @param mesh defines the hosting mesh (can be null)
         * @param side defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
         */
        constructor(id: string, scene: Scene, 
            /**
             * Defines the radius of the disc
             */
            radius: number, 
            /**
             * Defines the tesselation factor to apply to the disc
             */
            tessellation: number, canBeRegenerated?: boolean, mesh?: Nullable<Mesh>, 
            /**
             * Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
             */
            side?: number);
        _regenerateVertexData(): VertexData;
        copy(id: string): Geometry;
    }
    /**
     * Creates a new cylinder geometry
     * @description see http://doc.babylonjs.com/how_to/set_shapes#cylinder-or-cone
     */
    class CylinderGeometry extends _PrimitiveGeometry {
        /**
         * Defines the height of the cylinder
         */
        height: number;
        /**
         * Defines the diameter of the cylinder's top cap
         */
        diameterTop: number;
        /**
         * Defines the diameter of the cylinder's bottom cap
         */
        diameterBottom: number;
        /**
         * Defines the tessellation factor to apply to the cylinder
         */
        tessellation: number;
        /**
         * Defines the number of subdivisions to apply to the cylinder (1 by default)
         */
        subdivisions: number;
        /**
         * Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
         */
        side: number;
        /**
         * Creates a new cylinder geometry
         * @param id defines the unique ID of the geometry
         * @param scene defines the hosting scene
         * @param height defines the height of the cylinder
         * @param diameterTop defines the diameter of the cylinder's top cap
         * @param diameterBottom defines the diameter of the cylinder's bottom cap
         * @param tessellation defines the tessellation factor to apply to the cylinder (number of radial sides)
         * @param subdivisions defines the number of subdivisions to apply to the cylinder (number of rings) (1 by default)
         * @param canBeRegenerated defines if the geometry supports being regenerated with new parameters (false by default)
         * @param mesh defines the hosting mesh (can be null)
         * @param side defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
         */
        constructor(id: string, scene: Scene, 
            /**
             * Defines the height of the cylinder
             */
            height: number, 
            /**
             * Defines the diameter of the cylinder's top cap
             */
            diameterTop: number, 
            /**
             * Defines the diameter of the cylinder's bottom cap
             */
            diameterBottom: number, 
            /**
             * Defines the tessellation factor to apply to the cylinder
             */
            tessellation: number, 
            /**
             * Defines the number of subdivisions to apply to the cylinder (1 by default)
             */
            subdivisions?: number, canBeRegenerated?: boolean, mesh?: Nullable<Mesh>, 
            /**
             * Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
             */
            side?: number);
        _regenerateVertexData(): VertexData;
        copy(id: string): Geometry;
        serialize(): any;
        static Parse(parsedCylinder: any, scene: Scene): Nullable<CylinderGeometry>;
    }
    /**
     * Creates a new torus geometry
     * @description see http://doc.babylonjs.com/how_to/set_shapes#torus
     */
    class TorusGeometry extends _PrimitiveGeometry {
        /**
         * Defines the diameter of the torus
         */
        diameter: number;
        /**
         * Defines the thickness of the torus (ie. internal diameter)
         */
        thickness: number;
        /**
         * Defines the tesselation factor to apply to the torus
         */
        tessellation: number;
        /**
         * Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
         */
        side: number;
        /**
         * Creates a new torus geometry
         * @param id defines the unique ID of the geometry
         * @param scene defines the hosting scene
         * @param diameter defines the diameter of the torus
         * @param thickness defines the thickness of the torus (ie. internal diameter)
         * @param tessellation defines the tesselation factor to apply to the torus (number of segments along the circle)
         * @param canBeRegenerated defines if the geometry supports being regenerated with new parameters (false by default)
         * @param mesh defines the hosting mesh (can be null)
         * @param side defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
         */
        constructor(id: string, scene: Scene, 
            /**
             * Defines the diameter of the torus
             */
            diameter: number, 
            /**
             * Defines the thickness of the torus (ie. internal diameter)
             */
            thickness: number, 
            /**
             * Defines the tesselation factor to apply to the torus
             */
            tessellation: number, canBeRegenerated?: boolean, mesh?: Nullable<Mesh>, 
            /**
             * Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
             */
            side?: number);
        _regenerateVertexData(): VertexData;
        copy(id: string): Geometry;
        serialize(): any;
        static Parse(parsedTorus: any, scene: Scene): Nullable<TorusGeometry>;
    }
    /**
     * Creates a new ground geometry
     * @description see http://doc.babylonjs.com/how_to/set_shapes#ground
     */
    class GroundGeometry extends _PrimitiveGeometry {
        /**
         * Defines the width of the ground
         */
        width: number;
        /**
         * Defines the height of the ground
         */
        height: number;
        /**
         * Defines the subdivisions to apply to the ground
         */
        subdivisions: number;
        /**
         * Creates a new ground geometry
         * @param id defines the unique ID of the geometry
         * @param scene defines the hosting scene
         * @param width defines the width of the ground
         * @param height defines the height of the ground
         * @param subdivisions defines the subdivisions to apply to the ground
         * @param canBeRegenerated defines if the geometry supports being regenerated with new parameters (false by default)
         * @param mesh defines the hosting mesh (can be null)
         */
        constructor(id: string, scene: Scene, 
            /**
             * Defines the width of the ground
             */
            width: number, 
            /**
             * Defines the height of the ground
             */
            height: number, 
            /**
             * Defines the subdivisions to apply to the ground
             */
            subdivisions: number, canBeRegenerated?: boolean, mesh?: Nullable<Mesh>);
        _regenerateVertexData(): VertexData;
        copy(id: string): Geometry;
        serialize(): any;
        static Parse(parsedGround: any, scene: Scene): Nullable<GroundGeometry>;
    }
    /**
     * Creates a tiled ground geometry
     * @description see http://doc.babylonjs.com/how_to/set_shapes#tiled-ground
     */
    class TiledGroundGeometry extends _PrimitiveGeometry {
        /**
         * Defines the minimum value on X axis
         */
        xmin: number;
        /**
         * Defines the minimum value on Z axis
         */
        zmin: number;
        /**
         * Defines the maximum value on X axis
         */
        xmax: number;
        /**
         * Defines the maximum value on Z axis
         */
        zmax: number;
        /**
         * Defines the subdivisions to apply to the ground
         */
        subdivisions: {
            w: number;
            h: number;
        };
        /**
         * Defines the precision to use when computing the tiles
         */
        precision: {
            w: number;
            h: number;
        };
        /**
         * Creates a tiled ground geometry
         * @param id defines the unique ID of the geometry
         * @param scene defines the hosting scene
         * @param xmin defines the minimum value on X axis
         * @param zmin defines the minimum value on Z axis
         * @param xmax defines the maximum value on X axis
         * @param zmax defines the maximum value on Z axis
         * @param subdivisions defines the subdivisions to apply to the ground (number of subdivisions (tiles) on the height and the width of the map)
         * @param precision defines the precision to use when computing the tiles
         * @param canBeRegenerated defines if the geometry supports being regenerated with new parameters (false by default)
         * @param mesh defines the hosting mesh (can be null)
         */
        constructor(id: string, scene: Scene, 
            /**
             * Defines the minimum value on X axis
             */
            xmin: number, 
            /**
             * Defines the minimum value on Z axis
             */
            zmin: number, 
            /**
             * Defines the maximum value on X axis
             */
            xmax: number, 
            /**
             * Defines the maximum value on Z axis
             */
            zmax: number, 
            /**
             * Defines the subdivisions to apply to the ground
             */
            subdivisions: {
            w: number;
            h: number;
        }, 
            /**
             * Defines the precision to use when computing the tiles
             */
            precision: {
            w: number;
            h: number;
        }, canBeRegenerated?: boolean, mesh?: Nullable<Mesh>);
        _regenerateVertexData(): VertexData;
        copy(id: string): Geometry;
    }
    /**
     * Creates a plane geometry
     * @description see http://doc.babylonjs.com/how_to/set_shapes#plane
     */
    class PlaneGeometry extends _PrimitiveGeometry {
        /**
         * Defines the size of the plane (width === height)
         */
        size: number;
        /**
         * Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
         */
        side: number;
        /**
         * Creates a plane geometry
         * @param id defines the unique ID of the geometry
         * @param scene defines the hosting scene
         * @param size defines the size of the plane (width === height)
         * @param canBeRegenerated defines if the geometry supports being regenerated with new parameters (false by default)
         * @param mesh defines the hosting mesh (can be null)
         * @param side defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
         */
        constructor(id: string, scene: Scene, 
            /**
             * Defines the size of the plane (width === height)
             */
            size: number, canBeRegenerated?: boolean, mesh?: Nullable<Mesh>, 
            /**
             * Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
             */
            side?: number);
        _regenerateVertexData(): VertexData;
        copy(id: string): Geometry;
        serialize(): any;
        static Parse(parsedPlane: any, scene: Scene): Nullable<PlaneGeometry>;
    }
    /**
     * Creates a torus knot geometry
     * @description see http://doc.babylonjs.com/how_to/set_shapes#torus-knot
     */
    class TorusKnotGeometry extends _PrimitiveGeometry {
        /**
         * Defines the radius of the torus knot
         */
        radius: number;
        /**
         * Defines the thickness of the torus knot tube
         */
        tube: number;
        /**
         * Defines the number of radial segments
         */
        radialSegments: number;
        /**
         * Defines the number of tubular segments
         */
        tubularSegments: number;
        /**
         * Defines the first number of windings
         */
        p: number;
        /**
         * Defines the second number of windings
         */
        q: number;
        /**
         * Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
         */
        side: number;
        /**
         * Creates a torus knot geometry
         * @param id defines the unique ID of the geometry
         * @param scene defines the hosting scene
         * @param radius defines the radius of the torus knot
         * @param tube defines the thickness of the torus knot tube
         * @param radialSegments defines the number of radial segments
         * @param tubularSegments defines the number of tubular segments
         * @param p defines the first number of windings
         * @param q defines the second number of windings
         * @param canBeRegenerated defines if the geometry supports being regenerated with new parameters (false by default)
         * @param mesh defines the hosting mesh (can be null)
         * @param side defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
         */
        constructor(id: string, scene: Scene, 
            /**
             * Defines the radius of the torus knot
             */
            radius: number, 
            /**
             * Defines the thickness of the torus knot tube
             */
            tube: number, 
            /**
             * Defines the number of radial segments
             */
            radialSegments: number, 
            /**
             * Defines the number of tubular segments
             */
            tubularSegments: number, 
            /**
             * Defines the first number of windings
             */
            p: number, 
            /**
             * Defines the second number of windings
             */
            q: number, canBeRegenerated?: boolean, mesh?: Nullable<Mesh>, 
            /**
             * Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
             */
            side?: number);
        _regenerateVertexData(): VertexData;
        copy(id: string): Geometry;
        serialize(): any;
        static Parse(parsedTorusKnot: any, scene: Scene): Nullable<TorusKnotGeometry>;
    }
}

declare module BABYLON {
    class GroundMesh extends Mesh {
        generateOctree: boolean;
        private _heightQuads;
        _subdivisionsX: number;
        _subdivisionsY: number;
        _width: number;
        _height: number;
        _minX: number;
        _maxX: number;
        _minZ: number;
        _maxZ: number;
        constructor(name: string, scene: Scene);
        getClassName(): string;
        readonly subdivisions: number;
        readonly subdivisionsX: number;
        readonly subdivisionsY: number;
        optimize(chunksCount: number, octreeBlocksSize?: number): void;
        /**
         * Returns a height (y) value in the Worl system :
         * the ground altitude at the coordinates (x, z) expressed in the World system.
         * Returns the ground y position if (x, z) are outside the ground surface.
         */
        getHeightAtCoordinates(x: number, z: number): number;
        /**
         * Returns a normalized vector (Vector3) orthogonal to the ground
         * at the ground coordinates (x, z) expressed in the World system.
         * Returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.
         */
        getNormalAtCoordinates(x: number, z: number): Vector3;
        /**
         * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground
         * at the ground coordinates (x, z) expressed in the World system.
         * Doesn't uptade the reference Vector3 if (x, z) are outside the ground surface.
         * Returns the GroundMesh.
         */
        getNormalAtCoordinatesToRef(x: number, z: number, ref: Vector3): GroundMesh;
        /**
        * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()
        * if the ground has been updated.
        * This can be used in the render loop.
        * Returns the GroundMesh.
        */
        updateCoordinateHeights(): GroundMesh;
        private _getFacetAt(x, z);
        private _initHeightQuads();
        private _computeHeightQuads();
        serialize(serializationObject: any): void;
        static Parse(parsedMesh: any, scene: Scene): GroundMesh;
    }
}

declare module BABYLON {
    /**
     * Creates an instance based on a source mesh.
     */
    class InstancedMesh extends AbstractMesh {
        private _sourceMesh;
        private _currentLOD;
        constructor(name: string, source: Mesh);
        /**
         * Returns the string "InstancedMesh".
         */
        getClassName(): string;
        readonly receiveShadows: boolean;
        readonly material: Nullable<Material>;
        readonly visibility: number;
        readonly skeleton: Nullable<Skeleton>;
        renderingGroupId: number;
        /**
         * Returns the total number of vertices (integer).
         */
        getTotalVertices(): number;
        readonly sourceMesh: Mesh;
        /**
         * Is this node ready to be used/rendered
         * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)
         * @return {boolean} is it ready
         */
        isReady(completeCheck?: boolean): boolean;
        /**
         * Returns a float array or a Float32Array of the requested kind of data : positons, normals, uvs, etc.
         */
        getVerticesData(kind: string, copyWhenShared?: boolean): Nullable<FloatArray>;
        /**
         * Sets the vertex data of the mesh geometry for the requested `kind`.
         * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
         * The `data` are either a numeric array either a Float32Array.
         * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initianilly none) or updater.
         * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).
         * Note that a new underlying VertexBuffer object is created each call.
         * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
         *
         * Possible `kind` values :
         * - BABYLON.VertexBuffer.PositionKind
         * - BABYLON.VertexBuffer.UVKind
         * - BABYLON.VertexBuffer.UV2Kind
         * - BABYLON.VertexBuffer.UV3Kind
         * - BABYLON.VertexBuffer.UV4Kind
         * - BABYLON.VertexBuffer.UV5Kind
         * - BABYLON.VertexBuffer.UV6Kind
         * - BABYLON.VertexBuffer.ColorKind
         * - BABYLON.VertexBuffer.MatricesIndicesKind
         * - BABYLON.VertexBuffer.MatricesIndicesExtraKind
         * - BABYLON.VertexBuffer.MatricesWeightsKind
         * - BABYLON.VertexBuffer.MatricesWeightsExtraKind
         *
         * Returns the Mesh.
         */
        setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): Mesh;
        /**
         * Updates the existing vertex data of the mesh geometry for the requested `kind`.
         * If the mesh has no geometry, it is simply returned as it is.
         * The `data` are either a numeric array either a Float32Array.
         * No new underlying VertexBuffer object is created.
         * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
         * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.
         *
         * Possible `kind` values :
         * - BABYLON.VertexBuffer.PositionKind
         * - BABYLON.VertexBuffer.UVKind
         * - BABYLON.VertexBuffer.UV2Kind
         * - BABYLON.VertexBuffer.UV3Kind
         * - BABYLON.VertexBuffer.UV4Kind
         * - BABYLON.VertexBuffer.UV5Kind
         * - BABYLON.VertexBuffer.UV6Kind
         * - BABYLON.VertexBuffer.ColorKind
         * - BABYLON.VertexBuffer.MatricesIndicesKind
         * - BABYLON.VertexBuffer.MatricesIndicesExtraKind
         * - BABYLON.VertexBuffer.MatricesWeightsKind
         * - BABYLON.VertexBuffer.MatricesWeightsExtraKind
         *
         * Returns the Mesh.
         */
        updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): Mesh;
        /**
         * Sets the mesh indices.
         * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).
         * If the mesh has no geometry, a new Geometry object is created and set to the mesh.
         * This method creates a new index buffer each call.
         * Returns the Mesh.
         */
        setIndices(indices: IndicesArray, totalVertices?: Nullable<number>): Mesh;
        /**
         * Boolean : True if the mesh owns the requested kind of data.
         */
        isVerticesDataPresent(kind: string): boolean;
        /**
         * Returns an array of indices (IndicesArray).
         */
        getIndices(): Nullable<IndicesArray>;
        readonly _positions: Nullable<Vector3[]>;
        /**
         * Sets a new updated BoundingInfo to the mesh.
         * Returns the mesh.
         */
        refreshBoundingInfo(): InstancedMesh;
        _preActivate(): InstancedMesh;
        _activate(renderId: number): InstancedMesh;
        /**
         * Returns the current associated LOD AbstractMesh.
         */
        getLOD(camera: Camera): AbstractMesh;
        _syncSubMeshes(): InstancedMesh;
        _generatePointsArray(): boolean;
        /**
         * Creates a new InstancedMesh from the current mesh.
         * - name (string) : the cloned mesh name
         * - newParent (optional Node) : the optional Node to parent the clone to.
         * - doNotCloneChildren (optional boolean, default `false`) : if `true` the model children aren't cloned.
         *
         * Returns the clone.
         */
        clone(name: string, newParent: Node, doNotCloneChildren?: boolean): InstancedMesh;
        /**
         * Disposes the InstancedMesh.
         * Returns nothing.
         */
        dispose(doNotRecurse?: boolean, disposeMaterialAndTextures?: boolean): void;
    }
}

declare module BABYLON {
    class LinesMesh extends Mesh {
        useVertexColor: boolean | undefined;
        useVertexAlpha: boolean | undefined;
        color: Color3;
        alpha: number;
        /**
         * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.
         * This margin is expressed in world space coordinates, so its value may vary.
         * Default value is 0.1
         * @returns the intersection Threshold value.
         */
        /**
         * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.
         * This margin is expressed in world space coordinates, so its value may vary.
         * @param value the new threshold to apply
         */
        intersectionThreshold: number;
        private _intersectionThreshold;
        private _colorShader;
        constructor(name: string, scene?: Nullable<Scene>, parent?: Nullable<Node>, source?: LinesMesh, doNotCloneChildren?: boolean, useVertexColor?: boolean | undefined, useVertexAlpha?: boolean | undefined);
        /**
         * Returns the string "LineMesh"
         */
        getClassName(): string;
        material: Material;
        readonly checkCollisions: boolean;
        createInstance(name: string): InstancedMesh;
        _bind(subMesh: SubMesh, effect: Effect, fillMode: number): LinesMesh;
        _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number): LinesMesh;
        dispose(doNotRecurse?: boolean): void;
        /**
         * Returns a new LineMesh object cloned from the current one.
         */
        clone(name: string, newParent?: Node, doNotCloneChildren?: boolean): LinesMesh;
    }
}

declare module BABYLON {
    /**
     * @hidden
     **/
    class _InstancesBatch {
        mustReturn: boolean;
        visibleInstances: Nullable<InstancedMesh[]>[];
        renderSelf: boolean[];
    }
    class Mesh extends AbstractMesh implements IGetSetVerticesData {
        static _FRONTSIDE: number;
        static _BACKSIDE: number;
        static _DOUBLESIDE: number;
        static _DEFAULTSIDE: number;
        static _NO_CAP: number;
        static _CAP_START: number;
        static _CAP_END: number;
        static _CAP_ALL: number;
        /**
         * Mesh side orientation : usually the external or front surface
         */
        static readonly FRONTSIDE: number;
        /**
         * Mesh side orientation : usually the internal or back surface
         */
        static readonly BACKSIDE: number;
        /**
         * Mesh side orientation : both internal and external or front and back surfaces
         */
        static readonly DOUBLESIDE: number;
        /**
         * Mesh side orientation : by default, `FRONTSIDE`
         */
        static readonly DEFAULTSIDE: number;
        /**
         * Mesh cap setting : no cap
         */
        static readonly NO_CAP: number;
        /**
         * Mesh cap setting : one cap at the beginning of the mesh
         */
        static readonly CAP_START: number;
        /**
         * Mesh cap setting : one cap at the end of the mesh
         */
        static readonly CAP_END: number;
        /**
         * Mesh cap setting : two caps, one at the beginning  and one at the end of the mesh
         */
        static readonly CAP_ALL: number;
        /**
         * An event triggered before rendering the mesh
         */
        onBeforeRenderObservable: Observable<Mesh>;
        /**
        * An event triggered after rendering the mesh
        */
        onAfterRenderObservable: Observable<Mesh>;
        /**
        * An event triggered before drawing the mesh
        */
        onBeforeDrawObservable: Observable<Mesh>;
        private _onBeforeDrawObserver;
        onBeforeDraw: () => void;
        delayLoadState: number;
        instances: InstancedMesh[];
        delayLoadingFile: string;
        _binaryInfo: any;
        private _LODLevels;
        onLODLevelSelection: (distance: number, mesh: Mesh, selectedLevel: Mesh) => void;
        private _morphTargetManager;
        morphTargetManager: Nullable<MorphTargetManager>;
        _geometry: Nullable<Geometry>;
        _delayInfo: Array<string>;
        _delayLoadingFunction: (any: any, mesh: Mesh) => void;
        _visibleInstances: any;
        private _renderIdForInstances;
        private _batchCache;
        private _instancesBufferSize;
        private _instancesBuffer;
        private _instancesData;
        private _overridenInstanceCount;
        private _effectiveMaterial;
        _shouldGenerateFlatShading: boolean;
        private _preActivateId;
        _originalBuilderSideOrientation: number;
        overrideMaterialSideOrientation: Nullable<number>;
        private _areNormalsFrozen;
        private _sourcePositions;
        private _sourceNormals;
        private _source;
        readonly source: Nullable<Mesh>;
        isUnIndexed: boolean;
        /**
         * @constructor
         * @param {string} name The value used by scene.getMeshByName() to do a lookup.
         * @param {Scene} scene The scene to add this mesh to.
         * @param {Node} parent The parent of this mesh, if it has one
         * @param {Mesh} source An optional Mesh from which geometry is shared, cloned.
         * @param {boolean} doNotCloneChildren When cloning, skip cloning child meshes of source, default False.
         *                  When false, achieved by calling a clone(), also passing False.
         *                  This will make creation of children, recursive.
         * @param {boolean} clonePhysicsImpostor When cloning, include cloning mesh physics impostor, default True.
         */
        constructor(name: string, scene?: Nullable<Scene>, parent?: Nullable<Node>, source?: Nullable<Mesh>, doNotCloneChildren?: boolean, clonePhysicsImpostor?: boolean);
        /**
         * Returns the string "Mesh".
         */
        getClassName(): string;
        /**
         * Returns a string.
         * @param {boolean} fullDetails - support for multiple levels of logging within scene loading
         */
        toString(fullDetails?: boolean): string;
        _unBindEffect(): void;
        /**
         * True if the mesh has some Levels Of Details (LOD).
         * Returns a boolean.
         */
        readonly hasLODLevels: boolean;
        /**
         * Gets the list of {BABYLON.MeshLODLevel} associated with the current mesh
         * @returns an array of {BABYLON.MeshLODLevel}
         */
        getLODLevels(): MeshLODLevel[];
        private _sortLODLevels();
        /**
         * Add a mesh as LOD level triggered at the given distance.
         * tuto : http://doc.babylonjs.com/tutorials/How_to_use_LOD
         * @param {number} distance The distance from the center of the object to show this level
         * @param {Mesh} mesh The mesh to be added as LOD level
         * @return {Mesh} This mesh (for chaining)
         */
        addLODLevel(distance: number, mesh: Mesh): Mesh;
        /**
         * Returns the LOD level mesh at the passed distance or null if not found.
         * It is related to the method `addLODLevel(distance, mesh)`.
         * tuto : http://doc.babylonjs.com/tutorials/How_to_use_LOD
         * Returns an object Mesh or `null`.
         */
        getLODLevelAtDistance(distance: number): Nullable<Mesh>;
        /**
         * Remove a mesh from the LOD array
         * tuto : http://doc.babylonjs.com/tutorials/How_to_use_LOD
         * @param {Mesh} mesh The mesh to be removed.
         * @return {Mesh} This mesh (for chaining)
         */
        removeLODLevel(mesh: Mesh): Mesh;
        /**
         * Returns the registered LOD mesh distant from the parameter `camera` position if any, else returns the current mesh.
         * tuto : http://doc.babylonjs.com/tutorials/How_to_use_LOD
         */
        getLOD(camera: Camera, boundingSphere?: BoundingSphere): AbstractMesh;
        /**
         * Returns the mesh internal Geometry object.
         */
        readonly geometry: Nullable<Geometry>;
        /**
         * Returns a positive integer : the total number of vertices within the mesh geometry or zero if the mesh has no geometry.
         */
        getTotalVertices(): number;
        /**
         * Returns an array of integers or floats, or a Float32Array, depending on the requested `kind` (positions, indices, normals, etc).
         * If `copywhenShared` is true (default false) and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.
         * You can force the copy with forceCopy === true
         * Returns null if the mesh has no geometry or no vertex buffer.
         * Possible `kind` values :
         * - BABYLON.VertexBuffer.PositionKind
         * - BABYLON.VertexBuffer.UVKind
         * - BABYLON.VertexBuffer.UV2Kind
         * - BABYLON.VertexBuffer.UV3Kind
         * - BABYLON.VertexBuffer.UV4Kind
         * - BABYLON.VertexBuffer.UV5Kind
         * - BABYLON.VertexBuffer.UV6Kind
         * - BABYLON.VertexBuffer.ColorKind
         * - BABYLON.VertexBuffer.MatricesIndicesKind
         * - BABYLON.VertexBuffer.MatricesIndicesExtraKind
         * - BABYLON.VertexBuffer.MatricesWeightsKind
         * - BABYLON.VertexBuffer.MatricesWeightsExtraKind
         */
        getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray>;
        /**
         * Returns the mesh VertexBuffer object from the requested `kind` : positions, indices, normals, etc.
         * Returns `null` if the mesh has no geometry.
         * Possible `kind` values :
         * - BABYLON.VertexBuffer.PositionKind
         * - BABYLON.VertexBuffer.UVKind
         * - BABYLON.VertexBuffer.UV2Kind
         * - BABYLON.VertexBuffer.UV3Kind
         * - BABYLON.VertexBuffer.UV4Kind
         * - BABYLON.VertexBuffer.UV5Kind
         * - BABYLON.VertexBuffer.UV6Kind
         * - BABYLON.VertexBuffer.ColorKind
         * - BABYLON.VertexBuffer.MatricesIndicesKind
         * - BABYLON.VertexBuffer.MatricesIndicesExtraKind
         * - BABYLON.VertexBuffer.MatricesWeightsKind
         * - BABYLON.VertexBuffer.MatricesWeightsExtraKind
         */
        getVertexBuffer(kind: string): Nullable<VertexBuffer>;
        isVerticesDataPresent(kind: string): boolean;
        /**
         * Returns a boolean defining if the vertex data for the requested `kind` is updatable.
         * Possible `kind` values :
         * - BABYLON.VertexBuffer.PositionKind
         * - BABYLON.VertexBuffer.UVKind
         * - BABYLON.VertexBuffer.UV2Kind
         * - BABYLON.VertexBuffer.UV3Kind
         * - BABYLON.VertexBuffer.UV4Kind
         * - BABYLON.VertexBuffer.UV5Kind
         * - BABYLON.VertexBuffer.UV6Kind
         * - BABYLON.VertexBuffer.ColorKind
         * - BABYLON.VertexBuffer.MatricesIndicesKind
         * - BABYLON.VertexBuffer.MatricesIndicesExtraKind
         * - BABYLON.VertexBuffer.MatricesWeightsKind
         * - BABYLON.VertexBuffer.MatricesWeightsExtraKind
         */
        isVertexBufferUpdatable(kind: string): boolean;
        /**
         * Returns a string : the list of existing `kinds` of Vertex Data for this mesh.
         * Possible `kind` values :
         * - BABYLON.VertexBuffer.PositionKind
         * - BABYLON.VertexBuffer.UVKind
         * - BABYLON.VertexBuffer.UV2Kind
         * - BABYLON.VertexBuffer.UV3Kind
         * - BABYLON.VertexBuffer.UV4Kind
         * - BABYLON.VertexBuffer.UV5Kind
         * - BABYLON.VertexBuffer.UV6Kind
         * - BABYLON.VertexBuffer.ColorKind
         * - BABYLON.VertexBuffer.MatricesIndicesKind
         * - BABYLON.VertexBuffer.MatricesIndicesExtraKind
         * - BABYLON.VertexBuffer.MatricesWeightsKind
         * - BABYLON.VertexBuffer.MatricesWeightsExtraKind
         */
        getVerticesDataKinds(): string[];
        /**
         * Returns a positive integer : the total number of indices in this mesh geometry.
         * Returns zero if the mesh has no geometry.
         */
        getTotalIndices(): number;
        /**
         * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.
         * If the parameter `copyWhenShared` is true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.
         * Returns an empty array if the mesh has no geometry.
         */
        getIndices(copyWhenShared?: boolean): Nullable<IndicesArray>;
        readonly isBlocked: boolean;
        /**
         * Determine if the current mesh is ready to be rendered
         * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)
         * @param forceInstanceSupport will check if the mesh will be ready when used with instances (false by default)
         * @returns true if all associated assets are ready (material, textures, shaders)
         */
        isReady(completeCheck?: boolean, forceInstanceSupport?: boolean): boolean;
        /**
         * Boolean : true if the normals aren't to be recomputed on next mesh `positions` array update.
         * This property is pertinent only for updatable parametric shapes.
         */
        readonly areNormalsFrozen: boolean;
        /**
         * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc.
         * It has no effect at all on other shapes.
         * It prevents the mesh normals from being recomputed on next `positions` array update.
         * Returns the Mesh.
         */
        freezeNormals(): Mesh;
        /**
         * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc.
         * It has no effect at all on other shapes.
         * It reactivates the mesh normals computation if it was previously frozen.
         * Returns the Mesh.
         */
        unfreezeNormals(): Mesh;
        /**
         * Overrides instance count. Only applicable when custom instanced InterleavedVertexBuffer are used rather than InstancedMeshs
         */
        overridenInstanceCount: number;
        _preActivate(): Mesh;
        _preActivateForIntermediateRendering(renderId: number): Mesh;
        _registerInstanceForRenderId(instance: InstancedMesh, renderId: number): Mesh;
        /**
         * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.
         * This means the mesh underlying bounding box and sphere are recomputed.
         * Returns the Mesh.
         */
        refreshBoundingInfo(): Mesh;
        _refreshBoundingInfo(applySkeleton: boolean): Mesh;
        private _getPositionData(applySkeleton);
        _createGlobalSubMesh(force: boolean): Nullable<SubMesh>;
        subdivide(count: number): void;
        setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): Mesh;
        markVerticesDataAsUpdatable(kind: string, updatable?: boolean): void;
        /**
         * Sets the mesh VertexBuffer.
         * Returns the Mesh.
         */
        setVerticesBuffer(buffer: VertexBuffer): Mesh;
        updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): Mesh;
        /**
         * This method updates the vertex positions of an updatable mesh according to the `positionFunction` returned values.
         * tuto : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#other-shapes-updatemeshpositions
         * The parameter `positionFunction` is a simple JS function what is passed the mesh `positions` array. It doesn't need to return anything.
         * The parameter `computeNormals` is a boolean (default true) to enable/disable the mesh normal recomputation after the vertex position update.
         * Returns the Mesh.
         */
        updateMeshPositions(positionFunction: (data: FloatArray) => void, computeNormals?: boolean): Mesh;
        /**
         * Creates a un-shared specific occurence of the geometry for the mesh.
         * Returns the Mesh.
         */
        makeGeometryUnique(): Mesh;
        setIndices(indices: IndicesArray, totalVertices?: Nullable<number>, updatable?: boolean): Mesh;
        /**
         * Update the current index buffer
         * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array)
         * Returns the Mesh.
         */
        updateIndices(indices: IndicesArray, offset?: number): Mesh;
        /**
         * Invert the geometry to move from a right handed system to a left handed one.
         * Returns the Mesh.
         */
        toLeftHanded(): Mesh;
        _bind(subMesh: SubMesh, effect: Effect, fillMode: number): Mesh;
        _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number, alternate?: boolean): Mesh;
        /**
         * Registers for this mesh a javascript function called just before the rendering process.
         * This function is passed the current mesh.
         * Return the Mesh.
         */
        registerBeforeRender(func: (mesh: AbstractMesh) => void): Mesh;
        /**
         * Disposes a previously registered javascript function called before the rendering.
         * This function is passed the current mesh.
         * Returns the Mesh.
         */
        unregisterBeforeRender(func: (mesh: AbstractMesh) => void): Mesh;
        /**
         * Registers for this mesh a javascript function called just after the rendering is complete.
         * This function is passed the current mesh.
         * Returns the Mesh.
         */
        registerAfterRender(func: (mesh: AbstractMesh) => void): Mesh;
        /**
         * Disposes a previously registered javascript function called after the rendering.
         * This function is passed the current mesh.
         * Return the Mesh.
         */
        unregisterAfterRender(func: (mesh: AbstractMesh) => void): Mesh;
        _getInstancesRenderList(subMeshId: number): _InstancesBatch;
        _renderWithInstances(subMesh: SubMesh, fillMode: number, batch: _InstancesBatch, effect: Effect, engine: Engine): Mesh;
        _processRendering(subMesh: SubMesh, effect: Effect, fillMode: number, batch: _InstancesBatch, hardwareInstancedRendering: boolean, onBeforeDraw: (isInstance: boolean, world: Matrix, effectiveMaterial?: Material) => void, effectiveMaterial?: Material): Mesh;
        /**
         * Triggers the draw call for the mesh.
         * Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager.
         * Returns the Mesh.
         */
        render(subMesh: SubMesh, enableAlphaMode: boolean): Mesh;
        private _onBeforeDraw(isInstance, world, effectiveMaterial?);
        /**
         * Returns an array populated with ParticleSystem objects whose the mesh is the emitter.
         */
        getEmittedParticleSystems(): IParticleSystem[];
        /**
         * Returns an array populated with ParticleSystem objects whose the mesh or its children are the emitter.
         */
        getHierarchyEmittedParticleSystems(): IParticleSystem[];
        /**
         * Normalize matrix weights so that all vertices have a total weight set to 1
         */
        cleanMatrixWeights(): void;
        _checkDelayState(): Mesh;
        private _queueLoad(scene);
        /**
         * Boolean, true is the mesh in the frustum defined by the Plane objects from the `frustumPlanes` array parameter.
         */
        isInFrustum(frustumPlanes: Plane[]): boolean;
        /**
         * Sets the mesh material by the material or multiMaterial `id` property.
         * The material `id` is a string identifying the material or the multiMaterial.
         * This method returns the Mesh.
         */
        setMaterialByID(id: string): Mesh;
        /**
         * Returns as a new array populated with the mesh material and/or skeleton, if any.
         */
        getAnimatables(): IAnimatable[];
        /**
         * Modifies the mesh geometry according to the passed transformation matrix.
         * This method returns nothing but it really modifies the mesh even if it's originally not set as updatable.
         * The mesh normals are modified accordingly the same transformation.
         * tuto : http://doc.babylonjs.com/resources/baking_transformations
         * Note that, under the hood, this method sets a new VertexBuffer each call.
         * Returns the Mesh.
         */
        bakeTransformIntoVertices(transform: Matrix): Mesh;
        /**
         * Modifies the mesh geometry according to its own current World Matrix.
         * The mesh World Matrix is then reset.
         * This method returns nothing but really modifies the mesh even if it's originally not set as updatable.
         * tuto : tuto : http://doc.babylonjs.com/resources/baking_transformations
         * Note that, under the hood, this method sets a new VertexBuffer each call.
         * Returns the Mesh.
         */
        bakeCurrentTransformIntoVertices(): Mesh;
        readonly _positions: Nullable<Vector3[]>;
        _resetPointsArrayCache(): Mesh;
        _generatePointsArray(): boolean;
        /**
         * Returns a new Mesh object generated from the current mesh properties.
         * This method must not get confused with createInstance().
         * The parameter `name` is a string, the name given to the new mesh.
         * The optional parameter `newParent` can be any Node object (default `null`).
         * The optional parameter `doNotCloneChildren` (default `false`) allows/denies the recursive cloning of the original mesh children if any.
         * The parameter `clonePhysicsImpostor` (default `true`)  allows/denies the cloning in the same time of the original mesh `body` used by the physics engine, if any.
         */
        clone(name: string, newParent?: Node, doNotCloneChildren?: boolean, clonePhysicsImpostor?: boolean): Mesh;
        /**
         * Releases resources associated with this mesh.
         * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
         * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
         */
        dispose(doNotRecurse?: boolean, disposeMaterialAndTextures?: boolean): void;
        /**
         * Modifies the mesh geometry according to a displacement map.
         * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.
         * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.
         * This method returns nothing.
         * The parameter `url` is a string, the URL from the image file is to be downloaded.
         * The parameters `minHeight` and `maxHeight` are the lower and upper limits of the displacement.
         * The parameter `onSuccess` is an optional Javascript function to be called just after the mesh is modified. It is passed the modified mesh and must return nothing.
         * The parameter `uvOffset` is an optional vector2 used to offset UV.
         * The parameter `uvScale` is an optional vector2 used to scale UV.
         *
         * Returns the Mesh.
         */
        applyDisplacementMap(url: string, minHeight: number, maxHeight: number, onSuccess?: (mesh: Mesh) => void, uvOffset?: Vector2, uvScale?: Vector2): Mesh;
        /**
         * Modifies the mesh geometry according to a displacementMap buffer.
         * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.
         * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.
         * This method returns nothing.
         * The parameter `buffer` is a `Uint8Array` buffer containing series of `Uint8` lower than 255, the red, green, blue and alpha values of each successive pixel.
         * The parameters `heightMapWidth` and `heightMapHeight` are positive integers to set the width and height of the buffer image.
         * The parameters `minHeight` and `maxHeight` are the lower and upper limits of the displacement.
         * The parameter `uvOffset` is an optional vector2 used to offset UV.
         * The parameter `uvScale` is an optional vector2 used to scale UV.
         *
         * Returns the Mesh.
         */
        applyDisplacementMapFromBuffer(buffer: Uint8Array, heightMapWidth: number, heightMapHeight: number, minHeight: number, maxHeight: number, uvOffset?: Vector2, uvScale?: Vector2): Mesh;
        /**
         * Modify the mesh to get a flat shading rendering.
         * This means each mesh facet will then have its own normals. Usually new vertices are added in the mesh geometry to get this result.
         * This method returns the Mesh.
         * Warning : the mesh is really modified even if not set originally as updatable and, under the hood, a new VertexBuffer is allocated.
         */
        convertToFlatShadedMesh(): Mesh;
        /**
         * This method removes all the mesh indices and add new vertices (duplication) in order to unfold facets into buffers.
         * In other words, more vertices, no more indices and a single bigger VBO.
         * The mesh is really modified even if not set originally as updatable. Under the hood, a new VertexBuffer is allocated.
         * Returns the Mesh.
         */
        convertToUnIndexedMesh(): Mesh;
        /**
         * Inverses facet orientations and inverts also the normals with `flipNormals` (default `false`) if true.
         * This method returns the Mesh.
         * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.
         */
        flipFaces(flipNormals?: boolean): Mesh;
        /**
         * Creates a new InstancedMesh object from the mesh model.
         * An instance shares the same properties and the same material than its model.
         * Only these properties of each instance can then be set individually :
         * - position
         * - rotation
         * - rotationQuaternion
         * - setPivotMatrix
         * - scaling
         * tuto : http://doc.babylonjs.com/tutorials/How_to_use_Instances
         * Warning : this method is not supported for Line mesh and LineSystem
         */
        createInstance(name: string): InstancedMesh;
        /**
         * Synchronises all the mesh instance submeshes to the current mesh submeshes, if any.
         * After this call, all the mesh instances have the same submeshes than the current mesh.
         * This method returns the Mesh.
         */
        synchronizeInstances(): Mesh;
        /**
         * Simplify the mesh according to the given array of settings.
         * Function will return immediately and will simplify async. It returns the Mesh.
         * @param settings a collection of simplification settings.
         * @param parallelProcessing should all levels calculate parallel or one after the other.
         * @param type the type of simplification to run.
         * @param successCallback optional success callback to be called after the simplification finished processing all settings.
         */
        simplify(settings: Array<ISimplificationSettings>, parallelProcessing?: boolean, simplificationType?: SimplificationType, successCallback?: (mesh?: Mesh, submeshIndex?: number) => void): Mesh;
        /**
         * Optimization of the mesh's indices, in case a mesh has duplicated vertices.
         * The function will only reorder the indices and will not remove unused vertices to avoid problems with submeshes.
         * This should be used together with the simplification to avoid disappearing triangles.
         * Returns the Mesh.
         * @param successCallback an optional success callback to be called after the optimization finished.
         */
        optimizeIndices(successCallback?: (mesh?: Mesh) => void): Mesh;
        serialize(serializationObject: any): void;
        _syncGeometryWithMorphTargetManager(): void;
        /**
         * Returns a new Mesh object parsed from the source provided.
         * The parameter `parsedMesh` is the source.
         * The parameter `rootUrl` is a string, it's the root URL to prefix the `delayLoadingFile` property with
         */
        static Parse(parsedMesh: any, scene: Scene, rootUrl: string): Mesh;
        /**
         * Creates a ribbon mesh.
         * Please consider using the same method from the MeshBuilder class instead.
         * The ribbon is a parametric shape :  http://doc.babylonjs.com/tutorials/Parametric_Shapes.  It has no predefined shape. Its final shape will depend on the input parameters.
         *
         * Please read this full tutorial to understand how to design a ribbon : http://doc.babylonjs.com/tutorials/Ribbon_Tutorial
         * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry.
         * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array.
         * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array.
         * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path.
         * It's the offset to join together the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11.
         * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#ribbon
         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         */
        static CreateRibbon(name: string, pathArray: Vector3[][], closeArray: boolean | undefined, closePath: boolean, offset: number, scene?: Scene, updatable?: boolean, sideOrientation?: number, instance?: Mesh): Mesh;
        /**
         * Creates a plane polygonal mesh.  By default, this is a disc.
         * Please consider using the same method from the MeshBuilder class instead.
         * The parameter `radius` sets the radius size (float) of the polygon (default 0.5).
         * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc.
         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         */
        static CreateDisc(name: string, radius: number, tessellation: number, scene?: Nullable<Scene>, updatable?: boolean, sideOrientation?: number): Mesh;
        /**
         * Creates a box mesh.
         * Please consider using the same method from the MeshBuilder class instead.
         * The parameter `size` sets the size (float) of each box side (default 1).
         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         */
        static CreateBox(name: string, size: number, scene?: Nullable<Scene>, updatable?: boolean, sideOrientation?: number): Mesh;
        /**
         * Creates a sphere mesh.
         * Please consider using the same method from the MeshBuilder class instead.
         * The parameter `diameter` sets the diameter size (float) of the sphere (default 1).
         * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32).
         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         */
        static CreateSphere(name: string, segments: number, diameter: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh;
        /**
         * Creates a cylinder or a cone mesh.
         * Please consider using the same method from the MeshBuilder class instead.
         * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).
         * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).
         * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter "diameterBottom" can't be zero.
         * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.
         * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).
         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         */
        static CreateCylinder(name: string, height: number, diameterTop: number, diameterBottom: number, tessellation: number, subdivisions: any, scene?: Scene, updatable?: any, sideOrientation?: number): Mesh;
        /**
         * Creates a torus mesh.
         * Please consider using the same method from the MeshBuilder class instead.
         * The parameter `diameter` sets the diameter size (float) of the torus (default 1).
         * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5).
         * The parameter `tessellation` sets the number of torus sides (postive integer, default 16).
         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         */
        static CreateTorus(name: string, diameter: number, thickness: number, tessellation: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh;
        /**
         * Creates a torus knot mesh.
         * Please consider using the same method from the MeshBuilder class instead.
         * The parameter `radius` sets the global radius size (float) of the torus knot (default 2).
         * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32).
         * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32).
         * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3).
         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         */
        static CreateTorusKnot(name: string, radius: number, tube: number, radialSegments: number, tubularSegments: number, p: number, q: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh;
        /**
         * Creates a line mesh.
         * Please consider using the same method from the MeshBuilder class instead.
         * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter.
         * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function.
         * The parameter `points` is an array successive Vector3.
         * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines
         * When updating an instance, remember that only point positions can change, not the number of points.
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         */
        static CreateLines(name: string, points: Vector3[], scene?: Nullable<Scene>, updatable?: boolean, instance?: Nullable<LinesMesh>): LinesMesh;
        /**
         * Creates a dashed line mesh.
         * Please consider using the same method from the MeshBuilder class instead.
         * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter.
         * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function.
         * The parameter `points` is an array successive Vector3.
         * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200).
         * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3).
         * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1).
         * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines
         * When updating an instance, remember that only point positions can change, not the number of points.
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         */
        static CreateDashedLines(name: string, points: Vector3[], dashSize: number, gapSize: number, dashNb: number, scene?: Nullable<Scene>, updatable?: boolean, instance?: LinesMesh): LinesMesh;
        /**
         * Creates a polygon mesh.
         * Please consider using the same method from the MeshBuilder class instead.
         * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh.
         * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors.
         * You can set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         * Remember you can only change the shape positions, not their number when updating a polygon.
         */
        static CreatePolygon(name: string, shape: Vector3[], scene: Scene, holes?: Vector3[][], updatable?: boolean, sideOrientation?: number): Mesh;
        /**
          * Creates an extruded polygon mesh, with depth in the Y direction.
          * Please consider using the same method from the MeshBuilder class instead.
         */
        static ExtrudePolygon(name: string, shape: Vector3[], depth: number, scene: Scene, holes?: Vector3[][], updatable?: boolean, sideOrientation?: number): Mesh;
        /**
         * Creates an extruded shape mesh.
         * The extrusion is a parametric shape :  http://doc.babylonjs.com/tutorials/Parametric_Shapes.  It has no predefined shape. Its final shape will depend on the input parameters.
         * Please consider using the same method from the MeshBuilder class instead.
         *
         * Please read this full tutorial to understand how to design an extruded shape : http://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
         * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be
         * extruded along the Z axis.
         * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
         * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.
         * The parameter `scale` (float, default 1) is the value to scale the shape.
         * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
         * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#extruded-shape
         * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.
         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         */
        static ExtrudeShape(name: string, shape: Vector3[], path: Vector3[], scale: number, rotation: number, cap: number, scene?: Nullable<Scene>, updatable?: boolean, sideOrientation?: number, instance?: Mesh): Mesh;
        /**
         * Creates an custom extruded shape mesh.
         * The custom extrusion is a parametric shape :  http://doc.babylonjs.com/tutorials/Parametric_Shapes.  It has no predefined shape. Its final shape will depend on the input parameters.
         * Please consider using the same method from the MeshBuilder class instead.
         *
         * Please read this full tutorial to understand how to design a custom extruded shape : http://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
         * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be
         * extruded along the Z axis.
         * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
         * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path
         * and the distance of this point from the begining of the path :
         * ```javascript
         * var rotationFunction = function(i, distance) {
         *     // do things
         *     return rotationValue; }
         * ```
         * It must returns a float value that will be the rotation in radians applied to the shape on each path point.
         * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path
         * and the distance of this point from the begining of the path :
         * ```javascript
         * var scaleFunction = function(i, distance) {
         *     // do things
         *    return scaleValue;}
         * ```
         * It must returns a float value that will be the scale value applied to the shape on each path point.
         * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`.
         * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`.
         * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
         * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#extruded-shape
         * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.
         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         */
        static ExtrudeShapeCustom(name: string, shape: Vector3[], path: Vector3[], scaleFunction: Function, rotationFunction: Function, ribbonCloseArray: boolean, ribbonClosePath: boolean, cap: number, scene: Scene, updatable?: boolean, sideOrientation?: number, instance?: Mesh): Mesh;
        /**
         * Creates lathe mesh.
         * The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe.
         * Please consider using the same method from the MeshBuilder class instead.
         * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be
         * rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero.
         * The parameter `radius` (positive float, default 1) is the radius value of the lathe.
         * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe.
         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         */
        static CreateLathe(name: string, shape: Vector3[], radius: number, tessellation: number, scene: Scene, updatable?: boolean, sideOrientation?: number): Mesh;
        /**
         * Creates a plane mesh.
         * Please consider using the same method from the MeshBuilder class instead.
         * The parameter `size` sets the size (float) of both sides of the plane at once (default 1).
         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         */
        static CreatePlane(name: string, size: number, scene: Scene, updatable?: boolean, sideOrientation?: number): Mesh;
        /**
         * Creates a ground mesh.
         * Please consider using the same method from the MeshBuilder class instead.
         * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground.
         * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side.
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         */
        static CreateGround(name: string, width: number, height: number, subdivisions: number, scene?: Scene, updatable?: boolean): Mesh;
        /**
         * Creates a tiled ground mesh.
         * Please consider using the same method from the MeshBuilder class instead.
         * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates.
         * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates.
         * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the
         * numbers of subdivisions on the ground width and height. Each subdivision is called a tile.
         * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the
         * numbers of subdivisions on the ground width and height of each tile.
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         */
        static CreateTiledGround(name: string, xmin: number, zmin: number, xmax: number, zmax: number, subdivisions: {
            w: number;
            h: number;
        }, precision: {
            w: number;
            h: number;
        }, scene: Scene, updatable?: boolean): Mesh;
        /**
         * Creates a ground mesh from a height map.
         * tuto : http://doc.babylonjs.com/babylon101/height_map
         * Please consider using the same method from the MeshBuilder class instead.
         * The parameter `url` sets the URL of the height map image resource.
         * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.
         * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.
         * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.
         * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.
         * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).
         * This function is passed the newly built mesh :
         * ```javascript
         * function(mesh) { // do things
         *     return; }
         * ```
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         */
        static CreateGroundFromHeightMap(name: string, url: string, width: number, height: number, subdivisions: number, minHeight: number, maxHeight: number, scene: Scene, updatable?: boolean, onReady?: (mesh: GroundMesh) => void): GroundMesh;
        /**
         * Creates a tube mesh.
         * The tube is a parametric shape :  http://doc.babylonjs.com/tutorials/Parametric_Shapes.  It has no predefined shape. Its final shape will depend on the input parameters.
         * Please consider using the same method from the MeshBuilder class instead.
         * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube.
         * The parameter `radius` (positive float, default 1) sets the tube radius size.
         * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface.
         * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`.
         * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path.
         * It must return a radius value (positive float) :
         * ```javascript
         * var radiusFunction = function(i, distance) {
         *     // do things
         *     return radius; }
         * ```
         * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
         * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#tube
         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         */
        static CreateTube(name: string, path: Vector3[], radius: number, tessellation: number, radiusFunction: {
            (i: number, distance: number): number;
        }, cap: number, scene: Scene, updatable?: boolean, sideOrientation?: number, instance?: Mesh): Mesh;
        /**
         * Creates a polyhedron mesh.
         * Please consider using the same method from the MeshBuilder class instead.
         * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial
         *  to choose the wanted type.
         * The parameter `size` (positive float, default 1) sets the polygon size.
         * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value).
         * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`.
         * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron
         * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`).
         * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : http://doc.babylonjs.com/tutorials/CreateBox_Per_Face_Textures_And_Colors
         * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored.
         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         */
        static CreatePolyhedron(name: string, options: {
            type?: number;
            size?: number;
            sizeX?: number;
            sizeY?: number;
            sizeZ?: number;
            custom?: any;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            updatable?: boolean;
            sideOrientation?: number;
        }, scene: Scene): Mesh;
        /**
         * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided.
         * Please consider using the same method from the MeshBuilder class instead.
         * The parameter `radius` sets the radius size (float) of the icosphere (default 1).
         * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value than `radius`).
         * The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size.
         * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface.
         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         */
        static CreateIcoSphere(name: string, options: {
            radius?: number;
            flat?: boolean;
            subdivisions?: number;
            sideOrientation?: number;
            updatable?: boolean;
        }, scene: Scene): Mesh;
        /**
         * Creates a decal mesh.
         * Please consider using the same method from the MeshBuilder class instead.
         * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal.
         * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates.
         * The parameter `normal` (Vector3, default Vector3.Up) sets the normal of the mesh where the decal is applied onto in World coordinates.
         * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling.
         * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal.
         */
        static CreateDecal(name: string, sourceMesh: AbstractMesh, position: Vector3, normal: Vector3, size: Vector3, angle: number): Mesh;
        /**
         * @returns original positions used for CPU skinning.  Useful for integrating Morphing with skeletons in same mesh.
         */
        setPositionsForCPUSkinning(): Float32Array;
        /**
         * @returns original normals used for CPU skinning.  Useful for integrating Morphing with skeletons in same mesh.
         */
        setNormalsForCPUSkinning(): Float32Array;
        /**
         * Updates the vertex buffer by applying transformation from the bones.
         * Returns the Mesh.
         *
         * @param {skeleton} skeleton to apply
         */
        applySkeleton(skeleton: Skeleton): Mesh;
        /**
         * Returns an object `{min:` Vector3`, max:` Vector3`}`
         * This min and max Vector3 are the minimum and maximum vectors of each mesh bounding box from the passed array, in the World system
         */
        static MinMax(meshes: AbstractMesh[]): {
            min: Vector3;
            max: Vector3;
        };
        /**
         * Returns a Vector3, the center of the `{min:` Vector3`, max:` Vector3`}` or the center of MinMax vector3 computed from a mesh array.
         */
        static Center(meshesOrMinMaxVector: {
            min: Vector3;
            max: Vector3;
        } | AbstractMesh[]): Vector3;
        /**
         * Merge the array of meshes into a single mesh for performance reasons.
         * @param {Array<Mesh>} meshes - The vertices source.  They should all be of the same material.  Entries can empty
         * @param {boolean} disposeSource - When true (default), dispose of the vertices from the source meshes
         * @param {boolean} allow32BitsIndices - When the sum of the vertices > 64k, this must be set to true.
         * @param {Mesh} meshSubclass - When set, vertices inserted into this Mesh.  Meshes can then be merged into a Mesh sub-class.
         * @param {boolean} subdivideWithSubMeshes - When true (false default), subdivide mesh to his subMesh array with meshes source.
         */
        static MergeMeshes(meshes: Array<Mesh>, disposeSource?: boolean, allow32BitsIndices?: boolean, meshSubclass?: Mesh, subdivideWithSubMeshes?: boolean): Nullable<Mesh>;
    }
}

declare module BABYLON {
    /**
     * Define an interface for all classes that will get and set the data on vertices
     */
    interface IGetSetVerticesData {
        isVerticesDataPresent(kind: string): boolean;
        getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray>;
        getIndices(copyWhenShared?: boolean): Nullable<IndicesArray>;
        setVerticesData(kind: string, data: FloatArray, updatable: boolean): void;
        updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): void;
        setIndices(indices: IndicesArray, totalVertices: Nullable<number>, updatable?: boolean): void;
    }
    /**
     * This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance
     */
    class VertexData {
        /**
         * An array of the x, y, z position of each vertex  [...., x, y, z, .....]
         */
        positions: Nullable<FloatArray>;
        /**
         * An array of the x, y, z normal vector of each vertex  [...., x, y, z, .....]
         */
        normals: Nullable<FloatArray>;
        /**
         * An array of the x, y, z tangent vector of each vertex  [...., x, y, z, .....]
         */
        tangents: Nullable<FloatArray>;
        /**
         * An array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
         */
        uvs: Nullable<FloatArray>;
        /**
         * A second array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
         */
        uvs2: Nullable<FloatArray>;
        /**
         * A third array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
         */
        uvs3: Nullable<FloatArray>;
        /**
         * A fourth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
         */
        uvs4: Nullable<FloatArray>;
        /**
         * A fifth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
         */
        uvs5: Nullable<FloatArray>;
        /**
         * A sixth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
         */
        uvs6: Nullable<FloatArray>;
        /**
         * An array of the r, g, b, a, color of each vertex  [...., r, g, b, a, .....]
         */
        colors: Nullable<FloatArray>;
        /**
         * An array containing the list of indices to the array of matrices produced by bones, each vertex have up to 4 indices (8 if the matricesIndicesExtra is set).
         */
        matricesIndices: Nullable<FloatArray>;
        /**
         * An array containing the list of weights defining the weight of each indexed matrix in the final computation
         */
        matricesWeights: Nullable<FloatArray>;
        /**
         * An array extending the number of possible indices
         */
        matricesIndicesExtra: Nullable<FloatArray>;
        /**
         * An array extending the number of possible weights when the number of indices is extended
         */
        matricesWeightsExtra: Nullable<FloatArray>;
        /**
         * An array of i, j, k the three vertex indices required for each triangular facet  [...., i, j, k .....]
         */
        indices: Nullable<IndicesArray>;
        /**
         * Uses the passed data array to set the set the values for the specified kind of data
         * @param data a linear array of floating numbers
         * @param kind the type of data that is being set, eg positions, colors etc
         */
        set(data: FloatArray, kind: string): void;
        /**
         * Associates the vertexData to the passed Mesh.
         * Sets it as updatable or not (default `false`)
         * @param mesh the mesh the vertexData is applied to
         * @param updatable when used and having the value true allows new data to update the vertexData
         * @returns the VertexData
         */
        applyToMesh(mesh: Mesh, updatable?: boolean): VertexData;
        /**
         * Associates the vertexData to the passed Geometry.
         * Sets it as updatable or not (default `false`)
         * @param geometry the geometry the vertexData is applied to
         * @param updatable when used and having the value true allows new data to update the vertexData
         * @returns VertexData
         */
        applyToGeometry(geometry: Geometry, updatable?: boolean): VertexData;
        /**
         * Updates the associated mesh
         * @param mesh the mesh to be updated
         * @param updateExtends when true the mesh BoundingInfo will be renewed when and if position kind is updated, optional with default false
         * @param makeItUnique when true, and when and if position kind is updated, a new global geometry will be  created from these positions and set to the mesh, optional with default false
         * @returns VertexData
         */
        updateMesh(mesh: Mesh, updateExtends?: boolean, makeItUnique?: boolean): VertexData;
        /**
         * Updates the associated geometry
         * @param geometry the geometry to be updated
         * @param updateExtends when true BoundingInfo will be renewed when and if position kind is updated, optional with default false
         * @param makeItUnique when true, and when and if position kind is updated, a new global geometry will be created from these positions and set to the mesh, optional with default false
         * @returns VertexData.
         */
        updateGeometry(geometry: Geometry, updateExtends?: boolean, makeItUnique?: boolean): VertexData;
        private _applyTo(meshOrGeometry, updatable?);
        private _update(meshOrGeometry, updateExtends?, makeItUnique?);
        /**
         * Transforms each position and each normal of the vertexData according to the passed Matrix
         * @param matrix the transforming matrix
         * @returns the VertexData
         */
        transform(matrix: Matrix): VertexData;
        /**
         * Merges the passed VertexData into the current one
         * @param other the VertexData to be merged into the current one
         * @returns the modified VertexData
         */
        merge(other: VertexData): VertexData;
        private _mergeElement(source, other);
        private _validate();
        /**
         * Serializes the VertexData
         * @returns a serialized object
         */
        serialize(): any;
        /**
         * Extracts the vertexData from a mesh
         * @param mesh the mesh from which to extract the VertexData
         * @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false
         * @param forceCopy indicating that the VertexData must be cloned, optional, default false
         * @returns the object VertexData associated to the passed mesh
         */
        static ExtractFromMesh(mesh: Mesh, copyWhenShared?: boolean, forceCopy?: boolean): VertexData;
        /**
         * Extracts the vertexData from the geometry
         * @param geometry the geometry from which to extract the VertexData
         * @param copyWhenShared defines if the VertexData must be cloned when the geometrty is shared between multiple meshes, optional, default false
         * @param forceCopy indicating that the VertexData must be cloned, optional, default false
         * @returns the object VertexData associated to the passed mesh
         */
        static ExtractFromGeometry(geometry: Geometry, copyWhenShared?: boolean, forceCopy?: boolean): VertexData;
        private static _ExtractFrom(meshOrGeometry, copyWhenShared?, forceCopy?);
        /**
         * Creates the VertexData for a Ribbon
         * @param options an object used to set the following optional parameters for the ribbon, required but can be empty
          * * pathArray array of paths, each of which an array of successive Vector3
          * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false
          * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false
          * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length
          * * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
          * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
          * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
          * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false
          * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional
          * * colors a linear array, of length 4 * number of vertices, of custom color values, optional
         * @returns the VertexData of the ribbon
         */
        static CreateRibbon(options: {
            pathArray: Vector3[][];
            closeArray?: boolean;
            closePath?: boolean;
            offset?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            invertUV?: boolean;
            uvs?: Vector2[];
            colors?: Color4[];
        }): VertexData;
        /**
         * Creates the VertexData for a box
         * @param options an object used to set the following optional parameters for the box, required but can be empty
          * * size sets the width, height and depth of the box to the value of size, optional default 1
          * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size
          * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size
          * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size
          * * faceUV an array of 6 Vector4 elements used to set different images to each box side
          * * faceColors an array of 6 Color3 elements used to set different colors to each box side
          * * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
          * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
          * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @returns the VertexData of the box
         */
        static CreateBox(options: {
            size?: number;
            width?: number;
            height?: number;
            depth?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }): VertexData;
        /**
         * Creates the VertexData for an ellipsoid, defaults to a sphere
         * @param options an object used to set the following optional parameters for the box, required but can be empty
          * * segments sets the number of horizontal strips optional, default 32
          * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1
          * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter
          * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter
          * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter
          * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1
          * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1
          * * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
          * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
          * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @returns the VertexData of the ellipsoid
         */
        static CreateSphere(options: {
            segments?: number;
            diameter?: number;
            diameterX?: number;
            diameterY?: number;
            diameterZ?: number;
            arc?: number;
            slice?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }): VertexData;
        /**
         * Creates the VertexData for a cylinder, cone or prism
         * @param options an object used to set the following optional parameters for the box, required but can be empty
          * * height sets the height (y direction) of the cylinder, optional, default 2
          * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter
          * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter
          * * diameter sets the diameter of the top and bottom of the cone, optional default 1
          * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24
          * * subdivisions` the number of rings along the cylinder height, optional, default 1
          * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1
          * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
          * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
          * * hasRings when true makes each subdivision independantly treated as a face for faceUV and faceColors, optional, default false
          * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake
          * * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
          * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
          * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @returns the VertexData of the cylinder, cone or prism
         */
        static CreateCylinder(options: {
            height?: number;
            diameterTop?: number;
            diameterBottom?: number;
            diameter?: number;
            tessellation?: number;
            subdivisions?: number;
            arc?: number;
            faceColors?: Color4[];
            faceUV?: Vector4[];
            hasRings?: boolean;
            enclose?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }): VertexData;
        /**
         * Creates the VertexData for a torus
         * @param options an object used to set the following optional parameters for the box, required but can be empty
          * * diameter the diameter of the torus, optional default 1
          * * thickness the diameter of the tube forming the torus, optional default 0.5
          * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24
          * * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
          * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
          * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @returns the VertexData of the torus
         */
        static CreateTorus(options: {
            diameter?: number;
            thickness?: number;
            tessellation?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }): VertexData;
        /**
         * Creates the VertexData of the LineSystem
         * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty
         *  - lines an array of lines, each line being an array of successive Vector3
         *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point
         * @returns the VertexData of the LineSystem
         */
        static CreateLineSystem(options: {
            lines: Vector3[][];
            colors?: Nullable<Color4[][]>;
        }): VertexData;
        /**
         * Create the VertexData for a DashedLines
         * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty
         *  - points an array successive Vector3
         *  - dashSize the size of the dashes relative to the dash number, optional, default 3
         *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1
         *  - dashNb the intended total number of dashes, optional, default 200
         * @returns the VertexData for the DashedLines
         */
        static CreateDashedLines(options: {
            points: Vector3[];
            dashSize?: number;
            gapSize?: number;
            dashNb?: number;
        }): VertexData;
        /**
         * Creates the VertexData for a Ground
         * @param options an object used to set the following optional parameters for the Ground, required but can be empty
         *  - width the width (x direction) of the ground, optional, default 1
         *  - height the height (z direction) of the ground, optional, default 1
         *  - subdivisions the number of subdivisions per side, optional, default 1
         * @returns the VertexData of the Ground
         */
        static CreateGround(options: {
            width?: number;
            height?: number;
            subdivisions?: number;
            subdivisionsX?: number;
            subdivisionsY?: number;
        }): VertexData;
        /**
         * Creates the VertexData for a TiledGround by subdividing the ground into tiles
         * @param options an object used to set the following optional parameters for the Ground, required but can be empty
          * * xmin the ground minimum X coordinate, optional, default -1
          * * zmin the ground minimum Z coordinate, optional, default -1
          * * xmax the ground maximum X coordinate, optional, default 1
          * * zmax the ground maximum Z coordinate, optional, default 1
          * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}
          * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}
         * @returns the VertexData of the TiledGround
         */
        static CreateTiledGround(options: {
            xmin: number;
            zmin: number;
            xmax: number;
            zmax: number;
            subdivisions?: {
                w: number;
                h: number;
            };
            precision?: {
                w: number;
                h: number;
            };
        }): VertexData;
        /**
         * Creates the VertexData of the Ground designed from a heightmap
         * @param options an object used to set the following parameters for the Ground, required and provided by MeshBuilder.CreateGroundFromHeightMap
          * * width the width (x direction) of the ground
          * * height the height (z direction) of the ground
          * * subdivisions the number of subdivisions per side
          * * minHeight the minimum altitude on the ground, optional, default 0
          * * maxHeight the maximum altitude on the ground, optional default 1
          * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)
          * * buffer the array holding the image color data
          * * bufferWidth the width of image
          * * bufferHeight the height of image
         * @returns the VertexData of the Ground designed from a heightmap
         */
        static CreateGroundFromHeightMap(options: {
            width: number;
            height: number;
            subdivisions: number;
            minHeight: number;
            maxHeight: number;
            colorFilter: Color3;
            buffer: Uint8Array;
            bufferWidth: number;
            bufferHeight: number;
        }): VertexData;
        /**
         * Creates the VertexData for a Plane
         * @param options an object used to set the following optional parameters for the plane, required but can be empty
          * * size sets the width and height of the plane to the value of size, optional default 1
          * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size
          * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size
          * * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
          * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
          * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @returns the VertexData of the box
         */
        static CreatePlane(options: {
            size?: number;
            width?: number;
            height?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }): VertexData;
        /**
         * Creates the VertexData of the Disc or regular Polygon
         * @param options an object used to set the following optional parameters for the disc, required but can be empty
          * * radius the radius of the disc, optional default 0.5
          * * tessellation the number of polygon sides, optional, default 64
          * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1
          * * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
          * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
          * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @returns the VertexData of the box
         */
        static CreateDisc(options: {
            radius?: number;
            tessellation?: number;
            arc?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }): VertexData;
        /**
         * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()
         * All parameters are provided by MeshBuilder.CreatePolygon as needed
         * @param polygon a mesh built from polygonTriangulation.build()
         * @param sideOrientation takes the values BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
         * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
         * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
         * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @returns the VertexData of the Polygon
         */
        static CreatePolygon(polygon: Mesh, sideOrientation: number, fUV?: Vector4[], fColors?: Color4[], frontUVs?: Vector4, backUVs?: Vector4): VertexData;
        /**
         * Creates the VertexData of the IcoSphere
         * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty
          * * radius the radius of the IcoSphere, optional default 1
          * * radiusX allows stretching in the x direction, optional, default radius
          * * radiusY allows stretching in the y direction, optional, default radius
          * * radiusZ allows stretching in the z direction, optional, default radius
          * * flat when true creates a flat shaded mesh, optional, default true
          * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4
          * * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
          * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
          * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @returns the VertexData of the IcoSphere
         */
        static CreateIcoSphere(options: {
            radius?: number;
            radiusX?: number;
            radiusY?: number;
            radiusZ?: number;
            flat?: boolean;
            subdivisions?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }): VertexData;
        /**
         * Creates the VertexData for a Polyhedron
         * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty
         * * type provided types are:
         *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)
         *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)
         * * size the size of the IcoSphere, optional default 1
         * * sizeX allows stretching in the x direction, optional, default size
         * * sizeY allows stretching in the y direction, optional, default size
         * * sizeZ allows stretching in the z direction, optional, default size
         * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor
         * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
         * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
         * * flat when true creates a flat shaded mesh, optional, default true
         * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4
         * * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
         * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @returns the VertexData of the Polyhedron
         */
        static CreatePolyhedron(options: {
            type?: number;
            size?: number;
            sizeX?: number;
            sizeY?: number;
            sizeZ?: number;
            custom?: any;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            flat?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }): VertexData;
        /**
         * Creates the VertexData for a TorusKnot
         * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty
          * * radius the radius of the torus knot, optional, default 2
          * * tube the thickness of the tube, optional, default 0.5
          * * radialSegments the number of sides on each tube segments, optional, default 32
          * * tubularSegments the number of tubes to decompose the knot into, optional, default 32
          * * p the number of windings around the z axis, optional,  default 2
          * * q the number of windings around the x axis, optional,  default 3
          * * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
          * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
          * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
         * @returns the VertexData of the Torus Knot
         */
        static CreateTorusKnot(options: {
            radius?: number;
            tube?: number;
            radialSegments?: number;
            tubularSegments?: number;
            p?: number;
            q?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }): VertexData;
        /**
         * Compute normals for given positions and indices
         * @param positions an array of vertex positions, [...., x, y, z, ......]
         * @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]
         * @param normals an array of vertex normals, [...., x, y, z, ......]
         * @param options an object used to set the following optional parameters for the TorusKnot, optional
          * * facetNormals : optional array of facet normals (vector3)
          * * facetPositions : optional array of facet positions (vector3)
          * * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation
          * * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation
          * * bInfo : optional bounding info, required for facetPartitioning computation
          * * bbSize : optional bounding box size data, required for facetPartitioning computation
          * * subDiv : optional partitioning data about subdivsions on  each axis (int), required for facetPartitioning computation
          * * useRightHandedSystem: optional boolean to for right handed system computation
          * * depthSort : optional boolean to enable the facet depth sort computation
          * * distanceTo : optional Vector3 to compute the facet depth from this location
          * * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location
         */
        static ComputeNormals(positions: any, indices: any, normals: any, options?: {
            facetNormals?: any;
            facetPositions?: any;
            facetPartitioning?: any;
            ratio?: number;
            bInfo?: any;
            bbSize?: Vector3;
            subDiv?: any;
            useRightHandedSystem?: boolean;
            depthSort?: boolean;
            distanceTo?: Vector3;
            depthSortedFacets?: any;
        }): void;
        private static _ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs?, backUVs?);
        /**
         * Applies VertexData created from the imported parameters to the geometry
         * @param parsedVertexData the parsed data from an imported file
         * @param geometry the geometry to apply the VertexData to
         */
        static ImportVertexData(parsedVertexData: any, geometry: Geometry): void;
    }
}

declare module BABYLON {
    /**
     * Class containing static functions to help procedurally build meshes
     */
    class MeshBuilder {
        private static updateSideOrientation(orientation?);
        /**
         * Creates a box mesh
         * * The parameter `size` sets the size (float) of each box side (default 1)
         * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value than `size`)
         * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)
         * * Please read this tutorial : http://doc.babylonjs.com/tutorials/CreateBox_Per_Face_Textures_And_Colors
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @see http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#box
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the box mesh
         */
        static CreateBox(name: string, options: {
            size?: number;
            width?: number;
            height?: number;
            depth?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            updatable?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates a sphere mesh
         * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)
         * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value than `diameter`)
         * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)
         * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio
         * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the sphere mesh
         * @see http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#sphere
         */
        static CreateSphere(name: string, options: {
            segments?: number;
            diameter?: number;
            diameterX?: number;
            diameterY?: number;
            diameterZ?: number;
            arc?: number;
            slice?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            updatable?: boolean;
        }, scene: any): Mesh;
        /**
         * Creates a plane polygonal mesh.  By default, this is a disc
         * * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)
         * * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc
         * * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the plane polygonal mesh
         * @see http://doc.babylonjs.com/how_to/set_shapes#disc-or-regular-polygon
         */
        static CreateDisc(name: string, options: {
            radius?: number;
            tessellation?: number;
            arc?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided
         * * The parameter `radius` sets the radius size (float) of the icosphere (default 1)
         * * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value than `radius`)
         * * The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size
         * * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the icosahedron mesh
         * @see http://doc.babylonjs.com/how_to/polyhedra_shapes#icosphere
         */
        static CreateIcoSphere(name: string, options: {
            radius?: number;
            radiusX?: number;
            radiusY?: number;
            radiusZ?: number;
            flat?: boolean;
            subdivisions?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            updatable?: boolean;
        }, scene: Scene): Mesh;
        /**
         * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters
         * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry
         * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array
         * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array
         * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path
         * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11
         * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#ribbon
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
         * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones
         * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values
         * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry
         * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the ribbon mesh
         * @see http://doc.babylonjs.com/tutorials/Ribbon_Tutorial
         * @see http://doc.babylonjs.com/tutorials/Parametric_Shapes
         */
        static CreateRibbon(name: string, options: {
            pathArray: Vector3[][];
            closeArray?: boolean;
            closePath?: boolean;
            offset?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            instance?: Mesh;
            invertUV?: boolean;
            uvs?: Vector2[];
            colors?: Color4[];
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates a cylinder or a cone mesh
         * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).
         * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).
         * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter "diameterBottom" can't be zero.
         * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.
         * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).
         * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.
         * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.
         * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.
         * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).
         * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3
         * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7
         * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17
         * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.
         * * If `enclose` is false, a ring surface is one element.
         * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.
         * * Example how to set colors and textures on a sliced cylinder : http://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the cylinder mesh
         * @see http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#cylinder-or-cone
         */
        static CreateCylinder(name: string, options: {
            height?: number;
            diameterTop?: number;
            diameterBottom?: number;
            diameter?: number;
            tessellation?: number;
            subdivisions?: number;
            arc?: number;
            faceColors?: Color4[];
            faceUV?: Vector4[];
            updatable?: boolean;
            hasRings?: boolean;
            enclose?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }, scene: any): Mesh;
        /**
         * Creates a torus mesh
         * * The parameter `diameter` sets the diameter size (float) of the torus (default 1)
         * * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)
         * * The parameter `tessellation` sets the number of torus sides (postive integer, default 16)
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the torus mesh
         * @see http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#torus
         */
        static CreateTorus(name: string, options: {
            diameter?: number;
            thickness?: number;
            tessellation?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }, scene: any): Mesh;
        /**
         * Creates a torus knot mesh
         * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)
         * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)
         * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)
         * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the torus knot mesh
         * @see  http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#torus-knot
         */
        static CreateTorusKnot(name: string, options: {
            radius?: number;
            tube?: number;
            radialSegments?: number;
            tubularSegments?: number;
            p?: number;
            q?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }, scene: any): Mesh;
        /**
         * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh
         * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter
         * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function
         * * The parameter `lines` is an array of lines, each line being an array of successive Vector3
         * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter
         * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point
         * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)
         * * Updating a simple Line mesh, you just need to update every line in the `lines` array : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines
         * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @see http://doc.babylonjs.com/how_to/parametric_shapes#line-system
         * @param name defines the name of the new line system
         * @param options defines the options used to create the line system
         * @param scene defines the hosting scene
         * @returns a new line system mesh
         */
        static CreateLineSystem(name: string, options: {
            lines: Vector3[][];
            updatable?: boolean;
            instance?: Nullable<LinesMesh>;
            colors?: Nullable<Color4[][]>;
            useVertexAlpha?: boolean;
        }, scene: Nullable<Scene>): LinesMesh;
        /**
         * Creates a line mesh
         * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
         * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
         * * The parameter `points` is an array successive Vector3
         * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines
         * * The optional parameter `colors` is an array of successive Color4, one per line point
         * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)
         * * When updating an instance, remember that only point positions can change, not the number of points
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @see http://doc.babylonjs.com/how_to/parametric_shapes#lines
         * @param name defines the name of the new line system
         * @param options defines the options used to create the line system
         * @param scene defines the hosting scene
         * @returns a new line mesh
         */
        static CreateLines(name: string, options: {
            points: Vector3[];
            updatable?: boolean;
            instance?: Nullable<LinesMesh>;
            colors?: Color4[];
            useVertexAlpha?: boolean;
        }, scene?: Nullable<Scene>): LinesMesh;
        /**
         * Creates a dashed line mesh
         * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
         * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
         * * The parameter `points` is an array successive Vector3
         * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)
         * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)
         * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)
         * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines
         * * When updating an instance, remember that only point positions can change, not the number of points
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the dashed line mesh
         * @see http://doc.babylonjs.com/how_to/parametric_shapes#dashed-lines
         */
        static CreateDashedLines(name: string, options: {
            points: Vector3[];
            dashSize?: number;
            gapSize?: number;
            dashNb?: number;
            updatable?: boolean;
            instance?: LinesMesh;
        }, scene?: Nullable<Scene>): LinesMesh;
        /**
         * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
         * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
         * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
         * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.
         * * The parameter `scale` (float, default 1) is the value to scale the shape.
         * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
         * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#extruded-shape
         * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the extruded shape mesh
         * @see http://doc.babylonjs.com/tutorials/Parametric_Shapes
         * @see http://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
         * @see http://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
         */
        static ExtrudeShape(name: string, options: {
            shape: Vector3[];
            path: Vector3[];
            scale?: number;
            rotation?: number;
            cap?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            instance?: Mesh;
            invertUV?: boolean;
        }, scene?: Nullable<Scene>): Mesh;
        /**
         * Creates an custom extruded shape mesh.
         * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
         * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
         * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
         * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path
         * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.
         * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path
         * * It must returns a float value that will be the scale value applied to the shape on each path point
         * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`
         * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`
         * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
         * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#extruded-shape
         * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the custom extruded shape mesh
         * @see http://doc.babylonjs.com/how_to/parametric_shapes#custom-extruded-shapes
         * @see http://doc.babylonjs.com/tutorials/Parametric_Shapes
         * @see http://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
         */
        static ExtrudeShapeCustom(name: string, options: {
            shape: Vector3[];
            path: Vector3[];
            scaleFunction?: any;
            rotationFunction?: any;
            ribbonCloseArray?: boolean;
            ribbonClosePath?: boolean;
            cap?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            instance?: Mesh;
            invertUV?: boolean;
        }, scene: Scene): Mesh;
        /**
         * Creates lathe mesh.
         * The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe
         * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero
         * * The parameter `radius` (positive float, default 1) is the radius value of the lathe
         * * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe
         * * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape
         * * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter "arc"
         * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the lathe mesh
         * @see http://doc.babylonjs.com/how_to/parametric_shapes#lathe
         */
        static CreateLathe(name: string, options: {
            shape: Vector3[];
            radius?: number;
            tessellation?: number;
            arc?: number;
            closed?: boolean;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            cap?: number;
            invertUV?: boolean;
        }, scene: Scene): Mesh;
        /**
         * Creates a plane mesh
         * * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)
         * * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value than `size`)
         * * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the plane mesh
         * @see http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#plane
         */
        static CreatePlane(name: string, options: {
            size?: number;
            width?: number;
            height?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            updatable?: boolean;
            sourcePlane?: Plane;
        }, scene: Scene): Mesh;
        /**
         * Creates a ground mesh
         * * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground
         * * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the ground mesh
         * @see http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#plane
         */
        static CreateGround(name: string, options: {
            width?: number;
            height?: number;
            subdivisions?: number;
            subdivisionsX?: number;
            subdivisionsY?: number;
            updatable?: boolean;
        }, scene: any): Mesh;
        /**
         * Creates a tiled ground mesh
         * * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates
         * * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates
         * * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile
         * * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the tiled ground mesh
         * @see http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#tiled-ground
         */
        static CreateTiledGround(name: string, options: {
            xmin: number;
            zmin: number;
            xmax: number;
            zmax: number;
            subdivisions?: {
                w: number;
                h: number;
            };
            precision?: {
                w: number;
                h: number;
            };
            updatable?: boolean;
        }, scene: Scene): Mesh;
        /**
         * Creates a ground mesh from a height map
         * * The parameter `url` sets the URL of the height map image resource.
         * * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.
         * * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.
         * * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.
         * * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.
         * * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.
         * * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
         * @param name defines the name of the mesh
         * @param url defines the url to the height map
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the ground mesh
         * @see http://doc.babylonjs.com/babylon101/height_map
         * @see http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#ground-from-a-height-map
         */
        static CreateGroundFromHeightMap(name: string, url: string, options: {
            width?: number;
            height?: number;
            subdivisions?: number;
            minHeight?: number;
            maxHeight?: number;
            colorFilter?: Color3;
            updatable?: boolean;
            onReady?: (mesh: GroundMesh) => void;
        }, scene: Scene): GroundMesh;
        /**
         * Creates a polygon mesh
         * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh
         * * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors
         * * You can set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)
         * * Remember you can only change the shape positions, not their number when updating a polygon
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the polygon mesh
         */
        static CreatePolygon(name: string, options: {
            shape: Vector3[];
            holes?: Vector3[][];
            depth?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }, scene: Scene): Mesh;
        /**
         * Creates an extruded polygon mesh, with depth in the Y direction.
         * * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)
         * @see http://doc.babylonjs.com/tutorials/CreateBox_Per_Face_Textures_And_Colors
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the polygon mesh
         */
        static ExtrudePolygon(name: string, options: {
            shape: Vector3[];
            holes?: Vector3[][];
            depth?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }, scene: Scene): Mesh;
        /**
         * Creates a tube mesh.
         * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters
         * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube
         * * The parameter `radius` (positive float, default 1) sets the tube radius size
         * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface
         * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`
         * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)
         * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc
         * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
         * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#tube
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the tube mesh
         * @see http://doc.babylonjs.com/tutorials/Parametric_Shapes
         * @see http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#tube
         */
        static CreateTube(name: string, options: {
            path: Vector3[];
            radius?: number;
            tessellation?: number;
            radiusFunction?: {
                (i: number, distance: number): number;
            };
            cap?: number;
            arc?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            instance?: Mesh;
            invertUV?: boolean;
        }, scene: Scene): Mesh;
        /**
         * Creates a polyhedron mesh
         * * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type
         * * The parameter `size` (positive float, default 1) sets the polygon size
         * * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)
         * * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`
         * * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron
         * * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)
         * * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : http://doc.babylonjs.com/tutorials/CreateBox_Per_Face_Textures_And_Colors
         * * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored
         * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
         * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
         * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
         * @param name defines the name of the mesh
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the polyhedron mesh
         * @see http://doc.babylonjs.com/how_to/polyhedra_shapes
         */
        static CreatePolyhedron(name: string, options: {
            type?: number;
            size?: number;
            sizeX?: number;
            sizeY?: number;
            sizeZ?: number;
            custom?: any;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            flat?: boolean;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }, scene: Scene): Mesh;
        /**
         * Creates a decal mesh.
         * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal
         * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates
         * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates
         * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling
         * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal
         * @param name defines the name of the mesh
         * @param sourceMesh defines the mesh where the decal must be applied
         * @param options defines the options used to create the mesh
         * @param scene defines the hosting scene
         * @returns the decal mesh
         * @see http://doc.babylonjs.com/how_to/decals
         */
        static CreateDecal(name: string, sourceMesh: AbstractMesh, options: {
            position?: Vector3;
            normal?: Vector3;
            size?: Vector3;
            angle?: number;
        }): Mesh;
        private static _ExtrudeShapeGeneric(name, shape, curve, scale, rotation, scaleFunction, rotateFunction, rbCA, rbCP, cap, custom, scene, updtbl, side, instance, invertUV, frontUVs, backUVs);
    }
}

declare module BABYLON {
    class MeshLODLevel {
        distance: number;
        mesh: Mesh;
        constructor(distance: number, mesh: Mesh);
    }
}

declare module BABYLON {
    /**
     * A simplifier interface for future simplification implementations.
     */
    interface ISimplifier {
        /**
         * Simplification of a given mesh according to the given settings.
         * Since this requires computation, it is assumed that the function runs async.
         * @param settings The settings of the simplification, including quality and distance
         * @param successCallback A callback that will be called after the mesh was simplified.
         * @param errorCallback in case of an error, this callback will be called. optional.
         */
        simplify(settings: ISimplificationSettings, successCallback: (simplifiedMeshes: Mesh) => void, errorCallback?: () => void): void;
    }
    /**
     * Expected simplification settings.
     * Quality should be between 0 and 1 (1 being 100%, 0 being 0%);
     */
    interface ISimplificationSettings {
        quality: number;
        distance: number;
        optimizeMesh?: boolean;
    }
    class SimplificationSettings implements ISimplificationSettings {
        quality: number;
        distance: number;
        optimizeMesh: boolean | undefined;
        constructor(quality: number, distance: number, optimizeMesh?: boolean | undefined);
    }
    interface ISimplificationTask {
        settings: Array<ISimplificationSettings>;
        simplificationType: SimplificationType;
        mesh: Mesh;
        successCallback?: () => void;
        parallelProcessing: boolean;
    }
    class SimplificationQueue {
        private _simplificationArray;
        running: boolean;
        constructor();
        addTask(task: ISimplificationTask): void;
        executeNext(): void;
        runSimplification(task: ISimplificationTask): void;
        private getSimplifier(task);
    }
    /**
     * The implemented types of simplification
     * At the moment only Quadratic Error Decimation is implemented
     */
    enum SimplificationType {
        /** Quadratic error decimation */
        QUADRATIC = 0,
    }
    class DecimationTriangle {
        vertices: Array<DecimationVertex>;
        normal: Vector3;
        error: Array<number>;
        deleted: boolean;
        isDirty: boolean;
        borderFactor: number;
        deletePending: boolean;
        originalOffset: number;
        constructor(vertices: Array<DecimationVertex>);
    }
    class DecimationVertex {
        position: Vector3;
        id: number;
        q: QuadraticMatrix;
        isBorder: boolean;
        triangleStart: number;
        triangleCount: number;
        originalOffsets: Array<number>;
        constructor(position: Vector3, id: number);
        updatePosition(newPosition: Vector3): void;
    }
    class QuadraticMatrix {
        data: Array<number>;
        constructor(data?: Array<number>);
        det(a11: number, a12: number, a13: number, a21: number, a22: number, a23: number, a31: number, a32: number, a33: number): number;
        addInPlace(matrix: QuadraticMatrix): void;
        addArrayInPlace(data: Array<number>): void;
        add(matrix: QuadraticMatrix): QuadraticMatrix;
        static FromData(a: number, b: number, c: number, d: number): QuadraticMatrix;
        static DataFromNumbers(a: number, b: number, c: number, d: number): number[];
    }
    class Reference {
        vertexId: number;
        triangleId: number;
        constructor(vertexId: number, triangleId: number);
    }
    /**
     * An implementation of the Quadratic Error simplification algorithm.
     * Original paper : http://www1.cs.columbia.edu/~cs4162/html05s/garland97.pdf
     * Ported mostly from QSlim and http://voxels.blogspot.de/2014/05/quadric-mesh-simplification-with-source.html to babylon JS
     * @author RaananW
     */
    class QuadraticErrorSimplification implements ISimplifier {
        private _mesh;
        private triangles;
        private vertices;
        private references;
        private _reconstructedMesh;
        syncIterations: number;
        aggressiveness: number;
        decimationIterations: number;
        boundingBoxEpsilon: number;
        constructor(_mesh: Mesh);
        simplify(settings: ISimplificationSettings, successCallback: (simplifiedMesh: Mesh) => void): void;
        private runDecimation(settings, submeshIndex, successCallback);
        private initWithMesh(submeshIndex, callback, optimizeMesh?);
        private init(callback);
        private reconstructMesh(submeshIndex);
        private initDecimatedMesh();
        private isFlipped(vertex1, vertex2, point, deletedArray, borderFactor, delTr);
        private updateTriangles(origVertex, vertex, deletedArray, deletedTriangles);
        private identifyBorder();
        private updateMesh(identifyBorders?);
        private vertexError(q, point);
        private calculateError(vertex1, vertex2, pointResult?, normalResult?, uvResult?, colorResult?);
    }
}

declare module BABYLON {
    class Polygon {
        static Rectangle(xmin: number, ymin: number, xmax: number, ymax: number): Vector2[];
        static Circle(radius: number, cx?: number, cy?: number, numberOfSides?: number): Vector2[];
        static Parse(input: string): Vector2[];
        static StartingAt(x: number, y: number): Path2;
    }
    class PolygonMeshBuilder {
        private _points;
        private _outlinepoints;
        private _holes;
        private _name;
        private _scene;
        private _epoints;
        private _eholes;
        private _addToepoint(points);
        constructor(name: string, contours: Path2, scene: Scene);
        constructor(name: string, contours: Vector2[], scene: Scene);
        addHole(hole: Vector2[]): PolygonMeshBuilder;
        build(updatable?: boolean, depth?: number): Mesh;
        private addSide(positions, normals, uvs, indices, bounds, points, depth, flip);
    }
}

declare module BABYLON {
    class BaseSubMesh {
        _materialDefines: Nullable<MaterialDefines>;
        _materialEffect: Nullable<Effect>;
        readonly effect: Nullable<Effect>;
        setEffect(effect: Nullable<Effect>, defines?: Nullable<MaterialDefines>): void;
    }
    class SubMesh extends BaseSubMesh implements ICullable {
        materialIndex: number;
        verticesStart: number;
        verticesCount: number;
        indexStart: number;
        indexCount: number;
        linesIndexCount: number;
        private _mesh;
        private _renderingMesh;
        private _boundingInfo;
        private _linesIndexBuffer;
        _lastColliderWorldVertices: Nullable<Vector3[]>;
        _trianglePlanes: Plane[];
        _lastColliderTransformMatrix: Matrix;
        _renderId: number;
        _alphaIndex: number;
        _distanceToCamera: number;
        _id: number;
        private _currentMaterial;
        static AddToMesh(materialIndex: number, verticesStart: number, verticesCount: number, indexStart: number, indexCount: number, mesh: AbstractMesh, renderingMesh?: Mesh, createBoundingBox?: boolean): SubMesh;
        constructor(materialIndex: number, verticesStart: number, verticesCount: number, indexStart: number, indexCount: number, mesh: AbstractMesh, renderingMesh?: Mesh, createBoundingBox?: boolean);
        readonly IsGlobal: boolean;
        /**
         * Returns the submesh BoudingInfo object.
         */
        getBoundingInfo(): BoundingInfo;
        /**
         * Sets the submesh BoundingInfo.
         * Return the SubMesh.
         */
        setBoundingInfo(boundingInfo: BoundingInfo): SubMesh;
        /**
         * Returns the mesh of the current submesh.
         */
        getMesh(): AbstractMesh;
        /**
         * Returns the rendering mesh of the submesh.
         */
        getRenderingMesh(): Mesh;
        /**
         * Returns the submesh material.
         */
        getMaterial(): Nullable<Material>;
        /**
         * Sets a new updated BoundingInfo object to the submesh.
         * Returns the SubMesh.
         */
        refreshBoundingInfo(): SubMesh;
        _checkCollision(collider: Collider): boolean;
        /**
         * Updates the submesh BoundingInfo.
         * Returns the Submesh.
         */
        updateBoundingInfo(world: Matrix): SubMesh;
        /**
         * True is the submesh bounding box intersects the frustum defined by the passed array of planes.
         * Boolean returned.
         */
        isInFrustum(frustumPlanes: Plane[]): boolean;
        /**
         * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes.
         * Boolean returned.
         */
        isCompletelyInFrustum(frustumPlanes: Plane[]): boolean;
        /**
         * Renders the submesh.
         * Returns it.
         */
        render(enableAlphaMode: boolean): SubMesh;
        /**
         * Returns a new Index Buffer.
         * Type returned : WebGLBuffer.
         */
        getLinesIndexBuffer(indices: IndicesArray, engine: Engine): WebGLBuffer;
        /**
         * True is the passed Ray intersects the submesh bounding box.
         * Boolean returned.
         */
        canIntersects(ray: Ray): boolean;
        /**
         * Returns an object IntersectionInfo.
         */
        intersects(ray: Ray, positions: Vector3[], indices: IndicesArray, fastCheck?: boolean): Nullable<IntersectionInfo>;
        _rebuild(): void;
        /**
         * Creates a new Submesh from the passed Mesh.
         */
        clone(newMesh: AbstractMesh, newRenderingMesh?: Mesh): SubMesh;
        /**
         * Disposes the Submesh.
         * Returns nothing.
         */
        dispose(): void;
        /**
         * Creates a new Submesh from the passed parameters :
         * - materialIndex (integer) : the index of the main mesh material.
         * - startIndex (integer) : the index where to start the copy in the mesh indices array.
         * - indexCount (integer) : the number of indices to copy then from the startIndex.
         * - mesh (Mesh) : the main mesh to create the submesh from.
         * - renderingMesh (optional Mesh) : rendering mesh.
         */
        static CreateFromIndices(materialIndex: number, startIndex: number, indexCount: number, mesh: AbstractMesh, renderingMesh?: Mesh): SubMesh;
    }
}

declare module BABYLON {
    class TransformNode extends Node {
        static BILLBOARDMODE_NONE: number;
        static BILLBOARDMODE_X: number;
        static BILLBOARDMODE_Y: number;
        static BILLBOARDMODE_Z: number;
        static BILLBOARDMODE_ALL: number;
        private _forward;
        private _forwardInverted;
        private _up;
        private _right;
        private _rightInverted;
        private _rotation;
        private _rotationQuaternion;
        protected _scaling: Vector3;
        protected _isDirty: boolean;
        private _transformToBoneReferal;
        billboardMode: number;
        scalingDeterminant: number;
        infiniteDistance: boolean;
        position: Vector3;
        _poseMatrix: Matrix;
        private _localWorld;
        _worldMatrix: Matrix;
        _worldMatrixDeterminant: number;
        private _absolutePosition;
        private _pivotMatrix;
        private _pivotMatrixInverse;
        private _postMultiplyPivotMatrix;
        protected _isWorldMatrixFrozen: boolean;
        /**
        * An event triggered after the world matrix is updated
        */
        onAfterWorldMatrixUpdateObservable: Observable<TransformNode>;
        constructor(name: string, scene?: Nullable<Scene>, isPure?: boolean);
        /**
         * Gets a string idenfifying the name of the class
         * @returns "TransformNode" string
         */
        getClassName(): string;
        /**
          * Rotation property : a Vector3 depicting the rotation value in radians around each local axis X, Y, Z.
          * If rotation quaternion is set, this Vector3 will (almost always) be the Zero vector!
          * Default : (0.0, 0.0, 0.0)
          */
        rotation: Vector3;
        /**
         * Scaling property : a Vector3 depicting the mesh scaling along each local axis X, Y, Z.
         * Default : (1.0, 1.0, 1.0)
         */
        /**
         * Scaling property : a Vector3 depicting the mesh scaling along each local axis X, Y, Z.
         * Default : (1.0, 1.0, 1.0)
        */
        scaling: Vector3;
        /**
         * Rotation Quaternion property : this a Quaternion object depicting the mesh rotation by using a unit quaternion.
         * It's null by default.
         * If set, only the rotationQuaternion is then used to compute the mesh rotation and its property `.rotation\ is then ignored and set to (0.0, 0.0, 0.0)
         */
        rotationQuaternion: Nullable<Quaternion>;
        /**
         * The forward direction of that transform in world space.
         */
        readonly forward: Vector3;
        /**
         * The up direction of that transform in world space.
         */
        readonly up: Vector3;
        /**
         * The right direction of that transform in world space.
         */
        readonly right: Vector3;
        /**
         * Returns the latest update of the World matrix
         * Returns a Matrix.
         */
        getWorldMatrix(): Matrix;
        /** @hidden */
        _getWorldMatrixDeterminant(): number;
        /**
         * Returns directly the latest state of the mesh World matrix.
         * A Matrix is returned.
         */
        readonly worldMatrixFromCache: Matrix;
        /**
         * Copies the paramater passed Matrix into the mesh Pose matrix.
         * Returns the TransformNode.
         */
        updatePoseMatrix(matrix: Matrix): TransformNode;
        /**
         * Returns the mesh Pose matrix.
         * Returned object : Matrix
         */
        getPoseMatrix(): Matrix;
        _isSynchronized(): boolean;
        _initCache(): void;
        markAsDirty(property: string): TransformNode;
        /**
         * Returns the current mesh absolute position.
         * Retuns a Vector3.
         */
        readonly absolutePosition: Vector3;
        /**
         * Sets a new matrix to apply before all other transformation
         * @param matrix defines the transform matrix
         * @returns the current TransformNode
         */
        setPreTransformMatrix(matrix: Matrix): TransformNode;
        /**
         * Sets a new pivot matrix to the current node
         * @param matrix defines the new pivot matrix to use
         * @param postMultiplyPivotMatrix defines if the pivot matrix must be cancelled in the world matrix. When this parameter is set to true (default), the inverse of the pivot matrix is also applied at the end to cancel the transformation effect
         * @returns the current TransformNode
        */
        setPivotMatrix(matrix: Matrix, postMultiplyPivotMatrix?: boolean): TransformNode;
        /**
         * Returns the mesh pivot matrix.
         * Default : Identity.
         * A Matrix is returned.
         */
        getPivotMatrix(): Matrix;
        /**
         * Prevents the World matrix to be computed any longer.
         * Returns the TransformNode.
         */
        freezeWorldMatrix(): TransformNode;
        /**
         * Allows back the World matrix computation.
         * Returns the TransformNode.
         */
        unfreezeWorldMatrix(): this;
        /**
         * True if the World matrix has been frozen.
         * Returns a boolean.
         */
        readonly isWorldMatrixFrozen: boolean;
        /**
            * Retuns the mesh absolute position in the World.
            * Returns a Vector3.
            */
        getAbsolutePosition(): Vector3;
        /**
         * Sets the mesh absolute position in the World from a Vector3 or an Array(3).
         * Returns the TransformNode.
         */
        setAbsolutePosition(absolutePosition: Vector3): TransformNode;
        /**
           * Sets the mesh position in its local space.
           * Returns the TransformNode.
           */
        setPositionWithLocalVector(vector3: Vector3): TransformNode;
        /**
         * Returns the mesh position in the local space from the current World matrix values.
         * Returns a new Vector3.
         */
        getPositionExpressedInLocalSpace(): Vector3;
        /**
         * Translates the mesh along the passed Vector3 in its local space.
         * Returns the TransformNode.
         */
        locallyTranslate(vector3: Vector3): TransformNode;
        private static _lookAtVectorCache;
        /**
         * Orients a mesh towards a target point. Mesh must be drawn facing user.
         * @param targetPoint the position (must be in same space as current mesh) to look at
         * @param yawCor optional yaw (y-axis) correction in radians
         * @param pitchCor optional pitch (x-axis) correction in radians
         * @param rollCor optional roll (z-axis) correction in radians
         * @param space the choosen space of the target
         * @returns the TransformNode.
         */
        lookAt(targetPoint: Vector3, yawCor?: number, pitchCor?: number, rollCor?: number, space?: Space): TransformNode;
        /**
          * Returns a new Vector3 what is the localAxis, expressed in the mesh local space, rotated like the mesh.
          * This Vector3 is expressed in the World space.
          */
        getDirection(localAxis: Vector3): Vector3;
        /**
         * Sets the Vector3 "result" as the rotated Vector3 "localAxis" in the same rotation than the mesh.
         * localAxis is expressed in the mesh local space.
         * result is computed in the Wordl space from the mesh World matrix.
         * Returns the TransformNode.
         */
        getDirectionToRef(localAxis: Vector3, result: Vector3): TransformNode;
        /**
         * Sets a new pivot point to the current node
         * @param point defines the new pivot point to use
         * @param space defines if the point is in world or local space (local by default)
         * @returns the current TransformNode
        */
        setPivotPoint(point: Vector3, space?: Space): TransformNode;
        /**
         * Returns a new Vector3 set with the mesh pivot point coordinates in the local space.
         */
        getPivotPoint(): Vector3;
        /**
         * Sets the passed Vector3 "result" with the coordinates of the mesh pivot point in the local space.
         * Returns the TransformNode.
         */
        getPivotPointToRef(result: Vector3): TransformNode;
        /**
         * Returns a new Vector3 set with the mesh pivot point World coordinates.
         */
        getAbsolutePivotPoint(): Vector3;
        /**
         * Sets the Vector3 "result" coordinates with the mesh pivot point World coordinates.
         * Returns the TransformNode.
         */
        getAbsolutePivotPointToRef(result: Vector3): TransformNode;
        /**
         * Defines the passed node as the parent of the current node.
         * The node will remain exactly where it is and its position / rotation will be updated accordingly
         * Returns the TransformNode.
         */
        setParent(node: Nullable<Node>): TransformNode;
        private _nonUniformScaling;
        readonly nonUniformScaling: boolean;
        _updateNonUniformScalingState(value: boolean): boolean;
        /**
         * Attach the current TransformNode to another TransformNode associated with a bone
         * @param bone Bone affecting the TransformNode
         * @param affectedTransformNode TransformNode associated with the bone
         */
        attachToBone(bone: Bone, affectedTransformNode: TransformNode): TransformNode;
        detachFromBone(): TransformNode;
        private static _rotationAxisCache;
        /**
         * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in the given space.
         * space (default LOCAL) can be either BABYLON.Space.LOCAL, either BABYLON.Space.WORLD.
         * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.
         * The passed axis is also normalized.
         * Returns the TransformNode.
         */
        rotate(axis: Vector3, amount: number, space?: Space): TransformNode;
        /**
         * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in world space.
         * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.
         * The passed axis is also normalized.
         * Returns the TransformNode.
         * Method is based on http://www.euclideanspace.com/maths/geometry/affine/aroundPoint/index.htm
         */
        rotateAround(point: Vector3, axis: Vector3, amount: number): TransformNode;
        /**
         * Translates the mesh along the axis vector for the passed distance in the given space.
         * space (default LOCAL) can be either BABYLON.Space.LOCAL, either BABYLON.Space.WORLD.
         * Returns the TransformNode.
         */
        translate(axis: Vector3, distance: number, space?: Space): TransformNode;
        /**
         * Adds a rotation step to the mesh current rotation.
         * x, y, z are Euler angles expressed in radians.
         * This methods updates the current mesh rotation, either mesh.rotation, either mesh.rotationQuaternion if it's set.
         * This means this rotation is made in the mesh local space only.
         * It's useful to set a custom rotation order different from the BJS standard one YXZ.
         * Example : this rotates the mesh first around its local X axis, then around its local Z axis, finally around its local Y axis.
         * ```javascript
         * mesh.addRotation(x1, 0, 0).addRotation(0, 0, z2).addRotation(0, 0, y3);
         * ```
         * Note that `addRotation()` accumulates the passed rotation values to the current ones and computes the .rotation or .rotationQuaternion updated values.
         * Under the hood, only quaternions are used. So it's a little faster is you use .rotationQuaternion because it doesn't need to translate them back to Euler angles.
         * Returns the TransformNode.
         */
        addRotation(x: number, y: number, z: number): TransformNode;
        /**
         * Computes the mesh World matrix and returns it.
         * If the mesh world matrix is frozen, this computation does nothing more than returning the last frozen values.
         * If the parameter `force` is let to `false` (default), the current cached World matrix is returned.
         * If the parameter `force`is set to `true`, the actual computation is done.
         * Returns the mesh World Matrix.
         */
        computeWorldMatrix(force?: boolean): Matrix;
        protected _afterComputeWorldMatrix(): void;
        /**
        * If you'd like to be called back after the mesh position, rotation or scaling has been updated.
        * @param func: callback function to add
        *
        * Returns the TransformNode.
        */
        registerAfterWorldMatrixUpdate(func: (mesh: TransformNode) => void): TransformNode;
        /**
         * Removes a registered callback function.
         * Returns the TransformNode.
         */
        unregisterAfterWorldMatrixUpdate(func: (mesh: TransformNode) => void): TransformNode;
        /**
         * Clone the current transform node
         * Returns the new transform node
         * @param name Name of the new clone
         * @param newParent New parent for the clone
         * @param doNotCloneChildren Do not clone children hierarchy
         */
        clone(name: string, newParent: Node, doNotCloneChildren?: boolean): Nullable<TransformNode>;
        serialize(currentSerializationObject?: any): any;
        /**
         * Returns a new TransformNode object parsed from the source provided.
         * The parameter `parsedMesh` is the source.
         * The parameter `rootUrl` is a string, it's the root URL to prefix the `delayLoadingFile` property with
         */
        static Parse(parsedTransformNode: any, scene: Scene, rootUrl: string): TransformNode;
        /**
         * Releases resources associated with this transform node.
         * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
         * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
         */
        dispose(doNotRecurse?: boolean, disposeMaterialAndTextures?: boolean): void;
    }
}

declare module BABYLON {
    class VertexBuffer {
        private _buffer;
        private _kind;
        private _size;
        private _ownsBuffer;
        private _instanced;
        private _instanceDivisor;
        /**
         * The byte type.
         */
        static readonly BYTE: number;
        /**
         * The unsigned byte type.
         */
        static readonly UNSIGNED_BYTE: number;
        /**
         * The short type.
         */
        static readonly SHORT: number;
        /**
         * The unsigned short type.
         */
        static readonly UNSIGNED_SHORT: number;
        /**
         * The integer type.
         */
        static readonly INT: number;
        /**
         * The unsigned integer type.
         */
        static readonly UNSIGNED_INT: number;
        /**
         * The float type.
         */
        static readonly FLOAT: number;
        /**
         * Gets or sets the instance divisor when in instanced mode
         */
        instanceDivisor: number;
        /**
         * Gets the byte stride.
         */
        readonly byteStride: number;
        /**
         * Gets the byte offset.
         */
        readonly byteOffset: number;
        /**
         * Gets whether integer data values should be normalized into a certain range when being casted to a float.
         */
        readonly normalized: boolean;
        /**
         * Gets the data type of each component in the array.
         */
        readonly type: number;
        /**
         * Constructor
         * @param engine the engine
         * @param data the data to use for this vertex buffer
         * @param kind the vertex buffer kind
         * @param updatable whether the data is updatable
         * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)
         * @param stride the stride (optional)
         * @param instanced whether the buffer is instanced (optional)
         * @param offset the offset of the data (optional)
         * @param size the number of components (optional)
         * @param type the type of the component (optional)
         * @param normalized whether the data contains normalized data (optional)
         * @param useBytes set to true if stride and offset are in bytes (optional)
         */
        constructor(engine: any, data: DataArray | Buffer, kind: string, updatable: boolean, postponeInternalCreation?: boolean, stride?: number, instanced?: boolean, offset?: number, size?: number, type?: number, normalized?: boolean, useBytes?: boolean);
        _rebuild(): void;
        /**
         * Returns the kind of the VertexBuffer (string).
         */
        getKind(): string;
        /**
         * Boolean : is the VertexBuffer updatable ?
         */
        isUpdatable(): boolean;
        /**
         * Returns an array of numbers or a typed array containing the VertexBuffer data.
         */
        getData(): Nullable<DataArray>;
        /**
         * Returns the WebGLBuffer associated to the VertexBuffer.
         */
        getBuffer(): Nullable<WebGLBuffer>;
        /**
         * Returns the stride as a multiple of the type byte length.
         * DEPRECATED. Use byteStride instead.
         */
        getStrideSize(): number;
        /**
         * Returns the offset as a multiple of the type byte length.
         * DEPRECATED. Use byteOffset instead.
         */
        getOffset(): number;
        /**
         * Returns the number of components per vertex attribute (integer).
         */
        getSize(): number;
        /**
         * Boolean : is the WebGLBuffer of the VertexBuffer instanced now ?
         */
        getIsInstanced(): boolean;
        /**
         * Returns the instancing divisor, zero for non-instanced (integer).
         */
        getInstanceDivisor(): number;
        /**
         * Creates the underlying WebGLBuffer from the passed numeric array or Float32Array.
         * Returns the created WebGLBuffer.
         */
        create(data?: DataArray): void;
        /**
         * Updates the underlying WebGLBuffer according to the passed numeric array or Float32Array.
         * This function will create a new buffer if the current one is not updatable
         * Returns the updated WebGLBuffer.
         */
        update(data: DataArray): void;
        /**
         * Updates directly the underlying WebGLBuffer according to the passed numeric array or Float32Array.
         * Returns the directly updated WebGLBuffer.
         * @param data the new data
         * @param offset the new offset
         * @param useBytes set to true if the offset is in bytes
         */
        updateDirectly(data: DataArray, offset: number, useBytes?: boolean): void;
        /**
         * Disposes the VertexBuffer and the underlying WebGLBuffer.
         */
        dispose(): void;
        /**
         * Enumerates each value of this vertex buffer as numbers.
         * @param count the number of values to enumerate
         * @param callback the callback function called for each value
         */
        forEach(count: number, callback: (value: number, index: number) => void): void;
        private static _PositionKind;
        private static _NormalKind;
        private static _TangentKind;
        private static _UVKind;
        private static _UV2Kind;
        private static _UV3Kind;
        private static _UV4Kind;
        private static _UV5Kind;
        private static _UV6Kind;
        private static _ColorKind;
        private static _MatricesIndicesKind;
        private static _MatricesWeightsKind;
        private static _MatricesIndicesExtraKind;
        private static _MatricesWeightsExtraKind;
        static readonly PositionKind: string;
        static readonly NormalKind: string;
        static readonly TangentKind: string;
        static readonly UVKind: string;
        static readonly UV2Kind: string;
        static readonly UV3Kind: string;
        static readonly UV4Kind: string;
        static readonly UV5Kind: string;
        static readonly UV6Kind: string;
        static readonly ColorKind: string;
        static readonly MatricesIndicesKind: string;
        static readonly MatricesWeightsKind: string;
        static readonly MatricesIndicesExtraKind: string;
        static readonly MatricesWeightsExtraKind: string;
        /**
         * Deduces the stride given a kind.
         * @param kind The kind string to deduce
         * @returns The deduced stride
         */
        static DeduceStride(kind: string): number;
        /**
         * Gets the byte length of the given type.
         * @param type the type
         * @returns the number of bytes
         */
        static GetTypeByteLength(type: number): number;
        /**
         * Enumerates each value of the given parameters as numbers.
         * @param data the data to enumerate
         * @param byteOffset the byte offset of the data
         * @param byteStride the byte stride of the data
         * @param componentCount the number of components per element
         * @param componentType the type of the component
         * @param count the total number of components
         * @param normalized whether the data is normalized
         * @param callback the callback function called for each value
         */
        static ForEach(data: DataArray, byteOffset: number, byteStride: number, componentCount: number, componentType: number, count: number, normalized: boolean, callback: (value: number, index: number) => void): void;
        private static _GetFloatValue(dataView, type, byteOffset, normalized);
    }
}

declare module BABYLON {
    /**
     * This represents a GPU particle system in Babylon
     * This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data
     * @see https://www.babylonjs-playground.com/#PU4WYI#4
     */
    class GPUParticleSystem implements IDisposable, IParticleSystem, IAnimatable {
        /**
         * The id of the Particle system.
         */
        id: string;
        /**
         * The friendly name of the Particle system.
         */
        name: string;
        /**
         * The emitter represents the Mesh or position we are attaching the particle system to.
         */
        emitter: Nullable<AbstractMesh | Vector3>;
        /**
         * The rendering group used by the Particle system to chose when to render.
         */
        renderingGroupId: number;
        /**
         * The layer mask we are rendering the particles through.
         */
        layerMask: number;
        private _capacity;
        private _activeCount;
        private _currentActiveCount;
        private _renderEffect;
        private _updateEffect;
        private _buffer0;
        private _buffer1;
        private _spriteBuffer;
        private _updateVAO;
        private _renderVAO;
        private _targetIndex;
        private _sourceBuffer;
        private _targetBuffer;
        private _scene;
        private _engine;
        private _currentRenderId;
        private _started;
        private _stopped;
        private _timeDelta;
        private _randomTexture;
        private readonly _attributesStrideSize;
        private _updateEffectOptions;
        private _randomTextureSize;
        private _actualFrame;
        /**
         * List of animations used by the particle system.
         */
        animations: Animation[];
        /**
         * Gets a boolean indicating if the GPU particles can be rendered on current browser
         */
        static readonly IsSupported: boolean;
        /**
        * An event triggered when the system is disposed.
        */
        onDisposeObservable: Observable<GPUParticleSystem>;
        /**
         * The overall motion speed (0.01 is default update speed, faster updates = faster animation)
         */
        updateSpeed: number;
        /**
         * The amount of time the particle system is running (depends of the overall update speed).
         */
        targetStopDuration: number;
        /**
         * The texture used to render each particle. (this can be a spritesheet)
         */
        particleTexture: Nullable<Texture>;
        /**
         * Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE or ParticleSystem.BLENDMODE_STANDARD.
         */
        blendMode: number;
        /**
         * Minimum life time of emitting particles.
         */
        minLifeTime: number;
        /**
         * Maximum life time of emitting particles.
         */
        maxLifeTime: number;
        /**
         * Minimum Size of emitting particles.
         */
        minSize: number;
        /**
         * Maximum Size of emitting particles.
         */
        maxSize: number;
        /**
         * Random color of each particle after it has been emitted, between color1 and color2 vectors.
         */
        color1: Color4;
        /**
         * Random color of each particle after it has been emitted, between color1 and color2 vectors.
         */
        color2: Color4;
        /**
         * Color the particle will have at the end of its lifetime.
         */
        colorDead: Color4;
        /**
         * The maximum number of particles to emit per frame until we reach the activeParticleCount value
         */
        emitRate: number;
        /**
         * You can use gravity if you want to give an orientation to your particles.
         */
        gravity: Vector3;
        /**
         * Minimum power of emitting particles.
         */
        minEmitPower: number;
        /**
         * Maximum power of emitting particles.
         */
        maxEmitPower: number;
        /**
         * The particle emitter type defines the emitter used by the particle system.
         * It can be for example box, sphere, or cone...
         */
        particleEmitterType: Nullable<IParticleEmitterType>;
        /**
         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
         * This only works when particleEmitterTyps is a BoxParticleEmitter
         */
        direction1: Vector3;
        /**
         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
         * This only works when particleEmitterTyps is a BoxParticleEmitter
         */
        direction2: Vector3;
        /**
         * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
         * This only works when particleEmitterTyps is a BoxParticleEmitter
         */
        minEmitBox: Vector3;
        /**
         * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
         * This only works when particleEmitterTyps is a BoxParticleEmitter
         */
        maxEmitBox: Vector3;
        /**
         * Gets the maximum number of particles active at the same time.
         * @returns The max number of active particles.
         */
        getCapacity(): number;
        /**
         * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls
         * to override the particles.
         */
        forceDepthWrite: boolean;
        /**
         * Gets or set the number of active particles
         */
        activeParticleCount: number;
        /**
         * Is this system ready to be used/rendered
         * @return true if the system is ready
         */
        isReady(): boolean;
        /**
         * Gets Wether the system has been started.
         * @returns True if it has been started, otherwise false.
         */
        isStarted(): boolean;
        /**
         * Starts the particle system and begins to emit.
         */
        start(): void;
        /**
         * Stops the particle system.
         */
        stop(): void;
        /**
         * Remove all active particles
         */
        reset(): void;
        /**
         * Returns the string "GPUParticleSystem"
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Instantiates a GPU particle system.
         * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
         * @param name The name of the particle system
         * @param capacity The max number of particles alive at the same time
         * @param scene The scene the particle system belongs to
         */
        constructor(name: string, options: Partial<{
            capacity: number;
            randomTextureSize: number;
        }>, scene: Scene);
        private _createUpdateVAO(source);
        private _createRenderVAO(source, spriteSource);
        private _initialize(force?);
        /** @hidden */
        _recreateUpdateEffect(): void;
        /** @hidden */
        _recreateRenderEffect(): void;
        /**
         * Animates the particle system for the current frame by emitting new particles and or animating the living ones.
         */
        animate(): void;
        /**
         * Renders the particle system in its current state.
         * @returns the current number of particles
         */
        render(): number;
        /**
         * Rebuilds the particle system
         */
        rebuild(): void;
        private _releaseBuffers();
        private _releaseVAOs();
        /**
         * Disposes the particle system and free the associated resources
         * @param disposeTexture defines if the particule texture must be disposed as well (true by default)
         */
        dispose(disposeTexture?: boolean): void;
        /**
         * Clones the particle system.
         * @param name The name of the cloned object
         * @param newEmitter The new emitter to use
         * @returns the cloned particle system
         */
        clone(name: string, newEmitter: any): Nullable<GPUParticleSystem>;
        /**
         * Serializes the particle system to a JSON object.
         * @returns the JSON object
         */
        serialize(): any;
        /**
         * Parses a JSON object to create a GPU particle system.
         * @param parsedParticleSystem The JSON object to parse
         * @param scene The scene to create the particle system in
         * @param rootUrl The root url to use to load external dependencies like texture
         * @returns the parsed GPU particle system
         */
        static Parse(parsedParticleSystem: any, scene: Scene, rootUrl: string): GPUParticleSystem;
    }
}

declare module BABYLON {
    /**
     * Interface representing a particle system in Babylon.
     * This groups the common functionalities that needs to be implemented in order to create a particle system.
     * A particle system represents a way to manage particles from their emission to their animation and rendering.
     */
    interface IParticleSystem {
        /**
         * The id of the Particle system.
         */
        id: string;
        /**
         * The name of the Particle system.
         */
        name: string;
        /**
         * The emitter represents the Mesh or position we are attaching the particle system to.
         */
        emitter: Nullable<AbstractMesh | Vector3>;
        /**
         * The rendering group used by the Particle system to chose when to render.
         */
        renderingGroupId: number;
        /**
         * The layer mask we are rendering the particles through.
         */
        layerMask: number;
        /**
        * The overall motion speed (0.01 is default update speed, faster updates = faster animation)
        */
        updateSpeed: number;
        /**
         * The amount of time the particle system is running (depends of the overall update speed).
         */
        targetStopDuration: number;
        /**
         * The texture used to render each particle. (this can be a spritesheet)
         */
        particleTexture: Nullable<Texture>;
        /**
         * Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE or ParticleSystem.BLENDMODE_STANDARD.
         */
        blendMode: number;
        /**
         * Minimum life time of emitting particles.
         */
        minLifeTime: number;
        /**
         * Maximum life time of emitting particles.
         */
        maxLifeTime: number;
        /**
         * Minimum Size of emitting particles.
         */
        minSize: number;
        /**
         * Maximum Size of emitting particles.
         */
        maxSize: number;
        /**
         * Random color of each particle after it has been emitted, between color1 and color2 vectors.
         */
        color1: Color4;
        /**
         * Random color of each particle after it has been emitted, between color1 and color2 vectors.
         */
        color2: Color4;
        /**
         * Color the particle will have at the end of its lifetime.
         */
        colorDead: Color4;
        /**
         * The maximum number of particles to emit per frame until we reach the activeParticleCount value
         */
        emitRate: number;
        /**
         * You can use gravity if you want to give an orientation to your particles.
         */
        gravity: Vector3;
        /**
         * Minimum power of emitting particles.
         */
        minEmitPower: number;
        /**
         * Maximum power of emitting particles.
         */
        maxEmitPower: number;
        /**
         * The particle emitter type defines the emitter used by the particle system.
         * It can be for example box, sphere, or cone...
         */
        particleEmitterType: Nullable<IParticleEmitterType>;
        /**
         * Gets the maximum number of particles active at the same time.
         * @returns The max number of active particles.
         */
        getCapacity(): number;
        /**
         * Gets Wether the system has been started.
         * @returns True if it has been started, otherwise false.
         */
        isStarted(): boolean;
        /**
         * Gets if the particle system has been started.
         * @return true if the system has been started, otherwise false.
         */
        isStarted(): boolean;
        /**
         * Animates the particle system for this frame.
         */
        animate(): void;
        /**
         * Renders the particle system in its current state.
         * @returns the current number of particles
         */
        render(): number;
        /**
         * Dispose the particle system and frees its associated resources.
         * @param disposeTexture defines if the particule texture must be disposed as well (true by default)
         */
        dispose(disposeTexture?: boolean): void;
        /**
         * Clones the particle system.
         * @param name The name of the cloned object
         * @param newEmitter The new emitter to use
         * @returns the cloned particle system
         */
        clone(name: string, newEmitter: any): Nullable<IParticleSystem>;
        /**
         * Serializes the particle system to a JSON object.
         * @returns the JSON object
         */
        serialize(): any;
        /**
         * Rebuild the particle system
         */
        rebuild(): void;
        /**
         * Starts the particle system and begins to emit.
         */
        start(): void;
        /**
         * Stops the particle system.
         */
        stop(): void;
        /**
         * Remove all active particles
         */
        reset(): void;
        /**
         * Is this system ready to be used/rendered
         * @return true if the system is ready
         */
        isReady(): boolean;
    }
}

declare module BABYLON {
    /**
     * A particle represents one of the element emitted by a particle system.
     * This is mainly define by its coordinates, direction, velocity and age.
     */
    class Particle {
        /**
         * particleSystem the particle system the particle belongs to.
         */
        particleSystem: ParticleSystem;
        /**
         * The world position of the particle in the scene.
         */
        position: Vector3;
        /**
         * The world direction of the particle in the scene.
         */
        direction: Vector3;
        /**
         * The color of the particle.
         */
        color: Color4;
        /**
         * The color change of the particle per step.
         */
        colorStep: Color4;
        /**
         * Defines how long will the life of the particle be.
         */
        lifeTime: number;
        /**
         * The current age of the particle.
         */
        age: number;
        /**
         * The current size of the particle.
         */
        size: number;
        /**
         * The current angle of the particle.
         */
        angle: number;
        /**
         * Defines how fast is the angle changing.
         */
        angularSpeed: number;
        /**
         * Defines the cell index used by the particle to be rendered from a sprite.
         */
        cellIndex: number;
        private _currentFrameCounter;
        /**
         * Creates a new instance Particle
         * @param particleSystem the particle system the particle belongs to
         */
        constructor(
            /**
             * particleSystem the particle system the particle belongs to.
             */
            particleSystem: ParticleSystem);
        private updateCellInfoFromSystem();
        /**
         * Defines how the sprite cell index is updated for the particle. This is
         * defined as a callback.
         */
        updateCellIndex: (scaledUpdateSpeed: number) => void;
        private _updateCellIndexWithSpeedCalculated(scaledUpdateSpeed);
        private _updateCellIndexWithCustomSpeed();
        /**
         * Copy the properties of particle to another one.
         * @param other the particle to copy the information to.
         */
        copyTo(other: Particle): void;
    }
}

declare module BABYLON {
    /**
     * This represents a particle system in Babylon.
     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
     * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.
     * @example https://doc.babylonjs.com/babylon101/particles
     */
    class ParticleSystem implements IDisposable, IAnimatable, IParticleSystem {
        /**
         * Source color is added to the destination color without alpha affecting the result.
         */
        static BLENDMODE_ONEONE: number;
        /**
         * Blend current color and particle color using particles alpha.
         */
        static BLENDMODE_STANDARD: number;
        /**
         * List of animations used by the particle system.
         */
        animations: Animation[];
        /**
         * The id of the Particle system.
         */
        id: string;
        /**
         * The friendly name of the Particle system.
         */
        name: string;
        /**
         * The rendering group used by the Particle system to chose when to render.
         */
        renderingGroupId: number;
        /**
         * The emitter represents the Mesh or position we are attaching the particle system to.
         */
        emitter: Nullable<AbstractMesh | Vector3>;
        /**
         * The maximum number of particles to emit per frame
         */
        emitRate: number;
        /**
         * If you want to launch only a few particles at once, that can be done, as well.
         */
        manualEmitCount: number;
        /**
         * The overall motion speed (0.01 is default update speed, faster updates = faster animation)
         */
        updateSpeed: number;
        /**
         * The amount of time the particle system is running (depends of the overall update speed).
         */
        targetStopDuration: number;
        /**
         * Specifies whether the particle system will be disposed once it reaches the end of the animation.
         */
        disposeOnStop: boolean;
        /**
         * Minimum power of emitting particles.
         */
        minEmitPower: number;
        /**
         * Maximum power of emitting particles.
         */
        maxEmitPower: number;
        /**
         * Minimum life time of emitting particles.
         */
        minLifeTime: number;
        /**
         * Maximum life time of emitting particles.
         */
        maxLifeTime: number;
        /**
         * Minimum Size of emitting particles.
         */
        minSize: number;
        /**
         * Maximum Size of emitting particles.
         */
        maxSize: number;
        /**
         * Minimum angular speed of emitting particles (Z-axis rotation for each particle).
         */
        minAngularSpeed: number;
        /**
         * Maximum angular speed of emitting particles (Z-axis rotation for each particle).
         */
        maxAngularSpeed: number;
        /**
         * The texture used to render each particle. (this can be a spritesheet)
         */
        particleTexture: Nullable<Texture>;
        /**
         * The layer mask we are rendering the particles through.
         */
        layerMask: number;
        /**
         * This can help using your own shader to render the particle system.
         * The according effect will be created
         */
        customShader: any;
        /**
         * By default particle system starts as soon as they are created. This prevents the
         * automatic start to happen and let you decide when to start emitting particles.
         */
        preventAutoStart: boolean;
        /**
         * This function can be defined to provide custom update for active particles.
         * This function will be called instead of regular update (age, position, color, etc.).
         * Do not forget that this function will be called on every frame so try to keep it simple and fast :)
         */
        updateFunction: (particles: Particle[]) => void;
        /**
         * Callback triggered when the particle animation is ending.
         */
        onAnimationEnd: Nullable<() => void>;
        /**
         * Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE or ParticleSystem.BLENDMODE_STANDARD.
         */
        blendMode: number;
        /**
         * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls
         * to override the particles.
         */
        forceDepthWrite: boolean;
        /**
         * You can use gravity if you want to give an orientation to your particles.
         */
        gravity: Vector3;
        /**
          * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
          * This only works when particleEmitterTyps is a BoxParticleEmitter
          */
        direction1: Vector3;
        /**
         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
         * This only works when particleEmitterTyps is a BoxParticleEmitter
         */
        direction2: Vector3;
        /**
         * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
         * This only works when particleEmitterTyps is a BoxParticleEmitter
         */
        minEmitBox: Vector3;
        /**
         * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
         * This only works when particleEmitterTyps is a BoxParticleEmitter
         */
        maxEmitBox: Vector3;
        /**
         * Random color of each particle after it has been emitted, between color1 and color2 vectors.
         */
        color1: Color4;
        /**
         * Random color of each particle after it has been emitted, between color1 and color2 vectors.
         */
        color2: Color4;
        /**
         * Color the particle will have at the end of its lifetime.
         */
        colorDead: Color4;
        /**
         * An optional mask to filter some colors out of the texture, or filter a part of the alpha channel.
         */
        textureMask: Color4;
        /**
         * The particle emitter type defines the emitter used by the particle system.
         * It can be for example box, sphere, or cone...
         */
        particleEmitterType: IParticleEmitterType;
        /**
         * This function can be defined to specify initial direction for every new particle.
         * It by default use the emitterType defined function.
         */
        startDirectionFunction: (emitPower: number, worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle) => void;
        /**
         * This function can be defined to specify initial position for every new particle.
         * It by default use the emitterType defined function.
         */
        startPositionFunction: (worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle) => void;
        /**
         * If using a spritesheet (isAnimationSheetEnabled), defines if the sprite animation should loop between startSpriteCellID and endSpriteCellID or not.
         */
        spriteCellLoop: boolean;
        /**
         * If using a spritesheet (isAnimationSheetEnabled) and spriteCellLoop defines the speed of the sprite loop.
         */
        spriteCellChangeSpeed: number;
        /**
         * If using a spritesheet (isAnimationSheetEnabled) and spriteCellLoop defines the first sprite cell to display.
         */
        startSpriteCellID: number;
        /**
         * If using a spritesheet (isAnimationSheetEnabled) and spriteCellLoop defines the last sprite cell to display.
         */
        endSpriteCellID: number;
        /**
         * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell width to use.
         */
        spriteCellWidth: number;
        /**
         * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell height to use.
         */
        spriteCellHeight: number;
        /**
        * An event triggered when the system is disposed.
        */
        onDisposeObservable: Observable<ParticleSystem>;
        private _onDisposeObserver;
        /**
         * Sets a callback that will be triggered when the system is disposed.
         */
        onDispose: () => void;
        /**
         * Gets wether an animation sprite sheet is enabled or not on the particle system.
         */
        readonly isAnimationSheetEnabled: Boolean;
        private _particles;
        private _epsilon;
        private _capacity;
        private _scene;
        private _stockParticles;
        private _newPartsExcess;
        private _vertexData;
        private _vertexBuffer;
        private _vertexBuffers;
        private _indexBuffer;
        private _effect;
        private _customEffect;
        private _cachedDefines;
        private _scaledColorStep;
        private _colorDiff;
        private _scaledDirection;
        private _scaledGravity;
        private _currentRenderId;
        private _alive;
        private _started;
        private _stopped;
        private _actualFrame;
        private _scaledUpdateSpeed;
        private _vertexBufferSize;
        private _isAnimationSheetEnabled;
        /**
         * this is the Sub-emitters templates that will be used to generate particle system when the particle dies, this property is used by the root particle system only.
         */
        subEmitters: ParticleSystem[];
        /**
        * The current active Sub-systems, this property is used by the root particle system only.
        */
        activeSubSystems: Array<ParticleSystem>;
        private _rootParticleSystem;
        /**
         * Gets the current list of active particles
         */
        readonly particles: Particle[];
        /**
         * Returns the string "ParticleSystem"
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Instantiates a particle system.
         * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
         * @param name The name of the particle system
         * @param capacity The max number of particles alive at the same time
         * @param scene The scene the particle system belongs to
         * @param customEffect a custom effect used to change the way particles are rendered by default
         * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture
         * @param epsilon Offset used to render the particles
         */
        constructor(name: string, capacity: number, scene: Scene, customEffect?: Nullable<Effect>, isAnimationSheetEnabled?: boolean, epsilon?: number);
        private _createIndexBuffer();
        /**
         * Gets the maximum number of particles active at the same time.
         * @returns The max number of active particles.
         */
        getCapacity(): number;
        /**
         * Gets Wether there are still active particles in the system.
         * @returns True if it is alive, otherwise false.
         */
        isAlive(): boolean;
        /**
         * Gets Wether the system has been started.
         * @returns True if it has been started, otherwise false.
         */
        isStarted(): boolean;
        /**
         * Starts the particle system and begins to emit.
         */
        start(): void;
        /**
         * Stops the particle system.
         * @param stopSubEmitters if true it will stop the current system and all created sub-Systems if false it will stop the current root system only, this param is used by the root particle system only. the default value is true.
         */
        stop(stopSubEmitters?: boolean): void;
        /**
         * Remove all active particles
         */
        reset(): void;
        /**
         * @hidden (for internal use only)
         */
        _appendParticleVertex(index: number, particle: Particle, offsetX: number, offsetY: number): void;
        /**
         * @hidden (for internal use only)
         */
        _appendParticleVertexWithAnimation(index: number, particle: Particle, offsetX: number, offsetY: number): void;
        /**
         * "Recycles" one of the particle by copying it back to the "stock" of particles and removing it from the active list.
         * Its lifetime will start back at 0.
         */
        recycleParticle: (particle: Particle) => void;
        private _stopSubEmitters();
        private _createParticle;
        private _removeFromRoot();
        private _emitFromParticle;
        private _update(newParticles);
        private _getEffect();
        /**
         * Animates the particle system for the current frame by emitting new particles and or animating the living ones.
         */
        animate(): void;
        private _appendParticleVertexes;
        private _appenedParticleVertexesWithSheet(offset, particle);
        private _appenedParticleVertexesNoSheet(offset, particle);
        /**
         * Rebuilds the particle system.
         */
        rebuild(): void;
        /**
         * Is this system ready to be used/rendered
         * @return true if the system is ready
         */
        isReady(): boolean;
        /**
         * Renders the particle system in its current state.
         * @returns the current number of particles
         */
        render(): number;
        /**
         * Disposes the particle system and free the associated resources
         * @param disposeTexture defines if the particule texture must be disposed as well (true by default)
         */
        dispose(disposeTexture?: boolean): void;
        /**
         * Creates a Sphere Emitter for the particle system. (emits along the sphere radius)
         * @param radius The radius of the sphere to emit from
         * @returns the emitter
         */
        createSphereEmitter(radius?: number): SphereParticleEmitter;
        /**
         * Creates a Directed Sphere Emitter for the particle system. (emits between direction1 and direction2)
         * @param radius The radius of the sphere to emit from
         * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere
         * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere
         * @returns the emitter
         */
        createDirectedSphereEmitter(radius?: number, direction1?: Vector3, direction2?: Vector3): SphereDirectedParticleEmitter;
        /**
         * Creates a Cone Emitter for the particle system. (emits from the cone to the particle position)
         * @param radius The radius of the cone to emit from
         * @param angle The base angle of the cone
         * @returns the emitter
         */
        createConeEmitter(radius?: number, angle?: number): ConeParticleEmitter;
        /**
         * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)
         * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
         * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
         * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox
         * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox
         * @returns the emitter
         */
        createBoxEmitter(direction1: Vector3, direction2: Vector3, minEmitBox: Vector3, maxEmitBox: Vector3): BoxParticleEmitter;
        /**
         * Clones the particle system.
         * @param name The name of the cloned object
         * @param newEmitter The new emitter to use
         * @returns the cloned particle system
         */
        clone(name: string, newEmitter: any): ParticleSystem;
        /**
         * Serializes the particle system to a JSON object.
         * @returns the JSON object
         */
        serialize(): any;
        /**
         * Parses a JSON object to create a particle system.
         * @param parsedParticleSystem The JSON object to parse
         * @param scene The scene to create the particle system in
         * @param rootUrl The root url to use to load external dependencies like texture
         * @returns the Parsed particle system
         */
        static Parse(parsedParticleSystem: any, scene: Scene, rootUrl: string): ParticleSystem;
    }
}

declare module BABYLON {
    /**
     * Represents one particle of a solid particle system.
     */
    class SolidParticle {
        /**
         * particle global index
         */
        idx: number;
        /**
         * The color of the particle
         */
        color: Nullable<Color4>;
        /**
         * The world space position of the particle.
         */
        position: Vector3;
        /**
         * The world space rotation of the particle. (Not use if rotationQuaternion is set)
         */
        rotation: Vector3;
        /**
         * The world space rotation quaternion of the particle.
         */
        rotationQuaternion: Nullable<Quaternion>;
        /**
         * The scaling of the particle.
         */
        scaling: Vector3;
        /**
         * The uvs of the particle.
         */
        uvs: Vector4;
        /**
         * The current speed of the particle.
         */
        velocity: Vector3;
        /**
         * The pivot point in the particle local space.
         */
        pivot: Vector3;
        /**
         * Must the particle be translated from its pivot point in its local space ?
         * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.
         * Default : false
         */
        translateFromPivot: boolean;
        /**
         * Is the particle active or not ?
         */
        alive: boolean;
        /**
         * Is the particle visible or not ?
         */
        isVisible: boolean;
        /**
         * Index of this particle in the global "positions" array (Internal use)
         */
        _pos: number;
        /**
         * Index of this particle in the global "indices" array (Internal use)
         */
        _ind: number;
        /**
         * ModelShape of this particle (Internal use)
         */
        _model: ModelShape;
        /**
         * ModelShape id of this particle
         */
        shapeId: number;
        /**
         * Index of the particle in its shape id (Internal use)
         */
        idxInShape: number;
        /**
         * Reference to the shape model BoundingInfo object (Internal use)
         */
        _modelBoundingInfo: BoundingInfo;
        /**
         * Particle BoundingInfo object (Internal use)
         */
        _boundingInfo: BoundingInfo;
        /**
         * Reference to the SPS what the particle belongs to (Internal use)
         */
        _sps: SolidParticleSystem;
        /**
         * Still set as invisible in order to skip useless computations (Internal use)
         */
        _stillInvisible: boolean;
        /**
         * Last computed particle rotation matrix
         */
        _rotationMatrix: number[];
        /**
         * Parent particle Id, if any.
         * Default null.
         */
        parentId: Nullable<number>;
        /**
         * Internal global position in the SPS.
         */
        _globalPosition: Vector3;
        /**
         * Creates a Solid Particle object.
         * Don't create particles manually, use instead the Solid Particle System internal tools like _addParticle()
         * @param particleIndex (integer) is the particle index in the Solid Particle System pool. It's also the particle identifier.
         * @param positionIndex (integer) is the starting index of the particle vertices in the SPS "positions" array.
         * @param indiceIndex (integer) is the starting index of the particle indices in the SPS "indices" array.
         * @param model (ModelShape) is a reference to the model shape on what the particle is designed.
         * @param shapeId (integer) is the model shape identifier in the SPS.
         * @param idxInShape (integer) is the index of the particle in the current model (ex: the 10th box of addShape(box, 30))
         * @param modelBoundingInfo is the reference to the model BoundingInfo used for intersection computations.
         */
        constructor(particleIndex: number, positionIndex: number, indiceIndex: number, model: Nullable<ModelShape>, shapeId: number, idxInShape: number, sps: SolidParticleSystem, modelBoundingInfo?: Nullable<BoundingInfo>);
        /**
         * Legacy support, changed scale to scaling
         */
        /**
         * Legacy support, changed scale to scaling
         */
        scale: Vector3;
        /**
         * Legacy support, changed quaternion to rotationQuaternion
         */
        /**
         * Legacy support, changed quaternion to rotationQuaternion
         */
        quaternion: Nullable<Quaternion>;
        /**
         * Returns a boolean. True if the particle intersects another particle or another mesh, else false.
         * The intersection is computed on the particle bounding sphere and Axis Aligned Bounding Box (AABB)
         * @param target is the object (solid particle or mesh) what the intersection is computed against.
         * @returns true if it intersects
         */
        intersectsMesh(target: Mesh | SolidParticle): boolean;
    }
    /**
     * Represents the shape of the model used by one particle of a solid particle system.
     * SPS internal tool, don't use it manually.
     */
    class ModelShape {
        /**
         * The shape id.
         */
        shapeID: number;
        /**
         * flat array of model positions (internal use)
         */
        _shape: Vector3[];
        /**
         * flat array of model UVs (internal use)
         */
        _shapeUV: number[];
        /**
         * length of the shape in the model indices array (internal use)
         */
        _indicesLength: number;
        /**
         * Custom position function (internal use)
         */
        _positionFunction: Nullable<(particle: SolidParticle, i: number, s: number) => void>;
        /**
         * Custom vertex function (internal use)
         */
        _vertexFunction: Nullable<(particle: SolidParticle, vertex: Vector3, i: number) => void>;
        /**
         * Creates a ModelShape object. This is an internal simplified reference to a mesh used as for a model to replicate particles from by the SPS.
         * SPS internal tool, don't use it manually.
         * @hidden
         */
        constructor(id: number, shape: Vector3[], indicesLength: number, shapeUV: number[], posFunction: Nullable<(particle: SolidParticle, i: number, s: number) => void>, vtxFunction: Nullable<(particle: SolidParticle, vertex: Vector3, i: number) => void>);
    }
    /**
     * Represents a Depth Sorted Particle in the solid particle system.
     */
    class DepthSortedParticle {
        /**
         * Index of the particle in the "indices" array
         */
        ind: number;
        /**
         * Length of the particle shape in the "indices" array
         */
        indicesLength: number;
        /**
         * Squared distance from the particle to the camera
         */
        sqDistance: number;
    }
}

declare module BABYLON {
    /**
     * The SPS is a single updatable mesh. The solid particles are simply separate parts or faces fo this big mesh.
     *As it is just a mesh, the SPS has all the same properties than any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.

     * The SPS is also a particle system. It provides some methods to manage the particles.
     * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.
     *
     * Full documentation here : http://doc.babylonjs.com/overviews/Solid_Particle_System
     */
    class SolidParticleSystem implements IDisposable {
        /**
         *  The SPS array of Solid Particle objects. Just access each particle as with any classic array.
         *  Example : var p = SPS.particles[i];
         */
        particles: SolidParticle[];
        /**
         * The SPS total number of particles. Read only. Use SPS.counter instead if you need to set your own value.
         */
        nbParticles: number;
        /**
         * If the particles must ever face the camera (default false). Useful for planar particles.
         */
        billboard: boolean;
        /**
         * Recompute normals when adding a shape
         */
        recomputeNormals: boolean;
        /**
         * This a counter ofr your own usage. It's not set by any SPS functions.
         */
        counter: number;
        /**
         * The SPS name. This name is also given to the underlying mesh.
         */
        name: string;
        /**
         * The SPS mesh. It's a standard BJS Mesh, so all the methods from the Mesh class are avalaible.
         */
        mesh: Mesh;
        /**
         * This empty object is intended to store some SPS specific or temporary values in order to lower the Garbage Collector activity.
         * Please read : http://doc.babylonjs.com/overviews/Solid_Particle_System#garbage-collector-concerns
         */
        vars: any;
        /**
         * This array is populated when the SPS is set as 'pickable'.
         * Each key of this array is a `faceId` value that you can get from a pickResult object.
         * Each element of this array is an object `{idx: int, faceId: int}`.
         * `idx` is the picked particle index in the `SPS.particles` array
         * `faceId` is the picked face index counted within this particle.
         * Please read : http://doc.babylonjs.com/overviews/Solid_Particle_System#pickable-particles
         */
        pickedParticles: {
            idx: number;
            faceId: number;
        }[];
        /**
         * This array is populated when `enableDepthSort` is set to true.
         * Each element of this array is an instance of the class DepthSortedParticle.
         */
        depthSortedParticles: DepthSortedParticle[];
        /**
         * If the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster). (Internal use only)
         */
        _bSphereOnly: boolean;
        /**
         * A number to multiply the boundind sphere radius by in order to reduce it for instance. (Internal use only)
         */
        _bSphereRadiusFactor: number;
        private _scene;
        private _positions;
        private _indices;
        private _normals;
        private _colors;
        private _uvs;
        private _indices32;
        private _positions32;
        private _normals32;
        private _fixedNormal32;
        private _colors32;
        private _uvs32;
        private _index;
        private _updatable;
        private _pickable;
        private _isVisibilityBoxLocked;
        private _alwaysVisible;
        private _depthSort;
        private _shapeCounter;
        private _copy;
        private _shape;
        private _shapeUV;
        private _color;
        private _computeParticleColor;
        private _computeParticleTexture;
        private _computeParticleRotation;
        private _computeParticleVertex;
        private _computeBoundingBox;
        private _depthSortParticles;
        private _cam_axisZ;
        private _cam_axisY;
        private _cam_axisX;
        private _axisZ;
        private _camera;
        private _particle;
        private _camDir;
        private _camInvertedPosition;
        private _rotMatrix;
        private _invertMatrix;
        private _rotated;
        private _quaternion;
        private _vertex;
        private _normal;
        private _yaw;
        private _pitch;
        private _roll;
        private _halfroll;
        private _halfpitch;
        private _halfyaw;
        private _sinRoll;
        private _cosRoll;
        private _sinPitch;
        private _cosPitch;
        private _sinYaw;
        private _cosYaw;
        private _mustUnrotateFixedNormals;
        private _minimum;
        private _maximum;
        private _minBbox;
        private _maxBbox;
        private _particlesIntersect;
        private _depthSortFunction;
        private _needs32Bits;
        private _pivotBackTranslation;
        private _scaledPivot;
        private _particleHasParent;
        private _parent;
        /**
         * Creates a SPS (Solid Particle System) object.
         * @param name (String) is the SPS name, this will be the underlying mesh name.
         * @param scene (Scene) is the scene in which the SPS is added.
         * @param updatable (optional boolean, default true) : if the SPS must be updatable or immutable.
         * @param isPickable (optional boolean, default false) : if the solid particles must be pickable.
         * @param enableDepthSort (optional boolean, default false) : if the solid particles must be sorted in the geometry according to their distance to the camera.
         * @param particleIntersection (optional boolean, default false) : if the solid particle intersections must be computed.
         * @param boundingSphereOnly (optional boolean, default false) : if the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster).
         * @param bSphereRadiusFactor (optional float, default 1.0) : a number to multiply the boundind sphere radius by in order to reduce it for instance.
         * @example bSphereRadiusFactor = 1.0 / Math.sqrt(3.0) => the bounding sphere exactly matches a spherical mesh.
         */
        constructor(name: string, scene: Scene, options?: {
            updatable?: boolean;
            isPickable?: boolean;
            enableDepthSort?: boolean;
            particleIntersection?: boolean;
            boundingSphereOnly?: boolean;
            bSphereRadiusFactor?: number;
        });
        /**
         * Builds the SPS underlying mesh. Returns a standard Mesh.
         * If no model shape was added to the SPS, the returned mesh is just a single triangular plane.
         * @returns the created mesh
         */
        buildMesh(): Mesh;
        /**
         * Digests the mesh and generates as many solid particles in the system as wanted. Returns the SPS.
         * These particles will have the same geometry than the mesh parts and will be positioned at the same localisation than the mesh original places.
         * Thus the particles generated from `digest()` have their property `position` set yet.
         * @param mesh ( Mesh ) is the mesh to be digested
         * @param options {facetNb} (optional integer, default 1) is the number of mesh facets per particle, this parameter is overriden by the parameter `number` if any
         * {delta} (optional integer, default 0) is the random extra number of facets per particle , each particle will have between `facetNb` and `facetNb + delta` facets
         * {number} (optional positive integer) is the wanted number of particles : each particle is built with `mesh_total_facets / number` facets
         * @returns the current SPS
         */
        digest(mesh: Mesh, options?: {
            facetNb?: number;
            number?: number;
            delta?: number;
        }): SolidParticleSystem;
        private _unrotateFixedNormals();
        private _resetCopy();
        private _meshBuilder(p, shape, positions, meshInd, indices, meshUV, uvs, meshCol, colors, meshNor, normals, idx, idxInShape, options);
        private _posToShape(positions);
        private _uvsToShapeUV(uvs);
        private _addParticle(idx, idxpos, idxind, model, shapeId, idxInShape, bInfo?);
        /**
         * Adds some particles to the SPS from the model shape. Returns the shape id.
         * Please read the doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#create-an-immutable-sps
         * @param mesh is any Mesh object that will be used as a model for the solid particles.
         * @param nb (positive integer) the number of particles to be created from this model
         * @param options {positionFunction} is an optional javascript function to called for each particle on SPS creation.
         * {vertexFunction} is an optional javascript function to called for each vertex of each particle on SPS creation
         * @returns the number of shapes in the system
         */
        addShape(mesh: Mesh, nb: number, options?: {
            positionFunction?: any;
            vertexFunction?: any;
        }): number;
        private _rebuildParticle(particle);
        /**
         * Rebuilds the whole mesh and updates the VBO : custom positions and vertices are recomputed if needed.
         * @returns the SPS.
         */
        rebuildMesh(): SolidParticleSystem;
        /**
         *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.
         *  This method calls `updateParticle()` for each particle of the SPS.
         *  For an animated SPS, it is usually called within the render loop.
         * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_
         * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_
         * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_
         * @returns the SPS.
         */
        setParticles(start?: number, end?: number, update?: boolean): SolidParticleSystem;
        private _quaternionRotationYPR();
        private _quaternionToRotationMatrix();
        /**
        * Disposes the SPS.
        */
        dispose(): void;
        /**
         * Visibilty helper : Recomputes the visible size according to the mesh bounding box
         * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
         * @returns the SPS.
         */
        refreshVisibleSize(): SolidParticleSystem;
        /**
         * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.
         * @param size the size (float) of the visibility box
         * note : this doesn't lock the SPS mesh bounding box.
         * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
         */
        setVisibilityBox(size: number): void;
        /**
         * Gets whether the SPS as always visible or not
         * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
         */
        /**
         * Sets the SPS as always visible or not
         * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
         */
        isAlwaysVisible: boolean;
        /**
         * Gets if the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.
         * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
         */
        /**
         * Sets the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.
         * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
         */
        isVisibilityBoxLocked: boolean;
        /**
         * Gets if `setParticles()` computes the particle rotations or not.
         * Default value : true. The SPS is faster when it's set to false.
         * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.
         */
        /**
         * Tells to `setParticles()` to compute the particle rotations or not.
         * Default value : true. The SPS is faster when it's set to false.
         * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.
         */
        computeParticleRotation: boolean;
        /**
         * Gets if `setParticles()` computes the particle colors or not.
         * Default value : true. The SPS is faster when it's set to false.
         * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.
         */
        /**
         * Tells to `setParticles()` to compute the particle colors or not.
         * Default value : true. The SPS is faster when it's set to false.
         * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.
         */
        computeParticleColor: boolean;
        /**
         * Gets if `setParticles()` computes the particle textures or not.
         * Default value : true. The SPS is faster when it's set to false.
         * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.
         */
        computeParticleTexture: boolean;
        /**
         * Gets if `setParticles()` calls the vertex function for each vertex of each particle, or not.
         * Default value : false. The SPS is faster when it's set to false.
         * Note : the particle custom vertex positions aren't stored values.
         */
        /**
         * Tells to `setParticles()` to call the vertex function for each vertex of each particle, or not.
         * Default value : false. The SPS is faster when it's set to false.
         * Note : the particle custom vertex positions aren't stored values.
         */
        computeParticleVertex: boolean;
        /**
         * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.
         */
        /**
         * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.
         */
        computeBoundingBox: boolean;
        /**
         * Gets if `setParticles()` sorts or not the distance between each particle and the camera.
         * Skipped when `enableDepthSort` is set to `false` (default) at construction time.
         * Default : `true`
         */
        /**
         * Tells to `setParticles()` to sort or not the distance between each particle and the camera.
         * Skipped when `enableDepthSort` is set to `false` (default) at construction time.
         * Default : `true`
         */
        depthSortParticles: boolean;
        /**
         * This function does nothing. It may be overwritten to set all the particle first values.
         * The SPS doesn't call this function, you may have to call it by your own.
         * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management
         */
        initParticles(): void;
        /**
         * This function does nothing. It may be overwritten to recycle a particle.
         * The SPS doesn't call this function, you may have to call it by your own.
         * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management
         * @param particle The particle to recycle
         * @returns the recycled particle
         */
        recycleParticle(particle: SolidParticle): SolidParticle;
        /**
         * Updates a particle : this function should  be overwritten by the user.
         * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.
         * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management
         * @example : just set a particle position or velocity and recycle conditions
         * @param particle The particle to update
         * @returns the updated particle
         */
        updateParticle(particle: SolidParticle): SolidParticle;
        /**
         * Updates a vertex of a particle : it can be overwritten by the user.
         * This will be called on each vertex particle by `setParticles()` if `computeParticleVertex` is set to true only.
         * @param particle the current particle
         * @param vertex the current index of the current particle
         * @param pt the index of the current vertex in the particle shape
         * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#update-each-particle-shape
         * @example : just set a vertex particle position
         * @returns the updated vertex
         */
        updateParticleVertex(particle: SolidParticle, vertex: Vector3, pt: number): Vector3;
        /**
         * This will be called before any other treatment by `setParticles()` and will be passed three parameters.
         * This does nothing and may be overwritten by the user.
         * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
         * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
         * @param update the boolean update value actually passed to setParticles()
         */
        beforeUpdateParticles(start?: number, stop?: number, update?: boolean): void;
        /**
         * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.
         * This will be passed three parameters.
         * This does nothing and may be overwritten by the user.
         * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
         * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
         * @param update the boolean update value actually passed to setParticles()
         */
        afterUpdateParticles(start?: number, stop?: number, update?: boolean): void;
    }
}

declare module BABYLON {
    interface PhysicsImpostorJoint {
        mainImpostor: PhysicsImpostor;
        connectedImpostor: PhysicsImpostor;
        joint: PhysicsJoint;
    }
    class PhysicsEngine {
        private _physicsPlugin;
        gravity: Vector3;
        constructor(gravity: Nullable<Vector3>, _physicsPlugin?: IPhysicsEnginePlugin);
        setGravity(gravity: Vector3): void;
        /**
         * Set the time step of the physics engine.
         * default is 1/60.
         * To slow it down, enter 1/600 for example.
         * To speed it up, 1/30
         * @param {number} newTimeStep the new timestep to apply to this world.
         */
        setTimeStep(newTimeStep?: number): void;
        /**
         * Get the time step of the physics engine.
         */
        getTimeStep(): number;
        dispose(): void;
        getPhysicsPluginName(): string;
        static Epsilon: number;
        private _impostors;
        private _joints;
        /**
         * Adding a new impostor for the impostor tracking.
         * This will be done by the impostor itself.
         * @param {PhysicsImpostor} impostor the impostor to add
         */
        addImpostor(impostor: PhysicsImpostor): void;
        /**
         * Remove an impostor from the engine.
         * This impostor and its mesh will not longer be updated by the physics engine.
         * @param {PhysicsImpostor} impostor the impostor to remove
         */
        removeImpostor(impostor: PhysicsImpostor): void;
        /**
         * Add a joint to the physics engine
         * @param {PhysicsImpostor} mainImpostor the main impostor to which the joint is added.
         * @param {PhysicsImpostor} connectedImpostor the impostor that is connected to the main impostor using this joint
         * @param {PhysicsJoint} the joint that will connect both impostors.
         */
        addJoint(mainImpostor: PhysicsImpostor, connectedImpostor: PhysicsImpostor, joint: PhysicsJoint): void;
        removeJoint(mainImpostor: PhysicsImpostor, connectedImpostor: PhysicsImpostor, joint: PhysicsJoint): void;
        /**
         * Called by the scene. no need to call it.
         */
        _step(delta: number): void;
        getPhysicsPlugin(): IPhysicsEnginePlugin;
        getImpostors(): Array<PhysicsImpostor>;
        getImpostorForPhysicsObject(object: IPhysicsEnabledObject): Nullable<PhysicsImpostor>;
        getImpostorWithPhysicsBody(body: any): Nullable<PhysicsImpostor>;
    }
    interface IPhysicsEnginePlugin {
        world: any;
        name: string;
        setGravity(gravity: Vector3): void;
        setTimeStep(timeStep: number): void;
        getTimeStep(): number;
        executeStep(delta: number, impostors: Array<PhysicsImpostor>): void;
        applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3): void;
        applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3): void;
        generatePhysicsBody(impostor: PhysicsImpostor): void;
        removePhysicsBody(impostor: PhysicsImpostor): void;
        generateJoint(joint: PhysicsImpostorJoint): void;
        removeJoint(joint: PhysicsImpostorJoint): void;
        isSupported(): boolean;
        setTransformationFromPhysicsBody(impostor: PhysicsImpostor): void;
        setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion): void;
        setLinearVelocity(impostor: PhysicsImpostor, velocity: Nullable<Vector3>): void;
        setAngularVelocity(impostor: PhysicsImpostor, velocity: Nullable<Vector3>): void;
        getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3>;
        getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3>;
        setBodyMass(impostor: PhysicsImpostor, mass: number): void;
        getBodyMass(impostor: PhysicsImpostor): number;
        getBodyFriction(impostor: PhysicsImpostor): number;
        setBodyFriction(impostor: PhysicsImpostor, friction: number): void;
        getBodyRestitution(impostor: PhysicsImpostor): number;
        setBodyRestitution(impostor: PhysicsImpostor, restitution: number): void;
        sleepBody(impostor: PhysicsImpostor): void;
        wakeUpBody(impostor: PhysicsImpostor): void;
        updateDistanceJoint(joint: PhysicsJoint, maxDistance: number, minDistance?: number): void;
        setMotor(joint: IMotorEnabledJoint, speed: number, maxForce?: number, motorIndex?: number): void;
        setLimit(joint: IMotorEnabledJoint, upperLimit: number, lowerLimit?: number, motorIndex?: number): void;
        getRadius(impostor: PhysicsImpostor): number;
        getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void;
        syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor): void;
        dispose(): void;
    }
}

declare module BABYLON {
    class PhysicsHelper {
        private _scene;
        private _physicsEngine;
        constructor(scene: Scene);
        /**
         * @param {Vector3} origin the origin of the explosion
         * @param {number} radius the explosion radius
         * @param {number} strength the explosion strength
         * @param {PhysicsRadialImpulseFalloff} falloff possible options: Constant & Linear. Defaults to Constant
         */
        applyRadialExplosionImpulse(origin: Vector3, radius: number, strength: number, falloff?: PhysicsRadialImpulseFalloff): Nullable<PhysicsRadialExplosionEvent>;
        /**
         * @param {Vector3} origin the origin of the explosion
         * @param {number} radius the explosion radius
         * @param {number} strength the explosion strength
         * @param {PhysicsRadialImpulseFalloff} falloff possible options: Constant & Linear. Defaults to Constant
         */
        applyRadialExplosionForce(origin: Vector3, radius: number, strength: number, falloff?: PhysicsRadialImpulseFalloff): Nullable<PhysicsRadialExplosionEvent>;
        /**
         * @param {Vector3} origin the origin of the explosion
         * @param {number} radius the explosion radius
         * @param {number} strength the explosion strength
         * @param {PhysicsRadialImpulseFalloff} falloff possible options: Constant & Linear. Defaults to Constant
         */
        gravitationalField(origin: Vector3, radius: number, strength: number, falloff?: PhysicsRadialImpulseFalloff): Nullable<PhysicsGravitationalFieldEvent>;
        /**
         * @param {Vector3} origin the origin of the updraft
         * @param {number} radius the radius of the updraft
         * @param {number} strength the strength of the updraft
         * @param {number} height the height of the updraft
         * @param {PhysicsUpdraftMode} updraftMode possible options: Center & Perpendicular. Defaults to Center
         */
        updraft(origin: Vector3, radius: number, strength: number, height: number, updraftMode?: PhysicsUpdraftMode): Nullable<PhysicsUpdraftEvent>;
        /**
         * @param {Vector3} origin the of the vortex
         * @param {number} radius the radius of the vortex
         * @param {number} strength the strength of the vortex
         * @param {number} height   the height of the vortex
         */
        vortex(origin: Vector3, radius: number, strength: number, height: number): Nullable<PhysicsVortexEvent>;
    }
    /***** Radial explosion *****/
    class PhysicsRadialExplosionEvent {
        private _scene;
        private _sphere;
        private _sphereOptions;
        private _rays;
        private _dataFetched;
        constructor(scene: Scene);
        /**
         * Returns the data related to the radial explosion event (sphere & rays).
         * @returns {PhysicsRadialExplosionEventData}
         */
        getData(): PhysicsRadialExplosionEventData;
        /**
         * Returns the force and contact point of the impostor or false, if the impostor is not affected by the force/impulse.
         * @param impostor
         * @param {Vector3} origin the origin of the explosion
         * @param {number} radius the explosion radius
         * @param {number} strength the explosion strength
         * @param {PhysicsRadialImpulseFalloff} falloff possible options: Constant & Linear
         * @returns {Nullable<PhysicsForceAndContactPoint>}
         */
        getImpostorForceAndContactPoint(impostor: PhysicsImpostor, origin: Vector3, radius: number, strength: number, falloff: PhysicsRadialImpulseFalloff): Nullable<PhysicsForceAndContactPoint>;
        /**
         * Disposes the sphere.
         * @param {bolean} force
         */
        dispose(force?: boolean): void;
        /*** Helpers ***/
        private _prepareSphere();
        private _intersectsWithSphere(impostor, origin, radius);
    }
    /***** Gravitational Field *****/
    class PhysicsGravitationalFieldEvent {
        private _physicsHelper;
        private _scene;
        private _origin;
        private _radius;
        private _strength;
        private _falloff;
        private _tickCallback;
        private _sphere;
        private _dataFetched;
        constructor(physicsHelper: PhysicsHelper, scene: Scene, origin: Vector3, radius: number, strength: number, falloff?: PhysicsRadialImpulseFalloff);
        /**
         * Returns the data related to the gravitational field event (sphere).
         * @returns {PhysicsGravitationalFieldEventData}
         */
        getData(): PhysicsGravitationalFieldEventData;
        /**
         * Enables the gravitational field.
         */
        enable(): void;
        /**
         * Disables the gravitational field.
         */
        disable(): void;
        /**
         * Disposes the sphere.
         * @param {bolean} force
         */
        dispose(force?: boolean): void;
        private _tick();
    }
    /***** Updraft *****/
    class PhysicsUpdraftEvent {
        private _scene;
        private _origin;
        private _radius;
        private _strength;
        private _height;
        private _updraftMode;
        private _physicsEngine;
        private _originTop;
        private _originDirection;
        private _tickCallback;
        private _cylinder;
        private _cylinderPosition;
        private _dataFetched;
        constructor(_scene: Scene, _origin: Vector3, _radius: number, _strength: number, _height: number, _updraftMode: PhysicsUpdraftMode);
        /**
         * Returns the data related to the updraft event (cylinder).
         * @returns {PhysicsUpdraftEventData}
         */
        getData(): PhysicsUpdraftEventData;
        /**
         * Enables the updraft.
         */
        enable(): void;
        /**
         * Disables the cortex.
         */
        disable(): void;
        /**
         * Disposes the sphere.
         * @param {bolean} force
         */
        dispose(force?: boolean): void;
        private getImpostorForceAndContactPoint(impostor);
        private _tick();
        /*** Helpers ***/
        private _prepareCylinder();
        private _intersectsWithCylinder(impostor);
    }
    /***** Vortex *****/
    class PhysicsVortexEvent {
        private _scene;
        private _origin;
        private _radius;
        private _strength;
        private _height;
        private _physicsEngine;
        private _originTop;
        private _centripetalForceThreshold;
        private _updraftMultiplier;
        private _tickCallback;
        private _cylinder;
        private _cylinderPosition;
        private _dataFetched;
        constructor(_scene: Scene, _origin: Vector3, _radius: number, _strength: number, _height: number);
        /**
         * Returns the data related to the vortex event (cylinder).
         * @returns {PhysicsVortexEventData}
         */
        getData(): PhysicsVortexEventData;
        /**
         * Enables the vortex.
         */
        enable(): void;
        /**
         * Disables the cortex.
         */
        disable(): void;
        /**
         * Disposes the sphere.
         * @param {bolean} force
         */
        dispose(force?: boolean): void;
        private getImpostorForceAndContactPoint(impostor);
        private _tick();
        /*** Helpers ***/
        private _prepareCylinder();
        private _intersectsWithCylinder(impostor);
    }
    /***** Enums *****/
    /**
    * The strenght of the force in correspondence to the distance of the affected object
    */
    enum PhysicsRadialImpulseFalloff {
        /** Defines that impulse is constant in strength across it's whole radius */
        Constant = 0,
        /** DEfines that impulse gets weaker if it's further from the origin */
        Linear = 1,
    }
    /**
     * The strenght of the force in correspondence to the distance of the affected object
     */
    enum PhysicsUpdraftMode {
        /** Defines that the upstream forces will pull towards the top center of the cylinder */
        Center = 0,
        /** Defines that once a impostor is inside the cylinder, it will shoot out perpendicular from the ground of the cylinder */
        Perpendicular = 1,
    }
    /***** Data interfaces *****/
    interface PhysicsForceAndContactPoint {
        force: Vector3;
        contactPoint: Vector3;
    }
    interface PhysicsRadialExplosionEventData {
        sphere: Mesh;
        rays: Array<Ray>;
    }
    interface PhysicsGravitationalFieldEventData {
        sphere: Mesh;
    }
    interface PhysicsUpdraftEventData {
        cylinder: Mesh;
    }
    interface PhysicsVortexEventData {
        cylinder: Mesh;
    }
}

declare module BABYLON {
    interface PhysicsImpostorParameters {
        mass: number;
        friction?: number;
        restitution?: number;
        nativeOptions?: any;
        ignoreParent?: boolean;
        disableBidirectionalTransformation?: boolean;
    }
    interface IPhysicsEnabledObject {
        position: Vector3;
        rotationQuaternion: Nullable<Quaternion>;
        scaling: Vector3;
        rotation?: Vector3;
        parent?: any;
        getBoundingInfo(): BoundingInfo;
        computeWorldMatrix(force: boolean): Matrix;
        getWorldMatrix?(): Matrix;
        getChildMeshes?(directDescendantsOnly?: boolean): Array<AbstractMesh>;
        getVerticesData(kind: string): Nullable<Array<number> | Float32Array>;
        getIndices?(): Nullable<IndicesArray>;
        getScene?(): Scene;
        getAbsolutePosition(): Vector3;
        getAbsolutePivotPoint(): Vector3;
        rotate(axis: Vector3, amount: number, space?: Space): TransformNode;
        translate(axis: Vector3, distance: number, space?: Space): TransformNode;
        setAbsolutePosition(absolutePosition: Vector3): TransformNode;
        getClassName(): string;
    }
    class PhysicsImpostor {
        object: IPhysicsEnabledObject;
        type: number;
        private _options;
        private _scene;
        static DEFAULT_OBJECT_SIZE: Vector3;
        static IDENTITY_QUATERNION: Quaternion;
        private _physicsEngine;
        private _physicsBody;
        private _bodyUpdateRequired;
        private _onBeforePhysicsStepCallbacks;
        private _onAfterPhysicsStepCallbacks;
        private _onPhysicsCollideCallbacks;
        private _deltaPosition;
        private _deltaRotation;
        private _deltaRotationConjugated;
        private _parent;
        private _isDisposed;
        private static _tmpVecs;
        private static _tmpQuat;
        readonly isDisposed: boolean;
        mass: number;
        friction: number;
        restitution: number;
        uniqueId: number;
        private _joints;
        constructor(object: IPhysicsEnabledObject, type: number, _options?: PhysicsImpostorParameters, _scene?: Scene | undefined);
        /**
         * This function will completly initialize this impostor.
         * It will create a new body - but only if this mesh has no parent.
         * If it has, this impostor will not be used other than to define the impostor
         * of the child mesh.
         */
        _init(): void;
        private _getPhysicsParent();
        /**
         * Should a new body be generated.
         */
        isBodyInitRequired(): boolean;
        setScalingUpdated(updated: boolean): void;
        /**
         * Force a regeneration of this or the parent's impostor's body.
         * Use under cautious - This will remove all joints already implemented.
         */
        forceUpdate(): void;
        /**
         * Gets the body that holds this impostor. Either its own, or its parent.
         */
        /**
         * Set the physics body. Used mainly by the physics engine/plugin
         */
        physicsBody: any;
        parent: Nullable<PhysicsImpostor>;
        resetUpdateFlags(): void;
        getObjectExtendSize(): Vector3;
        getObjectCenter(): Vector3;
        /**
         * Get a specific parametes from the options parameter.
         */
        getParam(paramName: string): any;
        /**
         * Sets a specific parameter in the options given to the physics plugin
         */
        setParam(paramName: string, value: number): void;
        /**
         * Specifically change the body's mass option. Won't recreate the physics body object
         */
        setMass(mass: number): void;
        getLinearVelocity(): Nullable<Vector3>;
        setLinearVelocity(velocity: Nullable<Vector3>): void;
        getAngularVelocity(): Nullable<Vector3>;
        setAngularVelocity(velocity: Nullable<Vector3>): void;
        /**
         * Execute a function with the physics plugin native code.
         * Provide a function the will have two variables - the world object and the physics body object.
         */
        executeNativeFunction(func: (world: any, physicsBody: any) => void): void;
        /**
         * Register a function that will be executed before the physics world is stepping forward.
         */
        registerBeforePhysicsStep(func: (impostor: PhysicsImpostor) => void): void;
        unregisterBeforePhysicsStep(func: (impostor: PhysicsImpostor) => void): void;
        /**
         * Register a function that will be executed after the physics step
         */
        registerAfterPhysicsStep(func: (impostor: PhysicsImpostor) => void): void;
        unregisterAfterPhysicsStep(func: (impostor: PhysicsImpostor) => void): void;
        /**
         * register a function that will be executed when this impostor collides against a different body.
         */
        registerOnPhysicsCollide(collideAgainst: PhysicsImpostor | Array<PhysicsImpostor>, func: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor) => void): void;
        unregisterOnPhysicsCollide(collideAgainst: PhysicsImpostor | Array<PhysicsImpostor>, func: (collider: PhysicsImpostor, collidedAgainst: PhysicsImpostor | Array<PhysicsImpostor>) => void): void;
        private _tmpQuat;
        private _tmpQuat2;
        getParentsRotation(): Quaternion;
        /**
         * this function is executed by the physics engine.
         */
        beforeStep: () => void;
        /**
         * this function is executed by the physics engine.
         */
        afterStep: () => void;
        /**
         * Legacy collision detection event support
         */
        onCollideEvent: Nullable<(collider: PhysicsImpostor, collidedWith: PhysicsImpostor) => void>;
        onCollide: (e: {
            body: any;
        }) => void;
        /**
         * Apply a force
         */
        applyForce(force: Vector3, contactPoint: Vector3): PhysicsImpostor;
        /**
         * Apply an impulse
         */
        applyImpulse(force: Vector3, contactPoint: Vector3): PhysicsImpostor;
        /**
         * A help function to create a joint.
         */
        createJoint(otherImpostor: PhysicsImpostor, jointType: number, jointData: PhysicsJointData): PhysicsImpostor;
        /**
         * Add a joint to this impostor with a different impostor.
         */
        addJoint(otherImpostor: PhysicsImpostor, joint: PhysicsJoint): PhysicsImpostor;
        /**
         * Will keep this body still, in a sleep mode.
         */
        sleep(): PhysicsImpostor;
        /**
         * Wake the body up.
         */
        wakeUp(): PhysicsImpostor;
        clone(newObject: IPhysicsEnabledObject): Nullable<PhysicsImpostor>;
        dispose(): void;
        setDeltaPosition(position: Vector3): void;
        setDeltaRotation(rotation: Quaternion): void;
        getBoxSizeToRef(result: Vector3): PhysicsImpostor;
        getRadius(): number;
        /**
         * Sync a bone with this impostor
         * @param bone The bone to sync to the impostor.
         * @param boneMesh The mesh that the bone is influencing.
         * @param jointPivot The pivot of the joint / bone in local space.
         * @param distToJoint Optional distance from the impostor to the joint.
         * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.
         */
        syncBoneWithImpostor(bone: Bone, boneMesh: AbstractMesh, jointPivot: Vector3, distToJoint?: number, adjustRotation?: Quaternion): void;
        /**
         * Sync impostor to a bone
         * @param bone The bone that the impostor will be synced to.
         * @param boneMesh The mesh that the bone is influencing.
         * @param jointPivot The pivot of the joint / bone in local space.
         * @param distToJoint Optional distance from the impostor to the joint.
         * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.
         * @param boneAxis Optional vector3 axis the bone is aligned with
         */
        syncImpostorWithBone(bone: Bone, boneMesh: AbstractMesh, jointPivot: Vector3, distToJoint?: number, adjustRotation?: Quaternion, boneAxis?: Vector3): void;
        static NoImpostor: number;
        static SphereImpostor: number;
        static BoxImpostor: number;
        static PlaneImpostor: number;
        static MeshImpostor: number;
        static CylinderImpostor: number;
        static ParticleImpostor: number;
        static HeightmapImpostor: number;
    }
}

declare module BABYLON {
    interface PhysicsJointData {
        mainPivot?: Vector3;
        connectedPivot?: Vector3;
        mainAxis?: Vector3;
        connectedAxis?: Vector3;
        collision?: boolean;
        nativeParams?: any;
    }
    /**
     * This is a holder class for the physics joint created by the physics plugin.
     * It holds a set of functions to control the underlying joint.
     */
    class PhysicsJoint {
        type: number;
        jointData: PhysicsJointData;
        private _physicsJoint;
        protected _physicsPlugin: IPhysicsEnginePlugin;
        constructor(type: number, jointData: PhysicsJointData);
        physicsJoint: any;
        physicsPlugin: IPhysicsEnginePlugin;
        /**
         * Execute a function that is physics-plugin specific.
         * @param {Function} func the function that will be executed.
         *                        It accepts two parameters: the physics world and the physics joint.
         */
        executeNativeFunction(func: (world: any, physicsJoint: any) => void): void;
        static DistanceJoint: number;
        static HingeJoint: number;
        static BallAndSocketJoint: number;
        static WheelJoint: number;
        static SliderJoint: number;
        static PrismaticJoint: number;
        static UniversalJoint: number;
        static Hinge2Joint: number;
        static PointToPointJoint: number;
        static SpringJoint: number;
        static LockJoint: number;
    }
    /**
     * A class representing a physics distance joint.
     */
    class DistanceJoint extends PhysicsJoint {
        constructor(jointData: DistanceJointData);
        /**
         * Update the predefined distance.
         */
        updateDistance(maxDistance: number, minDistance?: number): void;
    }
    class MotorEnabledJoint extends PhysicsJoint implements IMotorEnabledJoint {
        constructor(type: number, jointData: PhysicsJointData);
        /**
         * Set the motor values.
         * Attention, this function is plugin specific. Engines won't react 100% the same.
         * @param {number} force the force to apply
         * @param {number} maxForce max force for this motor.
         */
        setMotor(force?: number, maxForce?: number): void;
        /**
         * Set the motor's limits.
         * Attention, this function is plugin specific. Engines won't react 100% the same.
         */
        setLimit(upperLimit: number, lowerLimit?: number): void;
    }
    /**
     * This class represents a single hinge physics joint
     */
    class HingeJoint extends MotorEnabledJoint {
        constructor(jointData: PhysicsJointData);
        /**
         * Set the motor values.
         * Attention, this function is plugin specific. Engines won't react 100% the same.
         * @param {number} force the force to apply
         * @param {number} maxForce max force for this motor.
         */
        setMotor(force?: number, maxForce?: number): void;
        /**
         * Set the motor's limits.
         * Attention, this function is plugin specific. Engines won't react 100% the same.
         */
        setLimit(upperLimit: number, lowerLimit?: number): void;
    }
    /**
     * This class represents a dual hinge physics joint (same as wheel joint)
     */
    class Hinge2Joint extends MotorEnabledJoint {
        constructor(jointData: PhysicsJointData);
        /**
         * Set the motor values.
         * Attention, this function is plugin specific. Engines won't react 100% the same.
         * @param {number} force the force to apply
         * @param {number} maxForce max force for this motor.
         * @param {motorIndex} the motor's index, 0 or 1.
         */
        setMotor(force?: number, maxForce?: number, motorIndex?: number): void;
        /**
         * Set the motor limits.
         * Attention, this function is plugin specific. Engines won't react 100% the same.
         * @param {number} upperLimit the upper limit
         * @param {number} lowerLimit lower limit
         * @param {motorIndex} the motor's index, 0 or 1.
         */
        setLimit(upperLimit: number, lowerLimit?: number, motorIndex?: number): void;
    }
    interface IMotorEnabledJoint {
        physicsJoint: any;
        setMotor(force?: number, maxForce?: number, motorIndex?: number): void;
        setLimit(upperLimit: number, lowerLimit?: number, motorIndex?: number): void;
    }
    interface DistanceJointData extends PhysicsJointData {
        maxDistance: number;
    }
    interface SpringJointData extends PhysicsJointData {
        length: number;
        stiffness: number;
        damping: number;
    }
}

declare module BABYLON {
    class ReflectionProbe {
        name: string;
        private _scene;
        private _renderTargetTexture;
        private _projectionMatrix;
        private _viewMatrix;
        private _target;
        private _add;
        private _attachedMesh;
        private _invertYAxis;
        position: Vector3;
        constructor(name: string, size: number, scene: Scene, generateMipMaps?: boolean);
        samples: number;
        refreshRate: number;
        getScene(): Scene;
        readonly cubeTexture: RenderTargetTexture;
        readonly renderList: Nullable<AbstractMesh[]>;
        attachToMesh(mesh: AbstractMesh): void;
        /**
         * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
         *
         * @param renderingGroupId The rendering group id corresponding to its index
         * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
         */
        setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean): void;
        dispose(): void;
    }
}

declare module BABYLON {
    class BoundingBoxRenderer {
        frontColor: Color3;
        backColor: Color3;
        showBackLines: boolean;
        renderList: SmartArray<BoundingBox>;
        private _scene;
        private _colorShader;
        private _vertexBuffers;
        private _indexBuffer;
        constructor(scene: Scene);
        private _prepareRessources();
        private _createIndexBuffer();
        _rebuild(): void;
        reset(): void;
        render(): void;
        renderOcclusionBoundingBox(mesh: AbstractMesh): void;
        dispose(): void;
    }
}

declare module BABYLON {
    /**
     * This represents a depth renderer in Babylon.
     * A depth renderer will render to it's depth map every frame which can be displayed or used in post processing
     */
    class DepthRenderer {
        private _scene;
        private _depthMap;
        private _effect;
        private _cachedDefines;
        private _camera;
        /**
         * Instantiates a depth renderer
         * @param scene The scene the renderer belongs to
         * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)
         * @param camera The camera to be used to render the depth map (default: scene's active camera)
         */
        constructor(scene: Scene, type?: number, camera?: Nullable<Camera>);
        /**
         * Creates the depth rendering effect and checks if the effect is ready.
         * @param subMesh The submesh to be used to render the depth map of
         * @param useInstances If multiple world instances should be used
         * @returns if the depth renderer is ready to render the depth map
         */
        isReady(subMesh: SubMesh, useInstances: boolean): boolean;
        /**
         * Gets the texture which the depth map will be written to.
         * @returns The depth map texture
         */
        getDepthMap(): RenderTargetTexture;
        /**
         * Disposes of the depth renderer.
         */
        dispose(): void;
    }
}

declare module BABYLON {
    class EdgesRenderer {
        edgesWidthScalerForOrthographic: number;
        edgesWidthScalerForPerspective: number;
        private _source;
        private _linesPositions;
        private _linesNormals;
        private _linesIndices;
        private _epsilon;
        private _indicesCount;
        private _lineShader;
        private _ib;
        private _buffers;
        private _checkVerticesInsteadOfIndices;
        constructor(source: AbstractMesh, epsilon?: number, checkVerticesInsteadOfIndices?: boolean);
        private _prepareRessources();
        _rebuild(): void;
        dispose(): void;
        private _processEdgeForAdjacencies(pa, pb, p0, p1, p2);
        private _processEdgeForAdjacenciesWithVertices(pa, pb, p0, p1, p2);
        private _checkEdge(faceIndex, edge, faceNormals, p0, p1);
        _generateEdgesLines(): void;
        render(): void;
    }
}

declare module BABYLON {
    /**
     * This renderer is helpfull to fill one of the render target with a geometry buffer.
     */
    class GeometryBufferRenderer {
        private _scene;
        private _multiRenderTarget;
        private _ratio;
        private _enablePosition;
        protected _effect: Effect;
        protected _cachedDefines: string;
        /**
         * Set the render list (meshes to be rendered) used in the G buffer.
         */
        renderList: Mesh[];
        /**
         * Gets wether or not G buffer are supported by the running hardware.
         * This requires draw buffer supports
         */
        readonly isSupported: boolean;
        /**
         * Gets wether or not position are enabled for the G buffer.
         */
        /**
         * Sets wether or not position are enabled for the G buffer.
         */
        enablePosition: boolean;
        /**
         * Gets the scene associated with the buffer.
         */
        readonly scene: Scene;
        /**
         * Gets the ratio used by the buffer during its creation.
         * How big is the buffer related to the main canvas.
         */
        readonly ratio: number;
        /**
         * Creates a new G Buffer for the scene
         * @param scene The scene the buffer belongs to
         * @param ratio How big is the buffer related to the main canvas.
         */
        constructor(scene: Scene, ratio?: number);
        /**
         * Checks wether everything is ready to render a submesh to the G buffer.
         * @param subMesh the submesh to check readiness for
         * @param useInstances is the mesh drawn using instance or not
         * @returns true if ready otherwise false
         */
        isReady(subMesh: SubMesh, useInstances: boolean): boolean;
        /**
         * Gets the current underlying G Buffer.
         * @returns the buffer
         */
        getGBuffer(): MultiRenderTarget;
        /**
         * Gets the number of samples used to render the buffer (anti aliasing).
         */
        /**
         * Sets the number of samples used to render the buffer (anti aliasing).
         */
        samples: number;
        /**
         * Disposes the renderer and frees up associated resources.
         */
        dispose(): void;
        protected _createRenderTargets(): void;
    }
}

declare module BABYLON {
    class OutlineRenderer {
        private _scene;
        private _effect;
        private _cachedDefines;
        zOffset: number;
        constructor(scene: Scene);
        render(subMesh: SubMesh, batch: _InstancesBatch, useOverlay?: boolean): void;
        isReady(subMesh: SubMesh, useInstances: boolean): boolean;
    }
}

declare module BABYLON {
    class RenderingGroup {
        index: number;
        private _scene;
        private _opaqueSubMeshes;
        private _transparentSubMeshes;
        private _alphaTestSubMeshes;
        private _depthOnlySubMeshes;
        private _particleSystems;
        private _spriteManagers;
        private _opaqueSortCompareFn;
        private _alphaTestSortCompareFn;
        private _transparentSortCompareFn;
        private _renderOpaque;
        private _renderAlphaTest;
        private _renderTransparent;
        private _edgesRenderers;
        onBeforeTransparentRendering: () => void;
        /**
         * Set the opaque sort comparison function.
         * If null the sub meshes will be render in the order they were created
         */
        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>;
        /**
         * Set the alpha test sort comparison function.
         * If null the sub meshes will be render in the order they were created
         */
        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>;
        /**
         * Set the transparent sort comparison function.
         * If null the sub meshes will be render in the order they were created
         */
        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>;
        /**
         * Creates a new rendering group.
         * @param index The rendering group index
         * @param opaqueSortCompareFn The opaque sort comparison function. If null no order is applied
         * @param alphaTestSortCompareFn The alpha test sort comparison function. If null no order is applied
         * @param transparentSortCompareFn The transparent sort comparison function. If null back to front + alpha index sort is applied
         */
        constructor(index: number, scene: Scene, opaqueSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>, alphaTestSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>, transparentSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>);
        /**
         * Render all the sub meshes contained in the group.
         * @param customRenderFunction Used to override the default render behaviour of the group.
         * @returns true if rendered some submeshes.
         */
        render(customRenderFunction: Nullable<(opaqueSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>) => void>, renderSprites: boolean, renderParticles: boolean, activeMeshes: Nullable<AbstractMesh[]>): void;
        /**
         * Renders the opaque submeshes in the order from the opaqueSortCompareFn.
         * @param subMeshes The submeshes to render
         */
        private renderOpaqueSorted(subMeshes);
        /**
         * Renders the opaque submeshes in the order from the alphatestSortCompareFn.
         * @param subMeshes The submeshes to render
         */
        private renderAlphaTestSorted(subMeshes);
        /**
         * Renders the opaque submeshes in the order from the transparentSortCompareFn.
         * @param subMeshes The submeshes to render
         */
        private renderTransparentSorted(subMeshes);
        /**
         * Renders the submeshes in a specified order.
         * @param subMeshes The submeshes to sort before render
         * @param sortCompareFn The comparison function use to sort
         * @param cameraPosition The camera position use to preprocess the submeshes to help sorting
         * @param transparent Specifies to activate blending if true
         */
        private static renderSorted(subMeshes, sortCompareFn, camera, transparent);
        /**
         * Renders the submeshes in the order they were dispatched (no sort applied).
         * @param subMeshes The submeshes to render
         */
        private static renderUnsorted(subMeshes);
        /**
         * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
         * are rendered back to front if in the same alpha index.
         *
         * @param a The first submesh
         * @param b The second submesh
         * @returns The result of the comparison
         */
        static defaultTransparentSortCompare(a: SubMesh, b: SubMesh): number;
        /**
         * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
         * are rendered back to front.
         *
         * @param a The first submesh
         * @param b The second submesh
         * @returns The result of the comparison
         */
        static backToFrontSortCompare(a: SubMesh, b: SubMesh): number;
        /**
         * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
         * are rendered front to back (prevent overdraw).
         *
         * @param a The first submesh
         * @param b The second submesh
         * @returns The result of the comparison
         */
        static frontToBackSortCompare(a: SubMesh, b: SubMesh): number;
        /**
         * Resets the different lists of submeshes to prepare a new frame.
         */
        prepare(): void;
        dispose(): void;
        /**
         * Inserts the submesh in its correct queue depending on its material.
         * @param subMesh The submesh to dispatch
         * @param [mesh] Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.
         * @param [material] Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.
         */
        dispatch(subMesh: SubMesh, mesh?: AbstractMesh, material?: Nullable<Material>): void;
        dispatchSprites(spriteManager: SpriteManager): void;
        dispatchParticles(particleSystem: IParticleSystem): void;
        private _renderParticles(activeMeshes);
        private _renderSprites();
    }
}

declare module BABYLON {
    class RenderingManager {
        /**
         * The max id used for rendering groups (not included)
         */
        static MAX_RENDERINGGROUPS: number;
        /**
         * The min id used for rendering groups (included)
         */
        static MIN_RENDERINGGROUPS: number;
        /**
         * Used to globally prevent autoclearing scenes.
         */
        static AUTOCLEAR: boolean;
        private _scene;
        private _renderingGroups;
        private _depthStencilBufferAlreadyCleaned;
        private _autoClearDepthStencil;
        private _customOpaqueSortCompareFn;
        private _customAlphaTestSortCompareFn;
        private _customTransparentSortCompareFn;
        private _renderinGroupInfo;
        constructor(scene: Scene);
        private _clearDepthStencilBuffer(depth?, stencil?);
        render(customRenderFunction: Nullable<(opaqueSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>) => void>, activeMeshes: Nullable<AbstractMesh[]>, renderParticles: boolean, renderSprites: boolean): void;
        reset(): void;
        dispose(): void;
        /**
         * Clear the info related to rendering groups preventing retention points during dispose.
         */
        freeRenderingGroups(): void;
        private _prepareRenderingGroup(renderingGroupId);
        dispatchSprites(spriteManager: SpriteManager): void;
        dispatchParticles(particleSystem: IParticleSystem): void;
        /**
         * @param subMesh The submesh to dispatch
         * @param [mesh] Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.
         * @param [material] Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.
         */
        dispatch(subMesh: SubMesh, mesh?: AbstractMesh, material?: Nullable<Material>): void;
        /**
         * Overrides the default sort function applied in the renderging group to prepare the meshes.
         * This allowed control for front to back rendering or reversly depending of the special needs.
         *
         * @param renderingGroupId The rendering group id corresponding to its index
         * @param opaqueSortCompareFn The opaque queue comparison function use to sort.
         * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.
         * @param transparentSortCompareFn The transparent queue comparison function use to sort.
         */
        setRenderingOrder(renderingGroupId: number, opaqueSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>, alphaTestSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>, transparentSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>): void;
        /**
         * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
         *
         * @param renderingGroupId The rendering group id corresponding to its index
         * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
         * @param depth Automatically clears depth between groups if true and autoClear is true.
         * @param stencil Automatically clears stencil between groups if true and autoClear is true.
         */
        setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean, depth?: boolean, stencil?: boolean): void;
    }
}

declare module BABYLON {
    /**
     * Postprocess used to generate anaglyphic rendering
     */
    class AnaglyphPostProcess extends PostProcess {
        private _passedProcess;
        /**
         * Creates a new AnaglyphPostProcess
         * @param name defines postprocess name
         * @param options defines creation options or target ratio scale
         * @param rigCameras defines cameras using this postprocess
         * @param samplingMode defines required sampling mode (BABYLON.Texture.NEAREST_SAMPLINGMODE by default)
         * @param engine defines hosting engine
         * @param reusable defines if the postprocess will be reused multiple times per frame
         */
        constructor(name: string, options: number | PostProcessOptions, rigCameras: Camera[], samplingMode?: number, engine?: Engine, reusable?: boolean);
    }
}

declare module BABYLON {
    class BlackAndWhitePostProcess extends PostProcess {
        degree: number;
        constructor(name: string, options: number | PostProcessOptions, camera: Camera, samplingMode?: number, engine?: Engine, reusable?: boolean);
    }
}

declare module BABYLON {
    /**
     * The bloom effect spreads bright areas of an image to simulate artifacts seen in cameras
     */
    class BloomEffect extends PostProcessRenderEffect {
        private bloomScale;
        /**
         * Internal
         */
        _effects: Array<PostProcess>;
        /**
         * Internal
         */
        _downscale: ExtractHighlightsPostProcess;
        private _blurX;
        private _blurY;
        private _merge;
        /**
         * The luminance threshold to find bright areas of the image to bloom.
         */
        threshold: number;
        /**
         * The strength of the bloom.
         */
        weight: number;
        /**
         * Specifies the size of the bloom blur kernel, relative to the final output size
         */
        kernel: number;
        /**
         * Creates a new instance of @see BloomEffect
         * @param scene The scene the effect belongs to.
         * @param bloomScale The ratio of the blur texture to the input texture that should be used to compute the bloom.
         * @param bloomKernel The size of the kernel to be used when applying the blur.
         * @param bloomWeight The the strength of bloom.
         * @param pipelineTextureType The type of texture to be used when performing the post processing.
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(scene: Scene, bloomScale: number, bloomWeight: number, bloomKernel: number, pipelineTextureType?: number, blockCompilation?: boolean);
        /**
         * Disposes each of the internal effects for a given camera.
         * @param camera The camera to dispose the effect on.
         */
        disposeEffects(camera: Camera): void;
        /**
         * Internal
         */
        _updateEffects(): void;
        /**
         * Internal
         * @returns if all the contained post processes are ready.
         */
        _isReady(): boolean;
    }
}

declare module BABYLON {
    /**
     * The BloomMergePostProcess merges blurred images with the original based on the values of the circle of confusion.
     */
    class BloomMergePostProcess extends PostProcess {
        /** Weight of the bloom to be added to the original input. */ weight: number;
        /**
         * Creates a new instance of @see BloomMergePostProcess
         * @param name The name of the effect.
         * @param originalFromInput Post process which's input will be used for the merge.
         * @param blurred Blurred highlights post process which's output will be used.
         * @param weight Weight of the bloom to be added to the original input.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, originalFromInput: PostProcess, blurred: PostProcess, /** Weight of the bloom to be added to the original input. */ weight: number, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
    }
}

declare module BABYLON {
    /**
     * The Blur Post Process which blurs an image based on a kernel and direction.
     * Can be used twice in x and y directions to perform a guassian blur in two passes.
     */
    class BlurPostProcess extends PostProcess {
        /** The direction in which to blur the image. */ direction: Vector2;
        private blockCompilation;
        protected _kernel: number;
        protected _idealKernel: number;
        protected _packedFloat: boolean;
        private _staticDefines;
        /**
         * Gets the length in pixels of the blur sample region
         */
        /**
         * Sets the length in pixels of the blur sample region
         */
        kernel: number;
        /**
         * Gets wether or not the blur is unpacking/repacking floats
         */
        /**
         * Sets wether or not the blur needs to unpack/repack floats
         */
        packedFloat: boolean;
        /**
         * Creates a new instance BlurPostProcess
         * @param name The name of the effect.
         * @param direction The direction in which to blur the image.
         * @param kernel The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.
         * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, /** The direction in which to blur the image. */ direction: Vector2, kernel: number, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, defines?: string, blockCompilation?: boolean);
        /**
         * Updates the effect with the current post process compile time values and recompiles the shader.
         * @param defines Define statements that should be added at the beginning of the shader. (default: null)
         * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)
         * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)
         * @param indexParameters The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx
         * @param onCompiled Called when the shader has been compiled.
         * @param onError Called if there is an error when compiling a shader.
         */
        updateEffect(defines?: Nullable<string>, uniforms?: Nullable<string[]>, samplers?: Nullable<string[]>, indexParameters?: any, onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void): void;
        protected _updateParameters(onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void): void;
        /**
         * Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.
         * Other odd kernels optimize correctly but require proportionally more samples, even kernels are
         * possible but will produce minor visual artifacts. Since each new kernel requires a new shader we
         * want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.
         * The gaps between physical kernels are compensated for in the weighting of the samples
         * @param idealKernel Ideal blur kernel.
         * @return Nearest best kernel.
         */
        protected _nearestBestKernel(idealKernel: number): number;
        /**
         * Calculates the value of a Gaussian distribution with sigma 3 at a given point.
         * @param x The point on the Gaussian distribution to sample.
         * @return the value of the Gaussian function at x.
         */
        protected _gaussianWeight(x: number): number;
        /**
          * Generates a string that can be used as a floating point number in GLSL.
          * @param x Value to print.
          * @param decimalFigures Number of decimal places to print the number to (excluding trailing 0s).
          * @return GLSL float string.
          */
        protected _glslFloat(x: number, decimalFigures?: number): string;
    }
}

declare module BABYLON {
    /**
     * The ChromaticAberrationPostProcess separates the rgb channels in an image to produce chromatic distortion around the edges of the screen
     */
    class ChromaticAberrationPostProcess extends PostProcess {
        /**
         * The amount of seperation of rgb channels (default: 30)
         */
        aberrationAmount: number;
        /**
         * The amount the effect will increase for pixels closer to the edge of the screen. (default: 0)
         */
        radialIntensity: number;
        /**
         * The normilized direction in which the rgb channels should be seperated. If set to 0,0 radial direction will be used. (default: Vector2(0.707,0.707))
         */
        direction: Vector2;
        /**
         * The center position where the radialIntensity should be around. [0.5,0.5 is center of screen, 1,1 is top right corder] (default: Vector2(0.5 ,0.5))
         */
        centerPosition: Vector2;
        /**
         * Creates a new instance ChromaticAberrationPostProcess
         * @param name The name of the effect.
         * @param screenWidth The width of the screen to apply the effect on.
         * @param screenHeight The height of the screen to apply the effect on.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, screenWidth: number, screenHeight: number, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
    }
}

declare module BABYLON {
    /**
     * The CircleOfConfusionPostProcess computes the circle of confusion value for each pixel given required lens parameters. See https://en.wikipedia.org/wiki/Circle_of_confusion
     */
    class CircleOfConfusionPostProcess extends PostProcess {
        /**
         * Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diamater of the resulting aperture can be computed by lensSize/fStop.
         */
        lensSize: number;
        /**
         * F-Stop of the effect's camera. The diamater of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)
         */
        fStop: number;
        /**
         * Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)
         */
        focusDistance: number;
        /**
         * Focal length of the effect's camera in scene units/1000 (eg. millimeter). (default: 50)
         */
        focalLength: number;
        private _depthTexture;
        /**
         * Creates a new instance CircleOfConfusionPostProcess
         * @param name The name of the effect.
         * @param depthTexture The depth texture of the scene to compute the circle of confusion. This must be set in order for this to function but may be set after initialization if needed.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, depthTexture: Nullable<RenderTargetTexture>, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
        /**
         * Depth texture to be used to compute the circle of confusion. This must be set here or in the constructor in order for the post process to function.
         */
        depthTexture: RenderTargetTexture;
    }
}

declare module BABYLON {
    class ColorCorrectionPostProcess extends PostProcess {
        private _colorTableTexture;
        constructor(name: string, colorTableUrl: string, options: number | PostProcessOptions, camera: Camera, samplingMode?: number, engine?: Engine, reusable?: boolean);
    }
}

declare module BABYLON {
    /**
     * The ConvolutionPostProcess applies a 3x3 kernel to every pixel of the
     * input texture to perform effects such as edge detection or sharpening
     * See http://en.wikipedia.org/wiki/Kernel_(image_processing)
     */
    class ConvolutionPostProcess extends PostProcess {
        /** Array of 9 values corrisponding to the 3x3 kernel to be applied */ kernel: number[];
        /**
         * Creates a new instance ConvolutionPostProcess
         * @param name The name of the effect.
         * @param kernel Array of 9 values corrisponding to the 3x3 kernel to be applied
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         */
        constructor(name: string, /** Array of 9 values corrisponding to the 3x3 kernel to be applied */ kernel: number[], options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number);
        /**
         * Edge detection 0 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
         */
        static EdgeDetect0Kernel: number[];
        /**
         * Edge detection 1 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
         */
        static EdgeDetect1Kernel: number[];
        /**
         * Edge detection 2 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
         */
        static EdgeDetect2Kernel: number[];
        /**
         * Kernel to sharpen an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
         */
        static SharpenKernel: number[];
        /**
         * Kernel to emboss an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
         */
        static EmbossKernel: number[];
        /**
         * Kernel to blur an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
         */
        static GaussianKernel: number[];
    }
}

declare module BABYLON {
    /**
     * The DepthOfFieldBlurPostProcess applied a blur in a give direction.
     * This blur differs from the standard BlurPostProcess as it attempts to avoid blurring pixels
     * based on samples that have a large difference in distance than the center pixel.
     * See section 2.6.2 http://fileadmin.cs.lth.se/cs/education/edan35/lectures/12dof.pdf
     */
    class DepthOfFieldBlurPostProcess extends BlurPostProcess {
        direction: Vector2;
        /**
         * Creates a new instance CircleOfConfusionPostProcess
         * @param name The name of the effect.
         * @param scene The scene the effect belongs to.
         * @param direction The direction the blur should be applied.
         * @param kernel The size of the kernel used to blur.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param circleOfConfusion The circle of confusion + depth map to be used to avoid blurring accross edges
         * @param imageToBlur The image to apply the blur to (default: Current rendered frame)
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, scene: Scene, direction: Vector2, kernel: number, options: number | PostProcessOptions, camera: Nullable<Camera>, circleOfConfusion: PostProcess, imageToBlur?: Nullable<PostProcess>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
    }
}

declare module BABYLON {
    /**
     * Specifies the level of max blur that should be applied when using the depth of field effect
     */
    enum DepthOfFieldEffectBlurLevel {
        /**
         * Subtle blur
         */
        Low = 0,
        /**
         * Medium blur
         */
        Medium = 1,
        /**
         * Large blur
         */
        High = 2,
    }
    /**
     * The depth of field effect applies a blur to objects that are closer or further from where the camera is focusing.
     */
    class DepthOfFieldEffect extends PostProcessRenderEffect {
        private _circleOfConfusion;
        /**
         * Internal, blurs from high to low
         */
        _depthOfFieldBlurX: Array<DepthOfFieldBlurPostProcess>;
        private _depthOfFieldBlurY;
        private _dofMerge;
        /**
         * Internal post processes in depth of field effect
         */
        _effects: Array<PostProcess>;
        /**
         * The focal the length of the camera used in the effect in scene units/1000 (eg. millimeter)
         */
        focalLength: number;
        /**
         * F-Stop of the effect's camera. The diamater of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)
         */
        fStop: number;
        /**
         * Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)
         */
        focusDistance: number;
        /**
         * Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diamater of the resulting aperture can be computed by lensSize/fStop.
         */
        lensSize: number;
        /**
         * Creates a new instance DepthOfFieldEffect
         * @param scene The scene the effect belongs to.
         * @param depthTexture The depth texture of the scene to compute the circle of confusion.This must be set in order for this to function but may be set after initialization if needed.
         * @param pipelineTextureType The type of texture to be used when performing the post processing.
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(scene: Scene, depthTexture: Nullable<RenderTargetTexture>, blurLevel?: DepthOfFieldEffectBlurLevel, pipelineTextureType?: number, blockCompilation?: boolean);
        /**
         * Depth texture to be used to compute the circle of confusion. This must be set here or in the constructor in order for the post process to function.
         */
        depthTexture: RenderTargetTexture;
        /**
         * Disposes each of the internal effects for a given camera.
         * @param camera The camera to dispose the effect on.
         */
        disposeEffects(camera: Camera): void;
        /**
         * Internal
         */
        _updateEffects(): void;
        /**
         * Internal
         * @returns if all the contained post processes are ready.
         */
        _isReady(): boolean;
    }
}

declare module BABYLON {
    /**
     * Options to be set when merging outputs from the default pipeline.
     */
    class DepthOfFieldMergePostProcessOptions {
        /**
         * The original image to merge on top of
         */
        originalFromInput: PostProcess;
        /**
         * Parameters to perform the merge of the depth of field effect
         */
        depthOfField?: {
            circleOfConfusion: PostProcess;
            blurSteps: Array<PostProcess>;
        };
        /**
         * Parameters to perform the merge of bloom effect
         */
        bloom?: {
            blurred: PostProcess;
            weight: number;
        };
    }
    /**
     * The DepthOfFieldMergePostProcess merges blurred images with the original based on the values of the circle of confusion.
     */
    class DepthOfFieldMergePostProcess extends PostProcess {
        private blurSteps;
        /**
         * Creates a new instance of DepthOfFieldMergePostProcess
         * @param name The name of the effect.
         * @param originalFromInput Post process which's input will be used for the merge.
         * @param circleOfConfusion Circle of confusion post process which's output will be used to blur each pixel.
         * @param blurSteps Blur post processes from low to high which will be mixed with the original image.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, originalFromInput: PostProcess, circleOfConfusion: PostProcess, blurSteps: Array<PostProcess>, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
        /**
         * Updates the effect with the current post process compile time values and recompiles the shader.
         * @param defines Define statements that should be added at the beginning of the shader. (default: null)
         * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)
         * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)
         * @param indexParameters The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx
         * @param onCompiled Called when the shader has been compiled.
         * @param onError Called if there is an error when compiling a shader.
         */
        updateEffect(defines?: Nullable<string>, uniforms?: Nullable<string[]>, samplers?: Nullable<string[]>, indexParameters?: any, onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void): void;
    }
}

declare module BABYLON {
    class DisplayPassPostProcess extends PostProcess {
        constructor(name: string, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean);
    }
}

declare module BABYLON {
    /**
     * The extract highlights post process sets all pixels to black except pixels above the specified luminance threshold. Used as the first step for a bloom effect.
     */
    class ExtractHighlightsPostProcess extends PostProcess {
        /**
         * The luminance threshold, pixels below this value will be set to black.
         */
        threshold: number;
        /**
         * Internal
         */
        _exposure: number;
        /**
         * Post process which has the input texture to be used when performing highlight extraction
         */
        _inputPostProcess: Nullable<PostProcess>;
        constructor(name: string, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
    }
}

declare module BABYLON {
    class FilterPostProcess extends PostProcess {
        kernelMatrix: Matrix;
        constructor(name: string, kernelMatrix: Matrix, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean);
    }
}

declare module BABYLON {
    class FxaaPostProcess extends PostProcess {
        texelWidth: number;
        texelHeight: number;
        constructor(name: string, options: number | PostProcessOptions, camera?: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number);
        private _getDefines();
    }
}

declare module BABYLON {
    /**
     * The GrainPostProcess adds noise to the image at mid luminance levels
     */
    class GrainPostProcess extends PostProcess {
        /**
         * The intensity of the grain added (default: 30)
         */
        intensity: number;
        /**
         * If the grain should be randomized on every frame
         */
        animated: boolean;
        /**
         * Creates a new instance of @see GrainPostProcess
         * @param name The name of the effect.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
    }
}

declare module BABYLON {
    class HighlightsPostProcess extends PostProcess {
        constructor(name: string, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number);
    }
}

declare module BABYLON {
    class ImageProcessingPostProcess extends PostProcess {
        /**
         * Default configuration related to image processing available in the PBR Material.
         */
        protected _imageProcessingConfiguration: ImageProcessingConfiguration;
        /**
         * Gets the image processing configuration used either in this material.
         */
        /**
         * Sets the Default image processing configuration used either in the this material.
         *
         * If sets to null, the scene one is in use.
         */
        imageProcessingConfiguration: ImageProcessingConfiguration;
        /**
         * Keep track of the image processing observer to allow dispose and replace.
         */
        private _imageProcessingObserver;
        /**
         * Attaches a new image processing configuration to the PBR Material.
         * @param configuration
         */
        protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>, doNotBuild?: boolean): void;
        /**
         * Gets Color curves setup used in the effect if colorCurvesEnabled is set to true .
         */
        /**
         * Sets Color curves setup used in the effect if colorCurvesEnabled is set to true .
         */
        colorCurves: Nullable<ColorCurves>;
        /**
         * Gets wether the color curves effect is enabled.
         */
        /**
         * Sets wether the color curves effect is enabled.
         */
        colorCurvesEnabled: boolean;
        /**
         * Gets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.
         */
        /**
         * Sets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.
         */
        colorGradingTexture: Nullable<BaseTexture>;
        /**
         * Gets wether the color grading effect is enabled.
         */
        /**
         * Gets wether the color grading effect is enabled.
         */
        colorGradingEnabled: boolean;
        /**
         * Gets exposure used in the effect.
         */
        /**
         * Sets exposure used in the effect.
         */
        exposure: number;
        /**
         * Gets wether tonemapping is enabled or not.
         */
        /**
         * Sets wether tonemapping is enabled or not
         */
        toneMappingEnabled: boolean;
        /**
         * Gets contrast used in the effect.
         */
        /**
         * Sets contrast used in the effect.
         */
        contrast: number;
        /**
         * Gets Vignette stretch size.
         */
        /**
         * Sets Vignette stretch size.
         */
        vignetteStretch: number;
        /**
         * Gets Vignette centre X Offset.
         */
        /**
         * Sets Vignette centre X Offset.
         */
        vignetteCentreX: number;
        /**
         * Gets Vignette centre Y Offset.
         */
        /**
         * Sets Vignette centre Y Offset.
         */
        vignetteCentreY: number;
        /**
         * Gets Vignette weight or intensity of the vignette effect.
         */
        /**
         * Sets Vignette weight or intensity of the vignette effect.
         */
        vignetteWeight: number;
        /**
         * Gets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
         * if vignetteEnabled is set to true.
         */
        /**
         * Sets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
         * if vignetteEnabled is set to true.
         */
        vignetteColor: Color4;
        /**
         * Gets Camera field of view used by the Vignette effect.
         */
        /**
         * Sets Camera field of view used by the Vignette effect.
         */
        vignetteCameraFov: number;
        /**
         * Gets the vignette blend mode allowing different kind of effect.
         */
        /**
         * Sets the vignette blend mode allowing different kind of effect.
         */
        vignetteBlendMode: number;
        /**
         * Gets wether the vignette effect is enabled.
         */
        /**
         * Sets wether the vignette effect is enabled.
         */
        vignetteEnabled: boolean;
        private _fromLinearSpace;
        /**
         * Gets wether the input of the processing is in Gamma or Linear Space.
         */
        /**
         * Sets wether the input of the processing is in Gamma or Linear Space.
         */
        fromLinearSpace: boolean;
        /**
         * Defines cache preventing GC.
         */
        private _defines;
        constructor(name: string, options: number | PostProcessOptions, camera?: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, imageProcessingConfiguration?: ImageProcessingConfiguration);
        getClassName(): string;
        protected _updateParameters(): void;
        dispose(camera?: Camera): void;
    }
}

declare module BABYLON {
    class PassPostProcess extends PostProcess {
        constructor(name: string, options: number | PostProcessOptions, camera?: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
    }
}

declare module BABYLON {
    type PostProcessOptions = {
        width: number;
        height: number;
    };
    /**
     * PostProcess can be used to apply a shader to a texture after it has been rendered
     * See https://doc.babylonjs.com/how_to/how_to_use_postprocesses
     */
    class PostProcess {
        /** Name of the PostProcess. */ name: string;
        /**
        * Width of the texture to apply the post process on
        */
        width: number;
        /**
        * Height of the texture to apply the post process on
        */
        height: number;
        /**
        * Internal, reference to the location where this postprocess was output to. (Typically the texture on the next postprocess in the chain)
        */
        _outputTexture: Nullable<InternalTexture>;
        /**
        * Sampling mode used by the shader
        * See https://doc.babylonjs.com/classes/3.1/texture
        */
        renderTargetSamplingMode: number;
        /**
        * Clear color to use when screen clearing
        */
        clearColor: Color4;
        /**
        * If the buffer needs to be cleared before applying the post process. (default: true)
        * Should be set to false if shader will overwrite all previous pixels.
        */
        autoClear: boolean;
        /**
        * Type of alpha mode to use when performing the post process (default: Engine.ALPHA_DISABLE)
        */
        alphaMode: number;
        /**
        * Sets the setAlphaBlendConstants of the babylon engine
        */
        alphaConstants: Color4;
        /**
        * Animations to be used for the post processing
        */
        animations: Animation[];
        /**
         * Enable Pixel Perfect mode where texture is not scaled to be power of 2.
         * Can only be used on a single postprocess or on the last one of a chain. (default: false)
         */
        enablePixelPerfectMode: boolean;
        /**
        * Scale mode for the post process (default: Engine.SCALEMODE_FLOOR)
        */
        scaleMode: number;
        /**
        * Force textures to be a power of two (default: false)
        */
        alwaysForcePOT: boolean;
        /**
        * Number of sample textures (default: 1)
        */
        samples: number;
        /**
        * Modify the scale of the post process to be the same as the viewport (default: false)
        */
        adaptScaleToCurrentViewport: boolean;
        private _camera;
        private _scene;
        private _engine;
        private _options;
        private _reusable;
        private _textureType;
        /**
        * Smart array of input and output textures for the post process.
        */
        _textures: SmartArray<InternalTexture>;
        /**
        * The index in _textures that corresponds to the output texture.
        */
        _currentRenderTextureInd: number;
        private _effect;
        private _samplers;
        private _fragmentUrl;
        private _vertexUrl;
        private _parameters;
        private _scaleRatio;
        protected _indexParameters: any;
        private _shareOutputWithPostProcess;
        private _texelSize;
        private _forcedOutputTexture;
        /**
        * An event triggered when the postprocess is activated.
        */
        onActivateObservable: Observable<Camera>;
        private _onActivateObserver;
        /**
        * A function that is added to the onActivateObservable
        */
        onActivate: Nullable<(camera: Camera) => void>;
        /**
        * An event triggered when the postprocess changes its size.
        */
        onSizeChangedObservable: Observable<PostProcess>;
        private _onSizeChangedObserver;
        /**
        * A function that is added to the onSizeChangedObservable
        */
        onSizeChanged: (postProcess: PostProcess) => void;
        /**
        * An event triggered when the postprocess applies its effect.
        */
        onApplyObservable: Observable<Effect>;
        private _onApplyObserver;
        /**
        * A function that is added to the onApplyObservable
        */
        onApply: (effect: Effect) => void;
        /**
        * An event triggered before rendering the postprocess
        */
        onBeforeRenderObservable: Observable<Effect>;
        private _onBeforeRenderObserver;
        /**
        * A function that is added to the onBeforeRenderObservable
        */
        onBeforeRender: (effect: Effect) => void;
        /**
        * An event triggered after rendering the postprocess
        */
        onAfterRenderObservable: Observable<Effect>;
        private _onAfterRenderObserver;
        /**
        * A function that is added to the onAfterRenderObservable
        */
        onAfterRender: (efect: Effect) => void;
        /**
        * The input texture for this post process and the output texture of the previous post process. When added to a pipeline the previous post process will
        * render it's output into this texture and this texture will be used as textureSampler in the fragment shader of this post process.
        */
        inputTexture: InternalTexture;
        /**
        * Gets the camera which post process is applied to.
        * @returns The camera the post process is applied to.
        */
        getCamera(): Camera;
        /**
        * Gets the texel size of the postprocess.
        * See https://en.wikipedia.org/wiki/Texel_(graphics)
        */
        readonly texelSize: Vector2;
        /**
         * Creates a new instance PostProcess
         * @param name The name of the PostProcess.
         * @param fragmentUrl The url of the fragment shader to be used.
         * @param parameters Array of the names of uniform non-sampler2D variables that will be passed to the shader.
         * @param samplers Array of the names of uniform sampler2D variables that will be passed to the shader.
         * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param defines String of defines that will be set when running the fragment shader. (default: null)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param vertexUrl The url of the vertex shader to be used. (default: "postprocess")
         * @param indexParameters The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx
         * @param blockCompilation If the shader should not be compiled imediatly. (default: false)
         */
        constructor(/** Name of the PostProcess. */ name: string, fragmentUrl: string, parameters: Nullable<string[]>, samplers: Nullable<string[]>, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, defines?: Nullable<string>, textureType?: number, vertexUrl?: string, indexParameters?: any, blockCompilation?: boolean);
        /**
         * Gets the engine which this post process belongs to.
         * @returns The engine the post process was enabled with.
         */
        getEngine(): Engine;
        /**
         * The effect that is created when initializing the post process.
         * @returns The created effect corrisponding the the postprocess.
         */
        getEffect(): Effect;
        /**
         * To avoid multiple redundant textures for multiple post process, the output the output texture for this post process can be shared with another.
         * @param postProcess The post process to share the output with.
         * @returns This post process.
         */
        shareOutputWith(postProcess: PostProcess): PostProcess;
        /**
         * Reverses the effect of calling shareOutputWith and returns the post process back to its original state.
         * This should be called if the post process that shares output with this post process is disabled/disposed.
         */
        useOwnOutput(): void;
        /**
         * Updates the effect with the current post process compile time values and recompiles the shader.
         * @param defines Define statements that should be added at the beginning of the shader. (default: null)
         * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)
         * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)
         * @param indexParameters The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx
         * @param onCompiled Called when the shader has been compiled.
         * @param onError Called if there is an error when compiling a shader.
         */
        updateEffect(defines?: Nullable<string>, uniforms?: Nullable<string[]>, samplers?: Nullable<string[]>, indexParameters?: any, onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void): void;
        /**
         * The post process is reusable if it can be used multiple times within one frame.
         * @returns If the post process is reusable
         */
        isReusable(): boolean;
        /** invalidate frameBuffer to hint the postprocess to create a depth buffer */
        markTextureDirty(): void;
        /**
         * Activates the post process by intializing the textures to be used when executed. Notifies onActivateObservable.
         * When this post process is used in a pipeline, this is call will bind the input texture of this post process to the output of the previous.
         * @param camera The camera that will be used in the post process. This camera will be used when calling onActivateObservable.
         * @param sourceTexture The source texture to be inspected to get the width and height if not specified in the post process constructor. (default: null)
         * @param forceDepthStencil If true, a depth and stencil buffer will be generated. (default: false)
         * @returns The target texture that was bound to be written to.
         */
        activate(camera: Nullable<Camera>, sourceTexture?: Nullable<InternalTexture>, forceDepthStencil?: boolean): InternalTexture;
        /**
         * If the post process is supported.
         */
        readonly isSupported: boolean;
        /**
         * The aspect ratio of the output texture.
         */
        readonly aspectRatio: number;
        /**
         * Get a value indicating if the post-process is ready to be used
         * @returns true if the post-process is ready (shader is compiled)
         */
        isReady(): boolean;
        /**
         * Binds all textures and uniforms to the shader, this will be run on every pass.
         * @returns the effect corrisponding to this post process. Null if not compiled or not ready.
         */
        apply(): Nullable<Effect>;
        private _disposeTextures();
        /**
         * Disposes the post process.
         * @param camera The camera to dispose the post process on.
         */
        dispose(camera?: Camera): void;
    }
}

declare module BABYLON {
    /**
     * PostProcessManager is used to manage one or more post processes or post process pipelines
     * See https://doc.babylonjs.com/how_to/how_to_use_postprocesses
     */
    class PostProcessManager {
        private _scene;
        private _indexBuffer;
        private _vertexBuffers;
        /**
         * Creates a new instance PostProcess
         * @param scene The scene that the post process is associated with.
         */
        constructor(scene: Scene);
        private _prepareBuffers();
        private _buildIndexBuffer();
        /**
         * Rebuilds the vertex buffers of the manager.
         */
        _rebuild(): void;
        /**
         * Prepares a frame to be run through a post process.
         * @param sourceTexture The input texture to the post procesess. (default: null)
         * @param postProcesses An array of post processes to be run. (default: null)
         * @returns True if the post processes were able to be run.
         */
        _prepareFrame(sourceTexture?: Nullable<InternalTexture>, postProcesses?: Nullable<PostProcess[]>): boolean;
        /**
         * Manually render a set of post processes to a texture.
         * @param postProcesses An array of post processes to be run.
         * @param targetTexture The target texture to render to.
         * @param forceFullscreenViewport force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight
         */
        directRender(postProcesses: PostProcess[], targetTexture?: Nullable<InternalTexture>, forceFullscreenViewport?: boolean): void;
        /**
         * Finalize the result of the output of the postprocesses.
         * @param doNotPresent If true the result will not be displayed to the screen.
         * @param targetTexture The target texture to render to.
         * @param faceIndex The index of the face to bind the target texture to.
         * @param postProcesses The array of post processes to render.
         * @param forceFullscreenViewport force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight (default: false)
         */
        _finalizeFrame(doNotPresent?: boolean, targetTexture?: InternalTexture, faceIndex?: number, postProcesses?: Array<PostProcess>, forceFullscreenViewport?: boolean): void;
        /**
         * Disposes of the post process manager.
         */
        dispose(): void;
    }
}

declare module BABYLON {
    class RefractionPostProcess extends PostProcess {
        color: Color3;
        depth: number;
        colorLevel: number;
        private _refTexture;
        private _ownRefractionTexture;
        /**
         * Gets or sets the refraction texture
         * Please note that you are responsible for disposing the texture if you set it manually
         */
        refractionTexture: Texture;
        constructor(name: string, refractionTextureUrl: string, color: Color3, depth: number, colorLevel: number, options: number | PostProcessOptions, camera: Camera, samplingMode?: number, engine?: Engine, reusable?: boolean);
        dispose(camera: Camera): void;
    }
}

declare module BABYLON {
    /**
     * The SharpenPostProcess applies a sharpen kernel to every pixel
     * See http://en.wikipedia.org/wiki/Kernel_(image_processing)
     */
    class SharpenPostProcess extends PostProcess {
        /**
         * How much of the original color should be applied. Setting this to 0 will display edge detection. (default: 1)
         */
        colorAmount: number;
        /**
         * How much sharpness should be applied (default: 0.3)
         */
        edgeAmount: number;
        /**
         * Creates a new instance ConvolutionPostProcess
         * @param name The name of the effect.
         * @param options The required width/height ratio to downsize to before computing the render pass.
         * @param camera The camera to apply the render pass to.
         * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
         * @param engine The engine which the post process will be applied. (default: current engine)
         * @param reusable If the post process can be reused on the same frame. (default: false)
         * @param textureType Type of textures used when performing the post process. (default: 0)
         * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
         */
        constructor(name: string, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType?: number, blockCompilation?: boolean);
    }
}

declare module BABYLON {
    class StereoscopicInterlacePostProcess extends PostProcess {
        private _stepSize;
        private _passedProcess;
        constructor(name: string, rigCameras: Camera[], isStereoscopicHoriz: boolean, samplingMode?: number, engine?: Engine, reusable?: boolean);
    }
}

declare module BABYLON {
    /** Defines operator used for tonemapping */
    enum TonemappingOperator {
        /** Hable */
        Hable = 0,
        /** Reinhard */
        Reinhard = 1,
        /** HejiDawson */
        HejiDawson = 2,
        /** Photographic */
        Photographic = 3,
    }
    /**
     * Defines a post process to apply tone mapping
     */
    class TonemapPostProcess extends PostProcess {
        private _operator;
        /** Defines the required exposure adjustement */
        exposureAdjustment: number;
        /**
         * Creates a new TonemapPostProcess
         * @param name defines the name of the postprocess
         * @param _operator defines the operator to use
         * @param exposureAdjustment defines the required exposure adjustement
         * @param camera defines the camera to use (can be null)
         * @param samplingMode defines the required sampling mode (BABYLON.Texture.BILINEAR_SAMPLINGMODE by default)
         * @param engine defines the hosting engine (can be ignore if camera is set)
         * @param textureFormat defines the texture format to use (BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT by default)
         */
        constructor(name: string, _operator: TonemappingOperator, 
            /** Defines the required exposure adjustement */
            exposureAdjustment: number, camera: Camera, samplingMode?: number, engine?: Engine, textureFormat?: number);
    }
}

declare module BABYLON {
    class VolumetricLightScatteringPostProcess extends PostProcess {
        private _volumetricLightScatteringPass;
        private _volumetricLightScatteringRTT;
        private _viewPort;
        private _screenCoordinates;
        private _cachedDefines;
        /**
        * If not undefined, the mesh position is computed from the attached node position
        */
        attachedNode: {
            position: Vector3;
        };
        /**
        * Custom position of the mesh. Used if "useCustomMeshPosition" is set to "true"
        */
        customMeshPosition: Vector3;
        /**
        * Set if the post-process should use a custom position for the light source (true) or the internal mesh position (false)
        */
        useCustomMeshPosition: boolean;
        /**
        * If the post-process should inverse the light scattering direction
        */
        invert: boolean;
        /**
        * The internal mesh used by the post-process
        */
        mesh: Mesh;
        useDiffuseColor: boolean;
        /**
        * Array containing the excluded meshes not rendered in the internal pass
        */
        excludedMeshes: AbstractMesh[];
        /**
        * Controls the overall intensity of the post-process
        */
        exposure: number;
        /**
        * Dissipates each sample's contribution in range [0, 1]
        */
        decay: number;
        /**
        * Controls the overall intensity of each sample
        */
        weight: number;
        /**
        * Controls the density of each sample
        */
        density: number;
        /**
         * @constructor
         * @param {string} name - The post-process name
         * @param {any} ratio - The size of the post-process and/or internal pass (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)
         * @param {BABYLON.Camera} camera - The camera that the post-process will be attached to
         * @param {BABYLON.Mesh} mesh - The mesh used to create the light scattering
         * @param {number} samples - The post-process quality, default 100
         * @param {number} samplingMode - The post-process filtering mode
         * @param {BABYLON.Engine} engine - The babylon engine
         * @param {boolean} reusable - If the post-process is reusable
         * @param {BABYLON.Scene} scene - The constructor needs a scene reference to initialize internal components. If "camera" is null (RenderPipeline, "scene" must be provided
         */
        constructor(name: string, ratio: any, camera: Camera, mesh?: Mesh, samples?: number, samplingMode?: number, engine?: Engine, reusable?: boolean, scene?: Scene);
        getClassName(): string;
        private _isReady(subMesh, useInstances);
        /**
         * Sets the new light position for light scattering effect
         * @param {BABYLON.Vector3} The new custom light position
         */
        setCustomMeshPosition(position: Vector3): void;
        /**
         * Returns the light position for light scattering effect
         * @return {BABYLON.Vector3} The custom light position
         */
        getCustomMeshPosition(): Vector3;
        /**
         * Disposes the internal assets and detaches the post-process from the camera
         */
        dispose(camera: Camera): void;
        /**
         * Returns the render target texture used by the post-process
         * @return {BABYLON.RenderTargetTexture} The render target texture used by the post-process
         */
        getPass(): RenderTargetTexture;
        private _meshExcluded(mesh);
        private _createPass(scene, ratio);
        private _updateMeshScreenCoordinates(scene);
        /**
        * Creates a default mesh for the Volumeric Light Scattering post-process
        * @param {string} The mesh name
        * @param {BABYLON.Scene} The scene where to create the mesh
        * @return {BABYLON.Mesh} the default mesh
        */
        static CreateDefaultMesh(name: string, scene: Scene): Mesh;
    }
}

declare module BABYLON {
    class VRDistortionCorrectionPostProcess extends PostProcess {
        private _isRightEye;
        private _distortionFactors;
        private _postProcessScaleFactor;
        private _lensCenterOffset;
        private _scaleIn;
        private _scaleFactor;
        private _lensCenter;
        constructor(name: string, camera: Camera, isRightEye: boolean, vrMetrics: VRCameraMetrics);
    }
}

declare module BABYLON {
    class Sprite {
        name: string;
        position: Vector3;
        color: Color4;
        width: number;
        height: number;
        angle: number;
        cellIndex: number;
        invertU: number;
        invertV: number;
        disposeWhenFinishedAnimating: boolean;
        animations: Animation[];
        isPickable: boolean;
        actionManager: ActionManager;
        private _animationStarted;
        private _loopAnimation;
        private _fromIndex;
        private _toIndex;
        private _delay;
        private _direction;
        private _manager;
        private _time;
        private _onAnimationEnd;
        size: number;
        constructor(name: string, manager: SpriteManager);
        playAnimation(from: number, to: number, loop: boolean, delay: number, onAnimationEnd: () => void): void;
        stopAnimation(): void;
        _animate(deltaTime: number): void;
        dispose(): void;
    }
}

declare module BABYLON {
    class SpriteManager {
        name: string;
        sprites: Sprite[];
        renderingGroupId: number;
        layerMask: number;
        fogEnabled: boolean;
        isPickable: boolean;
        cellWidth: number;
        cellHeight: number;
        /**
        * An event triggered when the manager is disposed.
        */
        onDisposeObservable: Observable<SpriteManager>;
        private _onDisposeObserver;
        onDispose: () => void;
        private _capacity;
        private _spriteTexture;
        private _epsilon;
        private _scene;
        private _vertexData;
        private _buffer;
        private _vertexBuffers;
        private _indexBuffer;
        private _effectBase;
        private _effectFog;
        texture: Texture;
        constructor(name: string, imgUrl: string, capacity: number, cellSize: any, scene: Scene, epsilon?: number, samplingMode?: number);
        private _appendSpriteVertex(index, sprite, offsetX, offsetY, rowSize);
        intersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean): Nullable<PickingInfo>;
        render(): void;
        dispose(): void;
    }
}

declare module BABYLON {
    /**
     * @hidden
     **/
    class _AlphaState {
        private _isAlphaBlendDirty;
        private _isBlendFunctionParametersDirty;
        private _isBlendEquationParametersDirty;
        private _isBlendConstantsDirty;
        private _alphaBlend;
        private _blendFunctionParameters;
        private _blendEquationParameters;
        private _blendConstants;
        /**
         * Initializes the state.
         */
        constructor();
        readonly isDirty: boolean;
        alphaBlend: boolean;
        setAlphaBlendConstants(r: number, g: number, b: number, a: number): void;
        setAlphaBlendFunctionParameters(value0: number, value1: number, value2: number, value3: number): void;
        setAlphaEquationParameters(rgb: number, alpha: number): void;
        reset(): void;
        apply(gl: WebGLRenderingContext): void;
    }
}

declare module BABYLON {
    /**
     * @hidden
     **/
    class _DepthCullingState {
        private _isDepthTestDirty;
        private _isDepthMaskDirty;
        private _isDepthFuncDirty;
        private _isCullFaceDirty;
        private _isCullDirty;
        private _isZOffsetDirty;
        private _isFrontFaceDirty;
        private _depthTest;
        private _depthMask;
        private _depthFunc;
        private _cull;
        private _cullFace;
        private _zOffset;
        private _frontFace;
        /**
         * Initializes the state.
         */
        constructor();
        readonly isDirty: boolean;
        zOffset: number;
        cullFace: Nullable<number>;
        cull: Nullable<boolean>;
        depthFunc: Nullable<number>;
        depthMask: boolean;
        depthTest: boolean;
        frontFace: Nullable<number>;
        reset(): void;
        apply(gl: WebGLRenderingContext): void;
    }
}

declare module BABYLON {
    /**
     * @hidden
     **/
    class _StencilState {
        private _isStencilTestDirty;
        private _isStencilMaskDirty;
        private _isStencilFuncDirty;
        private _isStencilOpDirty;
        private _stencilTest;
        private _stencilMask;
        private _stencilFunc;
        private _stencilFuncRef;
        private _stencilFuncMask;
        private _stencilOpStencilFail;
        private _stencilOpDepthFail;
        private _stencilOpStencilDepthPass;
        readonly isDirty: boolean;
        stencilFunc: number;
        stencilFuncRef: number;
        stencilFuncMask: number;
        stencilOpStencilFail: number;
        stencilOpDepthFail: number;
        stencilOpStencilDepthPass: number;
        stencilMask: number;
        stencilTest: boolean;
        constructor();
        reset(): void;
        apply(gl: WebGLRenderingContext): void;
    }
}

declare module BABYLON {
    /**
     * Class used to evalaute queries containing `and` and `or` operators
     */
    class AndOrNotEvaluator {
        /**
         * Evaluate a query
         * @param query defines the query to evaluate
         * @param evaluateCallback defines the callback used to filter result
         * @returns true if the query matches
         */
        static Eval(query: string, evaluateCallback: (val: any) => boolean): boolean;
        private static _HandleParenthesisContent(parenthesisContent, evaluateCallback);
        private static _SimplifyNegation(booleanString);
    }
}

declare module BABYLON {
    /**
     * Defines the list of states available for a task inside a {BABYLON.AssetsManager}
     */
    enum AssetTaskState {
        /**
         * Initialization
         */
        INIT = 0,
        /**
         * Running
         */
        RUNNING = 1,
        /**
         * Done
         */
        DONE = 2,
        /**
         * Error
         */
        ERROR = 3,
    }
    /**
     * Define an abstract asset task used with a {BABYLON.AssetsManager} class to load assets into a scene
     */
    abstract class AbstractAssetTask {
        /**
         * Task name
         */ name: string;
        /**
         * Callback called when the task is successful
         */
        onSuccess: (task: any) => void;
        /**
         * Callback called when the task is not successful
         */
        onError: (task: any, message?: string, exception?: any) => void;
        /**
         * Creates a new {BABYLON.AssetsManager}
         * @param name defines the name of the task
         */
        constructor(
            /**
             * Task name
             */ name: string);
        private _isCompleted;
        private _taskState;
        private _errorObject;
        /**
         * Get if the task is completed
         */
        readonly isCompleted: boolean;
        /**
         * Gets the current state of the task
         */
        readonly taskState: AssetTaskState;
        /**
         * Gets the current error object (if task is in error)
         */
        readonly errorObject: {
            message?: string;
            exception?: any;
        };
        /**
         * Internal only
         * @hidden
         */
        _setErrorObject(message?: string, exception?: any): void;
        /**
         * Execute the current task
         * @param scene defines the scene where you want your assets to be loaded
         * @param onSuccess is a callback called when the task is successfully executed
         * @param onError is a callback called if an error occurs
         */
        run(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void;
        /**
         * Execute the current task
         * @param scene defines the scene where you want your assets to be loaded
         * @param onSuccess is a callback called when the task is successfully executed
         * @param onError is a callback called if an error occurs
         */
        runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void;
        private onErrorCallback(onError, message?, exception?);
        private onDoneCallback(onSuccess, onError);
    }
    /**
     * Define the interface used by progress events raised during assets loading
     */
    interface IAssetsProgressEvent {
        /**
         * Defines the number of remaining tasks to process
         */
        remainingCount: number;
        /**
         * Defines the total number of tasks
         */
        totalCount: number;
        /**
         * Defines the task that was just processed
         */
        task: AbstractAssetTask;
    }
    /**
     * Class used to share progress information about assets loading
     */
    class AssetsProgressEvent implements IAssetsProgressEvent {
        /**
         * Defines the number of remaining tasks to process
         */
        remainingCount: number;
        /**
         * Defines the total number of tasks
         */
        totalCount: number;
        /**
         * Defines the task that was just processed
         */
        task: AbstractAssetTask;
        /**
         * Creates a {BABYLON.AssetsProgressEvent}
         * @param remainingCount defines the number of remaining tasks to process
         * @param totalCount defines the total number of tasks
         * @param task defines the task that was just processed
         */
        constructor(remainingCount: number, totalCount: number, task: AbstractAssetTask);
    }
    /**
     * Define a task used by {BABYLON.AssetsManager} to load meshes
     */
    class MeshAssetTask extends AbstractAssetTask {
        /**
         * Defines the name of the task
         */
        name: string;
        /**
         * Defines the list of mesh's names you want to load
         */
        meshesNames: any;
        /**
         * Defines the root url to use as a base to load your meshes and associated resources
         */
        rootUrl: string;
        /**
         * Defines the filename of the scene to load from
         */
        sceneFilename: string;
        /**
         * Gets the list of loaded meshes
         */
        loadedMeshes: Array<AbstractMesh>;
        /**
         * Gets the list of loaded particle systems
         */
        loadedParticleSystems: Array<ParticleSystem>;
        /**
         * Gets the list of loaded skeletons
         */
        loadedSkeletons: Array<Skeleton>;
        /**
         * Callback called when the task is successful
         */
        onSuccess: (task: MeshAssetTask) => void;
        /**
         * Callback called when the task is successful
         */
        onError: (task: MeshAssetTask, message?: string, exception?: any) => void;
        /**
         * Creates a new {BABYLON.MeshAssetTask}
         * @param name defines the name of the task
         * @param meshesNames defines the list of mesh's names you want to load
         * @param rootUrl defines the root url to use as a base to load your meshes and associated resources
         * @param sceneFilename defines the filename of the scene to load from
         */
        constructor(
            /**
             * Defines the name of the task
             */
            name: string, 
            /**
             * Defines the list of mesh's names you want to load
             */
            meshesNames: any, 
            /**
             * Defines the root url to use as a base to load your meshes and associated resources
             */
            rootUrl: string, 
            /**
             * Defines the filename of the scene to load from
             */
            sceneFilename: string);
        /**
         * Execute the current task
         * @param scene defines the scene where you want your assets to be loaded
         * @param onSuccess is a callback called when the task is successfully executed
         * @param onError is a callback called if an error occurs
         */
        runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void;
    }
    /**
     * Define a task used by {BABYLON.AssetsManager} to load text content
     */
    class TextFileAssetTask extends AbstractAssetTask {
        /**
         * Defines the name of the task
         */
        name: string;
        /**
         * Defines the location of the file to load
         */
        url: string;
        /**
         * Gets the loaded text string
         */
        text: string;
        /**
         * Callback called when the task is successful
         */
        onSuccess: (task: TextFileAssetTask) => void;
        /**
         * Callback called when the task is successful
         */
        onError: (task: TextFileAssetTask, message?: string, exception?: any) => void;
        /**
         * Creates a new TextFileAssetTask object
         * @param name defines the name of the task
         * @param url defines the location of the file to load
         */
        constructor(
            /**
             * Defines the name of the task
             */
            name: string, 
            /**
             * Defines the location of the file to load
             */
            url: string);
        /**
         * Execute the current task
         * @param scene defines the scene where you want your assets to be loaded
         * @param onSuccess is a callback called when the task is successfully executed
         * @param onError is a callback called if an error occurs
         */
        runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void;
    }
    /**
     * Define a task used by {BABYLON.AssetsManager} to load binary data
     */
    class BinaryFileAssetTask extends AbstractAssetTask {
        /**
         * Defines the name of the task
         */
        name: string;
        /**
         * Defines the location of the file to load
         */
        url: string;
        /**
         * Gets the lodaded data (as an array buffer)
         */
        data: ArrayBuffer;
        /**
         * Callback called when the task is successful
         */
        onSuccess: (task: BinaryFileAssetTask) => void;
        /**
         * Callback called when the task is successful
         */
        onError: (task: BinaryFileAssetTask, message?: string, exception?: any) => void;
        /**
         * Creates a new BinaryFileAssetTask object
         * @param name defines the name of the new task
         * @param url defines the location of the file to load
         */
        constructor(
            /**
             * Defines the name of the task
             */
            name: string, 
            /**
             * Defines the location of the file to load
             */
            url: string);
        /**
         * Execute the current task
         * @param scene defines the scene where you want your assets to be loaded
         * @param onSuccess is a callback called when the task is successfully executed
         * @param onError is a callback called if an error occurs
         */
        runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void;
    }
    /**
     * Define a task used by {BABYLON.AssetsManager} to load images
     */
    class ImageAssetTask extends AbstractAssetTask {
        /**
         * Defines the name of the task
         */
        name: string;
        /**
         * Defines the location of the image to load
         */
        url: string;
        /**
         * Gets the loaded images
         */
        image: HTMLImageElement;
        /**
         * Callback called when the task is successful
         */
        onSuccess: (task: ImageAssetTask) => void;
        /**
         * Callback called when the task is successful
         */
        onError: (task: ImageAssetTask, message?: string, exception?: any) => void;
        /**
         * Creates a new ImageAssetTask
         * @param name defines the name of the task
         * @param url defines the location of the image to load
         */
        constructor(
            /**
             * Defines the name of the task
             */
            name: string, 
            /**
             * Defines the location of the image to load
             */
            url: string);
        /**
         * Execute the current task
         * @param scene defines the scene where you want your assets to be loaded
         * @param onSuccess is a callback called when the task is successfully executed
         * @param onError is a callback called if an error occurs
         */
        runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void;
    }
    /**
     * Defines the interface used by texture loading tasks
     */
    interface ITextureAssetTask<TEX extends BaseTexture> {
        /**
         * Gets the loaded texture
         */
        texture: TEX;
    }
    /**
     * Define a task used by {BABYLON.AssetsManager} to load 2D textures
     */
    class TextureAssetTask extends AbstractAssetTask implements ITextureAssetTask<Texture> {
        /**
         * Defines the name of the task
         */
        name: string;
        /**
         * Defines the location of the file to load
         */
        url: string;
        /**
         * Defines if mipmap should not be generated (default is false)
         */
        noMipmap: boolean | undefined;
        /**
         * Defines if texture must be inverted on Y axis (default is false)
         */
        invertY: boolean | undefined;
        /**
         * Defines the sampling mode to use (default is BABYLON.Texture.TRILINEAR_SAMPLINGMODE)
         */
        samplingMode: number;
        /**
         * Gets the loaded texture
         */
        texture: Texture;
        /**
         * Callback called when the task is successful
         */
        onSuccess: (task: TextureAssetTask) => void;
        /**
         * Callback called when the task is successful
         */
        onError: (task: TextureAssetTask, message?: string, exception?: any) => void;
        /**
         * Creates a new TextureAssetTask object
         * @param name defines the name of the task
         * @param url defines the location of the file to load
         * @param noMipmap defines if mipmap should not be generated (default is false)
         * @param invertY defines if texture must be inverted on Y axis (default is false)
         * @param samplingMode defines the sampling mode to use (default is BABYLON.Texture.TRILINEAR_SAMPLINGMODE)
         */
        constructor(
            /**
             * Defines the name of the task
             */
            name: string, 
            /**
             * Defines the location of the file to load
             */
            url: string, 
            /**
             * Defines if mipmap should not be generated (default is false)
             */
            noMipmap?: boolean | undefined, 
            /**
             * Defines if texture must be inverted on Y axis (default is false)
             */
            invertY?: boolean | undefined, 
            /**
             * Defines the sampling mode to use (default is BABYLON.Texture.TRILINEAR_SAMPLINGMODE)
             */
            samplingMode?: number);
        /**
         * Execute the current task
         * @param scene defines the scene where you want your assets to be loaded
         * @param onSuccess is a callback called when the task is successfully executed
         * @param onError is a callback called if an error occurs
         */
        runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void;
    }
    /**
     * Define a task used by {BABYLON.AssetsManager} to load cube textures
     */
    class CubeTextureAssetTask extends AbstractAssetTask implements ITextureAssetTask<CubeTexture> {
        /**
         * Defines the name of the task
         */
        name: string;
        /**
         * Defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)
         */
        url: string;
        /**
         * Defines the extensions to use to load files (["_px", "_py", "_pz", "_nx", "_ny", "_nz"] by default)
         */
        extensions: string[] | undefined;
        /**
         * Defines if mipmaps should not be generated (default is false)
         */
        noMipmap: boolean | undefined;
        /**
         * Defines the explicit list of files (undefined by default)
         */
        files: string[] | undefined;
        /**
         * Gets the loaded texture
         */
        texture: CubeTexture;
        /**
         * Callback called when the task is successful
         */
        onSuccess: (task: CubeTextureAssetTask) => void;
        /**
         * Callback called when the task is successful
         */
        onError: (task: CubeTextureAssetTask, message?: string, exception?: any) => void;
        /**
         * Creates a new CubeTextureAssetTask
         * @param name defines the name of the task
         * @param url defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)
         * @param extensions defines the extensions to use to load files (["_px", "_py", "_pz", "_nx", "_ny", "_nz"] by default)
         * @param noMipmap defines if mipmaps should not be generated (default is false)
         * @param files defines the explicit list of files (undefined by default)
         */
        constructor(
            /**
             * Defines the name of the task
             */
            name: string, 
            /**
             * Defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)
             */
            url: string, 
            /**
             * Defines the extensions to use to load files (["_px", "_py", "_pz", "_nx", "_ny", "_nz"] by default)
             */
            extensions?: string[] | undefined, 
            /**
             * Defines if mipmaps should not be generated (default is false)
             */
            noMipmap?: boolean | undefined, 
            /**
             * Defines the explicit list of files (undefined by default)
             */
            files?: string[] | undefined);
        /**
         * Execute the current task
         * @param scene defines the scene where you want your assets to be loaded
         * @param onSuccess is a callback called when the task is successfully executed
         * @param onError is a callback called if an error occurs
         */
        runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void;
    }
    /**
     * Define a task used by {BABYLON.AssetsManager} to load HDR cube textures
     */
    class HDRCubeTextureAssetTask extends AbstractAssetTask implements ITextureAssetTask<HDRCubeTexture> {
        /**
         * Defines the name of the task
         */
        name: string;
        /**
         * Defines the location of the file to load
         */
        url: string;
        /**
         * Defines the desired size (the more it increases the longer the generation will be)
         */
        size: number;
        /**
         * Defines if mipmaps should not be generated (default is false)
         */
        noMipmap: boolean;
        /**
         * Specifies whether you want to extract the polynomial harmonics during the generation process (default is true)
         */
        generateHarmonics: boolean;
        /**
         * Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
         */
        gammaSpace: boolean;
        /**
         * Internal Use Only
         */
        reserved: boolean;
        /**
         * Gets the loaded texture
         */
        texture: HDRCubeTexture;
        /**
         * Callback called when the task is successful
         */
        onSuccess: (task: HDRCubeTextureAssetTask) => void;
        /**
         * Callback called when the task is successful
         */
        onError: (task: HDRCubeTextureAssetTask, message?: string, exception?: any) => void;
        /**
         * Creates a new HDRCubeTextureAssetTask object
         * @param name defines the name of the task
         * @param url defines the location of the file to load
         * @param size defines the desired size (the more it increases the longer the generation will be) If the size is omitted this implies you are using a preprocessed cubemap.
         * @param noMipmap defines if mipmaps should not be generated (default is false)
         * @param generateHarmonics specifies whether you want to extract the polynomial harmonics during the generation process (default is true)
         * @param gammaSpace specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
         * @param reserved Internal use only
         */
        constructor(
            /**
             * Defines the name of the task
             */
            name: string, 
            /**
             * Defines the location of the file to load
             */
            url: string, 
            /**
             * Defines the desired size (the more it increases the longer the generation will be)
             */
            size: number, 
            /**
             * Defines if mipmaps should not be generated (default is false)
             */
            noMipmap?: boolean, 
            /**
             * Specifies whether you want to extract the polynomial harmonics during the generation process (default is true)
             */
            generateHarmonics?: boolean, 
            /**
             * Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
             */
            gammaSpace?: boolean, 
            /**
             * Internal Use Only
             */
            reserved?: boolean);
        /**
         * Execute the current task
         * @param scene defines the scene where you want your assets to be loaded
         * @param onSuccess is a callback called when the task is successfully executed
         * @param onError is a callback called if an error occurs
         */
        run(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void;
    }
    /**
     * This class can be used to easily import assets into a scene
     * @see http://doc.babylonjs.com/how_to/how_to_use_assetsmanager
     */
    class AssetsManager {
        private _scene;
        private _isLoading;
        protected _tasks: AbstractAssetTask[];
        protected _waitingTasksCount: number;
        protected _totalTasksCount: number;
        /**
         * Callback called when all tasks are processed
         */
        onFinish: (tasks: AbstractAssetTask[]) => void;
        /**
         * Callback called when a task is successful
         */
        onTaskSuccess: (task: AbstractAssetTask) => void;
        /**
         * Callback called when a task had an error
         */
        onTaskError: (task: AbstractAssetTask) => void;
        /**
         * Callback called when a task is done (whatever the result is)
         */
        onProgress: (remainingCount: number, totalCount: number, task: AbstractAssetTask) => void;
        /**
         * Observable called when all tasks are processed
         */
        onTaskSuccessObservable: Observable<AbstractAssetTask>;
        /**
         * Observable called when a task had an error
         */
        onTaskErrorObservable: Observable<AbstractAssetTask>;
        /**
         * Observable called when a task is successful
         */
        onTasksDoneObservable: Observable<AbstractAssetTask[]>;
        /**
         * Observable called when a task is done (whatever the result is)
         */
        onProgressObservable: Observable<IAssetsProgressEvent>;
        /**
         * Gets or sets a boolean defining if the {BABYLON.AssetsManager} should use the default loading screen
         * @see http://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
         */
        useDefaultLoadingScreen: boolean;
        /**
         * Creates a new AssetsManager
         * @param scene defines the scene to work on
         */
        constructor(scene: Scene);
        /**
         * Add a {BABYLON.MeshAssetTask} to the list of active tasks
         * @param taskName defines the name of the new task
         * @param meshesNames defines the name of meshes to load
         * @param rootUrl defines the root url to use to locate files
         * @param sceneFilename defines the filename of the scene file
         * @returns a new {BABYLON.MeshAssetTask} object
         */
        addMeshTask(taskName: string, meshesNames: any, rootUrl: string, sceneFilename: string): MeshAssetTask;
        /**
         * Add a {BABYLON.TextFileAssetTask} to the list of active tasks
         * @param taskName defines the name of the new task
         * @param url defines the url of the file to load
         * @returns a new {BABYLON.TextFileAssetTask} object
         */
        addTextFileTask(taskName: string, url: string): TextFileAssetTask;
        /**
         * Add a {BABYLON.BinaryFileAssetTask} to the list of active tasks
         * @param taskName defines the name of the new task
         * @param url defines the url of the file to load
         * @returns a new {BABYLON.BinaryFileAssetTask} object
         */
        addBinaryFileTask(taskName: string, url: string): BinaryFileAssetTask;
        /**
         * Add a {BABYLON.ImageAssetTask} to the list of active tasks
         * @param taskName defines the name of the new task
         * @param url defines the url of the file to load
         * @returns a new {BABYLON.ImageAssetTask} object
         */
        addImageTask(taskName: string, url: string): ImageAssetTask;
        /**
         * Add a {BABYLON.TextureAssetTask} to the list of active tasks
         * @param taskName defines the name of the new task
         * @param url defines the url of the file to load
         * @param noMipmap defines if the texture must not receive mipmaps (false by default)
         * @param invertY defines if you want to invert Y axis of the loaded texture (false by default)
         * @param samplingMode defines the sampling mode to use (BABYLON.Texture.TRILINEAR_SAMPLINGMODE by default)
         * @returns a new {BABYLON.TextureAssetTask} object
         */
        addTextureTask(taskName: string, url: string, noMipmap?: boolean, invertY?: boolean, samplingMode?: number): TextureAssetTask;
        /**
         * Add a {BABYLON.CubeTextureAssetTask} to the list of active tasks
         * @param taskName defines the name of the new task
         * @param url defines the url of the file to load
         * @param extensions defines the extension to use to load the cube map (can be null)
         * @param noMipmap defines if the texture must not receive mipmaps (false by default)
         * @param files defines the list of files to load (can be null)
         * @returns a new {BABYLON.CubeTextureAssetTask} object
         */
        addCubeTextureTask(taskName: string, url: string, extensions?: string[], noMipmap?: boolean, files?: string[]): CubeTextureAssetTask;
        /**
         *
         * Add a {BABYLON.HDRCubeTextureAssetTask} to the list of active tasks
         * @param taskName defines the name of the new task
         * @param url defines the url of the file to load
         * @param size defines the size you want for the cubemap (can be null)
         * @param noMipmap defines if the texture must not receive mipmaps (false by default)
         * @param generateHarmonics defines if you want to automatically generate (true by default)
         * @param gammaSpace specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
         * @param reserved Internal use only
         * @returns a new {BABYLON.HDRCubeTextureAssetTask} object
         */
        addHDRCubeTextureTask(taskName: string, url: string, size: number, noMipmap?: boolean, generateHarmonics?: boolean, gammaSpace?: boolean, reserved?: boolean): HDRCubeTextureAssetTask;
        private _decreaseWaitingTasksCount(task);
        private _runTask(task);
        /**
         * Reset the {BABYLON.AssetsManager} and remove all tasks
         * @return the current instance of the {BABYLON.AssetsManager}
         */
        reset(): AssetsManager;
        /**
         * Start the loading process
         * @return the current instance of the {BABYLON.AssetsManager}
         */
        load(): AssetsManager;
    }
}

declare module BABYLON {
    /**
     * Class used to enable access to IndexedDB
     * @see @https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API
     */
    class Database {
        private callbackManifestChecked;
        private currentSceneUrl;
        private db;
        private _enableSceneOffline;
        private _enableTexturesOffline;
        private manifestVersionFound;
        private mustUpdateRessources;
        private hasReachedQuota;
        private isSupported;
        private idbFactory;
        /** Gets a boolean indicating if the user agent supports blob storage (this value will be updated after creating the first Database object) */
        static IsUASupportingBlobStorage: boolean;
        /** Gets a boolean indicating if Database storate is enabled */
        static IDBStorageEnabled: boolean;
        /**
         * Gets a boolean indicating if scene must be saved in the database
         */
        readonly enableSceneOffline: boolean;
        /**
         * Gets a boolean indicating if textures must be saved in the database
         */
        readonly enableTexturesOffline: boolean;
        /**
         * Creates a new Database
         * @param urlToScene defines the url to load the scene
         * @param callbackManifestChecked defines the callback to use when manifest is checked
         * @param disableManifestCheck defines a boolean indicating that we want to skip the manifest validation (it will be considered validated and up to date)
         */
        constructor(urlToScene: string, callbackManifestChecked: (checked: boolean) => any, disableManifestCheck?: boolean);
        private static _ParseURL;
        private static _ReturnFullUrlLocation;
        private _checkManifestFile();
        /**
         * Open the database and make it available
         * @param successCallback defines the callback to call on success
         * @param errorCallback defines the callback to call on error
         */
        openAsync(successCallback: () => void, errorCallback: () => void): void;
        /**
         * Loads an image from the database
         * @param url defines the url to load from
         * @param image defines the target DOM image
         */
        loadImageFromDB(url: string, image: HTMLImageElement): void;
        private _loadImageFromDBAsync(url, image, notInDBCallback);
        private _saveImageIntoDBAsync(url, image);
        private _checkVersionFromDB(url, versionLoaded);
        private _loadVersionFromDBAsync(url, callback, updateInDBCallback);
        private _saveVersionIntoDBAsync(url, callback);
        /**
         * Loads a file from database
         * @param url defines the URL to load from
         * @param sceneLoaded defines a callback to call on success
         * @param progressCallBack defines a callback to call when progress changed
         * @param errorCallback defines a callback to call on error
         * @param useArrayBuffer defines a boolean to use array buffer instead of text string
         */
        loadFileFromDB(url: string, sceneLoaded: (data: any) => void, progressCallBack?: (data: any) => void, errorCallback?: () => void, useArrayBuffer?: boolean): void;
        private _loadFileFromDBAsync(url, callback, notInDBCallback, useArrayBuffer?);
        private _saveFileIntoDBAsync(url, callback, progressCallback?, useArrayBuffer?);
    }
}

declare module BABYLON {
    interface DDSInfo {
        width: number;
        height: number;
        mipmapCount: number;
        isFourCC: boolean;
        isRGB: boolean;
        isLuminance: boolean;
        isCube: boolean;
        isCompressed: boolean;
        dxgiFormat: number;
        textureType: number;
        /** Sphericle polynomial created for the dds texture */
        sphericalPolynomial?: SphericalPolynomial;
    }
    class DDSTools {
        static StoreLODInAlphaChannel: boolean;
        static GetDDSInfo(arrayBuffer: any): DDSInfo;
        private static _FloatView;
        private static _Int32View;
        private static _ToHalfFloat(value);
        private static _FromHalfFloat(value);
        private static _GetHalfFloatAsFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod);
        private static _GetHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod);
        private static _GetFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod);
        private static _GetFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod);
        private static _GetHalfFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod);
        private static _GetRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset, aOffset);
        private static _ExtractLongWordOrder(value);
        private static _GetRGBArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset);
        private static _GetLuminanceArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer);
        static UploadDDSLevels(engine: Engine, gl: WebGLRenderingContext, arrayBuffer: any, info: DDSInfo, loadMipmaps: boolean, faces: number, lodIndex?: number, currentFace?: number): void;
    }
}

declare module BABYLON {
    function expandToProperty(callback: string, targetKey?: Nullable<string>): (target: any, propertyKey: string) => void;
    function serialize(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    function serializeAsTexture(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    function serializeAsColor3(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    function serializeAsFresnelParameters(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    function serializeAsVector2(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    function serializeAsVector3(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    function serializeAsMeshReference(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    function serializeAsColorCurves(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    function serializeAsColor4(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    function serializeAsImageProcessingConfiguration(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    function serializeAsQuaternion(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    /**
     * Decorator used to define property that can be serialized as reference to a camera
     * @param sourceName defines the name of the property to decorate
     */
    function serializeAsCameraReference(sourceName?: string): (target: any, propertyKey: string | symbol) => void;
    class SerializationHelper {
        static Serialize<T>(entity: T, serializationObject?: any): any;
        static Parse<T>(creationFunction: () => T, source: any, scene: Nullable<Scene>, rootUrl?: Nullable<string>): T;
        static Clone<T>(creationFunction: () => T, source: T): T;
        static Instanciate<T>(creationFunction: () => T, source: T): T;
    }
}

declare module BABYLON {
    /**
     * Wrapper class for promise with external resolve and reject.
     */
    class Deferred<T> {
        /**
         * The promise associated with this deferred object.
         */
        readonly promise: Promise<T>;
        private _resolve;
        private _reject;
        /**
         * The resolve method of the promise associated with this deferred object.
         */
        readonly resolve: (value?: T | PromiseLike<T> | undefined) => void;
        /**
         * The reject method of the promise associated with this deferred object.
         */
        readonly reject: (reason?: any) => void;
        /**
         * Constructor for this deferred object.
         */
        constructor();
    }
}

declare module BABYLON {
    class FilesInput {
        static FilesToLoad: {
            [key: string]: File;
        };
        onProcessFileCallback: (file: File, name: string, extension: string) => true;
        private _engine;
        private _currentScene;
        private _sceneLoadedCallback;
        private _progressCallback;
        private _additionalRenderLoopLogicCallback;
        private _textureLoadingCallback;
        private _startingProcessingFilesCallback;
        private _onReloadCallback;
        private _errorCallback;
        private _elementToMonitor;
        private _sceneFileToLoad;
        private _filesToLoad;
        constructor(engine: Engine, scene: Scene, sceneLoadedCallback: (sceneFile: File, scene: Scene) => void, progressCallback: (progress: SceneLoaderProgressEvent) => void, additionalRenderLoopLogicCallback: () => void, textureLoadingCallback: (remaining: number) => void, startingProcessingFilesCallback: () => void, onReloadCallback: (sceneFile: File) => void, errorCallback: (sceneFile: File, scene: Scene, message: string) => void);
        private _dragEnterHandler;
        private _dragOverHandler;
        private _dropHandler;
        monitorElementForDragNDrop(elementToMonitor: HTMLElement): void;
        dispose(): void;
        private renderFunction();
        private drag(e);
        private drop(eventDrop);
        private _traverseFolder(folder, files, remaining, callback);
        private _processFiles(files);
        loadFiles(event: any): void;
        private _processReload();
        reload(): void;
    }
}

declare module BABYLON {
    /**
     * for description see https://www.khronos.org/opengles/sdk/tools/KTX/
     * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
     */
    class KhronosTextureContainer {
        arrayBuffer: any;
        static HEADER_LEN: number;
        static COMPRESSED_2D: number;
        static COMPRESSED_3D: number;
        static TEX_2D: number;
        static TEX_3D: number;
        glType: number;
        glTypeSize: number;
        glFormat: number;
        glInternalFormat: number;
        glBaseInternalFormat: number;
        pixelWidth: number;
        pixelHeight: number;
        pixelDepth: number;
        numberOfArrayElements: number;
        numberOfFaces: number;
        numberOfMipmapLevels: number;
        bytesOfKeyValueData: number;
        loadType: number;
        /**
         * @param {ArrayBuffer} arrayBuffer- contents of the KTX container file
         * @param {number} facesExpected- should be either 1 or 6, based whether a cube texture or or
         * @param {boolean} threeDExpected- provision for indicating that data should be a 3D texture, not implemented
         * @param {boolean} textureArrayExpected- provision for indicating that data should be a texture array, not implemented
         */
        constructor(arrayBuffer: any, facesExpected: number, threeDExpected?: boolean, textureArrayExpected?: boolean);
        switchEndainness(val: number): number;
        /**
         * It is assumed that the texture has already been created & is currently bound
         */
        uploadLevels(gl: WebGLRenderingContext, loadMipmaps: boolean): void;
        private _upload2DCompressedLevels(gl, loadMipmaps);
    }
}

declare module BABYLON {
    /**
     * A class serves as a medium between the observable and its observers
     */
    class EventState {
        /**
         * Create a new EventState
         * @param mask defines the mask associated with this state
         * @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true
         * @param target defines the original target of the state
         * @param currentTarget defines the current target of the state
         */
        constructor(mask: number, skipNextObservers?: boolean, target?: any, currentTarget?: any);
        /**
         * Initialize the current event state
         * @param mask defines the mask associated with this state
         * @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true
         * @param target defines the original target of the state
         * @param currentTarget defines the current target of the state
         * @returns the current event state
         */
        initalize(mask: number, skipNextObservers?: boolean, target?: any, currentTarget?: any): EventState;
        /**
         * An Observer can set this property to true to prevent subsequent observers of being notified
         */
        skipNextObservers: boolean;
        /**
         * Get the mask value that were used to trigger the event corresponding to this EventState object
         */
        mask: number;
        /**
         * The object that originally notified the event
         */
        target?: any;
        /**
         * The current object in the bubbling phase
         */
        currentTarget?: any;
        /**
         * This will be populated with the return value of the last function that was executed.
         * If it is the first function in the callback chain it will be the event data.
         */
        lastReturnValue?: any;
    }
    /**
     * Represent an Observer registered to a given Observable object.
     */
    class Observer<T> {
        /**
         * Defines the callback to call when the observer is notified
         */
        callback: (eventData: T, eventState: EventState) => void;
        /**
         * Defines the mask of the observer (used to filter notifications)
         */
        mask: number;
        /**
         * Defines the current scope used to restore the JS context
         */
        scope: any;
        /** @hidden */
        _willBeUnregistered: boolean;
        /**
         * Gets or sets a property defining that the observer as to be unregistered after the next notification
         */
        unregisterOnNextCall: boolean;
        /**
         * Creates a new observer
         * @param callback defines the callback to call when the observer is notified
         * @param mask defines the mask of the observer (used to filter notifications)
         * @param scope defines the current scope used to restore the JS context
         */
        constructor(
            /**
             * Defines the callback to call when the observer is notified
             */
            callback: (eventData: T, eventState: EventState) => void, 
            /**
             * Defines the mask of the observer (used to filter notifications)
             */
            mask: number, 
            /**
             * Defines the current scope used to restore the JS context
             */
            scope?: any);
    }
    /**
     * Represent a list of observers registered to multiple Observables object.
     */
    class MultiObserver<T> {
        private _observers;
        private _observables;
        /**
         * Release associated resources
         */
        dispose(): void;
        /**
         * Raise a callback when one of the observable will notify
         * @param observables defines a list of observables to watch
         * @param callback defines the callback to call on notification
         * @param mask defines the mask used to filter notifications
         * @param scope defines the current scope used to restore the JS context
         * @returns the new MultiObserver
         */
        static Watch<T>(observables: Observable<T>[], callback: (eventData: T, eventState: EventState) => void, mask?: number, scope?: any): MultiObserver<T>;
    }
    /**
     * The Observable class is a simple implementation of the Observable pattern.
     *
     * There's one slight particularity though: a given Observable can notify its observer using a particular mask value, only the Observers registered with this mask value will be notified.
     * This enable a more fine grained execution without having to rely on multiple different Observable objects.
     * For instance you may have a given Observable that have four different types of notifications: Move (mask = 0x01), Stop (mask = 0x02), Turn Right (mask = 0X04), Turn Left (mask = 0X08).
     * A given observer can register itself with only Move and Stop (mask = 0x03), then it will only be notified when one of these two occurs and will never be for Turn Left/Right.
     */
    class Observable<T> {
        private _observers;
        private _eventState;
        private _onObserverAdded;
        /**
         * Creates a new observable
         * @param onObserverAdded defines a callback to call when a new observer is added
         */
        constructor(onObserverAdded?: (observer: Observer<T>) => void);
        /**
         * Create a new Observer with the specified callback
         * @param callback the callback that will be executed for that Observer
         * @param mask the mask used to filter observers
         * @param insertFirst if true the callback will be inserted at the first position, hence executed before the others ones. If false (default behavior) the callback will be inserted at the last position, executed after all the others already present.
         * @param scope optional scope for the callback to be called from
         * @param unregisterOnFirstCall defines if the observer as to be unregistered after the next notification
         * @returns the new observer created for the callback
         */
        add(callback: (eventData: T, eventState: EventState) => void, mask?: number, insertFirst?: boolean, scope?: any, unregisterOnFirstCall?: boolean): Nullable<Observer<T>>;
        /**
         * Remove an Observer from the Observable object
         * @param observer the instance of the Observer to remove
         * @returns false if it doesn't belong to this Observable
         */
        remove(observer: Nullable<Observer<T>>): boolean;
        /**
         * Remove a callback from the Observable object
         * @param callback the callback to remove
         * @param scope optional scope. If used only the callbacks with this scope will be removed
         * @returns false if it doesn't belong to this Observable
        */
        removeCallback(callback: (eventData: T, eventState: EventState) => void, scope?: any): boolean;
        private _deferUnregister(observer);
        /**
         * Notify all Observers by calling their respective callback with the given data
         * Will return true if all observers were executed, false if an observer set skipNextObservers to true, then prevent the subsequent ones to execute
         * @param eventData defines the data to send to all observers
         * @param mask defines the mask of the current notification (observers with incompatible mask (ie mask & observer.mask === 0) will not be notified)
         * @param target defines the original target of the state
         * @param currentTarget defines the current target of the state
         * @returns false if the complete observer chain was not processed (because one observer set the skipNextObservers to true)
         */
        notifyObservers(eventData: T, mask?: number, target?: any, currentTarget?: any): boolean;
        /**
         * Calling this will execute each callback, expecting it to be a promise or return a value.
         * If at any point in the chain one function fails, the promise will fail and the execution will not continue.
         * This is useful when a chain of events (sometimes async events) is needed to initialize a certain object
         * and it is crucial that all callbacks will be executed.
         * The order of the callbacks is kept, callbacks are not executed parallel.
         *
         * @param eventData The data to be sent to each callback
         * @param mask is used to filter observers defaults to -1
         * @param target defines the callback target (see EventState)
         * @param currentTarget defines he current object in the bubbling phase
         * @returns {Promise<T>} will return a Promise than resolves when all callbacks executed successfully.
         */
        notifyObserversWithPromise(eventData: T, mask?: number, target?: any, currentTarget?: any): Promise<T>;
        /**
         * Notify a specific observer
         * @param observer defines the observer to notify
         * @param eventData defines the data to be sent to each callback
         * @param mask is used to filter observers defaults to -1
         */
        notifyObserver(observer: Observer<T>, eventData: T, mask?: number): void;
        /**
         * Gets a boolean indicating if the observable has at least one observer
         * @returns true is the Observable has at least one Observer registered
         */
        hasObservers(): boolean;
        /**
        * Clear the list of observers
        */
        clear(): void;
        /**
         * Clone the current observable
         * @returns a new observable
         */
        clone(): Observable<T>;
        /**
         * Does this observable handles observer registered with a given mask
         * @param mask defines the mask to be tested
         * @return whether or not one observer registered with the given mask is handeled
        **/
        hasSpecificMask(mask?: number): boolean;
    }
}

declare module BABYLON {
    /**
     * Performance monitor tracks rolling average frame-time and frame-time variance over a user defined sliding-window
     */
    class PerformanceMonitor {
        private _enabled;
        private _rollingFrameTime;
        private _lastFrameTimeMs;
        /**
         * constructor
         * @param frameSampleSize The number of samples required to saturate the sliding window
         */
        constructor(frameSampleSize?: number);
        /**
         * Samples current frame
         * @param timeMs A timestamp in milliseconds of the current frame to compare with other frames
         */
        sampleFrame(timeMs?: number): void;
        /**
         * Returns the average frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
         * @return Average frame time in milliseconds
         */
        readonly averageFrameTime: number;
        /**
         * Returns the variance frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
         * @return Frame time variance in milliseconds squared
         */
        readonly averageFrameTimeVariance: number;
        /**
         * Returns the frame time of the most recent frame
         * @return Frame time in milliseconds
         */
        readonly instantaneousFrameTime: number;
        /**
         * Returns the average framerate in frames per second over the sliding window (or the subset of frames sampled so far)
         * @return Framerate in frames per second
         */
        readonly averageFPS: number;
        /**
         * Returns the average framerate in frames per second using the most recent frame time
         * @return Framerate in frames per second
         */
        readonly instantaneousFPS: number;
        /**
         * Returns true if enough samples have been taken to completely fill the sliding window
         * @return true if saturated
         */
        readonly isSaturated: boolean;
        /**
         * Enables contributions to the sliding window sample set
         */
        enable(): void;
        /**
         * Disables contributions to the sliding window sample set
         * Samples will not be interpolated over the disabled period
         */
        disable(): void;
        /**
         * Returns true if sampling is enabled
         * @return true if enabled
         */
        readonly isEnabled: boolean;
        /**
         * Resets performance monitor
         */
        reset(): void;
    }
    /**
     * RollingAverage
     *
     * Utility to efficiently compute the rolling average and variance over a sliding window of samples
     */
    class RollingAverage {
        /**
         * Current average
         */
        average: number;
        /**
         * Current variance
         */
        variance: number;
        protected _samples: Array<number>;
        protected _sampleCount: number;
        protected _pos: number;
        protected _m2: number;
        /**
         * constructor
         * @param length The number of samples required to saturate the sliding window
         */
        constructor(length: number);
        /**
         * Adds a sample to the sample set
         * @param v The sample value
         */
        add(v: number): void;
        /**
         * Returns previously added values or null if outside of history or outside the sliding window domain
         * @param i Index in history. For example, pass 0 for the most recent value and 1 for the value before that
         * @return Value previously recorded with add() or null if outside of range
         */
        history(i: number): number;
        /**
         * Returns true if enough samples have been taken to completely fill the sliding window
         * @return true if sample-set saturated
         */
        isSaturated(): boolean;
        /**
         * Resets the rolling average (equivalent to 0 samples taken so far)
         */
        reset(): void;
        /**
         * Wraps a value around the sample range boundaries
         * @param i Position in sample range, for example if the sample length is 5, and i is -3, then 2 will be returned.
         * @return Wrapped position in sample range
         */
        protected _wrapPosition(i: number): number;
    }
}

declare module BABYLON {
    /**
     * Helper class that provides a small promise polyfill
     */
    class PromisePolyfill {
        /**
         * Static function used to check if the polyfill is required
         * If this is the case then the function will inject the polyfill to window.Promise
         * @param force defines a boolean used to force the injection (mostly for testing purposes)
         */
        static Apply(force?: boolean): void;
    }
}

declare module BABYLON {
    /**
     * Defines the root class used to create scene optimization to use with SceneOptimizer
     * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    class SceneOptimization {
        /**
         * Defines the priority of this optimization (0 by default which means first in the list)
         */
        priority: number;
        /**
         * Gets a string describing the action executed by the current optimization
         * @returns description string
         */
        getDescription(): string;
        /**
         * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
         * @param scene defines the current scene where to apply this optimization
         * @param optimizer defines the current optimizer
         * @returns true if everything that can be done was applied
         */
        apply(scene: Scene, optimizer: SceneOptimizer): boolean;
        /**
         * Creates the SceneOptimization object
         * @param priority defines the priority of this optimization (0 by default which means first in the list)
         * @param desc defines the description associated with the optimization
         */
        constructor(
            /**
             * Defines the priority of this optimization (0 by default which means first in the list)
             */
            priority?: number);
    }
    /**
     * Defines an optimization used to reduce the size of render target textures
     * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    class TextureOptimization extends SceneOptimization {
        /**
         * Defines the priority of this optimization (0 by default which means first in the list)
         */
        priority: number;
        /**
         * Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter
         */
        maximumSize: number;
        /**
         * Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.
         */
        step: number;
        /**
         * Gets a string describing the action executed by the current optimization
         * @returns description string
         */
        getDescription(): string;
        /**
         * Creates the TextureOptimization object
         * @param priority defines the priority of this optimization (0 by default which means first in the list)
         * @param maximumSize defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter
         * @param step defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.
         */
        constructor(
            /**
             * Defines the priority of this optimization (0 by default which means first in the list)
             */
            priority?: number, 
            /**
             * Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter
             */
            maximumSize?: number, 
            /**
             * Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.
             */
            step?: number);
        /**
         * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
         * @param scene defines the current scene where to apply this optimization
         * @param optimizer defines the current optimizer
         * @returns true if everything that can be done was applied
         */
        apply(scene: Scene, optimizer: SceneOptimizer): boolean;
    }
    /**
     * Defines an optimization used to increase or decrease the rendering resolution
     * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    class HardwareScalingOptimization extends SceneOptimization {
        /**
         * Defines the priority of this optimization (0 by default which means first in the list)
         */
        priority: number;
        /**
         * Defines the maximum scale to use (2 by default)
         */
        maximumScale: number;
        /**
         * Defines the step to use between two passes (0.5 by default)
         */
        step: number;
        private _currentScale;
        private _directionOffset;
        /**
         * Gets a string describing the action executed by the current optimization
         * @return description string
         */
        getDescription(): string;
        /**
         * Creates the HardwareScalingOptimization object
         * @param priority defines the priority of this optimization (0 by default which means first in the list)
         * @param maximumScale defines the maximum scale to use (2 by default)
         * @param step defines the step to use between two passes (0.5 by default)
         */
        constructor(
            /**
             * Defines the priority of this optimization (0 by default which means first in the list)
             */
            priority?: number, 
            /**
             * Defines the maximum scale to use (2 by default)
             */
            maximumScale?: number, 
            /**
             * Defines the step to use between two passes (0.5 by default)
             */
            step?: number);
        /**
         * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
         * @param scene defines the current scene where to apply this optimization
         * @param optimizer defines the current optimizer
         * @returns true if everything that can be done was applied
         */
        apply(scene: Scene, optimizer: SceneOptimizer): boolean;
    }
    /**
     * Defines an optimization used to remove shadows
     * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    class ShadowsOptimization extends SceneOptimization {
        /**
         * Gets a string describing the action executed by the current optimization
         * @return description string
         */
        getDescription(): string;
        /**
         * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
         * @param scene defines the current scene where to apply this optimization
         * @param optimizer defines the current optimizer
         * @returns true if everything that can be done was applied
         */
        apply(scene: Scene, optimizer: SceneOptimizer): boolean;
    }
    /**
     * Defines an optimization used to turn post-processes off
     * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    class PostProcessesOptimization extends SceneOptimization {
        /**
         * Gets a string describing the action executed by the current optimization
         * @return description string
         */
        getDescription(): string;
        /**
         * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
         * @param scene defines the current scene where to apply this optimization
         * @param optimizer defines the current optimizer
         * @returns true if everything that can be done was applied
         */
        apply(scene: Scene, optimizer: SceneOptimizer): boolean;
    }
    /**
     * Defines an optimization used to turn lens flares off
     * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    class LensFlaresOptimization extends SceneOptimization {
        /**
         * Gets a string describing the action executed by the current optimization
         * @return description string
         */
        getDescription(): string;
        /**
         * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
         * @param scene defines the current scene where to apply this optimization
         * @param optimizer defines the current optimizer
         * @returns true if everything that can be done was applied
         */
        apply(scene: Scene, optimizer: SceneOptimizer): boolean;
    }
    /**
     * Defines an optimization based on user defined callback.
     * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    class CustomOptimization extends SceneOptimization {
        /**
         * Callback called to apply the custom optimization.
         */
        onApply: (scene: Scene, optimizer: SceneOptimizer) => boolean;
        /**
         * Callback called to get custom description
         */
        onGetDescription: () => string;
        /**
         * Gets a string describing the action executed by the current optimization
         * @returns description string
         */
        getDescription(): string;
        /**
         * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
         * @param scene defines the current scene where to apply this optimization
         * @param optimizer defines the current optimizer
         * @returns true if everything that can be done was applied
         */
        apply(scene: Scene, optimizer: SceneOptimizer): boolean;
    }
    /**
     * Defines an optimization used to turn particles off
     * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    class ParticlesOptimization extends SceneOptimization {
        /**
         * Gets a string describing the action executed by the current optimization
         * @return description string
         */
        getDescription(): string;
        /**
         * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
         * @param scene defines the current scene where to apply this optimization
         * @param optimizer defines the current optimizer
         * @returns true if everything that can be done was applied
         */
        apply(scene: Scene, optimizer: SceneOptimizer): boolean;
    }
    /**
     * Defines an optimization used to turn render targets off
     * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    class RenderTargetsOptimization extends SceneOptimization {
        /**
         * Gets a string describing the action executed by the current optimization
         * @return description string
         */
        getDescription(): string;
        /**
         * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
         * @param scene defines the current scene where to apply this optimization
         * @param optimizer defines the current optimizer
         * @returns true if everything that can be done was applied
         */
        apply(scene: Scene, optimizer: SceneOptimizer): boolean;
    }
    /**
     * Defines an optimization used to merge meshes with compatible materials
     * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    class MergeMeshesOptimization extends SceneOptimization {
        private static _UpdateSelectionTree;
        /**
         * Gets or sets a boolean which defines if optimization octree has to be updated
         */
        /**
         * Gets or sets a boolean which defines if optimization octree has to be updated
         */
        static UpdateSelectionTree: boolean;
        /**
         * Gets a string describing the action executed by the current optimization
         * @return description string
         */
        getDescription(): string;
        private _canBeMerged;
        /**
         * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
         * @param scene defines the current scene where to apply this optimization
         * @param optimizer defines the current optimizer
         * @param updateSelectionTree defines that the selection octree has to be updated (false by default)
         * @returns true if everything that can be done was applied
         */
        apply(scene: Scene, optimizer: SceneOptimizer, updateSelectionTree?: boolean): boolean;
    }
    /**
     * Defines a list of options used by SceneOptimizer
     * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    class SceneOptimizerOptions {
        /**
         * Defines the target frame rate to reach (60 by default)
         */
        targetFrameRate: number;
        /**
         * Defines the interval between two checkes (2000ms by default)
         */
        trackerDuration: number;
        /**
         * Gets the list of optimizations to apply
         */
        optimizations: SceneOptimization[];
        /**
         * Creates a new list of options used by SceneOptimizer
         * @param targetFrameRate defines the target frame rate to reach (60 by default)
         * @param trackerDuration defines the interval between two checkes (2000ms by default)
         */
        constructor(
            /**
             * Defines the target frame rate to reach (60 by default)
             */
            targetFrameRate?: number, 
            /**
             * Defines the interval between two checkes (2000ms by default)
             */
            trackerDuration?: number);
        /**
         * Add a new optimization
         * @param optimization defines the SceneOptimization to add to the list of active optimizations
         * @returns the current SceneOptimizerOptions
         */
        addOptimization(optimization: SceneOptimization): SceneOptimizerOptions;
        /**
         * Add a new custom optimization
         * @param onApply defines the callback called to apply the custom optimization (true if everything that can be done was applied)
         * @param onGetDescription defines the callback called to get the description attached with the optimization.
         * @param priority defines the priority of this optimization (0 by default which means first in the list)
         * @returns the current SceneOptimizerOptions
         */
        addCustomOptimization(onApply: (scene: Scene) => boolean, onGetDescription: () => string, priority?: number): SceneOptimizerOptions;
        /**
         * Creates a list of pre-defined optimizations aimed to reduce the visual impact on the scene
         * @param targetFrameRate defines the target frame rate (60 by default)
         * @returns a SceneOptimizerOptions object
         */
        static LowDegradationAllowed(targetFrameRate?: number): SceneOptimizerOptions;
        /**
         * Creates a list of pre-defined optimizations aimed to have a moderate impact on the scene visual
         * @param targetFrameRate defines the target frame rate (60 by default)
         * @returns a SceneOptimizerOptions object
         */
        static ModerateDegradationAllowed(targetFrameRate?: number): SceneOptimizerOptions;
        /**
         * Creates a list of pre-defined optimizations aimed to have a big impact on the scene visual
         * @param targetFrameRate defines the target frame rate (60 by default)
         * @returns a SceneOptimizerOptions object
         */
        static HighDegradationAllowed(targetFrameRate?: number): SceneOptimizerOptions;
    }
    /**
     * Class used to run optimizations in order to reach a target frame rate
     * @description More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    class SceneOptimizer implements IDisposable {
        private _isRunning;
        private _options;
        private _scene;
        private _currentPriorityLevel;
        private _targetFrameRate;
        private _trackerDuration;
        private _currentFrameRate;
        private _sceneDisposeObserver;
        private _improvementMode;
        /**
         * Defines an observable called when the optimizer reaches the target frame rate
         */
        onSuccessObservable: Observable<SceneOptimizer>;
        /**
         * Defines an observable called when the optimizer enables an optimization
         */
        onNewOptimizationAppliedObservable: Observable<SceneOptimization>;
        /**
         * Defines an observable called when the optimizer is not able to reach the target frame rate
         */
        onFailureObservable: Observable<SceneOptimizer>;
        /**
         * Gets a boolean indicating if the optimizer is in improvement mode
         */
        readonly isInImprovementMode: boolean;
        /**
         * Gets the current priority level (0 at start)
         */
        readonly currentPriorityLevel: number;
        /**
         * Gets the current frame rate checked by the SceneOptimizer
         */
        readonly currentFrameRate: number;
        /**
         * Gets or sets the current target frame rate (60 by default)
         */
        /**
         * Gets or sets the current target frame rate (60 by default)
         */
        targetFrameRate: number;
        /**
         * Gets or sets the current interval between two checks (every 2000ms by default)
         */
        /**
         * Gets or sets the current interval between two checks (every 2000ms by default)
         */
        trackerDuration: number;
        /**
         * Gets the list of active optimizations
         */
        readonly optimizations: SceneOptimization[];
        /**
         * Creates a new SceneOptimizer
         * @param scene defines the scene to work on
         * @param options defines the options to use with the SceneOptimizer
         * @param autoGeneratePriorities defines if priorities must be generated and not read from SceneOptimization property (true by default)
         * @param improvementMode defines if the scene optimizer must run the maximum optimization while staying over a target frame instead of trying to reach the target framerate (false by default)
         */
        constructor(scene: Scene, options?: SceneOptimizerOptions, autoGeneratePriorities?: boolean, improvementMode?: boolean);
        /**
         * Stops the current optimizer
         */
        stop(): void;
        /**
         * Reset the optimizer to initial step (current priority level = 0)
         */
        reset(): void;
        /**
         * Start the optimizer. By default it will try to reach a specific framerate
         * but if the optimizer is set with improvementMode === true then it will run all optimiatiation while frame rate is above the target frame rate
         */
        start(): void;
        private _checkCurrentState();
        /**
         * Release all resources
         */
        dispose(): void;
        /**
         * Helper function to create a SceneOptimizer with one single line of code
         * @param scene defines the scene to work on
         * @param options defines the options to use with the SceneOptimizer
         * @param onSuccess defines a callback to call on success
         * @param onFailure defines a callback to call on failure
         * @returns the new SceneOptimizer object
         */
        static OptimizeAsync(scene: Scene, options?: SceneOptimizerOptions, onSuccess?: () => void, onFailure?: () => void): SceneOptimizer;
    }
}

declare module BABYLON {
    class SceneSerializer {
        static ClearCache(): void;
        static Serialize(scene: Scene): any;
        static SerializeMesh(toSerialize: any, withParents?: boolean, withChildren?: boolean): any;
    }
}

declare module BABYLON {
    class SmartArray<T> {
        data: Array<T>;
        length: number;
        protected _id: number;
        [index: number]: T;
        constructor(capacity: number);
        push(value: T): void;
        forEach(func: (content: T) => void): void;
        sort(compareFn: (a: T, b: T) => number): void;
        reset(): void;
        dispose(): void;
        concat(array: any): void;
        indexOf(value: T): number;
        contains(value: T): boolean;
        private static _GlobalId;
    }
    class SmartArrayNoDuplicate<T> extends SmartArray<T> {
        private _duplicateId;
        [index: number]: T;
        push(value: T): void;
        pushNoDuplicate(value: T): boolean;
        reset(): void;
        concatWithNoDuplicate(array: any): void;
    }
}

declare module BABYLON {
    /**
     * This class implement a typical dictionary using a string as key and the generic type T as value.
     * The underlying implementation relies on an associative array to ensure the best performances.
     * The value can be anything including 'null' but except 'undefined'
     */
    class StringDictionary<T> {
        /**
         * This will clear this dictionary and copy the content from the 'source' one.
         * If the T value is a custom object, it won't be copied/cloned, the same object will be used
         * @param source the dictionary to take the content from and copy to this dictionary
         */
        copyFrom(source: StringDictionary<T>): void;
        /**
         * Get a value based from its key
         * @param key the given key to get the matching value from
         * @return the value if found, otherwise undefined is returned
         */
        get(key: string): T | undefined;
        /**
         * Get a value from its key or add it if it doesn't exist.
         * This method will ensure you that a given key/data will be present in the dictionary.
         * @param key the given key to get the matching value from
         * @param factory the factory that will create the value if the key is not present in the dictionary.
         * The factory will only be invoked if there's no data for the given key.
         * @return the value corresponding to the key.
         */
        getOrAddWithFactory(key: string, factory: (key: string) => T): T;
        /**
         * Get a value from its key if present in the dictionary otherwise add it
         * @param key the key to get the value from
         * @param val if there's no such key/value pair in the dictionary add it with this value
         * @return the value corresponding to the key
         */
        getOrAdd(key: string, val: T): T;
        /**
         * Check if there's a given key in the dictionary
         * @param key the key to check for
         * @return true if the key is present, false otherwise
         */
        contains(key: string): boolean;
        /**
         * Add a new key and its corresponding value
         * @param key the key to add
         * @param value the value corresponding to the key
         * @return true if the operation completed successfully, false if we couldn't insert the key/value because there was already this key in the dictionary
         */
        add(key: string, value: T): boolean;
        set(key: string, value: T): boolean;
        /**
         * Get the element of the given key and remove it from the dictionary
         * @param key
         */
        getAndRemove(key: string): Nullable<T>;
        /**
         * Remove a key/value from the dictionary.
         * @param key the key to remove
         * @return true if the item was successfully deleted, false if no item with such key exist in the dictionary
         */
        remove(key: string): boolean;
        /**
         * Clear the whole content of the dictionary
         */
        clear(): void;
        readonly count: number;
        /**
         * Execute a callback on each key/val of the dictionary.
         * Note that you can remove any element in this dictionary in the callback implementation
         * @param callback the callback to execute on a given key/value pair
         */
        forEach(callback: (key: string, val: T) => void): void;
        /**
         * Execute a callback on every occurrence of the dictionary until it returns a valid TRes object.
         * If the callback returns null or undefined the method will iterate to the next key/value pair
         * Note that you can remove any element in this dictionary in the callback implementation
         * @param callback the callback to execute, if it return a valid T instanced object the enumeration will stop and the object will be returned
         */
        first<TRes>(callback: (key: string, val: T) => TRes): TRes | null;
        private _count;
        private _data;
    }
}

declare module BABYLON {
    class Tags {
        static EnableFor(obj: any): void;
        static DisableFor(obj: any): void;
        static HasTags(obj: any): boolean;
        static GetTags(obj: any, asString?: boolean): any;
        static AddTagsTo(obj: any, tagsString: string): void;
        static _AddTagTo(obj: any, tag: string): void;
        static RemoveTagsFrom(obj: any, tagsString: string): void;
        static _RemoveTagFrom(obj: any, tag: string): void;
        static MatchesQuery(obj: any, tagsQuery: string): boolean;
    }
}

declare module BABYLON {
    class TextureTools {
        /**
         * Uses the GPU to create a copy texture rescaled at a given size
         * @param texture Texture to copy from
         * @param width Desired width
         * @param height Desired height
         * @return Generated texture
         */
        static CreateResizedCopy(texture: Texture, width: number, height: number, useBilinearMode?: boolean): Texture;
        static GetEnvironmentBRDFTexture(scene: Scene): BaseTexture;
        private static _environmentBRDFBase64Texture;
    }
}

declare module BABYLON {
    class TGATools {
        private static _TYPE_INDEXED;
        private static _TYPE_RGB;
        private static _TYPE_GREY;
        private static _TYPE_RLE_INDEXED;
        private static _TYPE_RLE_RGB;
        private static _TYPE_RLE_GREY;
        private static _ORIGIN_MASK;
        private static _ORIGIN_SHIFT;
        private static _ORIGIN_BL;
        private static _ORIGIN_BR;
        private static _ORIGIN_UL;
        private static _ORIGIN_UR;
        static GetTGAHeader(data: Uint8Array): any;
        static UploadContent(gl: WebGLRenderingContext, data: Uint8Array): void;
        static _getImageData8bits(header: any, palettes: Uint8Array, pixel_data: Uint8Array, y_start: number, y_step: number, y_end: number, x_start: number, x_step: number, x_end: number): Uint8Array;
        static _getImageData16bits(header: any, palettes: Uint8Array, pixel_data: Uint8Array, y_start: number, y_step: number, y_end: number, x_start: number, x_step: number, x_end: number): Uint8Array;
        static _getImageData24bits(header: any, palettes: Uint8Array, pixel_data: Uint8Array, y_start: number, y_step: number, y_end: number, x_start: number, x_step: number, x_end: number): Uint8Array;
        static _getImageData32bits(header: any, palettes: Uint8Array, pixel_data: Uint8Array, y_start: number, y_step: number, y_end: number, x_start: number, x_step: number, x_end: number): Uint8Array;
        static _getImageDataGrey8bits(header: any, palettes: Uint8Array, pixel_data: Uint8Array, y_start: number, y_step: number, y_end: number, x_start: number, x_step: number, x_end: number): Uint8Array;
        static _getImageDataGrey16bits(header: any, palettes: Uint8Array, pixel_data: Uint8Array, y_start: number, y_step: number, y_end: number, x_start: number, x_step: number, x_end: number): Uint8Array;
    }
}

declare module BABYLON {
    interface IAnimatable {
        animations: Array<Animation>;
    }
    class LoadFileError extends Error {
        request: XMLHttpRequest | undefined;
        private static _setPrototypeOf;
        constructor(message: string, request?: XMLHttpRequest | undefined);
    }
    class RetryStrategy {
        static ExponentialBackoff(maxRetries?: number, baseInterval?: number): (url: string, request: XMLHttpRequest, retryIndex: number) => number;
    }
    interface IFileRequest {
        /**
         * Raised when the request is complete (success or error).
         */
        onCompleteObservable: Observable<IFileRequest>;
        /**
         * Aborts the request for a file.
         */
        abort: () => void;
    }
    class Tools {
        static BaseUrl: string;
        static DefaultRetryStrategy: (url: string, request: XMLHttpRequest, retryIndex: number) => number;
        /**
         * Default behaviour for cors in the application.
         * It can be a string if the expected behavior is identical in the entire app.
         * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)
         */
        static CorsBehavior: string | ((url: string | string[]) => string);
        static UseFallbackTexture: boolean;
        /**
         * Use this object to register external classes like custom textures or material
         * to allow the laoders to instantiate them
         */
        static RegisteredExternalClasses: {
            [key: string]: Object;
        };
        static fallbackTexture: string;
        /**
         * Interpolates between a and b via alpha
         * @param a The lower value (returned when alpha = 0)
         * @param b The upper value (returned when alpha = 1)
         * @param alpha The interpolation-factor
         * @return The mixed value
         */
        static Mix(a: number, b: number, alpha: number): number;
        static Instantiate(className: string): any;
        /**
         * Provides a slice function that will work even on IE
         * @param data defines the array to slice
         * @param start defines the start of the data (optional)
         * @param end defines the end of the data (optional)
         * @returns the new sliced array
         */
        static Slice<T>(data: T, start?: number, end?: number): T;
        static SetImmediate(action: () => void): void;
        static IsExponentOfTwo(value: number): boolean;
        private static _tmpFloatArray;
        /**
         * Returns the nearest 32-bit single precision float representation of a Number
         * @param value A Number.  If the parameter is of a different type, it will get converted
         * to a number or to NaN if it cannot be converted
         * @returns number
         */
        static FloatRound(value: number): number;
        /**
         * Find the next highest power of two.
         * @param x Number to start search from.
         * @return Next highest power of two.
         */
        static CeilingPOT(x: number): number;
        /**
         * Find the next lowest power of two.
         * @param x Number to start search from.
         * @return Next lowest power of two.
         */
        static FloorPOT(x: number): number;
        /**
         * Find the nearest power of two.
         * @param x Number to start search from.
         * @return Next nearest power of two.
         */
        static NearestPOT(x: number): number;
        static GetExponentOfTwo(value: number, max: number, mode?: number): number;
        static GetFilename(path: string): string;
        /**
         * Extracts the "folder" part of a path (everything before the filename).
         * @param uri The URI to extract the info from
         * @param returnUnchangedIfNoSlash Do not touch the URI if no slashes are present
         * @returns The "folder" part of the path
         */
        static GetFolderPath(uri: string, returnUnchangedIfNoSlash?: boolean): string;
        static GetDOMTextContent(element: HTMLElement): string;
        static ToDegrees(angle: number): number;
        static ToRadians(angle: number): number;
        static EncodeArrayBufferTobase64(buffer: ArrayBuffer): string;
        static ExtractMinAndMaxIndexed(positions: FloatArray, indices: IndicesArray, indexStart: number, indexCount: number, bias?: Nullable<Vector2>): {
            minimum: Vector3;
            maximum: Vector3;
        };
        static ExtractMinAndMax(positions: FloatArray, start: number, count: number, bias?: Nullable<Vector2>, stride?: number): {
            minimum: Vector3;
            maximum: Vector3;
        };
        static Vector2ArrayFeeder(array: Array<Vector2> | Float32Array): (i: number) => Nullable<Vector2>;
        static ExtractMinAndMaxVector2(feeder: (index: number) => Vector2, bias?: Nullable<Vector2>): {
            minimum: Vector2;
            maximum: Vector2;
        };
        static MakeArray(obj: any, allowsNullUndefined?: boolean): Nullable<Array<any>>;
        static GetPointerPrefix(): string;
        /**
         * @param func - the function to be called
         * @param requester - the object that will request the next frame. Falls back to window.
         */
        static QueueNewFrame(func: () => void, requester?: any): number;
        static RequestFullscreen(element: HTMLElement): void;
        static ExitFullscreen(): void;
        static SetCorsBehavior(url: string | string[], element: {
            crossOrigin: string | null;
        }): void;
        static CleanUrl(url: string): string;
        static PreprocessUrl: (url: string) => string;
        static LoadImage(url: any, onLoad: (img: HTMLImageElement) => void, onError: (message?: string, exception?: any) => void, database: Nullable<Database>): HTMLImageElement;
        static LoadFile(url: string, onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void, onProgress?: (data: any) => void, database?: Database, useArrayBuffer?: boolean, onError?: (request?: XMLHttpRequest, exception?: any) => void): IFileRequest;
        /**
         * Load a script (identified by an url). When the url returns, the
         * content of this file is added into a new script element, attached to the DOM (body element)
         */
        static LoadScript(scriptUrl: string, onSuccess: () => void, onError?: (message?: string, exception?: any) => void): void;
        static ReadFileAsDataURL(fileToLoad: Blob, callback: (data: any) => void, progressCallback: (ev: ProgressEvent) => any): IFileRequest;
        static ReadFile(fileToLoad: File, callback: (data: any) => void, progressCallBack?: (ev: ProgressEvent) => any, useArrayBuffer?: boolean): IFileRequest;
        static FileAsURL(content: string): string;
        static Format(value: number, decimals?: number): string;
        static CheckExtends(v: Vector3, min: Vector3, max: Vector3): void;
        static DeepCopy(source: any, destination: any, doNotCopyList?: string[], mustCopyList?: string[]): void;
        static IsEmpty(obj: any): boolean;
        static RegisterTopRootEvents(events: {
            name: string;
            handler: Nullable<(e: FocusEvent) => any>;
        }[]): void;
        static UnregisterTopRootEvents(events: {
            name: string;
            handler: Nullable<(e: FocusEvent) => any>;
        }[]): void;
        static DumpFramebuffer(width: number, height: number, engine: Engine, successCallback?: (data: string) => void, mimeType?: string, fileName?: string): void;
        static EncodeScreenshotCanvasData(successCallback?: (data: string) => void, mimeType?: string, fileName?: string): void;
        static CreateScreenshot(engine: Engine, camera: Camera, size: any, successCallback?: (data: string) => void, mimeType?: string): void;
        /**
         * Generates an image screenshot from the specified camera.
         *
         * @param engine The engine to use for rendering
         * @param camera The camera to use for rendering
         * @param size This parameter can be set to a single number or to an object with the
         * following (optional) properties: precision, width, height. If a single number is passed,
         * it will be used for both width and height. If an object is passed, the screenshot size
         * will be derived from the parameters. The precision property is a multiplier allowing
         * rendering at a higher or lower resolution.
         * @param successCallback The callback receives a single parameter which contains the
         * screenshot as a string of base64-encoded characters. This string can be assigned to the
         * src parameter of an <img> to display it.
         * @param mimeType The MIME type of the screenshot image (default: image/png).
         * Check your browser for supported MIME types.
         * @param samples Texture samples (default: 1)
         * @param antialiasing Whether antialiasing should be turned on or not (default: false)
         * @param fileName A name for for the downloaded file.
         * @constructor
         */
        static CreateScreenshotUsingRenderTarget(engine: Engine, camera: Camera, size: any, successCallback?: (data: string) => void, mimeType?: string, samples?: number, antialiasing?: boolean, fileName?: string): void;
        static ValidateXHRData(xhr: XMLHttpRequest, dataType?: number): boolean;
        /**
         * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
         * Be aware Math.random() could cause collisions, but:
         * "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
         */
        static RandomId(): string;
        /**
        * Test if the given uri is a base64 string.
        * @param uri The uri to test
        * @return True if the uri is a base64 string or false otherwise.
        */
        static IsBase64(uri: string): boolean;
        /**
        * Decode the given base64 uri.
        * @param uri The uri to decode
        * @return The decoded base64 data.
        */
        static DecodeBase64(uri: string): ArrayBuffer;
        private static _NoneLogLevel;
        private static _MessageLogLevel;
        private static _WarningLogLevel;
        private static _ErrorLogLevel;
        private static _LogCache;
        static errorsCount: number;
        static OnNewCacheEntry: (entry: string) => void;
        static readonly NoneLogLevel: number;
        static readonly MessageLogLevel: number;
        static readonly WarningLogLevel: number;
        static readonly ErrorLogLevel: number;
        static readonly AllLogLevel: number;
        private static _AddLogEntry(entry);
        private static _FormatMessage(message);
        private static _LogDisabled(message);
        private static _LogEnabled(message);
        private static _WarnDisabled(message);
        private static _WarnEnabled(message);
        private static _ErrorDisabled(message);
        private static _ErrorEnabled(message);
        static Log: (message: string) => void;
        static Warn: (message: string) => void;
        static Error: (message: string) => void;
        static readonly LogCache: string;
        static ClearLogCache(): void;
        static LogLevels: number;
        static IsWindowObjectExist(): boolean;
        private static _PerformanceNoneLogLevel;
        private static _PerformanceUserMarkLogLevel;
        private static _PerformanceConsoleLogLevel;
        private static _performance;
        static readonly PerformanceNoneLogLevel: number;
        static readonly PerformanceUserMarkLogLevel: number;
        static readonly PerformanceConsoleLogLevel: number;
        static PerformanceLogLevel: number;
        static _StartPerformanceCounterDisabled(counterName: string, condition?: boolean): void;
        static _EndPerformanceCounterDisabled(counterName: string, condition?: boolean): void;
        static _StartUserMark(counterName: string, condition?: boolean): void;
        static _EndUserMark(counterName: string, condition?: boolean): void;
        static _StartPerformanceConsole(counterName: string, condition?: boolean): void;
        static _EndPerformanceConsole(counterName: string, condition?: boolean): void;
        static StartPerformanceCounter: (counterName: string, condition?: boolean) => void;
        static EndPerformanceCounter: (counterName: string, condition?: boolean) => void;
        static readonly Now: number;
        /**
         * This method will return the name of the class used to create the instance of the given object.
         * It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator.
         * @param object the object to get the class name from
         * @return the name of the class, will be "object" for a custom data type not using the @className decorator
         */
        static GetClassName(object: any, isType?: boolean): string;
        static First<T>(array: Array<T>, predicate: (item: T) => boolean): Nullable<T>;
        /**
         * This method will return the name of the full name of the class, including its owning module (if any).
         * It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator or implementing a method getClassName():string (in which case the module won't be specified).
         * @param object the object to get the class name from
         * @return a string that can have two forms: "moduleName.className" if module was specified when the class' Name was registered or "className" if there was not module specified.
         */
        static getFullClassName(object: any, isType?: boolean): Nullable<string>;
        /**
         * This method can be used with hashCodeFromStream when your input is an array of values that are either: number, string, boolean or custom type implementing the getHashCode():number method.
         * @param array
         */
        static arrayOrStringFeeder(array: any): (i: number) => number;
        /**
         * Compute the hashCode of a stream of number
         * To compute the HashCode on a string or an Array of data types implementing the getHashCode() method, use the arrayOrStringFeeder method.
         * @param feeder a callback that will be called until it returns null, each valid returned values will be used to compute the hash code.
         * @return the hash code computed
         */
        static hashCodeFromStream(feeder: (index: number) => number): number;
        /**
         * Returns a promise that resolves after the given amount of time.
         * @param delay Number of milliseconds to delay
         * @returns Promise that resolves after the given amount of time
         */
        static DelayAsync(delay: number): Promise<void>;
    }
    /**
     * This class is used to track a performance counter which is number based.
     * The user has access to many properties which give statistics of different nature
     *
     * The implementer can track two kinds of Performance Counter: time and count
     * For time you can optionally call fetchNewFrame() to notify the start of a new frame to monitor, then call beginMonitoring() to start and endMonitoring() to record the lapsed time. endMonitoring takes a newFrame parameter for you to specify if the monitored time should be set for a new frame or accumulated to the current frame being monitored.
     * For count you first have to call fetchNewFrame() to notify the start of a new frame to monitor, then call addCount() how many time required to increment the count value you monitor.
     */
    class PerfCounter {
        static Enabled: boolean;
        /**
         * Returns the smallest value ever
         */
        readonly min: number;
        /**
         * Returns the biggest value ever
         */
        readonly max: number;
        /**
         * Returns the average value since the performance counter is running
         */
        readonly average: number;
        /**
         * Returns the average value of the last second the counter was monitored
         */
        readonly lastSecAverage: number;
        /**
         * Returns the current value
         */
        readonly current: number;
        readonly total: number;
        readonly count: number;
        constructor();
        /**
         * Call this method to start monitoring a new frame.
         * This scenario is typically used when you accumulate monitoring time many times for a single frame, you call this method at the start of the frame, then beginMonitoring to start recording and endMonitoring(false) to accumulated the recorded time to the PerfCounter or addCount() to accumulate a monitored count.
         */
        fetchNewFrame(): void;
        /**
         * Call this method to monitor a count of something (e.g. mesh drawn in viewport count)
         * @param newCount the count value to add to the monitored count
         * @param fetchResult true when it's the last time in the frame you add to the counter and you wish to update the statistics properties (min/max/average), false if you only want to update statistics.
         */
        addCount(newCount: number, fetchResult: boolean): void;
        /**
         * Start monitoring this performance counter
         */
        beginMonitoring(): void;
        /**
         * Compute the time lapsed since the previous beginMonitoring() call.
         * @param newFrame true by default to fetch the result and monitor a new frame, if false the time monitored will be added to the current frame counter
         */
        endMonitoring(newFrame?: boolean): void;
        private _fetchResult();
        private _startMonitoringTime;
        private _min;
        private _max;
        private _average;
        private _current;
        private _totalValueCount;
        private _totalAccumulated;
        private _lastSecAverage;
        private _lastSecAccumulated;
        private _lastSecTime;
        private _lastSecValueCount;
    }
    /**
     * Use this className as a decorator on a given class definition to add it a name and optionally its module.
     * You can then use the Tools.getClassName(obj) on an instance to retrieve its class name.
     * This method is the only way to get it done in all cases, even if the .js file declaring the class is minified
     * @param name The name of the class, case should be preserved
     * @param module The name of the Module hosting the class, optional, but strongly recommended to specify if possible. Case should be preserved.
     */
    function className(name: string, module?: string): (target: Object) => void;
    /**
    * An implementation of a loop for asynchronous functions.
    */
    class AsyncLoop {
        iterations: number;
        private _fn;
        private _successCallback;
        index: number;
        private _done;
        /**
         * Constroctor.
         * @param iterations the number of iterations.
         * @param _fn the function to run each iteration
         * @param _successCallback the callback that will be called upon succesful execution
         * @param offset starting offset.
         */
        constructor(iterations: number, _fn: (asyncLoop: AsyncLoop) => void, _successCallback: () => void, offset?: number);
        /**
         * Execute the next iteration. Must be called after the last iteration was finished.
         */
        executeNext(): void;
        /**
         * Break the loop and run the success callback.
         */
        breakLoop(): void;
        /**
         * Helper function
         */
        static Run(iterations: number, _fn: (asyncLoop: AsyncLoop) => void, _successCallback: () => void, offset?: number): AsyncLoop;
        /**
         * A for-loop that will run a given number of iterations synchronous and the rest async.
         * @param iterations total number of iterations
         * @param syncedIterations number of synchronous iterations in each async iteration.
         * @param fn the function to call each iteration.
         * @param callback a success call back that will be called when iterating stops.
         * @param breakFunction a break condition (optional)
         * @param timeout timeout settings for the setTimeout function. default - 0.
         * @constructor
         */
        static SyncAsyncForLoop(iterations: number, syncedIterations: number, fn: (iteration: number) => void, callback: () => void, breakFunction?: () => boolean, timeout?: number): void;
    }
}

declare module BABYLON {
    /**
     * Defines the potential axis of a Joystick
     */
    enum JoystickAxis {
        /** X axis */
        X = 0,
        /** Y axis */
        Y = 1,
        /** Z axis */
        Z = 2,
    }
    /**
     * Class used to define virtual joystick (used in touch mode)
     */
    class VirtualJoystick {
        /**
         * Gets or sets a boolean indicating that left and right values must be inverted
         */
        reverseLeftRight: boolean;
        /**
         * Gets or sets a boolean indicating that up and down values must be inverted
         */
        reverseUpDown: boolean;
        /**
         * Gets the offset value for the position (ie. the change of the position value)
         */
        deltaPosition: Vector3;
        /**
         * Gets a boolean indicating if the virtual joystick was pressed
         */
        pressed: boolean;
        private static _globalJoystickIndex;
        private static vjCanvas;
        private static vjCanvasContext;
        private static vjCanvasWidth;
        private static vjCanvasHeight;
        private static halfWidth;
        private _action;
        private _axisTargetedByLeftAndRight;
        private _axisTargetedByUpAndDown;
        private _joystickSensibility;
        private _inversedSensibility;
        private _joystickPointerID;
        private _joystickColor;
        private _joystickPointerPos;
        private _joystickPreviousPointerPos;
        private _joystickPointerStartPos;
        private _deltaJoystickVector;
        private _leftJoystick;
        private _touches;
        private _onPointerDownHandlerRef;
        private _onPointerMoveHandlerRef;
        private _onPointerUpHandlerRef;
        private _onResize;
        /**
         * Creates a new virtual joystick
         * @param leftJoystick defines that the joystick is for left hand (false by default)
         */
        constructor(leftJoystick?: boolean);
        /**
         * Defines joystick sensibility (ie. the ratio beteen a physical move and virtual joystick position change)
         * @param newJoystickSensibility defines the new sensibility
         */
        setJoystickSensibility(newJoystickSensibility: number): void;
        private _onPointerDown(e);
        private _onPointerMove(e);
        private _onPointerUp(e);
        /**
        * Change the color of the virtual joystick
        * @param newColor a string that must be a CSS color value (like "red") or the hexa value (like "#FF0000")
        */
        setJoystickColor(newColor: string): void;
        /**
         * Defines a callback to call when the joystick is touched
         * @param action defines the callback
         */
        setActionOnTouch(action: () => any): void;
        /**
         * Defines which axis you'd like to control for left & right
         * @param axis defines the axis to use
         */
        setAxisForLeftRight(axis: JoystickAxis): void;
        /**
         * Defines which axis you'd like to control for up & down
         * @param axis defines the axis to use
         */
        setAxisForUpDown(axis: JoystickAxis): void;
        private _drawVirtualJoystick();
        /**
         * Release internal HTML canvas
         */
        releaseCanvas(): void;
    }
}

declare module BABYLON {
    /**
     * Helper class to push actions to a pool of workers.
     */
    class WorkerPool implements IDisposable {
        private _workerInfos;
        private _pendingActions;
        /**
         * Constructor
         * @param workers Array of workers to use for actions
         */
        constructor(workers: Array<Worker>);
        /**
         * Terminates all workers and clears any pending actions.
         */
        dispose(): void;
        /**
         * Pushes an action to the worker pool. If all the workers are active, the action will be
         * pended until a worker has completed its action.
         * @param action The action to perform. Call onComplete when the action is complete.
         */
        push(action: (worker: Worker, onComplete: () => void) => void): void;
        private _execute(workerInfo, action);
    }
}

declare module BABYLON {
    class AutoRotationBehavior implements Behavior<ArcRotateCamera> {
        readonly name: string;
        private _zoomStopsAnimation;
        private _idleRotationSpeed;
        private _idleRotationWaitTime;
        private _idleRotationSpinupTime;
        /**
        * Gets the flag that indicates if user zooming should stop animation.
        */
        /**
        * Sets the flag that indicates if user zooming should stop animation.
        */
        zoomStopsAnimation: boolean;
        /**
        * Gets the default speed at which the camera rotates around the model.
        */
        /**
        * Sets the default speed at which the camera rotates around the model.
        */
        idleRotationSpeed: number;
        /**
        * Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.
        */
        /**
        * Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.
        */
        idleRotationWaitTime: number;
        /**
        * Gets the time (milliseconds) to take to spin up to the full idle rotation speed.
        */
        /**
        * Sets the time (milliseconds) to take to spin up to the full idle rotation speed.
        */
        idleRotationSpinupTime: number;
        /**
         * Gets a value indicating if the camera is currently rotating because of this behavior
         */
        readonly rotationInProgress: boolean;
        private _onPrePointerObservableObserver;
        private _onAfterCheckInputsObserver;
        private _attachedCamera;
        private _isPointerDown;
        private _lastFrameTime;
        private _lastInteractionTime;
        private _cameraRotationSpeed;
        init(): void;
        attach(camera: ArcRotateCamera): void;
        detach(): void;
        /**
         * Returns true if user is scrolling.
         * @return true if user is scrolling.
         */
        private _userIsZooming();
        private _lastFrameRadius;
        private _shouldAnimationStopForInteraction();
        /**
         *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.
         */
        private _applyUserInteraction();
        private _userIsMoving();
    }
}

declare module BABYLON {
    /**
     * Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius
     */
    class BouncingBehavior implements Behavior<ArcRotateCamera> {
        readonly name: string;
        /**
         * The easing function used by animations
         */
        static EasingFunction: BackEase;
        /**
         * The easing mode used by animations
         */
        static EasingMode: number;
        /**
         * The duration of the animation, in milliseconds
         */
        transitionDuration: number;
        /**
         * Length of the distance animated by the transition when lower radius is reached
         */
        lowerRadiusTransitionRange: number;
        /**
         * Length of the distance animated by the transition when upper radius is reached
         */
        upperRadiusTransitionRange: number;
        private _autoTransitionRange;
        /**
         * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically
         */
        /**
         * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically
         * Transition ranges will be set to 5% of the bounding box diagonal in world space
         */
        autoTransitionRange: boolean;
        private _attachedCamera;
        private _onAfterCheckInputsObserver;
        private _onMeshTargetChangedObserver;
        init(): void;
        attach(camera: ArcRotateCamera): void;
        detach(): void;
        private _radiusIsAnimating;
        private _radiusBounceTransition;
        private _animatables;
        private _cachedWheelPrecision;
        /**
         * Checks if the camera radius is at the specified limit. Takes into account animation locks.
         * @param radiusLimit The limit to check against.
         * @return Bool to indicate if at limit.
         */
        private _isRadiusAtLimit(radiusLimit);
        /**
         * Applies an animation to the radius of the camera, extending by the radiusDelta.
         * @param radiusDelta The delta by which to animate to. Can be negative.
         */
        private _applyBoundRadiusAnimation(radiusDelta);
        /**
         * Removes all animation locks. Allows new animations to be added to any of the camera properties.
         */
        protected _clearAnimationLocks(): void;
        /**
         * Stops and removes all animations that have been applied to the camera
         */
        stopAllAnimations(): void;
    }
}

declare module BABYLON {
    class FramingBehavior implements Behavior<ArcRotateCamera> {
        readonly name: string;
        private _mode;
        private _radiusScale;
        private _positionScale;
        private _defaultElevation;
        private _elevationReturnTime;
        private _elevationReturnWaitTime;
        private _zoomStopsAnimation;
        private _framingTime;
        /**
         * The easing function used by animations
         */
        static EasingFunction: ExponentialEase;
        /**
         * The easing mode used by animations
         */
        static EasingMode: number;
        /**
         * Gets current mode used by the behavior.
         */
        /**
         * Sets the current mode used by the behavior
         */
        mode: number;
        /**
         * Gets the scale applied to the radius
         */
        /**
         * Sets the scale applied to the radius (1 by default)
         */
        radiusScale: number;
        /**
         * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.
         */
        /**
         * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.
         */
        positionScale: number;
        /**
        * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle
        * behaviour is triggered, in radians.
        */
        /**
        * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle
        * behaviour is triggered, in radians.
        */
        defaultElevation: number;
        /**
         * Gets the time (in milliseconds) taken to return to the default beta position.
         * Negative value indicates camera should not return to default.
         */
        /**
         * Sets the time (in milliseconds) taken to return to the default beta position.
         * Negative value indicates camera should not return to default.
         */
        elevationReturnTime: number;
        /**
         * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.
         */
        /**
         * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.
         */
        elevationReturnWaitTime: number;
        /**
        * Gets the flag that indicates if user zooming should stop animation.
        */
        /**
        * Sets the flag that indicates if user zooming should stop animation.
        */
        zoomStopsAnimation: boolean;
        /**
         * Gets the transition time when framing the mesh, in milliseconds
        */
        /**
         * Sets the transition time when framing the mesh, in milliseconds
        */
        framingTime: number;
        private _onPrePointerObservableObserver;
        private _onAfterCheckInputsObserver;
        private _onMeshTargetChangedObserver;
        private _attachedCamera;
        private _isPointerDown;
        private _lastInteractionTime;
        init(): void;
        attach(camera: ArcRotateCamera): void;
        detach(): void;
        private _animatables;
        private _betaIsAnimating;
        private _betaTransition;
        private _radiusTransition;
        private _vectorTransition;
        /**
         * Targets the given mesh and updates zoom level accordingly.
         * @param mesh  The mesh to target.
         * @param radius Optional. If a cached radius position already exists, overrides default.
         * @param framingPositionY Position on mesh to center camera focus where 0 corresponds bottom of its bounding box and 1, the top
         * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
         * @param onAnimationEnd Callback triggered at the end of the framing animation
         */
        zoomOnMesh(mesh: AbstractMesh, focusOnOriginXZ?: boolean, onAnimationEnd?: Nullable<() => void>): void;
        /**
         * Targets the given mesh with its children and updates zoom level accordingly.
         * @param mesh  The mesh to target.
         * @param radius Optional. If a cached radius position already exists, overrides default.
         * @param framingPositionY Position on mesh to center camera focus where 0 corresponds bottom of its bounding box and 1, the top
         * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
         * @param onAnimationEnd Callback triggered at the end of the framing animation
         */
        zoomOnMeshHierarchy(mesh: AbstractMesh, focusOnOriginXZ?: boolean, onAnimationEnd?: Nullable<() => void>): void;
        /**
         * Targets the given meshes with their children and updates zoom level accordingly.
         * @param meshes  The mesh to target.
         * @param radius Optional. If a cached radius position already exists, overrides default.
         * @param framingPositionY Position on mesh to center camera focus where 0 corresponds bottom of its bounding box and 1, the top
         * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
         * @param onAnimationEnd Callback triggered at the end of the framing animation
         */
        zoomOnMeshesHierarchy(meshes: AbstractMesh[], focusOnOriginXZ?: boolean, onAnimationEnd?: Nullable<() => void>): void;
        /**
         * Targets the given mesh and updates zoom level accordingly.
         * @param mesh  The mesh to target.
         * @param radius Optional. If a cached radius position already exists, overrides default.
         * @param framingPositionY Position on mesh to center camera focus where 0 corresponds bottom of its bounding box and 1, the top
         * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
         * @param onAnimationEnd Callback triggered at the end of the framing animation
         */
        zoomOnBoundingInfo(minimumWorld: Vector3, maximumWorld: Vector3, focusOnOriginXZ?: boolean, onAnimationEnd?: Nullable<() => void>): void;
        /**
         * Calculates the lowest radius for the camera based on the bounding box of the mesh.
         * @param mesh The mesh on which to base the calculation. mesh boundingInfo used to estimate necessary
         *			  frustum width.
         * @return The minimum distance from the primary mesh's center point at which the camera must be kept in order
         *		 to fully enclose the mesh in the viewing frustum.
         */
        protected _calculateLowerRadiusFromModelBoundingSphere(minimumWorld: Vector3, maximumWorld: Vector3): number;
        /**
         * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera
         * is automatically returned to its default position (expected to be above ground plane).
         */
        private _maintainCameraAboveGround();
        /**
         * Returns the frustum slope based on the canvas ratio and camera FOV
         * @returns The frustum slope represented as a Vector2 with X and Y slopes
         */
        private _getFrustumSlope();
        /**
         * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.
         */
        private _clearAnimationLocks();
        /**
         *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.
         */
        private _applyUserInteraction();
        /**
         * Stops and removes all animations that have been applied to the camera
         */
        stopAllAnimations(): void;
        /**
         * Gets a value indicating if the user is moving the camera
         */
        readonly isUserIsMoving: boolean;
        /**
         * The camera can move all the way towards the mesh.
         */
        static IgnoreBoundsSizeMode: number;
        /**
         * The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides
         */
        static FitFrustumSidesMode: number;
    }
}

declare module BABYLON {
    class ArcRotateCameraGamepadInput implements ICameraInput<ArcRotateCamera> {
        camera: ArcRotateCamera;
        gamepad: Nullable<Gamepad>;
        private _onGamepadConnectedObserver;
        private _onGamepadDisconnectedObserver;
        gamepadRotationSensibility: number;
        gamepadMoveSensibility: number;
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        detachControl(element: Nullable<HTMLElement>): void;
        checkInputs(): void;
        getClassName(): string;
        getSimpleName(): string;
    }
}

declare module BABYLON {
    class ArcRotateCameraKeyboardMoveInput implements ICameraInput<ArcRotateCamera> {
        camera: ArcRotateCamera;
        private _keys;
        keysUp: number[];
        keysDown: number[];
        keysLeft: number[];
        keysRight: number[];
        keysReset: number[];
        panningSensibility: number;
        zoomingSensibility: number;
        useAltToZoom: boolean;
        private _ctrlPressed;
        private _altPressed;
        private _onCanvasBlurObserver;
        private _onKeyboardObserver;
        private _engine;
        private _scene;
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        detachControl(element: Nullable<HTMLElement>): void;
        checkInputs(): void;
        getClassName(): string;
        getSimpleName(): string;
    }
}

declare module BABYLON {
    class ArcRotateCameraMouseWheelInput implements ICameraInput<ArcRotateCamera> {
        camera: ArcRotateCamera;
        private _wheel;
        private _observer;
        wheelPrecision: number;
        /**
         * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.
         * It defines the percentage of current camera.radius to use as delta when wheel is used.
         */
        wheelDeltaPercentage: number;
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        detachControl(element: Nullable<HTMLElement>): void;
        getClassName(): string;
        getSimpleName(): string;
    }
}

declare module BABYLON {
    class ArcRotateCameraPointersInput implements ICameraInput<ArcRotateCamera> {
        camera: ArcRotateCamera;
        buttons: number[];
        angularSensibilityX: number;
        angularSensibilityY: number;
        pinchPrecision: number;
        /**
         * pinchDeltaPercentage will be used instead of pinchPrecision if different from 0.
         * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.
         */
        pinchDeltaPercentage: number;
        panningSensibility: number;
        multiTouchPanning: boolean;
        multiTouchPanAndZoom: boolean;
        private _isPanClick;
        pinchInwards: boolean;
        private _pointerInput;
        private _observer;
        private _onMouseMove;
        private _onGestureStart;
        private _onGesture;
        private _MSGestureHandler;
        private _onLostFocus;
        private _onContextMenu;
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        detachControl(element: Nullable<HTMLElement>): void;
        getClassName(): string;
        getSimpleName(): string;
    }
}

declare module BABYLON {
    class ArcRotateCameraVRDeviceOrientationInput implements ICameraInput<ArcRotateCamera> {
        camera: ArcRotateCamera;
        alphaCorrection: number;
        betaCorrection: number;
        gammaCorrection: number;
        private _alpha;
        private _gamma;
        private _dirty;
        private _deviceOrientationHandler;
        constructor();
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        _onOrientationEvent(evt: DeviceOrientationEvent): void;
        checkInputs(): void;
        detachControl(element: Nullable<HTMLElement>): void;
        getClassName(): string;
        getSimpleName(): string;
    }
}

declare module BABYLON {
    /**
     * Takes information about the orientation of the device as reported by the deviceorientation event to orient the camera.
     * Screen rotation is taken into account.
     */
    class FreeCameraDeviceOrientationInput implements ICameraInput<FreeCamera> {
        private _camera;
        private _screenOrientationAngle;
        private _constantTranform;
        private _screenQuaternion;
        private _alpha;
        private _beta;
        private _gamma;
        constructor();
        camera: FreeCamera;
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        private _orientationChanged;
        private _deviceOrientation;
        detachControl(element: Nullable<HTMLElement>): void;
        checkInputs(): void;
        getClassName(): string;
        getSimpleName(): string;
    }
}

declare module BABYLON {
    class FreeCameraGamepadInput implements ICameraInput<FreeCamera> {
        camera: FreeCamera;
        gamepad: Nullable<Gamepad>;
        private _onGamepadConnectedObserver;
        private _onGamepadDisconnectedObserver;
        gamepadAngularSensibility: number;
        gamepadMoveSensibility: number;
        private _cameraTransform;
        private _deltaTransform;
        private _vector3;
        private _vector2;
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        detachControl(element: Nullable<HTMLElement>): void;
        checkInputs(): void;
        getClassName(): string;
        getSimpleName(): string;
    }
}

declare module BABYLON {
    class FreeCameraKeyboardMoveInput implements ICameraInput<FreeCamera> {
        camera: FreeCamera;
        private _keys;
        private _onCanvasBlurObserver;
        private _onKeyboardObserver;
        private _engine;
        private _scene;
        keysUp: number[];
        keysDown: number[];
        keysLeft: number[];
        keysRight: number[];
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        detachControl(element: Nullable<HTMLElement>): void;
        checkInputs(): void;
        getClassName(): string;
        _onLostFocus(e: FocusEvent): void;
        getSimpleName(): string;
    }
}

declare module BABYLON {
    class FreeCameraMouseInput implements ICameraInput<FreeCamera> {
        touchEnabled: boolean;
        camera: FreeCamera;
        buttons: number[];
        angularSensibility: number;
        private _pointerInput;
        private _onMouseMove;
        private _observer;
        private previousPosition;
        constructor(touchEnabled?: boolean);
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        detachControl(element: Nullable<HTMLElement>): void;
        getClassName(): string;
        getSimpleName(): string;
    }
}

declare module BABYLON {
    class FreeCameraTouchInput implements ICameraInput<FreeCamera> {
        camera: FreeCamera;
        private _offsetX;
        private _offsetY;
        private _pointerPressed;
        private _pointerInput;
        private _observer;
        private _onLostFocus;
        touchAngularSensibility: number;
        touchMoveSensibility: number;
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        detachControl(element: Nullable<HTMLElement>): void;
        checkInputs(): void;
        getClassName(): string;
        getSimpleName(): string;
    }
}

declare module BABYLON {
    class FreeCameraVirtualJoystickInput implements ICameraInput<FreeCamera> {
        camera: FreeCamera;
        private _leftjoystick;
        private _rightjoystick;
        getLeftJoystick(): VirtualJoystick;
        getRightJoystick(): VirtualJoystick;
        checkInputs(): void;
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        detachControl(element: Nullable<HTMLElement>): void;
        getClassName(): string;
        getSimpleName(): string;
    }
}

declare module BABYLON {
    class VRCameraMetrics {
        hResolution: number;
        vResolution: number;
        hScreenSize: number;
        vScreenSize: number;
        vScreenCenter: number;
        eyeToScreenDistance: number;
        lensSeparationDistance: number;
        interpupillaryDistance: number;
        distortionK: number[];
        chromaAbCorrection: number[];
        postProcessScaleFactor: number;
        lensCenterOffset: number;
        compensateDistortion: boolean;
        readonly aspectRatio: number;
        readonly aspectRatioFov: number;
        readonly leftHMatrix: Matrix;
        readonly rightHMatrix: Matrix;
        readonly leftPreViewMatrix: Matrix;
        readonly rightPreViewMatrix: Matrix;
        static GetDefault(): VRCameraMetrics;
    }
}

declare module BABYLON {
    class VRDeviceOrientationFreeCamera extends DeviceOrientationCamera {
        constructor(name: string, position: Vector3, scene: Scene, compensateDistortion?: boolean, vrCameraMetrics?: VRCameraMetrics);
        getClassName(): string;
    }
    class VRDeviceOrientationGamepadCamera extends VRDeviceOrientationFreeCamera {
        constructor(name: string, position: Vector3, scene: Scene, compensateDistortion?: boolean, vrCameraMetrics?: VRCameraMetrics);
        getClassName(): string;
    }
    class VRDeviceOrientationArcRotateCamera extends ArcRotateCamera {
        constructor(name: string, alpha: number, beta: number, radius: number, target: Vector3, scene: Scene, compensateDistortion?: boolean, vrCameraMetrics?: VRCameraMetrics);
        getClassName(): string;
    }
}

declare module BABYLON {
    /**
     * Options to modify the vr teleportation behavior.
     */
    interface VRTeleportationOptions {
        /**
         * The name of the mesh which should be used as the teleportation floor. (default: null)
         */
        floorMeshName?: string;
        /**
         * A list of meshes to be used as the teleportation floor. (default: empty)
         */
        floorMeshes?: Mesh[];
    }
    /**
     * Options to modify the vr experience helper's behavior.
     */
    interface VRExperienceHelperOptions extends WebVROptions {
        /**
         * Create a DeviceOrientationCamera to be used as your out of vr camera.
         */
        createDeviceOrientationCamera?: boolean;
        /**
         * Create a VRDeviceOrientationFreeCamera to be used for VR when no external HMD is found.
         */
        createFallbackVRDeviceOrientationFreeCamera?: boolean;
    }
    /**
     * Helps to quickly add VR support to an existing scene.
     * See http://doc.babylonjs.com/how_to/webvr_helper
     */
    class VRExperienceHelper {
        /** Options to modify the vr experience helper's behavior. */ webVROptions: VRExperienceHelperOptions;
        private _scene;
        private _position;
        private _btnVR;
        private _btnVRDisplayed;
        private _webVRsupported;
        private _webVRready;
        private _webVRrequesting;
        private _webVRpresenting;
        private _fullscreenVRpresenting;
        private _canvas;
        private _webVRCamera;
        private _vrDeviceOrientationCamera;
        private _deviceOrientationCamera;
        private _existingCamera;
        private _onKeyDown;
        private _onVrDisplayPresentChange;
        private _onVRDisplayChanged;
        private _onVRRequestPresentStart;
        private _onVRRequestPresentComplete;
        /**
         * Observable raised when entering VR.
         */
        onEnteringVRObservable: Observable<VRExperienceHelper>;
        /**
         * Observable raised when exiting VR.
         */
        onExitingVRObservable: Observable<VRExperienceHelper>;
        /**
         * Observable raised when controller mesh is loaded.
         */
        onControllerMeshLoadedObservable: Observable<WebVRController>;
        /** Return this.onEnteringVRObservable
         * Note: This one is for backward compatibility. Please use onEnteringVRObservable directly
         */
        readonly onEnteringVR: Observable<VRExperienceHelper>;
        /** Return this.onExitingVRObservable
         * Note: This one is for backward compatibility. Please use onExitingVRObservable directly
         */
        readonly onExitingVR: Observable<VRExperienceHelper>;
        /** Return this.onControllerMeshLoadedObservable
         * Note: This one is for backward compatibility. Please use onControllerMeshLoadedObservable directly
         */
        readonly onControllerMeshLoaded: Observable<WebVRController>;
        private _rayLength;
        private _useCustomVRButton;
        private _teleportationRequested;
        private _teleportActive;
        private _floorMeshName;
        private _floorMeshesCollection;
        private _rotationAllowed;
        private _teleportBackwardsVector;
        private _teleportationTarget;
        private _isDefaultTeleportationTarget;
        private _postProcessMove;
        private _teleportationFillColor;
        private _teleportationBorderColor;
        private _rotationAngle;
        private _haloCenter;
        private _cameraGazer;
        private _padSensibilityUp;
        private _padSensibilityDown;
        private leftController;
        private rightController;
        /**
         * Observable raised when a new mesh is selected based on meshSelectionPredicate
         */
        onNewMeshSelected: Observable<AbstractMesh>;
        /**
         * Observable raised when a new mesh is picked based on meshSelectionPredicate
         */
        onNewMeshPicked: Observable<PickingInfo>;
        private _circleEase;
        /**
         * Observable raised before camera teleportation
        */
        onBeforeCameraTeleport: Observable<Vector3>;
        /**
         *  Observable raised after camera teleportation
        */
        onAfterCameraTeleport: Observable<Vector3>;
        /**
        * Observable raised when current selected mesh gets unselected
        */
        onSelectedMeshUnselected: Observable<AbstractMesh>;
        private _raySelectionPredicate;
        /**
         * To be optionaly changed by user to define custom ray selection
         */
        raySelectionPredicate: (mesh: AbstractMesh) => boolean;
        /**
         * To be optionaly changed by user to define custom selection logic (after ray selection)
         */
        meshSelectionPredicate: (mesh: AbstractMesh) => boolean;
        /**
         * Set teleportation enabled. If set to false camera teleportation will be disabled but camera rotation will be kept.
         */
        teleportationEnabled: boolean;
        private _defaultHeight;
        private _teleportationInitialized;
        private _interactionsEnabled;
        private _interactionsRequested;
        private _displayGaze;
        private _displayLaserPointer;
        /**
         * The mesh used to display where the user is going to teleport.
         */
        /**
         * Sets the mesh to be used to display where the user is going to teleport.
         */
        teleportationTarget: Mesh;
        /**
         * The mesh used to display where the user is selecting,
         * when set bakeCurrentTransformIntoVertices will be called on the mesh.
         * See http://doc.babylonjs.com/resources/baking_transformations
         */
        gazeTrackerMesh: Mesh;
        /**
         * If the ray of the gaze should be displayed.
         */
        /**
         * Sets if the ray of the gaze should be displayed.
         */
        displayGaze: boolean;
        /**
         * If the ray of the LaserPointer should be displayed.
         */
        /**
         * Sets if the ray of the LaserPointer should be displayed.
         */
        displayLaserPointer: boolean;
        /**
         * The deviceOrientationCamera used as the camera when not in VR.
         */
        readonly deviceOrientationCamera: Nullable<DeviceOrientationCamera>;
        /**
         * Based on the current WebVR support, returns the current VR camera used.
         */
        readonly currentVRCamera: Nullable<Camera>;
        /**
         * The webVRCamera which is used when in VR.
         */
        readonly webVRCamera: WebVRFreeCamera;
        /**
         * The deviceOrientationCamera that is used as a fallback when vr device is not connected.
         */
        readonly vrDeviceOrientationCamera: Nullable<VRDeviceOrientationFreeCamera>;
        private readonly _teleportationRequestInitiated;
        /**
         * Instantiates a VRExperienceHelper.
         * Helps to quickly add VR support to an existing scene.
         * @param scene The scene the VRExperienceHelper belongs to.
         * @param webVROptions Options to modify the vr experience helper's behavior.
         */
        constructor(scene: Scene, /** Options to modify the vr experience helper's behavior. */ webVROptions?: VRExperienceHelperOptions);
        private _onDefaultMeshLoaded(webVRController);
        private _onResize;
        private _onFullscreenChange;
        /**
         * Gets a value indicating if we are currently in VR mode.
         */
        readonly isInVRMode: boolean;
        private onVrDisplayPresentChange();
        private onVRDisplayChanged(eventArgs);
        private moveButtonToBottomRight();
        private displayVRButton();
        private updateButtonVisibility();
        /**
         * Attempt to enter VR. If a headset is connected and ready, will request present on that.
         * Otherwise, will use the fullscreen API.
         */
        enterVR(): void;
        /**
         * Attempt to exit VR, or fullscreen.
         */
        exitVR(): void;
        /**
         * The position of the vr experience helper.
         */
        /**
         * Sets the position of the vr experience helper.
         */
        position: Vector3;
        /**
         * Enables controllers and user interactions suck as selecting and object or clicking on an object.
         */
        enableInteractions(): void;
        private beforeRender;
        private _isTeleportationFloor(mesh);
        /**
         * Adds a floor mesh to be used for teleportation.
         * @param floorMesh the mesh to be used for teleportation.
         */
        addFloorMesh(floorMesh: Mesh): void;
        /**
         * Removes a floor mesh from being used for teleportation.
         * @param floorMesh the mesh to be removed.
         */
        removeFloorMesh(floorMesh: Mesh): void;
        /**
         * Enables interactions and teleportation using the VR controllers and gaze.
         * @param vrTeleportationOptions options to modify teleportation behavior.
         */
        enableTeleportation(vrTeleportationOptions?: VRTeleportationOptions): void;
        private _onNewGamepadConnected;
        private _tryEnableInteractionOnController;
        private _onNewGamepadDisconnected;
        private _enableInteractionOnController(controller);
        private _checkTeleportWithRay(stateObject, gazer);
        private _checkRotate(stateObject, gazer);
        private _checkTeleportBackwards(stateObject, gazer);
        private _enableTeleportationOnController(controller);
        private _createTeleportationCircles();
        private _displayTeleportationTarget();
        private _hideTeleportationTarget();
        private _rotateCamera(right);
        private _moveTeleportationSelectorTo(hit, gazer, ray);
        private _workingVector;
        private _workingQuaternion;
        private _workingMatrix;
        private _teleportCamera(location);
        private _convertNormalToDirectionOfRay(normal, ray);
        private _castRayAndSelectObject(gazer);
        private _notifySelectedMeshUnselected(mesh);
        /**
         * Sets the color of the laser ray from the vr controllers.
         * @param color new color for the ray.
         */
        changeLaserColor(color: Color3): void;
        /**
         * Sets the color of the ray from the vr headsets gaze.
         * @param color new color for the ray.
         */
        changeGazeColor(color: Color3): void;
        /**
         * Exits VR and disposes of the vr experience helper
         */
        dispose(): void;
        /**
         * Gets the name of the VRExperienceHelper class
         * @returns "VRExperienceHelper"
         */
        getClassName(): string;
    }
}

declare module BABYLON {
    /**
     * This is a copy of VRPose. See https://developer.mozilla.org/en-US/docs/Web/API/VRPose
     * IMPORTANT!! The data is right-hand data.
     * @export
     * @interface DevicePose
     */
    interface DevicePose {
        /**
         * The position of the device, values in array are [x,y,z].
         */
        readonly position: Nullable<Float32Array>;
        /**
         * The linearVelocity of the device, values in array are [x,y,z].
         */
        readonly linearVelocity: Nullable<Float32Array>;
        /**
         * The linearAcceleration of the device, values in array are [x,y,z].
         */
        readonly linearAcceleration: Nullable<Float32Array>;
        /**
         * The orientation of the device in a quaternion array, values in array are [x,y,z,w].
         */
        readonly orientation: Nullable<Float32Array>;
        /**
         * The angularVelocity of the device, values in array are [x,y,z].
         */
        readonly angularVelocity: Nullable<Float32Array>;
        /**
         * The angularAcceleration of the device, values in array are [x,y,z].
         */
        readonly angularAcceleration: Nullable<Float32Array>;
    }
    /**
    * Interface representing a pose controlled object in Babylon.
    * A pose controlled object has both regular pose values as well as pose values
    * from an external device such as a VR head mounted display
    */
    interface PoseControlled {
        /**
         * The position of the object in babylon space.
         */
        position: Vector3;
        /**
         * The rotation quaternion of the object in babylon space.
         */
        rotationQuaternion: Quaternion;
        /**
         * The position of the device in babylon space.
         */
        devicePosition?: Vector3;
        /**
         * The rotation quaternion of the device in babylon space.
         */
        deviceRotationQuaternion: Quaternion;
        /**
         * The raw pose coming from the device.
         */
        rawPose: Nullable<DevicePose>;
        /**
         * The scale of the device to be used when translating from device space to babylon space.
         */
        deviceScaleFactor: number;
        /**
         * Updates the poseControlled values based on the input device pose.
         * @param poseData the pose data to update the object with
         */
        updateFromDevice(poseData: DevicePose): void;
    }
    /**
     * Set of options to customize the webVRCamera
     */
    interface WebVROptions {
        /**
         * Sets if the webVR camera should be tracked to the vrDevice. (default: true)
         */
        trackPosition?: boolean;
        /**
         * Sets the scale of the vrDevice in babylon space. (default: 1)
         */
        positionScale?: number;
        /**
         * If there are more than one VRDisplays, this will choose the display matching this name. (default: pick first vrDisplay)
         */
        displayName?: string;
        /**
         * Should the native controller meshes be initialized. (default: true)
         */
        controllerMeshes?: boolean;
        /**
         * Creating a default HemiLight only on controllers. (default: true)
         */
        defaultLightingOnControllers?: boolean;
        /**
         * If you don't want to use the default VR button of the helper. (default: false)
         */
        useCustomVRButton?: boolean;
        /**
         * If you'd like to provide your own button to the VRHelper. (default: standard babylon vr button)
         */
        customVRButton?: HTMLButtonElement;
        /**
         * To change the length of the ray for gaze/controllers. Will be scaled by positionScale. (default: 100)
         */
        rayLength?: number;
        /**
         * To change the default offset from the ground to account for user's height in meters. Will be scaled by positionScale. (default: 1.7)
         */
        defaultHeight?: number;
    }
    /**
     * This represents a WebVR camera.
     * The WebVR camera is Babylon's simple interface to interaction with Windows Mixed Reality, HTC Vive and Oculus Rift.
     * @example http://doc.babylonjs.com/how_to/webvr_camera
     */
    class WebVRFreeCamera extends FreeCamera implements PoseControlled {
        private webVROptions;
        /**
         * The vrDisplay tied to the camera. See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay
         */
        _vrDevice: any;
        /**
         * The rawPose of the vrDevice.
         */
        rawPose: Nullable<DevicePose>;
        private _onVREnabled;
        private _specsVersion;
        private _attached;
        private _frameData;
        protected _descendants: Array<Node>;
        private _deviceRoomPosition;
        private _deviceRoomRotationQuaternion;
        private _standingMatrix;
        /**
         * Represents device position in babylon space.
         */
        devicePosition: Vector3;
        /**
         * Represents device rotation in babylon space.
         */
        deviceRotationQuaternion: Quaternion;
        /**
         * The scale of the device to be used when translating from device space to babylon space.
         */
        deviceScaleFactor: number;
        private _deviceToWorld;
        private _worldToDevice;
        /**
         * References to the webVR controllers for the vrDevice.
         */
        controllers: Array<WebVRController>;
        /**
         * Emits an event when a controller is attached.
         */
        onControllersAttachedObservable: Observable<WebVRController[]>;
        /**
         * Emits an event when a controller's mesh has been loaded;
         */
        onControllerMeshLoadedObservable: Observable<WebVRController>;
        /**
         * If the rig cameras be used as parent instead of this camera.
         */
        rigParenting: boolean;
        private _lightOnControllers;
        private _defaultHeight?;
        /**
         * Instantiates a WebVRFreeCamera.
         * @param name The name of the WebVRFreeCamera
         * @param position The starting anchor position for the camera
         * @param scene The scene the camera belongs to
         * @param webVROptions a set of customizable options for the webVRCamera
         */
        constructor(name: string, position: Vector3, scene: Scene, webVROptions?: WebVROptions);
        /**
         * Gets the device distance from the ground in meters.
         * @returns the distance in meters from the vrDevice to ground in device space. If standing matrix is not supported for the vrDevice 0 is returned.
         */
        deviceDistanceToRoomGround(): number;
        /**
         * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.
         * @param callback will be called when the standing matrix is set. Callback parameter is if the standing matrix is supported.
         */
        useStandingMatrix(callback?: (bool: boolean) => void): void;
        /**
         * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.
         * @returns A promise with a boolean set to if the standing matrix is supported.
         */
        useStandingMatrixAsync(): Promise<boolean>;
        /**
         * Disposes the camera
         */
        dispose(): void;
        /**
         * Gets a vrController by name.
         * @param name The name of the controller to retreive
         * @returns the controller matching the name specified or null if not found
         */
        getControllerByName(name: string): Nullable<WebVRController>;
        private _leftController;
        /**
         * The controller corrisponding to the users left hand.
         */
        readonly leftController: Nullable<WebVRController>;
        private _rightController;
        /**
         * The controller corrisponding to the users right hand.
         */
        readonly rightController: Nullable<WebVRController>;
        /**
         * Casts a ray forward from the vrCamera's gaze.
         * @param length Length of the ray (default: 100)
         * @returns the ray corrisponding to the gaze
         */
        getForwardRay(length?: number): Ray;
        /**
         * Updates the camera based on device's frame data
         */
        _checkInputs(): void;
        /**
         * Updates the poseControlled values based on the input device pose.
         * @param poseData Pose coming from the device
         */
        updateFromDevice(poseData: DevicePose): void;
        /**
         * WebVR's attach control will start broadcasting frames to the device.
         * Note that in certain browsers (chrome for example) this function must be called
         * within a user-interaction callback. Example:
         * <pre> scene.onPointerDown = function() { camera.attachControl(canvas); }</pre>
         *
         * @param element html element to attach the vrDevice to
         * @param noPreventDefault prevent the default html element operation when attaching the vrDevice
         */
        attachControl(element: HTMLElement, noPreventDefault?: boolean): void;
        /**
         * Detaches the camera from the html element and disables VR
         *
         * @param element html element to detach from
         */
        detachControl(element: HTMLElement): void;
        /**
         * @returns the name of this class
         */
        getClassName(): string;
        /**
         * Calls resetPose on the vrDisplay
         * See: https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/resetPose
         */
        resetToCurrentRotation(): void;
        /**
         * Updates the rig cameras (left and right eye)
         */
        _updateRigCameras(): void;
        private _workingVector;
        private _oneVector;
        private _workingMatrix;
        private updateCacheCalled;
        /**
         * Updates the cached values of the camera
         * @param ignoreParentClass ignores updating the parent class's cache (default: false)
         */
        _updateCache(ignoreParentClass?: boolean): void;
        /**
         * Updates the current device position and rotation in the babylon world
         */
        update(): void;
        /**
         * Gets the view matrix of this camera (Always set to identity as left and right eye cameras contain the actual view matrix)
         * @returns an identity matrix
         */
        _getViewMatrix(): Matrix;
        /**
         * This function is called by the two RIG cameras.
         * 'this' is the left or right camera (and NOT (!!!) the WebVRFreeCamera instance)
         */
        protected _getWebVRViewMatrix(): Matrix;
        protected _getWebVRProjectionMatrix(): Matrix;
        private _onGamepadConnectedObserver;
        private _onGamepadDisconnectedObserver;
        /**
         * Initializes the controllers and their meshes
         */
        initControllers(): void;
    }
}

declare module BABYLON {
    interface IOctreeContainer<T> {
        blocks: Array<OctreeBlock<T>>;
    }
    class Octree<T> {
        maxDepth: number;
        blocks: Array<OctreeBlock<T>>;
        dynamicContent: T[];
        private _maxBlockCapacity;
        private _selectionContent;
        private _creationFunc;
        constructor(creationFunc: (entry: T, block: OctreeBlock<T>) => void, maxBlockCapacity?: number, maxDepth?: number);
        update(worldMin: Vector3, worldMax: Vector3, entries: T[]): void;
        addMesh(entry: T): void;
        select(frustumPlanes: Plane[], allowDuplicate?: boolean): SmartArray<T>;
        intersects(sphereCenter: Vector3, sphereRadius: number, allowDuplicate?: boolean): SmartArray<T>;
        intersectsRay(ray: Ray): SmartArray<T>;
        static _CreateBlocks<T>(worldMin: Vector3, worldMax: Vector3, entries: T[], maxBlockCapacity: number, currentDepth: number, maxDepth: number, target: IOctreeContainer<T>, creationFunc: (entry: T, block: OctreeBlock<T>) => void): void;
        static CreationFuncForMeshes: (entry: AbstractMesh, block: OctreeBlock<AbstractMesh>) => void;
        static CreationFuncForSubMeshes: (entry: SubMesh, block: OctreeBlock<SubMesh>) => void;
    }
}

declare module BABYLON {
    class OctreeBlock<T> {
        entries: T[];
        blocks: Array<OctreeBlock<T>>;
        private _depth;
        private _maxDepth;
        private _capacity;
        private _minPoint;
        private _maxPoint;
        private _boundingVectors;
        private _creationFunc;
        constructor(minPoint: Vector3, maxPoint: Vector3, capacity: number, depth: number, maxDepth: number, creationFunc: (entry: T, block: OctreeBlock<T>) => void);
        readonly capacity: number;
        readonly minPoint: Vector3;
        readonly maxPoint: Vector3;
        addEntry(entry: T): void;
        addEntries(entries: T[]): void;
        select(frustumPlanes: Plane[], selection: SmartArrayNoDuplicate<T>, allowDuplicate?: boolean): void;
        intersects(sphereCenter: Vector3, sphereRadius: number, selection: SmartArrayNoDuplicate<T>, allowDuplicate?: boolean): void;
        intersectsRay(ray: Ray, selection: SmartArrayNoDuplicate<T>): void;
        createInnerBlocks(): void;
    }
}

declare module BABYLON {
    /**
     * Google Daydream controller
     */
    class DaydreamController extends WebVRController {
        /**
         * Base Url for the controller model.
         */
        static MODEL_BASE_URL: string;
        /**
         * File name for the controller model.
         */
        static MODEL_FILENAME: string;
        /**
         * Gamepad Id prefix used to identify Daydream Controller.
         */
        static readonly GAMEPAD_ID_PREFIX: string;
        /**
         * Creates a new DaydreamController from a gamepad
         * @param vrGamepad the gamepad that the controller should be created from
         */
        constructor(vrGamepad: any);
        /**
         * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
         * @param scene scene in which to add meshes
         * @param meshLoaded optional callback function that will be called if the mesh loads successfully.
         */
        initControllerMesh(scene: Scene, meshLoaded?: (mesh: AbstractMesh) => void): void;
        /**
         * Called once for each button that changed state since the last frame
         * @param buttonIdx Which button index changed
         * @param state New state of the button
         * @param changes Which properties on the state changed since last frame
         */
        protected _handleButtonChange(buttonIdx: number, state: ExtendedGamepadButton, changes: GamepadButtonChanges): void;
    }
}

declare module BABYLON {
    /**
     * Gear VR Controller
     */
    class GearVRController extends WebVRController {
        /**
         * Base Url for the controller model.
         */
        static MODEL_BASE_URL: string;
        /**
         * File name for the controller model.
         */
        static MODEL_FILENAME: string;
        /**
         * Gamepad Id prefix used to identify this controller.
         */
        static readonly GAMEPAD_ID_PREFIX: string;
        private readonly _buttonIndexToObservableNameMap;
        /**
         * Creates a new GearVRController from a gamepad
         * @param vrGamepad the gamepad that the controller should be created from
         */
        constructor(vrGamepad: any);
        /**
         * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
         * @param scene scene in which to add meshes
         * @param meshLoaded optional callback function that will be called if the mesh loads successfully.
         */
        initControllerMesh(scene: Scene, meshLoaded?: (mesh: AbstractMesh) => void): void;
        /**
         * Called once for each button that changed state since the last frame
         * @param buttonIdx Which button index changed
         * @param state New state of the button
         * @param changes Which properties on the state changed since last frame
         */
        protected _handleButtonChange(buttonIdx: number, state: ExtendedGamepadButton, changes: GamepadButtonChanges): void;
    }
}

declare module BABYLON {
    /**
     * Generic Controller
     */
    class GenericController extends WebVRController {
        /**
         * Base Url for the controller model.
         */
        static readonly MODEL_BASE_URL: string;
        /**
         * File name for the controller model.
         */
        static readonly MODEL_FILENAME: string;
        /**
         * Creates a new GenericController from a gamepad
         * @param vrGamepad the gamepad that the controller should be created from
         */
        constructor(vrGamepad: any);
        /**
         * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
         * @param scene scene in which to add meshes
         * @param meshLoaded optional callback function that will be called if the mesh loads successfully.
         */
        initControllerMesh(scene: Scene, meshLoaded?: (mesh: AbstractMesh) => void): void;
        /**
         * Called once for each button that changed state since the last frame
         * @param buttonIdx Which button index changed
         * @param state New state of the button
         * @param changes Which properties on the state changed since last frame
         */
        protected _handleButtonChange(buttonIdx: number, state: ExtendedGamepadButton, changes: GamepadButtonChanges): void;
    }
}

declare module BABYLON {
    /**
     * Oculus Touch Controller
     */
    class OculusTouchController extends WebVRController {
        /**
         * Base Url for the controller model.
         */
        static MODEL_BASE_URL: string;
        /**
         * File name for the left controller model.
         */
        static MODEL_LEFT_FILENAME: string;
        /**
         * File name for the right controller model.
         */
        static MODEL_RIGHT_FILENAME: string;
        /**
         * Fired when the secondary trigger on this controller is modified
         */
        onSecondaryTriggerStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the thumb rest on this controller is modified
         */
        onThumbRestChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Creates a new OculusTouchController from a gamepad
         * @param vrGamepad the gamepad that the controller should be created from
         */
        constructor(vrGamepad: any);
        /**
         * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
         * @param scene scene in which to add meshes
         * @param meshLoaded optional callback function that will be called if the mesh loads successfully.
         */
        initControllerMesh(scene: Scene, meshLoaded?: (mesh: AbstractMesh) => void): void;
        /**
         * Fired when the A button on this controller is modified
         */
        readonly onAButtonStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the B button on this controller is modified
         */
        readonly onBButtonStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the X button on this controller is modified
         */
        readonly onXButtonStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the Y button on this controller is modified
         */
        readonly onYButtonStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
          * Called once for each button that changed state since the last frame
          * 0) thumb stick (touch, press, value = pressed (0,1)). value is in this.leftStick
          * 1) index trigger (touch (?), press (only when value > 0.1), value 0 to 1)
          * 2) secondary trigger (same)
          * 3) A (right) X (left), touch, pressed = value
          * 4) B / Y
          * 5) thumb rest
          * @param buttonIdx Which button index changed
          * @param state New state of the button
          * @param changes Which properties on the state changed since last frame
          */
        protected _handleButtonChange(buttonIdx: number, state: ExtendedGamepadButton, changes: GamepadButtonChanges): void;
    }
}

declare module BABYLON {
    /**
    * Defines the types of pose enabled controllers that are supported
    */
    enum PoseEnabledControllerType {
        /**
         * HTC Vive
         */
        VIVE = 0,
        /**
         * Oculus Rift
         */
        OCULUS = 1,
        /**
         * Windows mixed reality
         */
        WINDOWS = 2,
        /**
         * Samsung gear VR
         */
        GEAR_VR = 3,
        /**
         * Google Daydream
         */
        DAYDREAM = 4,
        /**
         * Generic
         */
        GENERIC = 5,
    }
    /**
     * Defines the MutableGamepadButton interface for the state of a gamepad button
     */
    interface MutableGamepadButton {
        /**
         * Value of the button/trigger
         */
        value: number;
        /**
         * If the button/trigger is currently touched
         */
        touched: boolean;
        /**
         * If the button/trigger is currently pressed
         */
        pressed: boolean;
    }
    /**
     * Defines the ExtendedGamepadButton interface for a gamepad button which includes state provided by a pose controller
     * @hidden
     */
    interface ExtendedGamepadButton extends GamepadButton {
        /**
         * If the button/trigger is currently pressed
         */
        readonly pressed: boolean;
        /**
         * If the button/trigger is currently touched
         */
        readonly touched: boolean;
        /**
         * Value of the button/trigger
         */
        readonly value: number;
    }
    /**
     * Defines the PoseEnabledControllerHelper object that is used initialize a gamepad as the controller type it is specified as (eg. windows mixed reality controller)
     */
    class PoseEnabledControllerHelper {
        /**
         * Initializes a gamepad as the controller type it is specified as (eg. windows mixed reality controller)
         * @param vrGamepad the gamepad to initialized
         * @returns a vr controller of the type the gamepad identified as
         */
        static InitiateController(vrGamepad: any): OculusTouchController | WindowsMotionController | ViveController | GearVRController | DaydreamController | GenericController;
    }
    /**
     * Defines the PoseEnabledController object that contains state of a vr capable controller
     */
    class PoseEnabledController extends Gamepad implements PoseControlled {
        private _deviceRoomPosition;
        private _deviceRoomRotationQuaternion;
        /**
         * The device position in babylon space
         */
        devicePosition: Vector3;
        /**
         * The device rotation in babylon space
         */
        deviceRotationQuaternion: Quaternion;
        /**
         * The scale factor of the device in babylon space
         */
        deviceScaleFactor: number;
        /**
         * (Likely devicePosition should be used instead) The device position in its room space
         */
        position: Vector3;
        /**
         * (Likely deviceRotationQuaternion should be used instead) The device rotation in its room space
         */
        rotationQuaternion: Quaternion;
        /**
         * The type of controller (Eg. Windows mixed reality)
         */
        controllerType: PoseEnabledControllerType;
        private _calculatedPosition;
        private _calculatedRotation;
        /**
         * The raw pose from the device
         */
        rawPose: DevicePose;
        /**
         * Internal, the mesh attached to the controller
         */
        _mesh: Nullable<AbstractMesh>;
        private _poseControlledCamera;
        private _leftHandSystemQuaternion;
        /**
         * Internal, matrix used to convert room space to babylon space
         */
        _deviceToWorld: Matrix;
        /**
         * Node to be used when casting a ray from the controller
         */
        _pointingPoseNode: Nullable<AbstractMesh>;
        /**
         * Name of the child mesh that can be used to cast a ray from the controller
         */
        static readonly POINTING_POSE: string;
        /**
         * Creates a new PoseEnabledController from a gamepad
         * @param browserGamepad the gamepad that the PoseEnabledController should be created from
         */
        constructor(browserGamepad: any);
        private _workingMatrix;
        /**
         * Updates the state of the pose enbaled controller and mesh based on the current position and rotation of the controller
         */
        update(): void;
        /**
         * Updates the state of the pose enbaled controller based on the raw pose data from the device
         * @param poseData raw pose fromthe device
         */
        updateFromDevice(poseData: DevicePose): void;
        /**
         * @hidden
         */
        _meshAttachedObservable: Observable<AbstractMesh>;
        /**
         * Attaches a mesh to the controller
         * @param mesh the mesh to be attached
         */
        attachToMesh(mesh: AbstractMesh): void;
        /**
         * Attaches the controllers mesh to a camera
         * @param camera the camera the mesh should be attached to
         */
        attachToPoseControlledCamera(camera: TargetCamera): void;
        /**
         * Disposes of the controller
         */
        dispose(): void;
        /**
         * The mesh that is attached to the controller
         */
        readonly mesh: Nullable<AbstractMesh>;
        /**
         * Gets the ray of the controller in the direction the controller is pointing
         * @param length the length the resulting ray should be
         * @returns a ray in the direction the controller is pointing
         */
        getForwardRay(length?: number): Ray;
    }
}

declare module BABYLON {
    /**
     * Vive Controller
     */
    class ViveController extends WebVRController {
        /**
         * Base Url for the controller model.
         */
        static MODEL_BASE_URL: string;
        /**
         * File name for the controller model.
         */
        static MODEL_FILENAME: string;
        /**
         * Creates a new ViveController from a gamepad
         * @param vrGamepad the gamepad that the controller should be created from
         */
        constructor(vrGamepad: any);
        /**
         * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
         * @param scene scene in which to add meshes
         * @param meshLoaded optional callback function that will be called if the mesh loads successfully.
         */
        initControllerMesh(scene: Scene, meshLoaded?: (mesh: AbstractMesh) => void): void;
        /**
         * Fired when the left button on this controller is modified
         */
        readonly onLeftButtonStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the right button on this controller is modified
         */
        readonly onRightButtonStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the menu button on this controller is modified
         */
        readonly onMenuButtonStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Called once for each button that changed state since the last frame
         * Vive mapping:
         * 0: touchpad
         * 1: trigger
         * 2: left AND right buttons
         * 3: menu button
         * @param buttonIdx Which button index changed
         * @param state New state of the button
         * @param changes Which properties on the state changed since last frame
         */
        protected _handleButtonChange(buttonIdx: number, state: ExtendedGamepadButton, changes: GamepadButtonChanges): void;
    }
}

declare module BABYLON {
    /**
     * Defines the WebVRController object that represents controllers tracked in 3D space
     */
    abstract class WebVRController extends PoseEnabledController {
        /**
         * Internal, the default controller model for the controller
         */
        protected _defaultModel: AbstractMesh;
        /**
         * Fired when the trigger state has changed
         */
        onTriggerStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the main button state has changed
         */
        onMainButtonStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the secondary button state has changed
         */
        onSecondaryButtonStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the pad state has changed
         */
        onPadStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when controllers stick values have changed
         */
        onPadValuesChangedObservable: Observable<StickValues>;
        /**
         * Array of button availible on the controller
         */
        protected _buttons: Array<MutableGamepadButton>;
        private _onButtonStateChange;
        /**
         * Fired when a controller button's state has changed
         * @param callback the callback containing the button that was modified
         */
        onButtonStateChange(callback: (controlledIndex: number, buttonIndex: number, state: ExtendedGamepadButton) => void): void;
        /**
         * X and Y axis corrisponding to the controllers joystick
         */
        pad: StickValues;
        /**
         * 'left' or 'right', see https://w3c.github.io/gamepad/extensions.html#gamepadhand-enum
         */
        hand: string;
        /**
         * The default controller model for the controller
         */
        readonly defaultModel: AbstractMesh;
        /**
         * Creates a new WebVRController from a gamepad
         * @param vrGamepad the gamepad that the WebVRController should be created from
         */
        constructor(vrGamepad: any);
        /**
         * Updates the state of the controller and mesh based on the current position and rotation of the controller
         */
        update(): void;
        /**
         * Function to be called when a button is modified
         */
        protected abstract _handleButtonChange(buttonIdx: number, value: ExtendedGamepadButton, changes: GamepadButtonChanges): void;
        /**
         * Loads a mesh and attaches it to the controller
         * @param scene the scene the mesh should be added to
         * @param meshLoaded callback for when the mesh has been loaded
         */
        abstract initControllerMesh(scene: Scene, meshLoaded?: (mesh: AbstractMesh) => void): void;
        private _setButtonValue(newState, currentState, buttonIndex);
        private _changes;
        private _checkChanges(newState, currentState);
        /**
         * Disposes of th webVRCOntroller
         */
        dispose(): void;
    }
}

declare module BABYLON {
    /**
     * Defines the WindowsMotionController object that the state of the windows motion controller
     */
    class WindowsMotionController extends WebVRController {
        /**
         * The base url used to load the left and right controller models
         */
        static MODEL_BASE_URL: string;
        /**
         * The name of the left controller model file
         */
        static MODEL_LEFT_FILENAME: string;
        /**
         * The name of the right controller model file
         */
        static MODEL_RIGHT_FILENAME: string;
        /**
         * The controller name prefix for this controller type
         */
        static readonly GAMEPAD_ID_PREFIX: string;
        /**
         * The controller id pattern for this controller type
         */
        private static readonly GAMEPAD_ID_PATTERN;
        private _loadedMeshInfo;
        private readonly _mapping;
        /**
         * Fired when the trackpad on this controller is clicked
         */
        onTrackpadChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the trackpad on this controller is modified
         */
        onTrackpadValuesChangedObservable: Observable<StickValues>;
        /**
         * The current x and y values of this controller's trackpad
         */
        trackpad: StickValues;
        /**
         * Creates a new WindowsMotionController from a gamepad
         * @param vrGamepad the gamepad that the controller should be created from
         */
        constructor(vrGamepad: any);
        /**
         * Fired when the trigger on this controller is modified
         */
        readonly onTriggerButtonStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the menu button on this controller is modified
         */
        readonly onMenuButtonStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the grip button on this controller is modified
         */
        readonly onGripButtonStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the thumbstick button on this controller is modified
         */
        readonly onThumbstickButtonStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the touchpad button on this controller is modified
         */
        readonly onTouchpadButtonStateChangedObservable: Observable<ExtendedGamepadButton>;
        /**
         * Fired when the touchpad values on this controller are modified
         */
        readonly onTouchpadValuesChangedObservable: Observable<StickValues>;
        /**
         * Called once per frame by the engine.
         */
        update(): void;
        /**
         * Called once for each button that changed state since the last frame
         * @param buttonIdx Which button index changed
         * @param state New state of the button
         * @param changes Which properties on the state changed since last frame
         */
        protected _handleButtonChange(buttonIdx: number, state: ExtendedGamepadButton, changes: GamepadButtonChanges): void;
        /**
         * Moves the buttons on the controller mesh based on their current state
         * @param buttonName the name of the button to move
         * @param buttonValue the value of the button which determines the buttons new position
         */
        protected _lerpButtonTransform(buttonName: string, buttonValue: number): void;
        /**
         * Moves the axis on the controller mesh based on its current state
         * @param axis the index of the axis
         * @param axisValue the value of the axis which determines the meshes new position
         * @hidden
         */
        protected _lerpAxisTransform(axis: number, axisValue: number): void;
        /**
         * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
         * @param scene scene in which to add meshes
         * @param meshLoaded optional callback function that will be called if the mesh loads successfully.
         */
        initControllerMesh(scene: Scene, meshLoaded?: (mesh: AbstractMesh) => void, forceDefault?: boolean): void;
        /**
         * Takes a list of meshes (as loaded from the glTF file) and finds the root node, as well as nodes that
         * can be transformed by button presses and axes values, based on this._mapping.
         *
         * @param scene scene in which the meshes exist
         * @param meshes list of meshes that make up the controller model to process
         * @return structured view of the given meshes, with mapping of buttons and axes to meshes that can be transformed.
         */
        private processModel(scene, meshes);
        private createMeshInfo(rootNode);
        /**
         * Gets the ray of the controller in the direction the controller is pointing
         * @param length the length the resulting ray should be
         * @returns a ray in the direction the controller is pointing
         */
        getForwardRay(length?: number): Ray;
        /**
        * Disposes of the controller
        */
        dispose(): void;
    }
}

declare module BABYLON {
    /**
     * Interface to implement to create a shadow generator compatible with BJS.
     */
    interface IShadowGenerator {
        /**
         * Gets the main RTT containing the shadow map (usually storing depth from the light point of view).
         * @returns The render target texture if present otherwise, null
         */
        getShadowMap(): Nullable<RenderTargetTexture>;
        /**
         * Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).
         * @returns The render target texture if the shadow map is present otherwise, null
         */
        getShadowMapForRendering(): Nullable<RenderTargetTexture>;
        /**
         * Determine wheter the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).
         * @param subMesh The submesh we want to render in the shadow map
         * @param useInstances Defines wether will draw in the map using instances
         * @returns true if ready otherwise, false
         */
        isReady(subMesh: SubMesh, useInstances: boolean): boolean;
        /**
         * Prepare all the defines in a material relying on a shadow map at the specified light index.
         * @param defines Defines of the material we want to update
         * @param lightIndex Index of the light in the enabled light list of the material
         */
        prepareDefines(defines: MaterialDefines, lightIndex: number): void;
        /**
         * Binds the shadow related information inside of an effect (information like near, far, darkness...
         * defined in the generator but impacting the effect).
         * It implies the unifroms available on the materials are the standard BJS ones.
         * @param lightIndex Index of the light in the enabled light list of the material owning the effect
         * @param effect The effect we are binfing the information for
         */
        bindShadowLight(lightIndex: string, effect: Effect): void;
        /**
         * Gets the transformation matrix used to project the meshes into the map from the light point of view.
         * (eq to shadow prjection matrix * light transform matrix)
         * @returns The transform matrix used to create the shadow map
         */
        getTransformMatrix(): Matrix;
        /**
         * Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between
         * Cube and 2D textures for instance.
         */
        recreateShadowMap(): void;
        /**
         * Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
         * @param onCompiled Callback triggered at the and of the effects compilation
         * @param options Sets of optional options forcing the compilation with different modes
         */
        forceCompilation(onCompiled?: (generator: ShadowGenerator) => void, options?: Partial<{
            useInstances: boolean;
        }>): void;
        /**
         * Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
         * @param options Sets of optional options forcing the compilation with different modes
         * @returns A promise that resolves when the compilation completes
         */
        forceCompilationAsync(options?: Partial<{
            useInstances: boolean;
        }>): Promise<void>;
        /**
         * Serializes the shadow generator setup to a json object.
         * @returns The serialized JSON object
         */
        serialize(): any;
        /**
         * Disposes the Shadow map and related Textures and effects.
         */
        dispose(): void;
    }
    /**
     * Default implementation IShadowGenerator.
     * This is the main object responsible of generating shadows in the framework.
     * Documentation: https://doc.babylonjs.com/babylon101/shadows
     */
    class ShadowGenerator implements IShadowGenerator {
        /**
         * Shadow generator mode None: no filtering applied.
         */
        static readonly FILTER_NONE: number;
        /**
         * Shadow generator mode ESM: Exponential Shadow Mapping.
         * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
         */
        static readonly FILTER_EXPONENTIALSHADOWMAP: number;
        /**
         * Shadow generator mode Poisson Sampling: Percentage Closer Filtering.
         * (Multiple Tap around evenly distributed around the pixel are used to evaluate the shadow strength)
         */
        static readonly FILTER_POISSONSAMPLING: number;
        /**
         * Shadow generator mode ESM: Blurred Exponential Shadow Mapping.
         * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
         */
        static readonly FILTER_BLUREXPONENTIALSHADOWMAP: number;
        /**
         * Shadow generator mode ESM: Exponential Shadow Mapping using the inverse of the exponential preventing
         * edge artifacts on steep falloff.
         * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
         */
        static readonly FILTER_CLOSEEXPONENTIALSHADOWMAP: number;
        /**
         * Shadow generator mode ESM: Blurred Exponential Shadow Mapping using the inverse of the exponential preventing
         * edge artifacts on steep falloff.
         * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
         */
        static readonly FILTER_BLURCLOSEEXPONENTIALSHADOWMAP: number;
        /**
         * Shadow generator mode PCF: Percentage Closer Filtering
         * benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1
         * (https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html)
         */
        static readonly FILTER_PCF: number;
        /**
         * Shadow generator mode PCSS: Percentage Closering Soft Shadow.
         * benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1
         * Contact Hardening
         */
        static readonly FILTER_PCSS: number;
        /**
         * Reserved for PCF and PCSS
         * Highest Quality.
         *
         * Execute PCF on a 5*5 kernel improving a lot the shadow aliasing artifacts.
         *
         * Execute PCSS with 32 taps blocker search and 64 taps PCF.
         */
        static readonly QUALITY_HIGH: number;
        /**
         * Reserved for PCF and PCSS
         * Good tradeoff for quality/perf cross devices
         *
         * Execute PCF on a 3*3 kernel.
         *
         * Execute PCSS with 16 taps blocker search and 32 taps PCF.
         */
        static readonly QUALITY_MEDIUM: number;
        /**
         * Reserved for PCF and PCSS
         * The lowest quality but the fastest.
         *
         * Execute PCF on a 1*1 kernel.
         *
         * Execute PCSS with 16 taps blocker search and 16 taps PCF.
         */
        static readonly QUALITY_LOW: number;
        private _bias;
        /**
         * Gets the bias: offset applied on the depth preventing acnea (in light direction).
         */
        /**
         * Sets the bias: offset applied on the depth preventing acnea (in light direction).
         */
        bias: number;
        private _normalBias;
        /**
         * Gets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportinal to the light/normal angle).
         */
        /**
         * Sets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportinal to the light/normal angle).
         */
        normalBias: number;
        private _blurBoxOffset;
        /**
         * Gets the blur box offset: offset applied during the blur pass.
         * Only usefull if useKernelBlur = false
         */
        /**
         * Sets the blur box offset: offset applied during the blur pass.
         * Only usefull if useKernelBlur = false
         */
        blurBoxOffset: number;
        private _blurScale;
        /**
         * Gets the blur scale: scale of the blurred texture compared to the main shadow map.
         * 2 means half of the size.
         */
        /**
         * Sets the blur scale: scale of the blurred texture compared to the main shadow map.
         * 2 means half of the size.
         */
        blurScale: number;
        private _blurKernel;
        /**
         * Gets the blur kernel: kernel size of the blur pass.
         * Only usefull if useKernelBlur = true
         */
        /**
         * Sets the blur kernel: kernel size of the blur pass.
         * Only usefull if useKernelBlur = true
         */
        blurKernel: number;
        private _useKernelBlur;
        /**
         * Gets whether the blur pass is a kernel blur (if true) or box blur.
         * Only usefull in filtered mode (useBlurExponentialShadowMap...)
         */
        /**
         * Sets whether the blur pass is a kernel blur (if true) or box blur.
         * Only usefull in filtered mode (useBlurExponentialShadowMap...)
         */
        useKernelBlur: boolean;
        private _depthScale;
        /**
         * Gets the depth scale used in ESM mode.
         */
        /**
         * Sets the depth scale used in ESM mode.
         * This can override the scale stored on the light.
         */
        depthScale: number;
        private _filter;
        /**
         * Gets the current mode of the shadow generator (normal, PCF, ESM...).
         * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
         */
        /**
         * Sets the current mode of the shadow generator (normal, PCF, ESM...).
         * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
         */
        filter: number;
        /**
         * Gets if the current filter is set to Poisson Sampling.
         */
        /**
         * Sets the current filter to Poisson Sampling.
         */
        usePoissonSampling: boolean;
        /**
         * Gets if the current filter is set to VSM.
         * DEPRECATED. Should use useExponentialShadowMap instead.
         */
        /**
         * Sets the current filter is to VSM.
         * DEPRECATED. Should use useExponentialShadowMap instead.
         */
        useVarianceShadowMap: boolean;
        /**
         * Gets if the current filter is set to blurred VSM.
         * DEPRECATED. Should use useBlurExponentialShadowMap instead.
         */
        /**
         * Sets the current filter is to blurred VSM.
         * DEPRECATED. Should use useBlurExponentialShadowMap instead.
         */
        useBlurVarianceShadowMap: boolean;
        /**
         * Gets if the current filter is set to ESM.
         */
        /**
         * Sets the current filter is to ESM.
         */
        useExponentialShadowMap: boolean;
        /**
         * Gets if the current filter is set to filtered ESM.
         */
        /**
         * Gets if the current filter is set to filtered  ESM.
         */
        useBlurExponentialShadowMap: boolean;
        /**
         * Gets if the current filter is set to "close ESM" (using the inverse of the
         * exponential to prevent steep falloff artifacts).
         */
        /**
         * Sets the current filter to "close ESM" (using the inverse of the
         * exponential to prevent steep falloff artifacts).
         */
        useCloseExponentialShadowMap: boolean;
        /**
         * Gets if the current filter is set to filtered "close ESM" (using the inverse of the
         * exponential to prevent steep falloff artifacts).
         */
        /**
         * Sets the current filter to filtered "close ESM" (using the inverse of the
         * exponential to prevent steep falloff artifacts).
         */
        useBlurCloseExponentialShadowMap: boolean;
        /**
         * Gets if the current filter is set to "PCF" (percentage closer filtering).
         */
        /**
         * Sets the current filter to "PCF" (percentage closer filtering).
         */
        usePercentageCloserFiltering: boolean;
        private _filteringQuality;
        /**
         * Gets the PCF or PCSS Quality.
         * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
         */
        /**
         * Sets the PCF or PCSS Quality.
         * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
         */
        filteringQuality: number;
        /**
         * Gets if the current filter is set to "PCSS" (contact hardening).
         */
        /**
         * Sets the current filter to "PCSS" (contact hardening).
         */
        useContactHardeningShadow: boolean;
        private _contactHardeningLightSizeUVRatio;
        /**
         * Gets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
         * Using a ratio helps keeping shape stability independently of the map size.
         *
         * It does not account for the light projection as it was having too much
         * instability during the light setup or during light position changes.
         *
         * Only valid if useContactHardeningShadow is true.
         */
        /**
         * Sets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
         * Using a ratio helps keeping shape stability independently of the map size.
         *
         * It does not account for the light projection as it was having too much
         * instability during the light setup or during light position changes.
         *
         * Only valid if useContactHardeningShadow is true.
         */
        contactHardeningLightSizeUVRatio: number;
        private _darkness;
        /**
         * Returns the darkness value (float). This can only decrease the actual darkness of a shadow.
         * 0 means strongest and 1 would means no shadow.
         * @returns the darkness.
         */
        getDarkness(): number;
        /**
         * Sets the darkness value (float). This can only decrease the actual darkness of a shadow.
         * @param darkness The darkness value 0 means strongest and 1 would means no shadow.
         * @returns the shadow generator allowing fluent coding.
         */
        setDarkness(darkness: number): ShadowGenerator;
        private _transparencyShadow;
        /**
         * Sets the ability to have transparent shadow (boolean).
         * @param transparent True if transparent else False
         * @returns the shadow generator allowing fluent coding
         */
        setTransparencyShadow(transparent: boolean): ShadowGenerator;
        private _shadowMap;
        private _shadowMap2;
        /**
         * Gets the main RTT containing the shadow map (usually storing depth from the light point of view).
         * @returns The render target texture if present otherwise, null
         */
        getShadowMap(): Nullable<RenderTargetTexture>;
        /**
         * Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).
         * @returns The render target texture if the shadow map is present otherwise, null
         */
        getShadowMapForRendering(): Nullable<RenderTargetTexture>;
        /**
         * Helper function to add a mesh and its descendants to the list of shadow casters.
         * @param mesh Mesh to add
         * @param includeDescendants boolean indicating if the descendants should be added. Default to true
         * @returns the Shadow Generator itself
         */
        addShadowCaster(mesh: AbstractMesh, includeDescendants?: boolean): ShadowGenerator;
        /**
         * Helper function to remove a mesh and its descendants from the list of shadow casters
         * @param mesh Mesh to remove
         * @param includeDescendants boolean indicating if the descendants should be removed. Default to true
         * @returns the Shadow Generator itself
         */
        removeShadowCaster(mesh: AbstractMesh, includeDescendants?: boolean): ShadowGenerator;
        /**
         * Controls the extent to which the shadows fade out at the edge of the frustum
         * Used only by directionals and spots
         */
        frustumEdgeFalloff: number;
        private _light;
        /**
         * Returns the associated light object.
         * @returns the light generating the shadow
         */
        getLight(): IShadowLight;
        /**
         * If true the shadow map is generated by rendering the back face of the mesh instead of the front face.
         * This can help with self-shadowing as the geometry making up the back of objects is slightly offset.
         * It might on the other hand introduce peter panning.
         */
        forceBackFacesOnly: boolean;
        private _scene;
        private _lightDirection;
        private _effect;
        private _viewMatrix;
        private _projectionMatrix;
        private _transformMatrix;
        private _cachedPosition;
        private _cachedDirection;
        private _cachedDefines;
        private _currentRenderID;
        private _boxBlurPostprocess;
        private _kernelBlurXPostprocess;
        private _kernelBlurYPostprocess;
        private _blurPostProcesses;
        private _mapSize;
        private _currentFaceIndex;
        private _currentFaceIndexCache;
        private _textureType;
        private _defaultTextureMatrix;
        /**
         * Creates a ShadowGenerator object.
         * A ShadowGenerator is the required tool to use the shadows.
         * Each light casting shadows needs to use its own ShadowGenerator.
         * Documentation : http://doc.babylonjs.com/tutorials/shadows
         * @param mapSize The size of the texture what stores the shadows. Example : 1024.
         * @param light The light object generating the shadows.
         * @param useFullFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.
         */
        constructor(mapSize: number, light: IShadowLight, useFullFloatFirst?: boolean);
        private _initializeGenerator();
        private _initializeShadowMap();
        private _initializeBlurRTTAndPostProcesses();
        private _renderForShadowMap(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes);
        private _renderSubMeshForShadowMap(subMesh);
        private _applyFilterValues();
        /**
         * Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
         * @param onCompiled Callback triggered at the and of the effects compilation
         * @param options Sets of optional options forcing the compilation with different modes
         */
        forceCompilation(onCompiled?: (generator: ShadowGenerator) => void, options?: Partial<{
            useInstances: boolean;
        }>): void;
        /**
         * Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
         * @param options Sets of optional options forcing the compilation with different modes
         * @returns A promise that resolves when the compilation completes
         */
        forceCompilationAsync(options?: Partial<{
            useInstances: boolean;
        }>): Promise<void>;
        /**
         * Determine wheter the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).
         * @param subMesh The submesh we want to render in the shadow map
         * @param useInstances Defines wether will draw in the map using instances
         * @returns true if ready otherwise, false
         */
        isReady(subMesh: SubMesh, useInstances: boolean): boolean;
        /**
         * Prepare all the defines in a material relying on a shadow map at the specified light index.
         * @param defines Defines of the material we want to update
         * @param lightIndex Index of the light in the enabled light list of the material
         */
        prepareDefines(defines: any, lightIndex: number): void;
        /**
         * Binds the shadow related information inside of an effect (information like near, far, darkness...
         * defined in the generator but impacting the effect).
         * @param lightIndex Index of the light in the enabled light list of the material owning the effect
         * @param effect The effect we are binfing the information for
         */
        bindShadowLight(lightIndex: string, effect: Effect): void;
        /**
         * Gets the transformation matrix used to project the meshes into the map from the light point of view.
         * (eq to shadow prjection matrix * light transform matrix)
         * @returns The transform matrix used to create the shadow map
         */
        getTransformMatrix(): Matrix;
        /**
         * Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between
         * Cube and 2D textures for instance.
         */
        recreateShadowMap(): void;
        private _disposeBlurPostProcesses();
        private _disposeRTTandPostProcesses();
        /**
         * Disposes the ShadowGenerator.
         * Returns nothing.
         */
        dispose(): void;
        /**
         * Serializes the shadow generator setup to a json object.
         * @returns The serialized JSON object
         */
        serialize(): any;
        /**
         * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.
         * @param parsedShadowGenerator The JSON object to parse
         * @param scene The scene to create the shadow map for
         * @returns The parsed shadow generator
         */
        static Parse(parsedShadowGenerator: any, scene: Scene): ShadowGenerator;
    }
}

declare module BABYLON {
}

declare module BABYLON {
    /**
     * Background material used to create an efficient environement around your scene.
     */
    class BackgroundMaterial extends PushMaterial {
        /**
         * Standard reflectance value at parallel view angle.
         */
        static StandardReflectance0: number;
        /**
         * Standard reflectance value at grazing angle.
         */
        static StandardReflectance90: number;
        protected _primaryColor: Color3;
        /**
         * Key light Color (multiply against the environement texture)
         */
        primaryColor: Color3;
        protected __perceptualColor: Nullable<Color3>;
        /**
         * Experimental Internal Use Only.
         *
         * Key light Color in "perceptual value" meaning the color you would like to see on screen.
         * This acts as a helper to set the primary color to a more "human friendly" value.
         * Conversion to linear space as well as exposure and tone mapping correction will be applied to keep the
         * output color as close as possible from the chosen value.
         * (This does not account for contrast color grading and color curves as they are considered post effect and not directly
         * part of lighting setup.)
         */
        _perceptualColor: Nullable<Color3>;
        protected _primaryColorShadowLevel: float;
        /**
         * Defines the level of the shadows (dark area of the reflection map) in order to help scaling the colors.
         * The color opposite to the primary color is used at the level chosen to define what the black area would look.
         */
        primaryColorShadowLevel: float;
        protected _primaryColorHighlightLevel: float;
        /**
         * Defines the level of the highliights (highlight area of the reflection map) in order to help scaling the colors.
         * The primary color is used at the level chosen to define what the white area would look.
         */
        primaryColorHighlightLevel: float;
        protected _reflectionTexture: Nullable<BaseTexture>;
        /**
         * Reflection Texture used in the material.
         * Should be author in a specific way for the best result (refer to the documentation).
         */
        reflectionTexture: Nullable<BaseTexture>;
        protected _reflectionBlur: float;
        /**
         * Reflection Texture level of blur.
         *
         * Can be use to reuse an existing HDR Texture and target a specific LOD to prevent authoring the
         * texture twice.
         */
        reflectionBlur: float;
        protected _diffuseTexture: Nullable<BaseTexture>;
        /**
         * Diffuse Texture used in the material.
         * Should be author in a specific way for the best result (refer to the documentation).
         */
        diffuseTexture: Nullable<BaseTexture>;
        protected _shadowLights: Nullable<IShadowLight[]>;
        /**
         * Specify the list of lights casting shadow on the material.
         * All scene shadow lights will be included if null.
         */
        shadowLights: Nullable<IShadowLight[]>;
        protected _shadowLevel: float;
        /**
         * Helps adjusting the shadow to a softer level if required.
         * 0 means black shadows and 1 means no shadows.
         */
        shadowLevel: float;
        protected _sceneCenter: Vector3;
        /**
         * In case of opacity Fresnel or reflection falloff, this is use as a scene center.
         * It is usually zero but might be interesting to modify according to your setup.
         */
        sceneCenter: Vector3;
        protected _opacityFresnel: boolean;
        /**
         * This helps specifying that the material is falling off to the sky box at grazing angle.
         * This helps ensuring a nice transition when the camera goes under the ground.
         */
        opacityFresnel: boolean;
        protected _reflectionFresnel: boolean;
        /**
         * This helps specifying that the material is falling off from diffuse to the reflection texture at grazing angle.
         * This helps adding a mirror texture on the ground.
         */
        reflectionFresnel: boolean;
        protected _reflectionFalloffDistance: number;
        /**
         * This helps specifying the falloff radius off the reflection texture from the sceneCenter.
         * This helps adding a nice falloff effect to the reflection if used as a mirror for instance.
         */
        reflectionFalloffDistance: number;
        protected _reflectionAmount: number;
        /**
         * This specifies the weight of the reflection against the background in case of reflection Fresnel.
         */
        reflectionAmount: number;
        protected _reflectionReflectance0: number;
        /**
         * This specifies the weight of the reflection at grazing angle.
         */
        reflectionReflectance0: number;
        protected _reflectionReflectance90: number;
        /**
         * This specifies the weight of the reflection at a perpendicular point of view.
         */
        reflectionReflectance90: number;
        /**
         * Sets the reflection reflectance fresnel values according to the default standard
         * empirically know to work well :-)
         */
        reflectionStandardFresnelWeight: number;
        protected _useRGBColor: boolean;
        /**
         * Helps to directly use the maps channels instead of their level.
         */
        useRGBColor: boolean;
        protected _enableNoise: boolean;
        /**
         * This helps reducing the banding effect that could occur on the background.
         */
        enableNoise: boolean;
        /**
         * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values "zoom in" and higher values "zoom out".
         * Best used when trying to implement visual zoom effects like fish-eye or binoculars while not adjusting camera fov.
         * Recommended to be keep at 1.0 except for special cases.
         */
        fovMultiplier: number;
        private _fovMultiplier;
        /**
         * Enable the FOV adjustment feature controlled by fovMultiplier.
         */
        useEquirectangularFOV: boolean;
        private _maxSimultaneousLights;
        /**
         * Number of Simultaneous lights allowed on the material.
         */
        maxSimultaneousLights: int;
        /**
         * Default configuration related to image processing available in the Background Material.
         */
        protected _imageProcessingConfiguration: ImageProcessingConfiguration;
        /**
         * Keep track of the image processing observer to allow dispose and replace.
         */
        private _imageProcessingObserver;
        /**
         * Attaches a new image processing configuration to the PBR Material.
         * @param configuration (if null the scene configuration will be use)
         */
        protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void;
        /**
         * Gets the image processing configuration used either in this material.
         */
        /**
         * Sets the Default image processing configuration used either in the this material.
         *
         * If sets to null, the scene one is in use.
         */
        imageProcessingConfiguration: Nullable<ImageProcessingConfiguration>;
        /**
         * Gets wether the color curves effect is enabled.
         */
        /**
         * Sets wether the color curves effect is enabled.
         */
        cameraColorCurvesEnabled: boolean;
        /**
         * Gets wether the color grading effect is enabled.
         */
        /**
         * Gets wether the color grading effect is enabled.
         */
        cameraColorGradingEnabled: boolean;
        /**
         * Gets wether tonemapping is enabled or not.
         */
        /**
         * Sets wether tonemapping is enabled or not
         */
        cameraToneMappingEnabled: boolean;
        /**
         * The camera exposure used on this material.
         * This property is here and not in the camera to allow controlling exposure without full screen post process.
         * This corresponds to a photographic exposure.
         */
        /**
         * The camera exposure used on this material.
         * This property is here and not in the camera to allow controlling exposure without full screen post process.
         * This corresponds to a photographic exposure.
         */
        cameraExposure: float;
        /**
         * Gets The camera contrast used on this material.
         */
        /**
         * Sets The camera contrast used on this material.
         */
        cameraContrast: float;
        /**
         * Gets the Color Grading 2D Lookup Texture.
         */
        /**
         * Sets the Color Grading 2D Lookup Texture.
         */
        cameraColorGradingTexture: Nullable<BaseTexture>;
        /**
         * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
         * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
         * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
         * corresponding to low luminance, medium luminance, and high luminance areas respectively.
         */
        /**
         * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
         * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
         * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
         * corresponding to low luminance, medium luminance, and high luminance areas respectively.
         */
        cameraColorCurves: Nullable<ColorCurves>;
        /**
         * Due to a bug in iOS10, video tags (which are using the background material) are in BGR and not RGB.
         * Setting this flag to true (not done automatically!) will convert it back to RGB.
         */
        switchToBGR: boolean;
        private _renderTargets;
        private _reflectionControls;
        private _white;
        private _primaryShadowColor;
        private _primaryHighlightColor;
        /**
         * Instantiates a Background Material in the given scene
         * @param name The friendly name of the material
         * @param scene The scene to add the material to
         */
        constructor(name: string, scene: Scene);
        /**
         * The entire material has been created in order to prevent overdraw.
         * @returns false
         */
        needAlphaTesting(): boolean;
        /**
         * The entire material has been created in order to prevent overdraw.
         * @returns true if blending is enable
         */
        needAlphaBlending(): boolean;
        /**
         * Checks wether the material is ready to be rendered for a given mesh.
         * @param mesh The mesh to render
         * @param subMesh The submesh to check against
         * @param useInstances Specify wether or not the material is used with instances
         * @returns true if all the dependencies are ready (Textures, Effects...)
         */
        isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean;
        /**
         * Compute the primary color according to the chosen perceptual color.
         */
        private _computePrimaryColorFromPerceptualColor();
        /**
         * Compute the highlights and shadow colors according to their chosen levels.
         */
        private _computePrimaryColors();
        /**
         * Build the uniform buffer used in the material.
         */
        buildUniformLayout(): void;
        /**
         * Unbind the material.
         */
        unbind(): void;
        /**
         * Bind only the world matrix to the material.
         * @param world The world matrix to bind.
         */
        bindOnlyWorldMatrix(world: Matrix): void;
        /**
         * Bind the material for a dedicated submeh (every used meshes will be considered opaque).
         * @param world The world matrix to bind.
         * @param subMesh The submesh to bind for.
         */
        bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void;
        /**
         * Dispose the material.
         * @param forceDisposeEffect Force disposal of the associated effect.
         * @param forceDisposeTextures Force disposal of the associated textures.
         */
        dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean): void;
        /**
         * Clones the material.
         * @param name The cloned name.
         * @returns The cloned material.
         */
        clone(name: string): BackgroundMaterial;
        /**
         * Serializes the current material to its JSON representation.
         * @returns The JSON representation.
         */
        serialize(): any;
        /**
         * Gets the class name of the material
         * @returns "BackgroundMaterial"
         */
        getClassName(): string;
        /**
         * Parse a JSON input to create back a background material.
         * @param source The JSON data to parse
         * @param scene The scene to create the parsed material in
         * @param rootUrl The root url of the assets the material depends upon
         * @returns the instantiated BackgroundMaterial.
         */
        static Parse(source: any, scene: Scene, rootUrl: string): BackgroundMaterial;
    }
}

declare module BABYLON {
    /**
     * The Physically based material base class of BJS.
     *
     * This offers the main features of a standard PBR material.
     * For more information, please refer to the documentation :
     * http://doc.babylonjs.com/extensions/Physically_Based_Rendering
     */
    abstract class PBRBaseMaterial extends PushMaterial {
        /**
         * Intensity of the direct lights e.g. the four lights available in your scene.
         * This impacts both the direct diffuse and specular highlights.
         */
        protected _directIntensity: number;
        /**
         * Intensity of the emissive part of the material.
         * This helps controlling the emissive effect without modifying the emissive color.
         */
        protected _emissiveIntensity: number;
        /**
         * Intensity of the environment e.g. how much the environment will light the object
         * either through harmonics for rough material or through the refelction for shiny ones.
         */
        protected _environmentIntensity: number;
        /**
         * This is a special control allowing the reduction of the specular highlights coming from the
         * four lights of the scene. Those highlights may not be needed in full environment lighting.
         */
        protected _specularIntensity: number;
        /**
         * This stores the direct, emissive, environment, and specular light intensities into a Vector4.
         */
        private _lightingInfos;
        /**
         * Debug Control allowing disabling the bump map on this material.
         */
        protected _disableBumpMap: boolean;
        /**
         * AKA Diffuse Texture in standard nomenclature.
         */
        protected _albedoTexture: BaseTexture;
        /**
         * AKA Occlusion Texture in other nomenclature.
         */
        protected _ambientTexture: BaseTexture;
        /**
         * AKA Occlusion Texture Intensity in other nomenclature.
         */
        protected _ambientTextureStrength: number;
        /**
         * Stores the alpha values in a texture.
         */
        protected _opacityTexture: BaseTexture;
        /**
         * Stores the reflection values in a texture.
         */
        protected _reflectionTexture: BaseTexture;
        /**
         * Stores the refraction values in a texture.
         */
        protected _refractionTexture: BaseTexture;
        /**
         * Stores the emissive values in a texture.
         */
        protected _emissiveTexture: BaseTexture;
        /**
         * AKA Specular texture in other nomenclature.
         */
        protected _reflectivityTexture: BaseTexture;
        /**
         * Used to switch from specular/glossiness to metallic/roughness workflow.
         */
        protected _metallicTexture: BaseTexture;
        /**
         * Specifies the metallic scalar of the metallic/roughness workflow.
         * Can also be used to scale the metalness values of the metallic texture.
         */
        protected _metallic: number;
        /**
         * Specifies the roughness scalar of the metallic/roughness workflow.
         * Can also be used to scale the roughness values of the metallic texture.
         */
        protected _roughness: number;
        /**
         * Used to enable roughness/glossiness fetch from a separate chanel depending on the current mode.
         * Gray Scale represents roughness in metallic mode and glossiness in specular mode.
         */
        protected _microSurfaceTexture: BaseTexture;
        /**
         * Stores surface normal data used to displace a mesh in a texture.
         */
        protected _bumpTexture: BaseTexture;
        /**
         * Stores the pre-calculated light information of a mesh in a texture.
         */
        protected _lightmapTexture: BaseTexture;
        /**
         * The color of a material in ambient lighting.
         */
        protected _ambientColor: Color3;
        /**
         * AKA Diffuse Color in other nomenclature.
         */
        protected _albedoColor: Color3;
        /**
         * AKA Specular Color in other nomenclature.
         */
        protected _reflectivityColor: Color3;
        /**
         * The color applied when light is reflected from a material.
         */
        protected _reflectionColor: Color3;
        /**
         * The color applied when light is emitted from a material.
         */
        protected _emissiveColor: Color3;
        /**
         * AKA Glossiness in other nomenclature.
         */
        protected _microSurface: number;
        /**
         * source material index of refraction (IOR)' / 'destination material IOR.
         */
        protected _indexOfRefraction: number;
        /**
         * Controls if refraction needs to be inverted on Y. This could be usefull for procedural texture.
         */
        protected _invertRefractionY: boolean;
        /**
         * This parameters will make the material used its opacity to control how much it is refracting aginst not.
         * Materials half opaque for instance using refraction could benefit from this control.
         */
        protected _linkRefractionWithTransparency: boolean;
        /**
         * Specifies that the material will use the light map as a show map.
         */
        protected _useLightmapAsShadowmap: boolean;
        /**
         * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal
         * makes the reflect vector face the model (under horizon).
         */
        protected _useHorizonOcclusion: boolean;
        /**
         * This parameters will enable/disable radiance occlusion by preventing the radiance to lit
         * too much the area relying on ambient texture to define their ambient occlusion.
         */
        protected _useRadianceOcclusion: boolean;
        /**
         * Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.
         */
        protected _useAlphaFromAlbedoTexture: boolean;
        /**
         * Specifies that the material will keeps the specular highlights over a transparent surface (only the most limunous ones).
         * A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.
         */
        protected _useSpecularOverAlpha: boolean;
        /**
         * Specifies if the reflectivity texture contains the glossiness information in its alpha channel.
         */
        protected _useMicroSurfaceFromReflectivityMapAlpha: boolean;
        /**
         * Specifies if the metallic texture contains the roughness information in its alpha channel.
         */
        protected _useRoughnessFromMetallicTextureAlpha: boolean;
        /**
         * Specifies if the metallic texture contains the roughness information in its green channel.
         */
        protected _useRoughnessFromMetallicTextureGreen: boolean;
        /**
         * Specifies if the metallic texture contains the metallness information in its blue channel.
         */
        protected _useMetallnessFromMetallicTextureBlue: boolean;
        /**
         * Specifies if the metallic texture contains the ambient occlusion information in its red channel.
         */
        protected _useAmbientOcclusionFromMetallicTextureRed: boolean;
        /**
         * Specifies if the ambient texture contains the ambient occlusion information in its red channel only.
         */
        protected _useAmbientInGrayScale: boolean;
        /**
         * In case the reflectivity map does not contain the microsurface information in its alpha channel,
         * The material will try to infer what glossiness each pixel should be.
         */
        protected _useAutoMicroSurfaceFromReflectivityMap: boolean;
        /**
         * BJS is using an harcoded light falloff based on a manually sets up range.
         * In PBR, one way to represents the fallof is to use the inverse squared root algorythm.
         * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
         */
        protected _usePhysicalLightFalloff: boolean;
        /**
         * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).
         * A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.
         */
        protected _useRadianceOverAlpha: boolean;
        /**
         * Allows using an object space normal map (instead of tangent space).
         */
        protected _useObjectSpaceNormalMap: boolean;
        /**
         * Allows using the bump map in parallax mode.
         */
        protected _useParallax: boolean;
        /**
         * Allows using the bump map in parallax occlusion mode.
         */
        protected _useParallaxOcclusion: boolean;
        /**
         * Controls the scale bias of the parallax mode.
         */
        protected _parallaxScaleBias: number;
        /**
         * If sets to true, disables all the lights affecting the material.
         */
        protected _disableLighting: boolean;
        /**
         * Number of Simultaneous lights allowed on the material.
         */
        protected _maxSimultaneousLights: number;
        /**
         * If sets to true, x component of normal map value will be inverted (x = 1.0 - x).
         */
        protected _invertNormalMapX: boolean;
        /**
         * If sets to true, y component of normal map value will be inverted (y = 1.0 - y).
         */
        protected _invertNormalMapY: boolean;
        /**
         * If sets to true and backfaceCulling is false, normals will be flipped on the backside.
         */
        protected _twoSidedLighting: boolean;
        /**
         * Defines the alpha limits in alpha test mode.
         */
        protected _alphaCutOff: number;
        /**
         * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.
         */
        protected _forceAlphaTest: boolean;
        /**
         * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
         * And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)
         */
        protected _useAlphaFresnel: boolean;
        /**
         * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
         * And/Or occlude the blended part. (alpha stays linear to compute the fresnel)
         */
        protected _useLinearAlphaFresnel: boolean;
        /**
         * The transparency mode of the material.
         */
        protected _transparencyMode: Nullable<number>;
        /**
         * Specifies the environment BRDF texture used to comput the scale and offset roughness values
         * from cos thetav and roughness:
         * http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf
         */
        protected _environmentBRDFTexture: Nullable<BaseTexture>;
        /**
         * Force the shader to compute irradiance in the fragment shader in order to take bump in account.
         */
        protected _forceIrradianceInFragment: boolean;
        /**
         * Force normal to face away from face.
         */
        protected _forceNormalForward: boolean;
        /**
         * Enables specular anti aliasing in the PBR shader.
         * It will both interacts on the Geometry for analytical and IBL lighting.
         * It also prefilter the roughness map based on the bump values.
         */
        protected _enableSpecularAntiAliasing: boolean;
        /**
         * Default configuration related to image processing available in the PBR Material.
         */
        protected _imageProcessingConfiguration: ImageProcessingConfiguration;
        /**
         * Keep track of the image processing observer to allow dispose and replace.
         */
        private _imageProcessingObserver;
        /**
         * Attaches a new image processing configuration to the PBR Material.
         * @param configuration
         */
        protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void;
        /**
         * Stores the available render targets.
         */
        private _renderTargets;
        /**
         * Sets the global ambient color for the material used in lighting calculations.
         */
        private _globalAmbientColor;
        /**
         * Enables the use of logarithmic depth buffers, which is good for wide depth buffers.
         */
        private _useLogarithmicDepth;
        /**
         * If set to true, no lighting calculations will be applied.
         */
        private _unlit;
        /**
         * Instantiates a new PBRMaterial instance.
         *
         * @param name The material name
         * @param scene The scene the material will be use in.
         */
        constructor(name: string, scene: Scene);
        /**
         * Gets the name of the material class.
         */
        getClassName(): string;
        /**
         * Enabled the use of logarithmic depth buffers, which is good for wide depth buffers.
         */
        /**
         * Enabled the use of logarithmic depth buffers, which is good for wide depth buffers.
         */
        useLogarithmicDepth: boolean;
        /**
         * Gets the current transparency mode.
         */
        /**
         * Sets the transparency mode of the material.
         */
        transparencyMode: Nullable<number>;
        /**
         * Returns true if alpha blending should be disabled.
         */
        private readonly _disableAlphaBlending;
        /**
         * Specifies whether or not this material should be rendered in alpha blend mode.
         */
        needAlphaBlending(): boolean;
        /**
         * Specifies if the mesh will require alpha blending.
         * @param mesh - BJS mesh.
         */
        needAlphaBlendingForMesh(mesh: AbstractMesh): boolean;
        /**
         * Specifies whether or not this material should be rendered in alpha test mode.
         */
        needAlphaTesting(): boolean;
        /**
         * Specifies whether or not the alpha value of the albedo texture should be used for alpha blending.
         */
        protected _shouldUseAlphaFromAlbedoTexture(): boolean;
        /**
         * Gets the texture used for the alpha test.
         */
        getAlphaTestTexture(): BaseTexture;
        /**
         * Stores the reflectivity values based on metallic roughness workflow.
         */
        private static _scaledReflectivity;
        /**
         * Specifies that the submesh is ready to be used.
         * @param mesh - BJS mesh.
         * @param subMesh - A submesh of the BJS mesh.  Used to check if it is ready.
         * @param useInstances - Specifies that instances should be used.
         * @returns - boolean indicating that the submesh is ready or not.
         */
        isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean;
        /**
         * Specifies if the material uses metallic roughness workflow.
         * @returns boolean specifiying if the material uses metallic roughness workflow.
        */
        isMetallicWorkflow(): boolean;
        private _prepareEffect(mesh, defines, onCompiled?, onError?, useInstances?, useClipPlane?);
        private _prepareDefines(mesh, defines, useInstances?, useClipPlane?);
        /**
         * Force shader compilation
         */
        forceCompilation(mesh: AbstractMesh, onCompiled?: (material: Material) => void, options?: Partial<{
            clipPlane: boolean;
        }>): void;
        /**
         * Initializes the uniform buffer layout for the shader.
         */
        buildUniformLayout(): void;
        /**
         * Unbinds the textures.
         */
        unbind(): void;
        /**
         * Binds the submesh data.
         * @param world - The world matrix.
         * @param mesh - The BJS mesh.
         * @param subMesh - A submesh of the BJS mesh.
         */
        bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void;
        /**
         * Returns the animatable textures.
         * @returns - Array of animatable textures.
         */
        getAnimatables(): IAnimatable[];
        /**
         * Returns the texture used for reflections.
         * @returns - Reflection texture if present.  Otherwise, returns the environment texture.
         */
        private _getReflectionTexture();
        /**
         * Returns the texture used for refraction or null if none is used.
         * @returns - Refection texture if present.  If no refraction texture and refraction
         * is linked with transparency, returns environment texture.  Otherwise, returns null.
         */
        private _getRefractionTexture();
        /**
         * Disposes the resources of the material.
         * @param forceDisposeEffect - Forces the disposal of effects.
         * @param forceDisposeTextures - Forces the disposal of all textures.
         */
        dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean): void;
    }
}

declare module BABYLON {
    /**
     * The Physically based simple base material of BJS.
     *
     * This enables better naming and convention enforcements on top of the pbrMaterial.
     * It is used as the base class for both the specGloss and metalRough conventions.
     */
    abstract class PBRBaseSimpleMaterial extends PBRBaseMaterial {
        /**
         * Number of Simultaneous lights allowed on the material.
         */
        maxSimultaneousLights: number;
        /**
         * If sets to true, disables all the lights affecting the material.
         */
        disableLighting: boolean;
        /**
         * Environment Texture used in the material (this is use for both reflection and environment lighting).
         */
        environmentTexture: BaseTexture;
        /**
         * If sets to true, x component of normal map value will invert (x = 1.0 - x).
         */
        invertNormalMapX: boolean;
        /**
         * If sets to true, y component of normal map value will invert (y = 1.0 - y).
         */
        invertNormalMapY: boolean;
        /**
         * Normal map used in the model.
         */
        normalTexture: BaseTexture;
        /**
         * Emissivie color used to self-illuminate the model.
         */
        emissiveColor: Color3;
        /**
         * Emissivie texture used to self-illuminate the model.
         */
        emissiveTexture: BaseTexture;
        /**
         * Occlusion Channel Strenght.
         */
        occlusionStrength: number;
        /**
         * Occlusion Texture of the material (adding extra occlusion effects).
         */
        occlusionTexture: BaseTexture;
        /**
         * Defines the alpha limits in alpha test mode.
         */
        alphaCutOff: number;
        /**
         * Gets the current double sided mode.
         */
        /**
         * If sets to true and backfaceCulling is false, normals will be flipped on the backside.
         */
        doubleSided: boolean;
        lightmapTexture: BaseTexture;
        useLightmapAsShadowmap: boolean;
        /**
         * Return the active textures of the material.
         */
        getActiveTextures(): BaseTexture[];
        hasTexture(texture: BaseTexture): boolean;
        /**
         * Instantiates a new PBRMaterial instance.
         *
         * @param name The material name
         * @param scene The scene the material will be use in.
         */
        constructor(name: string, scene: Scene);
        getClassName(): string;
    }
}

declare module BABYLON {
    /**
     * The Physically based material of BJS.
     *
     * This offers the main features of a standard PBR material.
     * For more information, please refer to the documentation :
     * http://doc.babylonjs.com/extensions/Physically_Based_Rendering
     */
    class PBRMaterial extends PBRBaseMaterial {
        private static _PBRMATERIAL_OPAQUE;
        /**
         * PBRMaterialTransparencyMode: No transparency mode, Alpha channel is not use.
         */
        static readonly PBRMATERIAL_OPAQUE: number;
        /**
         * Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.
         */
        private static _PBRMATERIAL_ALPHATEST;
        /**
         * PBRMaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.
         */
        static readonly PBRMATERIAL_ALPHATEST: number;
        /**
         * Represents the value for Alpha Blend.  Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
         */
        private static _PBRMATERIAL_ALPHABLEND;
        /**
         * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
         */
        static readonly PBRMATERIAL_ALPHABLEND: number;
        /**
         * Represents the value for Alpha Test and Blend.  Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
         * They are also discarded below the alpha cutoff threshold to improve performances.
         */
        private static _PBRMATERIAL_ALPHATESTANDBLEND;
        /**
         * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
         * They are also discarded below the alpha cutoff threshold to improve performances.
         */
        static readonly PBRMATERIAL_ALPHATESTANDBLEND: number;
        /**
         * Intensity of the direct lights e.g. the four lights available in your scene.
         * This impacts both the direct diffuse and specular highlights.
         */
        directIntensity: number;
        /**
         * Intensity of the emissive part of the material.
         * This helps controlling the emissive effect without modifying the emissive color.
         */
        emissiveIntensity: number;
        /**
         * Intensity of the environment e.g. how much the environment will light the object
         * either through harmonics for rough material or through the refelction for shiny ones.
         */
        environmentIntensity: number;
        /**
         * This is a special control allowing the reduction of the specular highlights coming from the
         * four lights of the scene. Those highlights may not be needed in full environment lighting.
         */
        specularIntensity: number;
        /**
         * Debug Control allowing disabling the bump map on this material.
         */
        disableBumpMap: boolean;
        /**
         * AKA Diffuse Texture in standard nomenclature.
         */
        albedoTexture: BaseTexture;
        /**
         * AKA Occlusion Texture in other nomenclature.
         */
        ambientTexture: BaseTexture;
        /**
         * AKA Occlusion Texture Intensity in other nomenclature.
         */
        ambientTextureStrength: number;
        /**
         * Stores the alpha values in a texture.
         */
        opacityTexture: BaseTexture;
        /**
         * Stores the reflection values in a texture.
         */
        reflectionTexture: Nullable<BaseTexture>;
        /**
         * Stores the emissive values in a texture.
         */
        emissiveTexture: BaseTexture;
        /**
         * AKA Specular texture in other nomenclature.
         */
        reflectivityTexture: BaseTexture;
        /**
         * Used to switch from specular/glossiness to metallic/roughness workflow.
         */
        metallicTexture: BaseTexture;
        /**
         * Specifies the metallic scalar of the metallic/roughness workflow.
         * Can also be used to scale the metalness values of the metallic texture.
         */
        metallic: number;
        /**
         * Specifies the roughness scalar of the metallic/roughness workflow.
         * Can also be used to scale the roughness values of the metallic texture.
         */
        roughness: number;
        /**
         * Used to enable roughness/glossiness fetch from a separate chanel depending on the current mode.
         * Gray Scale represents roughness in metallic mode and glossiness in specular mode.
         */
        microSurfaceTexture: BaseTexture;
        /**
         * Stores surface normal data used to displace a mesh in a texture.
         */
        bumpTexture: BaseTexture;
        /**
         * Stores the pre-calculated light information of a mesh in a texture.
         */
        lightmapTexture: BaseTexture;
        /**
         * Stores the refracted light information in a texture.
         */
        refractionTexture: BaseTexture;
        /**
         * The color of a material in ambient lighting.
         */
        ambientColor: Color3;
        /**
         * AKA Diffuse Color in other nomenclature.
         */
        albedoColor: Color3;
        /**
         * AKA Specular Color in other nomenclature.
         */
        reflectivityColor: Color3;
        /**
         * The color reflected from the material.
         */
        reflectionColor: Color3;
        /**
         * The color emitted from the material.
         */
        emissiveColor: Color3;
        /**
         * AKA Glossiness in other nomenclature.
         */
        microSurface: number;
        /**
         * source material index of refraction (IOR)' / 'destination material IOR.
         */
        indexOfRefraction: number;
        /**
         * Controls if refraction needs to be inverted on Y. This could be usefull for procedural texture.
         */
        invertRefractionY: boolean;
        /**
         * This parameters will make the material used its opacity to control how much it is refracting aginst not.
         * Materials half opaque for instance using refraction could benefit from this control.
         */
        linkRefractionWithTransparency: boolean;
        useLightmapAsShadowmap: boolean;
        /**
         * Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.
         */
        useAlphaFromAlbedoTexture: boolean;
        /**
         * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.
         */
        forceAlphaTest: boolean;
        /**
         * Defines the alpha limits in alpha test mode.
         */
        alphaCutOff: number;
        /**
         * Specifies that the material will keeps the specular highlights over a transparent surface (only the most limunous ones).
         * A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.
         */
        useSpecularOverAlpha: boolean;
        /**
         * Specifies if the reflectivity texture contains the glossiness information in its alpha channel.
         */
        useMicroSurfaceFromReflectivityMapAlpha: boolean;
        /**
         * Specifies if the metallic texture contains the roughness information in its alpha channel.
         */
        useRoughnessFromMetallicTextureAlpha: boolean;
        /**
         * Specifies if the metallic texture contains the roughness information in its green channel.
         */
        useRoughnessFromMetallicTextureGreen: boolean;
        /**
         * Specifies if the metallic texture contains the metallness information in its blue channel.
         */
        useMetallnessFromMetallicTextureBlue: boolean;
        /**
         * Specifies if the metallic texture contains the ambient occlusion information in its red channel.
         */
        useAmbientOcclusionFromMetallicTextureRed: boolean;
        /**
         * Specifies if the ambient texture contains the ambient occlusion information in its red channel only.
         */
        useAmbientInGrayScale: boolean;
        /**
         * In case the reflectivity map does not contain the microsurface information in its alpha channel,
         * The material will try to infer what glossiness each pixel should be.
         */
        useAutoMicroSurfaceFromReflectivityMap: boolean;
        /**
         * BJS is using an harcoded light falloff based on a manually sets up range.
         * In PBR, one way to represents the fallof is to use the inverse squared root algorythm.
         * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
         */
        usePhysicalLightFalloff: boolean;
        /**
         * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).
         * A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.
         */
        useRadianceOverAlpha: boolean;
        /**
         * Allows using an object space normal map (instead of tangent space).
         */
        useObjectSpaceNormalMap: boolean;
        /**
         * Allows using the bump map in parallax mode.
         */
        useParallax: boolean;
        /**
         * Allows using the bump map in parallax occlusion mode.
         */
        useParallaxOcclusion: boolean;
        /**
         * Controls the scale bias of the parallax mode.
         */
        parallaxScaleBias: number;
        /**
         * If sets to true, disables all the lights affecting the material.
         */
        disableLighting: boolean;
        /**
         * Force the shader to compute irradiance in the fragment shader in order to take bump in account.
         */
        forceIrradianceInFragment: boolean;
        /**
         * Number of Simultaneous lights allowed on the material.
         */
        maxSimultaneousLights: number;
        /**
         * If sets to true, x component of normal map value will invert (x = 1.0 - x).
         */
        invertNormalMapX: boolean;
        /**
         * If sets to true, y component of normal map value will invert (y = 1.0 - y).
         */
        invertNormalMapY: boolean;
        /**
         * If sets to true and backfaceCulling is false, normals will be flipped on the backside.
         */
        twoSidedLighting: boolean;
        /**
         * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
         * And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)
         */
        useAlphaFresnel: boolean;
        /**
         * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
         * And/Or occlude the blended part. (alpha stays linear to compute the fresnel)
         */
        useLinearAlphaFresnel: boolean;
        /**
         * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
         * And/Or occlude the blended part.
         */
        environmentBRDFTexture: Nullable<BaseTexture>;
        /**
         * Force normal to face away from face.
         */
        forceNormalForward: boolean;
        /**
         * Enables specular anti aliasing in the PBR shader.
         * It will both interacts on the Geometry for analytical and IBL lighting.
         * It also prefilter the roughness map based on the bump values.
         */
        enableSpecularAntiAliasing: boolean;
        /**
         * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal
         * makes the reflect vector face the model (under horizon).
         */
        useHorizonOcclusion: boolean;
        /**
         * This parameters will enable/disable radiance occlusion by preventing the radiance to lit
         * too much the area relying on ambient texture to define their ambient occlusion.
         */
        useRadianceOcclusion: boolean;
        /**
         * If set to true, no lighting calculations will be applied.
         */
        unlit: boolean;
        /**
         * Gets the image processing configuration used either in this material.
         */
        /**
         * Sets the Default image processing configuration used either in the this material.
         *
         * If sets to null, the scene one is in use.
         */
        imageProcessingConfiguration: ImageProcessingConfiguration;
        /**
         * Gets wether the color curves effect is enabled.
         */
        /**
         * Sets wether the color curves effect is enabled.
         */
        cameraColorCurvesEnabled: boolean;
        /**
         * Gets wether the color grading effect is enabled.
         */
        /**
         * Gets wether the color grading effect is enabled.
         */
        cameraColorGradingEnabled: boolean;
        /**
         * Gets wether tonemapping is enabled or not.
         */
        /**
         * Sets wether tonemapping is enabled or not
         */
        cameraToneMappingEnabled: boolean;
        /**
         * The camera exposure used on this material.
         * This property is here and not in the camera to allow controlling exposure without full screen post process.
         * This corresponds to a photographic exposure.
         */
        /**
         * The camera exposure used on this material.
         * This property is here and not in the camera to allow controlling exposure without full screen post process.
         * This corresponds to a photographic exposure.
         */
        cameraExposure: number;
        /**
         * Gets The camera contrast used on this material.
         */
        /**
         * Sets The camera contrast used on this material.
         */
        cameraContrast: number;
        /**
         * Gets the Color Grading 2D Lookup Texture.
         */
        /**
         * Sets the Color Grading 2D Lookup Texture.
         */
        cameraColorGradingTexture: Nullable<BaseTexture>;
        /**
         * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
         * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
         * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
         * corresponding to low luminance, medium luminance, and high luminance areas respectively.
         */
        /**
         * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
         * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
         * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
         * corresponding to low luminance, medium luminance, and high luminance areas respectively.
         */
        cameraColorCurves: Nullable<ColorCurves>;
        /**
         * Instantiates a new PBRMaterial instance.
         *
         * @param name The material name
         * @param scene The scene the material will be use in.
         */
        constructor(name: string, scene: Scene);
        /**
         * Returns the name of this material class.
         */
        getClassName(): string;
        /**
         * Returns an array of the actively used textures.
         * @returns - Array of BaseTextures
         */
        getActiveTextures(): BaseTexture[];
        /**
         * Checks to see if a texture is used in the material.
         * @param texture - Base texture to use.
         * @returns - Boolean specifying if a texture is used in the material.
         */
        hasTexture(texture: BaseTexture): boolean;
        /**
         * Makes a duplicate of the current material.
         * @param name - name to use for the new material.
         */
        clone(name: string): PBRMaterial;
        /**
         * Serializes this PBR Material.
         * @returns - An object with the serialized material.
         */
        serialize(): any;
        /**
         * Parses a PBR Material from a serialized object.
         * @param source - Serialized object.
         * @param scene - BJS scene instance.
         * @param rootUrl - url for the scene object
         * @returns - PBRMaterial
         */
        static Parse(source: any, scene: Scene, rootUrl: string): PBRMaterial;
    }
}

declare module BABYLON {
    /**
     * The PBR material of BJS following the metal roughness convention.
     *
     * This fits to the PBR convention in the GLTF definition:
     * https://github.com/KhronosGroup/glTF/tree/2.0/specification/2.0
     */
    class PBRMetallicRoughnessMaterial extends PBRBaseSimpleMaterial {
        /**
         * The base color has two different interpretations depending on the value of metalness.
         * When the material is a metal, the base color is the specific measured reflectance value
         * at normal incidence (F0). For a non-metal the base color represents the reflected diffuse color
         * of the material.
         */
        baseColor: Color3;
        /**
         * Base texture of the metallic workflow. It contains both the baseColor information in RGB as
         * well as opacity information in the alpha channel.
         */
        baseTexture: BaseTexture;
        /**
         * Specifies the metallic scalar value of the material.
         * Can also be used to scale the metalness values of the metallic texture.
         */
        metallic: number;
        /**
         * Specifies the roughness scalar value of the material.
         * Can also be used to scale the roughness values of the metallic texture.
         */
        roughness: number;
        /**
         * Texture containing both the metallic value in the B channel and the
         * roughness value in the G channel to keep better precision.
         */
        metallicRoughnessTexture: BaseTexture;
        /**
         * Instantiates a new PBRMetalRoughnessMaterial instance.
         *
         * @param name The material name
         * @param scene The scene the material will be use in.
         */
        constructor(name: string, scene: Scene);
        /**
         * Return the currrent class name of the material.
         */
        getClassName(): string;
        /**
         * Return the active textures of the material.
         */
        getActiveTextures(): BaseTexture[];
        /**
         * Checks to see if a texture is used in the material.
         * @param texture - Base texture to use.
         * @returns - Boolean specifying if a texture is used in the material.
         */
        hasTexture(texture: BaseTexture): boolean;
        /**
         * Makes a duplicate of the current material.
         * @param name - name to use for the new material.
         */
        clone(name: string): PBRMetallicRoughnessMaterial;
        /**
         * Serialize the material to a parsable JSON object.
         */
        serialize(): any;
        /**
         * Parses a JSON object correponding to the serialize function.
         */
        static Parse(source: any, scene: Scene, rootUrl: string): PBRMetallicRoughnessMaterial;
    }
}

declare module BABYLON {
    /**
     * The PBR material of BJS following the specular glossiness convention.
     *
     * This fits to the PBR convention in the GLTF definition:
     * https://github.com/KhronosGroup/glTF/tree/2.0/extensions/Khronos/KHR_materials_pbrSpecularGlossiness
     */
    class PBRSpecularGlossinessMaterial extends PBRBaseSimpleMaterial {
        /**
         * Specifies the diffuse color of the material.
         */
        diffuseColor: Color3;
        /**
         * Specifies the diffuse texture of the material. This can also contains the opcity value in its alpha
         * channel.
         */
        diffuseTexture: BaseTexture;
        /**
         * Specifies the specular color of the material. This indicates how reflective is the material (none to mirror).
         */
        specularColor: Color3;
        /**
         * Specifies the glossiness of the material. This indicates "how sharp is the reflection".
         */
        glossiness: number;
        /**
         * Specifies both the specular color RGB and the glossiness A of the material per pixels.
         */
        specularGlossinessTexture: BaseTexture;
        /**
         * Instantiates a new PBRSpecularGlossinessMaterial instance.
         *
         * @param name The material name
         * @param scene The scene the material will be use in.
         */
        constructor(name: string, scene: Scene);
        /**
         * Return the currrent class name of the material.
         */
        getClassName(): string;
        /**
         * Return the active textures of the material.
         */
        getActiveTextures(): BaseTexture[];
        /**
         * Checks to see if a texture is used in the material.
         * @param texture - Base texture to use.
         * @returns - Boolean specifying if a texture is used in the material.
         */
        hasTexture(texture: BaseTexture): boolean;
        /**
         * Makes a duplicate of the current material.
         * @param name - name to use for the new material.
         */
        clone(name: string): PBRSpecularGlossinessMaterial;
        /**
         * Serialize the material to a parsable JSON object.
         */
        serialize(): any;
        /**
         * Parses a JSON object correponding to the serialize function.
         */
        static Parse(source: any, scene: Scene, rootUrl: string): PBRSpecularGlossinessMaterial;
    }
}

declare module BABYLON {
    class BaseTexture {
        static DEFAULT_ANISOTROPIC_FILTERING_LEVEL: number;
        name: string;
        private _hasAlpha;
        hasAlpha: boolean;
        getAlphaFromRGB: boolean;
        level: number;
        coordinatesIndex: number;
        private _coordinatesMode;
        /**
        * How a texture is mapped.
        *
        * | Value | Type                                | Description |
        * | ----- | ----------------------------------- | ----------- |
        * | 0     | EXPLICIT_MODE                       |             |
        * | 1     | SPHERICAL_MODE                      |             |
        * | 2     | PLANAR_MODE                         |             |
        * | 3     | CUBIC_MODE                          |             |
        * | 4     | PROJECTION_MODE                     |             |
        * | 5     | SKYBOX_MODE                         |             |
        * | 6     | INVCUBIC_MODE                       |             |
        * | 7     | EQUIRECTANGULAR_MODE                |             |
        * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |
        * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |
        */
        coordinatesMode: number;
        /**
        * | Value | Type               | Description |
        * | ----- | ------------------ | ----------- |
        * | 0     | CLAMP_ADDRESSMODE  |             |
        * | 1     | WRAP_ADDRESSMODE   |             |
        * | 2     | MIRROR_ADDRESSMODE |             |
        */
        wrapU: number;
        /**
        * | Value | Type               | Description |
        * | ----- | ------------------ | ----------- |
        * | 0     | CLAMP_ADDRESSMODE  |             |
        * | 1     | WRAP_ADDRESSMODE   |             |
        * | 2     | MIRROR_ADDRESSMODE |             |
        */
        wrapV: number;
        /**
        * | Value | Type               | Description |
        * | ----- | ------------------ | ----------- |
        * | 0     | CLAMP_ADDRESSMODE  |             |
        * | 1     | WRAP_ADDRESSMODE   |             |
        * | 2     | MIRROR_ADDRESSMODE |             |
        */
        wrapR: number;
        anisotropicFilteringLevel: number;
        isCube: boolean;
        is3D: boolean;
        gammaSpace: boolean;
        invertZ: boolean;
        lodLevelInAlpha: boolean;
        lodGenerationOffset: number;
        lodGenerationScale: number;
        isRenderTarget: boolean;
        readonly uid: string;
        toString(): string;
        getClassName(): string;
        animations: Animation[];
        /**
        * An event triggered when the texture is disposed.
        */
        onDisposeObservable: Observable<BaseTexture>;
        private _onDisposeObserver;
        onDispose: () => void;
        delayLoadState: number;
        private _scene;
        _texture: Nullable<InternalTexture>;
        private _uid;
        readonly isBlocking: boolean;
        constructor(scene: Nullable<Scene>);
        getScene(): Nullable<Scene>;
        getTextureMatrix(): Matrix;
        getReflectionTextureMatrix(): Matrix;
        getInternalTexture(): Nullable<InternalTexture>;
        isReadyOrNotBlocking(): boolean;
        isReady(): boolean;
        getSize(): ISize;
        getBaseSize(): ISize;
        scale(ratio: number): void;
        readonly canRescale: boolean;
        _getFromCache(url: Nullable<string>, noMipmap: boolean, sampling?: number): Nullable<InternalTexture>;
        _rebuild(): void;
        delayLoad(): void;
        clone(): Nullable<BaseTexture>;
        readonly textureType: number;
        readonly textureFormat: number;
        readPixels(faceIndex?: number): Nullable<ArrayBufferView>;
        releaseInternalTexture(): void;
        sphericalPolynomial: Nullable<SphericalPolynomial>;
        readonly _lodTextureHigh: Nullable<BaseTexture>;
        readonly _lodTextureMid: Nullable<BaseTexture>;
        readonly _lodTextureLow: Nullable<BaseTexture>;
        dispose(): void;
        serialize(): any;
        static WhenAllReady(textures: BaseTexture[], callback: () => void): void;
    }
}

declare module BABYLON {
    /**
     * This represents a color grading texture. This acts as a lookup table LUT, useful during post process
     * It can help converting any input color in a desired output one. This can then be used to create effects
     * from sepia, black and white to sixties or futuristic rendering...
     *
     * The only supported format is currently 3dl.
     * More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table/
     */
    class ColorGradingTexture extends BaseTexture {
        /**
         * The current texture matrix. (will always be identity in color grading texture)
         */
        private _textureMatrix;
        /**
         * The texture URL.
         */
        url: string;
        /**
         * Empty line regex stored for GC.
         */
        private static _noneEmptyLineRegex;
        private _engine;
        /**
         * Instantiates a ColorGradingTexture from the following parameters.
         *
         * @param url The location of the color gradind data (currently only supporting 3dl)
         * @param scene The scene the texture will be used in
         */
        constructor(url: string, scene: Scene);
        /**
         * Returns the texture matrix used in most of the material.
         * This is not used in color grading but keep for troubleshooting purpose (easily swap diffuse by colorgrading to look in).
         */
        getTextureMatrix(): Matrix;
        /**
         * Occurs when the file being loaded is a .3dl LUT file.
         */
        private load3dlTexture();
        /**
         * Starts the loading process of the texture.
         */
        private loadTexture();
        /**
         * Clones the color gradind texture.
         */
        clone(): ColorGradingTexture;
        /**
         * Called during delayed load for textures.
         */
        delayLoad(): void;
        /**
         * Parses a color grading texture serialized by Babylon.
         * @param parsedTexture The texture information being parsedTexture
         * @param scene The scene to load the texture in
         * @param rootUrl The root url of the data assets to load
         * @return A color gradind texture
         */
        static Parse(parsedTexture: any, scene: Scene, rootUrl: string): Nullable<ColorGradingTexture>;
        /**
         * Serializes the LUT texture to json format.
         */
        serialize(): any;
    }
}

declare module BABYLON {
    class CubeTexture extends BaseTexture {
        url: string;
        coordinatesMode: number;
        /**
         * Gets or sets the center of the bounding box associated with the cube texture
         * It must define where the camera used to render the texture was set
         */
        boundingBoxPosition: Vector3;
        private _boundingBoxSize;
        /**
         * Gets or sets the size of the bounding box associated with the cube texture
         * When defined, the cubemap will switch to local mode
         * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity
         * @example https://www.babylonjs-playground.com/#RNASML
         */
        boundingBoxSize: Vector3;
        protected _rotationY: number;
        /**
         * Gets texture matrix rotation angle around Y axis radians.
         */
        /**
         * Sets texture matrix rotation angle around Y axis in radians.
         */
        rotationY: number;
        private _noMipmap;
        private _files;
        private _extensions;
        private _textureMatrix;
        private _format;
        private _prefiltered;
        static CreateFromImages(files: string[], scene: Scene, noMipmap?: boolean): CubeTexture;
        static CreateFromPrefilteredData(url: string, scene: Scene, forcedExtension?: any): CubeTexture;
        constructor(rootUrl: string, scene: Scene, extensions?: Nullable<string[]>, noMipmap?: boolean, files?: Nullable<string[]>, onLoad?: Nullable<() => void>, onError?: Nullable<(message?: string, exception?: any) => void>, format?: number, prefiltered?: boolean, forcedExtension?: any);
        delayLoad(): void;
        getReflectionTextureMatrix(): Matrix;
        setReflectionTextureMatrix(value: Matrix): void;
        static Parse(parsedTexture: any, scene: Scene, rootUrl: string): CubeTexture;
        clone(): CubeTexture;
    }
}

declare module BABYLON {
    /**
     * A class extending {BABYLON.Texture} allowing drawing on a texture
     * @see http://doc.babylonjs.com/how_to/dynamictexture
     */
    class DynamicTexture extends Texture {
        private _generateMipMaps;
        private _canvas;
        private _context;
        private _engine;
        /**
         * Creates a {BABYLON.DynamicTexture}
         * @param name defines the name of the texture
         * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height
         * @param scene defines the scene where you want the texture
         * @param generateMipMaps defines the use of MinMaps or not (default is false)
         * @param samplingMode defines the sampling mode to use (default is BABYLON.Texture.TRILINEAR_SAMPLINGMODE)
         * @param format defines the texture format to use (default is BABYLON.Engine.TEXTUREFORMAT_RGBA)
         */
        constructor(name: string, options: any, scene: Scene | null | undefined, generateMipMaps: boolean, samplingMode?: number, format?: number);
        /**
         * Gets the current state of canRescale
         */
        readonly canRescale: boolean;
        private _recreate(textureSize);
        /**
         * Scales the texture
         * @param ratio the scale factor to apply to both width and height
         */
        scale(ratio: number): void;
        /**
         * Resizes the texture
         * @param width the new width
         * @param height the new height
         */
        scaleTo(width: number, height: number): void;
        /**
         * Gets the context of the canvas used by the texture
         * @returns the canvas context of the dynamic texture
         */
        getContext(): CanvasRenderingContext2D;
        /**
         * Clears the texture
         */
        clear(): void;
        /**
         * Updates the texture
         * @param invertY defines the direction for the Y axis (default is true - y increases downwards)
         */
        update(invertY?: boolean): void;
        /**
         * Draws text onto the texture
         * @param text defines the text to be drawn
         * @param x defines the placement of the text from the left
         * @param y defines the placement of the text from the top when invertY is true and from the bottom when false
         * @param font defines the font to be used with font-style, font-size, font-name
         * @param color defines the color used for the text
         * @param clearColor defines the color for the canvas, use null to not overwrite canvas
         * @param invertY defines the direction for the Y axis (default is true - y increases downwards)
         * @param update defines whether texture is immediately update (default is true)
         */
        drawText(text: string, x: number, y: number, font: string, color: string, clearColor: string, invertY?: boolean, update?: boolean): void;
        /**
         * Clones the texture
         * @returns the clone of the texture.
         */
        clone(): DynamicTexture;
        /** @hidden */
        _rebuild(): void;
    }
}

declare module BABYLON {
    /**
     * This represents a texture coming from an HDR input.
     *
     * The only supported format is currently panorama picture stored in RGBE format.
     * Example of such files can be found on HDRLib: http://hdrlib.com/
     */
    class HDRCubeTexture extends BaseTexture {
        private static _facesMapping;
        private _generateHarmonics;
        private _noMipmap;
        private _textureMatrix;
        private _size;
        private _onLoad;
        private _onError;
        /**
         * The texture URL.
         */
        url: string;
        /**
         * The texture coordinates mode. As this texture is stored in a cube format, please modify carefully.
         */
        coordinatesMode: number;
        protected _isBlocking: boolean;
        /**
         * Gets wether or not the texture is blocking during loading.
         */
        /**
         * Sets wether or not the texture is blocking during loading.
         */
        isBlocking: boolean;
        protected _rotationY: number;
        /**
         * Gets texture matrix rotation angle around Y axis radians.
         */
        /**
         * Sets texture matrix rotation angle around Y axis in radians.
         */
        rotationY: number;
        /**
         * Gets or sets the center of the bounding box associated with the cube texture
         * It must define where the camera used to render the texture was set
         */
        boundingBoxPosition: Vector3;
        private _boundingBoxSize;
        /**
         * Gets or sets the size of the bounding box associated with the cube texture
         * When defined, the cubemap will switch to local mode
         * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity
         * @example https://www.babylonjs-playground.com/#RNASML
         */
        boundingBoxSize: Vector3;
        /**
         * Instantiates an HDRTexture from the following parameters.
         *
         * @param url The location of the HDR raw data (Panorama stored in RGBE format)
         * @param scene The scene the texture will be used in
         * @param size The cubemap desired size (the more it increases the longer the generation will be)
         * @param noMipmap Forces to not generate the mipmap if true
         * @param generateHarmonics Specifies whether you want to extract the polynomial harmonics during the generation process
         * @param gammaSpace Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space)
         * @param reserved Reserved flag for internal use.
         */
        constructor(url: string, scene: Scene, size: number, noMipmap?: boolean, generateHarmonics?: boolean, gammaSpace?: boolean, reserved?: boolean, onLoad?: Nullable<() => void>, onError?: Nullable<(message?: string, exception?: any) => void>);
        /**
         * Occurs when the file is raw .hdr file.
         */
        private loadTexture();
        clone(): HDRCubeTexture;
        delayLoad(): void;
        getReflectionTextureMatrix(): Matrix;
        setReflectionTextureMatrix(value: Matrix): void;
        static Parse(parsedTexture: any, scene: Scene, rootUrl: string): Nullable<HDRCubeTexture>;
        serialize(): any;
    }
}

declare module BABYLON {
    /**
     * Class used to store data associated with WebGL texture data for the engine
     * This class should not be used directly
     */
    class InternalTexture implements IInternalTextureTracker {
        /**
         * The source of the texture data is unknown
         */
        static DATASOURCE_UNKNOWN: number;
        /**
         * Texture data comes from an URL
         */
        static DATASOURCE_URL: number;
        /**
         * Texture data is only used for temporary storage
         */
        static DATASOURCE_TEMP: number;
        /**
         * Texture data comes from raw data (ArrayBuffer)
         */
        static DATASOURCE_RAW: number;
        /**
         * Texture content is dynamic (video or dynamic texture)
         */
        static DATASOURCE_DYNAMIC: number;
        /**
         * Texture content is generated by rendering to it
         */
        static DATASOURCE_RENDERTARGET: number;
        /**
         * Texture content is part of a multi render target process
         */
        static DATASOURCE_MULTIRENDERTARGET: number;
        /**
         * Texture data comes from a cube data file
         */
        static DATASOURCE_CUBE: number;
        /**
         * Texture data comes from a raw cube data
         */
        static DATASOURCE_CUBERAW: number;
        /**
         * Texture data come from a prefiltered cube data file
         */
        static DATASOURCE_CUBEPREFILTERED: number;
        /**
         * Texture content is raw 3D data
         */
        static DATASOURCE_RAW3D: number;
        /**
         * Texture content is a depth texture
         */
        static DATASOURCE_DEPTHTEXTURE: number;
        /**
         * Defines if the texture is ready
         */
        isReady: boolean;
        /**
         * Defines if the texture is a cube texture
         */
        isCube: boolean;
        /**
         * Defines if the texture contains 3D data
         */
        is3D: boolean;
        /**
         * Gets the URL used to load this texture
         */
        url: string;
        /**
         * Gets the sampling mode of the texture
         */
        samplingMode: number;
        /**
         * Gets a boolean indicating if the texture needs mipmaps generation
         */
        generateMipMaps: boolean;
        /**
         * Gets the number of samples used by the texture (WebGL2+ only)
         */
        samples: number;
        /**
         * Gets the type of the texture
         */
        type: number;
        /**
         * Gets the format of the texture
         */
        format: number;
        /**
         * Observable called when the texture is loaded
         */
        onLoadedObservable: Observable<InternalTexture>;
        /**
         * Gets the width of the texture
         */
        width: number;
        /**
         * Gets the height of the texture
         */
        height: number;
        /**
         * Gets the depth of the texture
         */
        depth: number;
        /**
         * Gets the initial width of the texture (It could be rescaled if the current system does not support non power of two textures)
         */
        baseWidth: number;
        /**
         * Gets the initial height of the texture (It could be rescaled if the current system does not support non power of two textures)
         */
        baseHeight: number;
        /**
         * Gets the initial depth of the texture (It could be rescaled if the current system does not support non power of two textures)
         */
        baseDepth: number;
        /**
         * Gets a boolean indicating if the texture is inverted on Y axis
         */
        invertY: boolean;
        /**
         * Gets or set the previous tracker in the list
         */
        previous: Nullable<IInternalTextureTracker>;
        /**
         * Gets or set the next tracker in the list
         */
        next: Nullable<IInternalTextureTracker>;
        /** @hidden */
        _initialSlot: number;
        /** @hidden */
        _designatedSlot: number;
        /** @hidden */
        _dataSource: number;
        /** @hidden */
        _buffer: Nullable<ArrayBuffer | HTMLImageElement>;
        /** @hidden */
        _bufferView: Nullable<ArrayBufferView>;
        /** @hidden */
        _bufferViewArray: Nullable<ArrayBufferView[]>;
        /** @hidden */
        _size: number;
        /** @hidden */
        _extension: string;
        /** @hidden */
        _files: Nullable<string[]>;
        /** @hidden */
        _workingCanvas: HTMLCanvasElement;
        /** @hidden */
        _workingContext: CanvasRenderingContext2D;
        /** @hidden */
        _framebuffer: Nullable<WebGLFramebuffer>;
        /** @hidden */
        _depthStencilBuffer: Nullable<WebGLRenderbuffer>;
        /** @hidden */
        _MSAAFramebuffer: Nullable<WebGLFramebuffer>;
        /** @hidden */
        _MSAARenderBuffer: Nullable<WebGLRenderbuffer>;
        /** @hidden */
        _attachments: Nullable<number[]>;
        /** @hidden */
        _cachedCoordinatesMode: Nullable<number>;
        /** @hidden */
        _cachedWrapU: Nullable<number>;
        /** @hidden */
        _cachedWrapV: Nullable<number>;
        /** @hidden */
        _cachedWrapR: Nullable<number>;
        /** @hidden */
        _cachedAnisotropicFilteringLevel: Nullable<number>;
        /** @hidden */
        _isDisabled: boolean;
        /** @hidden */
        _compression: Nullable<string>;
        /** @hidden */
        _generateStencilBuffer: boolean;
        /** @hidden */
        _generateDepthBuffer: boolean;
        /** @hidden */
        _comparisonFunction: number;
        /** @hidden */
        _sphericalPolynomial: Nullable<SphericalPolynomial>;
        /** @hidden */
        _lodGenerationScale: number;
        /** @hidden */
        _lodGenerationOffset: number;
        /** @hidden */
        _lodTextureHigh: BaseTexture;
        /** @hidden */
        _lodTextureMid: BaseTexture;
        /** @hidden */
        _lodTextureLow: BaseTexture;
        /** @hidden */
        _webGLTexture: Nullable<WebGLTexture>;
        /** @hidden */
        _references: number;
        private _engine;
        /**
         * Gets the data source type of the texture (can be one of the BABYLON.InternalTexture.DATASOURCE_XXXX)
         */
        readonly dataSource: number;
        /**
         * Creates a new InternalTexture
         * @param engine defines the engine to use
         * @param dataSource defines the type of data that will be used
         */
        constructor(engine: Engine, dataSource: number);
        /**
         * Increments the number of references (ie. the number of {BABYLON.Texture} that point to it)
         */
        incrementReferences(): void;
        /**
         * Change the size of the texture (not the size of the content)
         * @param width defines the new width
         * @param height defines the new height
         * @param depth defines the new depth (1 by default)
         */
        updateSize(width: int, height: int, depth?: int): void;
        /** @hidden */
        _rebuild(): void;
        private _swapAndDie(target);
        /**
         * Dispose the current allocated resources
         */
        dispose(): void;
    }
}

declare module BABYLON {
    /**
     * Internal interface used to track {BABYLON.InternalTexture} already bound to the GL context
     */
    interface IInternalTextureTracker {
        /**
         * Gets or set the previous tracker in the list
         */
        previous: Nullable<IInternalTextureTracker>;
        /**
         * Gets or set the next tracker in the list
         */
        next: Nullable<IInternalTextureTracker>;
    }
    /**
     * Internal class used by the engine to get list of {BABYLON.InternalTexture} already bound to the GL context
     */
    class DummyInternalTextureTracker {
        /**
         * Gets or set the previous tracker in the list
         */
        previous: Nullable<IInternalTextureTracker>;
        /**
         * Gets or set the next tracker in the list
         */
        next: Nullable<IInternalTextureTracker>;
    }
}

declare module BABYLON {
    class MirrorTexture extends RenderTargetTexture {
        private scene;
        mirrorPlane: Plane;
        private _transformMatrix;
        private _mirrorMatrix;
        private _savedViewMatrix;
        private _blurX;
        private _blurY;
        private _adaptiveBlurKernel;
        private _blurKernelX;
        private _blurKernelY;
        private _blurRatio;
        blurRatio: number;
        adaptiveBlurKernel: number;
        blurKernel: number;
        blurKernelX: number;
        blurKernelY: number;
        private _autoComputeBlurKernel();
        protected _onRatioRescale(): void;
        private _updateGammaSpace();
        private _imageProcessingConfigChangeObserver;
        constructor(name: string, size: number | {
            width: number;
            height: number;
        } | {
            ratio: number;
        }, scene: Scene, generateMipMaps?: boolean, type?: number, samplingMode?: number, generateDepthBuffer?: boolean);
        private _preparePostProcesses();
        clone(): MirrorTexture;
        serialize(): any;
        dispose(): void;
    }
}

declare module BABYLON {
    interface IMultiRenderTargetOptions {
        generateMipMaps?: boolean;
        types?: number[];
        samplingModes?: number[];
        generateDepthBuffer?: boolean;
        generateStencilBuffer?: boolean;
        generateDepthTexture?: boolean;
        textureCount?: number;
        doNotChangeAspectRatio?: boolean;
        defaultType?: number;
    }
    class MultiRenderTarget extends RenderTargetTexture {
        private _internalTextures;
        private _textures;
        readonly isSupported: boolean;
        private _multiRenderTargetOptions;
        readonly textures: Texture[];
        readonly depthTexture: Texture;
        wrapU: number;
        wrapV: number;
        constructor(name: string, size: any, count: number, scene: Scene, options?: IMultiRenderTargetOptions);
        _rebuild(): void;
        private _createInternalTextures();
        private _createTextures();
        samples: number;
        resize(size: any): void;
        protected unbindFrameBuffer(engine: Engine, faceIndex: number): void;
        dispose(): void;
        releaseInternalTextures(): void;
    }
}

declare module BABYLON {
    class RawTexture extends Texture {
        format: number;
        private _engine;
        constructor(data: ArrayBufferView, width: number, height: number, format: number, scene: Scene, generateMipMaps?: boolean, invertY?: boolean, samplingMode?: number, type?: number);
        update(data: ArrayBufferView): void;
        static CreateLuminanceTexture(data: ArrayBufferView, width: number, height: number, scene: Scene, generateMipMaps?: boolean, invertY?: boolean, samplingMode?: number): RawTexture;
        static CreateLuminanceAlphaTexture(data: ArrayBufferView, width: number, height: number, scene: Scene, generateMipMaps?: boolean, invertY?: boolean, samplingMode?: number): RawTexture;
        static CreateAlphaTexture(data: ArrayBufferView, width: number, height: number, scene: Scene, generateMipMaps?: boolean, invertY?: boolean, samplingMode?: number): RawTexture;
        static CreateRGBTexture(data: ArrayBufferView, width: number, height: number, scene: Scene, generateMipMaps?: boolean, invertY?: boolean, samplingMode?: number, type?: number): RawTexture;
        static CreateRGBATexture(data: ArrayBufferView, width: number, height: number, scene: Scene, generateMipMaps?: boolean, invertY?: boolean, samplingMode?: number, type?: number): RawTexture;
    }
}

declare module BABYLON {
    /**
     * Class used to store 3D textures containing user data
     */
    class RawTexture3D extends Texture {
        /** Gets or sets the texture format to use*/
        format: number;
        private _engine;
        /**
         * Create a new RawTexture3D
         * @param data defines the data of the texture
         * @param width defines the width of the texture
         * @param height defines the height of the texture
         * @param depth defines the depth of the texture
         * @param format defines the texture format to use
         * @param scene defines the hosting scene
         * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)
         * @param invertY defines if texture must be stored with Y axis inverted
         * @param samplingMode defines the sampling mode to use (BABYLON.Texture.TRILINEAR_SAMPLINGMODE by default)
         */
        constructor(data: ArrayBufferView, width: number, height: number, depth: number, 
            /** Gets or sets the texture format to use*/
            format: number, scene: Scene, generateMipMaps?: boolean, invertY?: boolean, samplingMode?: number);
        /**
         * Update the texture with new data
         * @param data defines the data to store in the texture
         */
        update(data: ArrayBufferView): void;
    }
}

declare module BABYLON {
    /**
    * Creates a refraction texture used by refraction channel of the standard material.
    * @param name the texture name
    * @param size size of the underlying texture
    * @param scene root scene
    */
    class RefractionTexture extends RenderTargetTexture {
        refractionPlane: Plane;
        depth: number;
        constructor(name: string, size: number, scene: Scene, generateMipMaps?: boolean);
        clone(): RefractionTexture;
        serialize(): any;
    }
}

declare module BABYLON {
    class RenderTargetTexture extends Texture {
        isCube: boolean;
        static _REFRESHRATE_RENDER_ONCE: number;
        static _REFRESHRATE_RENDER_ONEVERYFRAME: number;
        static _REFRESHRATE_RENDER_ONEVERYTWOFRAMES: number;
        static readonly REFRESHRATE_RENDER_ONCE: number;
        static readonly REFRESHRATE_RENDER_ONEVERYFRAME: number;
        static readonly REFRESHRATE_RENDER_ONEVERYTWOFRAMES: number;
        /**
        * Use this predicate to dynamically define the list of mesh you want to render.
        * If set, the renderList property will be overwritten.
        */
        renderListPredicate: (AbstractMesh: AbstractMesh) => boolean;
        /**
        * Use this list to define the list of mesh you want to render.
        */
        renderList: Nullable<Array<AbstractMesh>>;
        renderParticles: boolean;
        renderSprites: boolean;
        coordinatesMode: number;
        activeCamera: Nullable<Camera>;
        customRenderFunction: (opaqueSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>, beforeTransparents?: () => void) => void;
        useCameraPostProcesses: boolean;
        ignoreCameraViewport: boolean;
        private _postProcessManager;
        private _postProcesses;
        private _resizeObserver;
        /**
        * An event triggered when the texture is unbind.
        */
        onBeforeBindObservable: Observable<RenderTargetTexture>;
        /**
        * An event triggered when the texture is unbind.
        */
        onAfterUnbindObservable: Observable<RenderTargetTexture>;
        private _onAfterUnbindObserver;
        onAfterUnbind: () => void;
        /**
        * An event triggered before rendering the texture
        */
        onBeforeRenderObservable: Observable<number>;
        private _onBeforeRenderObserver;
        onBeforeRender: (faceIndex: number) => void;
        /**
        * An event triggered after rendering the texture
        */
        onAfterRenderObservable: Observable<number>;
        private _onAfterRenderObserver;
        onAfterRender: (faceIndex: number) => void;
        /**
        * An event triggered after the texture clear
        */
        onClearObservable: Observable<Engine>;
        private _onClearObserver;
        onClear: (Engine: Engine) => void;
        clearColor: Color4;
        protected _size: number | {
            width: number;
            height: number;
        };
        protected _initialSizeParameter: number | {
            width: number;
            height: number;
        } | {
            ratio: number;
        };
        protected _sizeRatio: Nullable<number>;
        _generateMipMaps: boolean;
        protected _renderingManager: RenderingManager;
        _waitingRenderList: string[];
        protected _doNotChangeAspectRatio: boolean;
        protected _currentRefreshId: number;
        protected _refreshRate: number;
        protected _textureMatrix: Matrix;
        protected _samples: number;
        protected _renderTargetOptions: RenderTargetCreationOptions;
        readonly renderTargetOptions: RenderTargetCreationOptions;
        protected _engine: Engine;
        protected _onRatioRescale(): void;
        /**
         * Gets or sets the center of the bounding box associated with the texture (when in cube mode)
         * It must define where the camera used to render the texture is set
         */
        boundingBoxPosition: Vector3;
        private _boundingBoxSize;
        /**
         * Gets or sets the size of the bounding box associated with the texture (when in cube mode)
         * When defined, the cubemap will switch to local mode
         * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity
         * @example https://www.babylonjs-playground.com/#RNASML
         */
        boundingBoxSize: Vector3;
        /**
         * In case the RTT has been created with a depth texture, get the associated
         * depth texture.
         * Otherwise, return null.
         */
        depthStencilTexture: Nullable<InternalTexture>;
        /**
         * Instantiate a render target texture. This is mainly to render of screen the scene to for instance apply post processse
         * or used a shadow, depth texture...
         * @param name The friendly name of the texture
         * @param size The size of the RTT (number if square, or {with: number, height:number} or {ratio:} to define a ratio from the main scene)
         * @param scene The scene the RTT belongs to. The latest created scene will be used if not precised.
         * @param generateMipMaps True if mip maps need to be generated after render.
         * @param doNotChangeAspectRatio True to not change the aspect ratio of the scene in the RTT
         * @param type The type of the buffer in the RTT (int, half float, float...)
         * @param isCube True if a cube texture needs to be created
         * @param samplingMode The sampling mode to be usedwith the render target (Linear, Nearest...)
         * @param generateDepthBuffer True to generate a depth buffer
         * @param generateStencilBuffer True to generate a stencil buffer
         * @param isMulti True if multiple textures need to be created (Draw Buffers)
         */
        constructor(name: string, size: number | {
            width: number;
            height: number;
        } | {
            ratio: number;
        }, scene: Nullable<Scene>, generateMipMaps?: boolean, doNotChangeAspectRatio?: boolean, type?: number, isCube?: boolean, samplingMode?: number, generateDepthBuffer?: boolean, generateStencilBuffer?: boolean, isMulti?: boolean);
        /**
         * Creates a depth stencil texture.
         * This is only available in WebGL 2 or with the depth texture extension available.
         * @param comparisonFunction Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode
         * @param bilinearFiltering Specifies whether or not bilinear filtering is enable on the texture
         * @param generateStencil Specifies whether or not a stencil should be allocated in the texture
         */
        createDepthStencilTexture(comparisonFunction?: number, bilinearFiltering?: boolean, generateStencil?: boolean): void;
        private _processSizeParameter(size);
        samples: number;
        resetRefreshCounter(): void;
        refreshRate: number;
        addPostProcess(postProcess: PostProcess): void;
        clearPostProcesses(dispose?: boolean): void;
        removePostProcess(postProcess: PostProcess): void;
        _shouldRender(): boolean;
        getRenderSize(): number;
        getRenderWidth(): number;
        getRenderHeight(): number;
        readonly canRescale: boolean;
        scale(ratio: number): void;
        getReflectionTextureMatrix(): Matrix;
        resize(size: number | {
            width: number;
            height: number;
        } | {
            ratio: number;
        }): void;
        render(useCameraPostProcess?: boolean, dumpForDebug?: boolean): void;
        private _bestReflectionRenderTargetDimension(renderDimension, scale);
        protected unbindFrameBuffer(engine: Engine, faceIndex: number): void;
        private renderToTarget(faceIndex, currentRenderList, currentRenderListLength, useCameraPostProcess, dumpForDebug);
        /**
         * Overrides the default sort function applied in the renderging group to prepare the meshes.
         * This allowed control for front to back rendering or reversly depending of the special needs.
         *
         * @param renderingGroupId The rendering group id corresponding to its index
         * @param opaqueSortCompareFn The opaque queue comparison function use to sort.
         * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.
         * @param transparentSortCompareFn The transparent queue comparison function use to sort.
         */
        setRenderingOrder(renderingGroupId: number, opaqueSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>, alphaTestSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>, transparentSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>): void;
        /**
         * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
         *
         * @param renderingGroupId The rendering group id corresponding to its index
         * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
         */
        setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean): void;
        clone(): RenderTargetTexture;
        serialize(): any;
        disposeFramebufferObjects(): void;
        dispose(): void;
        _rebuild(): void;
        /**
         * Clear the info related to rendering groups preventing retention point in material dispose.
         */
        freeRenderingGroups(): void;
    }
}

declare module BABYLON {
    class Texture extends BaseTexture {
        static NEAREST_SAMPLINGMODE: number;
        static NEAREST_NEAREST_MIPLINEAR: number;
        static BILINEAR_SAMPLINGMODE: number;
        static LINEAR_LINEAR_MIPNEAREST: number;
        static TRILINEAR_SAMPLINGMODE: number;
        static LINEAR_LINEAR_MIPLINEAR: number;
        static NEAREST_NEAREST_MIPNEAREST: number;
        static NEAREST_LINEAR_MIPNEAREST: number;
        static NEAREST_LINEAR_MIPLINEAR: number;
        static NEAREST_LINEAR: number;
        static NEAREST_NEAREST: number;
        static LINEAR_NEAREST_MIPNEAREST: number;
        static LINEAR_NEAREST_MIPLINEAR: number;
        static LINEAR_LINEAR: number;
        static LINEAR_NEAREST: number;
        static EXPLICIT_MODE: number;
        static SPHERICAL_MODE: number;
        static PLANAR_MODE: number;
        static CUBIC_MODE: number;
        static PROJECTION_MODE: number;
        static SKYBOX_MODE: number;
        static INVCUBIC_MODE: number;
        static EQUIRECTANGULAR_MODE: number;
        static FIXED_EQUIRECTANGULAR_MODE: number;
        static FIXED_EQUIRECTANGULAR_MIRRORED_MODE: number;
        static CLAMP_ADDRESSMODE: number;
        static WRAP_ADDRESSMODE: number;
        static MIRROR_ADDRESSMODE: number;
        /**
         * Gets or sets a boolean which defines if the texture url must be build from the serialized URL instead of just using the name and loading them side by side with the scene file
         */
        static UseSerializedUrlIfAny: boolean;
        url: Nullable<string>;
        uOffset: number;
        vOffset: number;
        uScale: number;
        vScale: number;
        uAng: number;
        vAng: number;
        wAng: number;
        readonly noMipmap: boolean;
        private _noMipmap;
        _invertY: boolean;
        private _rowGenerationMatrix;
        private _cachedTextureMatrix;
        private _projectionModeMatrix;
        private _t0;
        private _t1;
        private _t2;
        private _cachedUOffset;
        private _cachedVOffset;
        private _cachedUScale;
        private _cachedVScale;
        private _cachedUAng;
        private _cachedVAng;
        private _cachedWAng;
        private _cachedProjectionMatrixId;
        private _cachedCoordinatesMode;
        _samplingMode: number;
        private _buffer;
        private _deleteBuffer;
        protected _format: Nullable<number>;
        private _delayedOnLoad;
        private _delayedOnError;
        protected _onLoadObservable: Nullable<Observable<Texture>>;
        protected _isBlocking: boolean;
        isBlocking: boolean;
        readonly samplingMode: number;
        constructor(url: Nullable<string>, scene: Nullable<Scene>, noMipmap?: boolean, invertY?: boolean, samplingMode?: number, onLoad?: Nullable<() => void>, onError?: Nullable<(message?: string, exception?: any) => void>, buffer?: any, deleteBuffer?: boolean, format?: number);
        updateURL(url: string): void;
        delayLoad(): void;
        updateSamplingMode(samplingMode: number): void;
        private _prepareRowForTextureGeneration(x, y, z, t);
        getTextureMatrix(): Matrix;
        getReflectionTextureMatrix(): Matrix;
        clone(): Texture;
        readonly onLoadObservable: Observable<Texture>;
        serialize(): any;
        getClassName(): string;
        dispose(): void;
        static CreateFromBase64String(data: string, name: string, scene: Scene, noMipmap?: boolean, invertY?: boolean, samplingMode?: number, onLoad?: Nullable<() => void>, onError?: Nullable<() => void>, format?: number): Texture;
        static Parse(parsedTexture: any, scene: Scene, rootUrl: string): Nullable<BaseTexture>;
        static LoadFromDataString(name: string, buffer: any, scene: Scene, deleteBuffer?: boolean, noMipmap?: boolean, invertY?: boolean, samplingMode?: number, onLoad?: Nullable<() => void>, onError?: Nullable<(message?: string, exception?: any) => void>, format?: number): Texture;
    }
}

declare module BABYLON {
    /**
     * Settings for finer control over video usage
     */
    interface VideoTextureSettings {
        /**
         * Applies `autoplay` to video, if specified
         */
        autoPlay?: boolean;
        /**
         * Applies `loop` to video, if specified
         */
        loop?: boolean;
        /**
         * Automatically updates internal texture from video at every frame in the render loop
         */
        autoUpdateTexture: boolean;
    }
    class VideoTexture extends Texture {
        /**
         * Tells whether textures will be updated automatically or user is required to call `updateTexture` manually
         */
        readonly autoUpdateTexture: boolean;
        /**
         * The video instance used by the texture internally
         */
        readonly video: HTMLVideoElement;
        private _generateMipMaps;
        private _engine;
        private _stillImageCaptured;
        /**
         * Creates a video texture.
         * Sample : https://doc.babylonjs.com/how_to/video_texture
         * @param {string | null} name optional name, will detect from video source, if not defined
         * @param {(string | string[] | HTMLVideoElement)} src can be used to provide an url, array of urls or an already setup HTML video element.
         * @param {BABYLON.Scene} scene is obviously the current scene.
         * @param {boolean} generateMipMaps can be used to turn on mipmaps (Can be expensive for videoTextures because they are often updated).
         * @param {boolean} invertY is false by default but can be used to invert video on Y axis
         * @param {number} samplingMode controls the sampling method and is set to TRILINEAR_SAMPLINGMODE by default
         * @param {VideoTextureSettings} [settings] allows finer control over video usage
         */
        constructor(name: Nullable<string>, src: string | string[] | HTMLVideoElement, scene: Nullable<Scene>, generateMipMaps?: boolean, invertY?: boolean, samplingMode?: number, settings?: VideoTextureSettings);
        private _getName(src);
        private _getVideo(src);
        private _createInternalTexture;
        private reset;
        /**
         * Internal method to initiate `update`.
         */
        _rebuild(): void;
        /**
         * Update Texture in the `auto` mode. Does not do anything if `settings.autoUpdateTexture` is false.
         */
        update(): void;
        /**
         * Update Texture in `manual` mode. Does not do anything if not visible or paused.
         * @param isVisible Visibility state, detected by user using `scene.getActiveMeshes()` or othervise.
         */
        updateTexture(isVisible: boolean): void;
        protected _updateInternalTexture: (e?: Event | undefined) => void;
        /**
         * Change video content. Changing video instance or setting multiple urls (as in constructor) is not supported.
         * @param url New url.
         */
        updateURL(url: string): void;
        dispose(): void;
        static CreateFromWebCam(scene: Scene, onReady: (videoTexture: VideoTexture) => void, constraints: {
            minWidth: number;
            maxWidth: number;
            minHeight: number;
            maxHeight: number;
            deviceId: string;
        }): void;
    }
}

declare var DracoDecoderModule: any;
declare var WebAssembly: any;
declare module BABYLON {
    /**
     * Configuration for Draco compression
     */
    interface IDracoCompressionConfiguration {
        /**
         * Configuration for the decoder.
         */
        decoder?: {
            /**
             * The url to the WebAssembly module.
             */
            wasmUrl?: string;
            /**
             * The url to the WebAssembly binary.
             */
            wasmBinaryUrl?: string;
            /**
             * The url to the fallback JavaScript module.
             */
            fallbackUrl?: string;
        };
    }
    /**
     * Draco compression (https://google.github.io/draco/)
     */
    class DracoCompression implements IDisposable {
        private static _DecoderModulePromise;
        /**
         * The configuration.
         */
        static Configuration: IDracoCompressionConfiguration;
        /**
         * Returns true if the decoder is available.
         */
        static readonly DecoderAvailable: boolean;
        /**
         * Constructor
         */
        constructor();
        /**
         * Stop all async operations and release resources.
         */
        dispose(): void;
        /**
         * Decode Draco compressed mesh data to vertex data.
         * @param data The array buffer view for the Draco compression data
         * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids
         * @returns A promise that resolves with the decoded vertex data
         */
        decodeMeshAsync(data: ArrayBufferView, attributes: {
            [kind: string]: number;
        }): Promise<VertexData>;
        private static _GetDecoderModule();
        private static _LoadScriptAsync(url);
        private static _LoadFileAsync(url);
    }
}

declare module BABYLON {
    /**
     * Particle emitter emitting particles from the inside of a box.
     * It emits the particles randomly between 2 given directions.
     */
    class BoxParticleEmitter implements IParticleEmitterType {
        /**
         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
         */
        direction1: Vector3;
        /**
         * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
         */
        direction2: Vector3;
        /**
         * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
         */
        minEmitBox: Vector3;
        /**
         * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
         */
        maxEmitBox: Vector3;
        /**
         * Creates a new instance BoxParticleEmitter
         */
        constructor();
        /**
         * Called by the particle System when the direction is computed for the created particle.
         * @param emitPower is the power of the particle (speed)
         * @param worldMatrix is the world matrix of the particle system
         * @param directionToUpdate is the direction vector to update with the result
         * @param particle is the particle we are computed the direction for
         */
        startDirectionFunction(emitPower: number, worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle): void;
        /**
         * Called by the particle System when the position is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param positionToUpdate is the position vector to update with the result
         * @param particle is the particle we are computed the position for
         */
        startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle): void;
        /**
         * Clones the current emitter and returns a copy of it
         * @returns the new emitter
         */
        clone(): BoxParticleEmitter;
        /**
         * Called by the {BABYLON.GPUParticleSystem} to setup the update shader
         * @param effect defines the update shader
         */
        applyToShader(effect: Effect): void;
        /**
         * Returns a string to use to update the GPU particles update shader
         * @returns a string containng the defines string
         */
        getEffectDefines(): string;
        /**
         * Returns the string "BoxEmitter"
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Serializes the particle system to a JSON object.
         * @returns the JSON object
         */
        serialize(): any;
        /**
         * Parse properties from a JSON object
         * @param serializationObject defines the JSON object
         */
        parse(serializationObject: any): void;
    }
}

declare module BABYLON {
    /**
     * Particle emitter emitting particles from the inside of a cone.
     * It emits the particles alongside the cone volume from the base to the particle.
     * The emission direction might be randomized.
     */
    class ConeParticleEmitter implements IParticleEmitterType {
        /**
         * The radius of the emission cone.
         */
        angle: number;
        /**
         * The cone base angle.
         */
        directionRandomizer: number;
        private _radius;
        private _height;
        /**
         * Gets the radius of the emission cone.
         */
        /**
         * Sets the radius of the emission cone.
         */
        radius: number;
        /**
         * Creates a new instance ConeParticleEmitter
         * @param radius the radius of the emission cone (1 by default)
         * @param angles the cone base angle (PI by default)
         * @param directionRandomizer defines how much to randomize the particle direction [0-1]
         */
        constructor(radius?: number, 
            /**
             * The radius of the emission cone.
             */
            angle?: number, 
            /**
             * The cone base angle.
             */
            directionRandomizer?: number);
        /**
         * Called by the particle System when the direction is computed for the created particle.
         * @param emitPower is the power of the particle (speed)
         * @param worldMatrix is the world matrix of the particle system
         * @param directionToUpdate is the direction vector to update with the result
         * @param particle is the particle we are computed the direction for
         */
        startDirectionFunction(emitPower: number, worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle): void;
        /**
         * Called by the particle System when the position is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param positionToUpdate is the position vector to update with the result
         * @param particle is the particle we are computed the position for
         */
        startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle): void;
        /**
         * Clones the current emitter and returns a copy of it
         * @returns the new emitter
         */
        clone(): ConeParticleEmitter;
        /**
         * Called by the {BABYLON.GPUParticleSystem} to setup the update shader
         * @param effect defines the update shader
         */
        applyToShader(effect: Effect): void;
        /**
         * Returns a string to use to update the GPU particles update shader
         * @returns a string containng the defines string
         */
        getEffectDefines(): string;
        /**
         * Returns the string "BoxEmitter"
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Serializes the particle system to a JSON object.
         * @returns the JSON object
         */
        serialize(): any;
        /**
         * Parse properties from a JSON object
         * @param serializationObject defines the JSON object
         */
        parse(serializationObject: any): void;
    }
}

declare module BABYLON {
    /**
     * Particle emitter represents a volume emitting particles.
     * This is the responsibility of the implementation to define the volume shape like cone/sphere/box.
     */
    interface IParticleEmitterType {
        /**
         * Called by the particle System when the direction is computed for the created particle.
         * @param emitPower is the power of the particle (speed)
         * @param worldMatrix is the world matrix of the particle system
         * @param directionToUpdate is the direction vector to update with the result
         * @param particle is the particle we are computed the direction for
         */
        startDirectionFunction(emitPower: number, worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle): void;
        /**
         * Called by the particle System when the position is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param positionToUpdate is the position vector to update with the result
         * @param particle is the particle we are computed the position for
         */
        startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle): void;
        /**
         * Clones the current emitter and returns a copy of it
         * @returns the new emitter
         */
        clone(): IParticleEmitterType;
        /**
         * Called by the {BABYLON.GPUParticleSystem} to setup the update shader
         * @param effect defines the update shader
         */
        applyToShader(effect: Effect): void;
        /**
         * Returns a string to use to update the GPU particles update shader
         * @returns the effect defines string
         */
        getEffectDefines(): string;
        /**
         * Returns a string representing the class name
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Serializes the particle system to a JSON object.
         * @returns the JSON object
         */
        serialize(): any;
        /**
                * Parse properties from a JSON object
                * @param serializationObject defines the JSON object
                */
        parse(serializationObject: any): void;
    }
}

declare module BABYLON {
    /**
     * Particle emitter emitting particles from the inside of a sphere.
     * It emits the particles alongside the sphere radius. The emission direction might be randomized.
     */
    class SphereParticleEmitter implements IParticleEmitterType {
        /**
         * The radius of the emission sphere.
         */
        radius: number;
        /**
         * How much to randomize the particle direction [0-1].
         */
        directionRandomizer: number;
        /**
         * Creates a new instance SphereParticleEmitter
         * @param radius the radius of the emission sphere (1 by default)
         * @param directionRandomizer defines how much to randomize the particle direction [0-1]
         */
        constructor(
            /**
             * The radius of the emission sphere.
             */
            radius?: number, 
            /**
             * How much to randomize the particle direction [0-1].
             */
            directionRandomizer?: number);
        /**
         * Called by the particle System when the direction is computed for the created particle.
         * @param emitPower is the power of the particle (speed)
         * @param worldMatrix is the world matrix of the particle system
         * @param directionToUpdate is the direction vector to update with the result
         * @param particle is the particle we are computed the direction for
         */
        startDirectionFunction(emitPower: number, worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle): void;
        /**
         * Called by the particle System when the position is computed for the created particle.
         * @param worldMatrix is the world matrix of the particle system
         * @param positionToUpdate is the position vector to update with the result
         * @param particle is the particle we are computed the position for
         */
        startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle): void;
        /**
         * Clones the current emitter and returns a copy of it
         * @returns the new emitter
         */
        clone(): SphereParticleEmitter;
        /**
         * Called by the {BABYLON.GPUParticleSystem} to setup the update shader
         * @param effect defines the update shader
         */
        applyToShader(effect: Effect): void;
        /**
         * Returns a string to use to update the GPU particles update shader
         * @returns a string containng the defines string
         */
        getEffectDefines(): string;
        /**
         * Returns the string "SphereParticleEmitter"
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Serializes the particle system to a JSON object.
         * @returns the JSON object
         */
        serialize(): any;
        /**
         * Parse properties from a JSON object
         * @param serializationObject defines the JSON object
         */
        parse(serializationObject: any): void;
    }
    /**
     * Particle emitter emitting particles from the inside of a sphere.
     * It emits the particles randomly between two vectors.
     */
    class SphereDirectedParticleEmitter extends SphereParticleEmitter {
        /**
         * The min limit of the emission direction.
         */
        direction1: Vector3;
        /**
         * The max limit of the emission direction.
         */
        direction2: Vector3;
        /**
         * Creates a new instance SphereDirectedParticleEmitter
         * @param radius the radius of the emission sphere (1 by default)
         * @param direction1 the min limit of the emission direction (up vector by default)
         * @param direction2 the max limit of the emission direction (up vector by default)
         */
        constructor(radius?: number, 
            /**
             * The min limit of the emission direction.
             */
            direction1?: Vector3, 
            /**
             * The max limit of the emission direction.
             */
            direction2?: Vector3);
        /**
         * Called by the particle System when the direction is computed for the created particle.
         * @param emitPower is the power of the particle (speed)
         * @param worldMatrix is the world matrix of the particle system
         * @param directionToUpdate is the direction vector to update with the result
         * @param particle is the particle we are computed the direction for
         */
        startDirectionFunction(emitPower: number, worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle): void;
        /**
         * Clones the current emitter and returns a copy of it
         * @returns the new emitter
         */
        clone(): SphereDirectedParticleEmitter;
        /**
         * Called by the {BABYLON.GPUParticleSystem} to setup the update shader
         * @param effect defines the update shader
         */
        applyToShader(effect: Effect): void;
        /**
         * Returns a string to use to update the GPU particles update shader
         * @returns a string containng the defines string
         */
        getEffectDefines(): string;
        /**
         * Returns the string "SphereDirectedParticleEmitter"
         * @returns a string containing the class name
         */
        getClassName(): string;
        /**
         * Serializes the particle system to a JSON object.
         * @returns the JSON object
         */
        serialize(): any;
        /**
         * Parse properties from a JSON object
         * @param serializationObject defines the JSON object
         */
        parse(serializationObject: any): void;
    }
}

declare module BABYLON {
    class CannonJSPlugin implements IPhysicsEnginePlugin {
        private _useDeltaForWorldStep;
        world: any;
        name: string;
        private _physicsMaterials;
        private _fixedTimeStep;
        BJSCANNON: any;
        constructor(_useDeltaForWorldStep?: boolean, iterations?: number);
        setGravity(gravity: Vector3): void;
        setTimeStep(timeStep: number): void;
        getTimeStep(): number;
        executeStep(delta: number, impostors: Array<PhysicsImpostor>): void;
        applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3): void;
        applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3): void;
        generatePhysicsBody(impostor: PhysicsImpostor): void;
        private _processChildMeshes(mainImpostor);
        removePhysicsBody(impostor: PhysicsImpostor): void;
        generateJoint(impostorJoint: PhysicsImpostorJoint): void;
        removeJoint(impostorJoint: PhysicsImpostorJoint): void;
        private _addMaterial(name, friction, restitution);
        private _checkWithEpsilon(value);
        private _createShape(impostor);
        private _createHeightmap(object, pointDepth?);
        private _minus90X;
        private _plus90X;
        private _tmpPosition;
        private _tmpDeltaPosition;
        private _tmpUnityRotation;
        private _updatePhysicsBodyTransformation(impostor);
        setTransformationFromPhysicsBody(impostor: PhysicsImpostor): void;
        setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion): void;
        isSupported(): boolean;
        setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3): void;
        setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3): void;
        getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3>;
        getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3>;
        setBodyMass(impostor: PhysicsImpostor, mass: number): void;
        getBodyMass(impostor: PhysicsImpostor): number;
        getBodyFriction(impostor: PhysicsImpostor): number;
        setBodyFriction(impostor: PhysicsImpostor, friction: number): void;
        getBodyRestitution(impostor: PhysicsImpostor): number;
        setBodyRestitution(impostor: PhysicsImpostor, restitution: number): void;
        sleepBody(impostor: PhysicsImpostor): void;
        wakeUpBody(impostor: PhysicsImpostor): void;
        updateDistanceJoint(joint: PhysicsJoint, maxDistance: number, minDistance?: number): void;
        setMotor(joint: IMotorEnabledJoint, speed?: number, maxForce?: number, motorIndex?: number): void;
        setLimit(joint: IMotorEnabledJoint, upperLimit: number, lowerLimit?: number): void;
        syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor): void;
        getRadius(impostor: PhysicsImpostor): number;
        getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void;
        dispose(): void;
        private _extendNamespace();
    }
}

declare module BABYLON {
    class OimoJSPlugin implements IPhysicsEnginePlugin {
        world: any;
        name: string;
        BJSOIMO: any;
        constructor(iterations?: number);
        setGravity(gravity: Vector3): void;
        setTimeStep(timeStep: number): void;
        getTimeStep(): number;
        private _tmpImpostorsArray;
        executeStep(delta: number, impostors: Array<PhysicsImpostor>): void;
        applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3): void;
        applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3): void;
        generatePhysicsBody(impostor: PhysicsImpostor): void;
        private _tmpPositionVector;
        removePhysicsBody(impostor: PhysicsImpostor): void;
        generateJoint(impostorJoint: PhysicsImpostorJoint): void;
        removeJoint(impostorJoint: PhysicsImpostorJoint): void;
        isSupported(): boolean;
        setTransformationFromPhysicsBody(impostor: PhysicsImpostor): void;
        setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion): void;
        setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3): void;
        setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3): void;
        getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3>;
        getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3>;
        setBodyMass(impostor: PhysicsImpostor, mass: number): void;
        getBodyMass(impostor: PhysicsImpostor): number;
        getBodyFriction(impostor: PhysicsImpostor): number;
        setBodyFriction(impostor: PhysicsImpostor, friction: number): void;
        getBodyRestitution(impostor: PhysicsImpostor): number;
        setBodyRestitution(impostor: PhysicsImpostor, restitution: number): void;
        sleepBody(impostor: PhysicsImpostor): void;
        wakeUpBody(impostor: PhysicsImpostor): void;
        updateDistanceJoint(joint: PhysicsJoint, maxDistance: number, minDistance?: number): void;
        setMotor(joint: IMotorEnabledJoint, speed: number, maxForce?: number, motorIndex?: number): void;
        setLimit(joint: IMotorEnabledJoint, upperLimit: number, lowerLimit?: number, motorIndex?: number): void;
        syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor): void;
        getRadius(impostor: PhysicsImpostor): number;
        getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void;
        dispose(): void;
    }
}

declare module BABYLON {
    /**
     * This represents a set of one or more post processes in Babylon.
     * A post process can be used to apply a shader to a texture after it is rendered.
     * @example https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline
     */
    class PostProcessRenderEffect {
        private _postProcesses;
        private _getPostProcesses;
        private _singleInstance;
        private _cameras;
        private _indicesForCamera;
        /**
         * Name of the effect
         */
        _name: string;
        /**
         * Instantiates a post process render effect.
         * A post process can be used to apply a shader to a texture after it is rendered.
         * @param engine The engine the effect is tied to
         * @param name The name of the effect
         * @param getPostProcesses A function that returns a set of post processes which the effect will run in order to be run.
         * @param singleInstance False if this post process can be run on multiple cameras. (default: true)
         */
        constructor(engine: Engine, name: string, getPostProcesses: () => Nullable<PostProcess | Array<PostProcess>>, singleInstance?: boolean);
        /**
         * Checks if all the post processes in the effect are supported.
         */
        readonly isSupported: boolean;
        /**
         * Updates the current state of the effect
         */
        _update(): void;
        /**
         * Attaches the effect on cameras
         * @param cameras The camera to attach to.
         */
        _attachCameras(cameras: Camera): void;
        /**
         * Attaches the effect on cameras
         * @param cameras The camera to attach to.
         */
        _attachCameras(cameras: Camera[]): void;
        /**
         * Detatches the effect on cameras
         * @param cameras The camera to detatch from.
         */
        _detachCameras(cameras: Camera): void;
        /**
         * Detatches the effect on cameras
         * @param cameras The camera to detatch from.
         */
        _detachCameras(cameras: Camera[]): void;
        /**
         * Enables the effect on given cameras
         * @param cameras The camera to enable.
         */
        _enable(cameras: Camera): void;
        /**
         * Enables the effect on given cameras
         * @param cameras The camera to enable.
         */
        _enable(cameras: Nullable<Camera[]>): void;
        /**
         * Disables the effect on the given cameras
         * @param cameras The camera to disable.
         */
        _disable(cameras: Camera): void;
        /**
         * Disables the effect on the given cameras
         * @param cameras The camera to disable.
         */
        _disable(cameras: Nullable<Camera[]>): void;
        /**
         * Gets a list of the post processes contained in the effect.
         * @param camera The camera to get the post processes on.
         * @returns The list of the post processes in the effect.
         */
        getPostProcesses(camera?: Camera): Nullable<Array<PostProcess>>;
    }
}

declare module BABYLON {
    class PostProcessRenderPipeline {
        private engine;
        private _renderEffects;
        private _renderEffectsForIsolatedPass;
        protected _cameras: Camera[];
        _name: string;
        constructor(engine: Engine, name: string);
        getClassName(): string;
        readonly isSupported: boolean;
        addEffect(renderEffect: PostProcessRenderEffect): void;
        _rebuild(): void;
        _enableEffect(renderEffectName: string, cameras: Camera): void;
        _enableEffect(renderEffectName: string, cameras: Camera[]): void;
        _disableEffect(renderEffectName: string, cameras: Nullable<Camera[]>): void;
        _disableEffect(renderEffectName: string, cameras: Nullable<Camera[]>): void;
        _attachCameras(cameras: Camera, unique: boolean): void;
        _attachCameras(cameras: Camera[], unique: boolean): void;
        _detachCameras(cameras: Camera): void;
        _detachCameras(cameras: Nullable<Camera[]>): void;
        _update(): void;
        _reset(): void;
        protected _enableMSAAOnFirstPostProcess(sampleCount: number): boolean;
        dispose(): void;
    }
}

declare module BABYLON {
    class PostProcessRenderPipelineManager {
        private _renderPipelines;
        constructor();
        addPipeline(renderPipeline: PostProcessRenderPipeline): void;
        attachCamerasToRenderPipeline(renderPipelineName: string, cameras: Camera, unique?: boolean): void;
        attachCamerasToRenderPipeline(renderPipelineName: string, cameras: Camera[], unique?: boolean): void;
        detachCamerasFromRenderPipeline(renderPipelineName: string, cameras: Camera): void;
        detachCamerasFromRenderPipeline(renderPipelineName: string, cameras: Camera[]): void;
        enableEffectInPipeline(renderPipelineName: string, renderEffectName: string, cameras: Camera): void;
        enableEffectInPipeline(renderPipelineName: string, renderEffectName: string, cameras: Camera[]): void;
        disableEffectInPipeline(renderPipelineName: string, renderEffectName: string, cameras: Camera): void;
        disableEffectInPipeline(renderPipelineName: string, renderEffectName: string, cameras: Camera[]): void;
        update(): void;
        _rebuild(): void;
        dispose(): void;
    }
}

declare module BABYLON {
    /**
     * Helper class dealing with the extraction of spherical polynomial dataArray
     * from a cube map.
     */
    class CubeMapToSphericalPolynomialTools {
        private static FileFaces;
        /**
         * Converts a texture to the according Spherical Polynomial data.
         * This extracts the first 3 orders only as they are the only one used in the lighting.
         *
         * @param texture The texture to extract the information from.
         * @return The Spherical Polynomial data.
         */
        static ConvertCubeMapTextureToSphericalPolynomial(texture: BaseTexture): Nullable<SphericalPolynomial>;
        /**
         * Converts a cubemap to the according Spherical Polynomial data.
         * This extracts the first 3 orders only as they are the only one used in the lighting.
         *
         * @param cubeInfo The Cube map to extract the information from.
         * @return The Spherical Polynomial data.
         */
        static ConvertCubeMapToSphericalPolynomial(cubeInfo: CubeMapInfo): SphericalPolynomial;
    }
}

declare module BABYLON {
    /**
     * Header information of HDR texture files.
     */
    interface HDRInfo {
        /**
         * The height of the texture in pixels.
         */
        height: number;
        /**
         * The width of the texture in pixels.
         */
        width: number;
        /**
         * The index of the beginning of the data in the binary file.
         */
        dataPosition: number;
    }
    /**
     * This groups tools to convert HDR texture to native colors array.
     */
    class HDRTools {
        private static Ldexp(mantissa, exponent);
        private static Rgbe2float(float32array, red, green, blue, exponent, index);
        private static readStringLine(uint8array, startIndex);
        /**
         * Reads header information from an RGBE texture stored in a native array.
         * More information on this format are available here:
         * https://en.wikipedia.org/wiki/RGBE_image_format
         *
         * @param uint8array The binary file stored in  native array.
         * @return The header information.
         */
        static RGBE_ReadHeader(uint8array: Uint8Array): HDRInfo;
        /**
         * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.
         * This RGBE texture needs to store the information as a panorama.
         *
         * More information on this format are available here:
         * https://en.wikipedia.org/wiki/RGBE_image_format
         *
         * @param buffer The binary file stored in an array buffer.
         * @param size The expected size of the extracted cubemap.
         * @return The Cube Map information.
         */
        static GetCubeMapTextureData(buffer: ArrayBuffer, size: number): CubeMapInfo;
        /**
         * Returns the pixels data extracted from an RGBE texture.
         * This pixels will be stored left to right up to down in the R G B order in one array.
         *
         * More information on this format are available here:
         * https://en.wikipedia.org/wiki/RGBE_image_format
         *
         * @param uint8array The binary file stored in an array buffer.
         * @param hdrInfo The header information of the file.
         * @return The pixels data in RGB right to left up to down order.
         */
        static RGBE_ReadPixels(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array;
        private static RGBE_ReadPixels_RLE(uint8array, hdrInfo);
    }
}

declare module BABYLON {
    /**
     * CubeMap information grouping all the data for each faces as well as the cubemap size.
     */
    interface CubeMapInfo {
        /**
         * The pixel array for the front face.
         * This is stored in format, left to right, up to down format.
         */
        front: Nullable<ArrayBufferView>;
        /**
         * The pixel array for the back face.
         * This is stored in format, left to right, up to down format.
         */
        back: Nullable<ArrayBufferView>;
        /**
         * The pixel array for the left face.
         * This is stored in format, left to right, up to down format.
         */
        left: Nullable<ArrayBufferView>;
        /**
         * The pixel array for the right face.
         * This is stored in format, left to right, up to down format.
         */
        right: Nullable<ArrayBufferView>;
        /**
         * The pixel array for the up face.
         * This is stored in format, left to right, up to down format.
         */
        up: Nullable<ArrayBufferView>;
        /**
         * The pixel array for the down face.
         * This is stored in format, left to right, up to down format.
         */
        down: Nullable<ArrayBufferView>;
        /**
         * The size of the cubemap stored.
         *
         * Each faces will be size * size pixels.
         */
        size: number;
        /**
         * The format of the texture.
         *
         * RGBA, RGB.
         */
        format: number;
        /**
         * The type of the texture data.
         *
         * UNSIGNED_INT, FLOAT.
         */
        type: number;
        /**
         * Specifies whether the texture is in gamma space.
         */
        gammaSpace: boolean;
    }
    /**
     * Helper class usefull to convert panorama picture to their cubemap representation in 6 faces.
     */
    class PanoramaToCubeMapTools {
        private static FACE_FRONT;
        private static FACE_BACK;
        private static FACE_RIGHT;
        private static FACE_LEFT;
        private static FACE_DOWN;
        private static FACE_UP;
        /**
         * Converts a panorma stored in RGB right to left up to down format into a cubemap (6 faces).
         *
         * @param float32Array The source data.
         * @param inputWidth The width of the input panorama.
         * @param inputhHeight The height of the input panorama.
         * @param size The willing size of the generated cubemap (each faces will be size * size pixels)
         * @return The cubemap data
         */
        static ConvertPanoramaToCubemap(float32Array: Float32Array, inputWidth: number, inputHeight: number, size: number): CubeMapInfo;
        private static CreateCubemapTexture(texSize, faceData, float32Array, inputWidth, inputHeight);
        private static CalcProjectionSpherical(vDir, float32Array, inputWidth, inputHeight);
    }
}

declare module BABYLON {
    class CustomProceduralTexture extends ProceduralTexture {
        private _animate;
        private _time;
        private _config;
        private _texturePath;
        constructor(name: string, texturePath: any, size: number, scene: Scene, fallbackTexture?: Texture, generateMipMaps?: boolean);
        private loadJson(jsonUrl);
        isReady(): boolean;
        render(useCameraPostProcess?: boolean): void;
        updateTextures(): void;
        updateShaderUniforms(): void;
        animate: boolean;
    }
}

declare module BABYLON {
    class ProceduralTexture extends Texture {
        isCube: boolean;
        private _size;
        _generateMipMaps: boolean;
        isEnabled: boolean;
        private _currentRefreshId;
        private _refreshRate;
        onGenerated: () => void;
        private _vertexBuffers;
        private _indexBuffer;
        private _effect;
        private _uniforms;
        private _samplers;
        private _fragment;
        _textures: {
            [key: string]: Texture;
        };
        private _floats;
        private _floatsArrays;
        private _colors3;
        private _colors4;
        private _vectors2;
        private _vectors3;
        private _matrices;
        private _fallbackTexture;
        private _fallbackTextureUsed;
        private _engine;
        constructor(name: string, size: any, fragment: any, scene: Scene, fallbackTexture?: Nullable<Texture>, generateMipMaps?: boolean, isCube?: boolean);
        private _createIndexBuffer();
        _rebuild(): void;
        reset(): void;
        isReady(): boolean;
        resetRefreshCounter(): void;
        setFragment(fragment: any): void;
        refreshRate: number;
        _shouldRender(): boolean;
        getRenderSize(): number;
        resize(size: number, generateMipMaps: boolean): void;
        private _checkUniform(uniformName);
        setTexture(name: string, texture: Texture): ProceduralTexture;
        setFloat(name: string, value: number): ProceduralTexture;
        setFloats(name: string, value: number[]): ProceduralTexture;
        setColor3(name: string, value: Color3): ProceduralTexture;
        setColor4(name: string, value: Color4): ProceduralTexture;
        setVector2(name: string, value: Vector2): ProceduralTexture;
        setVector3(name: string, value: Vector3): ProceduralTexture;
        setMatrix(name: string, value: Matrix): ProceduralTexture;
        render(useCameraPostProcess?: boolean): void;
        clone(): ProceduralTexture;
        dispose(): void;
    }
}

declare module BABYLON {
    /**
     * The default rendering pipeline can be added to a scene to apply common post processing effects such as anti-aliasing or depth of field.
     * See https://doc.babylonjs.com/how_to/using_default_rendering_pipeline
     */
    class DefaultRenderingPipeline extends PostProcessRenderPipeline implements IDisposable, IAnimatable {
        private _scene;
        private _originalCameras;
        /**
         * ID of the sharpen post process,
         */
        private readonly SharpenPostProcessId;
        /**
         * ID of the image processing post process;
         */
        readonly ImageProcessingPostProcessId: string;
        /**
         * ID of the Fast Approximate Anti-Aliasing post process;
         */
        readonly FxaaPostProcessId: string;
        /**
         * ID of the chromatic aberration post process,
         */
        private readonly ChromaticAberrationPostProcessId;
        /**
         * ID of the grain post process
         */
        private readonly GrainPostProcessId;
        /**
         * Sharpen post process which will apply a sharpen convolution to enhance edges
         */
        sharpen: SharpenPostProcess;
        private _sharpenEffect;
        private bloom;
        /**
         * Depth of field effect, applies a blur based on how far away objects are from the focus distance.
         */
        depthOfField: DepthOfFieldEffect;
        /**
         * The Fast Approximate Anti-Aliasing post process which attemps to remove aliasing from an image.
         */
        fxaa: FxaaPostProcess;
        /**
         * Image post processing pass used to perform operations such as tone mapping or color grading.
         */
        imageProcessing: ImageProcessingPostProcess;
        /**
         * Chromatic aberration post process which will shift rgb colors in the image
         */
        chromaticAberration: ChromaticAberrationPostProcess;
        private _chromaticAberrationEffect;
        /**
         * Grain post process which add noise to the image
         */
        grain: GrainPostProcess;
        private _grainEffect;
        /**
         * Animations which can be used to tweak settings over a period of time
         */
        animations: Animation[];
        private _imageProcessingConfigurationObserver;
        private _sharpenEnabled;
        private _bloomEnabled;
        private _depthOfFieldEnabled;
        private _depthOfFieldBlurLevel;
        private _fxaaEnabled;
        private _imageProcessingEnabled;
        private _defaultPipelineTextureType;
        private _bloomScale;
        private _chromaticAberrationEnabled;
        private _grainEnabled;
        private _buildAllowed;
        /**
         * Enable or disable the sharpen process from the pipeline
         */
        sharpenEnabled: boolean;
        private _resizeObserver;
        private _hardwareScaleLevel;
        private _bloomKernel;
        /**
         * Specifies the size of the bloom blur kernel, relative to the final output size
         */
        bloomKernel: number;
        /**
         * Specifies the weight of the bloom in the final rendering
         */
        private _bloomWeight;
        /**
         * Specifies the luma threshold for the area that will be blurred by the bloom
         */
        private _bloomThreshold;
        private _hdr;
        /**
         * The strength of the bloom.
         */
        bloomWeight: number;
        /**
         * The strength of the bloom.
         */
        bloomThreshold: number;
        /**
         * The scale of the bloom, lower value will provide better performance.
         */
        bloomScale: number;
        /**
         * Enable or disable the bloom from the pipeline
         */
        bloomEnabled: boolean;
        private _rebuildBloom();
        /**
         * If the depth of field is enabled.
         */
        depthOfFieldEnabled: boolean;
        /**
         * Blur level of the depth of field effect. (Higher blur will effect performance)
         */
        depthOfFieldBlurLevel: DepthOfFieldEffectBlurLevel;
        /**
         * If the anti aliasing is enabled.
         */
        fxaaEnabled: boolean;
        private _samples;
        /**
         * MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)
         */
        samples: number;
        /**
         * If image processing is enabled.
         */
        imageProcessingEnabled: boolean;
        /**
         * Enable or disable the chromaticAberration process from the pipeline
         */
        chromaticAberrationEnabled: boolean;
        /**
         * Enable or disable the grain process from the pipeline
         */
        grainEnabled: boolean;
        /**
         * @constructor
         * @param {string} name - The rendering pipeline name
         * @param {BABYLON.Scene} scene - The scene linked to this pipeline
         * @param {any} ratio - The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)
         * @param {BABYLON.Camera[]} cameras - The array of cameras that the rendering pipeline will be attached to
         * @param {boolean} automaticBuild - if false, you will have to manually call prepare() to update the pipeline
         */
        constructor(name: string, hdr: boolean, scene: Scene, cameras?: Camera[], automaticBuild?: boolean);
        /**
         * Force the compilation of the entire pipeline.
         */
        prepare(): void;
        private _hasCleared;
        private _prevPostProcess;
        private _prevPrevPostProcess;
        private _setAutoClearAndTextureSharing(postProcess, skipTextureSharing?);
        private _buildPipeline();
        private _disposePostProcesses(disposeNonRecreated?);
        /**
         * Dispose of the pipeline and stop all post processes
         */
        dispose(): void;
        /**
         * Serialize the rendering pipeline (Used when exporting)
         * @returns the serialized object
         */
        serialize(): any;
        /**
         * Parse the serialized pipeline
         * @param source Source pipeline.
         * @param scene The scene to load the pipeline to.
         * @param rootUrl The URL of the serialized pipeline.
         * @returns An instantiated pipeline from the serialized object.
         */
        static Parse(source: any, scene: Scene, rootUrl: string): DefaultRenderingPipeline;
    }
}

declare module BABYLON {
    class LensRenderingPipeline extends PostProcessRenderPipeline {
        /**
        * The chromatic aberration PostProcess id in the pipeline
        */
        LensChromaticAberrationEffect: string;
        /**
        * The highlights enhancing PostProcess id in the pipeline
        */
        HighlightsEnhancingEffect: string;
        /**
        * The depth-of-field PostProcess id in the pipeline
        */
        LensDepthOfFieldEffect: string;
        private _scene;
        private _depthTexture;
        private _grainTexture;
        private _chromaticAberrationPostProcess;
        private _highlightsPostProcess;
        private _depthOfFieldPostProcess;
        private _edgeBlur;
        private _grainAmount;
        private _chromaticAberration;
        private _distortion;
        private _highlightsGain;
        private _highlightsThreshold;
        private _dofDistance;
        private _dofAperture;
        private _dofDarken;
        private _dofPentagon;
        private _blurNoise;
        /**
         * @constructor
         *
         * Effect parameters are as follow:
         * {
         *      chromatic_aberration: number;       // from 0 to x (1 for realism)
         *      edge_blur: number;                  // from 0 to x (1 for realism)
         *      distortion: number;                 // from 0 to x (1 for realism)
         *      grain_amount: number;               // from 0 to 1
         *      grain_texture: BABYLON.Texture;     // texture to use for grain effect; if unset, use random B&W noise
         *      dof_focus_distance: number;         // depth-of-field: focus distance; unset to disable (disabled by default)
         *      dof_aperture: number;               // depth-of-field: focus blur bias (default: 1)
         *      dof_darken: number;                 // depth-of-field: darken that which is out of focus (from 0 to 1, disabled by default)
         *      dof_pentagon: boolean;              // depth-of-field: makes a pentagon-like "bokeh" effect
         *      dof_gain: number;                   // depth-of-field: highlights gain; unset to disable (disabled by default)
         *      dof_threshold: number;              // depth-of-field: highlights threshold (default: 1)
         *      blur_noise: boolean;                // add a little bit of noise to the blur (default: true)
         * }
         * Note: if an effect parameter is unset, effect is disabled
         *
         * @param {string} name - The rendering pipeline name
         * @param {object} parameters - An object containing all parameters (see above)
         * @param {BABYLON.Scene} scene - The scene linked to this pipeline
         * @param {number} ratio - The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)
         * @param {BABYLON.Camera[]} cameras - The array of cameras that the rendering pipeline will be attached to
         */
        constructor(name: string, parameters: any, scene: Scene, ratio?: number, cameras?: Camera[]);
        setEdgeBlur(amount: number): void;
        disableEdgeBlur(): void;
        setGrainAmount(amount: number): void;
        disableGrain(): void;
        setChromaticAberration(amount: number): void;
        disableChromaticAberration(): void;
        setEdgeDistortion(amount: number): void;
        disableEdgeDistortion(): void;
        setFocusDistance(amount: number): void;
        disableDepthOfField(): void;
        setAperture(amount: number): void;
        setDarkenOutOfFocus(amount: number): void;
        enablePentagonBokeh(): void;
        disablePentagonBokeh(): void;
        enableNoiseBlur(): void;
        disableNoiseBlur(): void;
        setHighlightsGain(amount: number): void;
        setHighlightsThreshold(amount: number): void;
        disableHighlights(): void;
        /**
         * Removes the internal pipeline assets and detaches the pipeline from the scene cameras
         */
        dispose(disableDepthRender?: boolean): void;
        private _createChromaticAberrationPostProcess(ratio);
        private _createHighlightsPostProcess(ratio);
        private _createDepthOfFieldPostProcess(ratio);
        private _createGrainTexture();
    }
}

declare module BABYLON {
    class SSAO2RenderingPipeline extends PostProcessRenderPipeline {
        /**
        * The PassPostProcess id in the pipeline that contains the original scene color
        */
        SSAOOriginalSceneColorEffect: string;
        /**
        * The SSAO PostProcess id in the pipeline
        */
        SSAORenderEffect: string;
        /**
        * The horizontal blur PostProcess id in the pipeline
        */
        SSAOBlurHRenderEffect: string;
        /**
        * The vertical blur PostProcess id in the pipeline
        */
        SSAOBlurVRenderEffect: string;
        /**
        * The PostProcess id in the pipeline that combines the SSAO-Blur output with the original scene color (SSAOOriginalSceneColorEffect)
        */
        SSAOCombineRenderEffect: string;
        /**
        * The output strength of the SSAO post-process. Default value is 1.0.
        */
        totalStrength: number;
        /**
        * Maximum depth value to still render AO. A smooth falloff makes the dimming more natural, so there will be no abrupt shading change.
        */
        maxZ: number;
        /**
        * In order to save performances, SSAO radius is clamped on close geometry. This ratio changes by how much
        */
        minZAspect: number;
        /**
        * Number of samples used for the SSAO calculations. Default value is 8
        */
        private _samples;
        /**
         * Ratio object used for SSAO ratio and blur ratio
         */
        private _ratio;
        /**
        * Dynamically generated sphere sampler.
        */
        private _sampleSphere;
        /**
        * Blur filter offsets
        */
        private _samplerOffsets;
        samples: number;
        /**
        * Are we using bilateral blur ?
        */
        private _expensiveBlur;
        expensiveBlur: boolean;
        /**
        * The radius around the analyzed pixel used by the SSAO post-process. Default value is 2.0
        */
        radius: number;
        /**
        * The base color of the SSAO post-process
        * The final result is "base + ssao" between [0, 1]
        */
        base: number;
        /**
        *  Support test.
        */
        static readonly IsSupported: boolean;
        private _scene;
        private _depthTexture;
        private _normalTexture;
        private _randomTexture;
        private _originalColorPostProcess;
        private _ssaoPostProcess;
        private _blurHPostProcess;
        private _blurVPostProcess;
        private _ssaoCombinePostProcess;
        private _firstUpdate;
        /**
         * @constructor
         * @param {string} name - The rendering pipeline name
         * @param {BABYLON.Scene} scene - The scene linked to this pipeline
         * @param {any} ratio - The size of the postprocesses. Can be a number shared between passes or an object for more precision: { ssaoRatio: 0.5, blurRatio: 1.0 }
         * @param {BABYLON.Camera[]} cameras - The array of cameras that the rendering pipeline will be attached to
         */
        constructor(name: string, scene: Scene, ratio: any, cameras?: Camera[]);
        /**
         * Removes the internal pipeline assets and detatches the pipeline from the scene cameras
         */
        dispose(disableGeometryBufferRenderer?: boolean): void;
        private _createBlurPostProcess(ssaoRatio, blurRatio);
        _rebuild(): void;
        private _generateHemisphere();
        private _createSSAOPostProcess(ratio);
        private _createSSAOCombinePostProcess(ratio);
        private _createRandomTexture();
        /**
         * Serialize the rendering pipeline (Used when exporting)
         * @returns the serialized object
         */
        serialize(): any;
        /**
         * Parse the serialized pipeline
         * @param source Source pipeline.
         * @param scene The scene to load the pipeline to.
         * @param rootUrl The URL of the serialized pipeline.
         * @returns An instantiated pipeline from the serialized object.
         */
        static Parse(source: any, scene: Scene, rootUrl: string): SSAO2RenderingPipeline;
    }
}

declare module BABYLON {
    class SSAORenderingPipeline extends PostProcessRenderPipeline {
        /**
        * The PassPostProcess id in the pipeline that contains the original scene color
        */
        SSAOOriginalSceneColorEffect: string;
        /**
        * The SSAO PostProcess id in the pipeline
        */
        SSAORenderEffect: string;
        /**
        * The horizontal blur PostProcess id in the pipeline
        */
        SSAOBlurHRenderEffect: string;
        /**
        * The vertical blur PostProcess id in the pipeline
        */
        SSAOBlurVRenderEffect: string;
        /**
        * The PostProcess id in the pipeline that combines the SSAO-Blur output with the original scene color (SSAOOriginalSceneColorEffect)
        */
        SSAOCombineRenderEffect: string;
        /**
        * The output strength of the SSAO post-process. Default value is 1.0.
        */
        totalStrength: number;
        /**
        * The radius around the analyzed pixel used by the SSAO post-process. Default value is 0.0006
        */
        radius: number;
        /**
        * Related to fallOff, used to interpolate SSAO samples (first interpolate function input) based on the occlusion difference of each pixel
        * Must not be equal to fallOff and superior to fallOff.
        * Default value is 0.975
        */
        area: number;
        /**
        * Related to area, used to interpolate SSAO samples (second interpolate function input) based on the occlusion difference of each pixel
        * Must not be equal to area and inferior to area.
        * Default value is 0.0
        */
        fallOff: number;
        /**
        * The base color of the SSAO post-process
        * The final result is "base + ssao" between [0, 1]
        */
        base: number;
        private _scene;
        private _depthTexture;
        private _randomTexture;
        private _originalColorPostProcess;
        private _ssaoPostProcess;
        private _blurHPostProcess;
        private _blurVPostProcess;
        private _ssaoCombinePostProcess;
        private _firstUpdate;
        /**
         * @constructor
         * @param {string} name - The rendering pipeline name
         * @param {BABYLON.Scene} scene - The scene linked to this pipeline
         * @param {any} ratio - The size of the postprocesses. Can be a number shared between passes or an object for more precision: { ssaoRatio: 0.5, combineRatio: 1.0 }
         * @param {BABYLON.Camera[]} cameras - The array of cameras that the rendering pipeline will be attached to
         */
        constructor(name: string, scene: Scene, ratio: any, cameras?: Camera[]);
        /**
         * Removes the internal pipeline assets and detatches the pipeline from the scene cameras
         */
        dispose(disableDepthRender?: boolean): void;
        private _createBlurPostProcess(ratio);
        _rebuild(): void;
        private _createSSAOPostProcess(ratio);
        private _createSSAOCombinePostProcess(ratio);
        private _createRandomTexture();
    }
}

declare module BABYLON {
    class StandardRenderingPipeline extends PostProcessRenderPipeline implements IDisposable, IAnimatable {
        /**
        * Public members
        */
        originalPostProcess: Nullable<PostProcess>;
        downSampleX4PostProcess: Nullable<PostProcess>;
        brightPassPostProcess: Nullable<PostProcess>;
        blurHPostProcesses: PostProcess[];
        blurVPostProcesses: PostProcess[];
        textureAdderPostProcess: Nullable<PostProcess>;
        volumetricLightPostProcess: Nullable<PostProcess>;
        volumetricLightSmoothXPostProcess: Nullable<BlurPostProcess>;
        volumetricLightSmoothYPostProcess: Nullable<BlurPostProcess>;
        volumetricLightMergePostProces: Nullable<PostProcess>;
        volumetricLightFinalPostProcess: Nullable<PostProcess>;
        luminancePostProcess: Nullable<PostProcess>;
        luminanceDownSamplePostProcesses: PostProcess[];
        hdrPostProcess: Nullable<PostProcess>;
        textureAdderFinalPostProcess: Nullable<PostProcess>;
        lensFlareFinalPostProcess: Nullable<PostProcess>;
        hdrFinalPostProcess: Nullable<PostProcess>;
        lensFlarePostProcess: Nullable<PostProcess>;
        lensFlareComposePostProcess: Nullable<PostProcess>;
        motionBlurPostProcess: Nullable<PostProcess>;
        depthOfFieldPostProcess: Nullable<PostProcess>;
        brightThreshold: number;
        blurWidth: number;
        horizontalBlur: boolean;
        exposure: number;
        lensTexture: Nullable<Texture>;
        volumetricLightCoefficient: number;
        volumetricLightPower: number;
        volumetricLightBlurScale: number;
        sourceLight: Nullable<SpotLight | DirectionalLight>;
        hdrMinimumLuminance: number;
        hdrDecreaseRate: number;
        hdrIncreaseRate: number;
        lensColorTexture: Nullable<Texture>;
        lensFlareStrength: number;
        lensFlareGhostDispersal: number;
        lensFlareHaloWidth: number;
        lensFlareDistortionStrength: number;
        lensStarTexture: Nullable<Texture>;
        lensFlareDirtTexture: Nullable<Texture>;
        depthOfFieldDistance: number;
        depthOfFieldBlurWidth: number;
        motionStrength: number;
        animations: Animation[];
        /**
        * Private members
        */
        private _scene;
        private _currentDepthOfFieldSource;
        private _basePostProcess;
        private _hdrCurrentLuminance;
        private _floatTextureType;
        private _ratio;
        private _bloomEnabled;
        private _depthOfFieldEnabled;
        private _vlsEnabled;
        private _lensFlareEnabled;
        private _hdrEnabled;
        private _motionBlurEnabled;
        private _motionBlurSamples;
        private _volumetricLightStepsCount;
        BloomEnabled: boolean;
        DepthOfFieldEnabled: boolean;
        LensFlareEnabled: boolean;
        HDREnabled: boolean;
        VLSEnabled: boolean;
        MotionBlurEnabled: boolean;
        volumetricLightStepsCount: number;
        motionBlurSamples: number;
        /**
         * @constructor
         * @param {string} name - The rendering pipeline name
         * @param {BABYLON.Scene} scene - The scene linked to this pipeline
         * @param {any} ratio - The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)
         * @param {BABYLON.PostProcess} originalPostProcess - the custom original color post-process. Must be "reusable". Can be null.
         * @param {BABYLON.Camera[]} cameras - The array of cameras that the rendering pipeline will be attached to
         */
        constructor(name: string, scene: Scene, ratio: number, originalPostProcess?: Nullable<PostProcess>, cameras?: Camera[]);
        private _buildPipeline();
        private _createDownSampleX4PostProcess(scene, ratio);
        private _createBrightPassPostProcess(scene, ratio);
        private _createBlurPostProcesses(scene, ratio, indice, blurWidthKey?);
        private _createTextureAdderPostProcess(scene, ratio);
        private _createVolumetricLightPostProcess(scene, ratio);
        private _createLuminancePostProcesses(scene, textureType);
        private _createHdrPostProcess(scene, ratio);
        private _createLensFlarePostProcess(scene, ratio);
        private _createDepthOfFieldPostProcess(scene, ratio);
        private _createMotionBlurPostProcess(scene, ratio);
        private _getDepthTexture();
        private _disposePostProcesses();
        /**
         * Dispose of the pipeline and stop all post processes
         */
        dispose(): void;
        /**
         * Serialize the rendering pipeline (Used when exporting)
         * @returns the serialized object
         */
        serialize(): any;
        /**
         * Parse the serialized pipeline
         * @param source Source pipeline.
         * @param scene The scene to load the pipeline to.
         * @param rootUrl The URL of the serialized pipeline.
         * @returns An instantiated pipeline from the serialized object.
         */
        static Parse(source: any, scene: Scene, rootUrl: string): StandardRenderingPipeline;
        static LuminanceSteps: number;
    }
}
