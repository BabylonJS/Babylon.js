{"version":3,"sources":["webpack://BABYLONJS/serializers/src/webpack/universalModuleDefinition","webpack://BABYLONJS/serializers/src/webpack/bootstrap","webpack://BABYLONJS/node_modules/tslib/tslib.es6.js","webpack://BABYLONJS/serializers/src/(webpack)/buildin/global.js","webpack://BABYLONJS/serializers/src/OBJ/index.ts","webpack://BABYLONJS/serializers/src/OBJ/objSerializer.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/Extensions/KHR_lights_punctual.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/Extensions/KHR_materials_sheen.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/Extensions/KHR_texture_transform.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/Extensions/index.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/glTFAnimation.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/glTFData.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/glTFExporter.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/glTFExporterExtension.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/glTFMaterialExporter.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/glTFSerializer.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/glTFUtilities.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/index.ts","webpack://BABYLONJS/serializers/src/glTF/2.0/shaders/textureTransform.fragment.ts","webpack://BABYLONJS/serializers/src/glTF/glTFFileExporter.ts","webpack://BABYLONJS/serializers/src/glTF/index.ts","webpack://BABYLONJS/serializers/src/index.ts","webpack://BABYLONJS/serializers/src/legacy/legacy-glTF2Serializer.ts","webpack://BABYLONJS/serializers/src/legacy/legacy-objSerializer.ts","webpack://BABYLONJS/serializers/src/legacy/legacy-stlSerializer.ts","webpack://BABYLONJS/serializers/src/legacy/legacy.ts","webpack://BABYLONJS/serializers/src/stl/index.ts","webpack://BABYLONJS/serializers/src/stl/stlSerializer.ts","webpack://BABYLONJS/serializers/src/external {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}"],"names":[],"mappings":"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","file":"babylonjs.serializers.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-serializers\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-serializers\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"SERIALIZERS\"] = factory(root[\"BABYLON\"]);\n})((typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : this), function(__WEBPACK_EXTERNAL_MODULE_babylonjs_Maths_math_vector__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./legacy/legacy.ts\");\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","export * from \"./objSerializer\";","\nimport { Nullable } from \"babylonjs/types\";\nimport { Matrix } from \"babylonjs/Maths/math.vector\";\nimport { Tools } from \"babylonjs/Misc/tools\";\nimport { StandardMaterial } from \"babylonjs/Materials/standardMaterial\";\nimport { Geometry } from \"babylonjs/Meshes/geometry\";\nimport { Mesh } from \"babylonjs/Meshes/mesh\";\n\n/**\n * Class for generating OBJ data from a Babylon scene.\n */\nexport class OBJExport {\n    /**\n     * Exports the geometry of a Mesh array in .OBJ file format (text)\n     * @param mesh defines the list of meshes to serialize\n     * @param materials defines if materials should be exported\n     * @param matlibname defines the name of the associated mtl file\n     * @param globalposition defines if the exported positions are globals or local to the exported mesh\n     * @returns the OBJ content\n     */\n    public static OBJ(mesh: Mesh[], materials?: boolean, matlibname?: string, globalposition?: boolean): string {\n        const output: string[] = [];\n        let v = 1;\n        if (materials) {\n            if (!matlibname) {\n                matlibname = 'mat';\n            }\n            output.push(\"mtllib \" + matlibname + \".mtl\");\n        }\n        for (let j = 0; j < mesh.length; j++) {\n            output.push(\"g object\" + j);\n            output.push(\"o object_\" + j);\n\n            //Uses the position of the item in the scene, to the file (this back to normal in the end)\n            let lastMatrix: Nullable<Matrix> = null;\n            if (globalposition) {\n                var newMatrix = Matrix.Translation(mesh[j].position.x, mesh[j].position.y, mesh[j].position.z);\n                lastMatrix = Matrix.Translation(-(mesh[j].position.x), -(mesh[j].position.y), -(mesh[j].position.z));\n                mesh[j].bakeTransformIntoVertices(newMatrix);\n            }\n\n            //TODO: submeshes (groups)\n            //TODO: smoothing groups (s 1, s off);\n            if (materials) {\n                let mat = mesh[j].material;\n\n                if (mat) {\n                    output.push(\"usemtl \" + mat.id);\n                }\n            }\n            const g: Nullable<Geometry> = mesh[j].geometry;\n\n            if (!g) {\n                Tools.Warn(\"No geometry is present on the mesh\");\n                continue;\n            }\n\n            const trunkVerts = g.getVerticesData('position');\n            const trunkNormals = g.getVerticesData('normal');\n            const trunkUV = g.getVerticesData('uv');\n            const trunkFaces = g.getIndices();\n            var curV = 0;\n\n            if (!trunkVerts || !trunkFaces) {\n                Tools.Warn(\"There are no position vertices or indices on the mesh!\");\n                continue;\n            }\n\n            for (var i = 0; i < trunkVerts.length; i += 3) {\n                output.push(\"v \" + trunkVerts[i] + \" \" + trunkVerts[i + 1] + \" \" + trunkVerts[i + 2]);\n                curV++;\n            }\n\n            if (trunkNormals != null) {\n                for (i = 0; i < trunkNormals.length; i += 3) {\n                    output.push(\"vn \" + trunkNormals[i] + \" \" + trunkNormals[i + 1] + \" \" + trunkNormals[i + 2]);\n                }\n            }\n            if (trunkUV != null) {\n\n                for (i = 0; i < trunkUV.length; i += 2) {\n                    output.push(\"vt \" + trunkUV[i] + \" \" + trunkUV[i + 1]);\n                }\n            }\n\n            for (i = 0; i < trunkFaces.length; i += 3) {\n                const indices = [String(trunkFaces[i + 2] + v), String(trunkFaces[i + 1] + v), String(trunkFaces[i] + v)];\n                const blanks: string[] = [\"\", \"\", \"\"];\n\n                const facePositions = indices;\n                const faceUVs = trunkUV != null ? indices : blanks;\n                const faceNormals = trunkNormals != null ? indices : blanks;\n\n                output.push(\n                    \"f \" + facePositions[0] + \"/\" + faceUVs[0] + \"/\" + faceNormals[0] +\n                    \" \" + facePositions[1] + \"/\" + faceUVs[1] + \"/\" + faceNormals[1] +\n                    \" \" + facePositions[2] + \"/\" + faceUVs[2] + \"/\" + faceNormals[2]\n                );\n            }\n            //back de previous matrix, to not change the original mesh in the scene\n            if (globalposition && lastMatrix) {\n                mesh[j].bakeTransformIntoVertices(lastMatrix);\n            }\n            v += curV;\n        }\n        const text: string = output.join(\"\\n\");\n        return (text);\n    }\n\n    /**\n     * Exports the material(s) of a mesh in .MTL file format (text)\n     * @param mesh defines the mesh to extract the material from\n     * @returns the mtl content\n     */\n    //TODO: Export the materials of mesh array\n    public static MTL(mesh: Mesh): string {\n        var output = [];\n        var m = <StandardMaterial>mesh.material;\n        output.push(\"newmtl mat1\");\n        output.push(\"  Ns \" + m.specularPower.toFixed(4));\n        output.push(\"  Ni 1.5000\");\n        output.push(\"  d \" + m.alpha.toFixed(4));\n        output.push(\"  Tr 0.0000\");\n        output.push(\"  Tf 1.0000 1.0000 1.0000\");\n        output.push(\"  illum 2\");\n        output.push(\"  Ka \" + m.ambientColor.r.toFixed(4) + \" \" + m.ambientColor.g.toFixed(4) + \" \" + m.ambientColor.b.toFixed(4));\n        output.push(\"  Kd \" + m.diffuseColor.r.toFixed(4) + \" \" + m.diffuseColor.g.toFixed(4) + \" \" + m.diffuseColor.b.toFixed(4));\n        output.push(\"  Ks \" + m.specularColor.r.toFixed(4) + \" \" + m.specularColor.g.toFixed(4) + \" \" + m.specularColor.b.toFixed(4));\n        output.push(\"  Ke \" + m.emissiveColor.r.toFixed(4) + \" \" + m.emissiveColor.g.toFixed(4) + \" \" + m.emissiveColor.b.toFixed(4));\n\n        //TODO: uv scale, offset, wrap\n        //TODO: UV mirrored in Blender? second UV channel? lightMap? reflection textures?\n        var uvscale = \"\";\n\n        if (m.ambientTexture) {\n            output.push(\"  map_Ka \" + uvscale + m.ambientTexture.name);\n        }\n\n        if (m.diffuseTexture) {\n            output.push(\"  map_Kd \" + uvscale + m.diffuseTexture.name);\n            //TODO: alpha testing, opacity in diffuse texture alpha channel (diffuseTexture.hasAlpha -> map_d)\n        }\n\n        if (m.specularTexture) {\n            output.push(\"  map_Ks \" + uvscale + m.specularTexture.name);\n            /* TODO: glossiness = specular highlight component is in alpha channel of specularTexture. (???)\n            if (m.useGlossinessFromSpecularMapAlpha)  {\n                output.push(\"  map_Ns \"+uvscale + m.specularTexture.name);\n            }\n            */\n        }\n\n        /* TODO: emissive texture not in .MAT format (???)\n        if (m.emissiveTexture) {\n            output.push(\"  map_d \"+uvscale+m.emissiveTexture.name);\n        }\n        */\n\n        if (m.bumpTexture) {\n            output.push(\"  map_bump -imfchan z \" + uvscale + m.bumpTexture.name);\n        }\n\n        if (m.opacityTexture) {\n            output.push(\"  map_d \" + uvscale + m.opacityTexture.name);\n        }\n\n        var text = output.join(\"\\n\");\n        return (text);\n    }\n}\n","import { SpotLight } from \"babylonjs/Lights/spotLight\";\nimport { Nullable } from \"babylonjs/types\";\nimport { Vector3, Quaternion, TmpVectors, Matrix } from \"babylonjs/Maths/math.vector\";\nimport { Color3 } from \"babylonjs/Maths/math.color\";\nimport { Light } from \"babylonjs/Lights/light\";\nimport { DirectionalLight } from \"babylonjs/Lights/directionalLight\";\nimport { Node } from \"babylonjs/node\";\nimport { ShadowLight } from \"babylonjs/Lights/shadowLight\";\nimport { IChildRootProperty } from \"babylonjs-gltf2interface\";\nimport { INode } from \"babylonjs-gltf2interface\";\nimport { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\nimport { _Exporter } from \"../glTFExporter\";\nimport { Logger } from \"babylonjs/Misc/logger\";\nimport { _GLTFUtilities } from \"../glTFUtilities\";\n\nconst NAME = \"KHR_lights_punctual\";\n\nenum LightType {\n    DIRECTIONAL = \"directional\",\n    POINT = \"point\",\n    SPOT = \"spot\"\n}\n\ninterface ILightReference {\n    light: number;\n}\n\ninterface ILight extends IChildRootProperty {\n    type: LightType;\n    color?: number[];\n    intensity?: number;\n    range?: number;\n    spot?: {\n        innerConeAngle?: number;\n        outerConeAngle?: number;\n    };\n}\n\ninterface ILights {\n    lights: ILight[];\n}\n\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md)\n */\nexport class KHR_lights_punctual implements IGLTFExporterExtensionV2 {\n    /** The name of this extension. */\n    public readonly name = NAME;\n\n    /** Defines whether this extension is enabled. */\n    public enabled = true;\n\n    /** Defines whether this extension is required */\n    public required = false;\n\n    /** Reference to the glTF exporter */\n    private _exporter: _Exporter;\n\n    private _lights: ILights;\n\n    /** @hidden */\n    constructor(exporter: _Exporter) {\n        this._exporter = exporter;\n    }\n\n    /** @hidden */\n    public dispose() {\n        delete this._lights;\n    }\n\n    /** @hidden */\n    public get wasUsed() {\n        return !!this._lights;\n    }\n\n    /** @hidden */\n    public onExporting(): void {\n        this._exporter!._glTF.extensions![NAME] = this._lights;\n    }\n    /**\n     * Define this method to modify the default behavior when exporting a node\n     * @param context The context when exporting the node\n     * @param node glTF node\n     * @param babylonNode BabylonJS node\n     * @param nodeMap Node mapping of unique id to glTF node index\n     * @returns nullable INode promise\n     */\n    public postExportNodeAsync(context: string, node: Nullable<INode>, babylonNode: Node, nodeMap?: {[key: number]: number}): Promise<Nullable<INode>> {\n        return new Promise((resolve, reject) => {\n            if (node && babylonNode instanceof ShadowLight) {\n                const babylonLight: ShadowLight = babylonNode;\n                let light: ILight;\n\n                const lightType = (\n                    babylonLight.getTypeID() == Light.LIGHTTYPEID_POINTLIGHT ? LightType.POINT : (\n                        babylonLight.getTypeID() == Light.LIGHTTYPEID_DIRECTIONALLIGHT ? LightType.DIRECTIONAL : (\n                            babylonLight.getTypeID() == Light.LIGHTTYPEID_SPOTLIGHT ? LightType.SPOT : null\n                        )));\n                if (lightType == null) {\n                    Logger.Warn(`${context}: Light ${babylonLight.name} is not supported in ${NAME}`);\n                }\n                else {\n                    const lightPosition = babylonLight.position.clone();\n                    let convertToRightHandedSystem = this._exporter._convertToRightHandedSystemMap[babylonNode.uniqueId];\n                    if (!lightPosition.equals(Vector3.Zero())) {\n                        if (convertToRightHandedSystem) {\n                            _GLTFUtilities._GetRightHandedPositionVector3FromRef(lightPosition);\n                        }\n                        node.translation = lightPosition.asArray();\n                    }\n                    if (lightType !== LightType.POINT) {\n                        const localAxis = babylonLight.direction;\n                        const yaw = -Math.atan2(localAxis.z * (this._exporter._babylonScene.useRightHandedSystem ? -1 : 1), localAxis.x) + Math.PI / 2;\n                        const len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);\n                        const pitch = -Math.atan2(localAxis.y, len);\n                        const lightRotationQuaternion = Quaternion.RotationYawPitchRoll(yaw, pitch, 0);\n                        if (convertToRightHandedSystem) {\n                            _GLTFUtilities._GetRightHandedQuaternionFromRef(lightRotationQuaternion);\n                        }\n                        if (!lightRotationQuaternion.equals(Quaternion.Identity())) {\n                            node.rotation = lightRotationQuaternion.asArray();\n                        }\n                    }\n\n                    if (babylonLight.falloffType !== Light.FALLOFF_GLTF) {\n                        Logger.Warn(`${context}: Light falloff for ${babylonLight.name} does not match the ${NAME} specification!`);\n                    }\n                    light = {\n                        type: lightType\n                    };\n                    if (!babylonLight.diffuse.equals(Color3.White())) {\n                        light.color = babylonLight.diffuse.asArray();\n                    }\n                    if (babylonLight.intensity !== 1.0) {\n                        light.intensity = babylonLight.intensity;\n                    }\n                    if (babylonLight.range !== Number.MAX_VALUE) {\n                        light.range = babylonLight.range;\n                    }\n\n                    if (lightType === LightType.SPOT) {\n                        const babylonSpotLight = babylonLight as SpotLight;\n                        if (babylonSpotLight.angle !== Math.PI / 2.0) {\n                            if (light.spot == null) {\n                                light.spot = {};\n                            }\n                            light.spot.outerConeAngle = babylonSpotLight.angle / 2.0;\n                        }\n                        if (babylonSpotLight.innerAngle !== 0) {\n                            if (light.spot == null) {\n                                light.spot = {};\n                            }\n                            light.spot.innerConeAngle = babylonSpotLight.innerAngle / 2.0;\n                        }\n                    }\n\n                    if (this._lights == null) {\n                        this._lights = {\n                            lights: []\n                        };\n                    }\n\n                    this._lights.lights.push(light);\n\n                    const lightReference: ILightReference = {\n                        light: this._lights.lights.length - 1\n                    };\n\n                    // Avoid duplicating the Light's parent node if possible.\n                    let parentBabylonNode = babylonNode.parent;\n                    if (parentBabylonNode && parentBabylonNode.getChildren().length == 1) {\n                        let parentNode = this._exporter._nodes[nodeMap![parentBabylonNode.uniqueId]];\n                        if (parentNode) {\n                            let parentNodeLocalMatrix = TmpVectors.Matrix[0];\n                            let parentInvertNodeLocalMatrix = TmpVectors.Matrix[1];\n                            let parentNodeLocalTranslation = parentNode.translation ? new Vector3(parentNode.translation[0], parentNode.translation[1], parentNode.translation[2]) : Vector3.Zero();\n                            let parentNodeLocalRotation = parentNode.rotation ? new Quaternion(parentNode.rotation[0], parentNode.rotation[1], parentNode.rotation[2], parentNode.rotation[3]) : Quaternion.Identity();\n                            let parentNodeLocalScale = parentNode.scale ? new Vector3(parentNode.scale[0], parentNode.scale[1], parentNode.scale[2]) : Vector3.One();\n\n                            Matrix.ComposeToRef(parentNodeLocalScale, parentNodeLocalRotation, parentNodeLocalTranslation, parentNodeLocalMatrix);\n                            parentNodeLocalMatrix.invertToRef(parentInvertNodeLocalMatrix);\n\n                            // Convert light local matrix to local matrix relative to grandparent, facing -Z\n                            let lightLocalMatrix = TmpVectors.Matrix[2];\n                            let nodeLocalTranslation = node.translation ? new Vector3(node.translation[0], node.translation[1], node.translation[2]) : Vector3.Zero();\n\n                            // Undo directional light positional offset\n                            if (babylonLight instanceof DirectionalLight) {\n                                nodeLocalTranslation.subtractInPlace(this._exporter._babylonScene.useRightHandedSystem ? babylonLight.direction : _GLTFUtilities._GetRightHandedPositionVector3(babylonLight.direction));\n                            }\n                            let nodeLocalRotation = this._exporter._babylonScene.useRightHandedSystem ? Quaternion.Identity() : new Quaternion(0, 1, 0, 0);\n                            if (node.rotation) {\n                                nodeLocalRotation.multiplyInPlace(new Quaternion(node.rotation[0], node.rotation[1], node.rotation[2], node.rotation[3]));\n                            }\n                            let nodeLocalScale = node.scale ? new Vector3(node.scale[0], node.scale[1], node.scale[2]) : Vector3.One();\n\n                            Matrix.ComposeToRef(nodeLocalScale, nodeLocalRotation, nodeLocalTranslation, lightLocalMatrix);\n                            lightLocalMatrix.multiplyToRef(parentInvertNodeLocalMatrix, lightLocalMatrix);\n                            let parentNewScale = TmpVectors.Vector3[0];\n                            let parentNewRotationQuaternion = TmpVectors.Quaternion[0];\n                            let parentNewTranslation = TmpVectors.Vector3[1];\n\n                            lightLocalMatrix.decompose(parentNewScale, parentNewRotationQuaternion, parentNewTranslation);\n                            parentNode.scale = parentNewScale.asArray();\n                            parentNode.rotation = parentNewRotationQuaternion.asArray();\n                            parentNode.translation = parentNewTranslation.asArray();\n\n                            if (parentNode.extensions == null) {\n                                parentNode.extensions = {};\n                            }\n                            parentNode.extensions[NAME] = lightReference;\n\n                            // Do not export the original node\n                            resolve(undefined);\n                            return;\n                        }\n                    }\n\n                    if (node.extensions == null) {\n                        node.extensions = {};\n                    }\n\n                    node.extensions[NAME] = lightReference;\n                }\n            }\n            resolve(node);\n        });\n    }\n}\n\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_lights_punctual(exporter));","import { ITextureInfo, IMaterial } from \"babylonjs-gltf2interface\";\r\nimport { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\nimport { Material } from 'babylonjs/Materials/material';\r\nimport { PBRMaterial } from 'babylonjs/Materials/PBR/pbrMaterial';\r\nimport { Texture } from 'babylonjs/Materials/Textures/texture';\r\nimport { BaseTexture } from 'babylonjs/Materials/Textures/baseTexture';\r\nimport { Nullable } from 'babylonjs/types';\r\n\r\nconst NAME = \"KHR_materials_sheen\";\r\n\r\ninterface IKHR_materials_sheen {\r\n    intensityFactor: number;\r\n    colorFactor: number[];\r\n    colorIntensityTexture?: ITextureInfo;\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class KHR_materials_sheen implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /** Reference to the glTF exporter */\r\n    private _textureInfos: ITextureInfo[] = [];\r\n    private _exportedTextures: Nullable<BaseTexture>[] = [];\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: _Exporter) {\r\n    }\r\n\r\n    public dispose() {\r\n       this._textureInfos = [];\r\n       this._exportedTextures = [];\r\n    }\r\n\r\n    /** @hidden */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    private _getTextureIndex(babylonTexture: BaseTexture) {\r\n        let textureIndex = this._exportedTextures.indexOf(babylonTexture);\r\n\r\n        if (textureIndex === -1 && babylonTexture.reservedDataStore) {\r\n            textureIndex = this._exportedTextures.indexOf(babylonTexture.reservedDataStore.source);\r\n        }\r\n\r\n        return textureIndex;\r\n    }\r\n\r\n    public postExportTexture?(context: string, textureInfo: ITextureInfo, babylonTexture: Texture): void {\r\n        let textureIndex = this._getTextureIndex(babylonTexture);\r\n\r\n        if (textureIndex > -1) {\r\n            this._textureInfos[textureIndex] = textureInfo;\r\n        }\r\n    }\r\n\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        if (babylonMaterial instanceof PBRMaterial) {\r\n            if (babylonMaterial.sheen.isEnabled && babylonMaterial.sheen.texture) {\r\n                this._exportedTextures.push(babylonMaterial.sheen.texture);\r\n                return [babylonMaterial.sheen.texture];\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            if (babylonMaterial instanceof PBRMaterial) {\r\n                if (!babylonMaterial.sheen.isEnabled) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                if (node.extensions == null) {\r\n                    node.extensions = {};\r\n                }\r\n                const sheenInfo: IKHR_materials_sheen = {\r\n                    colorFactor: babylonMaterial.sheen.color.asArray(),\r\n                    intensityFactor: babylonMaterial.sheen.intensity\r\n                };\r\n\r\n                if (babylonMaterial.sheen.texture) {\r\n                    let textureIndex = this._getTextureIndex(babylonMaterial.sheen.texture);\r\n\r\n                    if (textureIndex > -1) {\r\n                        sheenInfo.colorIntensityTexture = this._textureInfos[textureIndex] ;\r\n                    }\r\n                }\r\n\r\n                node.extensions[NAME] = sheenInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_materials_sheen(exporter));","import { ImageMimeType, ITextureInfo } from \"babylonjs-gltf2interface\";\r\nimport { Tools } from \"babylonjs/Misc/tools\";\r\nimport { Texture } from \"babylonjs/Materials/Textures/texture\";\r\nimport { ProceduralTexture } from \"babylonjs/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport { Scene } from \"babylonjs/scene\";\r\n\r\nimport { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\n\r\nconst NAME = \"KHR_texture_transform\";\r\n\r\nimport \"../shaders/textureTransform.fragment\";\r\n\r\n/**\r\n * Interface for handling KHR texture transform\r\n * @hidden\r\n */\r\ninterface IKHRTextureTransform {\r\n    offset?: number[];\r\n    rotation?: number;\r\n    scale?: number[];\r\n    texCoord?: number;\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class KHR_texture_transform implements IGLTFExporterExtensionV2 {\r\n    private _recordedTextures: ProceduralTexture[] = [];\r\n\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /** Reference to the glTF exporter */\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: _Exporter) {\r\n    }\r\n\r\n    public dispose() {\r\n        for (var texture of this._recordedTextures) {\r\n            texture.dispose();\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportTexture?(context: string, textureInfo: ITextureInfo, babylonTexture: Texture): void {\r\n        if (babylonTexture && babylonTexture.uRotationCenter === 0 && babylonTexture.vRotationCenter === 0) {\r\n            let textureTransform: IKHRTextureTransform = {};\r\n            let transformIsRequired = false;\r\n\r\n            if (babylonTexture.uOffset !== 0 || babylonTexture.vOffset !== 0) {\r\n                textureTransform.offset = [babylonTexture.uOffset, babylonTexture.vOffset];\r\n                transformIsRequired = true;\r\n            }\r\n\r\n            if (babylonTexture.uScale !== 1 || babylonTexture.vScale !== 1) {\r\n                textureTransform.scale = [babylonTexture.uScale, babylonTexture.vScale];\r\n                transformIsRequired = true;\r\n            }\r\n\r\n            if (babylonTexture.wAng !== 0) {\r\n                textureTransform.rotation = babylonTexture.wAng;\r\n                transformIsRequired = true;\r\n            }\r\n\r\n            if (babylonTexture.coordinatesIndex !== 0) {\r\n                textureTransform.texCoord = babylonTexture.coordinatesIndex;\r\n                transformIsRequired = true;\r\n            }\r\n\r\n            if (!transformIsRequired) {\r\n                return;\r\n            }\r\n\r\n            this._wasUsed = true;\r\n            if (!textureInfo.extensions) {\r\n                textureInfo.extensions = {};\r\n            }\r\n            textureInfo.extensions[NAME] = textureTransform;\r\n        }\r\n    }\r\n\r\n    public preExportTextureAsync(context: string, babylonTexture: Texture, mimeType: ImageMimeType): Promise<Texture> {\r\n        return new Promise((resolve, reject) => {\r\n            const scene = babylonTexture.getScene();\r\n            if (!scene) {\r\n                reject(`${context}: \"scene\" is not defined for Babylon texture ${babylonTexture.name}!`);\r\n                return;\r\n            }\r\n\r\n            let transformIsRequired = false;\r\n\r\n            if (babylonTexture.uOffset !== 0 || babylonTexture.vOffset !== 0) {\r\n                transformIsRequired = true;\r\n            }\r\n\r\n            if (babylonTexture.uScale !== 1 || babylonTexture.vScale !== 1) {\r\n                transformIsRequired = true;\r\n            }\r\n\r\n            if (babylonTexture.wAng !== 0) {\r\n                transformIsRequired = true;\r\n            }\r\n\r\n            if (!transformIsRequired) {\r\n                resolve(babylonTexture);\r\n                return;\r\n            }\r\n\r\n            // Do we need to flatten the transform?\r\n            if (babylonTexture.uRotationCenter === 0 && babylonTexture.vRotationCenter === 0) {\r\n                resolve(babylonTexture);\r\n                return;\r\n            }\r\n\r\n            return this._textureTransformTextureAsync(babylonTexture, scene)\r\n                .then((proceduralTexture) => {\r\n                    resolve(proceduralTexture);\r\n                })\r\n                .catch((e) => {\r\n                    reject(e);\r\n                });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Transform the babylon texture by the offset, rotation and scale parameters using a procedural texture\r\n     * @param babylonTexture\r\n     * @param offset\r\n     * @param rotation\r\n     * @param scale\r\n     * @param scene\r\n     */\r\n    private _textureTransformTextureAsync(babylonTexture: Texture, scene: Scene): Promise<Texture> {\r\n        return new Promise((resolve) => {\r\n            const proceduralTexture = new ProceduralTexture(`${babylonTexture.name}`, babylonTexture.getSize(), \"textureTransform\", scene);\r\n            if (!proceduralTexture) {\r\n                Tools.Log(`Cannot create procedural texture for ${babylonTexture.name}!`);\r\n                resolve(babylonTexture);\r\n            }\r\n\r\n            proceduralTexture.reservedDataStore = {\r\n                hidden: true,\r\n                source: babylonTexture\r\n            };\r\n\r\n            this._recordedTextures.push(proceduralTexture);\r\n\r\n            proceduralTexture.coordinatesIndex = babylonTexture.coordinatesIndex;\r\n            proceduralTexture.setTexture(\"textureSampler\", babylonTexture);\r\n            proceduralTexture.setMatrix(\"textureTransformMat\", babylonTexture.getTextureMatrix());\r\n\r\n            // isReady trigger creation of effect if it doesnt exist yet\r\n            if (proceduralTexture.isReady()) {\r\n                proceduralTexture.render();\r\n                resolve(proceduralTexture);\r\n            } else {\r\n                proceduralTexture.getEffect().executeWhenCompiled(() => {\r\n                    proceduralTexture.render();\r\n                    resolve(proceduralTexture);\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_texture_transform(exporter));","export * from \"./KHR_texture_transform\";\r\nexport * from \"./KHR_lights_punctual\";\r\nexport * from \"./KHR_materials_sheen\";","import { AnimationSamplerInterpolation, AnimationChannelTargetPath, AccessorType, IAnimation, INode, IBufferView, IAccessor, IAnimationSampler, IAnimationChannel, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\nimport { Node } from \"babylonjs/node\";\r\nimport { Nullable } from \"babylonjs/types\";\r\nimport { Vector3, Quaternion } from \"babylonjs/Maths/math.vector\";\r\nimport { Tools } from \"babylonjs/Misc/tools\";\r\nimport { Animation } from \"babylonjs/Animations/animation\";\r\nimport { TransformNode } from \"babylonjs/Meshes/transformNode\";\r\nimport { Scene } from \"babylonjs/scene\";\r\n\r\nimport { _BinaryWriter } from \"./glTFExporter\";\r\nimport { _GLTFUtilities } from \"./glTFUtilities\";\r\nimport { IAnimationKey, AnimationKeyInterpolation } from 'babylonjs/Animations/animationKey';\r\n\r\n/**\r\n * @hidden\r\n * Interface to store animation data.\r\n */\r\nexport interface _IAnimationData {\r\n    /**\r\n     * Keyframe data.\r\n     */\r\n    inputs: number[];\r\n    /**\r\n     * Value data.\r\n     */\r\n    outputs: number[][];\r\n    /**\r\n     * Animation interpolation data.\r\n     */\r\n    samplerInterpolation: AnimationSamplerInterpolation;\r\n    /**\r\n     * Minimum keyframe value.\r\n     */\r\n    inputsMin: number;\r\n    /**\r\n     * Maximum keyframe value.\r\n     */\r\n    inputsMax: number;\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport interface _IAnimationInfo {\r\n    /**\r\n     * The target channel for the animation\r\n     */\r\n    animationChannelTargetPath: AnimationChannelTargetPath;\r\n    /**\r\n     * The glTF accessor type for the data.\r\n     */\r\n    dataAccessorType: AccessorType.VEC3 | AccessorType.VEC4;\r\n    /**\r\n     * Specifies if quaternions should be used.\r\n     */\r\n    useQuaternion: boolean;\r\n}\r\n\r\n/**\r\n * @hidden\r\n * Enum for handling in tangent and out tangent.\r\n */\r\nenum _TangentType {\r\n    /**\r\n     * Specifies that input tangents are used.\r\n     */\r\n    INTANGENT,\r\n    /**\r\n     * Specifies that output tangents are used.\r\n     */\r\n    OUTTANGENT\r\n}\r\n/**\r\n * @hidden\r\n * Utility class for generating glTF animation data from BabylonJS.\r\n */\r\nexport class _GLTFAnimation {\r\n    /**\r\n     * @ignore\r\n     *\r\n     * Creates glTF channel animation from BabylonJS animation.\r\n     * @param babylonTransformNode - BabylonJS mesh.\r\n     * @param animation - animation.\r\n     * @param animationChannelTargetPath - The target animation channel.\r\n     * @param convertToRightHandedSystem - Specifies if the values should be converted to right-handed.\r\n     * @param useQuaternion - Specifies if quaternions are used.\r\n     * @returns nullable IAnimationData\r\n     */\r\n    public static _CreateNodeAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, convertToRightHandedSystem: boolean, useQuaternion: boolean, animationSampleRate: number): Nullable<_IAnimationData> {\r\n        const inputs: number[] = [];\r\n        const outputs: number[][] = [];\r\n        const keyFrames = animation.getKeys();\r\n        const minMaxKeyFrames = _GLTFAnimation.calculateMinMaxKeyFrames(keyFrames);\r\n        const interpolationOrBake = _GLTFAnimation._DeduceInterpolation(keyFrames, animationChannelTargetPath, useQuaternion);\r\n        const frameDelta = minMaxKeyFrames.max - minMaxKeyFrames.min;\r\n\r\n        const interpolation = interpolationOrBake.interpolationType;\r\n        const shouldBakeAnimation = interpolationOrBake.shouldBakeAnimation;\r\n\r\n        if (shouldBakeAnimation) {\r\n            _GLTFAnimation._CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minMaxKeyFrames.min, minMaxKeyFrames.max, animation.framePerSecond, animationSampleRate, inputs, outputs, minMaxKeyFrames, convertToRightHandedSystem, useQuaternion);\r\n        }\r\n        else {\r\n            if (interpolation === AnimationSamplerInterpolation.LINEAR || interpolation === AnimationSamplerInterpolation.STEP) {\r\n                _GLTFAnimation._CreateLinearOrStepAnimation(babylonTransformNode, animation, animationChannelTargetPath, frameDelta, inputs, outputs, convertToRightHandedSystem, useQuaternion);\r\n\r\n            }\r\n            else if (interpolation === AnimationSamplerInterpolation.CUBICSPLINE) {\r\n                _GLTFAnimation._CreateCubicSplineAnimation(babylonTransformNode, animation, animationChannelTargetPath, frameDelta, inputs, outputs, convertToRightHandedSystem, useQuaternion);\r\n            }\r\n            else {\r\n                _GLTFAnimation._CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minMaxKeyFrames.min, minMaxKeyFrames.max, animation.framePerSecond, animationSampleRate, inputs, outputs, minMaxKeyFrames, convertToRightHandedSystem, useQuaternion);\r\n            }\r\n        }\r\n\r\n        if (inputs.length && outputs.length) {\r\n            const result: _IAnimationData = {\r\n                inputs: inputs,\r\n                outputs: outputs,\r\n                samplerInterpolation: interpolation,\r\n                inputsMin: shouldBakeAnimation ? minMaxKeyFrames.min : Tools.FloatRound(minMaxKeyFrames.min / animation.framePerSecond),\r\n                inputsMax: shouldBakeAnimation ? minMaxKeyFrames.max : Tools.FloatRound(minMaxKeyFrames.max / animation.framePerSecond)\r\n            };\r\n\r\n            return result;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private static _DeduceAnimationInfo(animation: Animation): Nullable<_IAnimationInfo> {\r\n        let animationChannelTargetPath: Nullable<AnimationChannelTargetPath> = null;\r\n        let dataAccessorType = AccessorType.VEC3;\r\n        let useQuaternion: boolean = false;\r\n        let property = animation.targetProperty.split('.');\r\n        switch (property[0]) {\r\n            case 'scaling': {\r\n                animationChannelTargetPath = AnimationChannelTargetPath.SCALE;\r\n                break;\r\n            }\r\n            case 'position': {\r\n                animationChannelTargetPath = AnimationChannelTargetPath.TRANSLATION;\r\n                break;\r\n            }\r\n            case 'rotation': {\r\n                dataAccessorType = AccessorType.VEC4;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.ROTATION;\r\n                break;\r\n            }\r\n            case 'rotationQuaternion': {\r\n                dataAccessorType = AccessorType.VEC4;\r\n                useQuaternion = true;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.ROTATION;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported animatable property ${property[0]}`);\r\n            }\r\n        }\r\n        if (animationChannelTargetPath) {\r\n            return { animationChannelTargetPath: animationChannelTargetPath, dataAccessorType: dataAccessorType, useQuaternion: useQuaternion };\r\n        }\r\n        else {\r\n            Tools.Error('animation channel target path and data accessor type could be deduced');\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create node animations from the transform node animations\r\n     * @param babylonNode\r\n     * @param runtimeGLTFAnimation\r\n     * @param idleGLTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param binaryWriter\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param convertToRightHandedSystem\r\n     * @param animationSampleRate\r\n     */\r\n    public static _CreateNodeAnimationFromNodeAnimations(babylonNode: Node, runtimeGLTFAnimation: IAnimation, idleGLTFAnimations: IAnimation[], nodeMap: { [key: number]: number }, nodes: INode[], binaryWriter: _BinaryWriter, bufferViews: IBufferView[], accessors: IAccessor[], convertToRightHandedSystem: boolean, animationSampleRate: number) {\r\n        let glTFAnimation: IAnimation;\r\n        if (babylonNode instanceof TransformNode) {\r\n            if (babylonNode.animations) {\r\n                for (let animation of babylonNode.animations) {\r\n                    let animationInfo = _GLTFAnimation._DeduceAnimationInfo(animation);\r\n                    if (animationInfo) {\r\n                        glTFAnimation = {\r\n                            name: animation.name,\r\n                            samplers: [],\r\n                            channels: []\r\n                        };\r\n                        _GLTFAnimation.AddAnimation(`${animation.name}`,\r\n                            animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation,\r\n                            babylonNode,\r\n                            animation,\r\n                            animationInfo.dataAccessorType,\r\n                            animationInfo.animationChannelTargetPath,\r\n                            nodeMap,\r\n                            binaryWriter,\r\n                            bufferViews,\r\n                            accessors,\r\n                            convertToRightHandedSystem,\r\n                            animationInfo.useQuaternion,\r\n                            animationSampleRate\r\n                        );\r\n                        if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {\r\n                            idleGLTFAnimations.push(glTFAnimation);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create node animations from the animation groups\r\n     * @param babylonScene\r\n     * @param glTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param binaryWriter\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param convertToRightHandedSystemMap\r\n     * @param animationSampleRate\r\n     */\r\n    public static _CreateNodeAnimationFromAnimationGroups(babylonScene: Scene, glTFAnimations: IAnimation[], nodeMap: { [key: number]: number }, nodes: INode[], binaryWriter: _BinaryWriter, bufferViews: IBufferView[], accessors: IAccessor[], convertToRightHandedSystemMap: { [nodeId: number]: boolean }, animationSampleRate: number) {\r\n        let glTFAnimation: IAnimation;\r\n        if (babylonScene.animationGroups) {\r\n            let animationGroups = babylonScene.animationGroups;\r\n\r\n            for (let animationGroup of animationGroups) {\r\n                glTFAnimation = {\r\n                    name: animationGroup.name,\r\n                    channels: [],\r\n                    samplers: []\r\n                };\r\n                for (let targetAnimation of animationGroup.targetedAnimations) {\r\n                    let target = targetAnimation.target;\r\n                    let animation = targetAnimation.animation;\r\n                    if (target instanceof TransformNode || target.length === 1 && target[0] instanceof TransformNode) {\r\n                        let animationInfo = _GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);\r\n                        if (animationInfo) {\r\n                            let babylonTransformNode = target instanceof TransformNode ? target as TransformNode : target[0] as TransformNode;\r\n                            let convertToRightHandedSystem = convertToRightHandedSystemMap[babylonTransformNode.uniqueId];\r\n                            _GLTFAnimation.AddAnimation(`${animation.name}`,\r\n                                glTFAnimation,\r\n                                babylonTransformNode,\r\n                                animation,\r\n                                animationInfo.dataAccessorType,\r\n                                animationInfo.animationChannelTargetPath,\r\n                                nodeMap,\r\n                                binaryWriter,\r\n                                bufferViews,\r\n                                accessors,\r\n                                convertToRightHandedSystem,\r\n                                animationInfo.useQuaternion,\r\n                                animationSampleRate\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n                if (glTFAnimation.channels.length && glTFAnimation.samplers.length) {\r\n                    glTFAnimations.push(glTFAnimation);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static AddAnimation(name: string, glTFAnimation: IAnimation, babylonTransformNode: TransformNode, animation: Animation, dataAccessorType: AccessorType, animationChannelTargetPath: AnimationChannelTargetPath, nodeMap: { [key: number]: number }, binaryWriter: _BinaryWriter, bufferViews: IBufferView[], accessors: IAccessor[], convertToRightHandedSystem: boolean, useQuaternion: boolean, animationSampleRate: number) {\r\n        let animationData = _GLTFAnimation._CreateNodeAnimation(babylonTransformNode, animation, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion, animationSampleRate);\r\n        let bufferView: IBufferView;\r\n        let accessor: IAccessor;\r\n        let keyframeAccessorIndex: number;\r\n        let dataAccessorIndex: number;\r\n        let outputLength: number;\r\n        let animationSampler: IAnimationSampler;\r\n        let animationChannel: IAnimationChannel;\r\n\r\n        if (animationData) {\r\n            let nodeIndex = nodeMap[babylonTransformNode.uniqueId];\r\n\r\n            // Creates buffer view and accessor for key frames.\r\n            let byteLength = animationData.inputs.length * 4;\r\n            bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, `${name}  keyframe data view`);\r\n            bufferViews.push(bufferView);\r\n            animationData.inputs.forEach(function(input) {\r\n                binaryWriter.setFloat32(input);\r\n            });\r\n\r\n            accessor = _GLTFUtilities._CreateAccessor(bufferViews.length - 1, `${name}  keyframes`, AccessorType.SCALAR, AccessorComponentType.FLOAT, animationData.inputs.length, null, [animationData.inputsMin], [animationData.inputsMax]);\r\n            accessors.push(accessor);\r\n            keyframeAccessorIndex = accessors.length - 1;\r\n\r\n            // create bufferview and accessor for keyed values.\r\n            outputLength = animationData.outputs.length;\r\n            byteLength = dataAccessorType === AccessorType.VEC3 ? animationData.outputs.length * 12 : animationData.outputs.length * 16;\r\n\r\n            // check for in and out tangents\r\n            bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, `${name}  data view`);\r\n            bufferViews.push(bufferView);\r\n\r\n            animationData.outputs.forEach(function(output) {\r\n                output.forEach(function(entry) {\r\n                    binaryWriter.setFloat32(entry);\r\n                });\r\n            });\r\n\r\n            accessor = _GLTFUtilities._CreateAccessor(bufferViews.length - 1, `${name}  data`, dataAccessorType, AccessorComponentType.FLOAT, outputLength, null, null, null);\r\n            accessors.push(accessor);\r\n            dataAccessorIndex = accessors.length - 1;\r\n\r\n            // create sampler\r\n            animationSampler = {\r\n                interpolation: animationData.samplerInterpolation,\r\n                input: keyframeAccessorIndex,\r\n                output: dataAccessorIndex\r\n            };\r\n            glTFAnimation.samplers.push(animationSampler);\r\n\r\n            // create channel\r\n            animationChannel = {\r\n                sampler: glTFAnimation.samplers.length - 1,\r\n                target: {\r\n                    node: nodeIndex,\r\n                    path: animationChannelTargetPath\r\n                }\r\n            };\r\n            glTFAnimation.channels.push(animationChannel);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a baked animation\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation corresponding to the BabylonJS mesh\r\n     * @param animationChannelTargetPath animation target channel\r\n     * @param minFrame minimum animation frame\r\n     * @param maxFrame maximum animation frame\r\n     * @param fps frames per second of the animation\r\n     * @param inputs input key frames of the animation\r\n     * @param outputs output key frame data of the animation\r\n     * @param convertToRightHandedSystem converts the values to right-handed\r\n     * @param useQuaternion specifies if quaternions should be used\r\n     */\r\n    private static _CreateBakedAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, minFrame: number, maxFrame: number, fps: number, sampleRate: number, inputs: number[], outputs: number[][], minMaxFrames: { min: number, max: number }, convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        let value: number | Vector3 | Quaternion;\r\n        let quaternionCache: Quaternion = Quaternion.Identity();\r\n        let previousTime: Nullable<number> = null;\r\n        let time: number;\r\n        let maxUsedFrame: Nullable<number> = null;\r\n        let currKeyFrame: Nullable<IAnimationKey> = null;\r\n        let nextKeyFrame: Nullable<IAnimationKey> = null;\r\n        let prevKeyFrame: Nullable<IAnimationKey> = null;\r\n        let endFrame: Nullable<number> = null;\r\n        minMaxFrames.min = Tools.FloatRound(minFrame / fps);\r\n\r\n        let keyFrames = animation.getKeys();\r\n\r\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\r\n            endFrame = null;\r\n            currKeyFrame = keyFrames[i];\r\n\r\n            if (i + 1 < length) {\r\n                nextKeyFrame = keyFrames[i + 1];\r\n                if (currKeyFrame.value.equals && currKeyFrame.value.equals(nextKeyFrame.value) || currKeyFrame.value === nextKeyFrame.value) {\r\n                    if (i === 0) { // set the first frame to itself\r\n                        endFrame = currKeyFrame.frame;\r\n                    }\r\n                    else {\r\n                        continue;\r\n                    }\r\n                }\r\n                else {\r\n                    endFrame = nextKeyFrame.frame;\r\n                }\r\n            }\r\n            else {\r\n                // at the last key frame\r\n                prevKeyFrame = keyFrames[i - 1];\r\n                if (currKeyFrame.value.equals && currKeyFrame.value.equals(prevKeyFrame.value) || currKeyFrame.value === prevKeyFrame.value) {\r\n                    continue;\r\n                }\r\n                else {\r\n                    endFrame = maxFrame;\r\n                }\r\n            }\r\n            if (endFrame) {\r\n                for (let f = currKeyFrame.frame; f <= endFrame; f += sampleRate) {\r\n                    time = Tools.FloatRound(f / fps);\r\n                    if (time === previousTime) {\r\n                        continue;\r\n                    }\r\n                    previousTime = time;\r\n                    maxUsedFrame = time;\r\n                    let state = {\r\n                        key: 0,\r\n                        repeatCount: 0,\r\n                        loopMode: animation.loopMode\r\n                    };\r\n                    value = animation._interpolate(f, state);\r\n\r\n                    _GLTFAnimation._SetInterpolatedValue(babylonTransformNode, value, time, animation, animationChannelTargetPath, quaternionCache, inputs, outputs, convertToRightHandedSystem, useQuaternion);\r\n                }\r\n            }\r\n        }\r\n        if (maxUsedFrame) {\r\n            minMaxFrames.max = maxUsedFrame;\r\n        }\r\n    }\r\n\r\n    private static _ConvertFactorToVector3OrQuaternion(factor: number, babylonTransformNode: TransformNode, animation: Animation, animationType: number, animationChannelTargetPath: AnimationChannelTargetPath, convertToRightHandedSystem: boolean, useQuaternion: boolean): Nullable<Vector3 | Quaternion> {\r\n        let property: string[];\r\n        let componentName: string;\r\n        let value: Nullable<Quaternion | Vector3> = null;\r\n        const basePositionRotationOrScale = _GLTFAnimation._GetBasePositionRotationOrScale(babylonTransformNode, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);\r\n        if (animationType === Animation.ANIMATIONTYPE_FLOAT) { // handles single component x, y, z or w component animation by using a base property and animating over a component.\r\n            property = animation.targetProperty.split('.');\r\n            componentName = property ? property[1] : ''; // x, y, or z component\r\n            value = useQuaternion ? Quaternion.FromArray(basePositionRotationOrScale).normalize() : Vector3.FromArray(basePositionRotationOrScale);\r\n\r\n            switch (componentName) {\r\n                case 'x': {\r\n                    value[componentName] = (convertToRightHandedSystem && useQuaternion && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) ? -factor : factor;\r\n                    break;\r\n                }\r\n                case 'y': {\r\n                    value[componentName] = (convertToRightHandedSystem && useQuaternion && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) ? -factor : factor;\r\n                    break;\r\n                }\r\n                case 'z': {\r\n                    value[componentName] = (convertToRightHandedSystem && !useQuaternion && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) ? -factor : factor;\r\n                    break;\r\n                }\r\n                case 'w': {\r\n                    (value as Quaternion).w = factor;\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`glTFAnimation: Unsupported component type \"${componentName}\" for scale animation!`);\r\n                }\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    private static _SetInterpolatedValue(babylonTransformNode: TransformNode, value: Nullable<number | Vector3 | Quaternion>, time: number, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, quaternionCache: Quaternion, inputs: number[], outputs: number[][], convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        const animationType = animation.dataType;\r\n        let cacheValue: Vector3 | Quaternion;\r\n        inputs.push(time);\r\n        if (typeof value === \"number\") {\r\n            value = this._ConvertFactorToVector3OrQuaternion(value as number, babylonTransformNode, animation, animationType, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);\r\n        }\r\n        if (value) {\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                if (useQuaternion) {\r\n                    quaternionCache = value as Quaternion;\r\n                }\r\n                else {\r\n                    cacheValue = value as Vector3;\r\n                    Quaternion.RotationYawPitchRollToRef(cacheValue.y, cacheValue.x, cacheValue.z, quaternionCache);\r\n                }\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedQuaternionFromRef(quaternionCache);\r\n\r\n                    if (!babylonTransformNode.parent) {\r\n                        quaternionCache = Quaternion.FromArray([0, 1, 0, 0]).multiply(quaternionCache);\r\n                    }\r\n                }\r\n                outputs.push(quaternionCache.asArray());\r\n            }\r\n            else {\r\n                cacheValue = value as Vector3;\r\n                if (convertToRightHandedSystem && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) {\r\n                    _GLTFUtilities._GetRightHandedPositionVector3FromRef(cacheValue);\r\n                    if (!babylonTransformNode.parent) {\r\n                        cacheValue.x *= -1;\r\n                        cacheValue.z *= -1;\r\n                    }\r\n                }\r\n\r\n                outputs.push(cacheValue.asArray());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates linear animation from the animation key frames\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param frameDelta The difference between the last and first frame of the animation\r\n     * @param inputs Array to store the key frame times\r\n     * @param outputs Array to store the key frame data\r\n     * @param convertToRightHandedSystem Specifies if the position data should be converted to right handed\r\n     * @param useQuaternion Specifies if quaternions are used in the animation\r\n     */\r\n    private static _CreateLinearOrStepAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, frameDelta: number, inputs: number[], outputs: number[][], convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        for (let keyFrame of animation.getKeys()) {\r\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\r\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, convertToRightHandedSystem, useQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates cubic spline animation from the animation key frames\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param frameDelta The difference between the last and first frame of the animation\r\n     * @param inputs Array to store the key frame times\r\n     * @param outputs Array to store the key frame data\r\n     * @param convertToRightHandedSystem Specifies if the position data should be converted to right handed\r\n     * @param useQuaternion Specifies if quaternions are used in the animation\r\n     */\r\n    private static _CreateCubicSplineAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, frameDelta: number, inputs: number[], outputs: number[][], convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        animation.getKeys().forEach(function(keyFrame) {\r\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\r\n            _GLTFAnimation.AddSplineTangent(\r\n                babylonTransformNode,\r\n                _TangentType.INTANGENT,\r\n                outputs,\r\n                animationChannelTargetPath,\r\n                AnimationSamplerInterpolation.CUBICSPLINE,\r\n                keyFrame,\r\n                frameDelta,\r\n                useQuaternion,\r\n                convertToRightHandedSystem\r\n            );\r\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, convertToRightHandedSystem, useQuaternion);\r\n\r\n            _GLTFAnimation.AddSplineTangent(\r\n                babylonTransformNode,\r\n                _TangentType.OUTTANGENT,\r\n                outputs,\r\n                animationChannelTargetPath,\r\n                AnimationSamplerInterpolation.CUBICSPLINE,\r\n                keyFrame,\r\n                frameDelta,\r\n                useQuaternion,\r\n                convertToRightHandedSystem\r\n            );\r\n        });\r\n    }\r\n\r\n    private static _GetBasePositionRotationOrScale(babylonTransformNode: TransformNode, animationChannelTargetPath: AnimationChannelTargetPath, convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        let basePositionRotationOrScale: number[];\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n            if (useQuaternion) {\r\n                if (babylonTransformNode.rotationQuaternion) {\r\n                    basePositionRotationOrScale = babylonTransformNode.rotationQuaternion.asArray();\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedQuaternionArrayFromRef(basePositionRotationOrScale);\r\n                        if (!babylonTransformNode.parent) {\r\n                            basePositionRotationOrScale = Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(basePositionRotationOrScale)).asArray();\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    basePositionRotationOrScale = Quaternion.Identity().asArray();\r\n                }\r\n            }\r\n            else {\r\n                basePositionRotationOrScale = babylonTransformNode.rotation.asArray();\r\n                _GLTFUtilities._GetRightHandedNormalArray3FromRef(basePositionRotationOrScale);\r\n            }\r\n        }\r\n        else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n            basePositionRotationOrScale = babylonTransformNode.position.asArray();\r\n            if (convertToRightHandedSystem) {\r\n                _GLTFUtilities._GetRightHandedPositionArray3FromRef(basePositionRotationOrScale);\r\n            }\r\n        }\r\n        else { // scale\r\n            basePositionRotationOrScale = babylonTransformNode.scaling.asArray();\r\n        }\r\n        return basePositionRotationOrScale;\r\n    }\r\n\r\n    /**\r\n     * Adds a key frame value\r\n     * @param keyFrame\r\n     * @param animation\r\n     * @param outputs\r\n     * @param animationChannelTargetPath\r\n     * @param basePositionRotationOrScale\r\n     * @param convertToRightHandedSystem\r\n     * @param useQuaternion\r\n     */\r\n    private static _AddKeyframeValue(keyFrame: IAnimationKey, animation: Animation, outputs: number[][], animationChannelTargetPath: AnimationChannelTargetPath, babylonTransformNode: TransformNode, convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        let value: number[];\r\n        let newPositionRotationOrScale: Nullable<Vector3 | Quaternion>;\r\n        const animationType = animation.dataType;\r\n        if (animationType === Animation.ANIMATIONTYPE_VECTOR3) {\r\n            value = keyFrame.value.asArray();\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                const array = Vector3.FromArray(value);\r\n                let rotationQuaternion = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z);\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedQuaternionFromRef(rotationQuaternion);\r\n\r\n                    if (!babylonTransformNode.parent) {\r\n                        rotationQuaternion = Quaternion.FromArray([0, 1, 0, 0]).multiply(rotationQuaternion);\r\n                    }\r\n                }\r\n                value = rotationQuaternion.asArray();\r\n            }\r\n            else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedNormalArray3FromRef(value);\r\n                    if (!babylonTransformNode.parent) {\r\n                        value[0] *= -1;\r\n                        value[2] *= -1;\r\n                    }\r\n                }\r\n            }\r\n            outputs.push(value); // scale  vector.\r\n\r\n        }\r\n        else if (animationType === Animation.ANIMATIONTYPE_FLOAT) { // handles single component x, y, z or w component animation by using a base property and animating over a component.\r\n            newPositionRotationOrScale = this._ConvertFactorToVector3OrQuaternion(keyFrame.value as number, babylonTransformNode, animation, animationType, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);\r\n            if (newPositionRotationOrScale) {\r\n                if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                    let posRotScale = useQuaternion ? newPositionRotationOrScale as Quaternion : Quaternion.RotationYawPitchRoll(newPositionRotationOrScale.y, newPositionRotationOrScale.x, newPositionRotationOrScale.z).normalize();\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedQuaternionFromRef(posRotScale);\r\n\r\n                        if (!babylonTransformNode.parent) {\r\n                            posRotScale = Quaternion.FromArray([0, 1, 0, 0]).multiply(posRotScale);\r\n                        }\r\n                    }\r\n                    outputs.push(posRotScale.asArray());\r\n                }\r\n                else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(newPositionRotationOrScale as Vector3);\r\n\r\n                        if (!babylonTransformNode.parent) {\r\n                            newPositionRotationOrScale.x *= -1;\r\n                            newPositionRotationOrScale.z *= -1;\r\n                        }\r\n                    }\r\n                }\r\n                outputs.push(newPositionRotationOrScale.asArray());\r\n            }\r\n        }\r\n        else if (animationType === Animation.ANIMATIONTYPE_QUATERNION) {\r\n            value = (keyFrame.value as Quaternion).normalize().asArray();\r\n\r\n            if (convertToRightHandedSystem) {\r\n                _GLTFUtilities._GetRightHandedQuaternionArrayFromRef(value);\r\n\r\n                if (!babylonTransformNode.parent) {\r\n                    value = Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(value)).asArray();\r\n                }\r\n            }\r\n\r\n            outputs.push(value);\r\n        }\r\n        else {\r\n            Tools.Error('glTFAnimation: Unsupported key frame values for animation!');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine the interpolation based on the key frames\r\n     * @param keyFrames\r\n     * @param animationChannelTargetPath\r\n     * @param useQuaternion\r\n     */\r\n    private static _DeduceInterpolation(keyFrames: IAnimationKey[], animationChannelTargetPath: AnimationChannelTargetPath, useQuaternion: boolean): { interpolationType: AnimationSamplerInterpolation, shouldBakeAnimation: boolean } {\r\n        let interpolationType: AnimationSamplerInterpolation | undefined;\r\n        let shouldBakeAnimation = false;\r\n        let key: IAnimationKey;\r\n\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION && !useQuaternion) {\r\n            return { interpolationType: AnimationSamplerInterpolation.LINEAR, shouldBakeAnimation: true };\r\n        }\r\n\r\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\r\n            key = keyFrames[i];\r\n            if (key.inTangent || key.outTangent) {\r\n                if (interpolationType) {\r\n                    if (interpolationType !== AnimationSamplerInterpolation.CUBICSPLINE) {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                        shouldBakeAnimation = true;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    interpolationType = AnimationSamplerInterpolation.CUBICSPLINE;\r\n                }\r\n            }\r\n            else {\r\n                if (interpolationType) {\r\n                    if (interpolationType === AnimationSamplerInterpolation.CUBICSPLINE ||\r\n                        (key.interpolation && (key.interpolation === AnimationKeyInterpolation.STEP) && interpolationType !== AnimationSamplerInterpolation.STEP)) {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                        shouldBakeAnimation = true;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (key.interpolation && (key.interpolation === AnimationKeyInterpolation.STEP)) {\r\n                        interpolationType = AnimationSamplerInterpolation.STEP;\r\n                    }\r\n                    else {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!interpolationType) {\r\n            interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n        }\r\n\r\n        return { interpolationType: interpolationType, shouldBakeAnimation: shouldBakeAnimation };\r\n    }\r\n\r\n    /**\r\n     * Adds an input tangent or output tangent to the output data\r\n     * If an input tangent or output tangent is missing, it uses the zero vector or zero quaternion\r\n     * @param tangentType Specifies which type of tangent to handle (inTangent or outTangent)\r\n     * @param outputs The animation data by keyframe\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param interpolation The interpolation type\r\n     * @param keyFrame The key frame with the animation data\r\n     * @param frameDelta Time difference between two frames used to scale the tangent by the frame delta\r\n     * @param useQuaternion Specifies if quaternions are used\r\n     * @param convertToRightHandedSystem Specifies if the values should be converted to right-handed\r\n     */\r\n    private static AddSplineTangent(babylonTransformNode: TransformNode, tangentType: _TangentType, outputs: number[][], animationChannelTargetPath: AnimationChannelTargetPath, interpolation: AnimationSamplerInterpolation, keyFrame: IAnimationKey, frameDelta: number, useQuaternion: boolean, convertToRightHandedSystem: boolean) {\r\n        let tangent: number[];\r\n        let tangentValue: Vector3 | Quaternion = tangentType === _TangentType.INTANGENT ? keyFrame.inTangent : keyFrame.outTangent;\r\n        if (interpolation === AnimationSamplerInterpolation.CUBICSPLINE) {\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                if (tangentValue) {\r\n                    if (useQuaternion) {\r\n                        tangent = (tangentValue as Quaternion).scale(frameDelta).asArray();\r\n                    }\r\n                    else {\r\n                        const array = (tangentValue as Vector3).scale(frameDelta);\r\n                        tangent = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z).asArray();\r\n                    }\r\n\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedQuaternionArrayFromRef(tangent);\r\n                        if (!babylonTransformNode.parent) {\r\n                            tangent = Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(tangent)).asArray();\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    tangent = [0, 0, 0, 0];\r\n                }\r\n            }\r\n            else {\r\n                if (tangentValue) {\r\n                    tangent = (tangentValue as Vector3).scale(frameDelta).asArray();\r\n                    if (convertToRightHandedSystem) {\r\n                        if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n                            _GLTFUtilities._GetRightHandedPositionArray3FromRef(tangent);\r\n                            if (!babylonTransformNode.parent) {\r\n                                tangent[0] *= -1; // x\r\n                                tangent[2] *= -1; // z\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    tangent = [0, 0, 0];\r\n                }\r\n            }\r\n\r\n            outputs.push(tangent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the minimum and maximum key frames' frame values\r\n     * @param keyFrames animation key frames\r\n     * @returns the minimum and maximum key frame value\r\n     */\r\n    private static calculateMinMaxKeyFrames(keyFrames: IAnimationKey[]): { min: number, max: number } {\r\n        let min: number = Infinity;\r\n        let max: number = -Infinity;\r\n        keyFrames.forEach(function(keyFrame) {\r\n            min = Math.min(min, keyFrame.frame);\r\n            max = Math.max(max, keyFrame.frame);\r\n        });\r\n\r\n        return { min: min, max: max };\r\n\r\n    }\r\n}","import { ImageMimeType } from \"babylonjs-gltf2interface\";\r\n\r\n/**\r\n * Class for holding and downloading glTF file data\r\n */\r\nexport class GLTFData {\r\n    /**\r\n     * Object which contains the file name as the key and its data as the value\r\n     */\r\n    glTFFiles: { [fileName: string]: string | Blob };\r\n\r\n    /**\r\n     * Initializes the glTF file object\r\n     */\r\n    public constructor() {\r\n        this.glTFFiles = {};\r\n    }\r\n\r\n    /**\r\n     * Downloads the glTF data as files based on their names and data\r\n     */\r\n    public downloadFiles(): void {\r\n        /**\r\n        * Checks for a matching suffix at the end of a string (for ES5 and lower)\r\n        * @param str Source string\r\n        * @param suffix Suffix to search for in the source string\r\n        * @returns Boolean indicating whether the suffix was found (true) or not (false)\r\n        */\r\n        function endsWith(str: string, suffix: string): boolean {\r\n            return str.indexOf(suffix, str.length - suffix.length) !== -1;\r\n        }\r\n\r\n        for (let key in this.glTFFiles) {\r\n            let link = document.createElement('a');\r\n            document.body.appendChild(link);\r\n            link.setAttribute(\"type\", \"hidden\");\r\n            link.download = key;\r\n            let blob = this.glTFFiles[key];\r\n            let mimeType;\r\n\r\n            if (endsWith(key, \".glb\")) {\r\n                mimeType = { type: \"model/gltf-binary\" };\r\n            }\r\n            else if (endsWith(key, \".bin\")) {\r\n                mimeType = { type: \"application/octet-stream\" };\r\n            }\r\n            else if (endsWith(key, \".gltf\")) {\r\n                mimeType = { type: \"model/gltf+json\" };\r\n            }\r\n            else if (endsWith(key, \".jpeg\" || \".jpg\")) {\r\n                mimeType = { type: ImageMimeType.JPEG };\r\n            }\r\n            else if (endsWith(key, \".png\")) {\r\n                mimeType = { type: ImageMimeType.PNG };\r\n            }\r\n\r\n            link.href = window.URL.createObjectURL(new Blob([blob], mimeType));\r\n            link.click();\r\n        }\r\n    }\r\n}\r\n","import { AccessorType, IBufferView, IAccessor, INode, IScene, IMesh, IMaterial, ITexture, IImage, ISampler, IAnimation, ImageMimeType, IMeshPrimitive, IBuffer, IGLTF, MeshPrimitiveMode, AccessorComponentType, ITextureInfo } from \"babylonjs-gltf2interface\";\r\n\r\nimport { FloatArray, Nullable, IndicesArray } from \"babylonjs/types\";\r\nimport { Vector2, Vector3, Vector4, Quaternion, Matrix } from \"babylonjs/Maths/math.vector\";\r\nimport { Color3 } from \"babylonjs/Maths/math.color\";\r\nimport { Tools } from \"babylonjs/Misc/tools\";\r\nimport { VertexBuffer } from \"babylonjs/Meshes/buffer\";\r\nimport { Node } from \"babylonjs/node\";\r\nimport { TransformNode } from \"babylonjs/Meshes/transformNode\";\r\nimport { AbstractMesh } from \"babylonjs/Meshes/abstractMesh\";\r\nimport { SubMesh } from \"babylonjs/Meshes/subMesh\";\r\nimport { Mesh } from \"babylonjs/Meshes/mesh\";\r\nimport { LinesMesh } from \"babylonjs/Meshes/linesMesh\";\r\nimport { InstancedMesh } from \"babylonjs/Meshes/instancedMesh\";\r\nimport { BaseTexture } from \"babylonjs/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"babylonjs/Materials/Textures/texture\";\r\nimport { Material } from \"babylonjs/Materials/material\";\r\nimport { MultiMaterial } from \"babylonjs/Materials/multiMaterial\";\r\nimport { Engine } from \"babylonjs/Engines/engine\";\r\nimport { Scene } from \"babylonjs/scene\";\r\n\r\nimport { IGLTFExporterExtensionV2 } from \"./glTFExporterExtension\";\r\nimport { _GLTFMaterialExporter } from \"./glTFMaterialExporter\";\r\nimport { IExportOptions } from \"./glTFSerializer\";\r\nimport { _GLTFUtilities } from \"./glTFUtilities\";\r\nimport { GLTFData } from \"./glTFData\";\r\nimport { _GLTFAnimation } from \"./glTFAnimation\";\r\nimport { Viewport } from 'babylonjs/Maths/math.viewport';\r\nimport { Epsilon } from 'babylonjs/Maths/math.constants';\r\n\r\n/**\r\n * Utility interface for storing vertex attribute data\r\n * @hidden\r\n */\r\ninterface _IVertexAttributeData {\r\n    /**\r\n     * Specifies the Babylon Vertex Buffer Type (Position, Normal, Color, etc.)\r\n    */\r\n    kind: string;\r\n\r\n    /**\r\n     * Specifies the glTF Accessor Type (VEC2, VEC3, etc.)\r\n    */\r\n    accessorType: AccessorType;\r\n\r\n    /**\r\n     * Specifies the BufferView index for the vertex attribute data\r\n    */\r\n    bufferViewIndex?: number;\r\n\r\n    byteStride?: number;\r\n}\r\n/**\r\n * Converts Babylon Scene into glTF 2.0.\r\n * @hidden\r\n */\r\nexport class _Exporter {\r\n    /**\r\n     * Stores the glTF to export\r\n     */\r\n    public _glTF: IGLTF;\r\n    /**\r\n     * Stores all generated buffer views, which represents views into the main glTF buffer data\r\n     */\r\n    public _bufferViews: IBufferView[];\r\n    /**\r\n     * Stores all the generated accessors, which is used for accessing the data within the buffer views in glTF\r\n     */\r\n    public _accessors: IAccessor[];\r\n    /**\r\n     * Stores all the generated nodes, which contains transform and/or mesh information per node\r\n     */\r\n    public _nodes: INode[];\r\n    /**\r\n     * Stores all the generated glTF scenes, which stores multiple node hierarchies\r\n     */\r\n    private _scenes: IScene[];\r\n    /**\r\n     * Stores all the generated mesh information, each containing a set of primitives to render in glTF\r\n     */\r\n    private _meshes: IMesh[];\r\n    /**\r\n     * Stores all the generated material information, which represents the appearance of each primitive\r\n     */\r\n    public _materials: IMaterial[];\r\n\r\n    public _materialMap: { [materialID: number]: number };\r\n    /**\r\n     * Stores all the generated texture information, which is referenced by glTF materials\r\n     */\r\n    public _textures: ITexture[];\r\n    /**\r\n     * Stores all the generated image information, which is referenced by glTF textures\r\n     */\r\n    public _images: IImage[];\r\n\r\n    /**\r\n     * Stores all the texture samplers\r\n     */\r\n    public _samplers: ISampler[];\r\n    /**\r\n     * Stores all the generated animation samplers, which is referenced by glTF animations\r\n     */\r\n    /**\r\n     * Stores the animations for glTF models\r\n     */\r\n    private _animations: IAnimation[];\r\n    /**\r\n     * Stores the total amount of bytes stored in the glTF buffer\r\n     */\r\n    private _totalByteLength: number;\r\n    /**\r\n     * Stores a reference to the Babylon scene containing the source geometry and material information\r\n     */\r\n    public _babylonScene: Scene;\r\n    /**\r\n     * Stores a map of the image data, where the key is the file name and the value\r\n     * is the image data\r\n     */\r\n    public _imageData: { [fileName: string]: { data: Uint8Array, mimeType: ImageMimeType } };\r\n\r\n    /**\r\n     * Stores a map of the unique id of a node to its index in the node array\r\n     */\r\n    public _nodeMap: { [key: number]: number };\r\n\r\n    /**\r\n     * Specifies if the source Babylon scene was left handed, and needed conversion.\r\n     */\r\n    public _convertToRightHandedSystem: boolean;\r\n\r\n    /**\r\n     * Specifies if a Babylon node should be converted to right-handed on export\r\n     */\r\n    public _convertToRightHandedSystemMap: { [nodeId: number]: boolean };\r\n\r\n    /*\r\n    * Specifies if root Babylon empty nodes that act as a coordinate space transform should be included in export\r\n    */\r\n    public _includeCoordinateSystemConversionNodes: boolean = false;\r\n\r\n    /**\r\n     * Baked animation sample rate\r\n     */\r\n    private _animationSampleRate: number;\r\n\r\n    private _options: IExportOptions;\r\n\r\n    private _localEngine: Engine;\r\n\r\n    public _glTFMaterialExporter: _GLTFMaterialExporter;\r\n\r\n    private _extensions: { [name: string]: IGLTFExporterExtensionV2 } = {};\r\n\r\n    private static _ExtensionNames = new Array<string>();\r\n    private static _ExtensionFactories: { [name: string]: (exporter: _Exporter) => IGLTFExporterExtensionV2 } = {};\r\n\r\n    private _applyExtension<T>(node: Nullable<T>, extensions: IGLTFExporterExtensionV2[], index: number, actionAsync: (extension: IGLTFExporterExtensionV2, node: Nullable<T>) => Promise<Nullable<T>> | undefined): Promise<Nullable<T>> {\r\n        if (index >= extensions.length) {\r\n            return Promise.resolve(node);\r\n        }\r\n\r\n        let currentPromise = actionAsync(extensions[index], node);\r\n\r\n        if (!currentPromise) {\r\n            return this._applyExtension(node, extensions, index + 1, actionAsync);\r\n        }\r\n\r\n        return currentPromise.then((newNode) => this._applyExtension(newNode, extensions, index + 1, actionAsync));\r\n    }\r\n\r\n    private _applyExtensions<T>(node: Nullable<T>, actionAsync: (extension: IGLTFExporterExtensionV2, node: Nullable<T>) => Promise<Nullable<T>> | undefined): Promise<Nullable<T>> {\r\n        var extensions: IGLTFExporterExtensionV2[] = [];\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            extensions.push(this._extensions[name]);\r\n        }\r\n\r\n        return this._applyExtension(node, extensions, 0, actionAsync);\r\n    }\r\n\r\n    public _extensionsPreExportTextureAsync(context: string, babylonTexture: Nullable<Texture>, mimeType: ImageMimeType): Promise<Nullable<BaseTexture>> {\r\n        return this._applyExtensions(babylonTexture, (extension, node) => extension.preExportTextureAsync && extension.preExportTextureAsync(context, node, mimeType));\r\n    }\r\n\r\n    public _extensionsPostExportMeshPrimitiveAsync(context: string, meshPrimitive: IMeshPrimitive, babylonSubMesh: SubMesh, binaryWriter: _BinaryWriter): Promise<Nullable<IMeshPrimitive>> {\r\n        return this._applyExtensions(meshPrimitive, (extension, node) => extension.postExportMeshPrimitiveAsync && extension.postExportMeshPrimitiveAsync(context, node, babylonSubMesh, binaryWriter));\r\n    }\r\n\r\n    public _extensionsPostExportNodeAsync(context: string, node: Nullable<INode>, babylonNode: Node, nodeMap?: {[key: number]: number}): Promise<Nullable<INode>> {\r\n        return this._applyExtensions(node, (extension, node) => extension.postExportNodeAsync && extension.postExportNodeAsync(context, node, babylonNode, nodeMap));\r\n    }\r\n\r\n    public _extensionsPostExportMaterialAsync(context: string, material: Nullable<IMaterial>, babylonMaterial: Material): Promise<Nullable<IMaterial>> {\r\n        return this._applyExtensions(material, (extension, node) => extension.postExportMaterialAsync && extension.postExportMaterialAsync(context, node, babylonMaterial));\r\n    }\r\n\r\n    public _extensionsPostExportMaterialAdditionalTextures(context: string, material: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        let output: BaseTexture[] = [];\r\n\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            var extension = this._extensions[name];\r\n\r\n            if (extension.postExportMaterialAdditionalTextures) {\r\n                output.push(...extension.postExportMaterialAdditionalTextures(context, material, babylonMaterial));\r\n            }\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n    public _extensionsPostExportTextures(context: string, textureInfo: ITextureInfo, babylonTexture: BaseTexture): void {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            var extension = this._extensions[name];\r\n\r\n            if (extension.postExportTexture) {\r\n                extension.postExportTexture(context, textureInfo, babylonTexture);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _forEachExtensions(action: (extension: IGLTFExporterExtensionV2) => void): void {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n            if (extension.enabled) {\r\n                action(extension);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _extensionsOnExporting(): void {\r\n        this._forEachExtensions((extension) => {\r\n            if (extension.wasUsed) {\r\n                if (this._glTF.extensionsUsed == null) {\r\n                    this._glTF.extensionsUsed = [];\r\n                }\r\n\r\n                if (this._glTF.extensionsUsed.indexOf(extension.name) === -1) {\r\n                    this._glTF.extensionsUsed.push(extension.name);\r\n                }\r\n\r\n                if (extension.required) {\r\n                    if (this._glTF.extensionsRequired == null) {\r\n                        this._glTF.extensionsRequired = [];\r\n                    }\r\n                    if (this._glTF.extensionsRequired.indexOf(extension.name) === -1) {\r\n                        this._glTF.extensionsRequired.push(extension.name);\r\n                    }\r\n                }\r\n\r\n                if (this._glTF.extensions == null) {\r\n                    this._glTF.extensions = {};\r\n                }\r\n\r\n                if (extension.onExporting) {\r\n                    extension.onExporting();\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load glTF serializer extensions\r\n     */\r\n    private _loadExtensions(): void {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = _Exporter._ExtensionFactories[name](this);\r\n            this._extensions[name] = extension;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF Exporter instance, which can accept optional exporter options\r\n     * @param babylonScene Babylon scene object\r\n     * @param options Options to modify the behavior of the exporter\r\n     */\r\n    public constructor(babylonScene: Scene, options?: IExportOptions) {\r\n        this._glTF = {\r\n            asset: { generator: \"BabylonJS\", version: \"2.0\" }\r\n        };\r\n        this._babylonScene = babylonScene;\r\n        this._bufferViews = [];\r\n        this._accessors = [];\r\n        this._meshes = [];\r\n        this._scenes = [];\r\n        this._nodes = [];\r\n        this._images = [];\r\n        this._materials = [];\r\n        this._materialMap = [];\r\n        this._textures = [];\r\n        this._samplers = [];\r\n        this._animations = [];\r\n        this._imageData = {};\r\n        this._options = options || {};\r\n        this._animationSampleRate = options && options.animationSampleRate ? options.animationSampleRate : 1 / 60;\r\n        this._includeCoordinateSystemConversionNodes = options && options.includeCoordinateSystemConversionNodes ? true : false;\r\n\r\n        this._glTFMaterialExporter = new _GLTFMaterialExporter(this);\r\n        this._loadExtensions();\r\n    }\r\n\r\n    public dispose() {\r\n        for (var extensionKey in this._extensions) {\r\n            const extension = this._extensions[extensionKey];\r\n\r\n            extension.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Registers a glTF exporter extension\r\n     * @param name Name of the extension to export\r\n     * @param factory The factory function that creates the exporter extension\r\n     */\r\n    public static RegisterExtension(name: string, factory: (exporter: _Exporter) => IGLTFExporterExtensionV2): void {\r\n        if (_Exporter.UnregisterExtension(name)) {\r\n            Tools.Warn(`Extension with the name ${name} already exists`);\r\n        }\r\n\r\n        _Exporter._ExtensionFactories[name] = factory;\r\n        _Exporter._ExtensionNames.push(name);\r\n    }\r\n\r\n    /**\r\n     * Un-registers an exporter extension\r\n     * @param name The name fo the exporter extension\r\n     * @returns A boolean indicating whether the extension has been un-registered\r\n     */\r\n    public static UnregisterExtension(name: string): boolean {\r\n        if (!_Exporter._ExtensionFactories[name]) {\r\n            return false;\r\n        }\r\n        delete _Exporter._ExtensionFactories[name];\r\n\r\n        const index = _Exporter._ExtensionNames.indexOf(name);\r\n        if (index !== -1) {\r\n            _Exporter._ExtensionNames.splice(index, 1);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Lazy load a local engine\r\n     */\r\n    public _getLocalEngine(): Engine {\r\n        if (!this._localEngine) {\r\n            const localCanvas = document.createElement('canvas');\r\n            localCanvas.id = \"WriteCanvas\";\r\n            localCanvas.width = 2048;\r\n            localCanvas.height = 2048;\r\n            this._localEngine = new Engine(localCanvas, true, { premultipliedAlpha: Tools.IsSafari(), preserveDrawingBuffer: true });\r\n            this._localEngine.setViewport(new Viewport(0, 0, 1, 1));\r\n        }\r\n\r\n        return this._localEngine;\r\n    }\r\n\r\n    private reorderIndicesBasedOnPrimitiveMode(submesh: SubMesh, primitiveMode: number, babylonIndices: IndicesArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        switch (primitiveMode) {\r\n            case Material.TriangleFillMode: {\r\n                if (!byteOffset) { byteOffset = 0; }\r\n                for (let i = submesh.indexStart, length = submesh.indexStart + submesh.indexCount; i < length; i = i + 3) {\r\n                    const index = byteOffset + i * 4;\r\n                    // swap the second and third indices\r\n                    const secondIndex = binaryWriter.getUInt32(index + 4);\r\n                    const thirdIndex = binaryWriter.getUInt32(index + 8);\r\n                    binaryWriter.setUInt32(thirdIndex, index + 4);\r\n                    binaryWriter.setUInt32(secondIndex, index + 8);\r\n                }\r\n                break;\r\n            }\r\n            case Material.TriangleFanDrawMode: {\r\n                for (let i = submesh.indexStart + submesh.indexCount - 1, start = submesh.indexStart; i >= start; --i) {\r\n                    binaryWriter.setUInt32(babylonIndices[i], byteOffset);\r\n                    byteOffset += 4;\r\n                }\r\n                break;\r\n            }\r\n            case Material.TriangleStripDrawMode: {\r\n                if (submesh.indexCount >= 3) {\r\n                    binaryWriter.setUInt32(babylonIndices[submesh.indexStart + 2], byteOffset + 4);\r\n                    binaryWriter.setUInt32(babylonIndices[submesh.indexStart + 1], byteOffset + 8);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attribute data based on the primitive mode.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private reorderVertexAttributeDataBasedOnPrimitiveMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter, convertToRightHandedSystem: boolean): void {\r\n        if (convertToRightHandedSystem && sideOrientation === Material.ClockWiseSideOrientation) {\r\n            switch (primitiveMode) {\r\n                case Material.TriangleFillMode: {\r\n                    this.reorderTriangleFillMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter, convertToRightHandedSystem);\r\n                    break;\r\n                }\r\n                case Material.TriangleStripDrawMode: {\r\n                    this.reorderTriangleStripDrawMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter, convertToRightHandedSystem);\r\n                    break;\r\n                }\r\n                case Material.TriangleFanDrawMode: {\r\n                    this.reorderTriangleFanMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter, convertToRightHandedSystem);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle mode order .  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private reorderTriangleFillMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter, convertToRightHandedSystem: boolean) {\r\n        const vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            let stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n            if (submesh.verticesCount % 3 !== 0) {\r\n                Tools.Error('The submesh vertices for the triangle fill mode is not divisible by 3!');\r\n            }\r\n            else {\r\n                let vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n                let index = 0;\r\n                switch (vertexBufferKind) {\r\n                    case VertexBuffer.PositionKind:\r\n                    case VertexBuffer.NormalKind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.TangentKind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.ColorKind: {\r\n                        const size = vertexBuffer.getSize();\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + size) {\r\n                            index = x * stride;\r\n                            if (size === 4) {\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + 2 * stride));\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + stride));\r\n                            }\r\n                            else {\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.UVKind:\r\n                    case VertexBuffer.UV2Kind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                    }\r\n                }\r\n                this.writeVertexAttributeData(vertexData, byteOffset, vertexBufferKind, meshAttributeArray, binaryWriter, convertToRightHandedSystem);\r\n            }\r\n        }\r\n        else {\r\n            Tools.Warn(`reorderTriangleFillMode: Vertex Buffer Kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle strip order.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private reorderTriangleStripDrawMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter, convertToRightHandedSystem: boolean) {\r\n        const vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            const stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n\r\n            let vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n            let index = 0;\r\n            switch (vertexBufferKind) {\r\n                case VertexBuffer.PositionKind:\r\n                case VertexBuffer.NormalKind: {\r\n                    index = submesh.verticesStart;\r\n                    (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                    (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                    break;\r\n                }\r\n                case VertexBuffer.TangentKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.ColorKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        vertexBuffer.getSize() === 4 ? (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index)) : (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.UVKind:\r\n                case VertexBuffer.UV2Kind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                }\r\n            }\r\n            this.writeVertexAttributeData(vertexData, byteOffset + 12, vertexBufferKind, meshAttributeArray, binaryWriter, convertToRightHandedSystem);\r\n        }\r\n        else {\r\n            Tools.Warn(`reorderTriangleStripDrawMode: Vertex buffer kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle fan order.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private reorderTriangleFanMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter, convertToRightHandedSystem: boolean) {\r\n        const vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            let stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n\r\n            let vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n            let index = 0;\r\n            switch (vertexBufferKind) {\r\n                case VertexBuffer.PositionKind:\r\n                case VertexBuffer.NormalKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.TangentKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n\r\n                }\r\n                case VertexBuffer.ColorKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                        vertexBuffer.getSize() === 4 ? (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index)) : (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.UVKind:\r\n                case VertexBuffer.UV2Kind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                }\r\n            }\r\n            this.writeVertexAttributeData(vertexData, byteOffset, vertexBufferKind, meshAttributeArray, binaryWriter, convertToRightHandedSystem);\r\n        }\r\n        else {\r\n            Tools.Warn(`reorderTriangleFanMode: Vertex buffer kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes the vertex attribute data to binary\r\n     * @param vertices The vertices to write to the binary writer\r\n     * @param byteOffset The offset into the binary writer to overwrite binary data\r\n     * @param vertexAttributeKind The vertex attribute type\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param binaryWriter The writer containing the binary data\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private writeVertexAttributeData(vertices: Vector2[] | Vector3[] | Vector4[], byteOffset: number, vertexAttributeKind: string, meshAttributeArray: FloatArray, binaryWriter: _BinaryWriter, convertToRightHandedSystem: boolean) {\r\n        for (let vertex of vertices) {\r\n            if (convertToRightHandedSystem && !(vertexAttributeKind === VertexBuffer.ColorKind) && !(vertex instanceof Vector2)) {\r\n                if (vertex instanceof Vector3) {\r\n                    if (vertexAttributeKind === VertexBuffer.NormalKind) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(vertex);\r\n                    }\r\n                    else if (vertexAttributeKind === VertexBuffer.PositionKind) {\r\n                        _GLTFUtilities._GetRightHandedPositionVector3FromRef(vertex);\r\n                    }\r\n                    else {\r\n                        Tools.Error('Unsupported vertex attribute kind!');\r\n                    }\r\n                }\r\n                else {\r\n                    _GLTFUtilities._GetRightHandedVector4FromRef(vertex);\r\n                }\r\n            }\r\n            if (vertexAttributeKind === VertexBuffer.NormalKind) {\r\n                vertex.normalize();\r\n            }\r\n            else if (vertexAttributeKind === VertexBuffer.TangentKind && vertex instanceof Vector4) {\r\n                _GLTFUtilities._NormalizeTangentFromRef(vertex);\r\n            }\r\n\r\n            for (let component of vertex.asArray()) {\r\n                binaryWriter.setFloat32(component, byteOffset);\r\n                byteOffset += 4;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes mesh attribute data to a data buffer\r\n     * Returns the bytelength of the data\r\n     * @param vertexBufferKind Indicates what kind of vertex data is being passed in\r\n     * @param meshAttributeArray Array containing the attribute data\r\n     * @param binaryWriter The buffer to write the binary data to\r\n     * @param indices Used to specify the order of the vertex data\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    public writeAttributeData(vertexBufferKind: string, meshAttributeArray: FloatArray, byteStride: number, binaryWriter: _BinaryWriter, convertToRightHandedSystem: boolean) {\r\n        const stride = byteStride / 4;\r\n        let vertexAttributes: number[][] = [];\r\n        let index: number;\r\n\r\n        switch (vertexBufferKind) {\r\n            case VertexBuffer.PositionKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector3.FromArray(meshAttributeArray, index);\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedPositionVector3FromRef(vertexData);\r\n                    }\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.NormalKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector3.FromArray(meshAttributeArray, index);\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(vertexData);\r\n                    }\r\n                    vertexData.normalize();\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.TangentKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector4.FromArray(meshAttributeArray, index);\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedVector4FromRef(vertexData);\r\n                    }\r\n                    _GLTFUtilities._NormalizeTangentFromRef(vertexData);\r\n\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.ColorKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = stride === 3 ? Vector3.FromArray(meshAttributeArray, index) : Vector4.FromArray(meshAttributeArray, index);\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.UVKind:\r\n            case VertexBuffer.UV2Kind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    vertexAttributes.push(convertToRightHandedSystem ? [meshAttributeArray[index], meshAttributeArray[index + 1]] : [meshAttributeArray[index], meshAttributeArray[index + 1]]);\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Vertex Buffer Type: \" + vertexBufferKind);\r\n                vertexAttributes = [];\r\n            }\r\n        }\r\n        for (let vertexAttribute of vertexAttributes) {\r\n            for (let component of vertexAttribute) {\r\n                binaryWriter.setFloat32(component);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates glTF json data\r\n     * @param shouldUseGlb Indicates whether the json should be written for a glb file\r\n     * @param glTFPrefix Text to use when prefixing a glTF file\r\n     * @param prettyPrint Indicates whether the json file should be pretty printed (true) or not (false)\r\n     * @returns json data as string\r\n     */\r\n    private generateJSON(shouldUseGlb: boolean, glTFPrefix?: string, prettyPrint?: boolean): string {\r\n        let buffer: IBuffer = { byteLength: this._totalByteLength };\r\n        let imageName: string;\r\n        let imageData: { data: Uint8Array, mimeType: ImageMimeType };\r\n        let bufferView: IBufferView;\r\n        let byteOffset: number = this._totalByteLength;\r\n\r\n        if (buffer.byteLength) {\r\n            this._glTF.buffers = [buffer];\r\n        }\r\n        if (this._nodes && this._nodes.length) {\r\n            this._glTF.nodes = this._nodes;\r\n        }\r\n        if (this._meshes && this._meshes.length) {\r\n            this._glTF.meshes = this._meshes;\r\n        }\r\n        if (this._scenes && this._scenes.length) {\r\n            this._glTF.scenes = this._scenes;\r\n            this._glTF.scene = 0;\r\n        }\r\n        if (this._bufferViews && this._bufferViews.length) {\r\n            this._glTF.bufferViews = this._bufferViews;\r\n        }\r\n        if (this._accessors && this._accessors.length) {\r\n            this._glTF.accessors = this._accessors;\r\n        }\r\n        if (this._animations && this._animations.length) {\r\n            this._glTF.animations = this._animations;\r\n        }\r\n        if (this._materials && this._materials.length) {\r\n            this._glTF.materials = this._materials;\r\n        }\r\n        if (this._textures && this._textures.length) {\r\n            this._glTF.textures = this._textures;\r\n        }\r\n        if (this._samplers && this._samplers.length) {\r\n            this._glTF.samplers = this._samplers;\r\n        }\r\n        if (this._images && this._images.length) {\r\n            if (!shouldUseGlb) {\r\n                this._glTF.images = this._images;\r\n            }\r\n            else {\r\n                this._glTF.images = [];\r\n\r\n                this._images.forEach((image) => {\r\n                    if (image.uri) {\r\n                        imageData = this._imageData[image.uri];\r\n                        imageName = image.uri.split('.')[0] + \" image\";\r\n                        bufferView = _GLTFUtilities._CreateBufferView(0, byteOffset, imageData.data.length, undefined, imageName);\r\n                        byteOffset += imageData.data.buffer.byteLength;\r\n                        this._bufferViews.push(bufferView);\r\n                        image.bufferView = this._bufferViews.length - 1;\r\n                        image.name = imageName;\r\n                        image.mimeType = imageData.mimeType;\r\n                        image.uri = undefined;\r\n                        if (!this._glTF.images) {\r\n                            this._glTF.images = [];\r\n                        }\r\n                        this._glTF.images.push(image);\r\n                    }\r\n                });\r\n                // Replace uri with bufferview and mime type for glb\r\n                buffer.byteLength = byteOffset;\r\n            }\r\n        }\r\n\r\n        if (!shouldUseGlb) {\r\n            buffer.uri = glTFPrefix + \".bin\";\r\n        }\r\n\r\n        const jsonText = prettyPrint ? JSON.stringify(this._glTF, null, 2) : JSON.stringify(this._glTF);\r\n\r\n        return jsonText;\r\n    }\r\n\r\n    /**\r\n     * Generates data for .gltf and .bin files based on the glTF prefix string\r\n     * @param glTFPrefix Text to use when prefixing a glTF file\r\n     * @param dispose Dispose the exporter\r\n     * @returns GLTFData with glTF file data\r\n     */\r\n    public _generateGLTFAsync(glTFPrefix: string, dispose = true): Promise<GLTFData> {\r\n        return this._generateBinaryAsync().then((binaryBuffer) => {\r\n            this._extensionsOnExporting();\r\n            const jsonText = this.generateJSON(false, glTFPrefix, true);\r\n            const bin = new Blob([binaryBuffer], { type: 'application/octet-stream' });\r\n\r\n            const glTFFileName = glTFPrefix + '.gltf';\r\n            const glTFBinFile = glTFPrefix + '.bin';\r\n\r\n            const container = new GLTFData();\r\n\r\n            container.glTFFiles[glTFFileName] = jsonText;\r\n            container.glTFFiles[glTFBinFile] = bin;\r\n\r\n            if (this._imageData) {\r\n                for (let image in this._imageData) {\r\n                    container.glTFFiles[image] = new Blob([this._imageData[image].data], { type: this._imageData[image].mimeType });\r\n                }\r\n            }\r\n\r\n            if (dispose) {\r\n                this.dispose();\r\n            }\r\n\r\n            return container;\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Creates a binary buffer for glTF\r\n     * @returns array buffer for binary data\r\n     */\r\n    private _generateBinaryAsync(): Promise<ArrayBuffer> {\r\n        let binaryWriter = new _BinaryWriter(4);\r\n        return this.createSceneAsync(this._babylonScene, binaryWriter).then(() => {\r\n            if (this._localEngine) {\r\n                this._localEngine.dispose();\r\n            }\r\n            return binaryWriter.getArrayBuffer();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Pads the number to a multiple of 4\r\n     * @param num number to pad\r\n     * @returns padded number\r\n     */\r\n    private _getPadding(num: number): number {\r\n        let remainder = num % 4;\r\n        let padding = remainder === 0 ? remainder : 4 - remainder;\r\n\r\n        return padding;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _generateGLBAsync(glTFPrefix: string, dispose = true): Promise<GLTFData> {\r\n        return this._generateBinaryAsync().then((binaryBuffer) => {\r\n            this._extensionsOnExporting();\r\n            const jsonText = this.generateJSON(true);\r\n            const glbFileName = glTFPrefix + '.glb';\r\n            const headerLength = 12;\r\n            const chunkLengthPrefix = 8;\r\n            const jsonLength = jsonText.length;\r\n            let imageByteLength = 0;\r\n\r\n            for (let key in this._imageData) {\r\n                imageByteLength += this._imageData[key].data.byteLength;\r\n            }\r\n            const jsonPadding = this._getPadding(jsonLength);\r\n            const binPadding = this._getPadding(binaryBuffer.byteLength);\r\n            const imagePadding = this._getPadding(imageByteLength);\r\n\r\n            const byteLength = headerLength + (2 * chunkLengthPrefix) + jsonLength + jsonPadding + binaryBuffer.byteLength + binPadding + imageByteLength + imagePadding;\r\n\r\n            //header\r\n            const headerBuffer = new ArrayBuffer(headerLength);\r\n            const headerBufferView = new DataView(headerBuffer);\r\n            headerBufferView.setUint32(0, 0x46546C67, true); //glTF\r\n            headerBufferView.setUint32(4, 2, true); // version\r\n            headerBufferView.setUint32(8, byteLength, true); // total bytes in file\r\n\r\n            //json chunk\r\n            const jsonChunkBuffer = new ArrayBuffer(chunkLengthPrefix + jsonLength + jsonPadding);\r\n            const jsonChunkBufferView = new DataView(jsonChunkBuffer);\r\n            jsonChunkBufferView.setUint32(0, jsonLength + jsonPadding, true);\r\n            jsonChunkBufferView.setUint32(4, 0x4E4F534A, true);\r\n\r\n            //json chunk bytes\r\n            const jsonData = new Uint8Array(jsonChunkBuffer, chunkLengthPrefix);\r\n            for (let i = 0; i < jsonLength; ++i) {\r\n                jsonData[i] = jsonText.charCodeAt(i);\r\n            }\r\n\r\n            //json padding\r\n            const jsonPaddingView = new Uint8Array(jsonChunkBuffer, chunkLengthPrefix + jsonLength);\r\n            for (let i = 0; i < jsonPadding; ++i) {\r\n                jsonPaddingView[i] = 0x20;\r\n            }\r\n\r\n            //binary chunk\r\n            const binaryChunkBuffer = new ArrayBuffer(chunkLengthPrefix);\r\n            const binaryChunkBufferView = new DataView(binaryChunkBuffer);\r\n            binaryChunkBufferView.setUint32(0, binaryBuffer.byteLength + imageByteLength + imagePadding, true);\r\n            binaryChunkBufferView.setUint32(4, 0x004E4942, true);\r\n\r\n            // binary padding\r\n            const binPaddingBuffer = new ArrayBuffer(binPadding);\r\n            const binPaddingView = new Uint8Array(binPaddingBuffer);\r\n            for (let i = 0; i < binPadding; ++i) {\r\n                binPaddingView[i] = 0;\r\n            }\r\n\r\n            const imagePaddingBuffer = new ArrayBuffer(imagePadding);\r\n            const imagePaddingView = new Uint8Array(imagePaddingBuffer);\r\n            for (let i = 0; i < imagePadding; ++i) {\r\n                imagePaddingView[i] = 0;\r\n            }\r\n\r\n            const glbData = [headerBuffer, jsonChunkBuffer, binaryChunkBuffer, binaryBuffer];\r\n\r\n            // binary data\r\n            for (let key in this._imageData) {\r\n                glbData.push(this._imageData[key].data.buffer);\r\n            }\r\n            glbData.push(binPaddingBuffer);\r\n\r\n            glbData.push(imagePaddingBuffer);\r\n\r\n            const glbFile = new Blob(glbData, { type: 'application/octet-stream' });\r\n\r\n            const container = new GLTFData();\r\n            container.glTFFiles[glbFileName] = glbFile;\r\n\r\n            if (this._localEngine != null) {\r\n                this._localEngine.dispose();\r\n            }\r\n\r\n            if (dispose) {\r\n                this.dispose();\r\n            }\r\n\r\n            return container;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the TRS for each node\r\n     * @param node glTF Node for storing the transformation data\r\n     * @param babylonTransformNode Babylon mesh used as the source for the transformation data\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private setNodeTransformation(node: INode, babylonTransformNode: TransformNode, convertToRightHandedSystem: boolean): void {\r\n        if (!babylonTransformNode.getPivotPoint().equalsToFloats(0, 0, 0)) {\r\n            Tools.Warn(\"Pivot points are not supported in the glTF serializer\");\r\n        }\r\n        if (!babylonTransformNode.position.equalsToFloats(0, 0, 0)) {\r\n            node.translation = convertToRightHandedSystem ? _GLTFUtilities._GetRightHandedPositionVector3(babylonTransformNode.position).asArray() : babylonTransformNode.position.asArray();\r\n        }\r\n\r\n        if (!babylonTransformNode.scaling.equalsToFloats(1, 1, 1)) {\r\n            node.scale = babylonTransformNode.scaling.asArray();\r\n        }\r\n\r\n        let rotationQuaternion = Quaternion.RotationYawPitchRoll(babylonTransformNode.rotation.y, babylonTransformNode.rotation.x, babylonTransformNode.rotation.z);\r\n        if (babylonTransformNode.rotationQuaternion) {\r\n            rotationQuaternion.multiplyInPlace(babylonTransformNode.rotationQuaternion);\r\n        }\r\n        if (!(rotationQuaternion.x === 0 && rotationQuaternion.y === 0 && rotationQuaternion.z === 0 && rotationQuaternion.w === 1)) {\r\n            if (convertToRightHandedSystem) {\r\n                _GLTFUtilities._GetRightHandedQuaternionFromRef(rotationQuaternion);\r\n\r\n            }\r\n            node.rotation = rotationQuaternion.normalize().asArray();\r\n        }\r\n    }\r\n\r\n    private getVertexBufferFromMesh(attributeKind: string, bufferMesh: Mesh): Nullable<VertexBuffer> {\r\n        if (bufferMesh.isVerticesDataPresent(attributeKind)) {\r\n            const vertexBuffer = bufferMesh.getVertexBuffer(attributeKind);\r\n            if (vertexBuffer) {\r\n                return vertexBuffer;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a bufferview based on the vertices type for the Babylon mesh\r\n     * @param kind Indicates the type of vertices data\r\n     * @param babylonTransformNode The Babylon mesh to get the vertices data from\r\n     * @param binaryWriter The buffer to write the bufferview data to\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private createBufferViewKind(kind: string, babylonTransformNode: TransformNode, binaryWriter: _BinaryWriter, byteStride: number, convertToRightHandedSystem: boolean) {\r\n        const bufferMesh = babylonTransformNode instanceof Mesh ?\r\n            babylonTransformNode as Mesh : babylonTransformNode instanceof InstancedMesh ?\r\n                (babylonTransformNode as InstancedMesh).sourceMesh : null;\r\n\r\n        if (bufferMesh) {\r\n            const vertexData = bufferMesh.getVerticesData(kind);\r\n\r\n            if (vertexData) {\r\n                const byteLength = vertexData.length * 4;\r\n                const bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, byteStride, kind + \" - \" + bufferMesh.name);\r\n                this._bufferViews.push(bufferView);\r\n\r\n                this.writeAttributeData(\r\n                    kind,\r\n                    vertexData,\r\n                    byteStride,\r\n                    binaryWriter,\r\n                    convertToRightHandedSystem\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The primitive mode of the Babylon mesh\r\n     * @param babylonMesh The BabylonJS mesh\r\n     */\r\n    private getMeshPrimitiveMode(babylonMesh: AbstractMesh): number {\r\n        if (babylonMesh instanceof LinesMesh) {\r\n            return Material.LineListDrawMode;\r\n        }\r\n        return babylonMesh.material ? babylonMesh.material.fillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the primitive mode of the glTF mesh primitive\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param primitiveMode The primitive mode\r\n     */\r\n    private setPrimitiveMode(meshPrimitive: IMeshPrimitive, primitiveMode: number) {\r\n        switch (primitiveMode) {\r\n            case Material.TriangleFillMode: {\r\n                // glTF defaults to using Triangle Mode\r\n                break;\r\n            }\r\n            case Material.TriangleStripDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.TRIANGLE_STRIP;\r\n                break;\r\n            }\r\n            case Material.TriangleFanDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.TRIANGLE_FAN;\r\n                break;\r\n            }\r\n            case Material.PointListDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.POINTS;\r\n            }\r\n            case Material.PointFillMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.POINTS;\r\n                break;\r\n            }\r\n            case Material.LineLoopDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINE_LOOP;\r\n                break;\r\n            }\r\n            case Material.LineListDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINES;\r\n                break;\r\n            }\r\n            case Material.LineStripDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINE_STRIP;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex attribute accessor based of the glTF mesh primitive\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param attributeKind vertex attribute\r\n     * @returns boolean specifying if uv coordinates are present\r\n     */\r\n    private setAttributeKind(meshPrimitive: IMeshPrimitive, attributeKind: string): void {\r\n        switch (attributeKind) {\r\n            case VertexBuffer.PositionKind: {\r\n                meshPrimitive.attributes.POSITION = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.NormalKind: {\r\n                meshPrimitive.attributes.NORMAL = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.ColorKind: {\r\n                meshPrimitive.attributes.COLOR_0 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.TangentKind: {\r\n                meshPrimitive.attributes.TANGENT = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.UVKind: {\r\n                meshPrimitive.attributes.TEXCOORD_0 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.UV2Kind: {\r\n                meshPrimitive.attributes.TEXCOORD_1 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Vertex Buffer Type: \" + attributeKind);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets data for the primitive attributes of each submesh\r\n     * @param mesh glTF Mesh object to store the primitive attribute information\r\n     * @param babylonTransformNode Babylon mesh to get the primitive attribute data from\r\n     * @param binaryWriter Buffer to write the attribute data to\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     */\r\n    private setPrimitiveAttributesAsync(mesh: IMesh, babylonTransformNode: TransformNode, binaryWriter: _BinaryWriter, convertToRightHandedSystem: boolean): Promise<void> {\r\n        let promises: Promise<IMeshPrimitive>[] = [];\r\n        let bufferMesh: Nullable<Mesh> = null;\r\n        let bufferView: IBufferView;\r\n        let minMax: { min: Nullable<number[]>, max: Nullable<number[]> };\r\n\r\n        if (babylonTransformNode instanceof Mesh) {\r\n            bufferMesh = (babylonTransformNode as Mesh);\r\n        }\r\n        else if (babylonTransformNode instanceof InstancedMesh) {\r\n            bufferMesh = (babylonTransformNode as InstancedMesh).sourceMesh;\r\n        }\r\n        const attributeData: _IVertexAttributeData[] = [\r\n            { kind: VertexBuffer.PositionKind, accessorType: AccessorType.VEC3, byteStride: 12 },\r\n            { kind: VertexBuffer.NormalKind, accessorType: AccessorType.VEC3, byteStride: 12 },\r\n            { kind: VertexBuffer.ColorKind, accessorType: AccessorType.VEC4, byteStride: 16 },\r\n            { kind: VertexBuffer.TangentKind, accessorType: AccessorType.VEC4, byteStride: 16 },\r\n            { kind: VertexBuffer.UVKind, accessorType: AccessorType.VEC2, byteStride: 8 },\r\n            { kind: VertexBuffer.UV2Kind, accessorType: AccessorType.VEC2, byteStride: 8 },\r\n        ];\r\n\r\n        if (bufferMesh) {\r\n            let indexBufferViewIndex: Nullable<number> = null;\r\n            const primitiveMode = this.getMeshPrimitiveMode(bufferMesh);\r\n            let vertexAttributeBufferViews: { [attributeKind: string]: number } = {};\r\n\r\n            // For each BabylonMesh, create bufferviews for each 'kind'\r\n            for (const attribute of attributeData) {\r\n                const attributeKind = attribute.kind;\r\n                if (bufferMesh.isVerticesDataPresent(attributeKind)) {\r\n                    const vertexBuffer = this.getVertexBufferFromMesh(attributeKind, bufferMesh);\r\n                    attribute.byteStride = vertexBuffer ? vertexBuffer.getSize() * 4 : VertexBuffer.DeduceStride(attributeKind) * 4;\r\n                    if (attribute.byteStride === 12) {\r\n                        attribute.accessorType = AccessorType.VEC3;\r\n                    }\r\n\r\n                    this.createBufferViewKind(attributeKind, babylonTransformNode, binaryWriter, attribute.byteStride, convertToRightHandedSystem);\r\n                    attribute.bufferViewIndex = this._bufferViews.length - 1;\r\n                    vertexAttributeBufferViews[attributeKind] = attribute.bufferViewIndex;\r\n                }\r\n            }\r\n\r\n            if (bufferMesh.getTotalIndices()) {\r\n                const indices = bufferMesh.getIndices();\r\n                if (indices) {\r\n                    const byteLength = indices.length * 4;\r\n                    bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, \"Indices - \" + bufferMesh.name);\r\n                    this._bufferViews.push(bufferView);\r\n                    indexBufferViewIndex = this._bufferViews.length - 1;\r\n\r\n                    for (let k = 0, length = indices.length; k < length; ++k) {\r\n                        binaryWriter.setUInt32(indices[k]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (bufferMesh.subMeshes) {\r\n                // go through all mesh primitives (submeshes)\r\n                for (const submesh of bufferMesh.subMeshes) {\r\n                    let babylonMaterial = submesh.getMaterial() || bufferMesh.getScene().defaultMaterial;\r\n\r\n                    let materialIndex: Nullable<number> = null;\r\n                    if (babylonMaterial) {\r\n                        if (bufferMesh instanceof LinesMesh) {\r\n                            // get the color from the lines mesh and set it in the material\r\n                            const material: IMaterial = {\r\n                                name: bufferMesh.name + ' material'\r\n                            };\r\n                            if (!bufferMesh.color.equals(Color3.White()) || bufferMesh.alpha < 1) {\r\n                                material.pbrMetallicRoughness = {\r\n                                    baseColorFactor: bufferMesh.color.asArray().concat([bufferMesh.alpha])\r\n                                };\r\n                            }\r\n                            this._materials.push(material);\r\n                            materialIndex = this._materials.length - 1;\r\n                        }\r\n                        else if (babylonMaterial instanceof MultiMaterial) {\r\n                            const subMaterial = babylonMaterial.subMaterials[submesh.materialIndex];\r\n                            if (subMaterial) {\r\n                                babylonMaterial = subMaterial;\r\n                                materialIndex = this._materialMap[babylonMaterial.uniqueId];\r\n                            }\r\n                        }\r\n                        else {\r\n                            materialIndex = this._materialMap[babylonMaterial.uniqueId];\r\n                        }\r\n                    }\r\n\r\n                    let glTFMaterial: Nullable<IMaterial> = materialIndex != null ? this._materials[materialIndex] : null;\r\n\r\n                    const meshPrimitive: IMeshPrimitive = { attributes: {} };\r\n                    this.setPrimitiveMode(meshPrimitive, primitiveMode);\r\n\r\n                    for (const attribute of attributeData) {\r\n                        const attributeKind = attribute.kind;\r\n                        if (attributeKind === VertexBuffer.UVKind || attributeKind === VertexBuffer.UV2Kind) {\r\n                            if (glTFMaterial && !this._glTFMaterialExporter._hasTexturesPresent(glTFMaterial)) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        let vertexData = bufferMesh.getVerticesData(attributeKind);\r\n                        if (vertexData) {\r\n                            const vertexBuffer = this.getVertexBufferFromMesh(attributeKind, bufferMesh);\r\n                            if (vertexBuffer) {\r\n                                const stride = vertexBuffer.getSize();\r\n                                const bufferViewIndex = attribute.bufferViewIndex;\r\n                                if (bufferViewIndex != undefined) { // check to see if bufferviewindex has a numeric value assigned.\r\n                                    minMax = { min: null, max: null };\r\n                                    if (attributeKind == VertexBuffer.PositionKind) {\r\n                                        minMax = _GLTFUtilities._CalculateMinMaxPositions(vertexData, 0, vertexData.length / stride, convertToRightHandedSystem);\r\n                                    }\r\n                                    const accessor = _GLTFUtilities._CreateAccessor(bufferViewIndex, attributeKind + \" - \" + babylonTransformNode.name, attribute.accessorType, AccessorComponentType.FLOAT, vertexData.length / stride, 0, minMax.min, minMax.max);\r\n                                    this._accessors.push(accessor);\r\n                                    this.setAttributeKind(meshPrimitive, attributeKind);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if (indexBufferViewIndex) {\r\n                        // Create accessor\r\n                        const accessor = _GLTFUtilities._CreateAccessor(indexBufferViewIndex, \"indices - \" + babylonTransformNode.name, AccessorType.SCALAR, AccessorComponentType.UNSIGNED_INT, submesh.indexCount, submesh.indexStart * 4, null, null);\r\n                        this._accessors.push(accessor);\r\n                        meshPrimitive.indices = this._accessors.length - 1;\r\n                    }\r\n                    if (materialIndex != null && Object.keys(meshPrimitive.attributes).length > 0) {\r\n                        let sideOrientation = bufferMesh.overrideMaterialSideOrientation !== null ? bufferMesh.overrideMaterialSideOrientation : babylonMaterial.sideOrientation;\r\n\r\n                        if ((sideOrientation == Material.ClockWiseSideOrientation && this._babylonScene.useRightHandedSystem)\r\n                            || (sideOrientation == Material.ClockWiseSideOrientation && convertToRightHandedSystem && bufferMesh.overrideMaterialSideOrientation !== bufferMesh.material?.sideOrientation)) {\r\n                            let byteOffset = indexBufferViewIndex != null ? this._bufferViews[indexBufferViewIndex].byteOffset : null;\r\n                            if (byteOffset == null) { byteOffset = 0; }\r\n                            let babylonIndices: Nullable<IndicesArray> = null;\r\n                            if (indexBufferViewIndex != null) {\r\n                                babylonIndices = bufferMesh.getIndices();\r\n                            }\r\n                            if (babylonIndices) {\r\n                                this.reorderIndicesBasedOnPrimitiveMode(submesh, primitiveMode, babylonIndices, byteOffset, binaryWriter);\r\n                            }\r\n                            else {\r\n                                for (let attribute of attributeData) {\r\n                                    let vertexData = bufferMesh.getVerticesData(attribute.kind);\r\n                                    if (vertexData) {\r\n                                        let byteOffset = this._bufferViews[vertexAttributeBufferViews[attribute.kind]].byteOffset;\r\n                                        if (!byteOffset) {\r\n                                            byteOffset = 0;\r\n                                        }\r\n                                        this.reorderVertexAttributeDataBasedOnPrimitiveMode(submesh, primitiveMode, sideOrientation, attribute.kind, vertexData, byteOffset, binaryWriter, convertToRightHandedSystem);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        meshPrimitive.material = materialIndex;\r\n\r\n                    }\r\n                    mesh.primitives.push(meshPrimitive);\r\n\r\n                    const promise = this._extensionsPostExportMeshPrimitiveAsync(\"postExport\", meshPrimitive, submesh, binaryWriter);\r\n                    if (promise) {\r\n                        promises.push();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return Promise.all(promises).then(() => {\r\n            /* do nothing */\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if the node is used to convert its descendants from a right handed coordinate system to the Babylon scene's coordinate system.\r\n     * @param node The node to check\r\n     * @returns True if the node is used to convert its descendants from right-handed to left-handed. False otherwise\r\n     */\r\n    private isBabylonCoordinateSystemConvertingNode(node: Node): boolean {\r\n        if (node instanceof TransformNode)\r\n        {\r\n            if (node.name !== \"__root__\") {\r\n                return false;\r\n            }\r\n            // Transform\r\n            let matrix = node.getWorldMatrix();\r\n            let matrixToLeftHanded = Matrix.Compose(this._convertToRightHandedSystem ? new Vector3(-1, 1, 1) : Vector3.One(), Quaternion.Identity(), Vector3.Zero());\r\n            let matrixProduct = matrix.multiply(matrixToLeftHanded);\r\n            let matrixIdentity = Matrix.IdentityReadOnly;\r\n\r\n            for (let i = 0; i < 16; i++) {\r\n                if (Math.abs(matrixProduct.m[i] - matrixIdentity.m[i]) > Epsilon) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            // Geometry\r\n            if ((node instanceof Mesh && node.geometry !== null) ||\r\n                (node instanceof InstancedMesh && node.sourceMesh.geometry !== null)) {\r\n                return false;\r\n            }\r\n\r\n            if (this._includeCoordinateSystemConversionNodes) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF scene based on the array of meshes\r\n     * Returns the the total byte offset\r\n     * @param babylonScene Babylon scene to get the mesh data from\r\n     * @param binaryWriter Buffer to write binary data to\r\n     */\r\n    private createSceneAsync(babylonScene: Scene, binaryWriter: _BinaryWriter): Promise<void> {\r\n        const scene: IScene = { nodes: [] };\r\n        let glTFNodeIndex: number;\r\n        let glTFNode: INode;\r\n        let directDescendents: Node[];\r\n        const nodes: Node[] = [...babylonScene.transformNodes, ...babylonScene.meshes, ...babylonScene.lights];\r\n        let rootNodesToLeftHanded: Node[] = [];\r\n\r\n        this._convertToRightHandedSystem = !babylonScene.useRightHandedSystem;\r\n        this._convertToRightHandedSystemMap = {};\r\n\r\n        // Set default values for all nodes\r\n        babylonScene.rootNodes.forEach((rootNode) => {\r\n            this._convertToRightHandedSystemMap[rootNode.uniqueId] = this._convertToRightHandedSystem;\r\n            rootNode.getDescendants(false).forEach((descendant) => {\r\n                this._convertToRightHandedSystemMap[descendant.uniqueId] = this._convertToRightHandedSystem;\r\n            });\r\n        });\r\n\r\n        // Check if root nodes converting to left-handed are present\r\n        babylonScene.rootNodes.forEach((rootNode) => {\r\n            if (this.isBabylonCoordinateSystemConvertingNode(rootNode)) {\r\n                rootNodesToLeftHanded.push(rootNode);\r\n\r\n                // Exclude the node from list of nodes to export\r\n                const indexRootNode = nodes.indexOf(rootNode);\r\n                if (indexRootNode !== -1) { // should always be true\r\n                    nodes.splice(indexRootNode, 1);\r\n                }\r\n\r\n                // Cancel conversion to right handed system\r\n                rootNode.getDescendants(false).forEach((descendant) => {\r\n                    this._convertToRightHandedSystemMap[descendant.uniqueId] = false;\r\n                });\r\n            }\r\n        });\r\n\r\n        return this._glTFMaterialExporter._convertMaterialsToGLTFAsync(babylonScene.materials, ImageMimeType.PNG, true).then(() => {\r\n            return this.createNodeMapAndAnimationsAsync(babylonScene, nodes, binaryWriter).then((nodeMap) => {\r\n                this._nodeMap = nodeMap;\r\n\r\n                this._totalByteLength = binaryWriter.getByteOffset();\r\n                if (this._totalByteLength == undefined) {\r\n                    throw new Error(\"undefined byte length!\");\r\n                }\r\n\r\n                // Build Hierarchy with the node map.\r\n                for (let babylonNode of nodes) {\r\n                    glTFNodeIndex = this._nodeMap[babylonNode.uniqueId];\r\n                    if (glTFNodeIndex !== undefined) {\r\n                        glTFNode = this._nodes[glTFNodeIndex];\r\n\r\n                        if (babylonNode.metadata) {\r\n                            if (this._options.metadataSelector) {\r\n                                glTFNode.extras = this._options.metadataSelector(babylonNode.metadata);\r\n                            } else if (babylonNode.metadata.gltf) {\r\n                                glTFNode.extras = babylonNode.metadata.gltf.extras;\r\n                            }\r\n                        }\r\n\r\n                        if (!babylonNode.parent || rootNodesToLeftHanded.indexOf(babylonNode.parent) !== -1) {\r\n                            if (this._options.shouldExportNode && !this._options.shouldExportNode(babylonNode)) {\r\n                                Tools.Log(\"Omitting \" + babylonNode.name + \" from scene.\");\r\n                            }\r\n                            else {\r\n                                let convertToRightHandedSystem = this._convertToRightHandedSystemMap[babylonNode.uniqueId];\r\n                                if (convertToRightHandedSystem) {\r\n                                    if (glTFNode.translation) {\r\n                                        glTFNode.translation[2] *= -1;\r\n                                        glTFNode.translation[0] *= -1;\r\n                                    }\r\n                                    glTFNode.rotation = glTFNode.rotation ? Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(glTFNode.rotation)).asArray() : (Quaternion.FromArray([0, 1, 0, 0])).asArray();\r\n                                }\r\n\r\n                                scene.nodes.push(glTFNodeIndex);\r\n                            }\r\n                        }\r\n\r\n                        directDescendents = babylonNode.getDescendants(true);\r\n                        if (!glTFNode.children && directDescendents && directDescendents.length) {\r\n                            const children: number[] = [];\r\n                            for (let descendent of directDescendents) {\r\n                                if (this._nodeMap[descendent.uniqueId] != null) {\r\n                                    children.push(this._nodeMap[descendent.uniqueId]);\r\n                                }\r\n                            }\r\n                            if (children.length) {\r\n                                glTFNode.children = children;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (scene.nodes.length) {\r\n                    this._scenes.push(scene);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a mapping of Node unique id to node index and handles animations\r\n     * @param babylonScene Babylon Scene\r\n     * @param nodes Babylon transform nodes\r\n     * @param binaryWriter Buffer to write binary data to\r\n     * @returns Node mapping of unique id to index\r\n     */\r\n    private createNodeMapAndAnimationsAsync(babylonScene: Scene, nodes: Node[], binaryWriter: _BinaryWriter): Promise<{ [key: number]: number }> {\r\n        let promiseChain = Promise.resolve();\r\n        const nodeMap: { [key: number]: number } = {};\r\n        let nodeIndex: number;\r\n        let runtimeGLTFAnimation: IAnimation = {\r\n            name: 'runtime animations',\r\n            channels: [],\r\n            samplers: []\r\n        };\r\n        let idleGLTFAnimations: IAnimation[] = [];\r\n\r\n        for (let babylonNode of nodes) {\r\n            if (!this._options.shouldExportNode || this._options.shouldExportNode(babylonNode)) {\r\n                promiseChain = promiseChain.then(() => {\r\n                    let convertToRightHandedSystem = this._convertToRightHandedSystemMap[babylonNode.uniqueId];\r\n                    return this.createNodeAsync(babylonNode, binaryWriter, convertToRightHandedSystem, nodeMap).then((node) => {\r\n                        const promise = this._extensionsPostExportNodeAsync(\"createNodeAsync\", node, babylonNode, nodeMap);\r\n                        if (promise == null) {\r\n                            Tools.Warn(`Not exporting node ${babylonNode.name}`);\r\n                            return Promise.resolve();\r\n                        }\r\n                        else {\r\n                            return promise.then((node) => {\r\n                                if (!node) {\r\n                                    return;\r\n                                }\r\n                                this._nodes.push(node);\r\n                                nodeIndex = this._nodes.length - 1;\r\n                                nodeMap[babylonNode.uniqueId] = nodeIndex;\r\n\r\n                                if (!babylonScene.animationGroups.length && babylonNode.animations.length) {\r\n                                    _GLTFAnimation._CreateNodeAnimationFromNodeAnimations(babylonNode, runtimeGLTFAnimation, idleGLTFAnimations, nodeMap, this._nodes, binaryWriter, this._bufferViews, this._accessors, convertToRightHandedSystem, this._animationSampleRate);\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n            else {\r\n                `Excluding node ${babylonNode.name}`;\r\n            }\r\n        }\r\n\r\n        return promiseChain.then(() => {\r\n            if (runtimeGLTFAnimation.channels.length && runtimeGLTFAnimation.samplers.length) {\r\n                this._animations.push(runtimeGLTFAnimation);\r\n            }\r\n            idleGLTFAnimations.forEach((idleGLTFAnimation) => {\r\n                if (idleGLTFAnimation.channels.length && idleGLTFAnimation.samplers.length) {\r\n                    this._animations.push(idleGLTFAnimation);\r\n                }\r\n            });\r\n\r\n            if (babylonScene.animationGroups.length) {\r\n                _GLTFAnimation._CreateNodeAnimationFromAnimationGroups(babylonScene, this._animations, nodeMap, this._nodes, binaryWriter, this._bufferViews, this._accessors, this._convertToRightHandedSystemMap, this._animationSampleRate);\r\n            }\r\n\r\n            return nodeMap;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF node from a Babylon mesh\r\n     * @param babylonMesh Source Babylon mesh\r\n     * @param binaryWriter Buffer for storing geometry data\r\n     * @param convertToRightHandedSystem Converts the values to right-handed\r\n     * @param nodeMap Node mapping of unique id to glTF node index\r\n     * @returns glTF node\r\n     */\r\n    private createNodeAsync(babylonNode: Node, binaryWriter: _BinaryWriter, convertToRightHandedSystem: boolean, nodeMap?: {[key: number]: number}): Promise<INode> {\r\n        return Promise.resolve().then(() => {\r\n            // create node to hold translation/rotation/scale and the mesh\r\n            const node: INode = {};\r\n            // create mesh\r\n            const mesh: IMesh = { primitives: [] };\r\n\r\n            if (babylonNode.name) {\r\n                node.name = babylonNode.name;\r\n            }\r\n\r\n            if (babylonNode instanceof TransformNode) {\r\n                // Set transformation\r\n                this.setNodeTransformation(node, babylonNode, convertToRightHandedSystem);\r\n\r\n                return this.setPrimitiveAttributesAsync(mesh, babylonNode, binaryWriter, convertToRightHandedSystem).then(() => {\r\n                    if (mesh.primitives.length) {\r\n                        this._meshes.push(mesh);\r\n                        node.mesh = this._meshes.length - 1;\r\n                    }\r\n                    return node;\r\n                });\r\n            }\r\n            else {\r\n                return node;\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * @hidden\r\n *\r\n * Stores glTF binary data.  If the array buffer byte length is exceeded, it doubles in size dynamically\r\n */\r\nexport class _BinaryWriter {\r\n    /**\r\n     * Array buffer which stores all binary data\r\n     */\r\n    private _arrayBuffer: ArrayBuffer;\r\n    /**\r\n     * View of the array buffer\r\n     */\r\n    private _dataView: DataView;\r\n    /**\r\n     * byte offset of data in array buffer\r\n     */\r\n    private _byteOffset: number;\r\n    /**\r\n     * Initialize binary writer with an initial byte length\r\n     * @param byteLength Initial byte length of the array buffer\r\n     */\r\n    constructor(byteLength: number) {\r\n        this._arrayBuffer = new ArrayBuffer(byteLength);\r\n        this._dataView = new DataView(this._arrayBuffer);\r\n        this._byteOffset = 0;\r\n    }\r\n    /**\r\n     * Resize the array buffer to the specified byte length\r\n     * @param byteLength\r\n     */\r\n    private resizeBuffer(byteLength: number): ArrayBuffer {\r\n        let newBuffer = new ArrayBuffer(byteLength);\r\n        let oldUint8Array = new Uint8Array(this._arrayBuffer);\r\n        let newUint8Array = new Uint8Array(newBuffer);\r\n        for (let i = 0, length = newUint8Array.byteLength; i < length; ++i) {\r\n            newUint8Array[i] = oldUint8Array[i];\r\n        }\r\n        this._arrayBuffer = newBuffer;\r\n        this._dataView = new DataView(this._arrayBuffer);\r\n\r\n        return newBuffer;\r\n    }\r\n    /**\r\n     * Get an array buffer with the length of the byte offset\r\n     * @returns ArrayBuffer resized to the byte offset\r\n     */\r\n    public getArrayBuffer(): ArrayBuffer {\r\n        return this.resizeBuffer(this.getByteOffset());\r\n    }\r\n    /**\r\n     * Get the byte offset of the array buffer\r\n     * @returns byte offset\r\n     */\r\n    public getByteOffset(): number {\r\n        if (this._byteOffset == undefined) {\r\n            throw new Error(\"Byte offset is undefined!\");\r\n        }\r\n        return this._byteOffset;\r\n    }\r\n    /**\r\n     * Stores an UInt8 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setUInt8(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setUint8(byteOffset, entry);\r\n            }\r\n            else {\r\n                Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n            }\r\n        }\r\n        else {\r\n            if (this._byteOffset + 1 > this._arrayBuffer.byteLength) {\r\n                this.resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setUint8(this._byteOffset++, entry);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets an UInt32 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public getUInt32(byteOffset: number): number {\r\n        if (byteOffset < this._byteOffset) {\r\n            return this._dataView.getUint32(byteOffset, true);\r\n        }\r\n        else {\r\n            Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n            throw new Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n        }\r\n    }\r\n\r\n    public getVector3Float32FromRef(vector3: Vector3, byteOffset: number): void {\r\n        if (byteOffset + 8 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            vector3.x = this._dataView.getFloat32(byteOffset, true);\r\n            vector3.y = this._dataView.getFloat32(byteOffset + 4, true);\r\n            vector3.z = this._dataView.getFloat32(byteOffset + 8, true);\r\n        }\r\n    }\r\n\r\n    public setVector3Float32FromRef(vector3: Vector3, byteOffset: number): void {\r\n        if (byteOffset + 8 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            this._dataView.setFloat32(byteOffset, vector3.x, true);\r\n            this._dataView.setFloat32(byteOffset + 4, vector3.y, true);\r\n            this._dataView.setFloat32(byteOffset + 8, vector3.z, true);\r\n        }\r\n    }\r\n\r\n    public getVector4Float32FromRef(vector4: Vector4, byteOffset: number): void {\r\n        if (byteOffset + 12 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            vector4.x = this._dataView.getFloat32(byteOffset, true);\r\n            vector4.y = this._dataView.getFloat32(byteOffset + 4, true);\r\n            vector4.z = this._dataView.getFloat32(byteOffset + 8, true);\r\n            vector4.w = this._dataView.getFloat32(byteOffset + 12, true);\r\n        }\r\n    }\r\n\r\n    public setVector4Float32FromRef(vector4: Vector4, byteOffset: number): void {\r\n        if (byteOffset + 12 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            this._dataView.setFloat32(byteOffset, vector4.x, true);\r\n            this._dataView.setFloat32(byteOffset + 4, vector4.y, true);\r\n            this._dataView.setFloat32(byteOffset + 8, vector4.z, true);\r\n            this._dataView.setFloat32(byteOffset + 12, vector4.w, true);\r\n        }\r\n    }\r\n    /**\r\n     * Stores a Float32 in the array buffer\r\n     * @param entry\r\n     */\r\n    public setFloat32(entry: number, byteOffset?: number) {\r\n        if (isNaN(entry)) {\r\n            Tools.Error('Invalid data being written!');\r\n        }\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setFloat32(byteOffset, entry, true);\r\n            }\r\n            else {\r\n                Tools.Error('BinaryWriter: byteoffset is greater than the current binary length!');\r\n            }\r\n        }\r\n        if (this._byteOffset + 4 > this._arrayBuffer.byteLength) {\r\n            this.resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n        }\r\n        this._dataView.setFloat32(this._byteOffset, entry, true);\r\n        this._byteOffset += 4;\r\n    }\r\n    /**\r\n     * Stores an UInt32 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setUInt32(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setUint32(byteOffset, entry, true);\r\n            }\r\n            else {\r\n                Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n            }\r\n        }\r\n        else {\r\n            if (this._byteOffset + 4 > this._arrayBuffer.byteLength) {\r\n                this.resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setUint32(this._byteOffset, entry, true);\r\n            this._byteOffset += 4;\r\n        }\r\n    }\r\n}","import { ImageMimeType, IMeshPrimitive, INode, IMaterial, ITextureInfo } from \"babylonjs-gltf2interface\";\r\nimport { Node } from \"babylonjs/node\";\r\nimport { Nullable } from \"babylonjs/types\";\r\n\r\nimport { Texture } from \"babylonjs/Materials/Textures/texture\";\r\nimport { SubMesh } from \"babylonjs/Meshes/subMesh\";\r\nimport { IDisposable } from \"babylonjs/scene\";\r\n\r\nimport { _BinaryWriter } from \"./glTFExporter\";\r\nimport { IGLTFExporterExtension } from \"../glTFFileExporter\";\r\nimport { Material } from 'babylonjs/Materials/material';\r\nimport { BaseTexture } from 'babylonjs/Materials/Textures/baseTexture';\r\n\r\n/** @hidden */\r\nexport var __IGLTFExporterExtensionV2 = 0; // I am here to allow dts to be created\r\n\r\n/**\r\n * Interface for a glTF exporter extension\r\n * @hidden\r\n */\r\nexport interface IGLTFExporterExtensionV2 extends IGLTFExporterExtension, IDisposable {\r\n    /**\r\n     * Define this method to modify the default behavior before exporting a texture\r\n     * @param context The context when loading the asset\r\n     * @param babylonTexture The Babylon.js texture\r\n     * @param mimeType The mime-type of the generated image\r\n     * @returns A promise that resolves with the exported texture\r\n     */\r\n    preExportTextureAsync?(context: string, babylonTexture: Nullable<Texture>, mimeType: ImageMimeType): Promise<Texture>;\r\n\r\n    /**\r\n     * Define this method to get notified when a texture info is created\r\n     * @param context The context when loading the asset\r\n     * @param textureInfo The glTF texture info\r\n     * @param babylonTexture The Babylon.js texture\r\n     */\r\n    postExportTexture?(context: string, textureInfo: ITextureInfo, babylonTexture: BaseTexture): void;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when exporting texture info\r\n     * @param context The context when loading the asset\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param babylonSubMesh Babylon submesh\r\n     * @param binaryWriter glTF serializer binary writer instance\r\n     * @returns nullable IMeshPrimitive promise\r\n     */\r\n    postExportMeshPrimitiveAsync?(context: string, meshPrimitive: Nullable<IMeshPrimitive>, babylonSubMesh: SubMesh, binaryWriter: _BinaryWriter): Promise<IMeshPrimitive>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when exporting a node\r\n     * @param context The context when exporting the node\r\n     * @param node glTF node\r\n     * @param babylonNode BabylonJS node\r\n     * @returns nullable INode promise\r\n     */\r\n    postExportNodeAsync?(context: string, node: Nullable<INode>, babylonNode: Node, nodeMap?: {[key: number]: number}): Promise<Nullable<INode>>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when exporting a material\r\n     * @param material glTF material\r\n     * @param babylonMaterial BabylonJS material\r\n     * @returns nullable IMaterial promise\r\n     */\r\n    postExportMaterialAsync?(context: string, node: Nullable<IMaterial>, babylonMaterial: Material): Promise<IMaterial>;\r\n\r\n    /**\r\n     * Define this method to return additional textures to export from a material\r\n     * @param material glTF material\r\n     * @param babylonMaterial BabylonJS material\r\n     * @returns List of textures\r\n     */\r\n    postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[];\r\n\r\n    /** Gets a boolean indicating that this extension was used */\r\n    wasUsed: boolean;\r\n\r\n    /** Gets a boolean indicating that this extension is required for the file to work */\r\n    required: boolean;\r\n\r\n    /**\r\n     * Called after the exporter state changes to EXPORTING\r\n     */\r\n    onExporting?(): void;\r\n}","import { ITextureInfo, ImageMimeType, IMaterial, IMaterialPbrMetallicRoughness, MaterialAlphaMode, IMaterialOcclusionTextureInfo, ISampler, TextureMagFilter, TextureMinFilter, TextureWrapMode, ITexture, IImage } from \"babylonjs-gltf2interface\";\r\n\r\nimport { Nullable } from \"babylonjs/types\";\r\nimport { Vector2 } from \"babylonjs/Maths/math.vector\";\r\nimport { Color3 } from \"babylonjs/Maths/math.color\";\r\nimport { Scalar } from \"babylonjs/Maths/math.scalar\";\r\nimport { Tools } from \"babylonjs/Misc/tools\";\r\nimport { TextureTools } from \"babylonjs/Misc/textureTools\";\r\nimport { BaseTexture } from \"babylonjs/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"babylonjs/Materials/Textures/texture\";\r\nimport { RawTexture } from \"babylonjs/Materials/Textures/rawTexture\";\r\nimport { Material } from \"babylonjs/Materials/material\";\r\nimport { StandardMaterial } from \"babylonjs/Materials/standardMaterial\";\r\nimport { PBRMaterial } from \"babylonjs/Materials/PBR/pbrMaterial\";\r\nimport { PBRMetallicRoughnessMaterial } from \"babylonjs/Materials/PBR/pbrMetallicRoughnessMaterial\";\r\nimport { PostProcess } from \"babylonjs/PostProcesses/postProcess\";\r\nimport { Scene } from \"babylonjs/scene\";\r\n\r\nimport { _Exporter } from \"./glTFExporter\";\r\nimport { Constants } from 'babylonjs/Engines/constants';\r\n\r\n/**\r\n * Interface for storing specular glossiness factors\r\n * @hidden\r\n */\r\ninterface _IPBRSpecularGlossiness {\r\n    /**\r\n     * Represents the linear diffuse factors of the material\r\n    */\r\n    diffuseColor: Color3;\r\n    /**\r\n     * Represents the linear specular factors of the material\r\n    */\r\n    specularColor: Color3;\r\n    /**\r\n     * Represents the smoothness of the material\r\n    */\r\n    glossiness: number;\r\n}\r\n\r\n/**\r\n * Interface for storing metallic roughness factors\r\n * @hidden\r\n */\r\ninterface _IPBRMetallicRoughness {\r\n    /**\r\n     * Represents the albedo color of the material\r\n    */\r\n    baseColor: Color3;\r\n    /**\r\n     * Represents the metallness of the material\r\n    */\r\n    metallic: Nullable<number>;\r\n    /**\r\n     * Represents the roughness of the material\r\n    */\r\n    roughness: Nullable<number>;\r\n    /**\r\n     * The metallic roughness texture as a base64 string\r\n    */\r\n    metallicRoughnessTextureBase64?: Nullable<string>;\r\n    /**\r\n     * The base color texture as a base64 string\r\n    */\r\n    baseColorTextureBase64?: Nullable<string>;\r\n}\r\n\r\n/**\r\n * Utility methods for working with glTF material conversion properties.  This class should only be used internally\r\n * @hidden\r\n */\r\nexport class _GLTFMaterialExporter {\r\n    /**\r\n     * Represents the dielectric specular values for R, G and B\r\n     */\r\n    private static readonly _DielectricSpecular: Color3 = new Color3(0.04, 0.04, 0.04);\r\n\r\n    /**\r\n     * Allows the maximum specular power to be defined for material calculations\r\n     */\r\n    private static readonly _MaxSpecularPower = 1024;\r\n\r\n    /**\r\n     * Mapping to store textures\r\n     */\r\n    private _textureMap: { [textureId: string]: ITextureInfo } = {};\r\n\r\n    /**\r\n     * Numeric tolerance value\r\n     */\r\n    private static readonly _Epsilon = 1e-6;\r\n\r\n    /**\r\n     * Reference to the glTF Exporter\r\n     */\r\n    private _exporter: _Exporter;\r\n\r\n    constructor(exporter: _Exporter) {\r\n        this._textureMap = {};\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /**\r\n     * Specifies if two colors are approximately equal in value\r\n     * @param color1 first color to compare to\r\n     * @param color2 second color to compare to\r\n     * @param epsilon threshold value\r\n     */\r\n    private static FuzzyEquals(color1: Color3, color2: Color3, epsilon: number): boolean {\r\n        return Scalar.WithinEpsilon(color1.r, color2.r, epsilon) &&\r\n            Scalar.WithinEpsilon(color1.g, color2.g, epsilon) &&\r\n            Scalar.WithinEpsilon(color1.b, color2.b, epsilon);\r\n    }\r\n\r\n    /**\r\n     * Gets the materials from a Babylon scene and converts them to glTF materials\r\n     * @param scene babylonjs scene\r\n     * @param mimeType texture mime type\r\n     * @param images array of images\r\n     * @param textures array of textures\r\n     * @param materials array of materials\r\n     * @param imageData mapping of texture names to base64 textures\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the material\r\n     */\r\n    public _convertMaterialsToGLTFAsync(babylonMaterials: Material[], mimeType: ImageMimeType, hasTextureCoords: boolean) {\r\n        let promises: Promise<IMaterial>[] = [];\r\n        for (let babylonMaterial of babylonMaterials) {\r\n            if (babylonMaterial instanceof StandardMaterial) {\r\n                promises.push(this._convertStandardMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));\r\n            }\r\n            else if (babylonMaterial instanceof PBRMetallicRoughnessMaterial) {\r\n                promises.push(this._convertPBRMetallicRoughnessMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));\r\n            }\r\n            else if (babylonMaterial instanceof PBRMaterial) {\r\n                promises.push(this._convertPBRMaterialAsync(babylonMaterial, mimeType, hasTextureCoords));\r\n            }\r\n            else {\r\n                Tools.Warn(`Unsupported material type: ${babylonMaterial.name}`);\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => { /* do nothing */ });\r\n    }\r\n\r\n    /**\r\n     * Makes a copy of the glTF material without the texture parameters\r\n     * @param originalMaterial original glTF material\r\n     * @returns glTF material without texture parameters\r\n     */\r\n    public _stripTexturesFromMaterial(originalMaterial: IMaterial): IMaterial {\r\n        let newMaterial: IMaterial = {};\r\n        if (originalMaterial) {\r\n            newMaterial.name = originalMaterial.name;\r\n            newMaterial.doubleSided = originalMaterial.doubleSided;\r\n            newMaterial.alphaMode = originalMaterial.alphaMode;\r\n            newMaterial.alphaCutoff = originalMaterial.alphaCutoff;\r\n            newMaterial.emissiveFactor = originalMaterial.emissiveFactor;\r\n            const originalPBRMetallicRoughness = originalMaterial.pbrMetallicRoughness;\r\n            if (originalPBRMetallicRoughness) {\r\n                newMaterial.pbrMetallicRoughness = {};\r\n                newMaterial.pbrMetallicRoughness.baseColorFactor = originalPBRMetallicRoughness.baseColorFactor;\r\n                newMaterial.pbrMetallicRoughness.metallicFactor = originalPBRMetallicRoughness.metallicFactor;\r\n                newMaterial.pbrMetallicRoughness.roughnessFactor = originalPBRMetallicRoughness.roughnessFactor;\r\n            }\r\n        }\r\n        return newMaterial;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material has any texture parameters present\r\n     * @param material glTF Material\r\n     * @returns boolean specifying if texture parameters are present\r\n     */\r\n    public _hasTexturesPresent(material: IMaterial): boolean {\r\n        if (material.emissiveTexture || material.normalTexture || material.occlusionTexture) {\r\n            return true;\r\n        }\r\n        const pbrMat = material.pbrMetallicRoughness;\r\n        if (pbrMat) {\r\n            if (pbrMat.baseColorTexture || pbrMat.metallicRoughnessTexture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon StandardMaterial to a glTF Metallic Roughness Material\r\n     * @param babylonStandardMaterial\r\n     * @returns glTF Metallic Roughness Material representation\r\n     */\r\n    public _convertToGLTFPBRMetallicRoughness(babylonStandardMaterial: StandardMaterial): IMaterialPbrMetallicRoughness {\r\n        const P0 = new Vector2(0, 1);\r\n        const P1 = new Vector2(0, 0.1);\r\n        const P2 = new Vector2(0, 0.1);\r\n        const P3 = new Vector2(1300, 0.1);\r\n\r\n        /**\r\n         * Given the control points, solve for x based on a given t for a cubic bezier curve\r\n         * @param t a value between 0 and 1\r\n         * @param p0 first control point\r\n         * @param p1 second control point\r\n         * @param p2 third control point\r\n         * @param p3 fourth control point\r\n         * @returns number result of cubic bezier curve at the specified t\r\n         */\r\n        function _cubicBezierCurve(t: number, p0: number, p1: number, p2: number, p3: number): number {\r\n            return (\r\n                (1 - t) * (1 - t) * (1 - t) * p0 +\r\n                3 * (1 - t) * (1 - t) * t * p1 +\r\n                3 * (1 - t) * t * t * p2 +\r\n                t * t * t * p3\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Evaluates a specified specular power value to determine the appropriate roughness value,\r\n         * based on a pre-defined cubic bezier curve with specular on the abscissa axis (x-axis)\r\n         * and roughness on the ordinant axis (y-axis)\r\n         * @param specularPower specular power of standard material\r\n         * @returns Number representing the roughness value\r\n         */\r\n        function _solveForRoughness(specularPower: number): number {\r\n            var t = Math.pow(specularPower / P3.x, 0.333333);\r\n            return _cubicBezierCurve(t, P0.y, P1.y, P2.y, P3.y);\r\n        }\r\n\r\n        let diffuse = babylonStandardMaterial.diffuseColor.toLinearSpace().scale(0.5);\r\n        let opacity = babylonStandardMaterial.alpha;\r\n        let specularPower = Scalar.Clamp(babylonStandardMaterial.specularPower, 0, _GLTFMaterialExporter._MaxSpecularPower);\r\n\r\n        const roughness = _solveForRoughness(specularPower);\r\n\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {\r\n            baseColorFactor: [\r\n                diffuse.r,\r\n                diffuse.g,\r\n                diffuse.b,\r\n                opacity\r\n            ],\r\n            metallicFactor: 0,\r\n            roughnessFactor: roughness,\r\n        };\r\n\r\n        return glTFPbrMetallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Computes the metallic factor\r\n     * @param diffuse diffused value\r\n     * @param specular specular value\r\n     * @param oneMinusSpecularStrength one minus the specular strength\r\n     * @returns metallic value\r\n     */\r\n    public static _SolveMetallic(diffuse: number, specular: number, oneMinusSpecularStrength: number): number {\r\n        if (specular < this._DielectricSpecular.r) {\r\n            this._DielectricSpecular;\r\n            return 0;\r\n        }\r\n\r\n        const a = this._DielectricSpecular.r;\r\n        const b = diffuse * oneMinusSpecularStrength / (1.0 - this._DielectricSpecular.r) + specular - 2.0 * this._DielectricSpecular.r;\r\n        const c = this._DielectricSpecular.r - specular;\r\n        const D = b * b - 4.0 * a * c;\r\n        return Scalar.Clamp((-b + Math.sqrt(D)) / (2.0 * a), 0, 1);\r\n    }\r\n\r\n    /**\r\n     * Sets the glTF alpha mode to a glTF material from the Babylon Material\r\n     * @param glTFMaterial glTF material\r\n     * @param babylonMaterial Babylon material\r\n     */\r\n    private static _SetAlphaMode(glTFMaterial: IMaterial, babylonMaterial: Material & { alphaCutOff: number }): void {\r\n        if (babylonMaterial.needAlphaBlending()) {\r\n            glTFMaterial.alphaMode = MaterialAlphaMode.BLEND;\r\n        }\r\n        else if (babylonMaterial.needAlphaTesting()) {\r\n            glTFMaterial.alphaMode = MaterialAlphaMode.MASK;\r\n            glTFMaterial.alphaCutoff = babylonMaterial.alphaCutOff;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon Standard Material to a glTF Material\r\n     * @param babylonStandardMaterial BJS Standard Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param materials array of glTF material interfaces\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertStandardMaterialAsync(babylonStandardMaterial: StandardMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<IMaterial> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        const promises = [];\r\n        const glTFPbrMetallicRoughness = this._convertToGLTFPBRMetallicRoughness(babylonStandardMaterial);\r\n\r\n        const glTFMaterial: IMaterial = { name: babylonStandardMaterial.name };\r\n        if (babylonStandardMaterial.backFaceCulling != null && !babylonStandardMaterial.backFaceCulling) {\r\n            if (!babylonStandardMaterial.twoSidedLighting) {\r\n                Tools.Warn(babylonStandardMaterial.name + \": Back-face culling enabled and two-sided lighting disabled is not supported in glTF.\");\r\n            }\r\n            glTFMaterial.doubleSided = true;\r\n        }\r\n        if (hasTextureCoords) {\r\n            if (babylonStandardMaterial.diffuseTexture) {\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.diffuseTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonStandardMaterial.bumpTexture) {\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.bumpTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.normalTexture = glTFTexture;\r\n                        if (babylonStandardMaterial.bumpTexture != null && babylonStandardMaterial.bumpTexture.level !== 1) {\r\n                            glTFMaterial.normalTexture.scale = babylonStandardMaterial.bumpTexture.level;\r\n                        }\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonStandardMaterial.emissiveTexture) {\r\n                glTFMaterial.emissiveFactor = [1.0, 1.0, 1.0];\r\n\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.emissiveTexture, mimeType).then((glTFEmissiveTexture) => {\r\n                    if (glTFEmissiveTexture) {\r\n                        glTFMaterial.emissiveTexture = glTFEmissiveTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonStandardMaterial.ambientTexture) {\r\n                promises.push(this._exportTextureAsync(babylonStandardMaterial.ambientTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        const occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                            index: glTFTexture.index\r\n                        };\r\n                        glTFMaterial.occlusionTexture = occlusionTexture;\r\n                        occlusionTexture.strength = 1.0;\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n\r\n        if (babylonStandardMaterial.alpha < 1.0 || babylonStandardMaterial.opacityTexture) {\r\n            if (babylonStandardMaterial.alphaMode === Constants.ALPHA_COMBINE) {\r\n                glTFMaterial.alphaMode = MaterialAlphaMode.BLEND;\r\n            }\r\n            else {\r\n                Tools.Warn(babylonStandardMaterial.name + \": glTF 2.0 does not support alpha mode: \" + babylonStandardMaterial.alphaMode.toString());\r\n            }\r\n        }\r\n        if (babylonStandardMaterial.emissiveColor && !_GLTFMaterialExporter.FuzzyEquals(babylonStandardMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n            glTFMaterial.emissiveFactor = babylonStandardMaterial.emissiveColor.asArray();\r\n        }\r\n\r\n        glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n        _GLTFMaterialExporter._SetAlphaMode(glTFMaterial, babylonStandardMaterial);\r\n\r\n        materials.push(glTFMaterial);\r\n        materialMap[babylonStandardMaterial.uniqueId] = materials.length - 1;\r\n\r\n        return this._finishMaterial(promises, glTFMaterial, babylonStandardMaterial, mimeType);\r\n    }\r\n\r\n    private _finishMaterial<T>(promises: Promise<T>[], glTFMaterial: IMaterial, babylonMaterial: Material, mimeType: ImageMimeType) {\r\n        return Promise.all(promises).then(() => {\r\n\r\n            const textures = this._exporter._extensionsPostExportMaterialAdditionalTextures(\"exportMaterial\", glTFMaterial, babylonMaterial);\r\n            let tasks: Nullable<Promise<Nullable<ITextureInfo>>[]> = null;\r\n\r\n            for (var texture of textures) {\r\n                if (!tasks) {\r\n                    tasks = [];\r\n                }\r\n                tasks.push(this._exportTextureAsync(texture, mimeType));\r\n            }\r\n\r\n            if (!tasks) {\r\n                tasks = [Promise.resolve(null)];\r\n            }\r\n\r\n            return Promise.all(tasks).then(() => {\r\n                let extensionWork = this._exporter._extensionsPostExportMaterialAsync(\"exportMaterial\", glTFMaterial, babylonMaterial);\r\n                if (!extensionWork) {\r\n                    return glTFMaterial;\r\n                }\r\n                return extensionWork.then(() => glTFMaterial);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon PBR Metallic Roughness Material to a glTF Material\r\n     * @param babylonPBRMetalRoughMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param materials array of glTF material interfaces\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertPBRMetallicRoughnessMaterialAsync(babylonPBRMetalRoughMaterial: PBRMetallicRoughnessMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<IMaterial> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        let promises: Promise<void>[] = [];\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {};\r\n\r\n        if (babylonPBRMetalRoughMaterial.baseColor) {\r\n            glTFPbrMetallicRoughness.baseColorFactor = [\r\n                babylonPBRMetalRoughMaterial.baseColor.r,\r\n                babylonPBRMetalRoughMaterial.baseColor.g,\r\n                babylonPBRMetalRoughMaterial.baseColor.b,\r\n                babylonPBRMetalRoughMaterial.alpha\r\n            ];\r\n        }\r\n\r\n        if (babylonPBRMetalRoughMaterial.metallic != null && babylonPBRMetalRoughMaterial.metallic !== 1) {\r\n            glTFPbrMetallicRoughness.metallicFactor = babylonPBRMetalRoughMaterial.metallic;\r\n        }\r\n        if (babylonPBRMetalRoughMaterial.roughness != null && babylonPBRMetalRoughMaterial.roughness !== 1) {\r\n            glTFPbrMetallicRoughness.roughnessFactor = babylonPBRMetalRoughMaterial.roughness;\r\n        }\r\n\r\n        const glTFMaterial: IMaterial = {\r\n            name: babylonPBRMetalRoughMaterial.name\r\n        };\r\n        if (babylonPBRMetalRoughMaterial.doubleSided) {\r\n            glTFMaterial.doubleSided = babylonPBRMetalRoughMaterial.doubleSided;\r\n        }\r\n        _GLTFMaterialExporter._SetAlphaMode(glTFMaterial, babylonPBRMetalRoughMaterial);\r\n        if (hasTextureCoords) {\r\n            if (babylonPBRMetalRoughMaterial.baseTexture != null) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.baseTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonPBRMetalRoughMaterial.normalTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.normalTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.normalTexture = glTFTexture;\r\n                        if (babylonPBRMetalRoughMaterial.normalTexture.level !== 1) {\r\n                            glTFMaterial.normalTexture.scale = babylonPBRMetalRoughMaterial.normalTexture.level;\r\n                        }\r\n                    }\r\n                }));\r\n\r\n            }\r\n            if (babylonPBRMetalRoughMaterial.occlusionTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.occlusionTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.occlusionTexture = glTFTexture;\r\n                        if (babylonPBRMetalRoughMaterial.occlusionStrength != null) {\r\n                            glTFMaterial.occlusionTexture.strength = babylonPBRMetalRoughMaterial.occlusionStrength;\r\n                        }\r\n                    }\r\n                }));\r\n\r\n            }\r\n            if (babylonPBRMetalRoughMaterial.emissiveTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMetalRoughMaterial.emissiveTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFMaterial.emissiveTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n\r\n        }\r\n\r\n        if (_GLTFMaterialExporter.FuzzyEquals(babylonPBRMetalRoughMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n            glTFMaterial.emissiveFactor = babylonPBRMetalRoughMaterial.emissiveColor.asArray();\r\n        }\r\n\r\n        glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n\r\n        materials.push(glTFMaterial);\r\n        materialMap[babylonPBRMetalRoughMaterial.uniqueId] = materials.length - 1;\r\n\r\n        return this._finishMaterial(promises, glTFMaterial, babylonPBRMetalRoughMaterial, mimeType);\r\n    }\r\n\r\n    /**\r\n     * Converts an image typed array buffer to a base64 image\r\n     * @param buffer typed array buffer\r\n     * @param width width of the image\r\n     * @param height height of the image\r\n     * @param mimeType mimetype of the image\r\n     * @returns base64 image string\r\n     */\r\n    private _createBase64FromCanvasAsync(buffer: Uint8Array | Float32Array, width: number, height: number, mimeType: ImageMimeType): Promise<string> {\r\n        return new Promise<string>((resolve, reject) => {\r\n            let hostingScene: Scene;\r\n\r\n            const textureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            const engine = this._exporter._getLocalEngine();\r\n\r\n            hostingScene = new Scene(engine);\r\n\r\n            // Create a temporary texture with the texture buffer data\r\n            const tempTexture = engine.createRawTexture(buffer, width, height, Constants.TEXTUREFORMAT_RGBA, false, true, Texture.NEAREST_SAMPLINGMODE, null, textureType);\r\n            const postProcess = new PostProcess(\"pass\", \"pass\", null, null, 1, null, Texture.NEAREST_SAMPLINGMODE, engine, false, undefined, Constants.TEXTURETYPE_UNSIGNED_INT, undefined, null, false);\r\n            postProcess.getEffect().executeWhenCompiled(() => {\r\n                postProcess.onApply = (effect) => {\r\n                    effect._bindTexture(\"textureSampler\", tempTexture);\r\n                };\r\n\r\n                // Set the size of the texture\r\n                engine.setSize(width, height);\r\n                hostingScene.postProcessManager.directRender([postProcess], null);\r\n                postProcess.dispose();\r\n                tempTexture.dispose();\r\n\r\n                // Read data from WebGL\r\n                const canvas = engine.getRenderingCanvas();\r\n\r\n                if (canvas) {\r\n                    if (!canvas.toBlob) { // fallback for browsers without \"canvas.toBlob\"\r\n                        const dataURL = canvas.toDataURL();\r\n                        resolve(dataURL);\r\n                    }\r\n                    else {\r\n                        Tools.ToBlob(canvas, (blob) => {\r\n                            if (blob) {\r\n                                let fileReader = new FileReader();\r\n                                fileReader.onload = (event: any) => {\r\n                                    let base64String = event.target.result as string;\r\n                                    hostingScene.dispose();\r\n                                    resolve(base64String);\r\n                                };\r\n                                fileReader.readAsDataURL(blob);\r\n                            }\r\n                            else {\r\n                                reject(\"gltfMaterialExporter: Failed to get blob from image canvas!\");\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    reject(\"Engine is missing a canvas!\");\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generates a white texture based on the specified width and height\r\n     * @param width width of the texture in pixels\r\n     * @param height height of the texture in pixels\r\n     * @param scene babylonjs scene\r\n     * @returns white texture\r\n     */\r\n    private _createWhiteTexture(width: number, height: number, scene: Scene): Texture {\r\n        const data = new Uint8Array(width * height * 4);\r\n\r\n        for (let i = 0; i < data.length; i = i + 4) {\r\n            data[i] = data[i + 1] = data[i + 2] = data[i + 3] = 0xFF;\r\n        }\r\n\r\n        const rawTexture = RawTexture.CreateRGBATexture(data, width, height, scene);\r\n\r\n        return rawTexture;\r\n    }\r\n\r\n    /**\r\n     * Resizes the two source textures to the same dimensions.  If a texture is null, a default white texture is generated.  If both textures are null, returns null\r\n     * @param texture1 first texture to resize\r\n     * @param texture2 second texture to resize\r\n     * @param scene babylonjs scene\r\n     * @returns resized textures or null\r\n     */\r\n    private _resizeTexturesToSameDimensions(texture1: BaseTexture, texture2: BaseTexture, scene: Scene): { \"texture1\": BaseTexture, \"texture2\": BaseTexture } {\r\n        let texture1Size = texture1 ? texture1.getSize() : { width: 0, height: 0 };\r\n        let texture2Size = texture2 ? texture2.getSize() : { width: 0, height: 0 };\r\n        let resizedTexture1;\r\n        let resizedTexture2;\r\n\r\n        if (texture1Size.width < texture2Size.width) {\r\n            if (texture1 && texture1 instanceof Texture) {\r\n                resizedTexture1 = TextureTools.CreateResizedCopy(texture1, texture2Size.width, texture2Size.height, true);\r\n            }\r\n            else {\r\n                resizedTexture1 = this._createWhiteTexture(texture2Size.width, texture2Size.height, scene);\r\n            }\r\n            resizedTexture2 = texture2;\r\n        }\r\n        else if (texture1Size.width > texture2Size.width) {\r\n            if (texture2 && texture2 instanceof Texture) {\r\n                resizedTexture2 = TextureTools.CreateResizedCopy(texture2, texture1Size.width, texture1Size.height, true);\r\n            }\r\n            else {\r\n                resizedTexture2 = this._createWhiteTexture(texture1Size.width, texture1Size.height, scene);\r\n            }\r\n            resizedTexture1 = texture1;\r\n        }\r\n        else {\r\n            resizedTexture1 = texture1;\r\n            resizedTexture2 = texture2;\r\n        }\r\n\r\n        return {\r\n            \"texture1\": resizedTexture1,\r\n            \"texture2\": resizedTexture2\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Converts an array of pixels to a Float32Array\r\n     * Throws an error if the pixel format is not supported\r\n     * @param pixels - array buffer containing pixel values\r\n     * @returns Float32 of pixels\r\n     */\r\n    private _convertPixelArrayToFloat32(pixels: ArrayBufferView): Float32Array {\r\n        if (pixels instanceof Uint8Array) {\r\n            const length = pixels.length;\r\n            const buffer = new Float32Array(pixels.length);\r\n            for (let i = 0; i < length; ++i) {\r\n                buffer[i] = pixels[i] / 255;\r\n            }\r\n            return buffer;\r\n        }\r\n        else if (pixels instanceof Float32Array) {\r\n            return pixels;\r\n        }\r\n        else {\r\n            throw new Error('Unsupported pixel format!');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert Specular Glossiness Textures to Metallic Roughness\r\n     * See link below for info on the material conversions from PBR Metallic/Roughness and Specular/Glossiness\r\n     * @link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows-bjs/js/babylon.pbrUtilities.js\r\n     * @param diffuseTexture texture used to store diffuse information\r\n     * @param specularGlossinessTexture texture used to store specular and glossiness information\r\n     * @param factors specular glossiness material factors\r\n     * @param mimeType the mime type to use for the texture\r\n     * @returns pbr metallic roughness interface or null\r\n     */\r\n    private _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(diffuseTexture: BaseTexture, specularGlossinessTexture: BaseTexture, factors: _IPBRSpecularGlossiness, mimeType: ImageMimeType): Promise<_IPBRMetallicRoughness> {\r\n        let promises = [];\r\n        if (!(diffuseTexture || specularGlossinessTexture)) {\r\n            return Promise.reject('_ConvertSpecularGlosinessTexturesToMetallicRoughness: diffuse and specular glossiness textures are not defined!');\r\n        }\r\n\r\n        const scene: Nullable<Scene> = diffuseTexture ? diffuseTexture.getScene() : specularGlossinessTexture ? specularGlossinessTexture.getScene() : null;\r\n        if (scene) {\r\n            const resizedTextures = this._resizeTexturesToSameDimensions(diffuseTexture, specularGlossinessTexture, scene);\r\n\r\n            let diffuseSize = resizedTextures.texture1.getSize();\r\n\r\n            let diffuseBuffer: Float32Array;\r\n            let specularGlossinessBuffer: Float32Array;\r\n\r\n            const width = diffuseSize.width;\r\n            const height = diffuseSize.height;\r\n\r\n            let diffusePixels = resizedTextures.texture1.readPixels();\r\n            let specularPixels = resizedTextures.texture2.readPixels();\r\n\r\n            if (diffusePixels) {\r\n                diffuseBuffer = this._convertPixelArrayToFloat32(diffusePixels);\r\n            }\r\n            else {\r\n                return Promise.reject(\"Failed to retrieve pixels from diffuse texture!\");\r\n            }\r\n            if (specularPixels) {\r\n                specularGlossinessBuffer = this._convertPixelArrayToFloat32(specularPixels);\r\n            }\r\n            else {\r\n                return Promise.reject(\"Failed to retrieve pixels from specular glossiness texture!\");\r\n            }\r\n\r\n            const byteLength = specularGlossinessBuffer.byteLength;\r\n\r\n            const metallicRoughnessBuffer = new Uint8Array(byteLength);\r\n            const baseColorBuffer = new Uint8Array(byteLength);\r\n\r\n            const strideSize = 4;\r\n            const maxBaseColor = Color3.Black();\r\n            let maxMetallic = 0;\r\n            let maxRoughness = 0;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const offset = (width * h + w) * strideSize;\r\n\r\n                    const diffuseColor = new Color3(diffuseBuffer[offset], diffuseBuffer[offset + 1], diffuseBuffer[offset + 2]).toLinearSpace().multiply(factors.diffuseColor);\r\n                    const specularColor = new Color3(specularGlossinessBuffer[offset], specularGlossinessBuffer[offset + 1], specularGlossinessBuffer[offset + 2]).toLinearSpace().multiply(factors.specularColor);\r\n                    const glossiness = (specularGlossinessBuffer[offset + 3]) * factors.glossiness;\r\n\r\n                    const specularGlossiness: _IPBRSpecularGlossiness = {\r\n                        diffuseColor: diffuseColor,\r\n                        specularColor: specularColor,\r\n                        glossiness: glossiness\r\n                    };\r\n\r\n                    const metallicRoughness = this._convertSpecularGlossinessToMetallicRoughness(specularGlossiness);\r\n                    maxBaseColor.r = Math.max(maxBaseColor.r, metallicRoughness.baseColor.r);\r\n                    maxBaseColor.g = Math.max(maxBaseColor.g, metallicRoughness.baseColor.g);\r\n                    maxBaseColor.b = Math.max(maxBaseColor.b, metallicRoughness.baseColor.b);\r\n                    maxMetallic = Math.max(maxMetallic, metallicRoughness.metallic!);\r\n                    maxRoughness = Math.max(maxRoughness, metallicRoughness.roughness!);\r\n\r\n                    baseColorBuffer[offset] = metallicRoughness.baseColor.r * 255;\r\n                    baseColorBuffer[offset + 1] = metallicRoughness.baseColor.g * 255;\r\n                    baseColorBuffer[offset + 2] = metallicRoughness.baseColor.b * 255;\r\n                    baseColorBuffer[offset + 3] = resizedTextures.texture1.hasAlpha ? diffuseBuffer[offset + 3] * 255 : 255;\r\n\r\n                    metallicRoughnessBuffer[offset] = 0;\r\n                    metallicRoughnessBuffer[offset + 1] = metallicRoughness.roughness! * 255;\r\n                    metallicRoughnessBuffer[offset + 2] = metallicRoughness.metallic! * 255;\r\n                    metallicRoughnessBuffer[offset + 3] = 255;\r\n                }\r\n            }\r\n\r\n            // Retrieves the metallic roughness factors from the maximum texture values.\r\n            const metallicRoughnessFactors: _IPBRMetallicRoughness = {\r\n                baseColor: maxBaseColor,\r\n                metallic: maxMetallic,\r\n                roughness: maxRoughness\r\n            };\r\n\r\n            let writeOutMetallicRoughnessTexture = false;\r\n            let writeOutBaseColorTexture = false;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const destinationOffset = (width * h + w) * strideSize;\r\n\r\n                    baseColorBuffer[destinationOffset] /= metallicRoughnessFactors.baseColor.r > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.r : 1;\r\n                    baseColorBuffer[destinationOffset + 1] /= metallicRoughnessFactors.baseColor.g > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.g : 1;\r\n                    baseColorBuffer[destinationOffset + 2] /= metallicRoughnessFactors.baseColor.b > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.b : 1;\r\n\r\n                    const linearBaseColorPixel = Color3.FromInts(baseColorBuffer[destinationOffset], baseColorBuffer[destinationOffset + 1], baseColorBuffer[destinationOffset + 2]);\r\n                    const sRGBBaseColorPixel = linearBaseColorPixel.toGammaSpace();\r\n                    baseColorBuffer[destinationOffset] = sRGBBaseColorPixel.r * 255;\r\n                    baseColorBuffer[destinationOffset + 1] = sRGBBaseColorPixel.g * 255;\r\n                    baseColorBuffer[destinationOffset + 2] = sRGBBaseColorPixel.b * 255;\r\n\r\n                    if (!_GLTFMaterialExporter.FuzzyEquals(sRGBBaseColorPixel, Color3.White(), _GLTFMaterialExporter._Epsilon)) {\r\n                        writeOutBaseColorTexture = true;\r\n                    }\r\n\r\n                    metallicRoughnessBuffer[destinationOffset + 1] /= metallicRoughnessFactors.roughness! > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.roughness! : 1;\r\n                    metallicRoughnessBuffer[destinationOffset + 2] /= metallicRoughnessFactors.metallic! > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.metallic! : 1;\r\n\r\n                    const metallicRoughnessPixel = Color3.FromInts(255, metallicRoughnessBuffer[destinationOffset + 1], metallicRoughnessBuffer[destinationOffset + 2]);\r\n\r\n                    if (!_GLTFMaterialExporter.FuzzyEquals(metallicRoughnessPixel, Color3.White(), _GLTFMaterialExporter._Epsilon)) {\r\n                        writeOutMetallicRoughnessTexture = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (writeOutMetallicRoughnessTexture) {\r\n                let promise = this._createBase64FromCanvasAsync(metallicRoughnessBuffer, width, height, mimeType).then((metallicRoughnessBase64) => {\r\n                    metallicRoughnessFactors.metallicRoughnessTextureBase64 = metallicRoughnessBase64;\r\n                });\r\n                promises.push(promise);\r\n            }\r\n            if (writeOutBaseColorTexture) {\r\n                let promise = this._createBase64FromCanvasAsync(baseColorBuffer, width, height, mimeType).then((baseColorBase64) => {\r\n                    metallicRoughnessFactors.baseColorTextureBase64 = baseColorBase64;\r\n                });\r\n                promises.push(promise);\r\n            }\r\n\r\n            return Promise.all(promises).then(() => {\r\n                return metallicRoughnessFactors;\r\n            });\r\n        }\r\n        else {\r\n            return Promise.reject(\"_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts specular glossiness material properties to metallic roughness\r\n     * @param specularGlossiness interface with specular glossiness material properties\r\n     * @returns interface with metallic roughness material properties\r\n     */\r\n    private _convertSpecularGlossinessToMetallicRoughness(specularGlossiness: _IPBRSpecularGlossiness): _IPBRMetallicRoughness {\r\n        const diffusePerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.diffuseColor);\r\n        const specularPerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.specularColor);\r\n        const oneMinusSpecularStrength = 1 - this._getMaxComponent(specularGlossiness.specularColor);\r\n        const metallic = _GLTFMaterialExporter._SolveMetallic(diffusePerceivedBrightness, specularPerceivedBrightness, oneMinusSpecularStrength);\r\n        const baseColorFromDiffuse = specularGlossiness.diffuseColor.scale(oneMinusSpecularStrength / (1.0 - _GLTFMaterialExporter._DielectricSpecular.r) / Math.max(1 - metallic, _GLTFMaterialExporter._Epsilon));\r\n        const baseColorFromSpecular = specularGlossiness.specularColor.subtract(_GLTFMaterialExporter._DielectricSpecular.scale(1 - metallic)).scale(1 / Math.max(metallic, _GLTFMaterialExporter._Epsilon));\r\n        let baseColor = Color3.Lerp(baseColorFromDiffuse, baseColorFromSpecular, metallic * metallic);\r\n        baseColor = baseColor.clampToRef(0, 1, baseColor);\r\n\r\n        const metallicRoughness: _IPBRMetallicRoughness = {\r\n            baseColor: baseColor,\r\n            metallic: metallic,\r\n            roughness: 1 - specularGlossiness.glossiness\r\n        };\r\n\r\n        return metallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Calculates the surface reflectance, independent of lighting conditions\r\n     * @param color Color source to calculate brightness from\r\n     * @returns number representing the perceived brightness, or zero if color is undefined\r\n     */\r\n    private _getPerceivedBrightness(color: Color3): number {\r\n        if (color) {\r\n            return Math.sqrt(0.299 * color.r * color.r + 0.587 * color.g * color.g + 0.114 * color.b * color.b);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum color component value\r\n     * @param color\r\n     * @returns maximum color component value, or zero if color is null or undefined\r\n     */\r\n    private _getMaxComponent(color: Color3): number {\r\n        if (color) {\r\n            return Math.max(color.r, Math.max(color.g, color.b));\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Metallic/Roughness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private _convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial: PBRMaterial, mimeType: ImageMimeType, glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness, hasTextureCoords: boolean): Promise<_IPBRMetallicRoughness> {\r\n        const promises = [];\r\n        const metallicRoughness: _IPBRMetallicRoughness = {\r\n            baseColor: babylonPBRMaterial.albedoColor,\r\n            metallic: babylonPBRMaterial.metallic,\r\n            roughness: babylonPBRMaterial.roughness\r\n        };\r\n\r\n        if (hasTextureCoords) {\r\n            if (babylonPBRMaterial.albedoTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMaterial.albedoTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n            if (babylonPBRMaterial.metallicTexture) {\r\n                promises.push(this._exportTextureAsync(babylonPBRMaterial.metallicTexture, mimeType).then((glTFTexture) => {\r\n                    if (glTFTexture) {\r\n                        glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n        return Promise.all(promises).then(() => {\r\n            return metallicRoughness;\r\n        });\r\n    }\r\n\r\n    private _getGLTFTextureSampler(texture: BaseTexture): ISampler {\r\n        const sampler = this._getGLTFTextureWrapModesSampler(texture);\r\n\r\n        let samplingMode = texture instanceof Texture ? texture.samplingMode : null;\r\n        if (samplingMode != null) {\r\n            switch (samplingMode) {\r\n                case Texture.LINEAR_LINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_LINEAR_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_LINEAR_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return sampler;\r\n    }\r\n\r\n    private _getGLTFTextureWrapMode(wrapMode: number): TextureWrapMode {\r\n        switch (wrapMode) {\r\n            case Texture.WRAP_ADDRESSMODE: {\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n            case Texture.CLAMP_ADDRESSMODE: {\r\n                return TextureWrapMode.CLAMP_TO_EDGE;\r\n            }\r\n            case Texture.MIRROR_ADDRESSMODE: {\r\n                return TextureWrapMode.MIRRORED_REPEAT;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported Texture Wrap Mode ${wrapMode}!`);\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getGLTFTextureWrapModesSampler(texture: BaseTexture): ISampler {\r\n        let wrapS = this._getGLTFTextureWrapMode(texture instanceof Texture ? texture.wrapU : Texture.WRAP_ADDRESSMODE);\r\n        let wrapT = this._getGLTFTextureWrapMode(texture instanceof Texture ? texture.wrapV : Texture.WRAP_ADDRESSMODE);\r\n\r\n        if (wrapS === TextureWrapMode.REPEAT && wrapT === TextureWrapMode.REPEAT) { // default wrapping mode in glTF, so omitting\r\n            return {};\r\n        }\r\n\r\n        return { wrapS: wrapS, wrapT: wrapT };\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Specular/Glossiness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private _convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial: PBRMaterial, mimeType: ImageMimeType, glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness, hasTextureCoords: boolean): Promise<_IPBRMetallicRoughness> {\r\n        return Promise.resolve().then(() => {\r\n            const samplers = this._exporter._samplers;\r\n            const textures = this._exporter._textures;\r\n            const specGloss: _IPBRSpecularGlossiness = {\r\n                diffuseColor: babylonPBRMaterial.albedoColor || Color3.White(),\r\n                specularColor: babylonPBRMaterial.reflectivityColor || Color3.White(),\r\n                glossiness: babylonPBRMaterial.microSurface || 1,\r\n            };\r\n            let samplerIndex: Nullable<number> = null;\r\n            const sampler = this._getGLTFTextureSampler(babylonPBRMaterial.albedoTexture);\r\n            if (sampler.magFilter != null && sampler.minFilter != null && sampler.wrapS != null && sampler.wrapT != null) {\r\n                samplers.push(sampler);\r\n                samplerIndex = samplers.length - 1;\r\n            }\r\n            if (babylonPBRMaterial.reflectivityTexture && !babylonPBRMaterial.useMicroSurfaceFromReflectivityMapAlpha) {\r\n                return Promise.reject(\"_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported\");\r\n            }\r\n            if ((babylonPBRMaterial.albedoTexture || babylonPBRMaterial.reflectivityTexture) && hasTextureCoords) {\r\n                return this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(babylonPBRMaterial.albedoTexture, babylonPBRMaterial.reflectivityTexture, specGloss, mimeType).then((metallicRoughnessFactors) => {\r\n                    if (metallicRoughnessFactors.baseColorTextureBase64) {\r\n                        const glTFBaseColorTexture = this._getTextureInfoFromBase64(metallicRoughnessFactors.baseColorTextureBase64, \"bjsBaseColorTexture_\" + (textures.length) + \".png\", mimeType, babylonPBRMaterial.albedoTexture ? babylonPBRMaterial.albedoTexture.coordinatesIndex : null, samplerIndex);\r\n                        if (glTFBaseColorTexture) {\r\n                            glTFPbrMetallicRoughness.baseColorTexture = glTFBaseColorTexture;\r\n                        }\r\n                    }\r\n                    if (metallicRoughnessFactors.metallicRoughnessTextureBase64) {\r\n                        const glTFMRColorTexture = this._getTextureInfoFromBase64(metallicRoughnessFactors.metallicRoughnessTextureBase64, \"bjsMetallicRoughnessTexture_\" + (textures.length) + \".png\", mimeType, babylonPBRMaterial.reflectivityTexture ? babylonPBRMaterial.reflectivityTexture.coordinatesIndex : null, samplerIndex);\r\n                        if (glTFMRColorTexture) {\r\n                            glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFMRColorTexture;\r\n                        }\r\n                    }\r\n\r\n                    return metallicRoughnessFactors;\r\n                });\r\n            }\r\n            else {\r\n                return this._convertSpecularGlossinessToMetallicRoughness(specGloss);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon PBR Metallic Roughness Material to a glTF Material\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param images array of glTF image interfaces\r\n     * @param textures array of glTF texture interfaces\r\n     * @param materials array of glTF material interfaces\r\n     * @param imageData map of image file name to data\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertPBRMaterialAsync(babylonPBRMaterial: PBRMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<IMaterial> {\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {};\r\n        const glTFMaterial: IMaterial = {\r\n            name: babylonPBRMaterial.name\r\n        };\r\n        const useMetallicRoughness = babylonPBRMaterial.isMetallicWorkflow();\r\n\r\n        if (useMetallicRoughness) {\r\n            if (babylonPBRMaterial.albedoColor) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [\r\n                    babylonPBRMaterial.albedoColor.r,\r\n                    babylonPBRMaterial.albedoColor.g,\r\n                    babylonPBRMaterial.albedoColor.b,\r\n                    babylonPBRMaterial.alpha\r\n                ];\r\n            }\r\n            return this._convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords).then((metallicRoughness) => {\r\n                return this.setMetallicRoughnessPbrMaterial(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords);\r\n            });\r\n        }\r\n        else {\r\n            return this._convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords).then((metallicRoughness) => {\r\n                return this.setMetallicRoughnessPbrMaterial(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords);\r\n            });\r\n        }\r\n    }\r\n\r\n    private setMetallicRoughnessPbrMaterial(metallicRoughness: Nullable<_IPBRMetallicRoughness>, babylonPBRMaterial: PBRMaterial, glTFMaterial: IMaterial, glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<IMaterial> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        let promises = [];\r\n        if (metallicRoughness) {\r\n            _GLTFMaterialExporter._SetAlphaMode(glTFMaterial, babylonPBRMaterial);\r\n            if (!(_GLTFMaterialExporter.FuzzyEquals(metallicRoughness.baseColor, Color3.White(), _GLTFMaterialExporter._Epsilon) && babylonPBRMaterial.alpha >= _GLTFMaterialExporter._Epsilon)) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [\r\n                    metallicRoughness.baseColor.r,\r\n                    metallicRoughness.baseColor.g,\r\n                    metallicRoughness.baseColor.b,\r\n                    babylonPBRMaterial.alpha\r\n                ];\r\n            }\r\n\r\n            if (metallicRoughness.metallic != null && metallicRoughness.metallic !== 1) {\r\n                glTFPbrMetallicRoughness.metallicFactor = metallicRoughness.metallic;\r\n            }\r\n            if (metallicRoughness.roughness != null && metallicRoughness.roughness !== 1) {\r\n                glTFPbrMetallicRoughness.roughnessFactor = metallicRoughness.roughness;\r\n            }\r\n\r\n            if (babylonPBRMaterial.backFaceCulling != null && !babylonPBRMaterial.backFaceCulling) {\r\n                if (!babylonPBRMaterial.twoSidedLighting) {\r\n                    Tools.Warn(babylonPBRMaterial.name + \": Back-face culling enabled and two-sided lighting disabled is not supported in glTF.\");\r\n                }\r\n                glTFMaterial.doubleSided = true;\r\n            }\r\n\r\n            if (hasTextureCoords) {\r\n                if (babylonPBRMaterial.bumpTexture) {\r\n                    let promise = this._exportTextureAsync(babylonPBRMaterial.bumpTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.normalTexture = glTFTexture;\r\n                            if (babylonPBRMaterial.bumpTexture.level !== 1) {\r\n                                glTFMaterial.normalTexture.scale = babylonPBRMaterial.bumpTexture.level;\r\n                            }\r\n                        }\r\n                    }\r\n                    );\r\n                    promises.push(promise);\r\n\r\n                }\r\n                if (babylonPBRMaterial.ambientTexture) {\r\n                    let promise = this._exportTextureAsync(babylonPBRMaterial.ambientTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            let occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                                index: glTFTexture.index,\r\n                                texCoord: glTFTexture.texCoord\r\n                            };\r\n\r\n                            glTFMaterial.occlusionTexture = occlusionTexture;\r\n\r\n                            if (babylonPBRMaterial.ambientTextureStrength) {\r\n                                occlusionTexture.strength = babylonPBRMaterial.ambientTextureStrength;\r\n                            }\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n\r\n                }\r\n                if (babylonPBRMaterial.emissiveTexture) {\r\n                    let promise = this._exportTextureAsync(babylonPBRMaterial.emissiveTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.emissiveTexture = glTFTexture;\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n                }\r\n            }\r\n            if (!_GLTFMaterialExporter.FuzzyEquals(babylonPBRMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n                glTFMaterial.emissiveFactor = babylonPBRMaterial.emissiveColor.asArray();\r\n            }\r\n\r\n            glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n            materials.push(glTFMaterial);\r\n            materialMap[babylonPBRMaterial.uniqueId] = materials.length - 1;\r\n        }\r\n\r\n        return this._finishMaterial(promises, glTFMaterial, babylonPBRMaterial, mimeType);\r\n    }\r\n\r\n    private getPixelsFromTexture(babylonTexture: BaseTexture): Uint8Array | Float32Array {\r\n        const pixels = babylonTexture.textureType === Constants.TEXTURETYPE_UNSIGNED_INT ? babylonTexture.readPixels() as Uint8Array : babylonTexture.readPixels() as Float32Array;\r\n        return pixels;\r\n    }\r\n\r\n    /**\r\n     * Extracts a texture from a Babylon texture into file data and glTF data\r\n     * @param babylonTexture Babylon texture to extract\r\n     * @param mimeType Mime Type of the babylonTexture\r\n     * @return glTF texture info, or null if the texture format is not supported\r\n     */\r\n    public _exportTextureAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        const extensionPromise = this._exporter._extensionsPreExportTextureAsync(\"exporter\", babylonTexture as Texture, mimeType);\r\n        if (!extensionPromise) {\r\n            return this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n        }\r\n\r\n        return extensionPromise.then((texture) => {\r\n            if (!texture) {\r\n                return this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n            }\r\n            return this._exportTextureInfoAsync(texture, mimeType);\r\n        });\r\n    }\r\n\r\n    public _exportTextureInfoAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        return Promise.resolve().then(() => {\r\n            const textureUid = babylonTexture.uid;\r\n            if (textureUid in this._textureMap) {\r\n                return this._textureMap[textureUid];\r\n            }\r\n            else {\r\n                const samplers = this._exporter._samplers;\r\n                const sampler = this._getGLTFTextureSampler(babylonTexture);\r\n                let samplerIndex: Nullable<number> = null;\r\n\r\n                //  if a pre-existing sampler with identical parameters exists, then reuse the previous sampler\r\n                let foundSamplerIndex: Nullable<number> = null;\r\n                for (let i = 0; i < samplers.length; ++i) {\r\n                    let s = samplers[i];\r\n                    if (s.minFilter === sampler.minFilter && s.magFilter === sampler.magFilter &&\r\n                        s.wrapS === sampler.wrapS && s.wrapT === sampler.wrapT) {\r\n                        foundSamplerIndex = i;\r\n                        break;\r\n                    }\r\n                }\r\n                if (foundSamplerIndex == null) {\r\n                    samplers.push(sampler);\r\n                    samplerIndex = samplers.length - 1;\r\n                }\r\n                else {\r\n                    samplerIndex = foundSamplerIndex;\r\n                }\r\n                const pixels = this.getPixelsFromTexture(babylonTexture);\r\n                const size = babylonTexture.getSize();\r\n\r\n                return this._createBase64FromCanvasAsync(pixels, size.width, size.height, mimeType).then((base64Data) => {\r\n                    const textureInfo = this._getTextureInfoFromBase64(base64Data, babylonTexture.name.replace(/\\.\\/|\\/|\\.\\\\|\\\\/g, \"_\"), mimeType, babylonTexture.coordinatesIndex, samplerIndex);\r\n                    if (textureInfo) {\r\n                        this._textureMap[textureUid] = textureInfo;\r\n                        this._exporter._extensionsPostExportTextures(\"linkTextureInfo\", textureInfo, babylonTexture);\r\n                    }\r\n\r\n                    return textureInfo;\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Builds a texture from base64 string\r\n     * @param base64Texture base64 texture string\r\n     * @param baseTextureName Name to use for the texture\r\n     * @param mimeType image mime type for the texture\r\n     * @param images array of images\r\n     * @param textures array of textures\r\n     * @param imageData map of image data\r\n     * @returns glTF texture info, or null if the texture format is not supported\r\n     */\r\n    private _getTextureInfoFromBase64(base64Texture: string, baseTextureName: string, mimeType: ImageMimeType, texCoordIndex: Nullable<number>, samplerIndex: Nullable<number>): Nullable<ITextureInfo> {\r\n        const textures = this._exporter._textures;\r\n        const images = this._exporter._images;\r\n        const imageData = this._exporter._imageData;\r\n        let textureInfo: Nullable<ITextureInfo> = null;\r\n\r\n        const glTFTexture: ITexture = {\r\n            source: images.length,\r\n            name: baseTextureName\r\n        };\r\n        if (samplerIndex != null) {\r\n            glTFTexture.sampler = samplerIndex;\r\n        }\r\n\r\n        const binStr = atob(base64Texture.split(',')[1]);\r\n        let arrBuff = new ArrayBuffer(binStr.length);\r\n        const arr = new Uint8Array(arrBuff);\r\n        for (let i = 0, length = binStr.length; i < length; ++i) {\r\n            arr[i] = binStr.charCodeAt(i);\r\n        }\r\n        const imageValues = { data: arr, mimeType: mimeType };\r\n\r\n        let extension = mimeType === ImageMimeType.JPEG ? '.jpeg' : '.png';\r\n        let textureName = baseTextureName + extension;\r\n        let originalTextureName = textureName;\r\n        if (textureName in imageData) {\r\n            textureName = `${baseTextureName}_${Tools.RandomId()}${extension}`;\r\n        }\r\n\r\n        imageData[textureName] = imageValues;\r\n        if (mimeType === ImageMimeType.JPEG || mimeType === ImageMimeType.PNG) {\r\n            const glTFImage: IImage = {\r\n                name: baseTextureName,\r\n                uri: textureName\r\n            };\r\n            let foundIndex: Nullable<number> = null;\r\n            for (let i = 0; i < images.length; ++i) {\r\n                if (images[i].uri === originalTextureName) {\r\n                    foundIndex = i;\r\n                    break;\r\n                }\r\n            }\r\n            if (foundIndex == null) {\r\n                images.push(glTFImage);\r\n                glTFTexture.source = images.length - 1;\r\n            }\r\n            else {\r\n                glTFTexture.source = foundIndex;\r\n\r\n            }\r\n            textures.push(glTFTexture);\r\n            textureInfo = {\r\n                index: textures.length - 1\r\n            };\r\n            if (texCoordIndex != null) {\r\n                textureInfo.texCoord = texCoordIndex;\r\n            }\r\n        }\r\n        else {\r\n            Tools.Error(`Unsupported texture mime type ${mimeType}`);\r\n        }\r\n\r\n        return textureInfo;\r\n    }\r\n}","import { Node } from \"babylonjs/node\";\r\nimport { Scene } from \"babylonjs/scene\";\r\nimport { GLTFData } from \"./glTFData\";\r\nimport { _Exporter } from \"./glTFExporter\";\r\n\r\n/**\r\n * Holds a collection of exporter options and parameters\r\n */\r\nexport interface IExportOptions {\r\n    /**\r\n     * Function which indicates whether a babylon node should be exported or not\r\n     * @param node source Babylon node. It is used to check whether it should be exported to glTF or not\r\n     * @returns boolean, which indicates whether the node should be exported (true) or not (false)\r\n     */\r\n    shouldExportNode?(node: Node): boolean;\r\n\r\n    /**\r\n     * Function used to extract the part of node's metadata that will be exported into glTF node extras\r\n     * @param metadata source metadata to read from\r\n     * @returns the data to store to glTF node extras\r\n     */\r\n    metadataSelector?(metadata: any): any;\r\n\r\n    /**\r\n     * The sample rate to bake animation curves\r\n     */\r\n    animationSampleRate?: number;\r\n\r\n    /**\r\n     * Begin serialization without waiting for the scene to be ready\r\n     */\r\n    exportWithoutWaitingForScene?: boolean;\r\n\r\n    /**\r\n     * Indicates if coordinate system swapping root nodes should be included in export\r\n     */\r\n    includeCoordinateSystemConversionNodes?: boolean;\r\n}\r\n\r\n/**\r\n * Class for generating glTF data from a Babylon scene.\r\n */\r\nexport class GLTF2Export {\r\n    /**\r\n     * Exports the geometry of the scene to .gltf file format asynchronously\r\n     * @param scene Babylon scene with scene hierarchy information\r\n     * @param filePrefix File prefix to use when generating the glTF file\r\n     * @param options Exporter options\r\n     * @returns Returns an object with a .gltf file and associates texture names\r\n     * as keys and their data and paths as values\r\n     */\r\n    public static GLTFAsync(scene: Scene, filePrefix: string, options?: IExportOptions): Promise<GLTFData> {\r\n        return scene.whenReadyAsync().then(() => {\r\n            const glTFPrefix = filePrefix.replace(/\\.[^/.]+$/, \"\");\r\n            const gltfGenerator = new _Exporter(scene, options);\r\n            return gltfGenerator._generateGLTFAsync(glTFPrefix);\r\n        });\r\n    }\r\n\r\n    private static _PreExportAsync(scene: Scene, options?: IExportOptions): Promise<void> {\r\n        return Promise.resolve().then(() => {\r\n            if (options && options.exportWithoutWaitingForScene) {\r\n                return Promise.resolve();\r\n            }\r\n            else {\r\n                return scene.whenReadyAsync();\r\n            }\r\n        });\r\n    }\r\n\r\n    private static _PostExportAsync(scene: Scene, glTFData: GLTFData, options?: IExportOptions): Promise<GLTFData> {\r\n        return Promise.resolve().then(() => {\r\n            if (options && options.exportWithoutWaitingForScene) {\r\n                return glTFData;\r\n            }\r\n            else {\r\n                return glTFData;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Exports the geometry of the scene to .glb file format asychronously\r\n     * @param scene Babylon scene with scene hierarchy information\r\n     * @param filePrefix File prefix to use when generating glb file\r\n     * @param options Exporter options\r\n     * @returns Returns an object with a .glb filename as key and data as value\r\n     */\r\n    public static GLBAsync(scene: Scene, filePrefix: string, options?: IExportOptions): Promise<GLTFData> {\r\n        return this._PreExportAsync(scene, options).then(() => {\r\n            const glTFPrefix = filePrefix.replace(/\\.[^/.]+$/, \"\");\r\n            const gltfGenerator = new _Exporter(scene, options);\r\n            return gltfGenerator._generateGLBAsync(glTFPrefix).then((glTFData) => {\r\n                return this._PostExportAsync(scene, glTFData, options);\r\n            });\r\n        });\r\n    }\r\n}\r\n","import { IBufferView, AccessorType, AccessorComponentType, IAccessor } from \"babylonjs-gltf2interface\";\r\n\r\nimport { FloatArray, Nullable } from \"babylonjs/types\";\r\nimport { Vector3, Vector4, Quaternion } from \"babylonjs/Maths/math.vector\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class _GLTFUtilities {\r\n    /**\r\n     * Creates a buffer view based on the supplied arguments\r\n     * @param bufferIndex index value of the specified buffer\r\n     * @param byteOffset byte offset value\r\n     * @param byteLength byte length of the bufferView\r\n     * @param byteStride byte distance between conequential elements\r\n     * @param name name of the buffer view\r\n     * @returns bufferView for glTF\r\n     */\r\n    public static _CreateBufferView(bufferIndex: number, byteOffset: number, byteLength: number, byteStride?: number, name?: string): IBufferView {\r\n        let bufferview: IBufferView = { buffer: bufferIndex, byteLength: byteLength };\r\n        if (byteOffset) {\r\n            bufferview.byteOffset = byteOffset;\r\n        }\r\n        if (name) {\r\n            bufferview.name = name;\r\n        }\r\n        if (byteStride) {\r\n            bufferview.byteStride = byteStride;\r\n        }\r\n\r\n        return bufferview;\r\n    }\r\n\r\n    /**\r\n     * Creates an accessor based on the supplied arguments\r\n     * @param bufferviewIndex The index of the bufferview referenced by this accessor\r\n     * @param name The name of the accessor\r\n     * @param type The type of the accessor\r\n     * @param componentType The datatype of components in the attribute\r\n     * @param count The number of attributes referenced by this accessor\r\n     * @param byteOffset The offset relative to the start of the bufferView in bytes\r\n     * @param min Minimum value of each component in this attribute\r\n     * @param max Maximum value of each component in this attribute\r\n     * @returns accessor for glTF\r\n     */\r\n    public static _CreateAccessor(bufferviewIndex: number, name: string, type: AccessorType, componentType: AccessorComponentType, count: number, byteOffset: Nullable<number>, min: Nullable<number[]>, max: Nullable<number[]>): IAccessor {\r\n        let accessor: IAccessor = { name: name, bufferView: bufferviewIndex, componentType: componentType, count: count, type: type };\r\n\r\n        if (min != null) {\r\n            accessor.min = min;\r\n        }\r\n        if (max != null) {\r\n            accessor.max = max;\r\n        }\r\n        if (byteOffset != null) {\r\n            accessor.byteOffset = byteOffset;\r\n        }\r\n\r\n        return accessor;\r\n    }\r\n\r\n    /**\r\n     * Calculates the minimum and maximum values of an array of position floats\r\n     * @param positions Positions array of a mesh\r\n     * @param vertexStart Starting vertex offset to calculate min and max values\r\n     * @param vertexCount Number of vertices to check for min and max values\r\n     * @returns min number array and max number array\r\n     */\r\n    public static _CalculateMinMaxPositions(positions: FloatArray, vertexStart: number, vertexCount: number, convertToRightHandedSystem: boolean): { min: number[], max: number[] } {\r\n        const min = [Infinity, Infinity, Infinity];\r\n        const max = [-Infinity, -Infinity, -Infinity];\r\n        const positionStrideSize = 3;\r\n        let indexOffset: number;\r\n        let position: Vector3;\r\n        let vector: number[];\r\n\r\n        if (vertexCount) {\r\n            for (let i = vertexStart, length = vertexStart + vertexCount; i < length; ++i) {\r\n                indexOffset = positionStrideSize * i;\r\n\r\n                position = Vector3.FromArray(positions, indexOffset);\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedPositionVector3FromRef(position);\r\n                }\r\n                vector = position.asArray();\r\n\r\n                for (let j = 0; j < positionStrideSize; ++j) {\r\n                    let num = vector[j];\r\n                    if (num < min[j]) {\r\n                        min[j] = num;\r\n                    }\r\n                    if (num > max[j]) {\r\n                        max[j] = num;\r\n                    }\r\n                    ++indexOffset;\r\n                }\r\n            }\r\n        }\r\n        return { min, max };\r\n    }\r\n\r\n    /**\r\n     * Converts a new right-handed Vector3\r\n     * @param vector vector3 array\r\n     * @returns right-handed Vector3\r\n     */\r\n    public static _GetRightHandedPositionVector3(vector: Vector3): Vector3 {\r\n        return new Vector3(vector.x, vector.y, -vector.z);\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector3 to right-handed\r\n     * @param vector Vector3 to convert to right-handed\r\n     */\r\n    public static _GetRightHandedPositionVector3FromRef(vector: Vector3) {\r\n        vector.z *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a three element number array to right-handed\r\n     * @param vector number array to convert to right-handed\r\n     */\r\n    public static _GetRightHandedPositionArray3FromRef(vector: number[]) {\r\n        vector[2] *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a new right-handed Vector3\r\n     * @param vector vector3 array\r\n     * @returns right-handed Vector3\r\n     */\r\n    public static _GetRightHandedNormalVector3(vector: Vector3): Vector3 {\r\n        return new Vector3(vector.x, vector.y, -vector.z);\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector3 to right-handed\r\n     * @param vector Vector3 to convert to right-handed\r\n     */\r\n    public static _GetRightHandedNormalVector3FromRef(vector: Vector3) {\r\n        vector.z *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a three element number array to right-handed\r\n     * @param vector number array to convert to right-handed\r\n     */\r\n    public static _GetRightHandedNormalArray3FromRef(vector: number[]) {\r\n        vector[2] *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector4 to right-handed\r\n     * @param vector Vector4 to convert to right-handed\r\n     */\r\n    public static _GetRightHandedVector4FromRef(vector: Vector4) {\r\n        vector.z *= -1;\r\n        vector.w *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector4 to right-handed\r\n     * @param vector Vector4 to convert to right-handed\r\n     */\r\n    public static _GetRightHandedArray4FromRef(vector: number[]) {\r\n        vector[2] *= -1;\r\n        vector[3] *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a Quaternion to right-handed\r\n     * @param quaternion Source quaternion to convert to right-handed\r\n     */\r\n    public static _GetRightHandedQuaternionFromRef(quaternion: Quaternion) {\r\n        quaternion.x *= -1;\r\n        quaternion.y *= -1;\r\n    }\r\n\r\n    /**\r\n     * Converts a Quaternion to right-handed\r\n     * @param quaternion Source quaternion to convert to right-handed\r\n     */\r\n    public static _GetRightHandedQuaternionArrayFromRef(quaternion: number[]) {\r\n        quaternion[0] *= -1;\r\n        quaternion[1] *= -1;\r\n    }\r\n\r\n    public static _NormalizeTangentFromRef(tangent: Vector4) {\r\n        const length = Math.sqrt(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z);\r\n        if (length > 0) {\r\n            tangent.x /= length;\r\n            tangent.y /= length;\r\n            tangent.z /= length;\r\n        }\r\n    }\r\n}","export * from \"./glTFAnimation\";\r\nexport * from \"./glTFData\";\r\nexport * from \"./glTFExporter\";\r\nexport * from \"./glTFExporterExtension\";\r\nexport * from \"./glTFMaterialExporter\";\r\nexport * from \"./glTFSerializer\";\r\nexport * from \"./glTFUtilities\";\r\nexport * from \"./Extensions\";","import { Effect } from \"babylonjs/Materials/effect\";\n\nlet name = 'textureTransformPixelShader';\nlet shader = `precision highp float;\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform mat4 textureTransformMat;\nvoid main(void) {\nvec2 uvTransformed=(textureTransformMat*vec4(vUV.xy,1,1)).xy;\ngl_FragColor=texture2D(textureSampler,uvTransformed);\n}`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var textureTransformPixelShader = { name, shader };\n","/** @hidden */\r\nexport var __IGLTFExporterExtension = 0; // I am here to allow dts to be created\r\n\r\n/**\r\n * Interface for extending the exporter\r\n * @hidden\r\n */\r\nexport interface IGLTFExporterExtension {\r\n    /**\r\n     * The name of this extension\r\n     */\r\n    readonly name: string;\r\n    /**\r\n     * Defines whether this extension is enabled\r\n     */\r\n    enabled: boolean;\r\n\r\n    /**\r\n     * Defines whether this extension is required\r\n     */\r\n    required: boolean;\r\n}","export * from \"./glTFFileExporter\";\r\nexport * from \"./2.0\";","export * from \"./OBJ\";\r\nexport * from \"./glTF\";\r\nexport * from \"./stl\";","import * as Exporters from \"../glTF/glTFFileExporter\";\r\nimport * as Datas from \"../glTF/2.0/glTFData\";\r\nimport * as Serializers from \"../glTF/2.0/glTFSerializer\";\r\nimport * as Extensions from \"../glTF/2.0/Extensions\";\r\nimport * as GLTF2 from \"../glTF/2.0\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nvar globalObject = (typeof global !== 'undefined') ? global : ((typeof window !== 'undefined') ? window : undefined);\r\nif (typeof globalObject !== \"undefined\") {\r\n    (<any>globalObject).BABYLON = (<any>globalObject).BABYLON || {};\r\n    var BABYLON = (<any>globalObject).BABYLON;\r\n    BABYLON.GLTF2 = BABYLON.GLTF2 || {};\r\n    BABYLON.GLTF2.Exporter = BABYLON.GLTF2.Exporter || {};\r\n    BABYLON.GLTF2.Exporter.Extensions = BABYLON.GLTF2.Exporter.Extensions || {};\r\n\r\n    const keys = [];\r\n    for (var key in Exporters) {\r\n        BABYLON[key] = (<any>Exporters)[key];\r\n        keys.push(key);\r\n    }\r\n    for (var key in Datas) {\r\n        BABYLON[key] = (<any>Datas)[key];\r\n        keys.push(key);\r\n    }\r\n    for (var key in Serializers) {\r\n        BABYLON[key] = (<any>Serializers)[key];\r\n        keys.push(key);\r\n    }\r\n\r\n    for (var key in Extensions) {\r\n        BABYLON.GLTF2.Exporter.Extensions[key] = (<any>Extensions)[key];\r\n        keys.push(key);\r\n    }\r\n\r\n    for (var key in GLTF2) {\r\n        // Prevent Reassignment.\r\n        if (keys.indexOf(key) > -1) {\r\n            continue;\r\n        }\r\n\r\n        BABYLON.GLTF2.Exporter[key] = (<any>GLTF2)[key];\r\n    }\r\n}\r\n\r\nexport * from \"../glTF/glTFFileExporter\";\r\nexport * from \"../glTF/2.0\";","import * as Serializers from \"../OBJ\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nvar globalObject = (typeof global !== 'undefined') ? global : ((typeof window !== 'undefined') ? window : undefined);\r\nif (typeof globalObject !== \"undefined\") {\r\n    for (var serializer in Serializers) {\r\n        (<any>globalObject).BABYLON[serializer] = (<any>Serializers)[serializer];\r\n    }\r\n}\r\n\r\nexport * from \"../OBJ\";","import * as Serializers from \"../stl\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nvar globalObject = (typeof global !== 'undefined') ? global : ((typeof window !== 'undefined') ? window : undefined);\r\nif (typeof globalObject !== \"undefined\") {\r\n    for (var serializer in Serializers) {\r\n        (<any>globalObject).BABYLON[serializer] = (<any>Serializers)[serializer];\r\n    }\r\n}\r\n\r\nexport * from \"../stl\";","import \"../index\";\r\nexport * from \"./legacy-glTF2Serializer\";\r\nexport * from \"./legacy-objSerializer\";\r\nexport * from \"./legacy-stlSerializer\";","export * from \"./stlSerializer\";","import { Mesh } from \"babylonjs/Meshes/mesh\";\nimport { VertexBuffer } from \"babylonjs/Meshes/buffer\";\nimport { Vector3 } from \"babylonjs/Maths/math.vector\";\n\n/**\n* Class for generating STL data from a Babylon scene.\n*/\nexport class STLExport {\n    /**\n    * Exports the geometry of a Mesh array in .STL file format (ASCII)\n    * @param meshes list defines the mesh to serialize\n    * @param download triggers the automatic download of the file.\n    * @param fileName changes the downloads fileName.\n    * @param binary changes the STL to a binary type.\n\t* @param isLittleEndian toggle for binary type exporter.\n    * @returns the STL as UTF8 string\n    */\n    public static CreateSTL(meshes: Mesh[], download: boolean= true, fileName: string= 'STL_Mesh', binary: boolean= false, isLittleEndian: boolean = true): any {\n\n        //Binary support adapted from https://gist.github.com/paulkaplan/6d5f0ab2c7e8fdc68a61\n\n        let getFaceData = function(indices: any, vertices: any, i: number) {\n            let id = [indices[i] * 3, indices[i + 1] * 3, indices[i + 2] * 3];\n            let v = [\n                new Vector3(vertices[id[0]], vertices[id[0] + 1], vertices[id[0] + 2]),\n                new Vector3(vertices[id[1]], vertices[id[1] + 1], vertices[id[1] + 2]),\n                new Vector3(vertices[id[2]], vertices[id[2] + 1], vertices[id[2] + 2])\n            ];\n            let p1p2 = v[0].subtract(v[1]);\n            let p3p2 = v[2].subtract(v[1]);\n            let n = (Vector3.Cross(p1p2, p3p2)).normalize();\n\n            return {v, n};\n        };\n\n        let writeVector = function(dataview: any, offset: number, vector: Vector3, isLittleEndian: boolean) {\n                offset = writeFloat(dataview, offset, vector.x, isLittleEndian);\n                offset = writeFloat(dataview, offset, vector.y, isLittleEndian);\n                return writeFloat(dataview, offset, vector.z, isLittleEndian);\n        };\n\n        let writeFloat = function(dataview: any, offset: number, value: number, isLittleEndian: boolean) {\n            dataview.setFloat32(offset, value, isLittleEndian);\n            return offset + 4;\n        };\n\n        let data;\n\n        let faceCount = 0;\n        let offset = 0;\n\n        if (binary) {\n            for (let i = 0; i < meshes.length; i++) {\n                let mesh = meshes[i];\n                let indices = mesh.getIndices();\n                faceCount += indices ? indices.length : 0;\n            }\n\n            let bufferSize = 84 + (50 * faceCount);\n            let buffer = new ArrayBuffer(bufferSize);\n            data = new DataView(buffer);\n\n            offset += 80;\n            data.setUint32(offset, faceCount, isLittleEndian);\n            offset += 4;\n\n        }else {\n            data = 'solid exportedMesh\\r\\n';\n        }\n\n        for (let i = 0; i < meshes.length; i++) {\n            let mesh = meshes[i];\n            mesh.bakeCurrentTransformIntoVertices();\n            let vertices = mesh.getVerticesData(VertexBuffer.PositionKind) || [];\n            let indices = mesh.getIndices() || [];\n\n            for (let i = 0; i < indices.length; i += 3) {\n                let fd = getFaceData(indices, vertices, i);\n\n                if (binary) {\n                    offset = writeVector(data, offset, fd.n, isLittleEndian);\n                    offset = writeVector(data, offset, fd.v[0], isLittleEndian);\n                    offset = writeVector(data, offset, fd.v[1], isLittleEndian);\n                    offset = writeVector(data, offset, fd.v[2], isLittleEndian);\n                    offset += 2;\n                }else {\n                    data += 'facet normal ' + fd.n.x + ' ' + fd.n.y + ' ' + fd.n.z + '\\r\\n';\n                    data += '\\touter loop\\r\\n';\n                    data += '\\t\\tvertex ' + fd.v[0].x + ' ' + fd.v[0].y + ' ' + fd.v[0].z + '\\r\\n';\n                    data += '\\t\\tvertex ' + fd.v[1].x + ' ' + fd.v[1].y + ' ' + fd.v[1].z + '\\r\\n';\n                    data += '\\t\\tvertex ' + fd.v[2].x + ' ' + fd.v[2].y + ' ' + fd.v[2].z + '\\r\\n';\n                    data += '\\tendloop\\r\\n';\n                    data += 'endfacet\\r\\n';\n                }\n\n            }\n        }\n\n        if (!binary) {\n            data += 'endsolid exportedMesh';\n        }\n\n        if (download) {\n            let a = document.createElement('a');\n            let blob = new Blob([data], {'type': 'application/octet-stream'});\n            a.href = window.URL.createObjectURL(blob);\n\n            if (!fileName) {\n                fileName = \"STL_Mesh\";\n            }\n            a.download = fileName + \".stl\";\n            a.click();\n        }\n\n    return data;\n    }\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE_babylonjs_Maths_math_vector__;"],"sourceRoot":""}