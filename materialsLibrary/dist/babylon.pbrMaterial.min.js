var BABYLON;!function(e){var n=4,i=function(e){function n(){e.call(this),this.DIFFUSE=!1,this.AMBIENT=!1,this.OPACITY=!1,this.OPACITYRGB=!1,this.REFLECTION=!1,this.EMISSIVE=!1,this.SPECULAR=!1,this.BUMP=!1,this.SPECULAROVERALPHA=!1,this.CLIPPLANE=!1,this.ALPHATEST=!1,this.ALPHAFROMDIFFUSE=!1,this.POINTSIZE=!1,this.FOG=!1,this.LIGHT0=!1,this.LIGHT1=!1,this.LIGHT2=!1,this.LIGHT3=!1,this.SPOTLIGHT0=!1,this.SPOTLIGHT1=!1,this.SPOTLIGHT2=!1,this.SPOTLIGHT3=!1,this.HEMILIGHT0=!1,this.HEMILIGHT1=!1,this.HEMILIGHT2=!1,this.HEMILIGHT3=!1,this.POINTLIGHT0=!1,this.POINTLIGHT1=!1,this.POINTLIGHT2=!1,this.POINTLIGHT3=!1,this.DIRLIGHT0=!1,this.DIRLIGHT1=!1,this.DIRLIGHT2=!1,this.DIRLIGHT3=!1,this.SPECULARTERM=!1,this.SHADOW0=!1,this.SHADOW1=!1,this.SHADOW2=!1,this.SHADOW3=!1,this.SHADOWS=!1,this.SHADOWVSM0=!1,this.SHADOWVSM1=!1,this.SHADOWVSM2=!1,this.SHADOWVSM3=!1,this.SHADOWPCF0=!1,this.SHADOWPCF1=!1,this.SHADOWPCF2=!1,this.SHADOWPCF3=!1,this.OPACITYFRESNEL=!1,this.EMISSIVEFRESNEL=!1,this.FRESNEL=!1,this.NORMAL=!1,this.UV1=!1,this.UV2=!1,this.VERTEXCOLOR=!1,this.VERTEXALPHA=!1,this.NUM_BONE_INFLUENCERS=0,this.BonesPerMesh=0,this.INSTANCES=!1,this.GLOSSINESSFROMSPECULARMAP=!1,this.EMISSIVEASILLUMINATION=!1,this.LINKEMISSIVEWITHDIFFUSE=!1,this.LIGHTMAP=!1,this.USELIGHTMAPASSHADOWMAP=!1,this.REFLECTIONMAP_3D=!1,this.REFLECTIONMAP_SPHERICAL=!1,this.REFLECTIONMAP_PLANAR=!1,this.REFLECTIONMAP_CUBIC=!1,this.REFLECTIONMAP_PROJECTION=!1,this.REFLECTIONMAP_SKYBOX=!1,this.REFLECTIONMAP_EXPLICIT=!1,this.REFLECTIONMAP_EQUIRECTANGULAR=!1,this.INVERTCUBICMAP=!1,this.LOGARITHMICDEPTH=!1,this.CAMERATONEMAP=!1,this.CAMERACONTRAST=!1,this.OVERLOADEDVALUES=!1,this.OVERLOADEDSHADOWVALUES=!1,this._keys=Object.keys(this)}return __extends(n,e),n}(e.MaterialDefines),t=function(t){function o(n,o){var s=this;t.call(this,n,o),this.directIntensity=1,this.emissiveIntensity=1,this.environmentIntensity=1,this._lightingInfos=new e.Vector4(this.directIntensity,this.emissiveIntensity,this.environmentIntensity,0),this.overloadedShadowIntensity=1,this.overloadedShadeIntensity=1,this._overloadedShadowInfos=new e.Vector4(this.overloadedShadowIntensity,this.overloadedShadeIntensity,0,0),this.cameraExposure=1,this.cameraContrast=1,this._cameraInfos=new e.Vector4(1,1,0,0),this.overloadedAmbientIntensity=0,this.overloadedDiffuseIntensity=0,this.overloadedSpecularIntensity=0,this.overloadedEmissiveIntensity=0,this._overloadedIntensity=new e.Vector4(this.overloadedAmbientIntensity,this.overloadedDiffuseIntensity,this.overloadedSpecularIntensity,this.overloadedEmissiveIntensity),this.overloadedAmbient=e.Color3.White(),this.overloadedDiffuse=e.Color3.White(),this.overloadedSpecular=e.Color3.White(),this.overloadedEmissive=e.Color3.White(),this.overloadedReflection=e.Color3.White(),this.overloadedGlossiness=0,this.overloadedGlossinessIntensity=0,this.overloadedReflectionIntensity=0,this._overloadedGlossiness=new e.Vector3(this.overloadedGlossiness,this.overloadedGlossinessIntensity,this.overloadedReflectionIntensity),this.disableBumpMap=!1,this.ambientColor=new e.Color3(0,0,0),this.diffuseColor=new e.Color3(1,1,1),this.specularColor=new e.Color3(1,1,1),this.reflectionColor=new e.Color3(.5,.5,.5),this.glossiness=.5,this.emissiveColor=new e.Color3(0,0,0),this.useAlphaFromDiffuseTexture=!1,this.useEmissiveAsIllumination=!1,this.linkEmissiveWithDiffuse=!1,this.useSpecularOverAlpha=!0,this.disableLighting=!1,this.useLightmapAsShadowmap=!1,this.useGlossinessFromSpecularMapAlpha=!1,this._renderTargets=new e.SmartArray(16),this._worldViewProjectionMatrix=e.Matrix.Zero(),this._globalAmbientColor=new e.Color3(0,0,0),this._tempColor=new e.Color3,this._defines=new i,this._cachedDefines=new i,this._myScene=null,this._myShadowGenerator=null,this._cachedDefines.BonesPerMesh=-1,this.getRenderTargetTextures=function(){return s._renderTargets.reset(),s.reflectionTexture&&s.reflectionTexture.isRenderTarget&&s._renderTargets.push(s.reflectionTexture),s._renderTargets}}return __extends(o,t),Object.defineProperty(o.prototype,"useLogarithmicDepth",{get:function(){return this._useLogarithmicDepth},set:function(e){this._useLogarithmicDepth=e&&this.getScene().getEngine().getCaps().fragmentDepthSupported},enumerable:!0,configurable:!0}),o.prototype.needAlphaBlending=function(){return this.alpha<1||null!=this.opacityTexture||this._shouldUseAlphaFromDiffuseTexture()||this.opacityFresnelParameters&&this.opacityFresnelParameters.isEnabled},o.prototype.needAlphaTesting=function(){return null!=this.diffuseTexture&&this.diffuseTexture.hasAlpha},o.prototype._shouldUseAlphaFromDiffuseTexture=function(){return null!=this.diffuseTexture&&this.diffuseTexture.hasAlpha&&this.useAlphaFromDiffuseTexture},o.prototype.getAlphaTestTexture=function(){return this.diffuseTexture},o.prototype._checkCache=function(e,n,i){return n?this._defines.INSTANCES!==i?!1:n._materialDefines&&n._materialDefines.isEqual(this._defines)?!0:!1:!0},o.PrepareDefinesForLights=function(i,t,o){for(var s=0,r=!1,a=0;a<i.lights.length;a++){var f=i.lights[a];if(f.isEnabled()){if(f._excludedMeshesIds.length>0){for(var l=0;l<f._excludedMeshesIds.length;l++){var d=i.getMeshByID(f._excludedMeshesIds[l]);d&&f.excludedMeshes.push(d)}f._excludedMeshesIds=[]}if(f._includedOnlyMeshesIds.length>0){for(var c=0;c<f._includedOnlyMeshesIds.length;c++){var v=i.getMeshByID(f._includedOnlyMeshesIds[c]);v&&f.includedOnlyMeshes.push(v)}f._includedOnlyMeshesIds=[]}if(f.canAffectMesh(t)){r=!0,o["LIGHT"+s]=!0;var u;if(u=f instanceof e.SpotLight?"SPOTLIGHT"+s:f instanceof e.HemisphericLight?"HEMILIGHT"+s:f instanceof e.PointLight?"POINTLIGHT"+s:"DIRLIGHT"+s,o[u]=!0,f.specular.equalsFloats(0,0,0)||(o.SPECULARTERM=!0),i.shadowsEnabled){var h=f.getShadowGenerator();t&&t.receiveShadows&&h&&(o["SHADOW"+s]=!0,o.SHADOWS=!0,(h.useVarianceShadowMap||h.useBlurVarianceShadowMap)&&(o["SHADOWVSM"+s]=!0),h.usePoissonSampling&&(o["SHADOWPCF"+s]=!0))}if(s++,s===n)break}}}return r},o.BindLights=function(i,t,s,r){for(var a=0,f=0;f<i.lights.length;f++){var l=i.lights[f];if(l.isEnabled()&&l.canAffectMesh(t)){if(l instanceof e.PointLight?l.transferToEffect(s,"vLightData"+a):l instanceof e.DirectionalLight?l.transferToEffect(s,"vLightData"+a):l instanceof e.SpotLight?l.transferToEffect(s,"vLightData"+a,"vLightDirection"+a):l instanceof e.HemisphericLight&&l.transferToEffect(s,"vLightData"+a,"vLightGround"+a),l.diffuse.toLinearSpaceToRef(o._scaledDiffuse),o._scaledDiffuse.scaleToRef(l.intensity,o._scaledDiffuse),l.diffuse.scaleToRef(l.intensity,o._scaledDiffuse),s.setColor4("vLightDiffuse"+a,o._scaledDiffuse,l.range),r.SPECULARTERM&&(l.specular.toLinearSpaceToRef(o._scaledSpecular),o._scaledSpecular.scaleToRef(l.intensity,o._scaledSpecular),s.setColor3("vLightSpecular"+a,o._scaledSpecular)),i.shadowsEnabled){var d=l.getShadowGenerator();t.receiveShadows&&d&&(l.needCube()||s.setMatrix("lightMatrix"+a,d.getTransformMatrix()),s.setTexture("shadowSampler"+a,d.getShadowMapForRendering()),s.setFloat3("shadowsInfo"+a,d.getDarkness(),d.getShadowMap().getSize().width,d.bias))}if(a++,a===n)break}}},o.prototype.isReady=function(t,s){if(this.checkReadyOnlyOnce&&this._wasPreviouslyReady)return!0;var r=this.getScene();if(!this.checkReadyOnEveryCall&&this._renderId===r.getRenderId()&&this._checkCache(r,t,s))return!0;var a=r.getEngine(),f=!1,l=!1;if(this._defines.reset(),r.texturesEnabled){if(this.diffuseTexture&&e.StandardMaterial.DiffuseTextureEnabled){if(!this.diffuseTexture.isReady())return!1;l=!0,this._defines.DIFFUSE=!0}if(this.ambientTexture&&e.StandardMaterial.AmbientTextureEnabled){if(!this.ambientTexture.isReady())return!1;l=!0,this._defines.AMBIENT=!0}if(this.opacityTexture&&e.StandardMaterial.OpacityTextureEnabled){if(!this.opacityTexture.isReady())return!1;l=!0,this._defines.OPACITY=!0,this.opacityTexture.getAlphaFromRGB&&(this._defines.OPACITYRGB=!0)}if(this.reflectionTexture&&e.StandardMaterial.ReflectionTextureEnabled){if(!this.reflectionTexture.isReady())return!1;switch(f=!0,this._defines.REFLECTION=!0,this.reflectionTexture.coordinatesMode===e.Texture.INVCUBIC_MODE&&(this._defines.INVERTCUBICMAP=!0),this._defines.REFLECTIONMAP_3D=this.reflectionTexture.isCube,this.reflectionTexture.coordinatesMode){case e.Texture.CUBIC_MODE:case e.Texture.INVCUBIC_MODE:this._defines.REFLECTIONMAP_CUBIC=!0;break;case e.Texture.EXPLICIT_MODE:this._defines.REFLECTIONMAP_EXPLICIT=!0;break;case e.Texture.PLANAR_MODE:this._defines.REFLECTIONMAP_PLANAR=!0;break;case e.Texture.PROJECTION_MODE:this._defines.REFLECTIONMAP_PROJECTION=!0;break;case e.Texture.SKYBOX_MODE:this._defines.REFLECTIONMAP_SKYBOX=!0;break;case e.Texture.SPHERICAL_MODE:this._defines.REFLECTIONMAP_SPHERICAL=!0;break;case e.Texture.EQUIRECTANGULAR_MODE:this._defines.REFLECTIONMAP_EQUIRECTANGULAR=!0}}if(this.lightmapTexture&&e.StandardMaterial.LightmapEnabled){if(!this.lightmapTexture.isReady())return!1;l=!0,this._defines.LIGHTMAP=!0,this._defines.USELIGHTMAPASSHADOWMAP=this.useLightmapAsShadowmap}if(this.emissiveTexture&&e.StandardMaterial.EmissiveTextureEnabled){if(!this.emissiveTexture.isReady())return!1;l=!0,this._defines.EMISSIVE=!0}if(this.specularTexture&&e.StandardMaterial.SpecularTextureEnabled){if(!this.specularTexture.isReady())return!1;l=!0,this._defines.SPECULAR=!0,this._defines.GLOSSINESSFROMSPECULARMAP=this.useGlossinessFromSpecularMapAlpha}}if(r.getEngine().getCaps().standardDerivatives&&this.bumpTexture&&e.StandardMaterial.BumpTextureEnabled&&!this.disableBumpMap){if(!this.bumpTexture.isReady())return!1;l=!0,this._defines.BUMP=!0}if(r.clipPlane&&(this._defines.CLIPPLANE=!0),a.getAlphaTesting()&&(this._defines.ALPHATEST=!0),this._shouldUseAlphaFromDiffuseTexture()&&(this._defines.ALPHAFROMDIFFUSE=!0),this.useEmissiveAsIllumination&&(this._defines.EMISSIVEASILLUMINATION=!0),this.linkEmissiveWithDiffuse&&(this._defines.LINKEMISSIVEWITHDIFFUSE=!0),this.useLogarithmicDepth&&(this._defines.LOGARITHMICDEPTH=!0),1!=this.cameraContrast&&(this._defines.CAMERACONTRAST=!0),1!=this.cameraExposure&&(this._defines.CAMERATONEMAP=!0),(1!=this.overloadedShadeIntensity||1!=this.overloadedShadowIntensity)&&(this._defines.OVERLOADEDSHADOWVALUES=!0),(this.overloadedGlossinessIntensity>0||this.overloadedEmissiveIntensity>0||this.overloadedSpecularIntensity>0||this.overloadedDiffuseIntensity>0||this.overloadedAmbientIntensity>0||this.overloadedReflectionIntensity>0)&&(this._defines.OVERLOADEDVALUES=!0),(this.pointsCloud||r.forcePointsCloud)&&(this._defines.POINTSIZE=!0),r.fogEnabled&&t&&t.applyFog&&r.fogMode!==e.Scene.FOGMODE_NONE&&this.fogEnabled&&(this._defines.FOG=!0),r.lightsEnabled&&!this.disableLighting&&(f=o.PrepareDefinesForLights(r,t,this._defines)),e.StandardMaterial.FresnelEnabled&&(this.opacityFresnelParameters&&this.opacityFresnelParameters.isEnabled||this.emissiveFresnelParameters&&this.emissiveFresnelParameters.isEnabled)&&(this.opacityFresnelParameters&&this.opacityFresnelParameters.isEnabled&&(this._defines.OPACITYFRESNEL=!0),this.emissiveFresnelParameters&&this.emissiveFresnelParameters.isEnabled&&(this._defines.EMISSIVEFRESNEL=!0),f=!0,this._defines.FRESNEL=!0),this._defines.SPECULARTERM&&this.useSpecularOverAlpha&&(this._defines.SPECULAROVERALPHA=!0),t&&(f&&t.isVerticesDataPresent(e.VertexBuffer.NormalKind)&&(this._defines.NORMAL=!0),l&&(t.isVerticesDataPresent(e.VertexBuffer.UVKind)&&(this._defines.UV1=!0),t.isVerticesDataPresent(e.VertexBuffer.UV2Kind)&&(this._defines.UV2=!0)),t.useVertexColors&&t.isVerticesDataPresent(e.VertexBuffer.ColorKind)&&(this._defines.VERTEXCOLOR=!0,t.hasVertexAlpha&&(this._defines.VERTEXALPHA=!0)),t.useBones&&t.computeBonesUsingShaders&&(this._defines.NUM_BONE_INFLUENCERS=t.numBoneInfluencers,this._defines.BonesPerMesh=t.skeleton.bones.length+1),s&&(this._defines.INSTANCES=!0)),!this._defines.isEqual(this._cachedDefines)){this._defines.cloneTo(this._cachedDefines),r.resetCachedMaterial();var d=new e.EffectFallbacks;this._defines.REFLECTION&&d.addFallback(0,"REFLECTION"),this._defines.SPECULAR&&d.addFallback(0,"SPECULAR"),this._defines.BUMP&&d.addFallback(0,"BUMP"),this._defines.SPECULAROVERALPHA&&d.addFallback(0,"SPECULAROVERALPHA"),this._defines.FOG&&d.addFallback(1,"FOG"),this._defines.POINTSIZE&&d.addFallback(0,"POINTSIZE"),this._defines.LOGARITHMICDEPTH&&d.addFallback(0,"LOGARITHMICDEPTH");for(var c=0;n>c;c++)this._defines["LIGHT"+c]&&(c>0&&d.addFallback(c,"LIGHT"+c),this._defines["SHADOW"+c]&&d.addFallback(0,"SHADOW"+c),this._defines["SHADOWPCF"+c]&&d.addFallback(0,"SHADOWPCF"+c),this._defines["SHADOWVSM"+c]&&d.addFallback(0,"SHADOWVSM"+c));this._defines.SPECULARTERM&&d.addFallback(0,"SPECULARTERM"),this._defines.OPACITYFRESNEL&&d.addFallback(1,"OPACITYFRESNEL"),this._defines.EMISSIVEFRESNEL&&d.addFallback(2,"EMISSIVEFRESNEL"),this._defines.FRESNEL&&d.addFallback(3,"FRESNEL"),this._defines.NUM_BONE_INFLUENCERS>0&&d.addCPUSkinningFallback(0,t);var v=[e.VertexBuffer.PositionKind];this._defines.NORMAL&&v.push(e.VertexBuffer.NormalKind),this._defines.UV1&&v.push(e.VertexBuffer.UVKind),this._defines.UV2&&v.push(e.VertexBuffer.UV2Kind),this._defines.VERTEXCOLOR&&v.push(e.VertexBuffer.ColorKind),this._defines.NUM_BONE_INFLUENCERS>0&&(v.push(e.VertexBuffer.MatricesIndicesKind),v.push(e.VertexBuffer.MatricesWeightsKind),this._defines.NUM_BONE_INFLUENCERS>4&&(v.push(e.VertexBuffer.MatricesIndicesExtraKind),v.push(e.VertexBuffer.MatricesWeightsExtraKind))),this._defines.INSTANCES&&(v.push("world0"),v.push("world1"),v.push("world2"),v.push("world3"));var u="pbr";r.getEngine().getCaps().standardDerivatives||(u="legacypbr");var h=this._defines.toString();this._effect=r.getEngine().createEffect(u,v,["world","view","viewProjection","vEyePosition","vLightsType","vAmbientColor","vDiffuseColor","vSpecularColor","vEmissiveColor","vReflectionColor","vLightData0","vLightDiffuse0","vLightSpecular0","vLightDirection0","vLightGround0","lightMatrix0","vLightData1","vLightDiffuse1","vLightSpecular1","vLightDirection1","vLightGround1","lightMatrix1","vLightData2","vLightDiffuse2","vLightSpecular2","vLightDirection2","vLightGround2","lightMatrix2","vLightData3","vLightDiffuse3","vLightSpecular3","vLightDirection3","vLightGround3","lightMatrix3","vFogInfos","vFogColor","pointSize","vDiffuseInfos","vAmbientInfos","vOpacityInfos","vReflectionInfos","vEmissiveInfos","vSpecularInfos","vBumpInfos","vLightmapInfos","mBones","vClipPlane","diffuseMatrix","ambientMatrix","opacityMatrix","reflectionMatrix","emissiveMatrix","specularMatrix","bumpMatrix","lightmapMatrix","shadowsInfo0","shadowsInfo1","shadowsInfo2","shadowsInfo3","opacityParts","emissiveLeftColor","emissiveRightColor","vLightingIntensity","vOverloadedShadowIntensity","vOverloadedIntensity","vCameraInfos","vOverloadedDiffuse","vOverloadedReflection","vOverloadedSpecular","vOverloadedEmissive","vOverloadedGlossiness","logarithmicDepthConstant"],["diffuseSampler","ambientSampler","opacitySampler","reflectionCubeSampler","reflection2DSampler","emissiveSampler","specularSampler","bumpSampler","lightmapSampler","shadowSampler0","shadowSampler1","shadowSampler2","shadowSampler3"],h,d,this.onCompiled,this.onError)}return this._effect.isReady()?(this._renderId=r.getRenderId(),this._wasPreviouslyReady=!0,t&&(t._materialDefines||(t._materialDefines=new i),this._defines.cloneTo(t._materialDefines)),!0):!1},o.prototype.unbind=function(){this.reflectionTexture&&this.reflectionTexture.isRenderTarget&&this._effect.setTexture("reflection2DSampler",null),t.prototype.unbind.call(this)},o.prototype.bindOnlyWorldMatrix=function(e){this._effect.setMatrix("world",e)},o.prototype.bind=function(n,i){this._myScene=this.getScene(),this.bindOnlyWorldMatrix(n),this._effect.setMatrix("viewProjection",this._myScene.getTransformMatrix()),i&&i.useBones&&i.computeBonesUsingShaders&&this._effect.setMatrices("mBones",i.skeleton.getTransformMatrices()),this._myScene.getCachedMaterial()!==this&&(e.StandardMaterial.FresnelEnabled&&(this.opacityFresnelParameters&&this.opacityFresnelParameters.isEnabled&&this._effect.setColor4("opacityParts",new e.Color3(this.opacityFresnelParameters.leftColor.toLuminance(),this.opacityFresnelParameters.rightColor.toLuminance(),this.opacityFresnelParameters.bias),this.opacityFresnelParameters.power),this.emissiveFresnelParameters&&this.emissiveFresnelParameters.isEnabled&&(this._effect.setColor4("emissiveLeftColor",this.emissiveFresnelParameters.leftColor,this.emissiveFresnelParameters.power),this._effect.setColor4("emissiveRightColor",this.emissiveFresnelParameters.rightColor,this.emissiveFresnelParameters.bias))),this.diffuseTexture&&e.StandardMaterial.DiffuseTextureEnabled&&(this._effect.setTexture("diffuseSampler",this.diffuseTexture),this._effect.setFloat2("vDiffuseInfos",this.diffuseTexture.coordinatesIndex,this.diffuseTexture.level),this._effect.setMatrix("diffuseMatrix",this.diffuseTexture.getTextureMatrix())),this.ambientTexture&&e.StandardMaterial.AmbientTextureEnabled&&(this._effect.setTexture("ambientSampler",this.ambientTexture),this._effect.setFloat2("vAmbientInfos",this.ambientTexture.coordinatesIndex,this.ambientTexture.level),this._effect.setMatrix("ambientMatrix",this.ambientTexture.getTextureMatrix())),this.opacityTexture&&e.StandardMaterial.OpacityTextureEnabled&&(this._effect.setTexture("opacitySampler",this.opacityTexture),this._effect.setFloat2("vOpacityInfos",this.opacityTexture.coordinatesIndex,this.opacityTexture.level),this._effect.setMatrix("opacityMatrix",this.opacityTexture.getTextureMatrix())),this.reflectionTexture&&e.StandardMaterial.ReflectionTextureEnabled&&(this.reflectionTexture.isCube?this._effect.setTexture("reflectionCubeSampler",this.reflectionTexture):this._effect.setTexture("reflection2DSampler",this.reflectionTexture),this._effect.setMatrix("reflectionMatrix",this.reflectionTexture.getReflectionTextureMatrix()),this._effect.setFloat2("vReflectionInfos",this.reflectionTexture.level,0)),this.emissiveTexture&&e.StandardMaterial.EmissiveTextureEnabled&&(this._effect.setTexture("emissiveSampler",this.emissiveTexture),this._effect.setFloat2("vEmissiveInfos",this.emissiveTexture.coordinatesIndex,this.emissiveTexture.level),this._effect.setMatrix("emissiveMatrix",this.emissiveTexture.getTextureMatrix())),this.lightmapTexture&&e.StandardMaterial.LightmapEnabled&&(this._effect.setTexture("lightmapSampler",this.lightmapTexture),this._effect.setFloat2("vLightmapInfos",this.lightmapTexture.coordinatesIndex,this.lightmapTexture.level),this._effect.setMatrix("lightmapMatrix",this.lightmapTexture.getTextureMatrix())),this.specularTexture&&e.StandardMaterial.SpecularTextureEnabled&&(this._effect.setTexture("specularSampler",this.specularTexture),this._effect.setFloat2("vSpecularInfos",this.specularTexture.coordinatesIndex,this.specularTexture.level),this._effect.setMatrix("specularMatrix",this.specularTexture.getTextureMatrix())),this.bumpTexture&&this._myScene.getEngine().getCaps().standardDerivatives&&e.StandardMaterial.BumpTextureEnabled&&!this.disableBumpMap&&(this._effect.setTexture("bumpSampler",this.bumpTexture),this._effect.setFloat2("vBumpInfos",this.bumpTexture.coordinatesIndex,1/this.bumpTexture.level),this._effect.setMatrix("bumpMatrix",this.bumpTexture.getTextureMatrix())),this._myScene.clipPlane&&this._effect.setFloat4("vClipPlane",this._myScene.clipPlane.normal.x,this._myScene.clipPlane.normal.y,this._myScene.clipPlane.normal.z,this._myScene.clipPlane.d),this.pointsCloud&&this._effect.setFloat("pointSize",this.pointSize),this._myScene.ambientColor.multiplyToRef(this.ambientColor,this._globalAmbientColor),this.specularColor.toLinearSpaceToRef(o._scaledSpecular),this._effect.setVector3("vEyePosition",this._myScene._mirroredCameraPosition?this._myScene._mirroredCameraPosition:this._myScene.activeCamera.position),this._effect.setColor3("vAmbientColor",this._globalAmbientColor),this._defines.SPECULARTERM&&this._effect.setColor4("vSpecularColor",o._scaledSpecular,this.glossiness),this.emissiveColor.toLinearSpaceToRef(o._scaledEmissive),this._effect.setColor3("vEmissiveColor",o._scaledEmissive),this.reflectionColor.toLinearSpaceToRef(o._scaledReflection),this._effect.setColor3("vReflectionColor",o._scaledReflection)),this.diffuseColor.toLinearSpaceToRef(o._scaledDiffuse),this._effect.setColor4("vDiffuseColor",o._scaledDiffuse,this.alpha*i.visibility),this._myScene.lightsEnabled&&!this.disableLighting&&o.BindLights(this._myScene,i,this._effect,this._defines),(this._myScene.fogEnabled&&i.applyFog&&this._myScene.fogMode!==e.Scene.FOGMODE_NONE||this.reflectionTexture)&&this._effect.setMatrix("view",this._myScene.getViewMatrix()),this._myScene.fogEnabled&&i.applyFog&&this._myScene.fogMode!==e.Scene.FOGMODE_NONE&&(this._effect.setFloat4("vFogInfos",this._myScene.fogMode,this._myScene.fogStart,this._myScene.fogEnd,this._myScene.fogDensity),this._effect.setColor3("vFogColor",this._myScene.fogColor)),this._lightingInfos.x=this.directIntensity,this._lightingInfos.y=this.emissiveIntensity,this._lightingInfos.z=this.environmentIntensity,this._effect.setVector4("vLightingIntensity",this._lightingInfos),this._overloadedShadowInfos.x=this.overloadedShadowIntensity,this._overloadedShadowInfos.y=this.overloadedShadeIntensity,this._effect.setVector4("vOverloadedShadowIntensity",this._overloadedShadowInfos),this._cameraInfos.x=this.cameraExposure,this._cameraInfos.y=this.cameraContrast,this._effect.setVector4("vCameraInfos",this._cameraInfos),this._overloadedIntensity.x=this.overloadedAmbientIntensity,this._overloadedIntensity.y=this.overloadedDiffuseIntensity,this._overloadedIntensity.z=this.overloadedSpecularIntensity,this._overloadedIntensity.w=this.overloadedEmissiveIntensity,this._effect.setVector4("vOverloadedIntensity",this._overloadedIntensity),this.overloadedAmbient.toLinearSpaceToRef(this._tempColor),this._effect.setColor3("vOverloadedAmbient",this._tempColor),this.overloadedDiffuse.toLinearSpaceToRef(this._tempColor),this._effect.setColor3("vOverloadedDiffuse",this._tempColor),this.overloadedSpecular.toLinearSpaceToRef(this._tempColor),this._effect.setColor3("vOverloadedSpecular",this._tempColor),this.overloadedEmissive.toLinearSpaceToRef(this._tempColor),this._effect.setColor3("vOverloadedEmissive",this._tempColor),this.overloadedReflection.toLinearSpaceToRef(this._tempColor),this._effect.setColor3("vOverloadedReflection",this._tempColor),this._overloadedGlossiness.x=this.overloadedGlossiness,this._overloadedGlossiness.y=this.overloadedGlossinessIntensity,this._overloadedGlossiness.z=this.overloadedReflectionIntensity,this._effect.setVector3("vOverloadedGlossiness",this._overloadedGlossiness),this._defines.LOGARITHMICDEPTH&&this._effect.setFloat("logarithmicDepthConstant",2/(Math.log(this._myScene.activeCamera.maxZ+1)/Math.LN2)),t.prototype.bind.call(this,n,i),this._myScene=null},o.prototype.getAnimatables=function(){var e=[];return this.diffuseTexture&&this.diffuseTexture.animations&&this.diffuseTexture.animations.length>0&&e.push(this.diffuseTexture),this.ambientTexture&&this.ambientTexture.animations&&this.ambientTexture.animations.length>0&&e.push(this.ambientTexture),this.opacityTexture&&this.opacityTexture.animations&&this.opacityTexture.animations.length>0&&e.push(this.opacityTexture),this.reflectionTexture&&this.reflectionTexture.animations&&this.reflectionTexture.animations.length>0&&e.push(this.reflectionTexture),this.emissiveTexture&&this.emissiveTexture.animations&&this.emissiveTexture.animations.length>0&&e.push(this.emissiveTexture),this.specularTexture&&this.specularTexture.animations&&this.specularTexture.animations.length>0&&e.push(this.specularTexture),this.bumpTexture&&this.bumpTexture.animations&&this.bumpTexture.animations.length>0&&e.push(this.bumpTexture),e},o.prototype.dispose=function(e){this.diffuseTexture&&this.diffuseTexture.dispose(),this.ambientTexture&&this.ambientTexture.dispose(),this.opacityTexture&&this.opacityTexture.dispose(),this.reflectionTexture&&this.reflectionTexture.dispose(),this.emissiveTexture&&this.emissiveTexture.dispose(),this.specularTexture&&this.specularTexture.dispose(),this.bumpTexture&&this.bumpTexture.dispose(),t.prototype.dispose.call(this,e)},o.prototype.clone=function(e){var n=new o(e,this.getScene());return this.copyTo(n),n.directIntensity=this.directIntensity,n.emissiveIntensity=this.emissiveIntensity,n.environmentIntensity=this.environmentIntensity,n.cameraExposure=this.cameraExposure,n.cameraContrast=this.cameraContrast,n.overloadedShadowIntensity=this.overloadedShadowIntensity,n.overloadedShadeIntensity=this.overloadedShadeIntensity,n.overloadedAmbientIntensity=this.overloadedAmbientIntensity,n.overloadedDiffuseIntensity=this.overloadedDiffuseIntensity,n.overloadedSpecularIntensity=this.overloadedSpecularIntensity,n.overloadedEmissiveIntensity=this.overloadedEmissiveIntensity,n.overloadedAmbient=this.overloadedAmbient,n.overloadedDiffuse=this.overloadedDiffuse,n.overloadedSpecular=this.overloadedSpecular,n.overloadedEmissive=this.overloadedEmissive,n.overloadedReflection=this.overloadedReflection,n.overloadedGlossiness=this.overloadedGlossiness,n.overloadedGlossinessIntensity=this.overloadedGlossinessIntensity,n.overloadedReflectionIntensity=this.overloadedReflectionIntensity,n.disableBumpMap=this.disableBumpMap,this.diffuseTexture&&this.diffuseTexture.clone&&(n.diffuseTexture=this.diffuseTexture.clone()),this.ambientTexture&&this.ambientTexture.clone&&(n.ambientTexture=this.ambientTexture.clone()),this.opacityTexture&&this.opacityTexture.clone&&(n.opacityTexture=this.opacityTexture.clone()),this.reflectionTexture&&this.reflectionTexture.clone&&(n.reflectionTexture=this.reflectionTexture.clone()),this.emissiveTexture&&this.emissiveTexture.clone&&(n.emissiveTexture=this.emissiveTexture.clone()),this.specularTexture&&this.specularTexture.clone&&(n.specularTexture=this.specularTexture.clone()),this.bumpTexture&&this.bumpTexture.clone&&(n.bumpTexture=this.bumpTexture.clone()),this.lightmapTexture&&this.lightmapTexture.clone&&(n.lightmapTexture=this.lightmapTexture.clone(),n.useLightmapAsShadowmap=this.useLightmapAsShadowmap),n.ambientColor=this.ambientColor.clone(),n.diffuseColor=this.diffuseColor.clone(),n.specularColor=this.specularColor.clone(),n.reflectionColor=this.reflectionColor.clone(),n.glossiness=this.glossiness,n.emissiveColor=this.emissiveColor.clone(),n.useAlphaFromDiffuseTexture=this.useAlphaFromDiffuseTexture,n.useEmissiveAsIllumination=this.useEmissiveAsIllumination,n.useGlossinessFromSpecularMapAlpha=this.useGlossinessFromSpecularMapAlpha,n.useSpecularOverAlpha=this.useSpecularOverAlpha,n.emissiveFresnelParameters=this.emissiveFresnelParameters.clone(),n.opacityFresnelParameters=this.opacityFresnelParameters.clone(),n},o.prototype.serialize=function(){var e=t.prototype.serialize.call(this);return e.customType="BABYLON.PBRMaterial",e.directIntensity=this.directIntensity,e.emissiveIntensity=this.emissiveIntensity,e.environmentIntensity=this.environmentIntensity,e.cameraExposure=this.cameraExposure,e.cameraContrast=this.cameraContrast,e.overloadedShadowIntensity=this.overloadedShadowIntensity,e.overloadedShadeIntensity=this.overloadedShadeIntensity,e.overloadedAmbientIntensity=this.overloadedAmbientIntensity,e.overloadedDiffuseIntensity=this.overloadedDiffuseIntensity,e.overloadedSpecularIntensity=this.overloadedSpecularIntensity,e.overloadedEmissiveIntensity=this.overloadedEmissiveIntensity,e.overloadedAmbient=this.overloadedAmbient.asArray(),e.overloadedDiffuse=this.overloadedDiffuse.asArray(),e.overloadedSpecular=this.overloadedSpecular.asArray(),e.overloadedEmissive=this.overloadedEmissive.asArray(),e.overloadedReflection=this.overloadedReflection.asArray(),e.overloadedGlossiness=this.overloadedGlossiness,e.overloadedGlossinessIntensity=this.overloadedGlossinessIntensity,e.overloadedReflectionIntensity=this.overloadedReflectionIntensity,e.disableBumpMap=this.disableBumpMap,this.diffuseTexture&&(e.diffuseTexture=this.diffuseTexture.serialize()),this.ambientTexture&&(e.ambientTexture=this.ambientTexture.serialize()),this.opacityTexture&&(e.opacityTexture=this.opacityTexture.serialize()),this.reflectionTexture&&(e.reflectionTexture=this.reflectionTexture.serialize()),this.emissiveTexture&&(e.emissiveTexture=this.emissiveTexture.serialize()),this.specularTexture&&(e.specularTexture=this.specularTexture.serialize()),this.bumpTexture&&(e.bumpTexture=this.bumpTexture.serialize()),this.lightmapTexture&&(e.lightmapTexture=this.lightmapTexture.serialize(),e.useLightmapAsShadowmap=this.useLightmapAsShadowmap),e.ambientColor=this.ambientColor.asArray(),e.diffuseColor=this.diffuseColor.asArray(),e.specularColor=this.specularColor.asArray(),e.reflectionColor=this.reflectionColor.asArray(),e.glossiness=this.glossiness,e.emissiveColor=this.emissiveColor.asArray(),e.useAlphaFromDiffuseTexture=this.useAlphaFromDiffuseTexture,e.useEmissiveAsIllumination=this.useEmissiveAsIllumination,e.useGlossinessFromSpecularMapAlpha=this.useGlossinessFromSpecularMapAlpha,e.useSpecularOverAlpha=this.useSpecularOverAlpha,e.emissiveFresnelParameters=this.emissiveFresnelParameters.serialize(),e.opacityFresnelParameters=this.opacityFresnelParameters.serialize(),e},o.Parse=function(n,i,t){var s=new o(n.name,i);return s.alpha=n.alpha,s.id=n.id,n.disableDepthWrite&&(s.disableDepthWrite=n.disableDepthWrite),n.checkReadyOnlyOnce&&(s.checkReadyOnlyOnce=n.checkReadyOnlyOnce),e.Tags.AddTagsTo(s,n.tags),s.backFaceCulling=n.backFaceCulling,s.wireframe=n.wireframe,s.directIntensity=n.directIntensity,s.emissiveIntensity=n.emissiveIntensity,s.environmentIntensity=n.environmentIntensity,s.cameraExposure=n.cameraExposure,s.cameraContrast=n.cameraContrast,s.overloadedShadowIntensity=n.overloadedShadowIntensity,s.overloadedShadeIntensity=n.overloadedShadeIntensity,s.overloadedAmbientIntensity=n.overloadedAmbientIntensity,s.overloadedDiffuseIntensity=n.overloadedDiffuseIntensity,s.overloadedSpecularIntensity=n.overloadedSpecularIntensity,s.overloadedEmissiveIntensity=n.overloadedEmissiveIntensity,s.overloadedAmbient=e.Color3.FromArray(n.overloadedAmbient),s.overloadedDiffuse=e.Color3.FromArray(n.overloadedDiffuse),s.overloadedSpecular=e.Color3.FromArray(n.overloadedSpecular),s.overloadedEmissive=e.Color3.FromArray(n.overloadedEmissive),s.overloadedReflection=e.Color3.FromArray(n.overloadedReflection),s.overloadedGlossiness=n.overloadedGlossiness,s.overloadedGlossinessIntensity=n.overloadedGlossinessIntensity,s.overloadedReflectionIntensity=n.overloadedReflectionIntensity,s.disableBumpMap=n.disableBumpMap,n.diffuseTexture&&(s.diffuseTexture=e.Texture.Parse(n.diffuseTexture,i,t)),n.ambientTexture&&(s.ambientTexture=e.Texture.Parse(n.ambientTexture,i,t)),n.opacityTexture&&(s.opacityTexture=e.Texture.Parse(n.opacityTexture,i,t)),n.reflectionTexture&&(s.reflectionTexture=e.Texture.Parse(n.reflectionTexture,i,t)),n.emissiveTexture&&(s.emissiveTexture=e.Texture.Parse(n.emissiveTexture,i,t)),n.specularTexture&&(s.specularTexture=e.Texture.Parse(n.specularTexture,i,t)),n.bumpTexture&&(s.bumpTexture=e.Texture.Parse(n.bumpTexture,i,t)),n.lightmapTexture&&(s.lightmapTexture=e.Texture.Parse(n.lightmapTexture,i,t),s.useLightmapAsShadowmap=n.useLightmapAsShadowmap),s.ambientColor=e.Color3.FromArray(n.ambient),s.diffuseColor=e.Color3.FromArray(n.diffuse),s.specularColor=e.Color3.FromArray(n.specular),s.reflectionColor=e.Color3.FromArray(n.reflectionColor),s.glossiness=n.glossiness,s.emissiveColor=e.Color3.FromArray(n.emissive),s.useAlphaFromDiffuseTexture=n.useAlphaFromDiffuseTexture,s.useEmissiveAsIllumination=n.useEmissiveAsIllumination,s.useGlossinessFromSpecularMapAlpha=n.useGlossinessFromSpecularMapAlpha,s.useSpecularOverAlpha=n.useSpecularOverAlpha,s.emissiveFresnelParameters=e.FresnelParameters.Parse(n.emissiveFresnelParameters),s.opacityFresnelParameters=e.FresnelParameters.Parse(n.opacityFresnelParameters),s},o._scaledDiffuse=new e.Color3,o._scaledSpecular=new e.Color3,o._scaledEmissive=new e.Color3,o._scaledReflection=new e.Color3,o}(e.Material);e.PBRMaterial=t}(BABYLON||(BABYLON={})),BABYLON.Effect.ShadersStore.pbrVertexShader="precision highp float;\n\n// Attributes\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#if NUM_BONE_INFLUENCERS > 0\nuniform mat4 mBones[BonesPerMesh];\n\nattribute vec4 matricesIndices;\nattribute vec4 matricesWeights;\n#if NUM_BONE_INFLUENCERS > 4\nattribute vec4 matricesIndicesExtra;\nattribute vec4 matricesWeightsExtra;\n#endif\n#endif\n\n// Uniforms\n\n#ifdef INSTANCES\nattribute vec4 world0;\nattribute vec4 world1;\nattribute vec4 world2;\nattribute vec4 world3;\n#else\nuniform mat4 world;\n#endif\n\nuniform mat4 view;\nuniform mat4 viewProjection;\n\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform mat4 ambientMatrix;\nuniform vec2 vAmbientInfos;\n#endif\n\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n\n#ifdef LIGHTMAP\nvarying vec2 vLightmapUV;\nuniform vec2 vLightmapInfos;\nuniform mat4 lightmapMatrix;\n#endif\n\n#if defined(SPECULAR) && defined(SPECULARTERM)\nvarying vec2 vSpecularUV;\nuniform vec2 vSpecularInfos;\nuniform mat4 specularMatrix;\n#endif\n\n#ifdef BUMP\nvarying vec2 vBumpUV;\nuniform vec2 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n\n// Output\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n\n#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nvarying float fClipDistance;\n#endif\n\n#ifdef FOG\nvarying float fFogDistance;\n#endif\n\n#ifdef SHADOWS\n#if defined(SPOTLIGHT0) || defined(DIRLIGHT0)\nuniform mat4 lightMatrix0;\nvarying vec4 vPositionFromLight0;\n#endif\n#if defined(SPOTLIGHT1) || defined(DIRLIGHT1)\nuniform mat4 lightMatrix1;\nvarying vec4 vPositionFromLight1;\n#endif\n#if defined(SPOTLIGHT2) || defined(DIRLIGHT2)\nuniform mat4 lightMatrix2;\nvarying vec4 vPositionFromLight2;\n#endif\n#if defined(SPOTLIGHT3) || defined(DIRLIGHT3)\nuniform mat4 lightMatrix3;\nvarying vec4 vPositionFromLight3;\n#endif\n#endif\n\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\nvarying vec3 vDirectionW;\n#endif\n\n#ifdef LOGARITHMICDEPTH\nuniform float logarithmicDepthConstant;\nvarying float vFragmentDepth;\n#endif\n\nvoid main(void) {\n\n#ifdef REFLECTIONMAP_SKYBOX\n    vPositionUVW = position;\n#endif \n\n#ifdef INSTANCES\n    mat4 finalWorld = mat4(world0, world1, world2, world3);\n#else\n    mat4 finalWorld = world;\n#endif\n\n#if NUM_BONE_INFLUENCERS > 0\n    mat4 influence;\n    influence = mBones[int(matricesIndices[0])] * matricesWeights[0];\n\n#if NUM_BONE_INFLUENCERS > 1\n    influence += mBones[int(matricesIndices[1])] * matricesWeights[1];\n#endif \n#if NUM_BONE_INFLUENCERS > 2\n    influence += mBones[int(matricesIndices[2])] * matricesWeights[2];\n#endif	\n#if NUM_BONE_INFLUENCERS > 3\n    influence += mBones[int(matricesIndices[3])] * matricesWeights[3];\n#endif	\n\n#if NUM_BONE_INFLUENCERS > 4\n    influence += mBones[int(matricesIndicesExtra[0])] * matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS > 5\n    influence += mBones[int(matricesIndicesExtra[1])] * matricesWeightsExtra[1];\n#endif	\n#if NUM_BONE_INFLUENCERS > 6\n    influence += mBones[int(matricesIndicesExtra[2])] * matricesWeightsExtra[2];\n#endif	\n#if NUM_BONE_INFLUENCERS > 7\n    influence += mBones[int(matricesIndicesExtra[3])] * matricesWeightsExtra[3];\n#endif	\n\n    finalWorld = finalWorld * influence;\n#endif\n\n    gl_Position = viewProjection * finalWorld * vec4(position, 1.0);\n\n    vec4 worldPos = finalWorld * vec4(position, 1.0);\n    vPositionW = vec3(worldPos);\n\n#ifdef NORMAL\n    vNormalW = normalize(vec3(finalWorld * vec4(normal, 0.0)));\n#endif\n\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\n    vDirectionW = normalize(vec3(finalWorld * vec4(position, 0.0)));\n#endif\n\n    // Texture coordinates\n#ifndef UV1\n    vec2 uv = vec2(0., 0.);\n#endif\n#ifndef UV2\n    vec2 uv2 = vec2(0., 0.);\n#endif\n\n#ifdef DIFFUSE\n    if (vDiffuseInfos.x == 0.)\n    {\n        vDiffuseUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\n    }\n    else\n    {\n        vDiffuseUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\n    }\n#endif\n\n#ifdef AMBIENT\n    if (vAmbientInfos.x == 0.)\n    {\n        vAmbientUV = vec2(ambientMatrix * vec4(uv, 1.0, 0.0));\n    }\n    else\n    {\n        vAmbientUV = vec2(ambientMatrix * vec4(uv2, 1.0, 0.0));\n    }\n#endif\n\n#ifdef OPACITY\n    if (vOpacityInfos.x == 0.)\n    {\n        vOpacityUV = vec2(opacityMatrix * vec4(uv, 1.0, 0.0));\n    }\n    else\n    {\n        vOpacityUV = vec2(opacityMatrix * vec4(uv2, 1.0, 0.0));\n    }\n#endif\n\n#ifdef EMISSIVE\n    if (vEmissiveInfos.x == 0.)\n    {\n        vEmissiveUV = vec2(emissiveMatrix * vec4(uv, 1.0, 0.0));\n    }\n    else\n    {\n        vEmissiveUV = vec2(emissiveMatrix * vec4(uv2, 1.0, 0.0));\n    }\n#endif\n\n#ifdef LIGHTMAP\n    if (vLightmapInfos.x == 0.)\n    {\n        vLightmapUV = vec2(lightmapMatrix * vec4(uv, 1.0, 0.0));\n    }\n    else\n    {\n        vLightmapUV = vec2(lightmapMatrix * vec4(uv2, 1.0, 0.0));\n    }\n#endif\n\n#if defined(SPECULAR) && defined(SPECULARTERM)\n    if (vSpecularInfos.x == 0.)\n    {\n        vSpecularUV = vec2(specularMatrix * vec4(uv, 1.0, 0.0));\n    }\n    else\n    {\n        vSpecularUV = vec2(specularMatrix * vec4(uv2, 1.0, 0.0));\n    }\n#endif\n\n#ifdef BUMP\n    if (vBumpInfos.x == 0.)\n    {\n        vBumpUV = vec2(bumpMatrix * vec4(uv, 1.0, 0.0));\n    }\n    else\n    {\n        vBumpUV = vec2(bumpMatrix * vec4(uv2, 1.0, 0.0));\n    }\n#endif\n\n    // Clip plane\n#ifdef CLIPPLANE\n    fClipDistance = dot(worldPos, vClipPlane);\n#endif\n\n    // Fog\n#ifdef FOG\n    fFogDistance = (view * worldPos).z;\n#endif\n\n    // Shadows\n#ifdef SHADOWS\n#if defined(SPOTLIGHT0) || defined(DIRLIGHT0)\n    vPositionFromLight0 = lightMatrix0 * worldPos;\n#endif\n#if defined(SPOTLIGHT1) || defined(DIRLIGHT1)\n    vPositionFromLight1 = lightMatrix1 * worldPos;\n#endif\n#if defined(SPOTLIGHT2) || defined(DIRLIGHT2)\n    vPositionFromLight2 = lightMatrix2 * worldPos;\n#endif\n#if defined(SPOTLIGHT3) || defined(DIRLIGHT3)\n    vPositionFromLight3 = lightMatrix3 * worldPos;\n#endif\n#endif\n\n    // Vertex color\n#ifdef VERTEXCOLOR\n    vColor = color;\n#endif\n\n    // Point size\n#ifdef POINTSIZE\n    gl_PointSize = pointSize;\n#endif\n\n    // Log. depth\n#ifdef LOGARITHMICDEPTH\n    vFragmentDepth = 1.0 + gl_Position.w;\n    gl_Position.z = log2(max(0.000001, vFragmentDepth)) * logarithmicDepthConstant;\n#endif\n}",
BABYLON.Effect.ShadersStore.pbrPixelShader="#ifdef BUMP\n#extension GL_OES_standard_derivatives : enable\n#endif\n\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n\nprecision highp float;\n\n// Constants\n#define RECIPROCAL_PI2 0.15915494\n#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\n\nuniform vec3 vEyePosition;\nuniform vec3 vAmbientColor;\nuniform vec3 vReflectionColor;\nuniform vec4 vDiffuseColor;\n\n// CUSTOM CONTROLS\nuniform vec4 vLightingIntensity;\nuniform vec4 vCameraInfos;\n\n#ifdef OVERLOADEDVALUES\n    uniform vec4 vOverloadedIntensity;\n    uniform vec3 vOverloadedAmbient;\n    uniform vec3 vOverloadedDiffuse;\n    uniform vec3 vOverloadedSpecular;\n    uniform vec3 vOverloadedEmissive;\n    uniform vec3 vOverloadedReflection;\n    uniform vec3 vOverloadedGlossiness;\n#endif\n\n#ifdef OVERLOADEDSHADOWVALUES\n    uniform vec4 vOverloadedShadowIntensity;\n#endif\n\n// PBR CUSTOM CONSTANTS\nconst float kPi = 3.1415926535897932384626433832795;\n\n// PBR HELPER METHODS\nfloat Square(float value)\n{\n    return value * value;\n}\n\nfloat getLuminance(vec3 color)\n{\n    return clamp(dot(color, vec3(0.2126, 0.7152, 0.0722)), 0., 1.);\n}\n\nfloat convertRoughnessToAverageSlope(float roughness)\n{\n    // Calculate AlphaG as square of roughness; add epsilon to avoid numerical issues\n    const float kMinimumVariance = 0.0005;\n    float alphaG = Square(roughness) + kMinimumVariance;\n    return alphaG;\n}\n\n// From Microfacet Models for Refraction through Rough Surfaces, Walter et al. 2007\nfloat smithVisibilityG1_TrowbridgeReitzGGX(float dot, float alphaG)\n{\n    float tanSquared = (1.0 - dot * dot) / (dot * dot);\n    return 2.0 / (1.0 + sqrt(1.0 + alphaG * alphaG * tanSquared));\n}\n\nfloat smithVisibilityG_TrowbridgeReitzGGX_Walter(float NdotL, float NdotV, float alphaG)\n{\n    return smithVisibilityG1_TrowbridgeReitzGGX(NdotL, alphaG) * smithVisibilityG1_TrowbridgeReitzGGX(NdotV, alphaG);\n}\n\n// Trowbridge-Reitz (GGX)\n// Generalised Trowbridge-Reitz with gamma power=2.0\nfloat normalDistributionFunction_TrowbridgeReitzGGX(float NdotH, float alphaG)\n{\n    // Note: alphaG is average slope (gradient) of the normals in slope-space.\n    // It is also the (trigonometric) tangent of the median distribution value, i.e. 50% of normals have\n    // a tangent (gradient) closer to the macrosurface than this slope.\n    float a2 = Square(alphaG);\n    float d = NdotH * NdotH * (a2 - 1.0) + 1.0;\n    return a2 / (kPi * d * d);\n}\n\nvec3 fresnelSchlickGGX(float VdotH, vec3 reflectance0, vec3 reflectance90)\n{\n    return reflectance0 + (reflectance90 - reflectance0) * pow(clamp(1.0 - VdotH, 0., 1.), 5.0);\n}\n\nvec3 FresnelSchlickEnvironmentGGX(float VdotN, vec3 reflectance0, vec3 reflectance90, float smoothness)\n{\n    // Schlick fresnel approximation, extended with basic smoothness term so that rough surfaces do not approach reflectance90 at grazing angle\n    float weight = mix(FRESNEL_MAXIMUM_ON_ROUGH, 1.0, smoothness);\n    return reflectance0 + weight * (reflectance90 - reflectance0) * pow(clamp(1.0 - VdotN, 0., 1.), 5.0);\n}\n\n// Cook Torance Specular computation.\nvec3 computeSpecularTerm(float NdotH, float NdotL, float NdotV, float VdotH, float roughness, vec3 specularColor)\n{\n    float alphaG = convertRoughnessToAverageSlope(roughness);\n    float distribution = normalDistributionFunction_TrowbridgeReitzGGX(NdotH, alphaG);\n    float visibility = smithVisibilityG_TrowbridgeReitzGGX_Walter(NdotL, NdotV, alphaG);\n    visibility /= (4.0 * NdotL * NdotV); // Cook Torance Denominator  integated in viibility to avoid issues when visibility function changes.\n\n    vec3 fresnel = fresnelSchlickGGX(VdotH, specularColor, vec3(1., 1., 1.));\n\n    float specTerm = max(0., visibility * distribution) * NdotL;\n    return fresnel * specTerm * kPi; // TODO: audit pi constants\n}\n\nfloat computeDiffuseTerm(float NdotL, float NdotV, float VdotH, float roughness)\n{\n    // Diffuse fresnel falloff as per Disney principled BRDF, and in the spirit of\n    // of general coupled diffuse/specular models e.g. Ashikhmin Shirley.\n    float diffuseFresnelNV = pow(clamp(1.0 - NdotL, 0.000001, 1.), 5.0);\n    float diffuseFresnelNL = pow(clamp(1.0 - NdotV, 0.000001, 1.), 5.0);\n    float diffuseFresnel90 = 0.5 + 2.0 * VdotH * VdotH * roughness;\n    float diffuseFresnelTerm =\n        (1.0 + (diffuseFresnel90 - 1.0) * diffuseFresnelNL) *\n        (1.0 + (diffuseFresnel90 - 1.0) * diffuseFresnelNV);\n\n\n    return diffuseFresnelTerm * NdotL;\n    // PI Test\n    // diffuseFresnelTerm /= kPi;\n}\n\nfloat computeDefaultGlossiness(float glossiness, vec3 specularColor)\n{\n    float kSpecularNoAlphaWorkflow_SmoothnessMax = 0.95;\n\n    float specularLuminance = getLuminance(specularColor);\n    float specularLuma = sqrt(specularLuminance);\n    glossiness = specularLuma * kSpecularNoAlphaWorkflow_SmoothnessMax;\n\n    return glossiness;\n}\n\nvec3 toLinearSpace(vec3 color)\n{\n    return vec3(pow(color.r, 2.2), pow(color.g, 2.2), pow(color.b, 2.2));\n}\n\nvec3 toGammaSpace(vec3 color)\n{\n    return vec3(pow(color.r, 1.0 / 2.2), pow(color.g, 1.0 / 2.2), pow(color.b, 1.0 / 2.2));\n}\n\n#ifdef CAMERATONEMAP\n    vec3 toneMaps(vec3 color)\n    {\n        color = max(color, 0.0);\n\n        // TONE MAPPING / EXPOSURE\n        color.rgb = color.rgb * vCameraInfos.x;\n\n        float tuning = 1.5; // TODO: sync up so e.g. 18% greys are matched to exposure appropriately\n        // PI Test\n        // tuning *=  kPi;\n        vec3 tonemapped = 1.0 - exp2(-color.rgb * tuning); // simple local photographic tonemapper\n        color.rgb = mix(color.rgb, tonemapped, 1.0);\n        return color;\n    }\n#endif\n\n#ifdef CAMERACONTRAST\n    vec4 contrasts(vec4 color)\n    {\n        color = clamp(color, 0.0, 1.0);\n\n        vec3 resultHighContrast = color.rgb * color.rgb * (3.0 - 2.0 * color.rgb);\n        float contrast = vCameraInfos.y;\n        if (contrast < 1.0)\n        {\n            // Decrease contrast: interpolate towards zero-contrast image (flat grey)\n            color.rgb = mix(vec3(0.5, 0.5, 0.5), color.rgb, contrast);\n        }\n        else\n        {\n            // Increase contrast: apply simple shoulder-toe high contrast curve\n            color.rgb = mix(color.rgb, resultHighContrast, contrast - 1.0);\n        }\n\n        return color;\n    }\n#endif\n// END PBR HELPER METHODS\n\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nuniform vec3 vEmissiveColor;\n\n// Input\nvarying vec3 vPositionW;\n\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n\n// Lights\n#ifdef LIGHT0\nuniform vec4 vLightData0;\nuniform vec4 vLightDiffuse0;\n#ifdef SPECULARTERM\nuniform vec3 vLightSpecular0;\n#endif\n#ifdef SHADOW0\n#if defined(SPOTLIGHT0) || defined(DIRLIGHT0)\nvarying vec4 vPositionFromLight0;\nuniform sampler2D shadowSampler0;\n#else\nuniform samplerCube shadowSampler0;\n#endif\nuniform vec3 shadowsInfo0;\n#endif\n#ifdef SPOTLIGHT0\nuniform vec4 vLightDirection0;\n#endif\n#ifdef HEMILIGHT0\nuniform vec3 vLightGround0;\n#endif\n#endif\n\n#ifdef LIGHT1\nuniform vec4 vLightData1;\nuniform vec4 vLightDiffuse1;\n#ifdef SPECULARTERM\nuniform vec3 vLightSpecular1;\n#endif\n#ifdef SHADOW1\n#if defined(SPOTLIGHT1) || defined(DIRLIGHT1)\nvarying vec4 vPositionFromLight1;\nuniform sampler2D shadowSampler1;\n#else\nuniform samplerCube shadowSampler1;\n#endif\nuniform vec3 shadowsInfo1;\n#endif\n#ifdef SPOTLIGHT1\nuniform vec4 vLightDirection1;\n#endif\n#ifdef HEMILIGHT1\nuniform vec3 vLightGround1;\n#endif\n#endif\n\n#ifdef LIGHT2\nuniform vec4 vLightData2;\nuniform vec4 vLightDiffuse2;\n#ifdef SPECULARTERM\nuniform vec3 vLightSpecular2;\n#endif\n#ifdef SHADOW2\n#if defined(SPOTLIGHT2) || defined(DIRLIGHT2)\nvarying vec4 vPositionFromLight2;\nuniform sampler2D shadowSampler2;\n#else\nuniform samplerCube shadowSampler2;\n#endif\nuniform vec3 shadowsInfo2;\n#endif\n#ifdef SPOTLIGHT2\nuniform vec4 vLightDirection2;\n#endif\n#ifdef HEMILIGHT2\nuniform vec3 vLightGround2;\n#endif\n#endif\n\n#ifdef LIGHT3\nuniform vec4 vLightData3;\nuniform vec4 vLightDiffuse3;\n#ifdef SPECULARTERM\nuniform vec3 vLightSpecular3;\n#endif\n#ifdef SHADOW3\n#if defined(SPOTLIGHT3) || defined(DIRLIGHT3)\nvarying vec4 vPositionFromLight3;\nuniform sampler2D shadowSampler3;\n#else\nuniform samplerCube shadowSampler3;\n#endif\nuniform vec3 shadowsInfo3;\n#endif\n#ifdef SPOTLIGHT3\nuniform vec4 vLightDirection3;\n#endif\n#ifdef HEMILIGHT3\nuniform vec3 vLightGround3;\n#endif\n#endif\n\n// Samplers\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform sampler2D diffuseSampler;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform sampler2D ambientSampler;\nuniform vec2 vAmbientInfos;\n#endif\n\n#ifdef OPACITY	\nvarying vec2 vOpacityUV;\nuniform sampler2D opacitySampler;\nuniform vec2 vOpacityInfos;\n#endif\n\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform sampler2D emissiveSampler;\n#endif\n\n#ifdef LIGHTMAP\nvarying vec2 vLightmapUV;\nuniform vec2 vLightmapInfos;\nuniform sampler2D lightmapSampler;\n#endif\n\n#if defined(SPECULAR) && defined(SPECULARTERM)\nvarying vec2 vSpecularUV;\nuniform vec2 vSpecularInfos;\nuniform sampler2D specularSampler;\n#endif\n\n// Fresnel\n#ifdef FRESNEL\nfloat computeFresnelTerm(vec3 viewDirection, vec3 worldNormal, float bias, float power)\n{\n    float fresnelTerm = pow(bias + abs(dot(viewDirection, worldNormal)), power);\n    return clamp(fresnelTerm, 0., 1.);\n}\n#endif\n\n#ifdef OPACITYFRESNEL\nuniform vec4 opacityParts;\n#endif\n\n#ifdef EMISSIVEFRESNEL\nuniform vec4 emissiveLeftColor;\nuniform vec4 emissiveRightColor;\n#endif\n\n// Reflection\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\n\n#ifdef REFLECTIONMAP_3D\nuniform samplerCube reflectionCubeSampler;\n#else\nuniform sampler2D reflection2DSampler;\n#endif\n\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\nvarying vec3 vDirectionW;\n#endif\n\n#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION)\nuniform mat4 reflectionMatrix;\n#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION)\nuniform mat4 view;\n#endif\n#endif\n\nvec3 computeReflectionCoords(vec4 worldPos, vec3 worldNormal)\n{\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\n    vec3 direction = normalize(vDirectionW);\n\n    float t = clamp(direction.y * -0.5 + 0.5, 0., 1.0);\n    float s = atan(direction.z, direction.x) * RECIPROCAL_PI2 + 0.5;\n\n    return vec3(s, t, 0);\n#endif\n\n#ifdef REFLECTIONMAP_SPHERICAL\n    vec3 viewDir = normalize(vec3(view * worldPos));\n    vec3 viewNormal = normalize(vec3(view * vec4(worldNormal, 0.0)));\n\n    vec3 r = reflect(viewDir, viewNormal);\n    r.z = r.z - 1.0;\n\n    float m = 2.0 * length(r);\n\n    return vec3(r.x / m + 0.5, 1.0 - r.y / m - 0.5, 0);\n#endif\n\n#ifdef REFLECTIONMAP_PLANAR\n    vec3 viewDir = worldPos.xyz - vEyePosition;\n    vec3 coords = normalize(reflect(viewDir, worldNormal));\n\n    return vec3(reflectionMatrix * vec4(coords, 1));\n#endif\n\n#ifdef REFLECTIONMAP_CUBIC\n    vec3 viewDir = worldPos.xyz - vEyePosition;\n    vec3 coords = reflect(viewDir, worldNormal);\n#ifdef INVERTCUBICMAP\n    coords.y = 1.0 - coords.y;\n#endif\n    return vec3(reflectionMatrix * vec4(coords, 0));\n#endif\n\n#ifdef REFLECTIONMAP_PROJECTION\n    return vec3(reflectionMatrix * (view * worldPos));\n#endif\n\n#ifdef REFLECTIONMAP_SKYBOX\n    return vPositionUVW;\n#endif\n\n#ifdef REFLECTIONMAP_EXPLICIT\n    return vec3(0, 0, 0);\n#endif\n}\n\n#endif\n\n// Shadows\n#ifdef SHADOWS\n\nfloat unpack(vec4 color)\n{\n    const vec4 bit_shift = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\n    return dot(color, bit_shift);\n}\n\n#if defined(POINTLIGHT0) || defined(POINTLIGHT1) || defined(POINTLIGHT2) || defined(POINTLIGHT3)\nfloat computeShadowCube(vec3 lightPosition, samplerCube shadowSampler, float darkness, float bias)\n{\n    vec3 directionToLight = vPositionW - lightPosition;\n    float depth = length(directionToLight);\n\n    depth = clamp(depth, 0., 1.);\n\n    directionToLight.y = 1.0 - directionToLight.y;\n\n    float shadow = unpack(textureCube(shadowSampler, directionToLight)) + bias;\n\n    if (depth > shadow)\n    {\n#ifdef OVERLOADEDSHADOWVALUES\n        return mix(1.0, darkness, vOverloadedShadowIntensity.x);\n#else\n        return darkness;\n#endif\n    }\n    return 1.0;\n}\n\nfloat computeShadowWithPCFCube(vec3 lightPosition, samplerCube shadowSampler, float mapSize, float bias, float darkness)\n{\n    vec3 directionToLight = vPositionW - lightPosition;\n    float depth = length(directionToLight);\n    float diskScale = (1.0 - (1.0 + depth * 3.0)) / mapSize;\n\n    depth = clamp(depth, 0., 1.);\n\n    directionToLight.y = 1.0 - directionToLight.y;\n\n    float visibility = 1.;\n\n    vec3 poissonDisk[4];\n    poissonDisk[0] = vec3(-1.0, 1.0, -1.0);\n    poissonDisk[1] = vec3(1.0, -1.0, -1.0);\n    poissonDisk[2] = vec3(-1.0, -1.0, -1.0);\n    poissonDisk[3] = vec3(1.0, -1.0, 1.0);\n\n    // Poisson Sampling\n    float biasedDepth = depth - bias;\n\n    if (unpack(textureCube(shadowSampler, directionToLight + poissonDisk[0] * diskScale)) < biasedDepth) visibility -= 0.25;\n    if (unpack(textureCube(shadowSampler, directionToLight + poissonDisk[1] * diskScale)) < biasedDepth) visibility -= 0.25;\n    if (unpack(textureCube(shadowSampler, directionToLight + poissonDisk[2] * diskScale)) < biasedDepth) visibility -= 0.25;\n    if (unpack(textureCube(shadowSampler, directionToLight + poissonDisk[3] * diskScale)) < biasedDepth) visibility -= 0.25;\n\n#ifdef OVERLOADEDSHADOWVALUES\n    return  min(1.0, mix(1.0, visibility + darkness, vOverloadedShadowIntensity.x));\n#else\n    return  min(1.0, visibility + darkness);\n#endif\n}\n#endif\n\n#if defined(SPOTLIGHT0) || defined(SPOTLIGHT1) || defined(SPOTLIGHT2) || defined(SPOTLIGHT3) ||  defined(DIRLIGHT0) || defined(DIRLIGHT1) || defined(DIRLIGHT2) || defined(DIRLIGHT3)\nfloat computeShadow(vec4 vPositionFromLight, sampler2D shadowSampler, float darkness, float bias)\n{\n    vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n    depth = 0.5 * depth + vec3(0.5);\n    vec2 uv = depth.xy;\n\n    if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n    {\n        return 1.0;\n    }\n\n    float shadow = unpack(texture2D(shadowSampler, uv)) + bias;\n\n    if (depth.z > shadow)\n    {\n#ifdef OVERLOADEDSHADOWVALUES\n        return mix(1.0, darkness, vOverloadedShadowIntensity.x);\n#else\n        return darkness;\n#endif\n    }\n    return 1.;\n}\n\nfloat computeShadowWithPCF(vec4 vPositionFromLight, sampler2D shadowSampler, float mapSize, float bias, float darkness)\n{\n    vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n    depth = 0.5 * depth + vec3(0.5);\n    vec2 uv = depth.xy;\n\n    if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n    {\n        return 1.0;\n    }\n\n    float visibility = 1.;\n\n    vec2 poissonDisk[4];\n    poissonDisk[0] = vec2(-0.94201624, -0.39906216);\n    poissonDisk[1] = vec2(0.94558609, -0.76890725);\n    poissonDisk[2] = vec2(-0.094184101, -0.92938870);\n    poissonDisk[3] = vec2(0.34495938, 0.29387760);\n\n    // Poisson Sampling\n    float biasedDepth = depth.z - bias;\n\n    if (unpack(texture2D(shadowSampler, uv + poissonDisk[0] / mapSize)) < biasedDepth) visibility -= 0.25;\n    if (unpack(texture2D(shadowSampler, uv + poissonDisk[1] / mapSize)) < biasedDepth) visibility -= 0.25;\n    if (unpack(texture2D(shadowSampler, uv + poissonDisk[2] / mapSize)) < biasedDepth) visibility -= 0.25;\n    if (unpack(texture2D(shadowSampler, uv + poissonDisk[3] / mapSize)) < biasedDepth) visibility -= 0.25;\n\n#ifdef OVERLOADEDSHADOWVALUES\n    return  min(1.0, mix(1.0, visibility + darkness, vOverloadedShadowIntensity.x));\n#else\n    return  min(1.0, visibility + darkness);\n#endif\n}\n\n// Thanks to http://devmaster.net/\nfloat unpackHalf(vec2 color)\n{\n    return color.x + (color.y / 255.0);\n}\n\nfloat linstep(float low, float high, float v) {\n    return clamp((v - low) / (high - low), 0.0, 1.0);\n}\n\nfloat ChebychevInequality(vec2 moments, float compare, float bias)\n{\n    float p = smoothstep(compare - bias, compare, moments.x);\n    float variance = max(moments.y - moments.x * moments.x, 0.02);\n    float d = compare - moments.x;\n    float p_max = linstep(0.2, 1.0, variance / (variance + d * d));\n\n    return clamp(max(p, p_max), 0.0, 1.0);\n}\n\nfloat computeShadowWithVSM(vec4 vPositionFromLight, sampler2D shadowSampler, float bias, float darkness)\n{\n    vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n    depth = 0.5 * depth + vec3(0.5);\n    vec2 uv = depth.xy;\n\n    if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0 || depth.z >= 1.0)\n    {\n        return 1.0;\n    }\n\n    vec4 texel = texture2D(shadowSampler, uv);\n\n    vec2 moments = vec2(unpackHalf(texel.xy), unpackHalf(texel.zw));\n#ifdef OVERLOADEDSHADOWVALUES\n    return min(1.0, mix(1.0, 1.0 - ChebychevInequality(moments, depth.z, bias) + darkness, vOverloadedShadowIntensity.x));\n#else\n    return min(1.0, 1.0 - ChebychevInequality(moments, depth.z, bias) + darkness);\n#endif\n}\n#endif\n\n#endif\n\n// Bump\n#ifdef BUMP\nvarying vec2 vBumpUV;\nuniform vec2 vBumpInfos;\nuniform sampler2D bumpSampler;\n\n// Thanks to http://www.thetenthplanet.de/archives/1180\nmat3 cotangent_frame(vec3 normal, vec3 p, vec2 uv)\n{\n    // get edge vectors of the pixel triangle\n    vec3 dp1 = dFdx(p);\n    vec3 dp2 = dFdy(p);\n    vec2 duv1 = dFdx(uv);\n    vec2 duv2 = dFdy(uv);\n\n    // solve the linear system\n    vec3 dp2perp = cross(dp2, normal);\n    vec3 dp1perp = cross(normal, dp1);\n    vec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;\n    vec3 binormal = dp2perp * duv1.y + dp1perp * duv2.y;\n\n    // construct a scale-invariant frame \n    float invmax = inversesqrt(max(dot(tangent, tangent), dot(binormal, binormal)));\n    return mat3(tangent * invmax, binormal * invmax, normal);\n}\n\nvec3 perturbNormal(vec3 viewDir)\n{\n    vec3 map = texture2D(bumpSampler, vBumpUV).xyz;\n    map = map * 255. / 127. - 128. / 127.;\n    mat3 TBN = cotangent_frame(vNormalW * vBumpInfos.y, -viewDir, vBumpUV);\n    return normalize(TBN * map);\n}\n#endif\n\n#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n\n#ifdef LOGARITHMICDEPTH\nuniform float logarithmicDepthConstant;\nvarying float vFragmentDepth;\n#endif\n\n// Fog\n#ifdef FOG\n\n#define FOGMODE_NONE    0.\n#define FOGMODE_EXP     1.\n#define FOGMODE_EXP2    2.\n#define FOGMODE_LINEAR  3.\n#define E 2.71828\n\nuniform vec4 vFogInfos;\nuniform vec3 vFogColor;\nvarying float fFogDistance;\n\nfloat CalcFogFactor()\n{\n    float fogCoeff = 1.0;\n    float fogStart = vFogInfos.y;\n    float fogEnd = vFogInfos.z;\n    float fogDensity = vFogInfos.w;\n\n    if (FOGMODE_LINEAR == vFogInfos.x)\n    {\n        fogCoeff = (fogEnd - fFogDistance) / (fogEnd - fogStart);\n    }\n    else if (FOGMODE_EXP == vFogInfos.x)\n    {\n        fogCoeff = 1.0 / pow(E, fFogDistance * fogDensity);\n    }\n    else if (FOGMODE_EXP2 == vFogInfos.x)\n    {\n        fogCoeff = 1.0 / pow(E, fFogDistance * fFogDistance * fogDensity * fogDensity);\n    }\n\n    return clamp(fogCoeff, 0.0, 1.0);\n}\n#endif\n\n// Light Computing\nstruct lightingInfo\n{\n    vec3 diffuse;\n#ifdef SPECULARTERM\n    vec3 specular;\n#endif\n};\n\nlightingInfo computeLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, float range, float roughness, float NdotV) {\n    lightingInfo result;\n\n    vec3 lightVectorW;\n    float attenuation = 1.0;\n    if (lightData.w == 0.)\n    {\n        vec3 direction = lightData.xyz - vPositionW;\n\n        attenuation = max(0., 1.0 - length(direction) / range);\n        lightVectorW = normalize(direction);\n    }\n    else\n    {\n        lightVectorW = normalize(-lightData.xyz);\n    }\n\n    // diffuse\n    vec3 H = normalize(viewDirectionW + lightVectorW);\n    float NdotL = max(0.00000000001, dot(vNormal, lightVectorW));\n    float VdotH = clamp(0.00000000001, 1.0, dot(viewDirectionW, H));\n\n    float diffuseTerm = computeDiffuseTerm(NdotL, NdotV, VdotH, roughness);\n    result.diffuse = diffuseTerm * diffuseColor * attenuation;\n\n#ifdef SPECULARTERM\n    // Specular\n    float NdotH = max(0.00000000001, dot(vNormal, H));\n\n    vec3 specTerm = computeSpecularTerm(NdotH, NdotL, NdotV, VdotH, roughness, specularColor);\n    result.specular = specTerm * attenuation;\n#endif\n\n    return result;\n}\n\nlightingInfo computeSpotLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 lightDirection, vec3 diffuseColor, vec3 specularColor, float range, float roughness, float NdotV) {\n    lightingInfo result;\n\n    vec3 direction = lightData.xyz - vPositionW;\n    vec3 lightVectorW = normalize(direction);\n    float attenuation = max(0., 1.0 - length(direction) / range);\n\n    // diffuse\n    float cosAngle = max(0.0000001, dot(-lightDirection.xyz, lightVectorW));\n    float spotAtten = 0.0;\n\n    if (cosAngle >= lightDirection.w)\n    {\n        cosAngle = max(0., pow(cosAngle, lightData.w));\n        spotAtten = clamp((cosAngle - lightDirection.w) / (1. - cosAngle), 0.0, 1.0);\n\n        // Diffuse\n        vec3 H = normalize(viewDirectionW - lightDirection.xyz);\n        float NdotL = max(0.00000000001, dot(vNormal, -lightDirection.xyz));\n        float VdotH = clamp(dot(viewDirectionW, H), 0.00000000001, 1.0);\n\n        float diffuseTerm = computeDiffuseTerm(NdotL, NdotV, VdotH, roughness);\n        result.diffuse = diffuseTerm * diffuseColor * attenuation * spotAtten;\n\n#ifdef SPECULARTERM\n        // Specular\n        float NdotH = max(0.00000000001, dot(vNormal, H));\n\n        vec3 specTerm = computeSpecularTerm(NdotH, NdotL, NdotV, VdotH, roughness, specularColor);\n        result.specular = specTerm  * attenuation * spotAtten;\n#endif\n\n        return result;\n    }\n\n    result.diffuse = vec3(0.);\n#ifdef SPECULARTERM\n    result.specular = vec3(0.);\n#endif\n\n    return result;\n}\n\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, vec3 groundColor, float roughness, float NdotV) {\n    lightingInfo result;\n\n    vec3 lightVectorW = normalize(lightData.xyz);\n\n    // Diffuse\n    float ndl = dot(vNormal, lightData.xyz) * 0.5 + 0.5;\n    result.diffuse = mix(groundColor, diffuseColor, ndl);\n\n#ifdef SPECULARTERM\n    // Specular\n    vec3 H = normalize(viewDirectionW + lightVectorW);\n    float NdotH = max(0.00000000001, dot(vNormal, H));\n    float NdotL = max(0.00000000001, ndl);\n    float VdotH = clamp(0.00000000001, 1.0, dot(viewDirectionW, H));\n\n    vec3 specTerm = computeSpecularTerm(NdotH, NdotL, NdotV, VdotH, roughness, specularColor);\n    result.specular = specTerm;\n#endif\n\n    return result;\n}\n\nvoid main(void) {\n    // Clip plane\n#ifdef CLIPPLANE\n    if (fClipDistance > 0.0)\n        discard;\n#endif\n\n    vec3 viewDirectionW = normalize(vEyePosition - vPositionW);\n\n    // Base color\n    vec4 baseColor = vec4(1., 1., 1., 1.);\n    vec3 diffuseColor = vDiffuseColor.rgb;\n    \n    // Alpha\n    float alpha = vDiffuseColor.a;\n\n#ifdef DIFFUSE\n    baseColor = texture2D(diffuseSampler, vDiffuseUV);\n    baseColor = vec4(toLinearSpace(baseColor.rgb), baseColor.a);\n\n#ifdef ALPHATEST\n    if (baseColor.a < 0.4)\n        discard;\n#endif\n\n#ifdef ALPHAFROMDIFFUSE\n    alpha *= baseColor.a;\n#endif\n\n    baseColor.rgb *= vDiffuseInfos.y;\n#endif\n\n#ifdef VERTEXCOLOR\n    baseColor.rgb *= vColor.rgb;\n#endif\n\n#ifdef OVERLOADEDVALUES\n    baseColor.rgb = mix(baseColor.rgb, vOverloadedDiffuse, vOverloadedIntensity.y);\n    diffuseColor.rgb = mix(diffuseColor.rgb, vOverloadedDiffuse, vOverloadedIntensity.y);\n#endif\n\n    // Bump\n#ifdef NORMAL\n    vec3 normalW = normalize(vNormalW);\n#else\n    vec3 normalW = vec3(1.0, 1.0, 1.0);\n#endif\n\n\n#ifdef BUMP\n    normalW = perturbNormal(viewDirectionW);\n#endif\n\n    // Ambient color\n    vec3 baseAmbientColor = vec3(1., 1., 1.);\n\n#ifdef AMBIENT\n    baseAmbientColor = texture2D(ambientSampler, vAmbientUV).rgb * vAmbientInfos.y;\n    \n    #ifdef OVERLOADEDVALUES\n        baseAmbientColor.rgb = mix(baseAmbientColor.rgb, vOverloadedAmbient, vOverloadedIntensity.x);\n    #endif\n#endif\n\n    // Specular map\n#ifdef SPECULARTERM\n    float glossiness = vSpecularColor.a;\n    vec3 specularColor = vSpecularColor.rgb;\n    \n    #ifdef OVERLOADEDVALUES\n        specularColor.rgb = mix(specularColor.rgb, vOverloadedSpecular, vOverloadedIntensity.z);\n    #endif\n\n    #ifdef SPECULAR\n        vec4 specularMapColor = texture2D(specularSampler, vSpecularUV);\n        specularColor = toLinearSpace(specularMapColor.rgb);\n\n        #ifdef OVERLOADEDVALUES\n                specularColor.rgb = mix(specularColor.rgb, vOverloadedSpecular, vOverloadedIntensity.z);\n        #endif\n\n        #ifdef GLOSSINESSFROMSPECULARMAP\n            glossiness = specularMapColor.a;\n        #else\n            glossiness = computeDefaultGlossiness(glossiness, specularColor);\n        #endif\n    #endif\n\n    #ifdef OVERLOADEDVALUES\n        glossiness = mix(glossiness, vOverloadedGlossiness.x, vOverloadedGlossiness.y);\n    #endif\n#else\n    float glossiness = 0.;\n    #ifdef OVERLOADEDVALUES\n        glossiness = mix(glossiness, vOverloadedGlossiness.x, vOverloadedGlossiness.y);\n    #endif\n    \n    vec3 specularColor = vec3(0., 0., 0);\n    #ifdef OVERLOADEDVALUES\n        specularColor.rgb = mix(specularColor.rgb, vOverloadedSpecular, vOverloadedIntensity.z);\n    #endif\n#endif\n\n    // Apply Energy Conservation taking in account the environment level only if the environment is present.\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n    baseColor.rgb = (1. - reflectance) * baseColor.rgb;\n\n    // Compute Specular Fresnel + Reflectance.\n    float NdotV = max(0.00000000001, dot(normalW, viewDirectionW));\n\n    // Adapt glossiness.\n    glossiness = clamp(glossiness, 0., 1.) * 0.98;\n\n    // Call rough to not conflict with previous one.\n    float rough = clamp(1. - glossiness, 0.000001, 1.0);\n\n    // Lighting\n    vec3 diffuseBase = vec3(0., 0., 0.);\n    \n#ifdef OVERLOADEDSHADOWVALUES\n    vec3 shadowedOnlyDiffuseBase = vec3(1., 1., 1.);\n#endif\n\n#ifdef SPECULARTERM\n    vec3 specularBase = vec3(0., 0., 0.);\n#endif\n    float shadow = 1.;\n\n#ifdef LIGHT0\n#ifndef SPECULARTERM\n    vec3 vLightSpecular0 = vec3(0.0);\n#endif\n#ifdef SPOTLIGHT0\n    lightingInfo info = computeSpotLighting(viewDirectionW, normalW, vLightData0, vLightDirection0, vLightDiffuse0.rgb, vLightSpecular0, vLightDiffuse0.a, rough, NdotV);\n#endif\n#ifdef HEMILIGHT0\n    lightingInfo info = computeHemisphericLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0.rgb, vLightSpecular0, vLightGround0, rough, NdotV);\n#endif\n#if defined(POINTLIGHT0) || defined(DIRLIGHT0)\n    lightingInfo info = computeLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0.rgb, vLightSpecular0, vLightDiffuse0.a, rough, NdotV);\n#endif\n#ifdef SHADOW0\n#ifdef SHADOWVSM0\n    shadow = computeShadowWithVSM(vPositionFromLight0, shadowSampler0, shadowsInfo0.z, shadowsInfo0.x);\n#else\n#ifdef SHADOWPCF0\n#if defined(POINTLIGHT0)\n    shadow = computeShadowWithPCFCube(vLightData0.xyz, shadowSampler0, shadowsInfo0.y, shadowsInfo0.z, shadowsInfo0.x);\n#else\n    shadow = computeShadowWithPCF(vPositionFromLight0, shadowSampler0, shadowsInfo0.y, shadowsInfo0.z, shadowsInfo0.x);\n#endif\n#else\n#if defined(POINTLIGHT0)\n    shadow = computeShadowCube(vLightData0.xyz, shadowSampler0, shadowsInfo0.x, shadowsInfo0.z);\n#else\n    shadow = computeShadow(vPositionFromLight0, shadowSampler0, shadowsInfo0.x, shadowsInfo0.z);\n#endif\n#endif\n#endif\n#else\n    shadow = 1.;\n#endif\n    diffuseBase += info.diffuse * shadow;\n#ifdef OVERLOADEDSHADOWVALUES\n    shadowedOnlyDiffuseBase *= shadow;\n#endif\n\n#ifdef SPECULARTERM\n    specularBase += info.specular * shadow;\n#endif\n#endif\n\n#ifdef LIGHT1\n#ifndef SPECULARTERM\n    vec3 vLightSpecular1 = vec3(0.0);\n#endif\n#ifdef SPOTLIGHT1\n    info = computeSpotLighting(viewDirectionW, normalW, vLightData1, vLightDirection1, vLightDiffuse1.rgb, vLightSpecular1, vLightDiffuse1.a, rough, NdotV);\n#endif\n#ifdef HEMILIGHT1\n    info = computeHemisphericLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1.rgb, vLightSpecular1, vLightGround1, rough, NdotV);\n#endif\n#if defined(POINTLIGHT1) || defined(DIRLIGHT1)\n    info = computeLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1.rgb, vLightSpecular1, vLightDiffuse1.a, rough, NdotV);\n#endif\n#ifdef SHADOW1\n#ifdef SHADOWVSM1\n    shadow = computeShadowWithVSM(vPositionFromLight1, shadowSampler1, shadowsInfo1.z, shadowsInfo1.x);\n#else\n#ifdef SHADOWPCF1\n#if defined(POINTLIGHT1)\n    shadow = computeShadowWithPCFCube(vLightData1.xyz, shadowSampler1, shadowsInfo1.y, shadowsInfo1.z, shadowsInfo1.x);\n#else\n    shadow = computeShadowWithPCF(vPositionFromLight1, shadowSampler1, shadowsInfo1.y, shadowsInfo1.z, shadowsInfo1.x);\n#endif\n#else\n#if defined(POINTLIGHT1)\n    shadow = computeShadowCube(vLightData1.xyz, shadowSampler1, shadowsInfo1.x, shadowsInfo1.z);\n#else\n    shadow = computeShadow(vPositionFromLight1, shadowSampler1, shadowsInfo1.x, shadowsInfo1.z);\n#endif\n#endif\n#endif\n#else\n    shadow = 1.;\n#endif\n\n    diffuseBase += info.diffuse * shadow;\n#ifdef OVERLOADEDSHADOWVALUES\n    shadowedOnlyDiffuseBase *= shadow;\n#endif\n\n#ifdef SPECULARTERM\n    specularBase += info.specular * shadow;\n#endif\n#endif\n\n#ifdef LIGHT2\n#ifndef SPECULARTERM\n    vec3 vLightSpecular2 = vec3(0.0);\n#endif\n#ifdef SPOTLIGHT2\n    info = computeSpotLighting(viewDirectionW, normalW, vLightData2, vLightDirection2, vLightDiffuse2.rgb, vLightSpecular2, vLightDiffuse2.a, rough, NdotV);\n#endif\n#ifdef HEMILIGHT2\n    info = computeHemisphericLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2.rgb, vLightSpecular2, vLightGround2, rough, NdotV);\n#endif\n#if defined(POINTLIGHT2) || defined(DIRLIGHT2)\n    info = computeLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2.rgb, vLightSpecular2, vLightDiffuse2.a, rough, NdotV);\n#endif\n#ifdef SHADOW2\n#ifdef SHADOWVSM2\n    shadow = computeShadowWithVSM(vPositionFromLight2, shadowSampler2, shadowsInfo2.z, shadowsInfo2.x);\n#else\n#ifdef SHADOWPCF2\n#if defined(POINTLIGHT2)\n    shadow = computeShadowWithPCFCube(vLightData2.xyz, shadowSampler2, shadowsInfo2.y, shadowsInfo2.z, shadowsInfo2.x);\n#else\n    shadow = computeShadowWithPCF(vPositionFromLight2, shadowSampler2, shadowsInfo2.y, shadowsInfo2.z, shadowsInfo2.x);\n#endif\n#else\n#if defined(POINTLIGHT2)\n    shadow = computeShadowCube(vLightData2.xyz, shadowSampler2, shadowsInfo2.x, shadowsInfo2.z);\n#else\n    shadow = computeShadow(vPositionFromLight2, shadowSampler2, shadowsInfo2.x, shadowsInfo2.z);\n#endif\n#endif	\n#endif	\n#else\n    shadow = 1.;\n#endif\n\n    diffuseBase += info.diffuse * shadow;\n#ifdef OVERLOADEDSHADOWVALUES\n    shadowedOnlyDiffuseBase *= shadow;\n#endif\n\n#ifdef SPECULARTERM\n    specularBase += info.specular * shadow;\n#endif\n#endif\n\n#ifdef LIGHT3\n#ifndef SPECULARTERM\n    vec3 vLightSpecular3 = vec3(0.0);\n#endif\n#ifdef SPOTLIGHT3\n    info = computeSpotLighting(viewDirectionW, normalW, vLightData3, vLightDirection3, vLightDiffuse3.rgb, vLightSpecular3, vLightDiffuse3.a, rough, NdotV);\n#endif\n#ifdef HEMILIGHT3\n    info = computeHemisphericLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3.rgb, vLightSpecular3, vLightGround3, rough, NdotV);\n#endif\n#if defined(POINTLIGHT3) || defined(DIRLIGHT3)\n    info = computeLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3.rgb, vLightSpecular3, vLightDiffuse3.a, rough, NdotV);\n#endif\n#ifdef SHADOW3\n#ifdef SHADOWVSM3\n    shadow = computeShadowWithVSM(vPositionFromLight3, shadowSampler3, shadowsInfo3.z, shadowsInfo3.x);\n#else\n#ifdef SHADOWPCF3\n#if defined(POINTLIGHT3)\n    shadow = computeShadowWithPCFCube(vLightData3.xyz, shadowSampler3, shadowsInfo3.y, shadowsInfo3.z, shadowsInfo3.x);\n#else\n    shadow = computeShadowWithPCF(vPositionFromLight3, shadowSampler3, shadowsInfo3.y, shadowsInfo3.z, shadowsInfo3.x);\n#endif\n#else\n#if defined(POINTLIGHT3)\n    shadow = computeShadowCube(vLightData3.xyz, shadowSampler3, shadowsInfo3.x, shadowsInfo3.z);\n#else\n    shadow = computeShadow(vPositionFromLight3, shadowSampler3, shadowsInfo3.x, shadowsInfo3.z);\n#endif\n#endif	\n#endif	\n#else\n    shadow = 1.;\n#endif\n\n    diffuseBase += info.diffuse * shadow;\n#ifdef OVERLOADEDSHADOWVALUES\n    shadowedOnlyDiffuseBase *= shadow;\n#endif\n\n#ifdef SPECULARTERM\n    specularBase += info.specular * shadow;\n#endif\n#endif\n\n// Reflection\nvec3 reflectionColor = vReflectionColor.rgb;\nvec3 ambientReflectionColor = vReflectionColor.rgb;\n\n#ifdef REFLECTION\n    vec3 vReflectionUVW = computeReflectionCoords(vec4(vPositionW, 1.0), normalW);\n\n    #ifdef REFLECTIONMAP_3D\n        float bias = 0.;\n\n        #ifdef SPECULARTERM\n            // Go mat -> blurry reflexion according to glossiness\n            bias = 20. * (1.0 - glossiness);\n        #endif\n\n        reflectionColor = textureCube(reflectionCubeSampler, vReflectionUVW, bias).rgb * vReflectionInfos.x;\n        reflectionColor = toLinearSpace(reflectionColor.rgb);\n\n        ambientReflectionColor = textureCube(reflectionCubeSampler, normalW, 20.).rgb * vReflectionInfos.x;\n        ambientReflectionColor = toLinearSpace(ambientReflectionColor.rgb);\n    #else\n        vec2 coords = vReflectionUVW.xy;\n\n        #ifdef REFLECTIONMAP_PROJECTION\n            coords /= vReflectionUVW.z;\n        #endif\n\n        coords.y = 1.0 - coords.y;\n\n        reflectionColor = texture2D(reflection2DSampler, coords).rgb * vReflectionInfos.x;\n        reflectionColor = toLinearSpace(reflectionColor.rgb);\n\n        ambientReflectionColor = texture2D(reflection2DSampler, coords, 20.).rgb * vReflectionInfos.x;\n        ambientReflectionColor = toLinearSpace(ambientReflectionColor.rgb);\n    #endif\n#endif\n\n#ifdef OVERLOADEDVALUES\n    ambientReflectionColor = mix(ambientReflectionColor, vOverloadedReflection, vOverloadedGlossiness.z);\n    reflectionColor = mix(reflectionColor, vOverloadedReflection, vOverloadedGlossiness.z);\n#endif\n\nreflectionColor *= vLightingIntensity.z;\nambientReflectionColor *= vLightingIntensity.z;\n\n// Compute reflection specular fresnel\nvec3 specularEnvironmentR0 = specularColor.rgb;\nvec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0);\nvec3 specularEnvironmentReflectanceViewer = FresnelSchlickEnvironmentGGX(clamp(NdotV, 0., 1.), specularEnvironmentR0, specularEnvironmentR90, sqrt(glossiness));\nreflectionColor *= specularEnvironmentReflectanceViewer;\n\n#ifdef OPACITY\n    vec4 opacityMap = texture2D(opacitySampler, vOpacityUV);\n\n    #ifdef OPACITYRGB\n        opacityMap.rgb = opacityMap.rgb * vec3(0.3, 0.59, 0.11);\n        alpha *= (opacityMap.x + opacityMap.y + opacityMap.z)* vOpacityInfos.y;\n    #else\n        alpha *= opacityMap.a * vOpacityInfos.y;\n    #endif\n\n#endif\n\n#ifdef VERTEXALPHA\n    alpha *= vColor.a;\n#endif\n\n#ifdef OPACITYFRESNEL\n    float opacityFresnelTerm = computeFresnelTerm(viewDirectionW, normalW, opacityParts.z, opacityParts.w);\n\n    alpha += opacityParts.x * (1.0 - opacityFresnelTerm) + opacityFresnelTerm * opacityParts.y;\n#endif\n\n    // Emissive\n    vec3 emissiveColor = vEmissiveColor;\n#ifdef EMISSIVE\n    vec3 emissiveColorTex = texture2D(emissiveSampler, vEmissiveUV).rgb;\n    emissiveColor = toLinearSpace(emissiveColorTex.rgb) * emissiveColor * vEmissiveInfos.y;\n#endif\n\n#ifdef OVERLOADEDVALUES\n    emissiveColor = mix(emissiveColor, vOverloadedEmissive, vOverloadedIntensity.w);\n#endif\n\n#ifdef EMISSIVEFRESNEL\n    float emissiveFresnelTerm = computeFresnelTerm(viewDirectionW, normalW, emissiveRightColor.a, emissiveLeftColor.a);\n\n    emissiveColor *= emissiveLeftColor.rgb * (1.0 - emissiveFresnelTerm) + emissiveFresnelTerm * emissiveRightColor.rgb;\n#endif\n\n    // Composition\n#ifdef EMISSIVEASILLUMINATION\n    vec3 finalDiffuse = max(diffuseBase * diffuseColor + vAmbientColor, 0.0) * baseColor.rgb;\n    \n    #ifdef OVERLOADEDSHADOWVALUES\n        shadowedOnlyDiffuseBase = max(shadowedOnlyDiffuseBase * diffuseColor + vAmbientColor, 0.0) * baseColor.rgb;\n    #endif\n#else\n    #ifdef LINKEMISSIVEWITHDIFFUSE\n        vec3 finalDiffuse = max((diffuseBase + emissiveColor) * diffuseColor + vAmbientColor, 0.0) * baseColor.rgb;\n\n        #ifdef OVERLOADEDSHADOWVALUES\n            shadowedOnlyDiffuseBase = max((shadowedOnlyDiffuseBase + emissiveColor) * diffuseColor + vAmbientColor, 0.0) * baseColor.rgb;\n        #endif\n    #else\n        vec3 finalDiffuse = max(diffuseBase * diffuseColor + emissiveColor + vAmbientColor, 0.0) * baseColor.rgb;\n\n        #ifdef OVERLOADEDSHADOWVALUES\n            shadowedOnlyDiffuseBase = max(shadowedOnlyDiffuseBase * diffuseColor + emissiveColor + vAmbientColor, 0.0) * baseColor.rgb;\n        #endif\n    #endif\n#endif\n\n#ifdef OVERLOADEDSHADOWVALUES\n    finalDiffuse = mix(finalDiffuse, shadowedOnlyDiffuseBase, (1.0 - vOverloadedShadowIntensity.y));\n#endif\n\n// diffuse lighting from environment 0.2 replaces Harmonic...\n// Ambient Reflection already includes the environment intensity.\nfinalDiffuse += baseColor.rgb * ambientReflectionColor * 0.2;\n\n#ifdef SPECULARTERM\n    vec3 finalSpecular = specularBase * specularColor;\n#else\n    vec3 finalSpecular = vec3(0.0);\n#endif\n\n#ifdef OVERLOADEDSHADOWVALUES\n    finalSpecular = mix(finalSpecular, vec3(0.0), (1.0 - vOverloadedShadowIntensity.y));\n#endif\n\n#ifdef SPECULAROVERALPHA\n    alpha = clamp(alpha + dot(finalSpecular, vec3(0.3, 0.59, 0.11)), 0., 1.);\n#endif\n\n// Composition\n// Reflection already includes the environment intensity.\n#ifdef EMISSIVEASILLUMINATION\n    vec4 color = vec4(finalDiffuse * baseAmbientColor * vLightingIntensity.x + finalSpecular * vLightingIntensity.x + reflectionColor + emissiveColor * vLightingIntensity.y, alpha);\n#else\n    vec4 color = vec4(finalDiffuse * baseAmbientColor * vLightingIntensity.x + finalSpecular * vLightingIntensity.x + reflectionColor, alpha);\n#endif\n\n#ifdef LIGHTMAP\n    vec3 lightmapColor = texture2D(lightmapSampler, vLightmapUV).rgb * vLightmapInfos.y;\n\n    #ifdef USELIGHTMAPASSHADOWMAP\n        color.rgb *= lightmapColor;\n    #else\n        color.rgb += lightmapColor;\n    #endif\n#endif\n\n#ifdef FOG\n    float fog = CalcFogFactor();\n    color.rgb = fog * color.rgb + (1.0 - fog) * vFogColor;\n#endif\n\n    color = max(color, 0.0);\n\n#ifdef CAMERATONEMAP\n    color.rgb = toneMaps(color.rgb);\n#endif\n\n    color.rgb = toGammaSpace(color.rgb);\n\n#ifdef CAMERACONTRAST\n    color = contrasts(color);\n#endif\n\n    // Normal Display.\n    // gl_FragColor = vec4(normalW * 0.5 + 0.5, 1.0);\n\n    // Ambient reflection color.\n    // gl_FragColor = vec4(ambientReflectionColor, 1.0);\n\n    // Reflection color.\n    // gl_FragColor = vec4(reflectionColor, 1.0);\n\n    // Base color.\n    // gl_FragColor = vec4(baseColor.rgb, 1.0);\n\n    // Specular color.\n    // gl_FragColor = vec4(specularColor.rgb, 1.0);\n\n    // Glossiness color.\n    // gl_FragColor = vec4(glossiness, glossiness, glossiness, 1.0);\n\n    // Specular Map\n    // gl_FragColor = vec4(specularMapColor.rgb, 1.0);\n\n    //// Emissive Color\n    //vec2 test = vEmissiveUV * 0.5 + 0.5;\n    //gl_FragColor = vec4(test.x, test.y, 1.0, 1.0);\n\n    gl_FragColor = color;\n}",
BABYLON.Effect.ShadersStore.legacypbrVertexShader="precision mediump float;\n\n// Attributes\nattribute vec3 position;\nattribute vec3 normal;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n\n#if NUM_BONE_INFLUENCERS > 0\nuniform mat4 mBones[BonesPerMesh];\n\nattribute vec4 matricesIndices;\nattribute vec4 matricesWeights;\n#if NUM_BONE_INFLUENCERS > 4\nattribute vec4 matricesIndicesExtra;\nattribute vec4 matricesWeightsExtra;\n#endif\n#endif\n\n// Uniforms\nuniform mat4 world;\nuniform mat4 view;\nuniform mat4 viewProjection;\n\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform mat4 ambientMatrix;\nuniform vec2 vAmbientInfos;\n#endif\n\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n\n#if defined(SPECULAR) && defined(SPECULARTERM)\nvarying vec2 vSpecularUV;\nuniform vec2 vSpecularInfos;\nuniform mat4 specularMatrix;\n#endif\n\n// Output\nvarying vec3 vPositionW;\nvarying vec3 vNormalW;\n\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n\n#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nvarying float fClipDistance;\n#endif\n\nvoid main(void) {\n    mat4 finalWorld = world;\n\n#if NUM_BONE_INFLUENCERS > 0\n    mat4 influence;\n    influence = mBones[int(matricesIndices[0])] * matricesWeights[0];\n\n#if NUM_BONE_INFLUENCERS > 1\n    influence += mBones[int(matricesIndices[1])] * matricesWeights[1];\n#endif \n#if NUM_BONE_INFLUENCERS > 2\n    influence += mBones[int(matricesIndices[2])] * matricesWeights[2];\n#endif	\n#if NUM_BONE_INFLUENCERS > 3\n    influence += mBones[int(matricesIndices[3])] * matricesWeights[3];\n#endif	\n\n#if NUM_BONE_INFLUENCERS > 4\n    influence += mBones[int(matricesIndicesExtra[0])] * matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS > 5\n    influence += mBones[int(matricesIndicesExtra[1])] * matricesWeightsExtra[1];\n#endif	\n#if NUM_BONE_INFLUENCERS > 6\n    influence += mBones[int(matricesIndicesExtra[2])] * matricesWeightsExtra[2];\n#endif	\n#if NUM_BONE_INFLUENCERS > 7\n    influence += mBones[int(matricesIndicesExtra[3])] * matricesWeightsExtra[3];\n#endif	\n\n    finalWorld = finalWorld * influence;\n#endif\n\n	gl_Position = viewProjection * finalWorld * vec4(position, 1.0);\n\n	vec4 worldPos = finalWorld * vec4(position, 1.0);\n	vPositionW = vec3(worldPos);\n	vNormalW = normalize(vec3(finalWorld * vec4(normal, 0.0)));\n\n	// Texture coordinates\n#ifndef UV1\n	vec2 uv = vec2(0., 0.);\n#endif\n#ifndef UV2\n	vec2 uv2 = vec2(0., 0.);\n#endif\n\n#ifdef DIFFUSE\n	if (vDiffuseInfos.x == 0.)\n	{\n		vDiffuseUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vDiffuseUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef AMBIENT\n	if (vAmbientInfos.x == 0.)\n	{\n		vAmbientUV = vec2(ambientMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vAmbientUV = vec2(ambientMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef OPACITY\n	if (vOpacityInfos.x == 0.)\n	{\n		vOpacityUV = vec2(opacityMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vOpacityUV = vec2(opacityMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef EMISSIVE\n	if (vEmissiveInfos.x == 0.)\n	{\n		vEmissiveUV = vec2(emissiveMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vEmissiveUV = vec2(emissiveMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#if defined(SPECULAR) && defined(SPECULARTERM)\n	if (vSpecularInfos.x == 0.)\n	{\n		vSpecularUV = vec2(specularMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vSpecularUV = vec2(specularMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n	// Clip plane\n#ifdef CLIPPLANE\n	fClipDistance = dot(worldPos, vClipPlane);\n#endif\n\n	// Vertex color\n#ifdef VERTEXCOLOR\n	vColor = color;\n#endif\n}",BABYLON.Effect.ShadersStore.legacypbrPixelShader="precision mediump float;\n\n// Constants\n#define RECIPROCAL_PI2 0.15915494\n#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\n\nuniform vec3 vEyePosition;\nuniform vec3 vAmbientColor;\nuniform vec4 vDiffuseColor;\nuniform vec3 vReflectionColor;\n\n// CUSTOM CONTROLS\nuniform vec4 vLightingIntensity;\nuniform vec4 vCameraInfos;\n\n#ifdef OVERLOADEDVALUES\nuniform vec4 vOverloadedIntensity;\nuniform vec3 vOverloadedAmbient;\nuniform vec3 vOverloadedDiffuse;\nuniform vec3 vOverloadedSpecular;\nuniform vec3 vOverloadedEmissive;\nuniform vec3 vOverloadedReflection;\nuniform vec3 vOverloadedGlossiness;\n#endif\n\n#ifdef OVERLOADEDSHADOWVALUES\nuniform vec4 vOverloadedShadowIntensity;\n#endif\n\n// PBR CUSTOM CONSTANTS\nconst float kPi = 3.1415926535897932384626433832795;\n\n// PBR HELPER METHODS\nfloat Square(float value)\n{\n    return value * value;\n}\n\nfloat getLuminance(vec3 color)\n{\n    return clamp(dot(color, vec3(0.2126, 0.7152, 0.0722)), 0., 1.);\n}\n\nfloat convertRoughnessToAverageSlope(float roughness)\n{\n    // Calculate AlphaG as square of roughness; add epsilon to avoid numerical issues\n    const float kMinimumVariance = 0.0005;\n    float alphaG = Square(roughness) + kMinimumVariance;\n    return alphaG;\n}\n\n// From Microfacet Models for Refraction through Rough Surfaces, Walter et al. 2007\nfloat smithVisibilityG1_TrowbridgeReitzGGX(float dot, float alphaG)\n{\n    float tanSquared = (1.0 - dot * dot) / (dot * dot);\n    return 2.0 / (1.0 + sqrt(1.0 + alphaG * alphaG * tanSquared));\n}\n\nfloat smithVisibilityG_TrowbridgeReitzGGX_Walter(float NdotL, float NdotV, float alphaG)\n{\n    return smithVisibilityG1_TrowbridgeReitzGGX(NdotL, alphaG) * smithVisibilityG1_TrowbridgeReitzGGX(NdotV, alphaG);\n}\n\n// Trowbridge-Reitz (GGX)\n// Generalised Trowbridge-Reitz with gamma power=2.0\nfloat normalDistributionFunction_TrowbridgeReitzGGX(float NdotH, float alphaG)\n{\n    // Note: alphaG is average slope (gradient) of the normals in slope-space.\n    // It is also the (trigonometric) tangent of the median distribution value, i.e. 50% of normals have\n    // a tangent (gradient) closer to the macrosurface than this slope.\n    float a2 = Square(alphaG);\n    float d = NdotH * NdotH * (a2 - 1.0) + 1.0;\n    return a2 / (kPi * d * d);\n}\n\nvec3 fresnelSchlickGGX(float VdotH, vec3 reflectance0, vec3 reflectance90)\n{\n    return reflectance0 + (reflectance90 - reflectance0) * pow(clamp(1.0 - VdotH, 0., 1.), 5.0);\n}\n\nvec3 FresnelSchlickEnvironmentGGX(float VdotN, vec3 reflectance0, vec3 reflectance90, float smoothness)\n{\n    // Schlick fresnel approximation, extended with basic smoothness term so that rough surfaces do not approach reflectance90 at grazing angle\n    float weight = mix(FRESNEL_MAXIMUM_ON_ROUGH, 1.0, smoothness);\n    return reflectance0 + weight * (reflectance90 - reflectance0) * pow(clamp(1.0 - VdotN, 0., 1.), 5.0);\n}\n\n// Cook Torance Specular computation.\nvec3 computeSpecularTerm(float NdotH, float NdotL, float NdotV, float VdotH, float roughness, vec3 specularColor)\n{\n    float alphaG = convertRoughnessToAverageSlope(roughness);\n    float distribution = normalDistributionFunction_TrowbridgeReitzGGX(NdotH, alphaG);\n    float visibility = smithVisibilityG_TrowbridgeReitzGGX_Walter(NdotL, NdotV, alphaG);\n    visibility /= (4.0 * NdotL * NdotV); // Cook Torance Denominator  integated in viibility to avoid issues when visibility function changes.\n\n    vec3 fresnel = fresnelSchlickGGX(VdotH, specularColor, vec3(1., 1., 1.));\n\n    float specTerm = max(0., visibility * distribution) * NdotL;\n    return fresnel * specTerm;\n}\n\nfloat computeDiffuseTerm(float NdotL, float NdotV, float VdotH, float roughness)\n{\n    // Diffuse fresnel falloff as per Disney principled BRDF, and in the spirit of\n    // of general coupled diffuse/specular models e.g. Ashikhmin Shirley.\n    float diffuseFresnelNV = pow(clamp(1.0 - NdotL, 0.000001, 1.), 5.0);\n    float diffuseFresnelNL = pow(clamp(1.0 - NdotV, 0.000001, 1.), 5.0);\n    float diffuseFresnel90 = 0.5 + 2.0 * VdotH * VdotH * roughness;\n    float diffuseFresnelTerm =\n        (1.0 + (diffuseFresnel90 - 1.0) * diffuseFresnelNL) *\n        (1.0 + (diffuseFresnel90 - 1.0) * diffuseFresnelNV);\n\n    return diffuseFresnelTerm * NdotL;\n}\n\nfloat computeDefaultGlossiness(float glossiness, vec3 specularColor)\n{\n    if (glossiness == 0.)\n    {\n        float kSpecularNoAlphaWorkflow_SmoothnessMax = 0.95;\n\n        float specularLuminance = getLuminance(specularColor);\n        float specularLuma = sqrt(specularLuminance);\n        glossiness = specularLuma * kSpecularNoAlphaWorkflow_SmoothnessMax;\n    }\n    return glossiness;\n}\n\nvec3 toLinearSpace(vec3 color)\n{\n    return vec3(pow(color.r, 2.2), pow(color.g, 2.2), pow(color.b, 2.2));\n}\n\nvec3 toGammaSpace(vec3 color)\n{\n    return vec3(pow(color.r, 1.0 / 2.2), pow(color.g, 1.0 / 2.2), pow(color.b, 1.0 / 2.2));\n}\n\n#ifdef CAMERATONEMAP\n    vec3 toneMaps(vec3 color)\n    {\n        color = max(color, 0.0);\n\n        // TONE MAPPING / EXPOSURE\n        color.rgb = color.rgb * vCameraInfos.x;\n\n        float tuning = 1.5; // TODO: sync up so e.g. 18% greys are matched to exposure appropriately\n        vec3 tonemapped = 1.0 - exp2(-color.rgb * tuning); // simple local photographic tonemapper\n        color.rgb = mix(color.rgb, tonemapped, 1.0);\n        return color;\n    }\n#endif\n\n#ifdef CAMERACONTRAST\n    vec4 contrasts(vec4 color)\n    {\n        color = clamp(color, 0.0, 1.0);\n\n        vec3 resultHighContrast = color.rgb * color.rgb * (3.0 - 2.0 * color.rgb);\n        float contrast = vCameraInfos.y;\n        if (contrast < 1.0)\n        {\n            // Decrease contrast: interpolate towards zero-contrast image (flat grey)\n            color.rgb = mix(vec3(0.5, 0.5, 0.5), color.rgb, contrast);\n        }\n        else\n        {\n            // Increase contrast: apply simple shoulder-toe high contrast curve\n            color.rgb = mix(color.rgb, resultHighContrast, contrast - 1.0);\n        }\n\n        return color;\n    }\n#endif\n// END PBR HELPER METHODS\n\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nuniform vec3 vEmissiveColor;\n\n// Input\nvarying vec3 vPositionW;\n\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n\n// Lights\n#ifdef LIGHT0\nuniform vec4 vLightData0;\nuniform vec4 vLightDiffuse0;\n#ifdef SPECULARTERM\nuniform vec3 vLightSpecular0;\n#endif\n#ifdef SHADOW0\n#if defined(SPOTLIGHT0) || defined(DIRLIGHT0)\nvarying vec4 vPositionFromLight0;\nuniform sampler2D shadowSampler0;\n#else\nuniform samplerCube shadowSampler0;\n#endif\nuniform vec3 shadowsInfo0;\n#endif\n#ifdef SPOTLIGHT0\nuniform vec4 vLightDirection0;\n#endif\n#ifdef HEMILIGHT0\nuniform vec3 vLightGround0;\n#endif\n#endif\n\n#ifdef LIGHT1\nuniform vec4 vLightData1;\nuniform vec4 vLightDiffuse1;\n#ifdef SPECULARTERM\nuniform vec3 vLightSpecular1;\n#endif\n#ifdef SHADOW1\n#if defined(SPOTLIGHT1) || defined(DIRLIGHT1)\nvarying vec4 vPositionFromLight1;\nuniform sampler2D shadowSampler1;\n#else\nuniform samplerCube shadowSampler1;\n#endif\nuniform vec3 shadowsInfo1;\n#endif\n#ifdef SPOTLIGHT1\nuniform vec4 vLightDirection1;\n#endif\n#ifdef HEMILIGHT1\nuniform vec3 vLightGround1;\n#endif\n#endif\n\n#ifdef LIGHT2\nuniform vec4 vLightData2;\nuniform vec4 vLightDiffuse2;\n#ifdef SPECULARTERM\nuniform vec3 vLightSpecular2;\n#endif\n#ifdef SHADOW2\n#if defined(SPOTLIGHT2) || defined(DIRLIGHT2)\nvarying vec4 vPositionFromLight2;\nuniform sampler2D shadowSampler2;\n#else\nuniform samplerCube shadowSampler2;\n#endif\nuniform vec3 shadowsInfo2;\n#endif\n#ifdef SPOTLIGHT2\nuniform vec4 vLightDirection2;\n#endif\n#ifdef HEMILIGHT2\nuniform vec3 vLightGround2;\n#endif\n#endif\n\n#ifdef LIGHT3\nuniform vec4 vLightData3;\nuniform vec4 vLightDiffuse3;\n#ifdef SPECULARTERM\nuniform vec3 vLightSpecular3;\n#endif\n#ifdef SHADOW3\n#if defined(SPOTLIGHT3) || defined(DIRLIGHT3)\nvarying vec4 vPositionFromLight3;\nuniform sampler2D shadowSampler3;\n#else\nuniform samplerCube shadowSampler3;\n#endif\nuniform vec3 shadowsInfo3;\n#endif\n#ifdef SPOTLIGHT3\nuniform vec4 vLightDirection3;\n#endif\n#ifdef HEMILIGHT3\nuniform vec3 vLightGround3;\n#endif\n#endif\n\n// Samplers\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform sampler2D diffuseSampler;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform sampler2D ambientSampler;\nuniform vec2 vAmbientInfos;\n#endif\n\n#ifdef OPACITY	\nvarying vec2 vOpacityUV;\nuniform sampler2D opacitySampler;\nuniform vec2 vOpacityInfos;\n#endif\n\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform sampler2D emissiveSampler;\n#endif\n\n#ifdef LIGHTMAP\nvarying vec2 vLightmapUV;\nuniform vec2 vLightmapInfos;\nuniform sampler2D lightmapSampler;\n#endif\n\n#if defined(SPECULAR) && defined(SPECULARTERM)\nvarying vec2 vSpecularUV;\nuniform vec2 vSpecularInfos;\nuniform sampler2D specularSampler;\n#endif\n\n#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n\n// Light Computing\nstruct lightingInfo\n{\n    vec3 diffuse;\n#ifdef SPECULARTERM\n    vec3 specular;\n#endif\n};\n\nlightingInfo computeLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, float range, float roughness, float NdotV) {\n    lightingInfo result;\n\n    vec3 lightVectorW;\n    float attenuation = 1.0;\n    if (lightData.w == 0.)\n    {\n        vec3 direction = lightData.xyz - vPositionW;\n\n        attenuation = max(0., 1.0 - length(direction) / range);\n        lightVectorW = normalize(direction);\n    }\n    else\n    {\n        lightVectorW = normalize(-lightData.xyz);\n    }\n\n    // diffuse\n    vec3 H = normalize(viewDirectionW + lightVectorW);\n    float NdotL = max(0.00000000001, dot(vNormal, lightVectorW));\n    float VdotH = clamp(0.00000000001, 1.0, dot(viewDirectionW, H));\n\n    float diffuseTerm = computeDiffuseTerm(NdotL, NdotV, VdotH, roughness);\n    result.diffuse = diffuseTerm * diffuseColor * attenuation;\n\n#ifdef SPECULARTERM\n    // Specular\n    float NdotH = max(0.00000000001, dot(vNormal, H));\n\n    vec3 specTerm = computeSpecularTerm(NdotH, NdotL, NdotV, VdotH, roughness, specularColor);\n    result.specular = specTerm * specularColor * attenuation;\n#endif\n\n    return result;\n}\n\nlightingInfo computeSpotLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 lightDirection, vec3 diffuseColor, vec3 specularColor, float range, float roughness, float NdotV) {\n    lightingInfo result;\n\n    vec3 direction = lightData.xyz - vPositionW;\n    vec3 lightVectorW = normalize(direction);\n    float attenuation = max(0., 1.0 - length(direction) / range);\n\n    // diffuse\n    float cosAngle = max(0.0000001, dot(-lightDirection.xyz, lightVectorW));\n    float spotAtten = 0.0;\n\n    if (cosAngle >= lightDirection.w)\n    {\n        cosAngle = max(0., pow(cosAngle, lightData.w));\n        spotAtten = clamp((cosAngle - lightDirection.w) / (1. - cosAngle), 0.0, 1.0);\n\n        // Diffuse\n        vec3 H = normalize(viewDirectionW - lightDirection.xyz);\n        float NdotL = max(0.00000000001, dot(vNormal, -lightDirection.xyz));\n        float VdotH = clamp(dot(viewDirectionW, H), 0.00000000001, 1.0);\n\n        float diffuseTerm = computeDiffuseTerm(NdotL, NdotV, VdotH, roughness);\n        result.diffuse = diffuseTerm * diffuseColor * attenuation * spotAtten;\n\n#ifdef SPECULARTERM\n        // Specular\n        float NdotH = max(0.00000000001, dot(vNormal, H));\n\n        vec3 specTerm = computeSpecularTerm(NdotH, NdotL, NdotV, VdotH, roughness, specularColor);\n        result.specular = specTerm * specularColor * attenuation * spotAtten;\n#endif\n\n        return result;\n    }\n\n    result.diffuse = vec3(0.);\n#ifdef SPECULARTERM\n    result.specular = vec3(0.);\n#endif\n\n    return result;\n}\n\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, vec3 groundColor, float roughness, float NdotV) {\n    lightingInfo result;\n\n    vec3 lightVectorW = normalize(lightData.xyz);\n\n    // Diffuse\n    float ndl = dot(vNormal, lightData.xyz) * 0.5 + 0.5;\n    result.diffuse = mix(groundColor, diffuseColor, ndl);\n\n#ifdef SPECULARTERM\n    // Specular\n    vec3 H = normalize(viewDirectionW + lightVectorW);\n    float NdotH = max(0.00000000001, dot(vNormal, H));\n    float NdotL = max(0.00000000001, ndl);\n    float VdotH = clamp(0.00000000001, 1.0, dot(viewDirectionW, H));\n\n    vec3 specTerm = computeSpecularTerm(NdotH, NdotL, NdotV, VdotH, roughness, specularColor);\n    result.specular = specTerm * specularColor;\n#endif\n\n    return result;\n}\n\nvoid main(void) {\n    // Clip plane\n#ifdef CLIPPLANE\n    if (fClipDistance > 0.0)\n        discard;\n#endif\n\n    vec3 viewDirectionW = normalize(vEyePosition - vPositionW);\n\n    // Base color\n    vec4 baseColor = vec4(1., 1., 1., 1.);\n    vec3 diffuseColor = vDiffuseColor.rgb;\n    \n    // Alpha\n    float alpha = vDiffuseColor.a;\n\n#ifdef DIFFUSE\n    baseColor = texture2D(diffuseSampler, vDiffuseUV);\n    baseColor = vec4(toLinearSpace(baseColor.rgb), baseColor.a);\n\n#ifdef ALPHATEST\n    if (baseColor.a < 0.4)\n        discard;\n#endif\n\n#ifdef ALPHAFROMDIFFUSE\n    alpha *= baseColor.a;\n#endif\n\n    baseColor.rgb *= vDiffuseInfos.y;\n#endif\n\n#ifdef VERTEXCOLOR\n    baseColor.rgb *= vColor.rgb;\n#endif\n\n#ifdef OVERLOADEDVALUES\n    baseColor.rgb = mix(baseColor.rgb, vOverloadedDiffuse, vOverloadedIntensity.y);\n    diffuseColor.rgb = mix(diffuseColor.rgb, vOverloadedDiffuse, vOverloadedIntensity.y);\n#endif\n\n    // Bump\n#ifdef NORMAL\n    vec3 normalW = normalize(vNormalW);\n#else\n    vec3 normalW = vec3(1.0, 1.0, 1.0);\n#endif\n\n    // Ambient color\n    vec3 baseAmbientColor = vec3(1., 1., 1.);\n\n#ifdef AMBIENT\n    baseAmbientColor = texture2D(ambientSampler, vAmbientUV).rgb * vAmbientInfos.y;\n    #ifdef OVERLOADEDVALUES\n        baseAmbientColor.rgb = mix(baseAmbientColor.rgb, vOverloadedAmbient, vOverloadedIntensity.x);\n    #endif\n#endif\n\n    // Specular map\n#ifdef SPECULARTERM\n    float glossiness = vSpecularColor.a;\n    vec3 specularColor = vSpecularColor.rgb;\n\n    #ifdef OVERLOADEDVALUES\n        specularColor.rgb = mix(specularColor.rgb, vOverloadedSpecular, vOverloadedIntensity.z);\n    #endif\n\n    #ifdef SPECULAR\n            vec4 specularMapColor = texture2D(specularSampler, vSpecularUV);\n            specularColor = toLinearSpace(specularMapColor.rgb);\n\n        #ifdef OVERLOADEDVALUES\n                specularColor.rgb = mix(specularColor.rgb, vOverloadedSpecular, vOverloadedIntensity.z);\n        #endif\n\n        #ifdef GLOSSINESSFROMSPECULARMAP\n            glossiness = specularMapColor.a;\n        #else\n            glossiness = computeDefaultGlossiness(glossiness, specularColor);\n        #endif\n    #endif\n\n    #ifdef OVERLOADEDVALUES\n        glossiness = mix(glossiness, vOverloadedGlossiness.x, vOverloadedGlossiness.y);\n    #endif\n#else\n    float glossiness = 0.;\n    #ifdef OVERLOADEDVALUES\n        glossiness = mix(glossiness, vOverloadedGlossiness.x, vOverloadedGlossiness.y);\n    #endif\n\n    vec3 specularColor = vec3(0., 0., 0);\n    #ifdef OVERLOADEDVALUES\n            specularColor.rgb = mix(specularColor.rgb, vOverloadedSpecular, vOverloadedIntensity.z);\n    #endif\n#endif\n\n    // Apply Energy Conservation taking in account the environment level only if the environment is present.\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n    baseColor.rgb = (1. - reflectance) * baseColor.rgb;\n\n    // Compute Specular Fresnel + Reflectance.\n    float NdotV = max(0.00000000001, dot(normalW, viewDirectionW));\n\n    // Adapt glossiness.\n    glossiness = clamp(glossiness, 0., 1.) * 0.98;\n\n    // Call rough to not conflict with previous one.\n    float rough = clamp(1. - glossiness, 0.000001, 1.0);\n\n    // Lighting\n    vec3 diffuseBase = vec3(0., 0., 0.);\n\n#ifdef OVERLOADEDSHADOWVALUES\n    vec3 shadowedOnlyDiffuseBase = vec3(1., 1., 1.);\n#endif\n\n#ifdef SPECULARTERM\n    vec3 specularBase = vec3(0., 0., 0.);\n#endif\n    float shadow = 1.;\n\n#ifdef LIGHT0\n#ifndef SPECULARTERM\n    vec3 vLightSpecular0 = vec3(0.0);\n#endif\n#ifdef SPOTLIGHT0\n    lightingInfo info = computeSpotLighting(viewDirectionW, normalW, vLightData0, vLightDirection0, vLightDiffuse0.rgb, vLightSpecular0, vLightDiffuse0.a, rough, NdotV);\n#endif\n#ifdef HEMILIGHT0\n    lightingInfo info = computeHemisphericLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0.rgb, vLightSpecular0, vLightGround0, rough, NdotV);\n#endif\n#if defined(POINTLIGHT0) || defined(DIRLIGHT0)\n    lightingInfo info = computeLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0.rgb, vLightSpecular0, vLightDiffuse0.a, rough, NdotV);\n#endif\n\n    shadow = 1.;\n    diffuseBase += info.diffuse * shadow;\n#ifdef OVERLOADEDSHADOWVALUES\n    shadowedOnlyDiffuseBase *= shadow;\n#endif\n\n#ifdef SPECULARTERM\n    specularBase += info.specular * shadow;\n#endif\n#endif\n\n#ifdef LIGHT1\n#ifndef SPECULARTERM\n    vec3 vLightSpecular1 = vec3(0.0);\n#endif\n#ifdef SPOTLIGHT1\n    info = computeSpotLighting(viewDirectionW, normalW, vLightData1, vLightDirection1, vLightDiffuse1.rgb, vLightSpecular1, vLightDiffuse1.a, rough, NdotV);\n#endif\n#ifdef HEMILIGHT1\n    info = computeHemisphericLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1.rgb, vLightSpecular1, vLightGround1, rough, NdotV);\n#endif\n#if defined(POINTLIGHT1) || defined(DIRLIGHT1)\n    info = computeLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1.rgb, vLightSpecular1, vLightDiffuse1.a, rough, NdotV);\n#endif\n\n    shadow = 1.;\n    diffuseBase += info.diffuse * shadow;\n#ifdef OVERLOADEDSHADOWVALUES\n    shadowedOnlyDiffuseBase *= shadow;\n#endif\n\n#ifdef SPECULARTERM\n    specularBase += info.specular * shadow;\n#endif\n#endif\n\n#ifdef LIGHT2\n#ifndef SPECULARTERM\n    vec3 vLightSpecular2 = vec3(0.0);\n#endif\n#ifdef SPOTLIGHT2\n    info = computeSpotLighting(viewDirectionW, normalW, vLightData2, vLightDirection2, vLightDiffuse2.rgb, vLightSpecular2, vLightDiffuse2.a, rough, NdotV);\n#endif\n#ifdef HEMILIGHT2\n    info = computeHemisphericLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2.rgb, vLightSpecular2, vLightGround2, rough, NdotV);\n#endif\n#if defined(POINTLIGHT2) || defined(DIRLIGHT2)\n    info = computeLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2.rgb, vLightSpecular2, vLightDiffuse2.a, rough, NdotV);\n#endif\n\n    shadow = 1.;\n    diffuseBase += info.diffuse * shadow;\n#ifdef OVERLOADEDSHADOWVALUES\n    shadowedOnlyDiffuseBase *= shadow;\n#endif\n\n#ifdef SPECULARTERM\n    specularBase += info.specular * shadow;\n#endif\n#endif\n\n#ifdef LIGHT3\n#ifndef SPECULARTERM\n    vec3 vLightSpecular3 = vec3(0.0);\n#endif\n#ifdef SPOTLIGHT3\n    info = computeSpotLighting(viewDirectionW, normalW, vLightData3, vLightDirection3, vLightDiffuse3.rgb, vLightSpecular3, vLightDiffuse3.a, rough, NdotV);\n#endif\n#ifdef HEMILIGHT3\n    info = computeHemisphericLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3.rgb, vLightSpecular3, vLightGround3, rough, NdotV);\n#endif\n#if defined(POINTLIGHT3) || defined(DIRLIGHT3)\n    info = computeLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3.rgb, vLightSpecular3, vLightDiffuse3.a, rough, NdotV);\n#endif\n\n    shadow = 1.;\n    diffuseBase += info.diffuse * shadow;\n#ifdef OVERLOADEDSHADOWVALUES\n    shadowedOnlyDiffuseBase *= shadow;\n#endif\n\n#ifdef SPECULARTERM\n    specularBase += info.specular * shadow;\n#endif\n#endif\n\n// Reflection\nvec3 reflectionColor = vReflectionColor.rgb;\nvec3 ambientReflectionColor = vReflectionColor.rgb;\n\nreflectionColor *= vLightingIntensity.z;\nambientReflectionColor *= vLightingIntensity.z;\n\n// Compute reflection specular fresnel\nvec3 specularEnvironmentR0 = specularColor.rgb;\nvec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0);\nvec3 specularEnvironmentReflectanceViewer = FresnelSchlickEnvironmentGGX(clamp(NdotV, 0., 1.), specularEnvironmentR0, specularEnvironmentR90, sqrt(glossiness));\nreflectionColor *= specularEnvironmentReflectanceViewer;\n\n#ifdef OVERLOADEDVALUES\n    ambientReflectionColor = mix(ambientReflectionColor, vOverloadedReflection, vOverloadedGlossiness.z);\n    reflectionColor = mix(reflectionColor, vOverloadedReflection, vOverloadedGlossiness.z);\n#endif\n\n#ifdef OPACITY\n    vec4 opacityMap = texture2D(opacitySampler, vOpacityUV);\n\n#ifdef OPACITYRGB\n    opacityMap.rgb = opacityMap.rgb * vec3(0.3, 0.59, 0.11);\n    alpha *= (opacityMap.x + opacityMap.y + opacityMap.z)* vOpacityInfos.y;\n#else\n    alpha *= opacityMap.a * vOpacityInfos.y;\n#endif\n\n#endif\n\n#ifdef VERTEXALPHA\n    alpha *= vColor.a;\n#endif\n\n    // Emissive\n    vec3 emissiveColor = vEmissiveColor;\n#ifdef EMISSIVE\n    vec3 emissiveColorTex = texture2D(emissiveSampler, vEmissiveUV).rgb;\n    emissiveColor = toLinearSpace(emissiveColorTex.rgb) * emissiveColor * vEmissiveInfos.y;\n#endif\n\n#ifdef OVERLOADEDVALUES\n    emissiveColor = mix(emissiveColor, vOverloadedEmissive, vOverloadedIntensity.w);\n#endif\n\n    // Composition\n#ifdef EMISSIVEASILLUMINATION\n    vec3 finalDiffuse = max(diffuseBase * diffuseColor + vAmbientColor, 0.0) * baseColor.rgb;\n\n    #ifdef OVERLOADEDSHADOWVALUES\n        shadowedOnlyDiffuseBase = max(shadowedOnlyDiffuseBase * diffuseColor + vAmbientColor, 0.0) * baseColor.rgb;\n    #endif\n#else\n    #ifdef LINKEMISSIVEWITHDIFFUSE\n        vec3 finalDiffuse = max((diffuseBase + emissiveColor) * diffuseColor + vAmbientColor, 0.0) * baseColor.rgb;\n        #ifdef OVERLOADEDSHADOWVALUES\n                shadowedOnlyDiffuseBase = max((shadowedOnlyDiffuseBase + emissiveColor) * diffuseColor + vAmbientColor, 0.0) * baseColor.rgb;\n        #endif\n    #else\n        vec3 finalDiffuse = max(diffuseBase * diffuseColor + emissiveColor + vAmbientColor, 0.0) * baseColor.rgb;\n        #ifdef OVERLOADEDSHADOWVALUES\n            shadowedOnlyDiffuseBase = max(shadowedOnlyDiffuseBase * diffuseColor + emissiveColor + vAmbientColor, 0.0) * baseColor.rgb;\n        #endif\n    #endif\n#endif\n\n#ifdef OVERLOADEDSHADOWVALUES\n      finalDiffuse = mix(finalDiffuse, shadowedOnlyDiffuseBase, (1.0 - vOverloadedShadowIntensity.y));\n#endif\n\n// diffuse lighting from environment 0.2 replaces Harmonic...\n// Ambient Reflection already includes the environment intensity.\nfinalDiffuse += baseColor.rgb * ambientReflectionColor * 0.2;\n\n#ifdef SPECULARTERM\n    vec3 finalSpecular = specularBase * specularColor;\n#else\n    vec3 finalSpecular = vec3(0.0);\n#endif\n\n#ifdef SPECULAROVERALPHA\n    alpha = clamp(alpha + dot(finalSpecular, vec3(0.3, 0.59, 0.11)), 0., 1.);\n#endif\n\n// Composition\n// Reflection already includes the environment intensity.\n#ifdef EMISSIVEASILLUMINATION\n    vec4 color = vec4(finalDiffuse * baseAmbientColor * vLightingIntensity.x + finalSpecular * vLightingIntensity.x + reflectionColor + emissiveColor * vLightingIntensity.y, alpha);\n#else\n    vec4 color = vec4(finalDiffuse * baseAmbientColor * vLightingIntensity.x + finalSpecular * vLightingIntensity.x + reflectionColor, alpha);\n#endif\n\n    color = max(color, 0.0);\n\n#ifdef CAMERATONEMAP\n    color.rgb = toneMaps(color.rgb);\n#endif\n\n    color.rgb = toGammaSpace(color.rgb);\n\n#ifdef CAMERACONTRAST\n    color = contrasts(color);\n#endif\n\n    gl_FragColor = color;\n}";