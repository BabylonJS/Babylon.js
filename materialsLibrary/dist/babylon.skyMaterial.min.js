var BABYLON;!function(n){var e=function(n){function e(){n.call(this),this.CLIPPLANE=!1,this.POINTSIZE=!1,this.FOG=!1,this.VERTEXCOLOR=!1,this.VERTEXALPHA=!1,this._keys=Object.keys(this)}return __extends(e,n),e}(n.MaterialDefines),i=function(i){function t(t,r){i.call(this,t,r),this.luminance=1,this.turbidity=10,this.rayleigh=2,this.mieCoefficient=.005,this.mieDirectionalG=.8,this.distance=500,this.inclination=.49,this.azimuth=.25,this._sunPosition=n.Vector3.Zero(),this._defines=new e,this._cachedDefines=new e}return __extends(t,i),t.prototype.needAlphaBlending=function(){return this.alpha<1},t.prototype.needAlphaTesting=function(){return!1},t.prototype.getAlphaTestTexture=function(){return null},t.prototype._checkCache=function(n,e,i){return e?e._materialDefines&&e._materialDefines.isEqual(this._defines)?!0:!1:!0},t.prototype.isReady=function(i,t){if(this.checkReadyOnlyOnce&&this._wasPreviouslyReady)return!0;var r=this.getScene();if(!this.checkReadyOnEveryCall&&this._renderId===r.getRenderId()&&this._checkCache(r,i,t))return!0;r.getEngine();if(this._defines.reset(),r.clipPlane&&(this._defines.CLIPPLANE=!0),(this.pointsCloud||r.forcePointsCloud)&&(this._defines.POINTSIZE=!0),r.fogEnabled&&i&&i.applyFog&&r.fogMode!==n.Scene.FOGMODE_NONE&&this.fogEnabled&&(this._defines.FOG=!0),i&&i.useVertexColors&&i.isVerticesDataPresent(n.VertexBuffer.ColorKind)&&(this._defines.VERTEXCOLOR=!0,i.hasVertexAlpha&&(this._defines.VERTEXALPHA=!0)),!this._defines.isEqual(this._cachedDefines)||!this._effect){this._defines.cloneTo(this._cachedDefines),r.resetCachedMaterial();var o=new n.EffectFallbacks;this._defines.FOG&&o.addFallback(1,"FOG");var a=[n.VertexBuffer.PositionKind];this._defines.VERTEXCOLOR&&a.push(n.VertexBuffer.ColorKind);var s="sky",f=this._defines.toString();this._effect=r.getEngine().createEffect(s,a,["world","viewProjection","vFogInfos","vFogColor","pointSize","vClipPlane","luminance","turbidity","rayleigh","mieCoefficient","mieDirectionalG","sunPosition"],[],f,o,this.onCompiled,this.onError)}return this._effect.isReady()?(this._renderId=r.getRenderId(),this._wasPreviouslyReady=!0,i&&(i._materialDefines||(i._materialDefines=new e),this._defines.cloneTo(i._materialDefines)),!0):!1},t.prototype.bindOnlyWorldMatrix=function(n){this._effect.setMatrix("world",n)},t.prototype.bind=function(e,t){var r=this.getScene();if(this.bindOnlyWorldMatrix(e),this._effect.setMatrix("viewProjection",r.getTransformMatrix()),r.getCachedMaterial()!==this){if(r.clipPlane){var o=r.clipPlane;this._effect.setFloat4("vClipPlane",o.normal.x,o.normal.y,o.normal.z,o.d)}this.pointsCloud&&this._effect.setFloat("pointSize",this.pointSize)}r.fogEnabled&&t.applyFog&&r.fogMode!==n.Scene.FOGMODE_NONE&&this._effect.setMatrix("view",r.getViewMatrix()),r.fogEnabled&&t.applyFog&&r.fogMode!==n.Scene.FOGMODE_NONE&&(this._effect.setFloat4("vFogInfos",r.fogMode,r.fogStart,r.fogEnd,r.fogDensity),this._effect.setColor3("vFogColor",r.fogColor)),this._effect.setFloat("luminance",this.luminance),this._effect.setFloat("turbidity",this.turbidity),this._effect.setFloat("rayleigh",this.rayleigh),this._effect.setFloat("mieCoefficient",this.mieCoefficient),this._effect.setFloat("mieDirectionalG",this.mieDirectionalG);var a=Math.PI*(this.inclination-.5),s=2*Math.PI*(this.azimuth-.5);this._sunPosition.x=this.distance*Math.cos(s),this._sunPosition.y=this.distance*Math.sin(s)*Math.sin(a),this._sunPosition.z=this.distance*Math.sin(s)*Math.cos(a),this._effect.setVector3("sunPosition",this._sunPosition),i.prototype.bind.call(this,e,t)},t.prototype.getAnimatables=function(){return[]},t.prototype.dispose=function(n){i.prototype.dispose.call(this,n)},t.prototype.clone=function(n){var e=new t(n,this.getScene());return this.copyTo(e),e.luminance=this.luminance,e.turbidity=this.turbidity,e.rayleigh=this.rayleigh,e.mieCoefficient=this.mieCoefficient,e.mieDirectionalG=this.mieDirectionalG,e.distance=this.distance,e.inclination=this.inclination,e.azimuth=this.azimuth,e},t.prototype.serialize=function(){var n=i.prototype.serialize.call(this);return n.customType="BABYLON.SkyMaterial",n.luminance=this.luminance,n.turbidity=this.turbidity,n.rayleigh=this.rayleigh,n.mieCoefficient=this.mieCoefficient,n.mieDirectionalG=this.mieDirectionalG,n.distance=this.distance,n.inclination=this.inclination,n.azimuth=this.azimuth,n},t.Parse=function(e,i,r){var o=new t(e.name,i);return o.alpha=e.alpha,o.id=e.id,n.Tags.AddTagsTo(o,e.tags),o.backFaceCulling=e.backFaceCulling,o.wireframe=e.wireframe,e.checkReadyOnlyOnce&&(o.checkReadyOnlyOnce=e.checkReadyOnlyOnce),o.luminance=e.luminance,o.turbidity=e.turbidity,o.rayleigh=e.rayleigh,o.mieCoefficient=e.mieCoefficient,o.mieDirectionalG=e.mieDirectionalG,o.distance=e.distance,o.inclination=e.inclination,o.azimuth=e.azimuth,o},t}(n.Material);n.SkyMaterial=i}(BABYLON||(BABYLON={})),BABYLON.Effect.ShadersStore.skyVertexShader="precision highp float;\r\n\r\n// Attributes\r\nattribute vec3 position;\r\n\r\n#ifdef VERTEXCOLOR\r\nattribute vec4 color;\r\n#endif\r\n\r\n// Uniforms\r\nuniform mat4 world;\r\nuniform mat4 viewProjection;\r\n\r\n#ifdef POINTSIZE\r\nuniform float pointSize;\r\n#endif\r\n\r\n// Output\r\nvarying vec3 vPositionW;\r\n\r\n#ifdef VERTEXCOLOR\r\nvarying vec4 vColor;\r\n#endif\r\n\r\n#ifdef CLIPPLANE\r\nuniform vec4 vClipPlane;\r\nvarying float fClipDistance;\r\n#endif\r\n\r\n#ifdef FOG\r\nvarying float fFogDistance;\r\n#endif\r\n\r\nvoid main(void) {\r\n	gl_Position = viewProjection * world * vec4(position, 1.0);\r\n	\r\n	vec4 worldPos = world * vec4(position, 1.0);\r\n	vPositionW = vec3(worldPos);\r\n\r\n	// Clip plane\r\n#ifdef CLIPPLANE\r\n	fClipDistance = dot(worldPos, vClipPlane);\r\n#endif\r\n\r\n	// Fog\r\n#ifdef FOG\r\n	fFogDistance = (view * worldPos).z;\r\n#endif\r\n\r\n	// Vertex color\r\n#ifdef VERTEXCOLOR\r\n	vColor = color;\r\n#endif\r\n\r\n	// Point size\r\n#ifdef POINTSIZE\r\n	gl_PointSize = pointSize;\r\n#endif\r\n}\r\n",BABYLON.Effect.ShadersStore.skyPixelShader="precision highp float;\r\n\r\n// Input\r\nvarying vec3 vPositionW;\r\n\r\n#ifdef VERTEXCOLOR\r\nvarying vec4 vColor;\r\n#endif\r\n\r\n#ifdef CLIPPLANE\r\nvarying float fClipDistance;\r\n#endif\r\n\r\n// Sky\r\nuniform float luminance;\r\nuniform float turbidity;\r\nuniform float rayleigh;\r\nuniform float mieCoefficient;\r\nuniform float mieDirectionalG;\r\nuniform vec3 sunPosition;\r\n\r\n// Fog\r\n#ifdef FOG\r\n#define FOGMODE_NONE    0.\r\n#define FOGMODE_EXP     1.\r\n#define FOGMODE_EXP2    2.\r\n#define FOGMODE_LINEAR  3.\r\n#define E 2.71828\r\n\r\nuniform vec4 vFogInfos;\r\nuniform vec3 vFogColor;\r\nvarying float fFogDistance;\r\n\r\nfloat CalcFogFactor()\r\n{\r\n	float fogCoeff = 1.0;\r\n	float fogStart = vFogInfos.y;\r\n	float fogEnd = vFogInfos.z;\r\n	float fogDensity = vFogInfos.w;\r\n\r\n	if (FOGMODE_LINEAR == vFogInfos.x)\r\n	{\r\n		fogCoeff = (fogEnd - fFogDistance) / (fogEnd - fogStart);\r\n	}\r\n	else if (FOGMODE_EXP == vFogInfos.x)\r\n	{\r\n		fogCoeff = 1.0 / pow(E, fFogDistance * fogDensity);\r\n	}\r\n	else if (FOGMODE_EXP2 == vFogInfos.x)\r\n	{\r\n		fogCoeff = 1.0 / pow(E, fFogDistance * fFogDistance * fogDensity * fogDensity);\r\n	}\r\n\r\n	return clamp(fogCoeff, 0.0, 1.0);\r\n}\r\n#endif\r\n\r\n// Constants\r\nconst float e = 2.71828182845904523536028747135266249775724709369995957;\r\nconst float pi = 3.141592653589793238462643383279502884197169;\r\nconst float n = 1.0003;\r\nconst float N = 2.545E25;\r\nconst float pn = 0.035;\r\n\r\nconst vec3 lambda = vec3(680E-9, 550E-9, 450E-9);\r\n\r\nconst vec3 K = vec3(0.686, 0.678, 0.666);\r\nconst float v = 4.0;\r\n\r\nconst float rayleighZenithLength = 8.4E3;\r\nconst float mieZenithLength = 1.25E3;\r\nconst vec3 up = vec3(0.0, 1.0, 0.0);\r\n\r\nconst float EE = 1000.0;\r\nconst float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\r\n\r\nconst float cutoffAngle = pi/1.95;\r\nconst float steepness = 1.5;\r\n\r\nvec3 totalRayleigh(vec3 lambda)\r\n{\r\n	return (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn));\r\n}\r\n\r\nvec3 simplifiedRayleigh()\r\n{\r\n	return 0.0005 / vec3(94, 40, 18);\r\n}\r\n\r\nfloat rayleighPhase(float cosTheta)\r\n{	 \r\n	return (3.0 / (16.0*pi)) * (1.0 + pow(cosTheta, 2.0));\r\n}\r\n\r\nvec3 totalMie(vec3 lambda, vec3 K, float T)\r\n{\r\n	float c = (0.2 * T ) * 10E-18;\r\n	return 0.434 * c * pi * pow((2.0 * pi) / lambda, vec3(v - 2.0)) * K;\r\n}\r\n\r\nfloat hgPhase(float cosTheta, float g)\r\n{\r\n	return (1.0 / (4.0*pi)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));\r\n}\r\n\r\nfloat sunIntensity(float zenithAngleCos)\r\n{\r\n	return EE * max(0.0, 1.0 - exp(-((cutoffAngle - acos(zenithAngleCos))/steepness)));\r\n}\r\n\r\nfloat A = 0.15;\r\nfloat B = 0.50;\r\nfloat C = 0.10;\r\nfloat D = 0.20;\r\nfloat E = 0.02;\r\nfloat F = 0.30;\r\nfloat W = 1000.0;\r\n\r\nvec3 Uncharted2Tonemap(vec3 x)\r\n{\r\n	return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\r\n}\r\n\r\nvoid main(void) {\r\n	// Clip plane\r\n#ifdef CLIPPLANE\r\n	if (fClipDistance > 0.0)\r\n		discard;\r\n#endif\r\n\r\n	/**\r\n	*--------------------------------------------------------------------------------------------------\r\n	* Sky Color\r\n	*--------------------------------------------------------------------------------------------------\r\n	*/\r\n	const vec3 cameraPos = vec3(0.0, 0.0, 0.0);\r\n	float sunfade = 1.0 - clamp(1.0 - exp((sunPosition.y / 450000.0)), 0.0, 1.0);\r\n	float rayleighCoefficient = rayleigh - (1.0 * (1.0 - sunfade));\r\n	vec3 sunDirection = normalize(sunPosition);\r\n	float sunE = sunIntensity(dot(sunDirection, up));\r\n	vec3 betaR = simplifiedRayleigh() * rayleighCoefficient;\r\n	vec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;\r\n	float zenithAngle = acos(max(0.0, dot(up, normalize(vPositionW - cameraPos))));\r\n	float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));\r\n	float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));\r\n	vec3 Fex = exp(-(betaR * sR + betaM * sM));\r\n	float cosTheta = dot(normalize(vPositionW - cameraPos), sunDirection);\r\n	float rPhase = rayleighPhase(cosTheta*0.5+0.5);\r\n	vec3 betaRTheta = betaR * rPhase;\r\n	float mPhase = hgPhase(cosTheta, mieDirectionalG);\r\n	vec3 betaMTheta = betaM * mPhase;\r\n	\r\n	vec3 Lin = pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex),vec3(1.5));\r\n	Lin *= mix(vec3(1.0), pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex, vec3(1.0 / 2.0)), clamp(pow(1.0-dot(up, sunDirection), 5.0), 0.0, 1.0));\r\n\r\n	vec3 direction = normalize(vPositionW - cameraPos);\r\n	float theta = acos(direction.y);\r\n	float phi = atan(direction.z, direction.x);\r\n	vec2 uv = vec2(phi, theta) / vec2(2.0 * pi, pi) + vec2(0.5, 0.0);\r\n	vec3 L0 = vec3(0.1) * Fex;\r\n	\r\n	float sundisk = smoothstep(sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta);\r\n	L0 += (sunE * 19000.0 * Fex) * sundisk;\r\n	\r\n	vec3 whiteScale = 1.0/Uncharted2Tonemap(vec3(W));\r\n	vec3 texColor = (Lin+L0);   \r\n	texColor *= 0.04 ;\r\n	texColor += vec3(0.0,0.001,0.0025)*0.3;\r\n\r\n	float g_fMaxLuminance = 1.0;\r\n	float fLumScaled = 0.1 / luminance;     \r\n	float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (g_fMaxLuminance * g_fMaxLuminance)))) / (1.0 + fLumScaled); \r\n\r\n	float ExposureBias = fLumCompressed;\r\n\r\n	vec3 curr = Uncharted2Tonemap((log2(2.0/pow(luminance,4.0)))*texColor);\r\n	vec3 skyColor = curr * whiteScale;\r\n\r\n	vec3 retColor = pow(skyColor,vec3(1.0/(1.2+(1.2*sunfade))));\r\n	\r\n	vec4 baseColor = vec4(retColor, 1.0);\r\n	/**\r\n	*--------------------------------------------------------------------------------------------------\r\n	* Sky Color\r\n	*--------------------------------------------------------------------------------------------------\r\n	*/\r\n	\r\n	// Alpha\r\n	float alpha = 1.0;\r\n\r\n#ifdef VERTEXCOLOR\r\n	baseColor.rgb *= vColor.rgb;\r\n#endif\r\n\r\n	// Lighting\r\n	vec3 diffuseBase = vec3(1.0, 1.0, 1.0);\r\n\r\n#ifdef VERTEXALPHA\r\n	alpha *= vColor.a;\r\n#endif\r\n\r\n	// Composition\r\n	vec4 color = vec4(baseColor.rgb, alpha);\r\n\r\n#ifdef FOG\r\n	float fog = CalcFogFactor();\r\n	color.rgb = fog * color.rgb + (1.0 - fog) * vFogColor;\r\n#endif\r\n\r\n	gl_FragColor = color;\r\n}";